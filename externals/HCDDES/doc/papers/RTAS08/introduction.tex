Constructing embedded software for applications that require high confidence in the software's functionality, reliability, and safety is hard. We have to not only design, implement, and verify the software, but also need to provide arguments for certifying its behavior. The problems of embedded software development are well-known \cite{HenSif:2006}, yet industrial practice falls short of these expectations. 

Existing development practices often fall into two categories. In one category we find the use of a model-based development environment (which typically includes a graphical model building tool supporting block-diagram and statechart-like notations, a simulation engine, and a code generator), which allows programming and the generation of code for the embedded system. The two most frequently used such environments are Simulink/Stateflow of Mathworks, and Matrix-X of National Instruments. In these toolchains the prevailing paradigm for development is to use dataflow diagrams and statecharts to specify code functions and perform simulations of the expected environment, then to generate code for the 'controller' part of the models, and finally, to deploy that code on some real-time OS platform. The second category of software develpment uses a UML-oriented modeling tool, possibly a code generator, as well as an interactive development environment (IDE). Examples here include numerous products from UML tool and IDE vendors. The prevailing paradigm here is to use the UML tool to create models of the software, optionally using the UML code generator to translate the models into an object-oriented language, then debug and deploy the code using the IDE. 

Both of these approaches have shortcomings. For the first case, advanced software engineering concepts are rarely used, platforms and their properties are rarely captured in models, and non-functional properties (e.g. fault-tolerance) are not explicit and very hard to reason about, just to mention a few. For the second, UML does not seem to be suitable for modeling the environment of the system (i.e. the physical dynamics of the 'plant'); there is often a disconnect between the models and the code as deployed, and the same problem occurs with non-functional properties. In both cases, support for verification and certification of the end-product is often missing. 

Accordingly, we need tools and techniques that could address the wide variety of problems arising in embedded software development. Because of the great variability of embedded software (ranging, for instance, from MP3 players to avionics systems to distributed air-traffic control) and the continuous evolution of the available tools, we believe a single tool will never be sufficient, i.e. we need to think in toolchains. These toolchains should contain elements that address the various expectations of embedded system developers and organizations that are interested in the quality of the results. 

This paper introduces the conceptual design of such a toolchain and describes some early results in its construction. The next section describes the envisioned development flow and the expected toolchain elements, and the subsequent sections describe the individual elements already constructed or being developed. The paper concludes with a comparison to other toolchains and a discussion of future work. 


