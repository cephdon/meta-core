\section{Background}
\label{section:background}

\subsection{ESMoL Component Model}

As the ESMoL language structure is documented elsewhere\cite{modeling:esmol_tr}, we only cover details relevant to incremental cycle checking.  ESMoL is a graphical
modeling language which allows designers to use Simulink diagrams as 
synchronous software function specifications (where the execution of each 
block is equivalent to a single bounded-time blocking C language call).  These
specifications are used to create blocks representing ESMoL component types.   
ESMoL components have message structures as interfaces, and the type
specification includes a map between Simulink signal ports and the 
fields of the input and output message structures.  The messages represent C structures, and the map graphically captures the marshaling of Simulink data to those structures.

Once software component types and interfaces have been specified, ESMoL 
designers instantiate those components into a distributed 
deployment model.  ESMoL allows the separate specification of the logical
data flow, the mapping of component instances to hardware, timing
information for tasks executing those components, and timing for messages sent
over a time-triggered communication bus.  Code generated from the models
conforms to an API for time-triggered execution.  A portable virtual machine
implementation of the API allows execution in simulation, hardware-in-the-loop,
and fully deployed configurations\cite{modeling:truetime}.

ESMoL deliberately provides an unusual degree of freedom in creating 
software component types.  A designer can include Simulink references from
any part of an imported dataflow model, and instantiate them any number of 
times within the type definitions. The partition of functions into ESMoL types 
allows the designer to control the granularity of functions assigned to 
distributed tasks.  Tasks can distribute functions over a time-triggered 
network for performance, or replicate similar functions for fault mitigation.  
This level of flexibility requires automatic type-checking to ensure 
compatibility for chosen configurations.  Beyond interface type-checking, 
structural well-formedness problems arise during assembly such as zero-delay 
cycles.   Model analysis must ensure well-formedness.

\subsection{Cycle Enumeration}

To implement cycle enumeration we use the algorithm Johnson proposed as an 
extension of Tiernan's algorithm \cite{cycles:tiernan} for 
enumerating elementary cycles in a directed graph\cite{cycles:johnson75}.  Both
approaches rely on depth-first search with backtracking, but Johnson's method
marks vertices on elementary paths already considered to eliminate fruitless
searching, unmarking them only when a cycle is found.  Johnson's algorithm is 
polynomial ($O((n + e)c)$, where $n$, $e$, and $c$ are the sizes of the 
vertex, edge, and cycle set, respectively), and is still considered the best 
available general cycle enumeration method\cite{cycles:mateti76}.  We created
an implementation of Johnson's algorithm in C++ using the Boost Graph library
\cite{tools:boostgraph}.

\subsection{Hierarchical Graphs}

For formally describing our incremental approach we use the algebra of
hierarchical graphs introduced by Bruni et al\cite{graphs:hier_algebra}.
We repeat here their first definition: a \emph{design} is a term of
sort $\mathcal{D}$ generated by

\begin{align}
\label{eq:hiergraphs}
\mathbb{D} &::= L_{\bar{x}} [ \mathbb{G} ]  \\
\mathbb{G} &::= \mathbf{0} \mid x \mid l<\bar{x}> \mid \mathbb{G} \parallel \mathbb{G} \mid  (\nu \bar{x})\mathbb{G} \mid \mathbb{D} <\bar{x}>  \nonumber
\end{align}

Here term $\mathbb{G}$ represents a hierarchical directed graph, $\mathbb{D}$ 
is an edge-encapsulated hierarchical graph, $x$ is a vertex,
$\bar{x}$ is a list of vertices in $\mathbb{G}$ (for which 
$\lfloor \bar{x} \rfloor$ is the corresponding set), $l \in \mathcal{E}$ 
(edge labels of $\mathbb{G}$, where edges can have n-ary connectivity ), 
$L_{\bar{x}} \in \mathcal{D}$ ($\mathcal{D}$ are
the design labels of $\mathbb{G}$ and $\bar{x}$ 
are interface vertices in $L$),
$\mathbb{G} \parallel \mathbb{G}$ is parallel graph composition which merges 
vertices with common names, $(\nu \bar{x}) \mathbb{G}$ restricts the interface 
of graph $\mathbb{G}$ to exclude vertices in $\lfloor \bar{x} \rfloor$,
and the notation $\mathbb{D} <\bar{x}>$ maps the vertices from the 
interface of $\mathbb{D}$ to the vertices listed in $\bar{x}$ (renaming
vertices internal to the design for the external interface). Finally
$\llbracket \mathbb{G} \rrbracket$ indicates the graph corresponding
to the term $\mathbb{G}$.

Intuitively, Equation \ref{eq:hiergraphs} is a grammar defining a simple textual notation for describing typed hierarchical graphs.  Within the formalism we can compare equivalence between algebraic descriptions of two hierarchical graphs using reduction rules and a normal form (as in Bruni\cite{graphs:hier_algebra}), though equivalence is beyond the scope of this publication. The algebraic properties are for future use. The other main attraction of this particular formalism is that the notation allows the definition of interface symbols which correspond easily to port objects in a dataflow language, and the hiding of those interfaces as we specialize types.  The notation is a compact shorthand for much larger diagrams or mathematical descriptions. The design sorts $\mathbb{D}$ correspond to composite types in our dataflow language (which may have children), and the edge-encapsulation means that graph edges are not visible outside the component that contains them.   The specification for a composite element is $L_{\bar{x}} [\mathbb{G} ]$, which means that an element of the sort $\mathbb{D}$ has type $L$ with interface vertices in the list $\bar{x}$ and a corresponding internal graph $\mathbb{G}$ defining the details of the component. The internal graph may also include subcomponents. Gluing of subgraphs (contained by the design sorts $\mathbb{D}$) only occurs at common vertices.  When a composite element from $\mathbb{D}$ of a particular type is used as a child element to form a  larger (parent) graph, vertices from the child are possibly renamed in the parent, hence the notation $\mathbb{D} <\bar{x}> $.  In a parallel composition, vertices with the same name $x$ are glued together.

Note that the term \emph{design} in the formalism is synonymous with the concept of a \emph{component} in a modeling hierarchy, with a type and a set of interface vertices. Unfortunately in the realm of graph theory the term \emph{component} has a different meaning.  The term-algebraic graph formalism also includes a definition of \emph{well-typedness}, where types defined on the vertex set are only connected if their types are compatible.  Finally the authors define \emph{well-formedness} for hierarchical graphs which includes \emph{well-typedness} as a condition.  We do not define the entire formalism here, only enough to understand the essence of the 
connections between the terms and the graphs that they represent.

