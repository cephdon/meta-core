/* GenCyPhy2SFC.cpp generated on Mon Feb 11 16:44:06 2013
 */

#include "GenCyber2SFC.h"
#include <UmlExt.h>
#include "GReATSort.h"
#include "RTTGenerator.h"
#include "Cyber2SFC-gr_cmptempl.h"
#include "CGLog.h"

void TL_0::operator()( const Packets_t& rootFolders_1, const Packets_t& rootStates_3, const Packets_t& projects_5)
{
#ifdef PRINT_INFO
	printLog( "TL_0" );
#endif
	if( ( !rootFolders_1.empty())&& ( !rootStates_3.empty())&& ( !projects_5.empty()))
		callGetProject_2e14( rootFolders_1, rootStates_3, projects_5);
}

void TL_0::callGetProject_2e14( const Packets_t& rootFolders_2dc0, const Packets_t& states_2dc3, const Packets_t& projects_2dc6)
{
	Packets_t rootFolders_2dc2;
	Packets_t states_2dc5;
	Packets_t projects_2dc8;
	GetProject_2dbf getProject_2dbf;
	getProject_2dbf( rootFolders_2dc0, states_2dc3, projects_2dc6, rootFolders_2dc2, states_2dc5, projects_2dc8);
	if( ( !rootFolders_2dc2.empty())&& ( !states_2dc5.empty())&& ( !projects_2dc8.empty()))
		callCreateTypes_2e18( rootFolders_2dc2, states_2dc5, projects_2dc8);
}

void TL_0::callCreateTypes_2e18( const Packets_t& rootFolders_2808, const Packets_t& states_280a, const Packets_t& projects_280c)
{
	Packets_t states_280e;
	Packets_t projects_280f;
	CreateTypes_2807 createTypes_2807;
	createTypes_2807( rootFolders_2808, states_280a, projects_280c, states_280e, projects_280f);
	if( ( !states_280e.empty())&& ( !projects_280f.empty()))
		callSetFileName_2e1c( states_280e, projects_280f);
}

void TL_0::callSetFileName_2e1c( const Packets_t& states_2def, const Packets_t& projects_2df3)
{
	Packets_t states_2df1;
	Packets_t programs_2df2;
	SetFileName_2dee setFileName_2dee;
	setFileName_2dee( states_2def, projects_2df3, states_2df1, programs_2df2);
	if( ( !states_2df1.empty())&& ( !programs_2df2.empty()))
		callProcessProgram_2e1f( states_2df1, programs_2df2);
}

void TL_0::callProcessProgram_2e1f( const Packets_t& states_8, const Packets_t& programs_a)
{
	ProcessProgram_7 processProgram_7;
	processProgram_7( states_8, programs_a);
}

void ProcessProgram_7::operator()( const Packets_t& states_8, const Packets_t& programs_a)
{
#ifdef PRINT_INFO
	printLog( "ProcessProgram_7" );
#endif
	for( Packets_t::const_iterator itstate_d= states_8.begin(), itprogram_14= programs_a.begin(); itstate_d!= states_8.end(), itprogram_14!= programs_a.end(); ++itstate_d, ++itprogram_14)
	{
		bool isUnique= isInputUnique( *itstate_d, *itprogram_14);
		if( !isUnique)
			continue;
		Packets_t onestate_11( 1, *itstate_d);
		Packets_t oneprogram_18( 1, *itprogram_14);
		executeOne( onestate_11, oneprogram_18);
	}
}

void ProcessProgram_7::executeOne( const Packets_t& states_8, const Packets_t& programs_a)
{
	if( ( !states_8.empty())&& ( !programs_a.empty()))
		callClearTables_27e6( states_8, programs_a);
}

bool ProcessProgram_7::isInputUnique( const Udm::Object& state_e, const Udm::Object& program_15)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_10= _state_c.begin(), itprogram_17= _program_13.begin(); itstate_10!= _state_c.end(), itprogram_17!= _program_13.end(); ++itstate_10, ++itprogram_17)
	{
		if( ( *itstate_10== state_e)&& ( *itprogram_17== program_15))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_c.push_back( state_e);
		_program_13.push_back( program_15);
	}
	return isUnique;
}

void ProcessProgram_7::callClearTables_27e6( const Packets_t& states_cbe, const Packets_t& programs_cc1)
{
	Packets_t states_cc0;
	Packets_t programs_cc3;
	ClearTables_cbd clearTables_cbd;
	clearTables_cbd( states_cbe, programs_cc1, states_cc0, programs_cc3);
	if( ( !states_cc0.empty())&& ( !programs_cc3.empty()))
		callCreateStateLabels_27e9( states_cc0, programs_cc3);
}

void ProcessProgram_7::callCreateStateLabels_27e9( const Packets_t& states_cdf, const Packets_t& programs_ce1)
{
	Packets_t states_ce3;
	Packets_t programs_ce4;
	CreateStateLabels_cde createStateLabels_cde;
	createStateLabels_cde( states_cdf, programs_ce1, states_ce3, programs_ce4);
	if( ( !states_ce3.empty())&& ( !programs_ce4.empty()))
		callCreateDEVars_27ec( states_ce3, programs_ce4);
}

void ProcessProgram_7::callCreateDEVars_27ec( const Packets_t& states_249c, const Packets_t& programs_249e)
{
	Packets_t states_24a0;
	Packets_t programs_24a1;
	CreateDEVars_249b createDEVars_249b;
	createDEVars_249b( states_249c, programs_249e, states_24a0, programs_24a1);
	if( ( !states_24a0.empty())&& ( !programs_24a1.empty()))
		callCreateFuncStateFunctions_27ef( states_24a0, programs_24a1);
}

void ProcessProgram_7::callCreateFuncStateFunctions_27ef( const Packets_t& states_efa, const Packets_t& programs_efc)
{
	Packets_t states_efe;
	Packets_t programs_eff;
	CreateFuncStateFunctions_ef9 createFuncStateFunctions_ef9;
	createFuncStateFunctions_ef9( states_efa, programs_efc, states_efe, programs_eff);
	if( ( !states_efe.empty())&& ( !programs_eff.empty()))
		callCreateFSFunctionBodies_27f2( states_efe, programs_eff);
}

void ProcessProgram_7::callCreateFSFunctionBodies_27f2( const Packets_t& states_51, const Packets_t& programs_53)
{
	Packets_t states_55;
	Packets_t programs_56;
	CreateFSFunctionBodies_50 createFSFunctionBodies_50;
	createFSFunctionBodies_50( states_51, programs_53, states_55, programs_56);
	if( ( !states_55.empty())&& ( !programs_56.empty()))
		callCreateFunctions_27f5( states_55, programs_56);
}

void ProcessProgram_7::callCreateFunctions_27f5( const Packets_t& states_245a, const Packets_t& programs_245c)
{
	Packets_t states_245e;
	Packets_t programs_245f;
	CreateFunctions_2459 createFunctions_2459;
	createFunctions_2459( states_245a, programs_245c, states_245e, programs_245f);
	if( ( !states_245e.empty())&& ( !programs_245f.empty()))
		callPopulateFunctions_27f8( states_245e, programs_245f);
}

void ProcessProgram_7::callPopulateFunctions_27f8( const Packets_t& states_1058, const Packets_t& programs_105a)
{
	Packets_t states_105c;
	Packets_t programs_105d;
	PopulateFunctions_1057 populateFunctions_1057;
	populateFunctions_1057( states_1058, programs_105a, states_105c, programs_105d);
	if( ( !states_105c.empty())&& ( !programs_105d.empty()))
		callCreateRootFunction_27fb( states_105c, programs_105d);
}

void ProcessProgram_7::callCreateRootFunction_27fb( const Packets_t& states_1f54, const Packets_t& programs_1f56)
{
	Packets_t states_1f58;
	Packets_t programs_1f59;
	CreateRootFunction_1f53 createRootFunction_1f53;
	createRootFunction_1f53( states_1f54, programs_1f56, states_1f58, programs_1f59);
	if( ( !states_1f58.empty())&& ( !programs_1f59.empty()))
		callCreateInitFunction_27fe( states_1f58, programs_1f59);
}

void ProcessProgram_7::callCreateInitFunction_27fe( const Packets_t& states_21fa, const Packets_t& programs_21fc)
{
	Packets_t states_21fe;
	Packets_t programs_21ff;
	CreateInitFunction_21f9 createInitFunction_21f9;
	createInitFunction_21f9( states_21fa, programs_21fc, states_21fe, programs_21ff);
	if( ( !states_21fe.empty())&& ( !programs_21ff.empty()))
		callCreateStatusFunction_2801( states_21fe, programs_21ff);
}

void ProcessProgram_7::callCreateStatusFunction_2801( const Packets_t& states_1b, const Packets_t& programs_1d)
{
	Packets_t states_1f;
	Packets_t programs_20;
	CreateStatusFunction_1a createStatusFunction_1a;
	createStatusFunction_1a( states_1b, programs_1d, states_1f, programs_20);
	if( ( !states_1f.empty())&& ( !programs_20.empty()))
		callMarkLegacy_2804( states_1f, programs_20);
}

void ProcessProgram_7::callMarkLegacy_2804( const Packets_t& states_243d, const Packets_t& programs_243f)
{
	MarkLegacy_243c markLegacy_243c;
	markLegacy_243c( states_243d, programs_243f);
}

void CreateStatusFunction_1a::operator()( const Packets_t& states_1b, const Packets_t& programs_1d, Packets_t& states_1f, Packets_t& programs_20)
{
#ifdef PRINT_INFO
	printLog( "CreateStatusFunction_1a" );
#endif
	_state_21= &states_1f;
	_program_22= &programs_20;
	if( ( !states_1b.empty())&& ( !programs_1d.empty()))
		callCreateStatusFunction_4d( states_1b, programs_1d);
	_state_21->insert( _state_21->end(), states_1b.begin(), states_1b.end());
	_program_22->insert( _program_22->end(), programs_1d.begin(), programs_1d.end());
}

void CreateStatusFunction_1a::callCreateStatusFunction_4d( const Packets_t& states_24, const Packets_t& programs_26)
{
	CreateStatusFunction_23 createStatusFunction_23;
	createStatusFunction_23( states_24, programs_26);
}

void CreateStatusFunction_23::operator()( const Packets_t& states_24, const Packets_t& programs_26)
{
#ifdef PRINT_INFO
	printLog( "CreateStatusFunction_23" );
#endif
	RTTGenerator::Instance()->generateRule(15, "CreateStatusFunction");
	processInputPackets( states_24, programs_26);
}

bool CreateStatusFunction_23::isInputUnique( const Udm::Object& state_2c, const Udm::Object& program_35)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_2e= _state_28.begin(), itProgram_37= _program_31.begin(); itState_2e!= _state_28.end(), itProgram_37!= _program_31.end(); ++itState_2e, ++itProgram_37)
	{
		if( ( *itState_2e== state_2c)&& ( *itProgram_37== program_35))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_28.push_back( state_2c);
		_program_31.push_back( program_35);
	}
	return isUnique;
}

bool CreateStatusFunction_23::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateStatusFunction_23::processInputPackets( const Packets_t& states_24, const Packets_t& programs_26)
{
	for( Packets_t::const_iterator itState_29= states_24.begin(), itProgram_32= programs_26.begin(); itState_29!= states_24.end(), itProgram_32!= programs_26.end(); ++itState_29, ++itProgram_32)
	{
		bool isUnique= isInputUnique( *itState_29, *itProgram_32);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_29, *itProgram_32);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateStatusFunction_23::patternMatcher( const Udm::Object& state_2a, const Udm::Object& program_33)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_2a.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_2f= CyberComposition::Simulink::State::Cast( state_2a);
		if( false== Uml::IsDerivedFrom( program_33.type(), SFC::Program::meta))
			continue;
		SFC::Program program_38= SFC::Program::Cast( program_33);
		set< SFC::Function> statuss_3a= state_2f.status();
		for( set< SFC::Function>::const_iterator itStatuss_3b= statuss_3a.begin(); itStatuss_3b!= statuss_3a.end(); ++itStatuss_3b)
		{
			SFC::Function currStatus_3c= *itStatuss_3b;
			set< SFC::Arg> args_3d= currStatus_3c.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itArg_3e= args_3d.begin(); itArg_3e!= args_3d.end(); ++itArg_3e)
			{
				SFC::Arg currArg_3f= *itArg_3e;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_43;
				if( !isValidBound(boundObjs_43, state_2f, true))
					continue;
				currMatch.state_44= state_2f;
				if( !isValidBound(boundObjs_43, program_38, true))
					continue;
				currMatch.program_45= program_38;
				if( !isValidBound(boundObjs_43, currArg_3f, false))
					continue;
				currMatch.arg_46= currArg_3f;
				if( !isValidBound(boundObjs_43, currStatus_3c, false))
					continue;
				currMatch.status_47= currStatus_3c;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void CreateStatusFunction_23::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function newgetStatus_48= SFC::Function::Create( currMatch.program_45, SFC::Program::meta_stmnt);
		SFC::Return newReturn_49= SFC::Return::Create( newgetStatus_48, SFC::Function::meta_stmnt);
		SFC::FunctionCall newFunctionCall_4a= SFC::FunctionCall::Create( newReturn_49, SFC::Return::meta_retexpr);
		SFC::ArgVal newArgVal_4b= SFC::ArgVal::Create( newFunctionCall_4a);
		SFC::Str newStr_4c= SFC::Str::Create( newArgVal_4b, SFC::ArgVal::meta_argexpr);
		SFC::Arg& Arg= currMatch.arg_46;
		SFC::ArgVal& ArgVal= newArgVal_4b;
		SFC::FunctionCall& FunctionCall= newFunctionCall_4a;
		SFC::Program& Program= currMatch.program_45;
		SFC::Return& Return= newReturn_49;
		CyberComposition::Simulink::State& State= currMatch.state_44;
		SFC::Function& Status= currMatch.status_47;
		SFC::Str& Str= newStr_4c;
		SFC::Function& getStatus= newgetStatus_48;
		{
getStatus.RefId() = Return.RefId() = Status.RefId();
};
		{
getStatus.name() = "getStatus";
getStatus.dt() = SFCTypesManager::getSingleton().getBasicType( "string" );
};
		{
__int64 statementCount = getStatus.statementCount();
Return.statementIndex() = statementCount++;
getStatus.statementCount() = statementCount;
};
		{
ArgVal.argIndex() = 0;
};
		{
Str.val() = "";
};
		{
__int64 statementCount = Program.statementCount();
getStatus.statementIndex() = statementCount++;
Program.statementCount() = statementCount;
};
		newFunctionCall_4a.callee()= currMatch.status_47;
		newArgVal_4b.arg()+= currMatch.arg_46;
	}
}

void CreateFSFunctionBodies_50::operator()( const Packets_t& states_51, const Packets_t& programs_53, Packets_t& states_55, Packets_t& programs_56)
{
#ifdef PRINT_INFO
	printLog( "CreateFSFunctionBodies_50" );
#endif
	_state_57= &states_55;
	_program_58= &programs_56;
	if( ( !states_51.empty())&& ( !programs_53.empty()))
		callPopulateGRFSFunction_cb4( states_51, programs_53);
	_state_57->insert( _state_57->end(), states_51.begin(), states_51.end());
	_program_58->insert( _program_58->end(), programs_53.begin(), programs_53.end());
}

void CreateFSFunctionBodies_50::callPopulateGRFSFunction_cb4( const Packets_t& states_5a, const Packets_t& programs_5c)
{
	Packets_t states_5e;
	Packets_t programs_5f;
	PopulateGRFSFunction_59 populateGRFSFunction_59;
	populateGRFSFunction_59( states_5a, programs_5c, states_5e, programs_5f);
	if( ( !states_5e.empty())&& ( !programs_5f.empty()))
		callPopulateEMFSFunction_cb7( states_5e, programs_5f);
}

void CreateFSFunctionBodies_50::callPopulateEMFSFunction_cb7( const Packets_t& states_c2f, const Packets_t& programs_c31)
{
	Packets_t states_c33;
	Packets_t programs_c34;
	PopulateEMFSFunction_c2e populateEMFSFunction_c2e;
	populateEMFSFunction_c2e( states_c2f, programs_c31, states_c33, programs_c34);
	if( ( !states_c33.empty())&& ( !programs_c34.empty()))
		callGetSubStates_cba( states_c33, programs_c34);
}

void CreateFSFunctionBodies_50::callGetSubStates_cba( const Packets_t& states_c8c, const Packets_t& parStmnts_c8f)
{
	Packets_t subStates_c8e;
	Packets_t parStmnts_c91;
	GetSubStates_c8b getSubStates_c8b;
	getSubStates_c8b( states_c8c, parStmnts_c8f, subStates_c8e, parStmnts_c91);
	if( ( !subStates_c8e.empty())&& ( !parStmnts_c91.empty()))
		callPopulateGRFSFunction_cb4( subStates_c8e, parStmnts_c91);
}

void PopulateGRFSFunction_59::operator()( const Packets_t& states_5a, const Packets_t& programs_5c, Packets_t& states_5e, Packets_t& programs_5f)
{
#ifdef PRINT_INFO
	printLog( "PopulateGRFSFunction_59" );
#endif
	_state_60= &states_5e;
	_program_61= &programs_5f;
	if( ( !states_5a.empty())&& ( !programs_5c.empty()))
		callGetGRFuncStateFunction_c21( states_5a, programs_5c);
	_state_60->insert( _state_60->end(), states_5a.begin(), states_5a.end());
	_program_61->insert( _program_61->end(), programs_5c.begin(), programs_5c.end());
}

void PopulateGRFSFunction_59::callGetGRFuncStateFunction_c21( const Packets_t& states_63, const Packets_t& programs_66)
{
	Packets_t states_65;
	Packets_t execs_68;
	GetGRFuncStateFunction_62 getGRFuncStateFunction_62;
	getGRFuncStateFunction_62( states_63, programs_66, states_65, execs_68);
	if( ( !states_65.empty())&& ( !execs_68.empty()))
		callTransStartMap_c24( states_65, execs_68);
}

void PopulateGRFSFunction_59::callTransStartMap_c24( const Packets_t& states_a08, const Packets_t& css_a0a)
{
	Packets_t states_a0c;
	Packets_t css_a0d;
	TransStartMap_a07 transStartMap_a07;
	transStartMap_a07( states_a08, css_a0a, states_a0c, css_a0d);
	if( ( !states_a0c.empty())&& ( !css_a0d.empty()))
		callDirectInFunction_c27( states_a0c, css_a0d);
}

void PopulateGRFSFunction_59::callDirectInFunction_c27( const Packets_t& states_94, const Packets_t& functions_97)
{
	Packets_t states_96;
	Packets_t functions_99;
	DirectInFunction_93 directInFunction_93;
	directInFunction_93( states_94, functions_97, states_96, functions_99);
	if( ( !states_96.empty())&& ( !functions_99.empty())&& ( !functions_99.empty()))
		callTransStartTransitions_c2a( states_96, functions_99, functions_99);
}

void PopulateGRFSFunction_59::callTransStartTransitions_c2a( const Packets_t& states_b2, const Packets_t& fcns_b4, const Packets_t& css_b6)
{
	TransStartTransitions_b1 transStartTransitions_b1;
	transStartTransitions_b1( states_b2, fcns_b4, css_b6);
}

void GetGRFuncStateFunction_62::operator()( const Packets_t& states_63, const Packets_t& programs_66, Packets_t& states_65, Packets_t& execs_68)
{
#ifdef PRINT_INFO
	printLog( "GetGRFuncStateFunction_62" );
#endif
	RTTGenerator::Instance()->generateRule(50, "GetGRFuncStateFunction");
	_state_69= &states_65;
	_exec_6a= &execs_68;
	processInputPackets( states_63, programs_66);
}

bool GetGRFuncStateFunction_62::isInputUnique( const Udm::Object& state_6f, const Udm::Object& program_78)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_71= _state_6b.begin(), itProgram_7a= _program_74.begin(); itState_71!= _state_6b.end(), itProgram_7a!= _program_74.end(); ++itState_71, ++itProgram_7a)
	{
		if( ( *itState_71== state_6f)&& ( *itProgram_7a== program_78))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_6b.push_back( state_6f);
		_program_74.push_back( program_78);
	}
	return isUnique;
}

bool GetGRFuncStateFunction_62::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool GetGRFuncStateFunction_62::isGuardTrue( SFC::Function& Exec, SFC::Program& Program, CyberComposition::Simulink::State& State, SFC::StateLabel& StateLabel)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( State.Decomposition() ) == "FUNC_STATE" &&
 static_cast< std::string >( State.Order() ) == "-1";;
	return Gz_guard;
}

void GetGRFuncStateFunction_62::processInputPackets( const Packets_t& states_63, const Packets_t& programs_66)
{
	for( Packets_t::const_iterator itState_6c= states_63.begin(), itProgram_75= programs_66.begin(); itState_6c!= states_63.end(), itProgram_75!= programs_66.end(); ++itState_6c, ++itProgram_75)
	{
		bool isUnique= isInputUnique( *itState_6c, *itProgram_75);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_6c, *itProgram_75);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetGRFuncStateFunction_62::patternMatcher( const Udm::Object& state_6d, const Udm::Object& program_76)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_6d.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_72= CyberComposition::Simulink::State::Cast( state_6d);
		if( false== Uml::IsDerivedFrom( program_76.type(), SFC::Program::meta))
			continue;
		SFC::Program program_7b= SFC::Program::Cast( program_76);
		set< SFC::Function> execs_7d= state_72.exec();
		for( set< SFC::Function>::const_iterator itExecs_7e= execs_7d.begin(); itExecs_7e!= execs_7d.end(); ++itExecs_7e)
		{
			SFC::Function currExec_7f= *itExecs_7e;
			set< SFC::StateLabel> stateLabels_80= state_72.src();
			for( set< SFC::StateLabel>::const_iterator itStateLabels_81= stateLabels_80.begin(); itStateLabels_81!= stateLabels_80.end(); ++itStateLabels_81)
			{
				SFC::StateLabel currStateLabel_82= *itStateLabels_81;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_86;
				if( !isValidBound(boundObjs_86, state_72, true))
					continue;
				currMatch.state_87= state_72;
				if( !isValidBound(boundObjs_86, program_7b, true))
					continue;
				currMatch.program_88= program_7b;
				if( !isValidBound(boundObjs_86, currStateLabel_82, false))
					continue;
				currMatch.stateLabel_89= currStateLabel_82;
				if( !isValidBound(boundObjs_86, currExec_7f, false))
					continue;
				currMatch.exec_8a= currExec_7f;
				bool Gz_guard= isGuardTrue( currMatch.exec_8a, currMatch.program_88, currMatch.state_87, currMatch.stateLabel_89);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetGRFuncStateFunction_62::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_87, currMatch.exec_8a);
	}
}

void GetGRFuncStateFunction_62::outputAppender( const CyberComposition::Simulink::State& state_8f, const SFC::Function& exec_91)
{
	_state_69->push_back( state_8f);
	_exec_6a->push_back( exec_91);
}

void DirectInFunction_93::operator()( const Packets_t& states_94, const Packets_t& functions_97, Packets_t& states_96, Packets_t& functions_99)
{
#ifdef PRINT_INFO
	printLog( "DirectInFunction_93" );
#endif
	RTTGenerator::Instance()->generateRule(57, "DirectInFunction");
	_state_9a= &states_96;
	_function_9b= &functions_99;
	processInputPackets( states_94, functions_97);
	forwardInputs( );
}

bool DirectInFunction_93::isInputUnique( const Udm::Object& state_a0, const Udm::Object& function_a9)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_a2= _state_9c.begin(), itFunction_ab= _function_a5.begin(); itState_a2!= _state_9c.end(), itFunction_ab!= _function_a5.end(); ++itState_a2, ++itFunction_ab)
	{
		if( ( *itState_a2== state_a0)&& ( *itFunction_ab== function_a9))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_9c.push_back( state_a0);
		_function_a5.push_back( function_a9);
	}
	return isUnique;
}

void DirectInFunction_93::processInputPackets( const Packets_t& states_94, const Packets_t& functions_97)
{
	for( Packets_t::const_iterator itState_9d= states_94.begin(), itFunction_a6= functions_97.begin(); itState_9d!= states_94.end(), itFunction_a6!= functions_97.end(); ++itState_9d, ++itFunction_a6)
	{
		bool isUnique= isInputUnique( *itState_9d, *itFunction_a6);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_9d, *itFunction_a6);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool DirectInFunction_93::patternMatcher( const Udm::Object& state_9e, const Udm::Object& function_a7)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_9e.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_a3= CyberComposition::Simulink::State::Cast( state_9e);
		if( false== Uml::IsDerivedFrom( function_a7.type(), SFC::Function::meta))
			continue;
		SFC::Function function_ac= SFC::Function::Cast( function_a7);
		Match currMatch;
		currMatch.state_af= state_a3;
		currMatch.function_b0= function_ac;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void DirectInFunction_93::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
	}
}

void DirectInFunction_93::forwardInputs()
{
	*_state_9a= _state_9c;
	*_function_9b= _function_a5;
}

void TransStartTransitions_b1::operator()( const Packets_t& states_b2, const Packets_t& fcns_b4, const Packets_t& css_b6)
{
#ifdef PRINT_INFO
	printLog( "TransStartTransitions_b1" );
#endif
	if( ( !states_b2.empty())&& ( !fcns_b4.empty())&& ( !css_b6.empty()))
		callInitTCVarLoop_9fa( states_b2, fcns_b4, css_b6);
}

void TransStartTransitions_b1::callInitTCVarLoop_9fa( const Packets_t& states_f3, const Packets_t& functions_f6, const Packets_t& compoundStatements_f9)
{
	Packets_t states_f5;
	Packets_t functions_f8;
	Packets_t conditionalGroups_fb;
	InitTCVarLoop_f2 initTCVarLoop_f2;
	initTCVarLoop_f2( states_f3, functions_f6, compoundStatements_f9, states_f5, functions_f8, conditionalGroups_fb);
	if( ( !states_f5.empty())&& ( !functions_f8.empty())&& ( !conditionalGroups_fb.empty()))
		callGetStartTC_9fe( states_f5, functions_f8, conditionalGroups_fb);
}

void TransStartTransitions_b1::callGetStartTC_9fe( const Packets_t& states_b9, const Packets_t& functions_bd, const Packets_t& conditionalGroups_c0)
{
	Packets_t states_bb;
	Packets_t transStarts_bc;
	Packets_t functions_bf;
	Packets_t conditionalGroups_c2;
	GetStartTC_b8 getStartTC_b8;
	getStartTC_b8( states_b9, functions_bd, conditionalGroups_c0, states_bb, transStarts_bc, functions_bf, conditionalGroups_c2);
	if( ( !states_bb.empty())&& ( !transStarts_bc.empty())&& ( !functions_bf.empty())&& ( !conditionalGroups_c2.empty()))
		callEnterTransConnectorRecurse_a02( states_bb, transStarts_bc, functions_bf, conditionalGroups_c2);
}

void TransStartTransitions_b1::callEnterTransConnectorRecurse_a02( const Packets_t& states_137, const Packets_t& tcs_139, const Packets_t& fcns_13b, const Packets_t& cgs_13d)
{
	EnterTransConnectorRecurse_136 enterTransConnectorRecurse_136;
	enterTransConnectorRecurse_136( states_137, tcs_139, fcns_13b, cgs_13d);
}

void GetStartTC_b8::operator()( const Packets_t& states_b9, const Packets_t& functions_bd, const Packets_t& conditionalGroups_c0, Packets_t& states_bb, Packets_t& transStarts_bc, Packets_t& functions_bf, Packets_t& conditionalGroups_c2)
{
#ifdef PRINT_INFO
	printLog( "GetStartTC_b8" );
#endif
	RTTGenerator::Instance()->generateRule(690, "GetStartTC");
	_state_c3= &states_bb;
	_transStart_c4= &transStarts_bc;
	_function_c5= &functions_bf;
	_conditionalGroup_c6= &conditionalGroups_c2;
	processInputPackets( states_b9, functions_bd, conditionalGroups_c0);
}

bool GetStartTC_b8::isInputUnique( const Udm::Object& state_cb, const Udm::Object& function_d4, const Udm::Object& conditionalGroup_dd)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_cd= _state_c7.begin(), itFunction_d6= _function_d0.begin(), itConditionalGroup_df= _conditionalGroup_d9.begin(); itState_cd!= _state_c7.end(), itFunction_d6!= _function_d0.end(), itConditionalGroup_df!= _conditionalGroup_d9.end(); ++itState_cd, ++itFunction_d6, ++itConditionalGroup_df)
	{
		if( ( *itState_cd== state_cb)&& ( *itFunction_d6== function_d4)&& ( *itConditionalGroup_df== conditionalGroup_dd))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_c7.push_back( state_cb);
		_function_d0.push_back( function_d4);
		_conditionalGroup_d9.push_back( conditionalGroup_dd);
	}
	return isUnique;
}

void GetStartTC_b8::processInputPackets( const Packets_t& states_b9, const Packets_t& functions_bd, const Packets_t& conditionalGroups_c0)
{
	for( Packets_t::const_iterator itState_c8= states_b9.begin(), itFunction_d1= functions_bd.begin(), itConditionalGroup_da= conditionalGroups_c0.begin(); itState_c8!= states_b9.end(), itFunction_d1!= functions_bd.end(), itConditionalGroup_da!= conditionalGroups_c0.end(); ++itState_c8, ++itFunction_d1, ++itConditionalGroup_da)
	{
		bool isUnique= isInputUnique( *itState_c8, *itFunction_d1, *itConditionalGroup_da);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_c8, *itFunction_d1, *itConditionalGroup_da);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetStartTC_b8::patternMatcher( const Udm::Object& state_c9, const Udm::Object& function_d2, const Udm::Object& conditionalGroup_db)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_c9.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_ce= CyberComposition::Simulink::State::Cast( state_c9);
		if( false== Uml::IsDerivedFrom( function_d2.type(), SFC::Function::meta))
			continue;
		SFC::Function function_d7= SFC::Function::Cast( function_d2);
		if( false== Uml::IsDerivedFrom( conditionalGroup_db.type(), SFC::ConditionalGroup::meta))
			continue;
		SFC::ConditionalGroup conditionalGroup_e0= SFC::ConditionalGroup::Cast( conditionalGroup_db);
		set< CyberComposition::Simulink::TransStart> transStarts_e2= state_ce.TransStart_kind_children();
		for( set< CyberComposition::Simulink::TransStart>::const_iterator itTransStart_e3= transStarts_e2.begin(); itTransStart_e3!= transStarts_e2.end(); ++itTransStart_e3)
		{
			CyberComposition::Simulink::TransStart currTransStart_e4= *itTransStart_e3;
			Match currMatch;
			currMatch.state_e6= state_ce;
			currMatch.function_e7= function_d7;
			currMatch.conditionalGroup_e8= conditionalGroup_e0;
			currMatch.transStart_e9= currTransStart_e4;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetStartTC_b8::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_e6, currMatch.transStart_e9, currMatch.function_e7, currMatch.conditionalGroup_e8);
	}
}

void GetStartTC_b8::outputAppender( const CyberComposition::Simulink::State& state_ea, const CyberComposition::Simulink::TransStart& transStart_ec, const SFC::Function& function_ee, const SFC::ConditionalGroup& conditionalGroup_f0)
{
	_state_c3->push_back( state_ea);
	_transStart_c4->push_back( transStart_ec);
	_function_c5->push_back( function_ee);
	_conditionalGroup_c6->push_back( conditionalGroup_f0);
}

void InitTCVarLoop_f2::operator()( const Packets_t& states_f3, const Packets_t& functions_f6, const Packets_t& compoundStatements_f9, Packets_t& states_f5, Packets_t& functions_f8, Packets_t& conditionalGroups_fb)
{
#ifdef PRINT_INFO
	printLog( "InitTCVarLoop_f2" );
#endif
	RTTGenerator::Instance()->generateRule(826, "InitTCVarLoop");
	_state_fc= &states_f5;
	_function_fd= &functions_f8;
	_conditionalGroup_fe= &conditionalGroups_fb;
	processInputPackets( states_f3, functions_f6, compoundStatements_f9);
}

bool InitTCVarLoop_f2::isInputUnique( const Udm::Object& state_103, const Udm::Object& function_10c, const Udm::Object& compoundStatement_115)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_105= _state_ff.begin(), itFunction_10e= _function_108.begin(), itCompoundStatement_117= _compoundStatement_111.begin(); itState_105!= _state_ff.end(), itFunction_10e!= _function_108.end(), itCompoundStatement_117!= _compoundStatement_111.end(); ++itState_105, ++itFunction_10e, ++itCompoundStatement_117)
	{
		if( ( *itState_105== state_103)&& ( *itFunction_10e== function_10c)&& ( *itCompoundStatement_117== compoundStatement_115))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_ff.push_back( state_103);
		_function_108.push_back( function_10c);
		_compoundStatement_111.push_back( compoundStatement_115);
	}
	return isUnique;
}

bool InitTCVarLoop_f2::isGuardTrue( SFC::CompoundStatement& CompoundStatement, SFC::Function& Function, CyberComposition::Simulink::State& State, SFC::LocalVar& TCVar)
{
	bool Gz_guard= false;
	return static_cast< std::string >( TCVar.name() ) == "_TCVar_";;
	return Gz_guard;
}

void InitTCVarLoop_f2::processInputPackets( const Packets_t& states_f3, const Packets_t& functions_f6, const Packets_t& compoundStatements_f9)
{
	for( Packets_t::const_iterator itState_100= states_f3.begin(), itFunction_109= functions_f6.begin(), itCompoundStatement_112= compoundStatements_f9.begin(); itState_100!= states_f3.end(), itFunction_109!= functions_f6.end(), itCompoundStatement_112!= compoundStatements_f9.end(); ++itState_100, ++itFunction_109, ++itCompoundStatement_112)
	{
		bool isUnique= isInputUnique( *itState_100, *itFunction_109, *itCompoundStatement_112);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_100, *itFunction_109, *itCompoundStatement_112);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InitTCVarLoop_f2::patternMatcher( const Udm::Object& state_101, const Udm::Object& function_10a, const Udm::Object& compoundStatement_113)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_101.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_106= CyberComposition::Simulink::State::Cast( state_101);
		if( false== Uml::IsDerivedFrom( function_10a.type(), SFC::Function::meta))
			continue;
		SFC::Function function_10f= SFC::Function::Cast( function_10a);
		if( false== Uml::IsDerivedFrom( compoundStatement_113.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_118= SFC::CompoundStatement::Cast( compoundStatement_113);
		set< SFC::LocalVar> tCVars_11a= function_10f.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itTCVar_11b= tCVars_11a.begin(); itTCVar_11b!= tCVars_11a.end(); ++itTCVar_11b)
		{
			SFC::LocalVar currTCVar_11c= *itTCVar_11b;
			Match currMatch;
			currMatch.state_11e= state_106;
			currMatch.function_11f= function_10f;
			currMatch.compoundStatement_120= compoundStatement_118;
			currMatch.tCVar_121= currTCVar_11c;
			bool Gz_guard= isGuardTrue( currMatch.compoundStatement_120, currMatch.function_11f, currMatch.state_11e, currMatch.tCVar_121);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void InitTCVarLoop_f2::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::IterativeBlock newIterativeBlock_126= SFC::IterativeBlock::Create( currMatch.compoundStatement_120, SFC::CompoundStatement::meta_stmnt);
		SFC::ConditionalGroup newConditionalGroup_127= SFC::ConditionalGroup::Create( newIterativeBlock_126, SFC::IterativeBlock::meta_stmnt);
		SFC::UserCode newInitTCVar_128= SFC::UserCode::Create( currMatch.compoundStatement_120, SFC::CompoundStatement::meta_stmnt);
		SFC::BinaryExprs newAssignTCVar_129= SFC::BinaryExprs::Create( newInitTCVar_128, SFC::UserCode::meta_codeexpr);
		SFC::Int newZero_12a= SFC::Int::Create( newAssignTCVar_129, SFC::BinaryExprs::meta_rightexpr);
		SFC::UserCode newUserCode_12b= SFC::UserCode::Create( newIterativeBlock_126, SFC::IterativeBlock::meta_cond);
		SFC::ArgDeclRef newAssignTCArgDeclRef_12c= SFC::ArgDeclRef::Create( newAssignTCVar_129, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newNotEqualTo_12d= SFC::BinaryExprs::Create( newUserCode_12b, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newEqualsTCArgDeclRef_12e= SFC::ArgDeclRef::Create( newNotEqualTo_12d, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newNegOne_12f= SFC::Int::Create( newNotEqualTo_12d, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef& AssignTCArgDeclRef= newAssignTCArgDeclRef_12c;
		SFC::BinaryExprs& AssignTCVar= newAssignTCVar_129;
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_120;
		SFC::ConditionalGroup& ConditionalGroup= newConditionalGroup_127;
		SFC::ArgDeclRef& EqualsTCArgDeclRef= newEqualsTCArgDeclRef_12e;
		SFC::Function& Function= currMatch.function_11f;
		SFC::UserCode& InitTCVar= newInitTCVar_128;
		SFC::IterativeBlock& IterativeBlock= newIterativeBlock_126;
		SFC::Int& NegOne= newNegOne_12f;
		SFC::BinaryExprs& NotEqualTo= newNotEqualTo_12d;
		CyberComposition::Simulink::State& State= currMatch.state_11e;
		SFC::LocalVar& TCVar= currMatch.tCVar_121;
		SFC::UserCode& UserCode= newUserCode_12b;
		SFC::Int& Zero= newZero_12a;
		{
__int64 statementCount = IterativeBlock.statementCount();
ConditionalGroup.statementIndex() = statementCount++;
IterativeBlock.statementCount() = statementCount;
};
		{
AssignTCVar.op() = "=";
};
		{
NotEqualTo.op() = "!=";
};
		{
NegOne.val() = -1;
};
		{
__int64 statementCount = CompoundStatement.statementCount();
InitTCVar.statementIndex() = statementCount++;
IterativeBlock.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		{
Zero.val() = 0;
};
		{
InitTCVar.RefId() = IterativeBlock.RefId() = ConditionalGroup.RefId() = UserCode.RefId() = CompoundStatement.RefId();
};
		newAssignTCArgDeclRef_12c.argdecl()= currMatch.tCVar_121;
		newEqualsTCArgDeclRef_12e.argdecl()= currMatch.tCVar_121;
		outputAppender( currMatch.state_11e, currMatch.function_11f, newConditionalGroup_127);
	}
}

void InitTCVarLoop_f2::outputAppender( const CyberComposition::Simulink::State& state_130, const SFC::Function& function_132, const SFC::ConditionalGroup& conditionalGroup_134)
{
	_state_fc->push_back( state_130);
	_function_fd->push_back( function_132);
	_conditionalGroup_fe->push_back( conditionalGroup_134);
}

void EnterTransConnectorRecurse_136::operator()( const Packets_t& states_137, const Packets_t& tcs_139, const Packets_t& fcns_13b, const Packets_t& cgs_13d)
{
#ifdef PRINT_INFO
	printLog( "EnterTransConnectorRecurse_136" );
#endif
	for( Packets_t::const_iterator itstate_140= states_137.begin(), ittc_147= tcs_139.begin(), itfcn_14e= fcns_13b.begin(), itcg_155= cgs_13d.begin(); itstate_140!= states_137.end(), ittc_147!= tcs_139.end(), itfcn_14e!= fcns_13b.end(), itcg_155!= cgs_13d.end(); ++itstate_140, ++ittc_147, ++itfcn_14e, ++itcg_155)
	{
		bool isUnique= isInputUnique( *itstate_140, *ittc_147, *itfcn_14e, *itcg_155);
		if( !isUnique)
			continue;
		Packets_t onestate_144( 1, *itstate_140);
		Packets_t onetc_14b( 1, *ittc_147);
		Packets_t onefcn_152( 1, *itfcn_14e);
		Packets_t onecg_159( 1, *itcg_155);
		executeOne( onestate_144, onetc_14b, onefcn_152, onecg_159);
	}
}

void EnterTransConnectorRecurse_136::executeOne( const Packets_t& states_137, const Packets_t& tcs_139, const Packets_t& fcns_13b, const Packets_t& cgs_13d)
{
	if( ( !states_137.empty())&& ( !tcs_139.empty())&& ( !fcns_13b.empty())&& ( !cgs_13d.empty()))
		callProcessedFilter_9e6( states_137, tcs_139, fcns_13b, cgs_13d);
}

bool EnterTransConnectorRecurse_136::isInputUnique( const Udm::Object& state_141, const Udm::Object& tc_148, const Udm::Object& fcn_14f, const Udm::Object& cg_156)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_143= _state_13f.begin(), ittc_14a= _tc_146.begin(), itfcn_151= _fcn_14d.begin(), itcg_158= _cg_154.begin(); itstate_143!= _state_13f.end(), ittc_14a!= _tc_146.end(), itfcn_151!= _fcn_14d.end(), itcg_158!= _cg_154.end(); ++itstate_143, ++ittc_14a, ++itfcn_151, ++itcg_158)
	{
		if( ( *itstate_143== state_141)&& ( *ittc_14a== tc_148)&& ( *itfcn_151== fcn_14f)&& ( *itcg_158== cg_156))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_13f.push_back( state_141);
		_tc_146.push_back( tc_148);
		_fcn_14d.push_back( fcn_14f);
		_cg_154.push_back( cg_156);
	}
	return isUnique;
}

void EnterTransConnectorRecurse_136::callProcessedFilter_9e6( const Packets_t& states_81a, const Packets_t& tcs_81c, const Packets_t& fcns_81e, const Packets_t& cgs_820)
{
	Packets_t states_822;
	Packets_t tcs_823;
	Packets_t fcns_824;
	Packets_t cgs_825;
	ProcessedFilter_819 processedFilter_819;
	processedFilter_819( states_81a, tcs_81c, fcns_81e, cgs_820, states_822, tcs_823, fcns_824, cgs_825);
	if( ( !states_822.empty())&& ( !tcs_823.empty())&& ( !fcns_824.empty())&& ( !cgs_825.empty()))
		callCreateTransitionCG_9eb( states_822, tcs_823, fcns_824, cgs_825);
}

void EnterTransConnectorRecurse_136::callCreateTransitionCG_9eb( const Packets_t& states_7c9, const Packets_t& transConnectors_7cc, const Packets_t& functions_7cf, const Packets_t& tCVarCGs_7d3)
{
	Packets_t states_7cb;
	Packets_t transConnectors_7ce;
	Packets_t functions_7d1;
	Packets_t transitionCGs_7d2;
	CreateTransitionCG_7c8 createTransitionCG_7c8;
	createTransitionCG_7c8( states_7c9, transConnectors_7cc, functions_7cf, tCVarCGs_7d3, states_7cb, transConnectors_7ce, functions_7d1, transitionCGs_7d2);
	if( ( !states_7cb.empty())&& ( !transConnectors_7ce.empty())&& ( !functions_7d1.empty())&& ( !transitionCGs_7d2.empty()))
		callEnterTransitions_9f0( states_7cb, transConnectors_7ce, functions_7d1, transitionCGs_7d2);
}

void EnterTransConnectorRecurse_136::callEnterTransitions_9f0( const Packets_t& states_15c, const Packets_t& tcs_15e, const Packets_t& fcns_160, const Packets_t& css_162)
{
	Packets_t states_164;
	Packets_t tcs_165;
	Packets_t fcns_166;
	Packets_t css_167;
	EnterTransitions_15b enterTransitions_15b;
	enterTransitions_15b( states_15c, tcs_15e, fcns_160, css_162, states_164, tcs_165, fcns_166, css_167);
	if( ( !states_164.empty())&& ( !tcs_165.empty())&& ( !fcns_166.empty())&& ( !css_167.empty()))
		callNoDefaultTransition_9f5( states_164, tcs_165, fcns_166, css_167);
}

void EnterTransConnectorRecurse_136::callNoDefaultTransition_9f5( const Packets_t& states_88d, const Packets_t& tcs_88f, const Packets_t& fcns_891, const Packets_t& css_893)
{
	NoDefaultTransition_88c noDefaultTransition_88c;
	noDefaultTransition_88c( states_88d, tcs_88f, fcns_891, css_893);
}

void EnterTransitions_15b::operator()( const Packets_t& states_15c, const Packets_t& tcs_15e, const Packets_t& fcns_160, const Packets_t& css_162, Packets_t& states_164, Packets_t& tcs_165, Packets_t& fcns_166, Packets_t& css_167)
{
#ifdef PRINT_INFO
	printLog( "EnterTransitions_15b" );
#endif
	_state_168= &states_164;
	_tc_169= &tcs_165;
	_fcn_16a= &fcns_166;
	_cs_16b= &css_167;
	if( ( !states_15c.empty())&& ( !tcs_15e.empty())&& ( !fcns_160.empty())&& ( !css_162.empty()))
		callGetAllTransitions_7be( states_15c, tcs_15e, fcns_160, css_162);
	_state_168->insert( _state_168->end(), states_15c.begin(), states_15c.end());
	_tc_169->insert( _tc_169->end(), tcs_15e.begin(), tcs_15e.end());
	_fcn_16a->insert( _fcn_16a->end(), fcns_160.begin(), fcns_160.end());
	_cs_16b->insert( _cs_16b->end(), css_162.begin(), css_162.end());
}

void EnterTransitions_15b::callGetAllTransitions_7be( const Packets_t& states_6b4, const Packets_t& tcs_6b6, const Packets_t& fcns_6b8, const Packets_t& css_6ba)
{
	Packets_t states_6bc;
	Packets_t transs_6bd;
	Packets_t fcns_6be;
	Packets_t css_6bf;
	GetAllTransitions_6b3 getAllTransitions_6b3;
	getAllTransitions_6b3( states_6b4, tcs_6b6, fcns_6b8, css_6ba, states_6bc, transs_6bd, fcns_6be, css_6bf);
	if( ( !states_6bc.empty())&& ( !transs_6bd.empty())&& ( !fcns_6be.empty())&& ( !css_6bf.empty()))
		callEnterProcessTransitions_7c3( states_6bc, transs_6bd, fcns_6be, css_6bf);
}

void EnterTransitions_15b::callEnterProcessTransitions_7c3( const Packets_t& states_16d, const Packets_t& transs_16f, const Packets_t& fcns_171, const Packets_t& css_173)
{
	EnterProcessTransitions_16c enterProcessTransitions_16c;
	enterProcessTransitions_16c( states_16d, transs_16f, fcns_171, css_173);
}

void EnterProcessTransitions_16c::operator()( const Packets_t& states_16d, const Packets_t& transs_16f, const Packets_t& fcns_171, const Packets_t& css_173)
{
#ifdef PRINT_INFO
	printLog( "EnterProcessTransitions_16c" );
#endif
	if( ( !states_16d.empty())&& ( !transs_16f.empty())&& ( !fcns_171.empty())&& ( !css_173.empty()))
		callOrderTransitions_680( states_16d, transs_16f, fcns_171, css_173);
}

void EnterProcessTransitions_16c::callOrderTransitions_680( const Packets_t& states_63f, const Packets_t& transitions_642, const Packets_t& functions_645, const Packets_t& compoundStatements_648)
{
	Packets_t states_641;
	Packets_t transitions_644;
	Packets_t functions_647;
	Packets_t compoundStatements_64a;
	OrderTransitions_63e orderTransitions_63e;
	orderTransitions_63e( states_63f, transitions_642, functions_645, compoundStatements_648, states_641, transitions_644, functions_647, compoundStatements_64a);
	if( ( !states_641.empty())&& ( !transitions_644.empty())&& ( !functions_647.empty())&& ( !compoundStatements_64a.empty()))
		callTransCond_685( states_641, transitions_644, functions_647, compoundStatements_64a);
}

void EnterProcessTransitions_16c::callTransCond_685( const Packets_t& states_331, const Packets_t& transitions_335, const Packets_t& functions_338, const Packets_t& transitionCGs_33b)
{
	Packets_t states_333;
	Packets_t dstTransConnectors_334;
	Packets_t transitions_337;
	Packets_t functions_33a;
	Packets_t conditionalBlocks_33d;
	TransCond_330 transCond_330;
	transCond_330( states_331, transitions_335, functions_338, transitionCGs_33b, states_333, dstTransConnectors_334, transitions_337, functions_33a, conditionalBlocks_33d);
	if( ( !states_333.empty())&& ( !dstTransConnectors_334.empty())&& ( !transitions_337.empty())&& ( !functions_33a.empty())&& ( !conditionalBlocks_33d.empty()))
		callTest_68a( states_333, dstTransConnectors_334, transitions_337, functions_33a, conditionalBlocks_33d);
}

void EnterProcessTransitions_16c::callTest_68a( const Packets_t& states_37c, const Packets_t& dsts_37e, const Packets_t& transs_380, const Packets_t& fcns_382, const Packets_t& cbs_384)
{
	Packets_t states_386;
	Packets_t dsts_387;
	Packets_t transs_388;
	Packets_t fcns_389;
	Packets_t cbs_38a;
	Packets_t states_38b;
	Packets_t dsts_38c;
	Packets_t transs_38d;
	Packets_t fcns_38e;
	Packets_t cbs_38f;
	Packets_t states_390;
	Packets_t dsts_391;
	Packets_t transs_392;
	Packets_t fcns_393;
	Packets_t cbs_394;
	Packets_t states_395;
	Packets_t dsts_396;
	Packets_t transs_397;
	Packets_t fcns_398;
	Packets_t cbs_399;
	Packets_t states_39a;
	Packets_t dsts_39b;
	Packets_t transs_39c;
	Packets_t fcns_39d;
	Packets_t cbs_39e;
	Test_37b test_37b;
	test_37b( states_37c, dsts_37e, transs_380, fcns_382, cbs_384, states_386, dsts_387, transs_388, fcns_389, cbs_38a, states_38b, dsts_38c, transs_38d, fcns_38e, cbs_38f, states_390, dsts_391, transs_392, fcns_393, cbs_394, states_395, dsts_396, transs_397, fcns_398, cbs_399, states_39a, dsts_39b, transs_39c, fcns_39d, cbs_39e);
	if( ( !states_386.empty())&& ( !dsts_387.empty())&& ( !transs_388.empty())&& ( !fcns_389.empty())&& ( !cbs_38a.empty()))
		callEnterNextState_690( states_386, dsts_387, transs_388, fcns_389, cbs_38a);
	if( ( !states_390.empty())&& ( !dsts_391.empty())&& ( !transs_392.empty())&& ( !fcns_393.empty())&& ( !cbs_394.empty()))
		callNextJunction_696( states_390, dsts_391, transs_392, fcns_393, cbs_394);
	if( ( !states_39a.empty())&& ( !dsts_39b.empty())&& ( !transs_39c.empty())&& ( !fcns_39d.empty())&& ( !cbs_39e.empty()))
		callDeadEndJunction_69c( states_39a, dsts_39b, transs_39c, fcns_39d, cbs_39e);
	if( ( !states_395.empty())&& ( !dsts_396.empty())&& ( !transs_397.empty())&& ( !fcns_398.empty())&& ( !cbs_399.empty()))
		callGetDstJuncFromRef_6a2( states_395, dsts_396, transs_397, fcns_398, cbs_399);
	if( ( !states_38b.empty())&& ( !dsts_38c.empty())&& ( !transs_38d.empty())&& ( !fcns_38e.empty())&& ( !cbs_38f.empty()))
		callGetDstStateFromRef_6a8( states_38b, dsts_38c, transs_38d, fcns_38e, cbs_38f);
}

void EnterProcessTransitions_16c::callEnterNextState_690( const Packets_t& states_176, const Packets_t& dstStates_178, const Packets_t& transitions_17a, const Packets_t& functions_17c, const Packets_t& transitionCBs_17e)
{
	EnterNextState_175 enterNextState_175;
	enterNextState_175( states_176, dstStates_178, transitions_17a, functions_17c, transitionCBs_17e);
}

void EnterProcessTransitions_16c::callNextJunction_696( const Packets_t& states_1d3, const Packets_t& junctions_1d6, const Packets_t& transitions_1d9, const Packets_t& functions_1db, const Packets_t& transitionCBs_1de)
{
	Packets_t states_1d5;
	Packets_t junctions_1d8;
	Packets_t functions_1dd;
	Packets_t conditionalGroups_1e0;
	NextJunction_1d2 nextJunction_1d2;
	nextJunction_1d2( states_1d3, junctions_1d6, transitions_1d9, functions_1db, transitionCBs_1de, states_1d5, junctions_1d8, functions_1dd, conditionalGroups_1e0);
	if( ( !states_1d5.empty())&& ( !junctions_1d8.empty())&& ( !functions_1dd.empty())&& ( !conditionalGroups_1e0.empty()))
		callEnterTransConnectorRecurse_6ae( states_1d5, junctions_1d8, functions_1dd, conditionalGroups_1e0);
}

void EnterProcessTransitions_16c::callDeadEndJunction_69c( const Packets_t& states_2e5, const Packets_t& transConnectors_2e7, const Packets_t& transitions_2e9, const Packets_t& functions_2eb, const Packets_t& transitionCBs_2ed)
{
	DeadEndJunction_2e4 deadEndJunction_2e4;
	deadEndJunction_2e4( states_2e5, transConnectors_2e7, transitions_2e9, functions_2eb, transitionCBs_2ed);
}

void EnterProcessTransitions_16c::callGetDstJuncFromRef_6a2( const Packets_t& states_23b, const Packets_t& connectorRefs_23e, const Packets_t& transitions_241, const Packets_t& functions_244, const Packets_t& conditionalBlocks_247)
{
	Packets_t states_23d;
	Packets_t junctions_240;
	Packets_t transitions_243;
	Packets_t functions_246;
	Packets_t conditionalBlocks_249;
	GetDstJuncFromRef_23a getDstJuncFromRef_23a;
	getDstJuncFromRef_23a( states_23b, connectorRefs_23e, transitions_241, functions_244, conditionalBlocks_247, states_23d, junctions_240, transitions_243, functions_246, conditionalBlocks_249);
	if( ( !states_23d.empty())&& ( !junctions_240.empty())&& ( !transitions_243.empty())&& ( !functions_246.empty())&& ( !conditionalBlocks_249.empty()))
		callNextJunction_696( states_23d, junctions_240, transitions_243, functions_246, conditionalBlocks_249);
}

void EnterProcessTransitions_16c::callGetDstStateFromRef_6a8( const Packets_t& states_290, const Packets_t& connectorRefs_294, const Packets_t& transitions_296, const Packets_t& functions_299, const Packets_t& conditionalBlocks_29c)
{
	Packets_t states_292;
	Packets_t dstStates_293;
	Packets_t transitions_298;
	Packets_t functions_29b;
	Packets_t conditionalBlocks_29e;
	GetDstStateFromRef_28f getDstStateFromRef_28f;
	getDstStateFromRef_28f( states_290, connectorRefs_294, transitions_296, functions_299, conditionalBlocks_29c, states_292, dstStates_293, transitions_298, functions_29b, conditionalBlocks_29e);
	if( ( !states_292.empty())&& ( !dstStates_293.empty())&& ( !transitions_298.empty())&& ( !functions_29b.empty())&& ( !conditionalBlocks_29e.empty()))
		callEnterNextState_690( states_292, dstStates_293, transitions_298, functions_29b, conditionalBlocks_29e);
}

void EnterProcessTransitions_16c::callEnterTransConnectorRecurse_6ae( const Packets_t& states_137, const Packets_t& tcs_139, const Packets_t& fcns_13b, const Packets_t& cgs_13d)
{
	EnterTransConnectorRecurse_136 enterTransConnectorRecurse_136;
	enterTransConnectorRecurse_136( states_137, tcs_139, fcns_13b, cgs_13d);
}

void EnterNextState_175::operator()( const Packets_t& states_176, const Packets_t& dstStates_178, const Packets_t& transitions_17a, const Packets_t& functions_17c, const Packets_t& transitionCBs_17e)
{
#ifdef PRINT_INFO
	printLog( "EnterNextState_175" );
#endif
	RTTGenerator::Instance()->generateRule(2247, "EnterNextState");
	processInputPackets( states_176, dstStates_178, transitions_17a, functions_17c, transitionCBs_17e);
}

bool EnterNextState_175::isInputUnique( const Udm::Object& state_184, const Udm::Object& dstState_18d, const Udm::Object& transition_196, const Udm::Object& function_19f, const Udm::Object& transitionCB_1a8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_186= _state_180.begin(), itDstState_18f= _dstState_189.begin(), itTransition_198= _transition_192.begin(), itFunction_1a1= _function_19b.begin(), itTransitionCB_1aa= _transitionCB_1a4.begin(); itState_186!= _state_180.end(), itDstState_18f!= _dstState_189.end(), itTransition_198!= _transition_192.end(), itFunction_1a1!= _function_19b.end(), itTransitionCB_1aa!= _transitionCB_1a4.end(); ++itState_186, ++itDstState_18f, ++itTransition_198, ++itFunction_1a1, ++itTransitionCB_1aa)
	{
		if( ( *itState_186== state_184)&& ( *itDstState_18f== dstState_18d)&& ( *itTransition_198== transition_196)&& ( *itFunction_1a1== function_19f)&& ( *itTransitionCB_1aa== transitionCB_1a8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_180.push_back( state_184);
		_dstState_189.push_back( dstState_18d);
		_transition_192.push_back( transition_196);
		_function_19b.push_back( function_19f);
		_transitionCB_1a4.push_back( transitionCB_1a8);
	}
	return isUnique;
}

bool EnterNextState_175::isGuardTrue( CyberComposition::Simulink::State& DstState, SFC::Function& Enter, SFC::Arg& EnterArg0, SFC::Arg& EnterArg1, SFC::Function& Function, CyberComposition::Simulink::State& State, SFC::StateLabel& StateLabel, CyberComposition::Simulink::Transition& Transition, SFC::ConditionalBlock& TransitionCB)
{
	bool Gz_guard= false;
	return EnterArg0.argIndex() == 0 && EnterArg1.argIndex() == 1;;
	return Gz_guard;
}

void EnterNextState_175::processInputPackets( const Packets_t& states_176, const Packets_t& dstStates_178, const Packets_t& transitions_17a, const Packets_t& functions_17c, const Packets_t& transitionCBs_17e)
{
	for( Packets_t::const_iterator itState_181= states_176.begin(), itDstState_18a= dstStates_178.begin(), itTransition_193= transitions_17a.begin(), itFunction_19c= functions_17c.begin(), itTransitionCB_1a5= transitionCBs_17e.begin(); itState_181!= states_176.end(), itDstState_18a!= dstStates_178.end(), itTransition_193!= transitions_17a.end(), itFunction_19c!= functions_17c.end(), itTransitionCB_1a5!= transitionCBs_17e.end(); ++itState_181, ++itDstState_18a, ++itTransition_193, ++itFunction_19c, ++itTransitionCB_1a5)
	{
		bool isUnique= isInputUnique( *itState_181, *itDstState_18a, *itTransition_193, *itFunction_19c, *itTransitionCB_1a5);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_181, *itDstState_18a, *itTransition_193, *itFunction_19c, *itTransitionCB_1a5);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool EnterNextState_175::patternMatcher( const Udm::Object& state_182, const Udm::Object& dstState_18b, const Udm::Object& transition_194, const Udm::Object& function_19d, const Udm::Object& transitionCB_1a6)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_182.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_187= CyberComposition::Simulink::State::Cast( state_182);
		if( false== Uml::IsDerivedFrom( dstState_18b.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State dstState_190= CyberComposition::Simulink::State::Cast( dstState_18b);
		if( false== Uml::IsDerivedFrom( transition_194.type(), CyberComposition::Simulink::Transition::meta))
			continue;
		CyberComposition::Simulink::Transition transition_199= CyberComposition::Simulink::Transition::Cast( transition_194);
		if( false== Uml::IsDerivedFrom( function_19d.type(), SFC::Function::meta))
			continue;
		SFC::Function function_1a2= SFC::Function::Cast( function_19d);
		if( false== Uml::IsDerivedFrom( transitionCB_1a6.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock transitionCB_1ab= SFC::ConditionalBlock::Cast( transitionCB_1a6);
		set< SFC::Function> enters_1ad= dstState_190.enter();
		for( set< SFC::Function>::const_iterator itEnters_1ae= enters_1ad.begin(); itEnters_1ae!= enters_1ad.end(); ++itEnters_1ae)
		{
			SFC::Function currEnter_1af= *itEnters_1ae;
			set< SFC::Arg> enterArg1s_1b0= currEnter_1af.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itEnterArg1_1b1= enterArg1s_1b0.begin(); itEnterArg1_1b1!= enterArg1s_1b0.end(); ++itEnterArg1_1b1)
			{
				SFC::Arg currEnterArg1_1b2= *itEnterArg1_1b1;
				set< SFC::Arg> enterArg0s_1b3= currEnter_1af.Arg_kind_children();
				for( set< SFC::Arg>::const_iterator itEnterArg0_1b4= enterArg0s_1b3.begin(); itEnterArg0_1b4!= enterArg0s_1b3.end(); ++itEnterArg0_1b4)
				{
					SFC::Arg currEnterArg0_1b5= *itEnterArg0_1b4;
					set< SFC::StateLabel> stateLabels_1b6= state_187.src();
					for( set< SFC::StateLabel>::const_iterator itStateLabels_1b7= stateLabels_1b6.begin(); itStateLabels_1b7!= stateLabels_1b6.end(); ++itStateLabels_1b7)
					{
						SFC::StateLabel currStateLabel_1b8= *itStateLabels_1b7;
						Match currMatch;
						currMatch.state_1ba= state_187;
						currMatch.dstState_1bb= dstState_190;
						currMatch.transition_1bc= transition_199;
						currMatch.function_1bd= function_1a2;
						currMatch.transitionCB_1be= transitionCB_1ab;
						currMatch.stateLabel_1bf= currStateLabel_1b8;
						currMatch.enterArg0_1c0= currEnterArg0_1b5;
						currMatch.enter_1c1= currEnter_1af;
						currMatch.enterArg1_1c2= currEnterArg1_1b2;
						bool Gz_guard= isGuardTrue( currMatch.dstState_1bb, currMatch.enter_1c1, currMatch.enterArg0_1c0, currMatch.enterArg1_1c2, currMatch.function_1bd, currMatch.state_1ba, currMatch.stateLabel_1bf, currMatch.transition_1bc, currMatch.transitionCB_1be);
						if( true== Gz_guard)
							_matches.push_back( currMatch);
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void EnterNextState_175::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Return newReturn_1cc= SFC::Return::Create( currMatch.transitionCB_1be, SFC::ConditionalBlock::meta_stmnt);
		SFC::FunctionCall newEnterFunctionCall_1cd= SFC::FunctionCall::Create( currMatch.transitionCB_1be, SFC::ConditionalBlock::meta_stmnt);
		SFC::ArgVal newEnterArgVal0_1ce= SFC::ArgVal::Create( newEnterFunctionCall_1cd);
		SFC::Int newTwo_1cf= SFC::Int::Create( newEnterArgVal0_1ce, SFC::ArgVal::meta_argexpr);
		SFC::ArgVal newEnterArgVal1_1d0= SFC::ArgVal::Create( newEnterFunctionCall_1cd);
		SFC::ArgDeclRef newEnterArgDeclRef_1d1= SFC::ArgDeclRef::Create( newEnterArgVal1_1d0, SFC::ArgVal::meta_argexpr);
		CyberComposition::Simulink::State& DstState= currMatch.dstState_1bb;
		SFC::Function& Enter= currMatch.enter_1c1;
		SFC::Arg& EnterArg0= currMatch.enterArg0_1c0;
		SFC::Arg& EnterArg1= currMatch.enterArg1_1c2;
		SFC::ArgDeclRef& EnterArgDeclRef= newEnterArgDeclRef_1d1;
		SFC::ArgVal& EnterArgVal0= newEnterArgVal0_1ce;
		SFC::ArgVal& EnterArgVal1= newEnterArgVal1_1d0;
		SFC::FunctionCall& EnterFunctionCall= newEnterFunctionCall_1cd;
		SFC::Function& Function= currMatch.function_1bd;
		SFC::Return& Return= newReturn_1cc;
		CyberComposition::Simulink::State& State= currMatch.state_1ba;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_1bf;
		CyberComposition::Simulink::Transition& Transition= currMatch.transition_1bc;
		SFC::ConditionalBlock& TransitionCB= currMatch.transitionCB_1be;
		SFC::Int& Two= newTwo_1cf;
		{
EnterFunctionCall.RefId() = Return.RefId() = TransitionCB.RefId();
};
		{
EnterArgVal1.argIndex() = 1;
};
		{
SFManager::mstat2SFC( TransitionCB, Transition.Action() );

__int64 statementCount = TransitionCB.statementCount();
EnterFunctionCall.statementIndex() = statementCount++;
Return.statementIndex() = statementCount++;
TransitionCB.statementCount() = statementCount;
};
		{
EnterArgVal0.argIndex() = 0;
};
		{
Two.val() = 2;
};
		newEnterFunctionCall_1cd.callee()= currMatch.enter_1c1;
		newEnterArgDeclRef_1d1.argdecl()= currMatch.stateLabel_1bf;
		newEnterArgVal1_1d0.arg()+= currMatch.enterArg1_1c2;
		newEnterArgVal0_1ce.arg()+= currMatch.enterArg0_1c0;
	}
}

void NextJunction_1d2::operator()( const Packets_t& states_1d3, const Packets_t& junctions_1d6, const Packets_t& transitions_1d9, const Packets_t& functions_1db, const Packets_t& transitionCBs_1de, Packets_t& states_1d5, Packets_t& junctions_1d8, Packets_t& functions_1dd, Packets_t& conditionalGroups_1e0)
{
#ifdef PRINT_INFO
	printLog( "NextJunction_1d2" );
#endif
	RTTGenerator::Instance()->generateRule(2672, "NextJunction");
	_state_1e1= &states_1d5;
	_junction_1e2= &junctions_1d8;
	_function_1e3= &functions_1dd;
	_conditionalGroup_1e4= &conditionalGroups_1e0;
	processInputPackets( states_1d3, junctions_1d6, transitions_1d9, functions_1db, transitionCBs_1de);
}

bool NextJunction_1d2::isInputUnique( const Udm::Object& state_1e9, const Udm::Object& junction_1f2, const Udm::Object& transition_1fb, const Udm::Object& function_204, const Udm::Object& transitionCB_20d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1eb= _state_1e5.begin(), itJunction_1f4= _junction_1ee.begin(), itTransition_1fd= _transition_1f7.begin(), itFunction_206= _function_200.begin(), itTransitionCB_20f= _transitionCB_209.begin(); itState_1eb!= _state_1e5.end(), itJunction_1f4!= _junction_1ee.end(), itTransition_1fd!= _transition_1f7.end(), itFunction_206!= _function_200.end(), itTransitionCB_20f!= _transitionCB_209.end(); ++itState_1eb, ++itJunction_1f4, ++itTransition_1fd, ++itFunction_206, ++itTransitionCB_20f)
	{
		if( ( *itState_1eb== state_1e9)&& ( *itJunction_1f4== junction_1f2)&& ( *itTransition_1fd== transition_1fb)&& ( *itFunction_206== function_204)&& ( *itTransitionCB_20f== transitionCB_20d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1e5.push_back( state_1e9);
		_junction_1ee.push_back( junction_1f2);
		_transition_1f7.push_back( transition_1fb);
		_function_200.push_back( function_204);
		_transitionCB_209.push_back( transitionCB_20d);
	}
	return isUnique;
}

bool NextJunction_1d2::isGuardTrue( SFC::ConditionalBlock& ConditionalBlock, SFC::ConditionalGroup& ConditionalGroup, SFC::Function& Function, CyberComposition::Simulink::SF_Junction& Junction, CyberComposition::Simulink::State& State, SFC::LocalVar& TCVar, CyberComposition::Simulink::Transition& Transition, SFC::ConditionalBlock& TransitionCB, SFC::ConditionalGroup& TransitionCG)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( TCVar.name() ) == "_TCVar_";;
	return Gz_guard;
}

void NextJunction_1d2::processInputPackets( const Packets_t& states_1d3, const Packets_t& junctions_1d6, const Packets_t& transitions_1d9, const Packets_t& functions_1db, const Packets_t& transitionCBs_1de)
{
	for( Packets_t::const_iterator itState_1e6= states_1d3.begin(), itJunction_1ef= junctions_1d6.begin(), itTransition_1f8= transitions_1d9.begin(), itFunction_201= functions_1db.begin(), itTransitionCB_20a= transitionCBs_1de.begin(); itState_1e6!= states_1d3.end(), itJunction_1ef!= junctions_1d6.end(), itTransition_1f8!= transitions_1d9.end(), itFunction_201!= functions_1db.end(), itTransitionCB_20a!= transitionCBs_1de.end(); ++itState_1e6, ++itJunction_1ef, ++itTransition_1f8, ++itFunction_201, ++itTransitionCB_20a)
	{
		bool isUnique= isInputUnique( *itState_1e6, *itJunction_1ef, *itTransition_1f8, *itFunction_201, *itTransitionCB_20a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1e6, *itJunction_1ef, *itTransition_1f8, *itFunction_201, *itTransitionCB_20a);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool NextJunction_1d2::patternMatcher( const Udm::Object& state_1e7, const Udm::Object& junction_1f0, const Udm::Object& transition_1f9, const Udm::Object& function_202, const Udm::Object& transitionCB_20b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1e7.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1ec= CyberComposition::Simulink::State::Cast( state_1e7);
		if( false== Uml::IsDerivedFrom( junction_1f0.type(), CyberComposition::Simulink::SF_Junction::meta))
			continue;
		CyberComposition::Simulink::SF_Junction junction_1f5= CyberComposition::Simulink::SF_Junction::Cast( junction_1f0);
		if( false== Uml::IsDerivedFrom( transition_1f9.type(), CyberComposition::Simulink::Transition::meta))
			continue;
		CyberComposition::Simulink::Transition transition_1fe= CyberComposition::Simulink::Transition::Cast( transition_1f9);
		if( false== Uml::IsDerivedFrom( function_202.type(), SFC::Function::meta))
			continue;
		SFC::Function function_207= SFC::Function::Cast( function_202);
		if( false== Uml::IsDerivedFrom( transitionCB_20b.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock transitionCB_210= SFC::ConditionalBlock::Cast( transitionCB_20b);
		Udm::Object transitionCBParent_212= transitionCB_210.container();
		if( false== Uml::IsDerivedFrom( transitionCBParent_212.type(), SFC::ConditionalGroup::meta))
			continue;
		SFC::ConditionalGroup transitionCGTransitionCB_213= SFC::ConditionalGroup::Cast( transitionCBParent_212);
		Udm::Object transitionCGParent_214= transitionCGTransitionCB_213.container();
		if( false== Uml::IsDerivedFrom( transitionCGParent_214.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlockTransitionCG_215= SFC::ConditionalBlock::Cast( transitionCGParent_214);
		Udm::Object conditionalBlockParent_216= conditionalBlockTransitionCG_215.container();
		if( false== Uml::IsDerivedFrom( conditionalBlockParent_216.type(), SFC::ConditionalGroup::meta))
			continue;
		SFC::ConditionalGroup conditionalGroupConditionalBlock_217= SFC::ConditionalGroup::Cast( conditionalBlockParent_216);
		set< SFC::LocalVar> tCVars_218= function_207.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itTCVar_219= tCVars_218.begin(); itTCVar_219!= tCVars_218.end(); ++itTCVar_219)
		{
			SFC::LocalVar currTCVar_21a= *itTCVar_219;
			Match currMatch;
			currMatch.state_21c= state_1ec;
			currMatch.junction_21d= junction_1f5;
			currMatch.transition_21e= transition_1fe;
			currMatch.function_21f= function_207;
			currMatch.transitionCB_220= transitionCB_210;
			currMatch.tCVar_221= currTCVar_21a;
			currMatch.conditionalGroup_222= conditionalGroupConditionalBlock_217;
			currMatch.transitionCG_223= transitionCGTransitionCB_213;
			currMatch.conditionalBlock_224= conditionalBlockTransitionCG_215;
			bool Gz_guard= isGuardTrue( currMatch.conditionalBlock_224, currMatch.conditionalGroup_222, currMatch.function_21f, currMatch.junction_21d, currMatch.state_21c, currMatch.tCVar_221, currMatch.transition_21e, currMatch.transitionCB_220, currMatch.transitionCG_223);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void NextJunction_1d2::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newNextJunction_22e= SFC::UserCode::Create( currMatch.transitionCB_220, SFC::ConditionalBlock::meta_stmnt);
		SFC::BinaryExprs newAssign_22f= SFC::BinaryExprs::Create( newNextJunction_22e, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newArgDeclRef_230= SFC::ArgDeclRef::Create( newAssign_22f, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newInt_231= SFC::Int::Create( newAssign_22f, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_230;
		SFC::BinaryExprs& Assign= newAssign_22f;
		SFC::ConditionalBlock& ConditionalBlock= currMatch.conditionalBlock_224;
		SFC::ConditionalGroup& ConditionalGroup= currMatch.conditionalGroup_222;
		SFC::Function& Function= currMatch.function_21f;
		SFC::Int& Int= newInt_231;
		CyberComposition::Simulink::SF_Junction& Junction= currMatch.junction_21d;
		SFC::UserCode& NextJunction= newNextJunction_22e;
		CyberComposition::Simulink::State& State= currMatch.state_21c;
		SFC::LocalVar& TCVar= currMatch.tCVar_221;
		CyberComposition::Simulink::Transition& Transition= currMatch.transition_21e;
		SFC::ConditionalBlock& TransitionCB= currMatch.transitionCB_220;
		SFC::ConditionalGroup& TransitionCG= currMatch.transitionCG_223;
		{
NextJunction.RefId() = Junction.RefId();
};
		{
Assign.op() = "=";

};
		{
__int64 statementCount = TransitionCB.statementCount();
NextJunction.statementIndex() = statementCount++;
TransitionCB.statementCount() = statementCount;
};
		{
Int.val() = SFManager::StateTransConnectorMap::get_singleton().getTransConnectorMap( State ).getTransConnectorNumber( Junction );
};
		newArgDeclRef_230.argdecl()= currMatch.tCVar_221;
		outputAppender( currMatch.state_21c, currMatch.junction_21d, currMatch.function_21f, currMatch.conditionalGroup_222);
	}
}

void NextJunction_1d2::outputAppender( const CyberComposition::Simulink::State& state_232, const CyberComposition::Simulink::SF_Junction& junction_234, const SFC::Function& function_236, const SFC::ConditionalGroup& conditionalGroup_238)
{
	_state_1e1->push_back( state_232);
	_junction_1e2->push_back( junction_234);
	_function_1e3->push_back( function_236);
	_conditionalGroup_1e4->push_back( conditionalGroup_238);
}

void GetDstJuncFromRef_23a::operator()( const Packets_t& states_23b, const Packets_t& connectorRefs_23e, const Packets_t& transitions_241, const Packets_t& functions_244, const Packets_t& conditionalBlocks_247, Packets_t& states_23d, Packets_t& junctions_240, Packets_t& transitions_243, Packets_t& functions_246, Packets_t& conditionalBlocks_249)
{
#ifdef PRINT_INFO
	printLog( "GetDstJuncFromRef_23a" );
#endif
	RTTGenerator::Instance()->generateRule(2460, "GetDstJuncFromRef");
	_state_24a= &states_23d;
	_junction_24b= &junctions_240;
	_transition_24c= &transitions_243;
	_function_24d= &functions_246;
	_conditionalBlock_24e= &conditionalBlocks_249;
	processInputPackets( states_23b, connectorRefs_23e, transitions_241, functions_244, conditionalBlocks_247);
}

bool GetDstJuncFromRef_23a::isInputUnique( const Udm::Object& state_253, const Udm::Object& connectorRef_25c, const Udm::Object& transition_265, const Udm::Object& function_26e, const Udm::Object& conditionalBlock_277)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_255= _state_24f.begin(), itConnectorRef_25e= _connectorRef_258.begin(), itTransition_267= _transition_261.begin(), itFunction_270= _function_26a.begin(), itConditionalBlock_279= _conditionalBlock_273.begin(); itState_255!= _state_24f.end(), itConnectorRef_25e!= _connectorRef_258.end(), itTransition_267!= _transition_261.end(), itFunction_270!= _function_26a.end(), itConditionalBlock_279!= _conditionalBlock_273.end(); ++itState_255, ++itConnectorRef_25e, ++itTransition_267, ++itFunction_270, ++itConditionalBlock_279)
	{
		if( ( *itState_255== state_253)&& ( *itConnectorRef_25e== connectorRef_25c)&& ( *itTransition_267== transition_265)&& ( *itFunction_270== function_26e)&& ( *itConditionalBlock_279== conditionalBlock_277))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_24f.push_back( state_253);
		_connectorRef_258.push_back( connectorRef_25c);
		_transition_261.push_back( transition_265);
		_function_26a.push_back( function_26e);
		_conditionalBlock_273.push_back( conditionalBlock_277);
	}
	return isUnique;
}

void GetDstJuncFromRef_23a::processInputPackets( const Packets_t& states_23b, const Packets_t& connectorRefs_23e, const Packets_t& transitions_241, const Packets_t& functions_244, const Packets_t& conditionalBlocks_247)
{
	for( Packets_t::const_iterator itState_250= states_23b.begin(), itConnectorRef_259= connectorRefs_23e.begin(), itTransition_262= transitions_241.begin(), itFunction_26b= functions_244.begin(), itConditionalBlock_274= conditionalBlocks_247.begin(); itState_250!= states_23b.end(), itConnectorRef_259!= connectorRefs_23e.end(), itTransition_262!= transitions_241.end(), itFunction_26b!= functions_244.end(), itConditionalBlock_274!= conditionalBlocks_247.end(); ++itState_250, ++itConnectorRef_259, ++itTransition_262, ++itFunction_26b, ++itConditionalBlock_274)
	{
		bool isUnique= isInputUnique( *itState_250, *itConnectorRef_259, *itTransition_262, *itFunction_26b, *itConditionalBlock_274);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_250, *itConnectorRef_259, *itTransition_262, *itFunction_26b, *itConditionalBlock_274);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetDstJuncFromRef_23a::patternMatcher( const Udm::Object& state_251, const Udm::Object& connectorRef_25a, const Udm::Object& transition_263, const Udm::Object& function_26c, const Udm::Object& conditionalBlock_275)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_251.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_256= CyberComposition::Simulink::State::Cast( state_251);
		if( false== Uml::IsDerivedFrom( connectorRef_25a.type(), CyberComposition::Simulink::ConnectorRef::meta))
			continue;
		CyberComposition::Simulink::ConnectorRef connectorRef_25f= CyberComposition::Simulink::ConnectorRef::Cast( connectorRef_25a);
		if( false== Uml::IsDerivedFrom( transition_263.type(), CyberComposition::Simulink::Transition::meta))
			continue;
		CyberComposition::Simulink::Transition transition_268= CyberComposition::Simulink::Transition::Cast( transition_263);
		if( false== Uml::IsDerivedFrom( function_26c.type(), SFC::Function::meta))
			continue;
		SFC::Function function_271= SFC::Function::Cast( function_26c);
		if( false== Uml::IsDerivedFrom( conditionalBlock_275.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlock_27a= SFC::ConditionalBlock::Cast( conditionalBlock_275);
		CyberComposition::Simulink::TransConnector junction_27c= connectorRef_25f.ref();
		if( false== Uml::IsDerivedFrom( junction_27c.type(), CyberComposition::Simulink::SF_Junction::meta))
			continue;
		CyberComposition::Simulink::SF_Junction junction_27d= CyberComposition::Simulink::SF_Junction::Cast( junction_27c);
		if( !junction_27d)
			continue;
		Match currMatch;
		currMatch.state_27f= state_256;
		currMatch.connectorRef_280= connectorRef_25f;
		currMatch.transition_281= transition_268;
		currMatch.function_282= function_271;
		currMatch.conditionalBlock_283= conditionalBlock_27a;
		currMatch.junction_284= junction_27d;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void GetDstJuncFromRef_23a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_27f, currMatch.junction_284, currMatch.transition_281, currMatch.function_282, currMatch.conditionalBlock_283);
	}
}

void GetDstJuncFromRef_23a::outputAppender( const CyberComposition::Simulink::State& state_285, const CyberComposition::Simulink::SF_Junction& junction_287, const CyberComposition::Simulink::Transition& transition_289, const SFC::Function& function_28b, const SFC::ConditionalBlock& conditionalBlock_28d)
{
	_state_24a->push_back( state_285);
	_junction_24b->push_back( junction_287);
	_transition_24c->push_back( transition_289);
	_function_24d->push_back( function_28b);
	_conditionalBlock_24e->push_back( conditionalBlock_28d);
}

void GetDstStateFromRef_28f::operator()( const Packets_t& states_290, const Packets_t& connectorRefs_294, const Packets_t& transitions_296, const Packets_t& functions_299, const Packets_t& conditionalBlocks_29c, Packets_t& states_292, Packets_t& dstStates_293, Packets_t& transitions_298, Packets_t& functions_29b, Packets_t& conditionalBlocks_29e)
{
#ifdef PRINT_INFO
	printLog( "GetDstStateFromRef_28f" );
#endif
	RTTGenerator::Instance()->generateRule(2664, "GetDstStateFromRef");
	_state_29f= &states_292;
	_dstState_2a0= &dstStates_293;
	_transition_2a1= &transitions_298;
	_function_2a2= &functions_29b;
	_conditionalBlock_2a3= &conditionalBlocks_29e;
	processInputPackets( states_290, connectorRefs_294, transitions_296, functions_299, conditionalBlocks_29c);
}

bool GetDstStateFromRef_28f::isInputUnique( const Udm::Object& state_2a8, const Udm::Object& connectorRef_2b1, const Udm::Object& transition_2ba, const Udm::Object& function_2c3, const Udm::Object& conditionalBlock_2cc)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_2aa= _state_2a4.begin(), itConnectorRef_2b3= _connectorRef_2ad.begin(), itTransition_2bc= _transition_2b6.begin(), itFunction_2c5= _function_2bf.begin(), itConditionalBlock_2ce= _conditionalBlock_2c8.begin(); itState_2aa!= _state_2a4.end(), itConnectorRef_2b3!= _connectorRef_2ad.end(), itTransition_2bc!= _transition_2b6.end(), itFunction_2c5!= _function_2bf.end(), itConditionalBlock_2ce!= _conditionalBlock_2c8.end(); ++itState_2aa, ++itConnectorRef_2b3, ++itTransition_2bc, ++itFunction_2c5, ++itConditionalBlock_2ce)
	{
		if( ( *itState_2aa== state_2a8)&& ( *itConnectorRef_2b3== connectorRef_2b1)&& ( *itTransition_2bc== transition_2ba)&& ( *itFunction_2c5== function_2c3)&& ( *itConditionalBlock_2ce== conditionalBlock_2cc))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_2a4.push_back( state_2a8);
		_connectorRef_2ad.push_back( connectorRef_2b1);
		_transition_2b6.push_back( transition_2ba);
		_function_2bf.push_back( function_2c3);
		_conditionalBlock_2c8.push_back( conditionalBlock_2cc);
	}
	return isUnique;
}

void GetDstStateFromRef_28f::processInputPackets( const Packets_t& states_290, const Packets_t& connectorRefs_294, const Packets_t& transitions_296, const Packets_t& functions_299, const Packets_t& conditionalBlocks_29c)
{
	for( Packets_t::const_iterator itState_2a5= states_290.begin(), itConnectorRef_2ae= connectorRefs_294.begin(), itTransition_2b7= transitions_296.begin(), itFunction_2c0= functions_299.begin(), itConditionalBlock_2c9= conditionalBlocks_29c.begin(); itState_2a5!= states_290.end(), itConnectorRef_2ae!= connectorRefs_294.end(), itTransition_2b7!= transitions_296.end(), itFunction_2c0!= functions_299.end(), itConditionalBlock_2c9!= conditionalBlocks_29c.end(); ++itState_2a5, ++itConnectorRef_2ae, ++itTransition_2b7, ++itFunction_2c0, ++itConditionalBlock_2c9)
	{
		bool isUnique= isInputUnique( *itState_2a5, *itConnectorRef_2ae, *itTransition_2b7, *itFunction_2c0, *itConditionalBlock_2c9);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_2a5, *itConnectorRef_2ae, *itTransition_2b7, *itFunction_2c0, *itConditionalBlock_2c9);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetDstStateFromRef_28f::patternMatcher( const Udm::Object& state_2a6, const Udm::Object& connectorRef_2af, const Udm::Object& transition_2b8, const Udm::Object& function_2c1, const Udm::Object& conditionalBlock_2ca)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_2a6.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_2ab= CyberComposition::Simulink::State::Cast( state_2a6);
		if( false== Uml::IsDerivedFrom( connectorRef_2af.type(), CyberComposition::Simulink::ConnectorRef::meta))
			continue;
		CyberComposition::Simulink::ConnectorRef connectorRef_2b4= CyberComposition::Simulink::ConnectorRef::Cast( connectorRef_2af);
		if( false== Uml::IsDerivedFrom( transition_2b8.type(), CyberComposition::Simulink::Transition::meta))
			continue;
		CyberComposition::Simulink::Transition transition_2bd= CyberComposition::Simulink::Transition::Cast( transition_2b8);
		if( false== Uml::IsDerivedFrom( function_2c1.type(), SFC::Function::meta))
			continue;
		SFC::Function function_2c6= SFC::Function::Cast( function_2c1);
		if( false== Uml::IsDerivedFrom( conditionalBlock_2ca.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlock_2cf= SFC::ConditionalBlock::Cast( conditionalBlock_2ca);
		CyberComposition::Simulink::TransConnector dstState_2d1= connectorRef_2b4.ref();
		if( false== Uml::IsDerivedFrom( dstState_2d1.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State dstState_2d2= CyberComposition::Simulink::State::Cast( dstState_2d1);
		if( !dstState_2d2)
			continue;
		Match currMatch;
		currMatch.state_2d4= state_2ab;
		currMatch.connectorRef_2d5= connectorRef_2b4;
		currMatch.transition_2d6= transition_2bd;
		currMatch.function_2d7= function_2c6;
		currMatch.conditionalBlock_2d8= conditionalBlock_2cf;
		currMatch.dstState_2d9= dstState_2d2;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void GetDstStateFromRef_28f::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_2d4, currMatch.dstState_2d9, currMatch.transition_2d6, currMatch.function_2d7, currMatch.conditionalBlock_2d8);
	}
}

void GetDstStateFromRef_28f::outputAppender( const CyberComposition::Simulink::State& state_2da, const CyberComposition::Simulink::State& dstState_2dc, const CyberComposition::Simulink::Transition& transition_2de, const SFC::Function& function_2e0, const SFC::ConditionalBlock& conditionalBlock_2e2)
{
	_state_29f->push_back( state_2da);
	_dstState_2a0->push_back( dstState_2dc);
	_transition_2a1->push_back( transition_2de);
	_function_2a2->push_back( function_2e0);
	_conditionalBlock_2a3->push_back( conditionalBlock_2e2);
}

void DeadEndJunction_2e4::operator()( const Packets_t& states_2e5, const Packets_t& transConnectors_2e7, const Packets_t& transitions_2e9, const Packets_t& functions_2eb, const Packets_t& transitionCBs_2ed)
{
#ifdef PRINT_INFO
	printLog( "DeadEndJunction_2e4" );
#endif
	RTTGenerator::Instance()->generateRule(2435, "DeadEndJunction");
	processInputPackets( states_2e5, transConnectors_2e7, transitions_2e9, functions_2eb, transitionCBs_2ed);
}

bool DeadEndJunction_2e4::isInputUnique( const Udm::Object& state_2f3, const Udm::Object& transConnector_2fc, const Udm::Object& transition_305, const Udm::Object& function_30e, const Udm::Object& transitionCB_317)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_2f5= _state_2ef.begin(), itTransConnector_2fe= _transConnector_2f8.begin(), itTransition_307= _transition_301.begin(), itFunction_310= _function_30a.begin(), itTransitionCB_319= _transitionCB_313.begin(); itState_2f5!= _state_2ef.end(), itTransConnector_2fe!= _transConnector_2f8.end(), itTransition_307!= _transition_301.end(), itFunction_310!= _function_30a.end(), itTransitionCB_319!= _transitionCB_313.end(); ++itState_2f5, ++itTransConnector_2fe, ++itTransition_307, ++itFunction_310, ++itTransitionCB_319)
	{
		if( ( *itState_2f5== state_2f3)&& ( *itTransConnector_2fe== transConnector_2fc)&& ( *itTransition_307== transition_305)&& ( *itFunction_310== function_30e)&& ( *itTransitionCB_319== transitionCB_317))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_2ef.push_back( state_2f3);
		_transConnector_2f8.push_back( transConnector_2fc);
		_transition_301.push_back( transition_305);
		_function_30a.push_back( function_30e);
		_transitionCB_313.push_back( transitionCB_317);
	}
	return isUnique;
}

bool DeadEndJunction_2e4::isGuardTrue( SFC::Function& Function, CyberComposition::Simulink::State& State, SFC::LocalVar& TCVar, CyberComposition::Simulink::TransConnector& TransConnector, CyberComposition::Simulink::Transition& Transition, SFC::ConditionalBlock& TransitionCB)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( TCVar.name() ) == "_TCVar_";;
	return Gz_guard;
}

void DeadEndJunction_2e4::processInputPackets( const Packets_t& states_2e5, const Packets_t& transConnectors_2e7, const Packets_t& transitions_2e9, const Packets_t& functions_2eb, const Packets_t& transitionCBs_2ed)
{
	for( Packets_t::const_iterator itState_2f0= states_2e5.begin(), itTransConnector_2f9= transConnectors_2e7.begin(), itTransition_302= transitions_2e9.begin(), itFunction_30b= functions_2eb.begin(), itTransitionCB_314= transitionCBs_2ed.begin(); itState_2f0!= states_2e5.end(), itTransConnector_2f9!= transConnectors_2e7.end(), itTransition_302!= transitions_2e9.end(), itFunction_30b!= functions_2eb.end(), itTransitionCB_314!= transitionCBs_2ed.end(); ++itState_2f0, ++itTransConnector_2f9, ++itTransition_302, ++itFunction_30b, ++itTransitionCB_314)
	{
		bool isUnique= isInputUnique( *itState_2f0, *itTransConnector_2f9, *itTransition_302, *itFunction_30b, *itTransitionCB_314);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_2f0, *itTransConnector_2f9, *itTransition_302, *itFunction_30b, *itTransitionCB_314);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool DeadEndJunction_2e4::patternMatcher( const Udm::Object& state_2f1, const Udm::Object& transConnector_2fa, const Udm::Object& transition_303, const Udm::Object& function_30c, const Udm::Object& transitionCB_315)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_2f1.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_2f6= CyberComposition::Simulink::State::Cast( state_2f1);
		if( false== Uml::IsDerivedFrom( transConnector_2fa.type(), CyberComposition::Simulink::TransConnector::meta))
			continue;
		CyberComposition::Simulink::TransConnector transConnector_2ff= CyberComposition::Simulink::TransConnector::Cast( transConnector_2fa);
		if( false== Uml::IsDerivedFrom( transition_303.type(), CyberComposition::Simulink::Transition::meta))
			continue;
		CyberComposition::Simulink::Transition transition_308= CyberComposition::Simulink::Transition::Cast( transition_303);
		if( false== Uml::IsDerivedFrom( function_30c.type(), SFC::Function::meta))
			continue;
		SFC::Function function_311= SFC::Function::Cast( function_30c);
		if( false== Uml::IsDerivedFrom( transitionCB_315.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock transitionCB_31a= SFC::ConditionalBlock::Cast( transitionCB_315);
		set< SFC::LocalVar> tCVars_31c= function_311.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itTCVar_31d= tCVars_31c.begin(); itTCVar_31d!= tCVars_31c.end(); ++itTCVar_31d)
		{
			SFC::LocalVar currTCVar_31e= *itTCVar_31d;
			Match currMatch;
			currMatch.state_320= state_2f6;
			currMatch.transConnector_321= transConnector_2ff;
			currMatch.transition_322= transition_308;
			currMatch.function_323= function_311;
			currMatch.transitionCB_324= transitionCB_31a;
			currMatch.tCVar_325= currTCVar_31e;
			bool Gz_guard= isGuardTrue( currMatch.function_323, currMatch.state_320, currMatch.tCVar_325, currMatch.transConnector_321, currMatch.transition_322, currMatch.transitionCB_324);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void DeadEndJunction_2e4::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newNextJunction_32c= SFC::UserCode::Create( currMatch.transitionCB_324, SFC::ConditionalBlock::meta_stmnt);
		SFC::BinaryExprs newAssign_32d= SFC::BinaryExprs::Create( newNextJunction_32c, SFC::UserCode::meta_codeexpr);
		SFC::Int newNegOne_32e= SFC::Int::Create( newAssign_32d, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_32f= SFC::ArgDeclRef::Create( newAssign_32d, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_32f;
		SFC::BinaryExprs& Assign= newAssign_32d;
		SFC::Function& Function= currMatch.function_323;
		SFC::Int& NegOne= newNegOne_32e;
		SFC::UserCode& NextJunction= newNextJunction_32c;
		CyberComposition::Simulink::State& State= currMatch.state_320;
		SFC::LocalVar& TCVar= currMatch.tCVar_325;
		CyberComposition::Simulink::TransConnector& TransConnector= currMatch.transConnector_321;
		CyberComposition::Simulink::Transition& Transition= currMatch.transition_322;
		SFC::ConditionalBlock& TransitionCB= currMatch.transitionCB_324;
		{
NextJunction.RefId() = TransConnector.RefId();
};
		{
__int64 statementCount = TransitionCB.statementCount();
NextJunction.statementIndex() = statementCount++;
TransitionCB.statementCount() = statementCount;
};
		{
Assign.op() = "=";
NegOne.val() = -1;
};
		newArgDeclRef_32f.argdecl()= currMatch.tCVar_325;
	}
}

void TransCond_330::operator()( const Packets_t& states_331, const Packets_t& transitions_335, const Packets_t& functions_338, const Packets_t& transitionCGs_33b, Packets_t& states_333, Packets_t& dstTransConnectors_334, Packets_t& transitions_337, Packets_t& functions_33a, Packets_t& conditionalBlocks_33d)
{
#ifdef PRINT_INFO
	printLog( "TransCond_330" );
#endif
	RTTGenerator::Instance()->generateRule(2421, "TransCond");
	_state_33e= &states_333;
	_dstTransConnector_33f= &dstTransConnectors_334;
	_transition_340= &transitions_337;
	_function_341= &functions_33a;
	_conditionalBlock_342= &conditionalBlocks_33d;
	processInputPackets( states_331, transitions_335, functions_338, transitionCGs_33b);
}

bool TransCond_330::isInputUnique( const Udm::Object& state_347, const Udm::Object& transition_350, const Udm::Object& function_359, const Udm::Object& transitionCG_362)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_349= _state_343.begin(), itTransition_352= _transition_34c.begin(), itFunction_35b= _function_355.begin(), itTransitionCG_364= _transitionCG_35e.begin(); itState_349!= _state_343.end(), itTransition_352!= _transition_34c.end(), itFunction_35b!= _function_355.end(), itTransitionCG_364!= _transitionCG_35e.end(); ++itState_349, ++itTransition_352, ++itFunction_35b, ++itTransitionCG_364)
	{
		if( ( *itState_349== state_347)&& ( *itTransition_352== transition_350)&& ( *itFunction_35b== function_359)&& ( *itTransitionCG_364== transitionCG_362))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_343.push_back( state_347);
		_transition_34c.push_back( transition_350);
		_function_355.push_back( function_359);
		_transitionCG_35e.push_back( transitionCG_362);
	}
	return isUnique;
}

void TransCond_330::processInputPackets( const Packets_t& states_331, const Packets_t& transitions_335, const Packets_t& functions_338, const Packets_t& transitionCGs_33b)
{
	for( Packets_t::const_iterator itState_344= states_331.begin(), itTransition_34d= transitions_335.begin(), itFunction_356= functions_338.begin(), itTransitionCG_35f= transitionCGs_33b.begin(); itState_344!= states_331.end(), itTransition_34d!= transitions_335.end(), itFunction_356!= functions_338.end(), itTransitionCG_35f!= transitionCGs_33b.end(); ++itState_344, ++itTransition_34d, ++itFunction_356, ++itTransitionCG_35f)
	{
		bool isUnique= isInputUnique( *itState_344, *itTransition_34d, *itFunction_356, *itTransitionCG_35f);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_344, *itTransition_34d, *itFunction_356, *itTransitionCG_35f);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool TransCond_330::patternMatcher( const Udm::Object& state_345, const Udm::Object& transition_34e, const Udm::Object& function_357, const Udm::Object& transitionCG_360)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_345.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_34a= CyberComposition::Simulink::State::Cast( state_345);
		if( false== Uml::IsDerivedFrom( transition_34e.type(), CyberComposition::Simulink::Transition::meta))
			continue;
		CyberComposition::Simulink::Transition transition_353= CyberComposition::Simulink::Transition::Cast( transition_34e);
		if( false== Uml::IsDerivedFrom( function_357.type(), SFC::Function::meta))
			continue;
		SFC::Function function_35c= SFC::Function::Cast( function_357);
		if( false== Uml::IsDerivedFrom( transitionCG_360.type(), SFC::ConditionalGroup::meta))
			continue;
		SFC::ConditionalGroup transitionCG_365= SFC::ConditionalGroup::Cast( transitionCG_360);
		CyberComposition::Simulink::TransConnector srcTransConnector_367= transition_353.srcTransition_end();
		CyberComposition::Simulink::TransConnector dstTransConnector_368= transition_353.dstTransition_end();
		Match currMatch;
		currMatch.state_36a= state_34a;
		currMatch.transition_36b= transition_353;
		currMatch.function_36c= function_35c;
		currMatch.transitionCG_36d= transitionCG_365;
		currMatch.dstTransConnector_36e= dstTransConnector_368;
		currMatch.srcTransConnector_36f= srcTransConnector_367;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void TransCond_330::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_370= SFC::ConditionalBlock::Create( currMatch.transitionCG_36d, SFC::ConditionalGroup::meta_stmnt);
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_370;
		CyberComposition::Simulink::TransConnector& DstTransConnector= currMatch.dstTransConnector_36e;
		SFC::Function& Function= currMatch.function_36c;
		CyberComposition::Simulink::TransConnector& SrcTransConnector= currMatch.srcTransConnector_36f;
		CyberComposition::Simulink::State& State= currMatch.state_36a;
		CyberComposition::Simulink::Transition& Transition= currMatch.transition_36b;
		SFC::ConditionalGroup& TransitionCG= currMatch.transitionCG_36d;
		{
ConditionalBlock.RefId() = Transition.RefId();
};
		{
__int64 statementCount = TransitionCG.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
TransitionCG.statementCount() = statementCount;
};
		{
std::string condition = Transition.Trigger();
SFManager::filterComments( condition );
condition = SFManager::trim( condition );

std::string guard = Transition.Guard();
SFManager::filterComments( guard );
guard = SFManager::trim( guard );

if ( condition.empty() ) {
  condition = guard;
} else if ( !guard.empty() ) {
  condition = "( " + condition + " ) && ( " + guard + " )";
}
if ( condition.empty() ) condition = "1";

SFManager::mexpr2SFCCondition( ConditionalBlock, condition );

SFManager::mstat2SFC( ConditionalBlock, Transition.ConditionAction() );
};
		outputAppender( currMatch.state_36a, currMatch.dstTransConnector_36e, currMatch.transition_36b, currMatch.function_36c, newConditionalBlock_370);
	}
}

void TransCond_330::outputAppender( const CyberComposition::Simulink::State& state_371, const CyberComposition::Simulink::TransConnector& dstTransConnector_373, const CyberComposition::Simulink::Transition& transition_375, const SFC::Function& function_377, const SFC::ConditionalBlock& conditionalBlock_379)
{
	_state_33e->push_back( state_371);
	_dstTransConnector_33f->push_back( dstTransConnector_373);
	_transition_340->push_back( transition_375);
	_function_341->push_back( function_377);
	_conditionalBlock_342->push_back( conditionalBlock_379);
}

void Test_37b::operator()( const Packets_t& states_37c, const Packets_t& dsts_37e, const Packets_t& transs_380, const Packets_t& fcns_382, const Packets_t& cbs_384, Packets_t& states_386, Packets_t& dsts_387, Packets_t& transs_388, Packets_t& fcns_389, Packets_t& cbs_38a, Packets_t& states_38b, Packets_t& dsts_38c, Packets_t& transs_38d, Packets_t& fcns_38e, Packets_t& cbs_38f, Packets_t& states_390, Packets_t& dsts_391, Packets_t& transs_392, Packets_t& fcns_393, Packets_t& cbs_394, Packets_t& states_395, Packets_t& dsts_396, Packets_t& transs_397, Packets_t& fcns_398, Packets_t& cbs_399, Packets_t& states_39a, Packets_t& dsts_39b, Packets_t& transs_39c, Packets_t& fcns_39d, Packets_t& cbs_39e)
{
#ifdef PRINT_INFO
	printLog( "Test_37b" );
#endif
	_state_39f= &states_386;
	_dst_3a0= &dsts_387;
	_trans_3a1= &transs_388;
	_fcn_3a2= &fcns_389;
	_cb_3a3= &cbs_38a;
	_state_3a4= &states_38b;
	_dst_3a5= &dsts_38c;
	_trans_3a6= &transs_38d;
	_fcn_3a7= &fcns_38e;
	_cb_3a8= &cbs_38f;
	_state_3a9= &states_390;
	_dst_3aa= &dsts_391;
	_trans_3ab= &transs_392;
	_fcn_3ac= &fcns_393;
	_cb_3ad= &cbs_394;
	_state_3ae= &states_395;
	_dst_3af= &dsts_396;
	_trans_3b0= &transs_397;
	_fcn_3b1= &fcns_398;
	_cb_3b2= &cbs_399;
	_state_3b3= &states_39a;
	_dst_3b4= &dsts_39b;
	_trans_3b5= &transs_39c;
	_fcn_3b6= &fcns_39d;
	_cb_3b7= &cbs_39e;
	for( Packets_t::const_iterator itstate_3b9= states_37c.begin(), itdst_3c0= dsts_37e.begin(), ittrans_3c7= transs_380.begin(), itfcn_3ce= fcns_382.begin(), itcb_3d5= cbs_384.begin(); itstate_3b9!= states_37c.end(), itdst_3c0!= dsts_37e.end(), ittrans_3c7!= transs_380.end(), itfcn_3ce!= fcns_382.end(), itcb_3d5!= cbs_384.end(); ++itstate_3b9, ++itdst_3c0, ++ittrans_3c7, ++itfcn_3ce, ++itcb_3d5)
	{
		bool isUnique= isInputUnique( *itstate_3b9, *itdst_3c0, *ittrans_3c7, *itfcn_3ce, *itcb_3d5);
		if( !isUnique)
			continue;
		Packets_t onestate_3bd( 1, *itstate_3b9);
		Packets_t onedst_3c4( 1, *itdst_3c0);
		Packets_t onetrans_3cb( 1, *ittrans_3c7);
		Packets_t onefcn_3d2( 1, *itfcn_3ce);
		Packets_t onecb_3d9( 1, *itcb_3d5);
		executeOne( onestate_3bd, onedst_3c4, onetrans_3cb, onefcn_3d2, onecb_3d9);
	}
}

void Test_37b::executeOne( const Packets_t& states_37c, const Packets_t& dsts_37e, const Packets_t& transs_380, const Packets_t& fcns_382, const Packets_t& cbs_384)
{
	Packets_t states_3de;
	Packets_t dstStates_3e1;
	Packets_t transitions_3e4;
	Packets_t functions_3e7;
	Packets_t conditionalBlocks_3ea;
	DstIsState_3db dstIsState_3db;
	bool isMatchDstIsState_3db= dstIsState_3db( states_37c, dsts_37e, transs_380, fcns_382, cbs_384, states_3de, dstStates_3e1, transitions_3e4, functions_3e7, conditionalBlocks_3ea);
	_state_39f->insert( _state_39f->end(), states_3de.begin(), states_3de.end());
	_dst_3a0->insert( _dst_3a0->end(), dstStates_3e1.begin(), dstStates_3e1.end());
	_trans_3a1->insert( _trans_3a1->end(), transitions_3e4.begin(), transitions_3e4.end());
	_fcn_3a2->insert( _fcn_3a2->end(), functions_3e7.begin(), functions_3e7.end());
	_cb_3a3->insert( _cb_3a3->end(), conditionalBlocks_3ea.begin(), conditionalBlocks_3ea.end());
	if( isMatchDstIsState_3db)
		return;
	Packets_t states_430;
	Packets_t connectorRefs_433;
	Packets_t transitions_436;
	Packets_t functions_439;
	Packets_t conditionalBlocks_43c;
	DstIsRefState_42d dstIsRefState_42d;
	bool isMatchDstIsRefState_42d= dstIsRefState_42d( states_37c, dsts_37e, transs_380, fcns_382, cbs_384, states_430, connectorRefs_433, transitions_436, functions_439, conditionalBlocks_43c);
	_state_3a4->insert( _state_3a4->end(), states_430.begin(), states_430.end());
	_dst_3a5->insert( _dst_3a5->end(), connectorRefs_433.begin(), connectorRefs_433.end());
	_trans_3a6->insert( _trans_3a6->end(), transitions_436.begin(), transitions_436.end());
	_fcn_3a7->insert( _fcn_3a7->end(), functions_439.begin(), functions_439.end());
	_cb_3a8->insert( _cb_3a8->end(), conditionalBlocks_43c.begin(), conditionalBlocks_43c.end());
	if( isMatchDstIsRefState_42d)
		return;
	Packets_t states_485;
	Packets_t junctions_488;
	Packets_t transitions_48b;
	Packets_t functions_48e;
	Packets_t conditionalBlocks_491;
	DstIsJuncWithTrans_482 dstIsJuncWithTrans_482;
	bool isMatchDstIsJuncWithTrans_482= dstIsJuncWithTrans_482( states_37c, dsts_37e, transs_380, fcns_382, cbs_384, states_485, junctions_488, transitions_48b, functions_48e, conditionalBlocks_491);
	_state_3a9->insert( _state_3a9->end(), states_485.begin(), states_485.end());
	_dst_3aa->insert( _dst_3aa->end(), junctions_488.begin(), junctions_488.end());
	_trans_3ab->insert( _trans_3ab->end(), transitions_48b.begin(), transitions_48b.end());
	_fcn_3ac->insert( _fcn_3ac->end(), functions_48e.begin(), functions_48e.end());
	_cb_3ad->insert( _cb_3ad->end(), conditionalBlocks_491.begin(), conditionalBlocks_491.end());
	if( isMatchDstIsJuncWithTrans_482)
		return;
	Packets_t states_4dd;
	Packets_t junctions_4e0;
	Packets_t transitions_4e3;
	Packets_t functions_4e6;
	Packets_t conditionalBlocks_4e9;
	DstIsJuncWithRefTrans_4da dstIsJuncWithRefTrans_4da;
	bool isMatchDstIsJuncWithRefTrans_4da= dstIsJuncWithRefTrans_4da( states_37c, dsts_37e, transs_380, fcns_382, cbs_384, states_4dd, junctions_4e0, transitions_4e3, functions_4e6, conditionalBlocks_4e9);
	_state_3a9->insert( _state_3a9->end(), states_4dd.begin(), states_4dd.end());
	_dst_3aa->insert( _dst_3aa->end(), junctions_4e0.begin(), junctions_4e0.end());
	_trans_3ab->insert( _trans_3ab->end(), transitions_4e3.begin(), transitions_4e3.end());
	_fcn_3ac->insert( _fcn_3ac->end(), functions_4e6.begin(), functions_4e6.end());
	_cb_3ad->insert( _cb_3ad->end(), conditionalBlocks_4e9.begin(), conditionalBlocks_4e9.end());
	if( isMatchDstIsJuncWithRefTrans_4da)
		return;
	Packets_t states_539;
	Packets_t connectorRefs_53c;
	Packets_t transitions_53f;
	Packets_t functions_542;
	Packets_t conditionalBlocks_545;
	DstIsJuncRefWithTrans_536 dstIsJuncRefWithTrans_536;
	bool isMatchDstIsJuncRefWithTrans_536= dstIsJuncRefWithTrans_536( states_37c, dsts_37e, transs_380, fcns_382, cbs_384, states_539, connectorRefs_53c, transitions_53f, functions_542, conditionalBlocks_545);
	_state_3ae->insert( _state_3ae->end(), states_539.begin(), states_539.end());
	_dst_3af->insert( _dst_3af->end(), connectorRefs_53c.begin(), connectorRefs_53c.end());
	_trans_3b0->insert( _trans_3b0->end(), transitions_53f.begin(), transitions_53f.end());
	_fcn_3b1->insert( _fcn_3b1->end(), functions_542.begin(), functions_542.end());
	_cb_3b2->insert( _cb_3b2->end(), conditionalBlocks_545.begin(), conditionalBlocks_545.end());
	if( isMatchDstIsJuncRefWithTrans_536)
		return;
	Packets_t states_594;
	Packets_t connectorRefs_597;
	Packets_t transitions_59a;
	Packets_t functions_59d;
	Packets_t conditionalBlocks_5a0;
	DstIsJuncRefWithJuncTrans_591 dstIsJuncRefWithJuncTrans_591;
	bool isMatchDstIsJuncRefWithJuncTrans_591= dstIsJuncRefWithJuncTrans_591( states_37c, dsts_37e, transs_380, fcns_382, cbs_384, states_594, connectorRefs_597, transitions_59a, functions_59d, conditionalBlocks_5a0);
	_state_3ae->insert( _state_3ae->end(), states_594.begin(), states_594.end());
	_dst_3af->insert( _dst_3af->end(), connectorRefs_597.begin(), connectorRefs_597.end());
	_trans_3b0->insert( _trans_3b0->end(), transitions_59a.begin(), transitions_59a.end());
	_fcn_3b1->insert( _fcn_3b1->end(), functions_59d.begin(), functions_59d.end());
	_cb_3b2->insert( _cb_3b2->end(), conditionalBlocks_5a0.begin(), conditionalBlocks_5a0.end());
	if( isMatchDstIsJuncRefWithJuncTrans_591)
		return;
	Packets_t states_5ef;
	Packets_t transConnectors_5f2;
	Packets_t transitions_5f5;
	Packets_t functions_5f8;
	Packets_t conditionalBlocks_5fb;
	DeadEnd_5ec deadEnd_5ec;
	bool isMatchDeadEnd_5ec= deadEnd_5ec( states_37c, dsts_37e, transs_380, fcns_382, cbs_384, states_5ef, transConnectors_5f2, transitions_5f5, functions_5f8, conditionalBlocks_5fb);
	_state_3b3->insert( _state_3b3->end(), states_5ef.begin(), states_5ef.end());
	_dst_3b4->insert( _dst_3b4->end(), transConnectors_5f2.begin(), transConnectors_5f2.end());
	_trans_3b5->insert( _trans_3b5->end(), transitions_5f5.begin(), transitions_5f5.end());
	_fcn_3b6->insert( _fcn_3b6->end(), functions_5f8.begin(), functions_5f8.end());
	_cb_3b7->insert( _cb_3b7->end(), conditionalBlocks_5fb.begin(), conditionalBlocks_5fb.end());
	if( isMatchDeadEnd_5ec)
		return;
}

bool Test_37b::isInputUnique( const Udm::Object& state_3ba, const Udm::Object& dst_3c1, const Udm::Object& trans_3c8, const Udm::Object& fcn_3cf, const Udm::Object& cb_3d6)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_3bc= _state_3b8.begin(), itdst_3c3= _dst_3bf.begin(), ittrans_3ca= _trans_3c6.begin(), itfcn_3d1= _fcn_3cd.begin(), itcb_3d8= _cb_3d4.begin(); itstate_3bc!= _state_3b8.end(), itdst_3c3!= _dst_3bf.end(), ittrans_3ca!= _trans_3c6.end(), itfcn_3d1!= _fcn_3cd.end(), itcb_3d8!= _cb_3d4.end(); ++itstate_3bc, ++itdst_3c3, ++ittrans_3ca, ++itfcn_3d1, ++itcb_3d8)
	{
		if( ( *itstate_3bc== state_3ba)&& ( *itdst_3c3== dst_3c1)&& ( *ittrans_3ca== trans_3c8)&& ( *itfcn_3d1== fcn_3cf)&& ( *itcb_3d8== cb_3d6))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_3b8.push_back( state_3ba);
		_dst_3bf.push_back( dst_3c1);
		_trans_3c6.push_back( trans_3c8);
		_fcn_3cd.push_back( fcn_3cf);
		_cb_3d4.push_back( cb_3d6);
	}
	return isUnique;
}

bool DstIsState_3db::operator()( const Packets_t& states_3dc, const Packets_t& dstStates_3df, const Packets_t& transitions_3e2, const Packets_t& functions_3e5, const Packets_t& conditionalBlocks_3e8, Packets_t& states_3de, Packets_t& dstStates_3e1, Packets_t& transitions_3e4, Packets_t& functions_3e7, Packets_t& conditionalBlocks_3ea)
{
#ifdef PRINT_INFO
	printLog( "DstIsState_3db" );
#endif
	_state_3eb= &states_3de;
	_dstState_3ec= &dstStates_3e1;
	_transition_3ed= &transitions_3e4;
	_function_3ee= &functions_3e7;
	_conditionalBlock_3ef= &conditionalBlocks_3ea;
	processInputPackets( states_3dc, dstStates_3df, transitions_3e2, functions_3e5, conditionalBlocks_3e8);
	if( false== _matches.empty())
		return true;
	return false;
}

bool DstIsState_3db::isInputUnique( const Udm::Object& state_3f4, const Udm::Object& dstState_3fd, const Udm::Object& transition_406, const Udm::Object& function_40f, const Udm::Object& conditionalBlock_418)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_3f6= _state_3f0.begin(), itDstState_3ff= _dstState_3f9.begin(), itTransition_408= _transition_402.begin(), itFunction_411= _function_40b.begin(), itConditionalBlock_41a= _conditionalBlock_414.begin(); itState_3f6!= _state_3f0.end(), itDstState_3ff!= _dstState_3f9.end(), itTransition_408!= _transition_402.end(), itFunction_411!= _function_40b.end(), itConditionalBlock_41a!= _conditionalBlock_414.end(); ++itState_3f6, ++itDstState_3ff, ++itTransition_408, ++itFunction_411, ++itConditionalBlock_41a)
	{
		if( ( *itState_3f6== state_3f4)&& ( *itDstState_3ff== dstState_3fd)&& ( *itTransition_408== transition_406)&& ( *itFunction_411== function_40f)&& ( *itConditionalBlock_41a== conditionalBlock_418))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_3f0.push_back( state_3f4);
		_dstState_3f9.push_back( dstState_3fd);
		_transition_402.push_back( transition_406);
		_function_40b.push_back( function_40f);
		_conditionalBlock_414.push_back( conditionalBlock_418);
	}
	return isUnique;
}

void DstIsState_3db::processInputPackets( const Packets_t& states_3dc, const Packets_t& dstStates_3df, const Packets_t& transitions_3e2, const Packets_t& functions_3e5, const Packets_t& conditionalBlocks_3e8)
{
	for( Packets_t::const_iterator itState_3f1= states_3dc.begin(), itDstState_3fa= dstStates_3df.begin(), itTransition_403= transitions_3e2.begin(), itFunction_40c= functions_3e5.begin(), itConditionalBlock_415= conditionalBlocks_3e8.begin(); itState_3f1!= states_3dc.end(), itDstState_3fa!= dstStates_3df.end(), itTransition_403!= transitions_3e2.end(), itFunction_40c!= functions_3e5.end(), itConditionalBlock_415!= conditionalBlocks_3e8.end(); ++itState_3f1, ++itDstState_3fa, ++itTransition_403, ++itFunction_40c, ++itConditionalBlock_415)
	{
		bool isUnique= isInputUnique( *itState_3f1, *itDstState_3fa, *itTransition_403, *itFunction_40c, *itConditionalBlock_415);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_3f1, *itDstState_3fa, *itTransition_403, *itFunction_40c, *itConditionalBlock_415);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_41e, currMatch.dstState_41f, currMatch.transition_420, currMatch.function_421, currMatch.conditionalBlock_422);
	}
}

bool DstIsState_3db::patternMatcher( const Udm::Object& state_3f2, const Udm::Object& dstState_3fb, const Udm::Object& transition_404, const Udm::Object& function_40d, const Udm::Object& conditionalBlock_416)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_3f2.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_3f7= CyberComposition::Simulink::State::Cast( state_3f2);
		if( false== Uml::IsDerivedFrom( dstState_3fb.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State dstState_400= CyberComposition::Simulink::State::Cast( dstState_3fb);
		if( false== Uml::IsDerivedFrom( transition_404.type(), CyberComposition::Simulink::Transition::meta))
			continue;
		CyberComposition::Simulink::Transition transition_409= CyberComposition::Simulink::Transition::Cast( transition_404);
		if( false== Uml::IsDerivedFrom( function_40d.type(), SFC::Function::meta))
			continue;
		SFC::Function function_412= SFC::Function::Cast( function_40d);
		if( false== Uml::IsDerivedFrom( conditionalBlock_416.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlock_41b= SFC::ConditionalBlock::Cast( conditionalBlock_416);
		Match currMatch;
		currMatch.state_41e= state_3f7;
		currMatch.dstState_41f= dstState_400;
		currMatch.transition_420= transition_409;
		currMatch.function_421= function_412;
		currMatch.conditionalBlock_422= conditionalBlock_41b;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void DstIsState_3db::outputAppender( const CyberComposition::Simulink::State& state_423, const CyberComposition::Simulink::State& dstState_425, const CyberComposition::Simulink::Transition& transition_427, const SFC::Function& function_429, const SFC::ConditionalBlock& conditionalBlock_42b)
{
	_state_3eb->push_back( state_423);
	_dstState_3ec->push_back( dstState_425);
	_transition_3ed->push_back( transition_427);
	_function_3ee->push_back( function_429);
	_conditionalBlock_3ef->push_back( conditionalBlock_42b);
}

bool DstIsRefState_42d::operator()( const Packets_t& states_42e, const Packets_t& connectorRefs_431, const Packets_t& transitions_434, const Packets_t& functions_437, const Packets_t& conditionalBlocks_43a, Packets_t& states_430, Packets_t& connectorRefs_433, Packets_t& transitions_436, Packets_t& functions_439, Packets_t& conditionalBlocks_43c)
{
#ifdef PRINT_INFO
	printLog( "DstIsRefState_42d" );
#endif
	_state_43d= &states_430;
	_connectorRef_43e= &connectorRefs_433;
	_transition_43f= &transitions_436;
	_function_440= &functions_439;
	_conditionalBlock_441= &conditionalBlocks_43c;
	processInputPackets( states_42e, connectorRefs_431, transitions_434, functions_437, conditionalBlocks_43a);
	if( false== _matches.empty())
		return true;
	return false;
}

bool DstIsRefState_42d::isInputUnique( const Udm::Object& state_446, const Udm::Object& connectorRef_44f, const Udm::Object& transition_458, const Udm::Object& function_461, const Udm::Object& conditionalBlock_46a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_448= _state_442.begin(), itConnectorRef_451= _connectorRef_44b.begin(), itTransition_45a= _transition_454.begin(), itFunction_463= _function_45d.begin(), itConditionalBlock_46c= _conditionalBlock_466.begin(); itState_448!= _state_442.end(), itConnectorRef_451!= _connectorRef_44b.end(), itTransition_45a!= _transition_454.end(), itFunction_463!= _function_45d.end(), itConditionalBlock_46c!= _conditionalBlock_466.end(); ++itState_448, ++itConnectorRef_451, ++itTransition_45a, ++itFunction_463, ++itConditionalBlock_46c)
	{
		if( ( *itState_448== state_446)&& ( *itConnectorRef_451== connectorRef_44f)&& ( *itTransition_45a== transition_458)&& ( *itFunction_463== function_461)&& ( *itConditionalBlock_46c== conditionalBlock_46a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_442.push_back( state_446);
		_connectorRef_44b.push_back( connectorRef_44f);
		_transition_454.push_back( transition_458);
		_function_45d.push_back( function_461);
		_conditionalBlock_466.push_back( conditionalBlock_46a);
	}
	return isUnique;
}

void DstIsRefState_42d::processInputPackets( const Packets_t& states_42e, const Packets_t& connectorRefs_431, const Packets_t& transitions_434, const Packets_t& functions_437, const Packets_t& conditionalBlocks_43a)
{
	for( Packets_t::const_iterator itState_443= states_42e.begin(), itConnectorRef_44c= connectorRefs_431.begin(), itTransition_455= transitions_434.begin(), itFunction_45e= functions_437.begin(), itConditionalBlock_467= conditionalBlocks_43a.begin(); itState_443!= states_42e.end(), itConnectorRef_44c!= connectorRefs_431.end(), itTransition_455!= transitions_434.end(), itFunction_45e!= functions_437.end(), itConditionalBlock_467!= conditionalBlocks_43a.end(); ++itState_443, ++itConnectorRef_44c, ++itTransition_455, ++itFunction_45e, ++itConditionalBlock_467)
	{
		bool isUnique= isInputUnique( *itState_443, *itConnectorRef_44c, *itTransition_455, *itFunction_45e, *itConditionalBlock_467);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_443, *itConnectorRef_44c, *itTransition_455, *itFunction_45e, *itConditionalBlock_467);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_472, currMatch.connectorRef_473, currMatch.transition_474, currMatch.function_475, currMatch.conditionalBlock_476);
	}
}

bool DstIsRefState_42d::patternMatcher( const Udm::Object& state_444, const Udm::Object& connectorRef_44d, const Udm::Object& transition_456, const Udm::Object& function_45f, const Udm::Object& conditionalBlock_468)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_444.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_449= CyberComposition::Simulink::State::Cast( state_444);
		if( false== Uml::IsDerivedFrom( connectorRef_44d.type(), CyberComposition::Simulink::ConnectorRef::meta))
			continue;
		CyberComposition::Simulink::ConnectorRef connectorRef_452= CyberComposition::Simulink::ConnectorRef::Cast( connectorRef_44d);
		if( false== Uml::IsDerivedFrom( transition_456.type(), CyberComposition::Simulink::Transition::meta))
			continue;
		CyberComposition::Simulink::Transition transition_45b= CyberComposition::Simulink::Transition::Cast( transition_456);
		if( false== Uml::IsDerivedFrom( function_45f.type(), SFC::Function::meta))
			continue;
		SFC::Function function_464= SFC::Function::Cast( function_45f);
		if( false== Uml::IsDerivedFrom( conditionalBlock_468.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlock_46d= SFC::ConditionalBlock::Cast( conditionalBlock_468);
		CyberComposition::Simulink::TransConnector dstState_46f= connectorRef_452.ref();
		if( false== Uml::IsDerivedFrom( dstState_46f.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State dstState_470= CyberComposition::Simulink::State::Cast( dstState_46f);
		if( !dstState_470)
			continue;
		Match currMatch;
		currMatch.state_472= state_449;
		currMatch.connectorRef_473= connectorRef_452;
		currMatch.transition_474= transition_45b;
		currMatch.function_475= function_464;
		currMatch.conditionalBlock_476= conditionalBlock_46d;
		currMatch.dstState_477= dstState_470;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void DstIsRefState_42d::outputAppender( const CyberComposition::Simulink::State& state_478, const CyberComposition::Simulink::ConnectorRef& connectorRef_47a, const CyberComposition::Simulink::Transition& transition_47c, const SFC::Function& function_47e, const SFC::ConditionalBlock& conditionalBlock_480)
{
	_state_43d->push_back( state_478);
	_connectorRef_43e->push_back( connectorRef_47a);
	_transition_43f->push_back( transition_47c);
	_function_440->push_back( function_47e);
	_conditionalBlock_441->push_back( conditionalBlock_480);
}

bool DstIsJuncWithTrans_482::operator()( const Packets_t& states_483, const Packets_t& junctions_486, const Packets_t& transitions_489, const Packets_t& functions_48c, const Packets_t& conditionalBlocks_48f, Packets_t& states_485, Packets_t& junctions_488, Packets_t& transitions_48b, Packets_t& functions_48e, Packets_t& conditionalBlocks_491)
{
#ifdef PRINT_INFO
	printLog( "DstIsJuncWithTrans_482" );
#endif
	_state_492= &states_485;
	_junction_493= &junctions_488;
	_transition_494= &transitions_48b;
	_function_495= &functions_48e;
	_conditionalBlock_496= &conditionalBlocks_491;
	processInputPackets( states_483, junctions_486, transitions_489, functions_48c, conditionalBlocks_48f);
	if( false== _matches.empty())
		return true;
	return false;
}

bool DstIsJuncWithTrans_482::isInputUnique( const Udm::Object& state_49b, const Udm::Object& junction_4a4, const Udm::Object& transition_4ad, const Udm::Object& function_4b6, const Udm::Object& conditionalBlock_4bf)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_49d= _state_497.begin(), itJunction_4a6= _junction_4a0.begin(), itTransition_4af= _transition_4a9.begin(), itFunction_4b8= _function_4b2.begin(), itConditionalBlock_4c1= _conditionalBlock_4bb.begin(); itState_49d!= _state_497.end(), itJunction_4a6!= _junction_4a0.end(), itTransition_4af!= _transition_4a9.end(), itFunction_4b8!= _function_4b2.end(), itConditionalBlock_4c1!= _conditionalBlock_4bb.end(); ++itState_49d, ++itJunction_4a6, ++itTransition_4af, ++itFunction_4b8, ++itConditionalBlock_4c1)
	{
		if( ( *itState_49d== state_49b)&& ( *itJunction_4a6== junction_4a4)&& ( *itTransition_4af== transition_4ad)&& ( *itFunction_4b8== function_4b6)&& ( *itConditionalBlock_4c1== conditionalBlock_4bf))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_497.push_back( state_49b);
		_junction_4a0.push_back( junction_4a4);
		_transition_4a9.push_back( transition_4ad);
		_function_4b2.push_back( function_4b6);
		_conditionalBlock_4bb.push_back( conditionalBlock_4bf);
	}
	return isUnique;
}

void DstIsJuncWithTrans_482::processInputPackets( const Packets_t& states_483, const Packets_t& junctions_486, const Packets_t& transitions_489, const Packets_t& functions_48c, const Packets_t& conditionalBlocks_48f)
{
	for( Packets_t::const_iterator itState_498= states_483.begin(), itJunction_4a1= junctions_486.begin(), itTransition_4aa= transitions_489.begin(), itFunction_4b3= functions_48c.begin(), itConditionalBlock_4bc= conditionalBlocks_48f.begin(); itState_498!= states_483.end(), itJunction_4a1!= junctions_486.end(), itTransition_4aa!= transitions_489.end(), itFunction_4b3!= functions_48c.end(), itConditionalBlock_4bc!= conditionalBlocks_48f.end(); ++itState_498, ++itJunction_4a1, ++itTransition_4aa, ++itFunction_4b3, ++itConditionalBlock_4bc)
	{
		bool isUnique= isInputUnique( *itState_498, *itJunction_4a1, *itTransition_4aa, *itFunction_4b3, *itConditionalBlock_4bc);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_498, *itJunction_4a1, *itTransition_4aa, *itFunction_4b3, *itConditionalBlock_4bc);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_4c9, currMatch.junction_4ca, currMatch.transition_4cb, currMatch.function_4cc, currMatch.conditionalBlock_4cd);
	}
}

bool DstIsJuncWithTrans_482::patternMatcher( const Udm::Object& state_499, const Udm::Object& junction_4a2, const Udm::Object& transition_4ab, const Udm::Object& function_4b4, const Udm::Object& conditionalBlock_4bd)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_499.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_49e= CyberComposition::Simulink::State::Cast( state_499);
		if( false== Uml::IsDerivedFrom( junction_4a2.type(), CyberComposition::Simulink::SF_Junction::meta))
			continue;
		CyberComposition::Simulink::SF_Junction junction_4a7= CyberComposition::Simulink::SF_Junction::Cast( junction_4a2);
		if( false== Uml::IsDerivedFrom( transition_4ab.type(), CyberComposition::Simulink::Transition::meta))
			continue;
		CyberComposition::Simulink::Transition transition_4b0= CyberComposition::Simulink::Transition::Cast( transition_4ab);
		if( false== Uml::IsDerivedFrom( function_4b4.type(), SFC::Function::meta))
			continue;
		SFC::Function function_4b9= SFC::Function::Cast( function_4b4);
		if( false== Uml::IsDerivedFrom( conditionalBlock_4bd.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlock_4c2= SFC::ConditionalBlock::Cast( conditionalBlock_4bd);
		set< CyberComposition::Simulink::Transition> transition2s_4c4= junction_4a7.dstTransition();
		for( set< CyberComposition::Simulink::Transition>::const_iterator itTransition2s_4c5= transition2s_4c4.begin(); itTransition2s_4c5!= transition2s_4c4.end(); ++itTransition2s_4c5)
		{
			CyberComposition::Simulink::Transition currTransition2_4c6= *itTransition2s_4c5;
			CyberComposition::Simulink::TransConnector transConnector_4c7= currTransition2_4c6.dstTransition_end();
			Match currMatch;
			currMatch.state_4c9= state_49e;
			currMatch.junction_4ca= junction_4a7;
			currMatch.transition_4cb= transition_4b0;
			currMatch.function_4cc= function_4b9;
			currMatch.conditionalBlock_4cd= conditionalBlock_4c2;
			currMatch.transition2_4ce= currTransition2_4c6;
			currMatch.transConnector_4cf= transConnector_4c7;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void DstIsJuncWithTrans_482::outputAppender( const CyberComposition::Simulink::State& state_4d0, const CyberComposition::Simulink::SF_Junction& junction_4d2, const CyberComposition::Simulink::Transition& transition_4d4, const SFC::Function& function_4d6, const SFC::ConditionalBlock& conditionalBlock_4d8)
{
	_state_492->push_back( state_4d0);
	_junction_493->push_back( junction_4d2);
	_transition_494->push_back( transition_4d4);
	_function_495->push_back( function_4d6);
	_conditionalBlock_496->push_back( conditionalBlock_4d8);
}

bool DstIsJuncWithRefTrans_4da::operator()( const Packets_t& states_4db, const Packets_t& junctions_4de, const Packets_t& transitions_4e1, const Packets_t& functions_4e4, const Packets_t& conditionalBlocks_4e7, Packets_t& states_4dd, Packets_t& junctions_4e0, Packets_t& transitions_4e3, Packets_t& functions_4e6, Packets_t& conditionalBlocks_4e9)
{
#ifdef PRINT_INFO
	printLog( "DstIsJuncWithRefTrans_4da" );
#endif
	_state_4ea= &states_4dd;
	_junction_4eb= &junctions_4e0;
	_transition_4ec= &transitions_4e3;
	_function_4ed= &functions_4e6;
	_conditionalBlock_4ee= &conditionalBlocks_4e9;
	processInputPackets( states_4db, junctions_4de, transitions_4e1, functions_4e4, conditionalBlocks_4e7);
	if( false== _matches.empty())
		return true;
	return false;
}

bool DstIsJuncWithRefTrans_4da::isInputUnique( const Udm::Object& state_4f3, const Udm::Object& junction_4fc, const Udm::Object& transition_505, const Udm::Object& function_50e, const Udm::Object& conditionalBlock_517)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_4f5= _state_4ef.begin(), itJunction_4fe= _junction_4f8.begin(), itTransition_507= _transition_501.begin(), itFunction_510= _function_50a.begin(), itConditionalBlock_519= _conditionalBlock_513.begin(); itState_4f5!= _state_4ef.end(), itJunction_4fe!= _junction_4f8.end(), itTransition_507!= _transition_501.end(), itFunction_510!= _function_50a.end(), itConditionalBlock_519!= _conditionalBlock_513.end(); ++itState_4f5, ++itJunction_4fe, ++itTransition_507, ++itFunction_510, ++itConditionalBlock_519)
	{
		if( ( *itState_4f5== state_4f3)&& ( *itJunction_4fe== junction_4fc)&& ( *itTransition_507== transition_505)&& ( *itFunction_510== function_50e)&& ( *itConditionalBlock_519== conditionalBlock_517))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_4ef.push_back( state_4f3);
		_junction_4f8.push_back( junction_4fc);
		_transition_501.push_back( transition_505);
		_function_50a.push_back( function_50e);
		_conditionalBlock_513.push_back( conditionalBlock_517);
	}
	return isUnique;
}

void DstIsJuncWithRefTrans_4da::processInputPackets( const Packets_t& states_4db, const Packets_t& junctions_4de, const Packets_t& transitions_4e1, const Packets_t& functions_4e4, const Packets_t& conditionalBlocks_4e7)
{
	for( Packets_t::const_iterator itState_4f0= states_4db.begin(), itJunction_4f9= junctions_4de.begin(), itTransition_502= transitions_4e1.begin(), itFunction_50b= functions_4e4.begin(), itConditionalBlock_514= conditionalBlocks_4e7.begin(); itState_4f0!= states_4db.end(), itJunction_4f9!= junctions_4de.end(), itTransition_502!= transitions_4e1.end(), itFunction_50b!= functions_4e4.end(), itConditionalBlock_514!= conditionalBlocks_4e7.end(); ++itState_4f0, ++itJunction_4f9, ++itTransition_502, ++itFunction_50b, ++itConditionalBlock_514)
	{
		bool isUnique= isInputUnique( *itState_4f0, *itJunction_4f9, *itTransition_502, *itFunction_50b, *itConditionalBlock_514);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_4f0, *itJunction_4f9, *itTransition_502, *itFunction_50b, *itConditionalBlock_514);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_524, currMatch.junction_525, currMatch.transition_526, currMatch.function_527, currMatch.conditionalBlock_528);
	}
}

bool DstIsJuncWithRefTrans_4da::patternMatcher( const Udm::Object& state_4f1, const Udm::Object& junction_4fa, const Udm::Object& transition_503, const Udm::Object& function_50c, const Udm::Object& conditionalBlock_515)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_4f1.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_4f6= CyberComposition::Simulink::State::Cast( state_4f1);
		if( false== Uml::IsDerivedFrom( junction_4fa.type(), CyberComposition::Simulink::SF_Junction::meta))
			continue;
		CyberComposition::Simulink::SF_Junction junction_4ff= CyberComposition::Simulink::SF_Junction::Cast( junction_4fa);
		if( false== Uml::IsDerivedFrom( transition_503.type(), CyberComposition::Simulink::Transition::meta))
			continue;
		CyberComposition::Simulink::Transition transition_508= CyberComposition::Simulink::Transition::Cast( transition_503);
		if( false== Uml::IsDerivedFrom( function_50c.type(), SFC::Function::meta))
			continue;
		SFC::Function function_511= SFC::Function::Cast( function_50c);
		if( false== Uml::IsDerivedFrom( conditionalBlock_515.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlock_51a= SFC::ConditionalBlock::Cast( conditionalBlock_515);
		set< CyberComposition::Simulink::ConnectorRef> connectorRefs_51c= junction_4ff.referedbyConnectorRef();
		for( set< CyberComposition::Simulink::ConnectorRef>::const_iterator itConnectorRefs_51d= connectorRefs_51c.begin(); itConnectorRefs_51d!= connectorRefs_51c.end(); ++itConnectorRefs_51d)
		{
			CyberComposition::Simulink::ConnectorRef currConnectorRef_51e= *itConnectorRefs_51d;
			set< CyberComposition::Simulink::Transition> transition2s_51f= currConnectorRef_51e.dstTransition();
			for( set< CyberComposition::Simulink::Transition>::const_iterator itTransition2s_520= transition2s_51f.begin(); itTransition2s_520!= transition2s_51f.end(); ++itTransition2s_520)
			{
				CyberComposition::Simulink::Transition currTransition2_521= *itTransition2s_520;
				CyberComposition::Simulink::TransConnector transConnector_522= currTransition2_521.dstTransition_end();
				Match currMatch;
				currMatch.state_524= state_4f6;
				currMatch.junction_525= junction_4ff;
				currMatch.transition_526= transition_508;
				currMatch.function_527= function_511;
				currMatch.conditionalBlock_528= conditionalBlock_51a;
				currMatch.connectorRef_529= currConnectorRef_51e;
				currMatch.transition2_52a= currTransition2_521;
				currMatch.transConnector_52b= transConnector_522;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void DstIsJuncWithRefTrans_4da::outputAppender( const CyberComposition::Simulink::State& state_52c, const CyberComposition::Simulink::SF_Junction& junction_52e, const CyberComposition::Simulink::Transition& transition_530, const SFC::Function& function_532, const SFC::ConditionalBlock& conditionalBlock_534)
{
	_state_4ea->push_back( state_52c);
	_junction_4eb->push_back( junction_52e);
	_transition_4ec->push_back( transition_530);
	_function_4ed->push_back( function_532);
	_conditionalBlock_4ee->push_back( conditionalBlock_534);
}

bool DstIsJuncRefWithTrans_536::operator()( const Packets_t& states_537, const Packets_t& connectorRefs_53a, const Packets_t& transitions_53d, const Packets_t& functions_540, const Packets_t& conditionalBlocks_543, Packets_t& states_539, Packets_t& connectorRefs_53c, Packets_t& transitions_53f, Packets_t& functions_542, Packets_t& conditionalBlocks_545)
{
#ifdef PRINT_INFO
	printLog( "DstIsJuncRefWithTrans_536" );
#endif
	_state_546= &states_539;
	_connectorRef_547= &connectorRefs_53c;
	_transition_548= &transitions_53f;
	_function_549= &functions_542;
	_conditionalBlock_54a= &conditionalBlocks_545;
	processInputPackets( states_537, connectorRefs_53a, transitions_53d, functions_540, conditionalBlocks_543);
	if( false== _matches.empty())
		return true;
	return false;
}

bool DstIsJuncRefWithTrans_536::isInputUnique( const Udm::Object& state_54f, const Udm::Object& connectorRef_558, const Udm::Object& transition_561, const Udm::Object& function_56a, const Udm::Object& conditionalBlock_573)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_551= _state_54b.begin(), itConnectorRef_55a= _connectorRef_554.begin(), itTransition_563= _transition_55d.begin(), itFunction_56c= _function_566.begin(), itConditionalBlock_575= _conditionalBlock_56f.begin(); itState_551!= _state_54b.end(), itConnectorRef_55a!= _connectorRef_554.end(), itTransition_563!= _transition_55d.end(), itFunction_56c!= _function_566.end(), itConditionalBlock_575!= _conditionalBlock_56f.end(); ++itState_551, ++itConnectorRef_55a, ++itTransition_563, ++itFunction_56c, ++itConditionalBlock_575)
	{
		if( ( *itState_551== state_54f)&& ( *itConnectorRef_55a== connectorRef_558)&& ( *itTransition_563== transition_561)&& ( *itFunction_56c== function_56a)&& ( *itConditionalBlock_575== conditionalBlock_573))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_54b.push_back( state_54f);
		_connectorRef_554.push_back( connectorRef_558);
		_transition_55d.push_back( transition_561);
		_function_566.push_back( function_56a);
		_conditionalBlock_56f.push_back( conditionalBlock_573);
	}
	return isUnique;
}

void DstIsJuncRefWithTrans_536::processInputPackets( const Packets_t& states_537, const Packets_t& connectorRefs_53a, const Packets_t& transitions_53d, const Packets_t& functions_540, const Packets_t& conditionalBlocks_543)
{
	for( Packets_t::const_iterator itState_54c= states_537.begin(), itConnectorRef_555= connectorRefs_53a.begin(), itTransition_55e= transitions_53d.begin(), itFunction_567= functions_540.begin(), itConditionalBlock_570= conditionalBlocks_543.begin(); itState_54c!= states_537.end(), itConnectorRef_555!= connectorRefs_53a.end(), itTransition_55e!= transitions_53d.end(), itFunction_567!= functions_540.end(), itConditionalBlock_570!= conditionalBlocks_543.end(); ++itState_54c, ++itConnectorRef_555, ++itTransition_55e, ++itFunction_567, ++itConditionalBlock_570)
	{
		bool isUnique= isInputUnique( *itState_54c, *itConnectorRef_555, *itTransition_55e, *itFunction_567, *itConditionalBlock_570);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_54c, *itConnectorRef_555, *itTransition_55e, *itFunction_567, *itConditionalBlock_570);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_57f, currMatch.connectorRef_580, currMatch.transition_581, currMatch.function_582, currMatch.conditionalBlock_583);
	}
}

bool DstIsJuncRefWithTrans_536::patternMatcher( const Udm::Object& state_54d, const Udm::Object& connectorRef_556, const Udm::Object& transition_55f, const Udm::Object& function_568, const Udm::Object& conditionalBlock_571)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_54d.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_552= CyberComposition::Simulink::State::Cast( state_54d);
		if( false== Uml::IsDerivedFrom( connectorRef_556.type(), CyberComposition::Simulink::ConnectorRef::meta))
			continue;
		CyberComposition::Simulink::ConnectorRef connectorRef_55b= CyberComposition::Simulink::ConnectorRef::Cast( connectorRef_556);
		if( false== Uml::IsDerivedFrom( transition_55f.type(), CyberComposition::Simulink::Transition::meta))
			continue;
		CyberComposition::Simulink::Transition transition_564= CyberComposition::Simulink::Transition::Cast( transition_55f);
		if( false== Uml::IsDerivedFrom( function_568.type(), SFC::Function::meta))
			continue;
		SFC::Function function_56d= SFC::Function::Cast( function_568);
		if( false== Uml::IsDerivedFrom( conditionalBlock_571.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlock_576= SFC::ConditionalBlock::Cast( conditionalBlock_571);
		CyberComposition::Simulink::TransConnector junction_578= connectorRef_55b.ref();
		if( false== Uml::IsDerivedFrom( junction_578.type(), CyberComposition::Simulink::SF_Junction::meta))
			continue;
		CyberComposition::Simulink::SF_Junction junction_579= CyberComposition::Simulink::SF_Junction::Cast( junction_578);
		if( !junction_579)
			continue;
		set< CyberComposition::Simulink::Transition> transition2s_57a= connectorRef_55b.dstTransition();
		for( set< CyberComposition::Simulink::Transition>::const_iterator itTransition2s_57b= transition2s_57a.begin(); itTransition2s_57b!= transition2s_57a.end(); ++itTransition2s_57b)
		{
			CyberComposition::Simulink::Transition currTransition2_57c= *itTransition2s_57b;
			CyberComposition::Simulink::TransConnector transConnector_57d= currTransition2_57c.dstTransition_end();
			Match currMatch;
			currMatch.state_57f= state_552;
			currMatch.connectorRef_580= connectorRef_55b;
			currMatch.transition_581= transition_564;
			currMatch.function_582= function_56d;
			currMatch.conditionalBlock_583= conditionalBlock_576;
			currMatch.junction_584= junction_579;
			currMatch.transition2_585= currTransition2_57c;
			currMatch.transConnector_586= transConnector_57d;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void DstIsJuncRefWithTrans_536::outputAppender( const CyberComposition::Simulink::State& state_587, const CyberComposition::Simulink::ConnectorRef& connectorRef_589, const CyberComposition::Simulink::Transition& transition_58b, const SFC::Function& function_58d, const SFC::ConditionalBlock& conditionalBlock_58f)
{
	_state_546->push_back( state_587);
	_connectorRef_547->push_back( connectorRef_589);
	_transition_548->push_back( transition_58b);
	_function_549->push_back( function_58d);
	_conditionalBlock_54a->push_back( conditionalBlock_58f);
}

bool DstIsJuncRefWithJuncTrans_591::operator()( const Packets_t& states_592, const Packets_t& connectorRefs_595, const Packets_t& transitions_598, const Packets_t& functions_59b, const Packets_t& conditionalBlocks_59e, Packets_t& states_594, Packets_t& connectorRefs_597, Packets_t& transitions_59a, Packets_t& functions_59d, Packets_t& conditionalBlocks_5a0)
{
#ifdef PRINT_INFO
	printLog( "DstIsJuncRefWithJuncTrans_591" );
#endif
	_state_5a1= &states_594;
	_connectorRef_5a2= &connectorRefs_597;
	_transition_5a3= &transitions_59a;
	_function_5a4= &functions_59d;
	_conditionalBlock_5a5= &conditionalBlocks_5a0;
	processInputPackets( states_592, connectorRefs_595, transitions_598, functions_59b, conditionalBlocks_59e);
	if( false== _matches.empty())
		return true;
	return false;
}

bool DstIsJuncRefWithJuncTrans_591::isInputUnique( const Udm::Object& state_5aa, const Udm::Object& connectorRef_5b3, const Udm::Object& transition_5bc, const Udm::Object& function_5c5, const Udm::Object& conditionalBlock_5ce)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_5ac= _state_5a6.begin(), itConnectorRef_5b5= _connectorRef_5af.begin(), itTransition_5be= _transition_5b8.begin(), itFunction_5c7= _function_5c1.begin(), itConditionalBlock_5d0= _conditionalBlock_5ca.begin(); itState_5ac!= _state_5a6.end(), itConnectorRef_5b5!= _connectorRef_5af.end(), itTransition_5be!= _transition_5b8.end(), itFunction_5c7!= _function_5c1.end(), itConditionalBlock_5d0!= _conditionalBlock_5ca.end(); ++itState_5ac, ++itConnectorRef_5b5, ++itTransition_5be, ++itFunction_5c7, ++itConditionalBlock_5d0)
	{
		if( ( *itState_5ac== state_5aa)&& ( *itConnectorRef_5b5== connectorRef_5b3)&& ( *itTransition_5be== transition_5bc)&& ( *itFunction_5c7== function_5c5)&& ( *itConditionalBlock_5d0== conditionalBlock_5ce))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_5a6.push_back( state_5aa);
		_connectorRef_5af.push_back( connectorRef_5b3);
		_transition_5b8.push_back( transition_5bc);
		_function_5c1.push_back( function_5c5);
		_conditionalBlock_5ca.push_back( conditionalBlock_5ce);
	}
	return isUnique;
}

void DstIsJuncRefWithJuncTrans_591::processInputPackets( const Packets_t& states_592, const Packets_t& connectorRefs_595, const Packets_t& transitions_598, const Packets_t& functions_59b, const Packets_t& conditionalBlocks_59e)
{
	for( Packets_t::const_iterator itState_5a7= states_592.begin(), itConnectorRef_5b0= connectorRefs_595.begin(), itTransition_5b9= transitions_598.begin(), itFunction_5c2= functions_59b.begin(), itConditionalBlock_5cb= conditionalBlocks_59e.begin(); itState_5a7!= states_592.end(), itConnectorRef_5b0!= connectorRefs_595.end(), itTransition_5b9!= transitions_598.end(), itFunction_5c2!= functions_59b.end(), itConditionalBlock_5cb!= conditionalBlocks_59e.end(); ++itState_5a7, ++itConnectorRef_5b0, ++itTransition_5b9, ++itFunction_5c2, ++itConditionalBlock_5cb)
	{
		bool isUnique= isInputUnique( *itState_5a7, *itConnectorRef_5b0, *itTransition_5b9, *itFunction_5c2, *itConditionalBlock_5cb);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_5a7, *itConnectorRef_5b0, *itTransition_5b9, *itFunction_5c2, *itConditionalBlock_5cb);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_5da, currMatch.connectorRef_5db, currMatch.transition_5dc, currMatch.function_5dd, currMatch.conditionalBlock_5de);
	}
}

bool DstIsJuncRefWithJuncTrans_591::patternMatcher( const Udm::Object& state_5a8, const Udm::Object& connectorRef_5b1, const Udm::Object& transition_5ba, const Udm::Object& function_5c3, const Udm::Object& conditionalBlock_5cc)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_5a8.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_5ad= CyberComposition::Simulink::State::Cast( state_5a8);
		if( false== Uml::IsDerivedFrom( connectorRef_5b1.type(), CyberComposition::Simulink::ConnectorRef::meta))
			continue;
		CyberComposition::Simulink::ConnectorRef connectorRef_5b6= CyberComposition::Simulink::ConnectorRef::Cast( connectorRef_5b1);
		if( false== Uml::IsDerivedFrom( transition_5ba.type(), CyberComposition::Simulink::Transition::meta))
			continue;
		CyberComposition::Simulink::Transition transition_5bf= CyberComposition::Simulink::Transition::Cast( transition_5ba);
		if( false== Uml::IsDerivedFrom( function_5c3.type(), SFC::Function::meta))
			continue;
		SFC::Function function_5c8= SFC::Function::Cast( function_5c3);
		if( false== Uml::IsDerivedFrom( conditionalBlock_5cc.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlock_5d1= SFC::ConditionalBlock::Cast( conditionalBlock_5cc);
		CyberComposition::Simulink::TransConnector junction_5d3= connectorRef_5b6.ref();
		if( false== Uml::IsDerivedFrom( junction_5d3.type(), CyberComposition::Simulink::SF_Junction::meta))
			continue;
		CyberComposition::Simulink::SF_Junction junction_5d4= CyberComposition::Simulink::SF_Junction::Cast( junction_5d3);
		if( !junction_5d4)
			continue;
		set< CyberComposition::Simulink::Transition> transition2s_5d5= junction_5d4.dstTransition();
		for( set< CyberComposition::Simulink::Transition>::const_iterator itTransition2s_5d6= transition2s_5d5.begin(); itTransition2s_5d6!= transition2s_5d5.end(); ++itTransition2s_5d6)
		{
			CyberComposition::Simulink::Transition currTransition2_5d7= *itTransition2s_5d6;
			CyberComposition::Simulink::TransConnector transConnector_5d8= currTransition2_5d7.dstTransition_end();
			Match currMatch;
			currMatch.state_5da= state_5ad;
			currMatch.connectorRef_5db= connectorRef_5b6;
			currMatch.transition_5dc= transition_5bf;
			currMatch.function_5dd= function_5c8;
			currMatch.conditionalBlock_5de= conditionalBlock_5d1;
			currMatch.junction_5df= junction_5d4;
			currMatch.transition2_5e0= currTransition2_5d7;
			currMatch.transConnector_5e1= transConnector_5d8;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void DstIsJuncRefWithJuncTrans_591::outputAppender( const CyberComposition::Simulink::State& state_5e2, const CyberComposition::Simulink::ConnectorRef& connectorRef_5e4, const CyberComposition::Simulink::Transition& transition_5e6, const SFC::Function& function_5e8, const SFC::ConditionalBlock& conditionalBlock_5ea)
{
	_state_5a1->push_back( state_5e2);
	_connectorRef_5a2->push_back( connectorRef_5e4);
	_transition_5a3->push_back( transition_5e6);
	_function_5a4->push_back( function_5e8);
	_conditionalBlock_5a5->push_back( conditionalBlock_5ea);
}

bool DeadEnd_5ec::operator()( const Packets_t& states_5ed, const Packets_t& transConnectors_5f0, const Packets_t& transitions_5f3, const Packets_t& functions_5f6, const Packets_t& conditionalBlocks_5f9, Packets_t& states_5ef, Packets_t& transConnectors_5f2, Packets_t& transitions_5f5, Packets_t& functions_5f8, Packets_t& conditionalBlocks_5fb)
{
#ifdef PRINT_INFO
	printLog( "DeadEnd_5ec" );
#endif
	_state_5fc= &states_5ef;
	_transConnector_5fd= &transConnectors_5f2;
	_transition_5fe= &transitions_5f5;
	_function_5ff= &functions_5f8;
	_conditionalBlock_600= &conditionalBlocks_5fb;
	processInputPackets( states_5ed, transConnectors_5f0, transitions_5f3, functions_5f6, conditionalBlocks_5f9);
	if( false== _matches.empty())
		return true;
	return false;
}

bool DeadEnd_5ec::isInputUnique( const Udm::Object& state_605, const Udm::Object& transConnector_60e, const Udm::Object& transition_617, const Udm::Object& function_620, const Udm::Object& conditionalBlock_629)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_607= _state_601.begin(), itTransConnector_610= _transConnector_60a.begin(), itTransition_619= _transition_613.begin(), itFunction_622= _function_61c.begin(), itConditionalBlock_62b= _conditionalBlock_625.begin(); itState_607!= _state_601.end(), itTransConnector_610!= _transConnector_60a.end(), itTransition_619!= _transition_613.end(), itFunction_622!= _function_61c.end(), itConditionalBlock_62b!= _conditionalBlock_625.end(); ++itState_607, ++itTransConnector_610, ++itTransition_619, ++itFunction_622, ++itConditionalBlock_62b)
	{
		if( ( *itState_607== state_605)&& ( *itTransConnector_610== transConnector_60e)&& ( *itTransition_619== transition_617)&& ( *itFunction_622== function_620)&& ( *itConditionalBlock_62b== conditionalBlock_629))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_601.push_back( state_605);
		_transConnector_60a.push_back( transConnector_60e);
		_transition_613.push_back( transition_617);
		_function_61c.push_back( function_620);
		_conditionalBlock_625.push_back( conditionalBlock_629);
	}
	return isUnique;
}

void DeadEnd_5ec::processInputPackets( const Packets_t& states_5ed, const Packets_t& transConnectors_5f0, const Packets_t& transitions_5f3, const Packets_t& functions_5f6, const Packets_t& conditionalBlocks_5f9)
{
	for( Packets_t::const_iterator itState_602= states_5ed.begin(), itTransConnector_60b= transConnectors_5f0.begin(), itTransition_614= transitions_5f3.begin(), itFunction_61d= functions_5f6.begin(), itConditionalBlock_626= conditionalBlocks_5f9.begin(); itState_602!= states_5ed.end(), itTransConnector_60b!= transConnectors_5f0.end(), itTransition_614!= transitions_5f3.end(), itFunction_61d!= functions_5f6.end(), itConditionalBlock_626!= conditionalBlocks_5f9.end(); ++itState_602, ++itTransConnector_60b, ++itTransition_614, ++itFunction_61d, ++itConditionalBlock_626)
	{
		bool isUnique= isInputUnique( *itState_602, *itTransConnector_60b, *itTransition_614, *itFunction_61d, *itConditionalBlock_626);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_602, *itTransConnector_60b, *itTransition_614, *itFunction_61d, *itConditionalBlock_626);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_62f, currMatch.transConnector_630, currMatch.transition_631, currMatch.function_632, currMatch.conditionalBlock_633);
	}
}

bool DeadEnd_5ec::patternMatcher( const Udm::Object& state_603, const Udm::Object& transConnector_60c, const Udm::Object& transition_615, const Udm::Object& function_61e, const Udm::Object& conditionalBlock_627)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_603.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_608= CyberComposition::Simulink::State::Cast( state_603);
		if( false== Uml::IsDerivedFrom( transConnector_60c.type(), CyberComposition::Simulink::TransConnector::meta))
			continue;
		CyberComposition::Simulink::TransConnector transConnector_611= CyberComposition::Simulink::TransConnector::Cast( transConnector_60c);
		if( false== Uml::IsDerivedFrom( transition_615.type(), CyberComposition::Simulink::Transition::meta))
			continue;
		CyberComposition::Simulink::Transition transition_61a= CyberComposition::Simulink::Transition::Cast( transition_615);
		if( false== Uml::IsDerivedFrom( function_61e.type(), SFC::Function::meta))
			continue;
		SFC::Function function_623= SFC::Function::Cast( function_61e);
		if( false== Uml::IsDerivedFrom( conditionalBlock_627.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlock_62c= SFC::ConditionalBlock::Cast( conditionalBlock_627);
		Match currMatch;
		currMatch.state_62f= state_608;
		currMatch.transConnector_630= transConnector_611;
		currMatch.transition_631= transition_61a;
		currMatch.function_632= function_623;
		currMatch.conditionalBlock_633= conditionalBlock_62c;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void DeadEnd_5ec::outputAppender( const CyberComposition::Simulink::State& state_634, const CyberComposition::Simulink::TransConnector& transConnector_636, const CyberComposition::Simulink::Transition& transition_638, const SFC::Function& function_63a, const SFC::ConditionalBlock& conditionalBlock_63c)
{
	_state_5fc->push_back( state_634);
	_transConnector_5fd->push_back( transConnector_636);
	_transition_5fe->push_back( transition_638);
	_function_5ff->push_back( function_63a);
	_conditionalBlock_600->push_back( conditionalBlock_63c);
}

void OrderTransitions_63e::operator()( const Packets_t& states_63f, const Packets_t& transitions_642, const Packets_t& functions_645, const Packets_t& compoundStatements_648, Packets_t& states_641, Packets_t& transitions_644, Packets_t& functions_647, Packets_t& compoundStatements_64a)
{
#ifdef PRINT_INFO
	printLog( "OrderTransitions_63e" );
#endif
	RTTGenerator::Instance()->generateRule(2455, "OrderTransitions");
	_state_64b= &states_641;
	_transition_64c= &transitions_644;
	_function_64d= &functions_647;
	_compoundStatement_64e= &compoundStatements_64a;
	processInputPackets( states_63f, transitions_642, functions_645, compoundStatements_648);
	sortOutputs( );
}

bool OrderTransitions_63e::isInputUnique( const Udm::Object& state_653, const Udm::Object& transition_65c, const Udm::Object& function_665, const Udm::Object& compoundStatement_66e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_655= _state_64f.begin(), itTransition_65e= _transition_658.begin(), itFunction_667= _function_661.begin(), itCompoundStatement_670= _compoundStatement_66a.begin(); itState_655!= _state_64f.end(), itTransition_65e!= _transition_658.end(), itFunction_667!= _function_661.end(), itCompoundStatement_670!= _compoundStatement_66a.end(); ++itState_655, ++itTransition_65e, ++itFunction_667, ++itCompoundStatement_670)
	{
		if( ( *itState_655== state_653)&& ( *itTransition_65e== transition_65c)&& ( *itFunction_667== function_665)&& ( *itCompoundStatement_670== compoundStatement_66e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_64f.push_back( state_653);
		_transition_658.push_back( transition_65c);
		_function_661.push_back( function_665);
		_compoundStatement_66a.push_back( compoundStatement_66e);
	}
	return isUnique;
}

void OrderTransitions_63e::processInputPackets( const Packets_t& states_63f, const Packets_t& transitions_642, const Packets_t& functions_645, const Packets_t& compoundStatements_648)
{
	for( Packets_t::const_iterator itState_650= states_63f.begin(), itTransition_659= transitions_642.begin(), itFunction_662= functions_645.begin(), itCompoundStatement_66b= compoundStatements_648.begin(); itState_650!= states_63f.end(), itTransition_659!= transitions_642.end(), itFunction_662!= functions_645.end(), itCompoundStatement_66b!= compoundStatements_648.end(); ++itState_650, ++itTransition_659, ++itFunction_662, ++itCompoundStatement_66b)
	{
		bool isUnique= isInputUnique( *itState_650, *itTransition_659, *itFunction_662, *itCompoundStatement_66b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_650, *itTransition_659, *itFunction_662, *itCompoundStatement_66b);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool OrderTransitions_63e::patternMatcher( const Udm::Object& state_651, const Udm::Object& transition_65a, const Udm::Object& function_663, const Udm::Object& compoundStatement_66c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_651.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_656= CyberComposition::Simulink::State::Cast( state_651);
		if( false== Uml::IsDerivedFrom( transition_65a.type(), CyberComposition::Simulink::Transition::meta))
			continue;
		CyberComposition::Simulink::Transition transition_65f= CyberComposition::Simulink::Transition::Cast( transition_65a);
		if( false== Uml::IsDerivedFrom( function_663.type(), SFC::Function::meta))
			continue;
		SFC::Function function_668= SFC::Function::Cast( function_663);
		if( false== Uml::IsDerivedFrom( compoundStatement_66c.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_671= SFC::CompoundStatement::Cast( compoundStatement_66c);
		Match currMatch;
		currMatch.state_674= state_656;
		currMatch.transition_675= transition_65f;
		currMatch.function_676= function_668;
		currMatch.compoundStatement_677= compoundStatement_671;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void OrderTransitions_63e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_674, currMatch.transition_675, currMatch.function_676, currMatch.compoundStatement_677);
	}
}

void OrderTransitions_63e::outputAppender( const CyberComposition::Simulink::State& state_678, const CyberComposition::Simulink::Transition& transition_67a, const SFC::Function& function_67c, const SFC::CompoundStatement& compoundStatement_67e)
{
	_state_64b->push_back( state_678);
	_transition_64c->push_back( transition_67a);
	_function_64d->push_back( function_67c);
	_compoundStatement_64e->push_back( compoundStatement_67e);
}

void OrderTransitions_63e::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::Transition, std::pointer_to_binary_function< const CyberComposition::Simulink::Transition&, const CyberComposition::Simulink::Transition&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::Transition&, const CyberComposition::Simulink::Transition&, bool> ptr_TransitionOrder( TransitionOrder< CyberComposition::Simulink::Transition>);
	SortedSet_t sortedSet( ptr_TransitionOrder);
	std::vector< int> permutationVector( _transition_64c->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _transition_64c->begin(); it!= _transition_64c->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::Transition::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _transition_64c->begin());
	// order rest of the containers
	permutate( permutationVector, *_state_64b);
	permutate( permutationVector, *_function_64d);
	permutate( permutationVector, *_compoundStatement_64e);
}

void GetAllTransitions_6b3::operator()( const Packets_t& states_6b4, const Packets_t& tcs_6b6, const Packets_t& fcns_6b8, const Packets_t& css_6ba, Packets_t& states_6bc, Packets_t& transs_6bd, Packets_t& fcns_6be, Packets_t& css_6bf)
{
#ifdef PRINT_INFO
	printLog( "GetAllTransitions_6b3" );
#endif
	_state_6c0= &states_6bc;
	_trans_6c1= &transs_6bd;
	_fcn_6c2= &fcns_6be;
	_cs_6c3= &css_6bf;
	if( ( !states_6b4.empty())&& ( !tcs_6b6.empty())&& ( !fcns_6b8.empty())&& ( !css_6ba.empty()))
		callGetTransitionsFromJunctionRefs_7af( states_6b4, tcs_6b6, fcns_6b8, css_6ba);
	if( ( !states_6b4.empty())&& ( !tcs_6b6.empty())&& ( !fcns_6b8.empty())&& ( !css_6ba.empty()))
		callGetDirectTransitions_7b4( states_6b4, tcs_6b6, fcns_6b8, css_6ba);
	if( ( !states_6b4.empty())&& ( !tcs_6b6.empty())&& ( !fcns_6b8.empty())&& ( !css_6ba.empty()))
		callGetTransitionsFromStateRefs_7b9( states_6b4, tcs_6b6, fcns_6b8, css_6ba);
}

void GetAllTransitions_6b3::callGetTransitionsFromJunctionRefs_7af( const Packets_t& states_6c5, const Packets_t& junctions_6c9, const Packets_t& functions_6cb, const Packets_t& compoundStatements_6ce)
{
	Packets_t states_6c7;
	Packets_t transitions_6c8;
	Packets_t functions_6cd;
	Packets_t compoundStatements_6d0;
	GetTransitionsFromJunctionRefs_6c4 getTransitionsFromJunctionRefs_6c4;
	getTransitionsFromJunctionRefs_6c4( states_6c5, junctions_6c9, functions_6cb, compoundStatements_6ce, states_6c7, transitions_6c8, functions_6cd, compoundStatements_6d0);
	_state_6c0->insert( _state_6c0->end(), states_6c7.begin(), states_6c7.end());
	_trans_6c1->insert( _trans_6c1->end(), transitions_6c8.begin(), transitions_6c8.end());
	_fcn_6c2->insert( _fcn_6c2->end(), functions_6cd.begin(), functions_6cd.end());
	_cs_6c3->insert( _cs_6c3->end(), compoundStatements_6d0.begin(), compoundStatements_6d0.end());
}

void GetAllTransitions_6b3::callGetDirectTransitions_7b4( const Packets_t& states_711, const Packets_t& srcTransConnectors_714, const Packets_t& functions_717, const Packets_t& compoundStatements_71a)
{
	Packets_t states_713;
	Packets_t transitions_716;
	Packets_t functions_719;
	Packets_t compoundStatements_71c;
	GetDirectTransitions_710 getDirectTransitions_710;
	getDirectTransitions_710( states_711, srcTransConnectors_714, functions_717, compoundStatements_71a, states_713, transitions_716, functions_719, compoundStatements_71c);
	_state_6c0->insert( _state_6c0->end(), states_713.begin(), states_713.end());
	_trans_6c1->insert( _trans_6c1->end(), transitions_716.begin(), transitions_716.end());
	_fcn_6c2->insert( _fcn_6c2->end(), functions_719.begin(), functions_719.end());
	_cs_6c3->insert( _cs_6c3->end(), compoundStatements_71c.begin(), compoundStatements_71c.end());
}

void GetAllTransitions_6b3::callGetTransitionsFromStateRefs_7b9( const Packets_t& states_759, const Packets_t& tCStates_75d, const Packets_t& functions_75f, const Packets_t& compoundStatements_762)
{
	Packets_t states_75b;
	Packets_t transitions_75c;
	Packets_t functions_761;
	Packets_t compoundStatements_764;
	GetTransitionsFromStateRefs_758 getTransitionsFromStateRefs_758;
	getTransitionsFromStateRefs_758( states_759, tCStates_75d, functions_75f, compoundStatements_762, states_75b, transitions_75c, functions_761, compoundStatements_764);
	_state_6c0->insert( _state_6c0->end(), states_75b.begin(), states_75b.end());
	_trans_6c1->insert( _trans_6c1->end(), transitions_75c.begin(), transitions_75c.end());
	_fcn_6c2->insert( _fcn_6c2->end(), functions_761.begin(), functions_761.end());
	_cs_6c3->insert( _cs_6c3->end(), compoundStatements_764.begin(), compoundStatements_764.end());
}

void GetTransitionsFromJunctionRefs_6c4::operator()( const Packets_t& states_6c5, const Packets_t& junctions_6c9, const Packets_t& functions_6cb, const Packets_t& compoundStatements_6ce, Packets_t& states_6c7, Packets_t& transitions_6c8, Packets_t& functions_6cd, Packets_t& compoundStatements_6d0)
{
#ifdef PRINT_INFO
	printLog( "GetTransitionsFromJunctionRefs_6c4" );
#endif
	RTTGenerator::Instance()->generateRule(2383, "GetTransitionsFromJunctionRefs");
	_state_6d1= &states_6c7;
	_transition_6d2= &transitions_6c8;
	_function_6d3= &functions_6cd;
	_compoundStatement_6d4= &compoundStatements_6d0;
	processInputPackets( states_6c5, junctions_6c9, functions_6cb, compoundStatements_6ce);
}

bool GetTransitionsFromJunctionRefs_6c4::isInputUnique( const Udm::Object& state_6d9, const Udm::Object& junction_6e2, const Udm::Object& function_6eb, const Udm::Object& compoundStatement_6f4)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_6db= _state_6d5.begin(), itJunction_6e4= _junction_6de.begin(), itFunction_6ed= _function_6e7.begin(), itCompoundStatement_6f6= _compoundStatement_6f0.begin(); itState_6db!= _state_6d5.end(), itJunction_6e4!= _junction_6de.end(), itFunction_6ed!= _function_6e7.end(), itCompoundStatement_6f6!= _compoundStatement_6f0.end(); ++itState_6db, ++itJunction_6e4, ++itFunction_6ed, ++itCompoundStatement_6f6)
	{
		if( ( *itState_6db== state_6d9)&& ( *itJunction_6e4== junction_6e2)&& ( *itFunction_6ed== function_6eb)&& ( *itCompoundStatement_6f6== compoundStatement_6f4))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_6d5.push_back( state_6d9);
		_junction_6de.push_back( junction_6e2);
		_function_6e7.push_back( function_6eb);
		_compoundStatement_6f0.push_back( compoundStatement_6f4);
	}
	return isUnique;
}

void GetTransitionsFromJunctionRefs_6c4::processInputPackets( const Packets_t& states_6c5, const Packets_t& junctions_6c9, const Packets_t& functions_6cb, const Packets_t& compoundStatements_6ce)
{
	for( Packets_t::const_iterator itState_6d6= states_6c5.begin(), itJunction_6df= junctions_6c9.begin(), itFunction_6e8= functions_6cb.begin(), itCompoundStatement_6f1= compoundStatements_6ce.begin(); itState_6d6!= states_6c5.end(), itJunction_6df!= junctions_6c9.end(), itFunction_6e8!= functions_6cb.end(), itCompoundStatement_6f1!= compoundStatements_6ce.end(); ++itState_6d6, ++itJunction_6df, ++itFunction_6e8, ++itCompoundStatement_6f1)
	{
		bool isUnique= isInputUnique( *itState_6d6, *itJunction_6df, *itFunction_6e8, *itCompoundStatement_6f1);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_6d6, *itJunction_6df, *itFunction_6e8, *itCompoundStatement_6f1);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetTransitionsFromJunctionRefs_6c4::patternMatcher( const Udm::Object& state_6d7, const Udm::Object& junction_6e0, const Udm::Object& function_6e9, const Udm::Object& compoundStatement_6f2)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_6d7.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_6dc= CyberComposition::Simulink::State::Cast( state_6d7);
		if( false== Uml::IsDerivedFrom( junction_6e0.type(), CyberComposition::Simulink::SF_Junction::meta))
			continue;
		CyberComposition::Simulink::SF_Junction junction_6e5= CyberComposition::Simulink::SF_Junction::Cast( junction_6e0);
		if( false== Uml::IsDerivedFrom( function_6e9.type(), SFC::Function::meta))
			continue;
		SFC::Function function_6ee= SFC::Function::Cast( function_6e9);
		if( false== Uml::IsDerivedFrom( compoundStatement_6f2.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_6f7= SFC::CompoundStatement::Cast( compoundStatement_6f2);
		set< CyberComposition::Simulink::ConnectorRef> connectorRefs_6f9= junction_6e5.referedbyConnectorRef();
		for( set< CyberComposition::Simulink::ConnectorRef>::const_iterator itConnectorRefs_6fa= connectorRefs_6f9.begin(); itConnectorRefs_6fa!= connectorRefs_6f9.end(); ++itConnectorRefs_6fa)
		{
			CyberComposition::Simulink::ConnectorRef currConnectorRef_6fb= *itConnectorRefs_6fa;
			set< CyberComposition::Simulink::Transition> transitions_6fc= currConnectorRef_6fb.dstTransition();
			for( set< CyberComposition::Simulink::Transition>::const_iterator itTransitions_6fd= transitions_6fc.begin(); itTransitions_6fd!= transitions_6fc.end(); ++itTransitions_6fd)
			{
				CyberComposition::Simulink::Transition currTransition_6fe= *itTransitions_6fd;
				CyberComposition::Simulink::TransConnector dstTransConnector_6ff= currTransition_6fe.dstTransition_end();
				Match currMatch;
				currMatch.state_701= state_6dc;
				currMatch.junction_702= junction_6e5;
				currMatch.function_703= function_6ee;
				currMatch.compoundStatement_704= compoundStatement_6f7;
				currMatch.transition_705= currTransition_6fe;
				currMatch.connectorRef_706= currConnectorRef_6fb;
				currMatch.dstTransConnector_707= dstTransConnector_6ff;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetTransitionsFromJunctionRefs_6c4::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_701, currMatch.transition_705, currMatch.function_703, currMatch.compoundStatement_704);
	}
}

void GetTransitionsFromJunctionRefs_6c4::outputAppender( const CyberComposition::Simulink::State& state_708, const CyberComposition::Simulink::Transition& transition_70a, const SFC::Function& function_70c, const SFC::CompoundStatement& compoundStatement_70e)
{
	_state_6d1->push_back( state_708);
	_transition_6d2->push_back( transition_70a);
	_function_6d3->push_back( function_70c);
	_compoundStatement_6d4->push_back( compoundStatement_70e);
}

void GetDirectTransitions_710::operator()( const Packets_t& states_711, const Packets_t& srcTransConnectors_714, const Packets_t& functions_717, const Packets_t& compoundStatements_71a, Packets_t& states_713, Packets_t& transitions_716, Packets_t& functions_719, Packets_t& compoundStatements_71c)
{
#ifdef PRINT_INFO
	printLog( "GetDirectTransitions_710" );
#endif
	RTTGenerator::Instance()->generateRule(2394, "GetDirectTransitions");
	_state_71d= &states_713;
	_transition_71e= &transitions_716;
	_function_71f= &functions_719;
	_compoundStatement_720= &compoundStatements_71c;
	processInputPackets( states_711, srcTransConnectors_714, functions_717, compoundStatements_71a);
}

bool GetDirectTransitions_710::isInputUnique( const Udm::Object& state_725, const Udm::Object& srcTransConnector_72e, const Udm::Object& function_737, const Udm::Object& compoundStatement_740)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_727= _state_721.begin(), itSrcTransConnector_730= _srcTransConnector_72a.begin(), itFunction_739= _function_733.begin(), itCompoundStatement_742= _compoundStatement_73c.begin(); itState_727!= _state_721.end(), itSrcTransConnector_730!= _srcTransConnector_72a.end(), itFunction_739!= _function_733.end(), itCompoundStatement_742!= _compoundStatement_73c.end(); ++itState_727, ++itSrcTransConnector_730, ++itFunction_739, ++itCompoundStatement_742)
	{
		if( ( *itState_727== state_725)&& ( *itSrcTransConnector_730== srcTransConnector_72e)&& ( *itFunction_739== function_737)&& ( *itCompoundStatement_742== compoundStatement_740))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_721.push_back( state_725);
		_srcTransConnector_72a.push_back( srcTransConnector_72e);
		_function_733.push_back( function_737);
		_compoundStatement_73c.push_back( compoundStatement_740);
	}
	return isUnique;
}

void GetDirectTransitions_710::processInputPackets( const Packets_t& states_711, const Packets_t& srcTransConnectors_714, const Packets_t& functions_717, const Packets_t& compoundStatements_71a)
{
	for( Packets_t::const_iterator itState_722= states_711.begin(), itSrcTransConnector_72b= srcTransConnectors_714.begin(), itFunction_734= functions_717.begin(), itCompoundStatement_73d= compoundStatements_71a.begin(); itState_722!= states_711.end(), itSrcTransConnector_72b!= srcTransConnectors_714.end(), itFunction_734!= functions_717.end(), itCompoundStatement_73d!= compoundStatements_71a.end(); ++itState_722, ++itSrcTransConnector_72b, ++itFunction_734, ++itCompoundStatement_73d)
	{
		bool isUnique= isInputUnique( *itState_722, *itSrcTransConnector_72b, *itFunction_734, *itCompoundStatement_73d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_722, *itSrcTransConnector_72b, *itFunction_734, *itCompoundStatement_73d);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetDirectTransitions_710::patternMatcher( const Udm::Object& state_723, const Udm::Object& srcTransConnector_72c, const Udm::Object& function_735, const Udm::Object& compoundStatement_73e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_723.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_728= CyberComposition::Simulink::State::Cast( state_723);
		if( false== Uml::IsDerivedFrom( srcTransConnector_72c.type(), CyberComposition::Simulink::TransConnector::meta))
			continue;
		CyberComposition::Simulink::TransConnector srcTransConnector_731= CyberComposition::Simulink::TransConnector::Cast( srcTransConnector_72c);
		if( false== Uml::IsDerivedFrom( function_735.type(), SFC::Function::meta))
			continue;
		SFC::Function function_73a= SFC::Function::Cast( function_735);
		if( false== Uml::IsDerivedFrom( compoundStatement_73e.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_743= SFC::CompoundStatement::Cast( compoundStatement_73e);
		set< CyberComposition::Simulink::Transition> transitions_745= srcTransConnector_731.dstTransition();
		for( set< CyberComposition::Simulink::Transition>::const_iterator itTransitions_746= transitions_745.begin(); itTransitions_746!= transitions_745.end(); ++itTransitions_746)
		{
			CyberComposition::Simulink::Transition currTransition_747= *itTransitions_746;
			CyberComposition::Simulink::TransConnector dstTransConnector_748= currTransition_747.dstTransition_end();
			Match currMatch;
			currMatch.state_74a= state_728;
			currMatch.srcTransConnector_74b= srcTransConnector_731;
			currMatch.function_74c= function_73a;
			currMatch.compoundStatement_74d= compoundStatement_743;
			currMatch.transition_74e= currTransition_747;
			currMatch.dstTransConnector_74f= dstTransConnector_748;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetDirectTransitions_710::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_74a, currMatch.transition_74e, currMatch.function_74c, currMatch.compoundStatement_74d);
	}
}

void GetDirectTransitions_710::outputAppender( const CyberComposition::Simulink::State& state_750, const CyberComposition::Simulink::Transition& transition_752, const SFC::Function& function_754, const SFC::CompoundStatement& compoundStatement_756)
{
	_state_71d->push_back( state_750);
	_transition_71e->push_back( transition_752);
	_function_71f->push_back( function_754);
	_compoundStatement_720->push_back( compoundStatement_756);
}

void GetTransitionsFromStateRefs_758::operator()( const Packets_t& states_759, const Packets_t& tCStates_75d, const Packets_t& functions_75f, const Packets_t& compoundStatements_762, Packets_t& states_75b, Packets_t& transitions_75c, Packets_t& functions_761, Packets_t& compoundStatements_764)
{
#ifdef PRINT_INFO
	printLog( "GetTransitionsFromStateRefs_758" );
#endif
	RTTGenerator::Instance()->generateRule(2403, "GetTransitionsFromStateRefs");
	_state_765= &states_75b;
	_transition_766= &transitions_75c;
	_function_767= &functions_761;
	_compoundStatement_768= &compoundStatements_764;
	processInputPackets( states_759, tCStates_75d, functions_75f, compoundStatements_762);
}

bool GetTransitionsFromStateRefs_758::isInputUnique( const Udm::Object& state_76d, const Udm::Object& tCState_776, const Udm::Object& function_77f, const Udm::Object& compoundStatement_788)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_76f= _state_769.begin(), itTCState_778= _tCState_772.begin(), itFunction_781= _function_77b.begin(), itCompoundStatement_78a= _compoundStatement_784.begin(); itState_76f!= _state_769.end(), itTCState_778!= _tCState_772.end(), itFunction_781!= _function_77b.end(), itCompoundStatement_78a!= _compoundStatement_784.end(); ++itState_76f, ++itTCState_778, ++itFunction_781, ++itCompoundStatement_78a)
	{
		if( ( *itState_76f== state_76d)&& ( *itTCState_778== tCState_776)&& ( *itFunction_781== function_77f)&& ( *itCompoundStatement_78a== compoundStatement_788))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_769.push_back( state_76d);
		_tCState_772.push_back( tCState_776);
		_function_77b.push_back( function_77f);
		_compoundStatement_784.push_back( compoundStatement_788);
	}
	return isUnique;
}

bool GetTransitionsFromStateRefs_758::isGuardTrue( SFC::CompoundStatement& CompoundStatement, CyberComposition::Simulink::ConnectorRef& ConnectorRef, CyberComposition::Simulink::TransConnector& DstTransConnector, SFC::Function& Function, CyberComposition::Simulink::State& RefParentState, CyberComposition::Simulink::State& State, CyberComposition::Simulink::State& TCState, CyberComposition::Simulink::Transition& Transition)
{
	bool Gz_guard= false;
	return State != RefParentState;;
	return Gz_guard;
}

void GetTransitionsFromStateRefs_758::processInputPackets( const Packets_t& states_759, const Packets_t& tCStates_75d, const Packets_t& functions_75f, const Packets_t& compoundStatements_762)
{
	for( Packets_t::const_iterator itState_76a= states_759.begin(), itTCState_773= tCStates_75d.begin(), itFunction_77c= functions_75f.begin(), itCompoundStatement_785= compoundStatements_762.begin(); itState_76a!= states_759.end(), itTCState_773!= tCStates_75d.end(), itFunction_77c!= functions_75f.end(), itCompoundStatement_785!= compoundStatements_762.end(); ++itState_76a, ++itTCState_773, ++itFunction_77c, ++itCompoundStatement_785)
	{
		bool isUnique= isInputUnique( *itState_76a, *itTCState_773, *itFunction_77c, *itCompoundStatement_785);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_76a, *itTCState_773, *itFunction_77c, *itCompoundStatement_785);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetTransitionsFromStateRefs_758::patternMatcher( const Udm::Object& state_76b, const Udm::Object& tCState_774, const Udm::Object& function_77d, const Udm::Object& compoundStatement_786)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_76b.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_770= CyberComposition::Simulink::State::Cast( state_76b);
		if( false== Uml::IsDerivedFrom( tCState_774.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State tCState_779= CyberComposition::Simulink::State::Cast( tCState_774);
		if( false== Uml::IsDerivedFrom( function_77d.type(), SFC::Function::meta))
			continue;
		SFC::Function function_782= SFC::Function::Cast( function_77d);
		if( false== Uml::IsDerivedFrom( compoundStatement_786.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_78b= SFC::CompoundStatement::Cast( compoundStatement_786);
		set< CyberComposition::Simulink::ConnectorRef> connectorRefs_78d= state_770.referedbyConnectorRef();
		for( set< CyberComposition::Simulink::ConnectorRef>::const_iterator itConnectorRefs_78e= connectorRefs_78d.begin(); itConnectorRefs_78e!= connectorRefs_78d.end(); ++itConnectorRefs_78e)
		{
			CyberComposition::Simulink::ConnectorRef currConnectorRef_78f= *itConnectorRefs_78e;
			Udm::Object connectorRefParent_790= currConnectorRef_78f.container();
			if( false== Uml::IsDerivedFrom( connectorRefParent_790.type(), CyberComposition::Simulink::State::meta))
				continue;
			CyberComposition::Simulink::State refParentStateConnectorRef_791= CyberComposition::Simulink::State::Cast( connectorRefParent_790);
			set< CyberComposition::Simulink::Transition> transitions_792= currConnectorRef_78f.dstTransition();
			for( set< CyberComposition::Simulink::Transition>::const_iterator itTransitions_793= transitions_792.begin(); itTransitions_793!= transitions_792.end(); ++itTransitions_793)
			{
				CyberComposition::Simulink::Transition currTransition_794= *itTransitions_793;
				CyberComposition::Simulink::TransConnector dstTransConnector_795= currTransition_794.dstTransition_end();
				Match currMatch;
				currMatch.state_797= state_770;
				currMatch.tCState_798= tCState_779;
				currMatch.function_799= function_782;
				currMatch.compoundStatement_79a= compoundStatement_78b;
				currMatch.refParentState_79b= refParentStateConnectorRef_791;
				currMatch.transition_79c= currTransition_794;
				currMatch.connectorRef_79d= currConnectorRef_78f;
				currMatch.dstTransConnector_79e= dstTransConnector_795;
				bool Gz_guard= isGuardTrue( currMatch.compoundStatement_79a, currMatch.connectorRef_79d, currMatch.dstTransConnector_79e, currMatch.function_799, currMatch.refParentState_79b, currMatch.state_797, currMatch.tCState_798, currMatch.transition_79c);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetTransitionsFromStateRefs_758::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_797, currMatch.transition_79c, currMatch.function_799, currMatch.compoundStatement_79a);
	}
}

void GetTransitionsFromStateRefs_758::outputAppender( const CyberComposition::Simulink::State& state_7a7, const CyberComposition::Simulink::Transition& transition_7a9, const SFC::Function& function_7ab, const SFC::CompoundStatement& compoundStatement_7ad)
{
	_state_765->push_back( state_7a7);
	_transition_766->push_back( transition_7a9);
	_function_767->push_back( function_7ab);
	_compoundStatement_768->push_back( compoundStatement_7ad);
}

void CreateTransitionCG_7c8::operator()( const Packets_t& states_7c9, const Packets_t& transConnectors_7cc, const Packets_t& functions_7cf, const Packets_t& tCVarCGs_7d3, Packets_t& states_7cb, Packets_t& transConnectors_7ce, Packets_t& functions_7d1, Packets_t& transitionCGs_7d2)
{
#ifdef PRINT_INFO
	printLog( "CreateTransitionCG_7c8" );
#endif
	RTTGenerator::Instance()->generateRule(2713, "CreateTransitionCG");
	_state_7d5= &states_7cb;
	_transConnector_7d6= &transConnectors_7ce;
	_function_7d7= &functions_7d1;
	_transitionCG_7d8= &transitionCGs_7d2;
	processInputPackets( states_7c9, transConnectors_7cc, functions_7cf, tCVarCGs_7d3);
}

bool CreateTransitionCG_7c8::isInputUnique( const Udm::Object& state_7dd, const Udm::Object& transConnector_7e6, const Udm::Object& function_7ef, const Udm::Object& tCVarCG_7f8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_7df= _state_7d9.begin(), itTransConnector_7e8= _transConnector_7e2.begin(), itFunction_7f1= _function_7eb.begin(), itTCVarCG_7fa= _tCVarCG_7f4.begin(); itState_7df!= _state_7d9.end(), itTransConnector_7e8!= _transConnector_7e2.end(), itFunction_7f1!= _function_7eb.end(), itTCVarCG_7fa!= _tCVarCG_7f4.end(); ++itState_7df, ++itTransConnector_7e8, ++itFunction_7f1, ++itTCVarCG_7fa)
	{
		if( ( *itState_7df== state_7dd)&& ( *itTransConnector_7e8== transConnector_7e6)&& ( *itFunction_7f1== function_7ef)&& ( *itTCVarCG_7fa== tCVarCG_7f8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_7d9.push_back( state_7dd);
		_transConnector_7e2.push_back( transConnector_7e6);
		_function_7eb.push_back( function_7ef);
		_tCVarCG_7f4.push_back( tCVarCG_7f8);
	}
	return isUnique;
}

bool CreateTransitionCG_7c8::isGuardTrue( SFC::Function& Function, CyberComposition::Simulink::State& State, SFC::LocalVar& TCVar, SFC::ConditionalGroup& TCVarCG, CyberComposition::Simulink::TransConnector& TransConnector)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( TCVar.name() ) == "_TCVar_";
	return Gz_guard;
}

void CreateTransitionCG_7c8::processInputPackets( const Packets_t& states_7c9, const Packets_t& transConnectors_7cc, const Packets_t& functions_7cf, const Packets_t& tCVarCGs_7d3)
{
	for( Packets_t::const_iterator itState_7da= states_7c9.begin(), itTransConnector_7e3= transConnectors_7cc.begin(), itFunction_7ec= functions_7cf.begin(), itTCVarCG_7f5= tCVarCGs_7d3.begin(); itState_7da!= states_7c9.end(), itTransConnector_7e3!= transConnectors_7cc.end(), itFunction_7ec!= functions_7cf.end(), itTCVarCG_7f5!= tCVarCGs_7d3.end(); ++itState_7da, ++itTransConnector_7e3, ++itFunction_7ec, ++itTCVarCG_7f5)
	{
		bool isUnique= isInputUnique( *itState_7da, *itTransConnector_7e3, *itFunction_7ec, *itTCVarCG_7f5);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_7da, *itTransConnector_7e3, *itFunction_7ec, *itTCVarCG_7f5);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateTransitionCG_7c8::patternMatcher( const Udm::Object& state_7db, const Udm::Object& transConnector_7e4, const Udm::Object& function_7ed, const Udm::Object& tCVarCG_7f6)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_7db.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_7e0= CyberComposition::Simulink::State::Cast( state_7db);
		if( false== Uml::IsDerivedFrom( transConnector_7e4.type(), CyberComposition::Simulink::TransConnector::meta))
			continue;
		CyberComposition::Simulink::TransConnector transConnector_7e9= CyberComposition::Simulink::TransConnector::Cast( transConnector_7e4);
		if( false== Uml::IsDerivedFrom( function_7ed.type(), SFC::Function::meta))
			continue;
		SFC::Function function_7f2= SFC::Function::Cast( function_7ed);
		if( false== Uml::IsDerivedFrom( tCVarCG_7f6.type(), SFC::ConditionalGroup::meta))
			continue;
		SFC::ConditionalGroup tCVarCG_7fb= SFC::ConditionalGroup::Cast( tCVarCG_7f6);
		set< SFC::LocalVar> tCVars_7fd= function_7f2.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itTCVar_7fe= tCVars_7fd.begin(); itTCVar_7fe!= tCVars_7fd.end(); ++itTCVar_7fe)
		{
			SFC::LocalVar currTCVar_7ff= *itTCVar_7fe;
			Match currMatch;
			currMatch.state_801= state_7e0;
			currMatch.transConnector_802= transConnector_7e9;
			currMatch.function_803= function_7f2;
			currMatch.tCVarCG_804= tCVarCG_7fb;
			currMatch.tCVar_805= currTCVar_7ff;
			bool Gz_guard= isGuardTrue( currMatch.function_803, currMatch.state_801, currMatch.tCVar_805, currMatch.tCVarCG_804, currMatch.transConnector_802);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateTransitionCG_7c8::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newTCVarCB_80b= SFC::ConditionalBlock::Create( currMatch.tCVarCG_804, SFC::ConditionalGroup::meta_stmnt);
		SFC::UserCode newTCVarTest_80c= SFC::UserCode::Create( newTCVarCB_80b, SFC::ConditionalBlock::meta_cond);
		SFC::BinaryExprs newEquals_80d= SFC::BinaryExprs::Create( newTCVarTest_80c, SFC::UserCode::meta_codeexpr);
		SFC::Int newInt_80e= SFC::Int::Create( newEquals_80d, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_80f= SFC::ArgDeclRef::Create( newEquals_80d, SFC::BinaryExprs::meta_leftexpr);
		SFC::ConditionalGroup newTransitionCG_810= SFC::ConditionalGroup::Create( newTCVarCB_80b, SFC::ConditionalBlock::meta_stmnt);
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_80f;
		SFC::BinaryExprs& Equals= newEquals_80d;
		SFC::Function& Function= currMatch.function_803;
		SFC::Int& Int= newInt_80e;
		CyberComposition::Simulink::State& State= currMatch.state_801;
		SFC::LocalVar& TCVar= currMatch.tCVar_805;
		SFC::ConditionalBlock& TCVarCB= newTCVarCB_80b;
		SFC::ConditionalGroup& TCVarCG= currMatch.tCVarCG_804;
		SFC::UserCode& TCVarTest= newTCVarTest_80c;
		CyberComposition::Simulink::TransConnector& TransConnector= currMatch.transConnector_802;
		SFC::ConditionalGroup& TransitionCG= newTransitionCG_810;
		{
TCVarCB.RefId() = TCVarTest.RefId() = TransitionCG.RefId() = TransConnector.RefId();
};
		{
__int64 statementCount = TCVarCG.statementCount();
TCVarCB.statementIndex() = statementCount++;
TCVarCG.statementCount() = statementCount;
};
		{
Equals.op() = "==";
};
		{
__int64 statementCount = TCVarCB.statementCount();
TransitionCG.statementIndex() = statementCount++;
TCVarCB.statementCount() = statementCount;
};
		{
Int.val() = SFManager::StateTransConnectorMap::get_singleton().getTransConnectorMap( State ).getTransConnectorNumber( TransConnector );
};
		{
SFManager::StateTransConnectorMap::get_singleton().getTransConnectorMap( State ).setIsTransConnectorProcessed( TransConnector, true );
};
		newArgDeclRef_80f.argdecl()= currMatch.tCVar_805;
		outputAppender( currMatch.state_801, currMatch.transConnector_802, currMatch.function_803, newTransitionCG_810);
	}
}

void CreateTransitionCG_7c8::outputAppender( const CyberComposition::Simulink::State& state_811, const CyberComposition::Simulink::TransConnector& transConnector_813, const SFC::Function& function_815, const SFC::ConditionalGroup& transitionCG_817)
{
	_state_7d5->push_back( state_811);
	_transConnector_7d6->push_back( transConnector_813);
	_function_7d7->push_back( function_815);
	_transitionCG_7d8->push_back( transitionCG_817);
}

void ProcessedFilter_819::operator()( const Packets_t& states_81a, const Packets_t& tcs_81c, const Packets_t& fcns_81e, const Packets_t& cgs_820, Packets_t& states_822, Packets_t& tcs_823, Packets_t& fcns_824, Packets_t& cgs_825)
{
#ifdef PRINT_INFO
	printLog( "ProcessedFilter_819" );
#endif
	_state_826= &states_822;
	_tc_827= &tcs_823;
	_fcn_828= &fcns_824;
	_cg_829= &cgs_825;
	for( Packets_t::const_iterator itstate_82b= states_81a.begin(), ittc_832= tcs_81c.begin(), itfcn_839= fcns_81e.begin(), itcg_840= cgs_820.begin(); itstate_82b!= states_81a.end(), ittc_832!= tcs_81c.end(), itfcn_839!= fcns_81e.end(), itcg_840!= cgs_820.end(); ++itstate_82b, ++ittc_832, ++itfcn_839, ++itcg_840)
	{
		bool isUnique= isInputUnique( *itstate_82b, *ittc_832, *itfcn_839, *itcg_840);
		if( !isUnique)
			continue;
		Packets_t onestate_82f( 1, *itstate_82b);
		Packets_t onetc_836( 1, *ittc_832);
		Packets_t onefcn_83d( 1, *itfcn_839);
		Packets_t onecg_844( 1, *itcg_840);
		executeOne( onestate_82f, onetc_836, onefcn_83d, onecg_844);
	}
}

void ProcessedFilter_819::executeOne( const Packets_t& states_81a, const Packets_t& tcs_81c, const Packets_t& fcns_81e, const Packets_t& cgs_820)
{
	Packets_t states_849;
	Packets_t transConnectors_84c;
	Packets_t functions_84f;
	Packets_t conditionalGroups_852;
	TCNotProcessed_846 tCNotProcessed_846;
	bool isMatchTCNotProcessed_846= tCNotProcessed_846( states_81a, tcs_81c, fcns_81e, cgs_820, states_849, transConnectors_84c, functions_84f, conditionalGroups_852);
	_state_826->insert( _state_826->end(), states_849.begin(), states_849.end());
	_tc_827->insert( _tc_827->end(), transConnectors_84c.begin(), transConnectors_84c.end());
	_fcn_828->insert( _fcn_828->end(), functions_84f.begin(), functions_84f.end());
	_cg_829->insert( _cg_829->end(), conditionalGroups_852.begin(), conditionalGroups_852.end());
	if( isMatchTCNotProcessed_846)
		return;
}

bool ProcessedFilter_819::isInputUnique( const Udm::Object& state_82c, const Udm::Object& tc_833, const Udm::Object& fcn_83a, const Udm::Object& cg_841)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_82e= _state_82a.begin(), ittc_835= _tc_831.begin(), itfcn_83c= _fcn_838.begin(), itcg_843= _cg_83f.begin(); itstate_82e!= _state_82a.end(), ittc_835!= _tc_831.end(), itfcn_83c!= _fcn_838.end(), itcg_843!= _cg_83f.end(); ++itstate_82e, ++ittc_835, ++itfcn_83c, ++itcg_843)
	{
		if( ( *itstate_82e== state_82c)&& ( *ittc_835== tc_833)&& ( *itfcn_83c== fcn_83a)&& ( *itcg_843== cg_841))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_82a.push_back( state_82c);
		_tc_831.push_back( tc_833);
		_fcn_838.push_back( fcn_83a);
		_cg_83f.push_back( cg_841);
	}
	return isUnique;
}

bool TCNotProcessed_846::operator()( const Packets_t& states_847, const Packets_t& transConnectors_84a, const Packets_t& functions_84d, const Packets_t& conditionalGroups_850, Packets_t& states_849, Packets_t& transConnectors_84c, Packets_t& functions_84f, Packets_t& conditionalGroups_852)
{
#ifdef PRINT_INFO
	printLog( "TCNotProcessed_846" );
#endif
	_state_853= &states_849;
	_transConnector_854= &transConnectors_84c;
	_function_855= &functions_84f;
	_conditionalGroup_856= &conditionalGroups_852;
	processInputPackets( states_847, transConnectors_84a, functions_84d, conditionalGroups_850);
	if( false== _matches.empty())
		return true;
	return false;
}

bool TCNotProcessed_846::isInputUnique( const Udm::Object& state_85b, const Udm::Object& transConnector_864, const Udm::Object& function_86d, const Udm::Object& conditionalGroup_876)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_85d= _state_857.begin(), itTransConnector_866= _transConnector_860.begin(), itFunction_86f= _function_869.begin(), itConditionalGroup_878= _conditionalGroup_872.begin(); itState_85d!= _state_857.end(), itTransConnector_866!= _transConnector_860.end(), itFunction_86f!= _function_869.end(), itConditionalGroup_878!= _conditionalGroup_872.end(); ++itState_85d, ++itTransConnector_866, ++itFunction_86f, ++itConditionalGroup_878)
	{
		if( ( *itState_85d== state_85b)&& ( *itTransConnector_866== transConnector_864)&& ( *itFunction_86f== function_86d)&& ( *itConditionalGroup_878== conditionalGroup_876))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_857.push_back( state_85b);
		_transConnector_860.push_back( transConnector_864);
		_function_869.push_back( function_86d);
		_conditionalGroup_872.push_back( conditionalGroup_876);
	}
	return isUnique;
}

bool TCNotProcessed_846::isGuardTrue( SFC::ConditionalGroup& ConditionalGroup, SFC::Function& Function, CyberComposition::Simulink::State& State, CyberComposition::Simulink::TransConnector& TransConnector)
{
	bool Gz_guard= false;
	return !SFManager::StateTransConnectorMap::get_singleton().getTransConnectorMap( State ).getIsTransConnectorProcessed( TransConnector );;
	return Gz_guard;
}

void TCNotProcessed_846::processInputPackets( const Packets_t& states_847, const Packets_t& transConnectors_84a, const Packets_t& functions_84d, const Packets_t& conditionalGroups_850)
{
	for( Packets_t::const_iterator itState_858= states_847.begin(), itTransConnector_861= transConnectors_84a.begin(), itFunction_86a= functions_84d.begin(), itConditionalGroup_873= conditionalGroups_850.begin(); itState_858!= states_847.end(), itTransConnector_861!= transConnectors_84a.end(), itFunction_86a!= functions_84d.end(), itConditionalGroup_873!= conditionalGroups_850.end(); ++itState_858, ++itTransConnector_861, ++itFunction_86a, ++itConditionalGroup_873)
	{
		bool isUnique= isInputUnique( *itState_858, *itTransConnector_861, *itFunction_86a, *itConditionalGroup_873);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_858, *itTransConnector_861, *itFunction_86a, *itConditionalGroup_873);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_87c, currMatch.transConnector_87d, currMatch.function_87e, currMatch.conditionalGroup_87f);
	}
}

bool TCNotProcessed_846::patternMatcher( const Udm::Object& state_859, const Udm::Object& transConnector_862, const Udm::Object& function_86b, const Udm::Object& conditionalGroup_874)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_859.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_85e= CyberComposition::Simulink::State::Cast( state_859);
		if( false== Uml::IsDerivedFrom( transConnector_862.type(), CyberComposition::Simulink::TransConnector::meta))
			continue;
		CyberComposition::Simulink::TransConnector transConnector_867= CyberComposition::Simulink::TransConnector::Cast( transConnector_862);
		if( false== Uml::IsDerivedFrom( function_86b.type(), SFC::Function::meta))
			continue;
		SFC::Function function_870= SFC::Function::Cast( function_86b);
		if( false== Uml::IsDerivedFrom( conditionalGroup_874.type(), SFC::ConditionalGroup::meta))
			continue;
		SFC::ConditionalGroup conditionalGroup_879= SFC::ConditionalGroup::Cast( conditionalGroup_874);
		Match currMatch;
		currMatch.state_87c= state_85e;
		currMatch.transConnector_87d= transConnector_867;
		currMatch.function_87e= function_870;
		currMatch.conditionalGroup_87f= conditionalGroup_879;
		bool Gz_guard= isGuardTrue( currMatch.conditionalGroup_87f, currMatch.function_87e, currMatch.state_87c, currMatch.transConnector_87d);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void TCNotProcessed_846::outputAppender( const CyberComposition::Simulink::State& state_884, const CyberComposition::Simulink::TransConnector& transConnector_886, const SFC::Function& function_888, const SFC::ConditionalGroup& conditionalGroup_88a)
{
	_state_853->push_back( state_884);
	_transConnector_854->push_back( transConnector_886);
	_function_855->push_back( function_888);
	_conditionalGroup_856->push_back( conditionalGroup_88a);
}

void NoDefaultTransition_88c::operator()( const Packets_t& states_88d, const Packets_t& tcs_88f, const Packets_t& fcns_891, const Packets_t& css_893)
{
#ifdef PRINT_INFO
	printLog( "NoDefaultTransition_88c" );
#endif
	if( ( !states_88d.empty())&& ( !tcs_88f.empty())&& ( !fcns_891.empty())&& ( !css_893.empty()))
		callNDTTest_9dc( states_88d, tcs_88f, fcns_891, css_893);
}

void NoDefaultTransition_88c::callNDTTest_9dc( const Packets_t& states_8db, const Packets_t& tcs_8dd, const Packets_t& fcns_8df, const Packets_t& css_8e1)
{
	Packets_t states_8e3;
	Packets_t tcs_8e4;
	Packets_t fcns_8e5;
	Packets_t css_8e6;
	NDTTest_8da nDTTest_8da;
	nDTTest_8da( states_8db, tcs_8dd, fcns_8df, css_8e1, states_8e3, tcs_8e4, fcns_8e5, css_8e6);
	if( ( !states_8e3.empty())&& ( !tcs_8e4.empty())&& ( !fcns_8e5.empty())&& ( !css_8e6.empty()))
		callExitLoop_9e1( states_8e3, tcs_8e4, fcns_8e5, css_8e6);
}

void NoDefaultTransition_88c::callExitLoop_9e1( const Packets_t& states_896, const Packets_t& srcTransConnectors_898, const Packets_t& functions_89a, const Packets_t& compoundStatements_89c)
{
	ExitLoop_895 exitLoop_895;
	exitLoop_895( states_896, srcTransConnectors_898, functions_89a, compoundStatements_89c);
}

void ExitLoop_895::operator()( const Packets_t& states_896, const Packets_t& srcTransConnectors_898, const Packets_t& functions_89a, const Packets_t& compoundStatements_89c)
{
#ifdef PRINT_INFO
	printLog( "ExitLoop_895" );
#endif
	RTTGenerator::Instance()->generateRule(2744, "ExitLoop");
	processInputPackets( states_896, srcTransConnectors_898, functions_89a, compoundStatements_89c);
}

bool ExitLoop_895::isInputUnique( const Udm::Object& state_8a2, const Udm::Object& srcTransConnector_8ab, const Udm::Object& function_8b4, const Udm::Object& compoundStatement_8bd)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_8a4= _state_89e.begin(), itSrcTransConnector_8ad= _srcTransConnector_8a7.begin(), itFunction_8b6= _function_8b0.begin(), itCompoundStatement_8bf= _compoundStatement_8b9.begin(); itState_8a4!= _state_89e.end(), itSrcTransConnector_8ad!= _srcTransConnector_8a7.end(), itFunction_8b6!= _function_8b0.end(), itCompoundStatement_8bf!= _compoundStatement_8b9.end(); ++itState_8a4, ++itSrcTransConnector_8ad, ++itFunction_8b6, ++itCompoundStatement_8bf)
	{
		if( ( *itState_8a4== state_8a2)&& ( *itSrcTransConnector_8ad== srcTransConnector_8ab)&& ( *itFunction_8b6== function_8b4)&& ( *itCompoundStatement_8bf== compoundStatement_8bd))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_89e.push_back( state_8a2);
		_srcTransConnector_8a7.push_back( srcTransConnector_8ab);
		_function_8b0.push_back( function_8b4);
		_compoundStatement_8b9.push_back( compoundStatement_8bd);
	}
	return isUnique;
}

bool ExitLoop_895::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool ExitLoop_895::isGuardTrue( SFC::CompoundStatement& CompoundStatement, SFC::Function& Function, CyberComposition::Simulink::TransConnector& SrcTransConnector, CyberComposition::Simulink::State& State, SFC::LocalVar& TCVar)
{
	bool Gz_guard= false;
	return static_cast< std::string >( TCVar.name() ) == "_TCVar_";;
	return Gz_guard;
}

void ExitLoop_895::processInputPackets( const Packets_t& states_896, const Packets_t& srcTransConnectors_898, const Packets_t& functions_89a, const Packets_t& compoundStatements_89c)
{
	for( Packets_t::const_iterator itState_89f= states_896.begin(), itSrcTransConnector_8a8= srcTransConnectors_898.begin(), itFunction_8b1= functions_89a.begin(), itCompoundStatement_8ba= compoundStatements_89c.begin(); itState_89f!= states_896.end(), itSrcTransConnector_8a8!= srcTransConnectors_898.end(), itFunction_8b1!= functions_89a.end(), itCompoundStatement_8ba!= compoundStatements_89c.end(); ++itState_89f, ++itSrcTransConnector_8a8, ++itFunction_8b1, ++itCompoundStatement_8ba)
	{
		bool isUnique= isInputUnique( *itState_89f, *itSrcTransConnector_8a8, *itFunction_8b1, *itCompoundStatement_8ba);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_89f, *itSrcTransConnector_8a8, *itFunction_8b1, *itCompoundStatement_8ba);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ExitLoop_895::patternMatcher( const Udm::Object& state_8a0, const Udm::Object& srcTransConnector_8a9, const Udm::Object& function_8b2, const Udm::Object& compoundStatement_8bb)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_8a0.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_8a5= CyberComposition::Simulink::State::Cast( state_8a0);
		if( false== Uml::IsDerivedFrom( srcTransConnector_8a9.type(), CyberComposition::Simulink::TransConnector::meta))
			continue;
		CyberComposition::Simulink::TransConnector srcTransConnector_8ae= CyberComposition::Simulink::TransConnector::Cast( srcTransConnector_8a9);
		if( false== Uml::IsDerivedFrom( function_8b2.type(), SFC::Function::meta))
			continue;
		SFC::Function function_8b7= SFC::Function::Cast( function_8b2);
		if( false== Uml::IsDerivedFrom( compoundStatement_8bb.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_8c0= SFC::CompoundStatement::Cast( compoundStatement_8bb);
		set< SFC::LocalVar> tCVars_8c2= function_8b7.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itTCVar_8c3= tCVars_8c2.begin(); itTCVar_8c3!= tCVars_8c2.end(); ++itTCVar_8c3)
		{
			SFC::LocalVar currTCVar_8c4= *itTCVar_8c3;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_8c8;
			if( !isValidBound(boundObjs_8c8, state_8a5, true))
				continue;
			currMatch.state_8c9= state_8a5;
			if( !isValidBound(boundObjs_8c8, srcTransConnector_8ae, true))
				continue;
			currMatch.srcTransConnector_8ca= srcTransConnector_8ae;
			if( !isValidBound(boundObjs_8c8, function_8b7, true))
				continue;
			currMatch.function_8cb= function_8b7;
			if( !isValidBound(boundObjs_8c8, compoundStatement_8c0, true))
				continue;
			currMatch.compoundStatement_8cc= compoundStatement_8c0;
			if( !isValidBound(boundObjs_8c8, currTCVar_8c4, false))
				continue;
			currMatch.tCVar_8cd= currTCVar_8c4;
			bool Gz_guard= isGuardTrue( currMatch.compoundStatement_8cc, currMatch.function_8cb, currMatch.srcTransConnector_8ca, currMatch.state_8c9, currMatch.tCVar_8cd);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void ExitLoop_895::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_8d3= SFC::ConditionalBlock::Create( currMatch.compoundStatement_8cc, SFC::CompoundStatement::meta_stmnt);
		SFC::UserCode newUserCode_8d4= SFC::UserCode::Create( newConditionalBlock_8d3, SFC::ConditionalBlock::meta_stmnt);
		SFC::BinaryExprs newAssign_8d5= SFC::BinaryExprs::Create( newUserCode_8d4, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newArgDeclRef_8d6= SFC::ArgDeclRef::Create( newAssign_8d5, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newNegOne_8d7= SFC::Int::Create( newAssign_8d5, SFC::BinaryExprs::meta_rightexpr);
		SFC::UserCode newTrueCond_8d8= SFC::UserCode::Create( newConditionalBlock_8d3, SFC::ConditionalBlock::meta_cond);
		SFC::Int newOne_8d9= SFC::Int::Create( newTrueCond_8d8, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_8d6;
		SFC::BinaryExprs& Assign= newAssign_8d5;
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_8cc;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_8d3;
		SFC::Function& Function= currMatch.function_8cb;
		SFC::Int& NegOne= newNegOne_8d7;
		SFC::Int& One= newOne_8d9;
		CyberComposition::Simulink::TransConnector& SrcTransConnector= currMatch.srcTransConnector_8ca;
		CyberComposition::Simulink::State& State= currMatch.state_8c9;
		SFC::LocalVar& TCVar= currMatch.tCVar_8cd;
		SFC::UserCode& TrueCond= newTrueCond_8d8;
		SFC::UserCode& UserCode= newUserCode_8d4;
		{
ConditionalBlock.RefId() = UserCode.RefId() = SrcTransConnector.RefId();
};
		{
Assign.op() = "=";
};
		{
__int64 statementCount = ConditionalBlock.statementCount();
UserCode.statementIndex() = statementCount++;
ConditionalBlock.statementCount() = statementCount;
};
		{
__int64 statementCount = CompoundStatement.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		{
One.val() = 1;
};
		{
NegOne.val() = -1;
};
		newArgDeclRef_8d6.argdecl()= currMatch.tCVar_8cd;
	}
}

void NDTTest_8da::operator()( const Packets_t& states_8db, const Packets_t& tcs_8dd, const Packets_t& fcns_8df, const Packets_t& css_8e1, Packets_t& states_8e3, Packets_t& tcs_8e4, Packets_t& fcns_8e5, Packets_t& css_8e6)
{
#ifdef PRINT_INFO
	printLog( "NDTTest_8da" );
#endif
	_state_8e7= &states_8e3;
	_tc_8e8= &tcs_8e4;
	_fcn_8e9= &fcns_8e5;
	_cs_8ea= &css_8e6;
	for( Packets_t::const_iterator itstate_8ec= states_8db.begin(), ittc_8f3= tcs_8dd.begin(), itfcn_8fa= fcns_8df.begin(), itcs_901= css_8e1.begin(); itstate_8ec!= states_8db.end(), ittc_8f3!= tcs_8dd.end(), itfcn_8fa!= fcns_8df.end(), itcs_901!= css_8e1.end(); ++itstate_8ec, ++ittc_8f3, ++itfcn_8fa, ++itcs_901)
	{
		bool isUnique= isInputUnique( *itstate_8ec, *ittc_8f3, *itfcn_8fa, *itcs_901);
		if( !isUnique)
			continue;
		Packets_t onestate_8f0( 1, *itstate_8ec);
		Packets_t onetc_8f7( 1, *ittc_8f3);
		Packets_t onefcn_8fe( 1, *itfcn_8fa);
		Packets_t onecs_905( 1, *itcs_901);
		executeOne( onestate_8f0, onetc_8f7, onefcn_8fe, onecs_905);
	}
}

void NDTTest_8da::executeOne( const Packets_t& states_8db, const Packets_t& tcs_8dd, const Packets_t& fcns_8df, const Packets_t& css_8e1)
{
	HasDefaultTransitionDouble_907 hasDefaultTransitionDouble_907;
	bool isMatchHasDefaultTransitionDouble_907= hasDefaultTransitionDouble_907( states_8db, tcs_8dd, fcns_8df, css_8e1);
	if( isMatchHasDefaultTransitionDouble_907)
		return;
	HasDefaultTransitionInt_94f hasDefaultTransitionInt_94f;
	bool isMatchHasDefaultTransitionInt_94f= hasDefaultTransitionInt_94f( states_8db, tcs_8dd, fcns_8df, css_8e1);
	if( isMatchHasDefaultTransitionInt_94f)
		return;
	Packets_t states_99a;
	Packets_t transConnectors_99d;
	Packets_t functions_9a0;
	Packets_t compoundStatements_9a3;
	NoDefault_997 noDefault_997;
	bool isMatchNoDefault_997= noDefault_997( states_8db, tcs_8dd, fcns_8df, css_8e1, states_99a, transConnectors_99d, functions_9a0, compoundStatements_9a3);
	_state_8e7->insert( _state_8e7->end(), states_99a.begin(), states_99a.end());
	_tc_8e8->insert( _tc_8e8->end(), transConnectors_99d.begin(), transConnectors_99d.end());
	_fcn_8e9->insert( _fcn_8e9->end(), functions_9a0.begin(), functions_9a0.end());
	_cs_8ea->insert( _cs_8ea->end(), compoundStatements_9a3.begin(), compoundStatements_9a3.end());
	if( isMatchNoDefault_997)
		return;
}

bool NDTTest_8da::isInputUnique( const Udm::Object& state_8ed, const Udm::Object& tc_8f4, const Udm::Object& fcn_8fb, const Udm::Object& cs_902)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_8ef= _state_8eb.begin(), ittc_8f6= _tc_8f2.begin(), itfcn_8fd= _fcn_8f9.begin(), itcs_904= _cs_900.begin(); itstate_8ef!= _state_8eb.end(), ittc_8f6!= _tc_8f2.end(), itfcn_8fd!= _fcn_8f9.end(), itcs_904!= _cs_900.end(); ++itstate_8ef, ++ittc_8f6, ++itfcn_8fd, ++itcs_904)
	{
		if( ( *itstate_8ef== state_8ed)&& ( *ittc_8f6== tc_8f4)&& ( *itfcn_8fd== fcn_8fb)&& ( *itcs_904== cs_902))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_8eb.push_back( state_8ed);
		_tc_8f2.push_back( tc_8f4);
		_fcn_8f9.push_back( fcn_8fb);
		_cs_900.push_back( cs_902);
	}
	return isUnique;
}

bool HasDefaultTransitionDouble_907::operator()( const Packets_t& states_908, const Packets_t& srcTransConnectors_90a, const Packets_t& functions_90c, const Packets_t& compoundStatements_90e)
{
#ifdef PRINT_INFO
	printLog( "HasDefaultTransitionDouble_907" );
#endif
	processInputPackets( states_908, srcTransConnectors_90a, functions_90c, compoundStatements_90e);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasDefaultTransitionDouble_907::isInputUnique( const Udm::Object& state_914, const Udm::Object& srcTransConnector_91d, const Udm::Object& function_926, const Udm::Object& compoundStatement_92f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_916= _state_910.begin(), itSrcTransConnector_91f= _srcTransConnector_919.begin(), itFunction_928= _function_922.begin(), itCompoundStatement_931= _compoundStatement_92b.begin(); itState_916!= _state_910.end(), itSrcTransConnector_91f!= _srcTransConnector_919.end(), itFunction_928!= _function_922.end(), itCompoundStatement_931!= _compoundStatement_92b.end(); ++itState_916, ++itSrcTransConnector_91f, ++itFunction_928, ++itCompoundStatement_931)
	{
		if( ( *itState_916== state_914)&& ( *itSrcTransConnector_91f== srcTransConnector_91d)&& ( *itFunction_928== function_926)&& ( *itCompoundStatement_931== compoundStatement_92f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_910.push_back( state_914);
		_srcTransConnector_919.push_back( srcTransConnector_91d);
		_function_922.push_back( function_926);
		_compoundStatement_92b.push_back( compoundStatement_92f);
	}
	return isUnique;
}

bool HasDefaultTransitionDouble_907::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool HasDefaultTransitionDouble_907::isGuardTrue( SFC::CompoundStatement& CompoundStatement, SFC::ConditionalBlock& ConditionalBlock, SFC::Double& Double, SFC::Function& Function, CyberComposition::Simulink::TransConnector& SrcTransConnector, CyberComposition::Simulink::State& State, SFC::UserCode& UserCode)
{
	bool Gz_guard= false;
	return Double.val() == 1;;
	return Gz_guard;
}

void HasDefaultTransitionDouble_907::processInputPackets( const Packets_t& states_908, const Packets_t& srcTransConnectors_90a, const Packets_t& functions_90c, const Packets_t& compoundStatements_90e)
{
	for( Packets_t::const_iterator itState_911= states_908.begin(), itSrcTransConnector_91a= srcTransConnectors_90a.begin(), itFunction_923= functions_90c.begin(), itCompoundStatement_92c= compoundStatements_90e.begin(); itState_911!= states_908.end(), itSrcTransConnector_91a!= srcTransConnectors_90a.end(), itFunction_923!= functions_90c.end(), itCompoundStatement_92c!= compoundStatements_90e.end(); ++itState_911, ++itSrcTransConnector_91a, ++itFunction_923, ++itCompoundStatement_92c)
	{
		bool isUnique= isInputUnique( *itState_911, *itSrcTransConnector_91a, *itFunction_923, *itCompoundStatement_92c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_911, *itSrcTransConnector_91a, *itFunction_923, *itCompoundStatement_92c);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( );
	}
}

bool HasDefaultTransitionDouble_907::patternMatcher( const Udm::Object& state_912, const Udm::Object& srcTransConnector_91b, const Udm::Object& function_924, const Udm::Object& compoundStatement_92d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_912.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_917= CyberComposition::Simulink::State::Cast( state_912);
		if( false== Uml::IsDerivedFrom( srcTransConnector_91b.type(), CyberComposition::Simulink::TransConnector::meta))
			continue;
		CyberComposition::Simulink::TransConnector srcTransConnector_920= CyberComposition::Simulink::TransConnector::Cast( srcTransConnector_91b);
		if( false== Uml::IsDerivedFrom( function_924.type(), SFC::Function::meta))
			continue;
		SFC::Function function_929= SFC::Function::Cast( function_924);
		if( false== Uml::IsDerivedFrom( compoundStatement_92d.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_932= SFC::CompoundStatement::Cast( compoundStatement_92d);
		set< SFC::ConditionalBlock> conditionalBlocks_934= compoundStatement_932.ConditionalBlock_kind_children();
		for( set< SFC::ConditionalBlock>::const_iterator itConditionalBlock_935= conditionalBlocks_934.begin(); itConditionalBlock_935!= conditionalBlocks_934.end(); ++itConditionalBlock_935)
		{
			SFC::ConditionalBlock currConditionalBlock_936= *itConditionalBlock_935;
			set< SFC::UserCode> userCodes_937= currConditionalBlock_936.UserCode_kind_children();
			for( set< SFC::UserCode>::const_iterator itUserCode_938= userCodes_937.begin(); itUserCode_938!= userCodes_937.end(); ++itUserCode_938)
			{
				SFC::UserCode currUserCode_939= *itUserCode_938;
				set< SFC::Double> doubles_93a= currUserCode_939.Double_kind_children();
				for( set< SFC::Double>::const_iterator itDouble_93b= doubles_93a.begin(); itDouble_93b!= doubles_93a.end(); ++itDouble_93b)
				{
					SFC::Double currDouble_93c= *itDouble_93b;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_940;
					if( !isValidBound(boundObjs_940, state_917, true))
						continue;
					currMatch.state_941= state_917;
					if( !isValidBound(boundObjs_940, srcTransConnector_920, true))
						continue;
					currMatch.srcTransConnector_942= srcTransConnector_920;
					if( !isValidBound(boundObjs_940, function_929, true))
						continue;
					currMatch.function_943= function_929;
					if( !isValidBound(boundObjs_940, compoundStatement_932, true))
						continue;
					currMatch.compoundStatement_944= compoundStatement_932;
					if( !isValidBound(boundObjs_940, currUserCode_939, false))
						continue;
					currMatch.userCode_945= currUserCode_939;
					if( !isValidBound(boundObjs_940, currDouble_93c, false))
						continue;
					currMatch.double_946= currDouble_93c;
					if( !isValidBound(boundObjs_940, currConditionalBlock_936, false))
						continue;
					currMatch.conditionalBlock_947= currConditionalBlock_936;
					bool Gz_guard= isGuardTrue( currMatch.compoundStatement_944, currMatch.conditionalBlock_947, currMatch.double_946, currMatch.function_943, currMatch.srcTransConnector_942, currMatch.state_941, currMatch.userCode_945);
					if( true== Gz_guard)
						_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void HasDefaultTransitionDouble_907::outputAppender()
{
}

bool HasDefaultTransitionInt_94f::operator()( const Packets_t& states_950, const Packets_t& srcTransConnectors_952, const Packets_t& functions_954, const Packets_t& compoundStatements_956)
{
#ifdef PRINT_INFO
	printLog( "HasDefaultTransitionInt_94f" );
#endif
	processInputPackets( states_950, srcTransConnectors_952, functions_954, compoundStatements_956);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasDefaultTransitionInt_94f::isInputUnique( const Udm::Object& state_95c, const Udm::Object& srcTransConnector_965, const Udm::Object& function_96e, const Udm::Object& compoundStatement_977)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_95e= _state_958.begin(), itSrcTransConnector_967= _srcTransConnector_961.begin(), itFunction_970= _function_96a.begin(), itCompoundStatement_979= _compoundStatement_973.begin(); itState_95e!= _state_958.end(), itSrcTransConnector_967!= _srcTransConnector_961.end(), itFunction_970!= _function_96a.end(), itCompoundStatement_979!= _compoundStatement_973.end(); ++itState_95e, ++itSrcTransConnector_967, ++itFunction_970, ++itCompoundStatement_979)
	{
		if( ( *itState_95e== state_95c)&& ( *itSrcTransConnector_967== srcTransConnector_965)&& ( *itFunction_970== function_96e)&& ( *itCompoundStatement_979== compoundStatement_977))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_958.push_back( state_95c);
		_srcTransConnector_961.push_back( srcTransConnector_965);
		_function_96a.push_back( function_96e);
		_compoundStatement_973.push_back( compoundStatement_977);
	}
	return isUnique;
}

bool HasDefaultTransitionInt_94f::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool HasDefaultTransitionInt_94f::isGuardTrue( SFC::CompoundStatement& CompoundStatement, SFC::ConditionalBlock& ConditionalBlock, SFC::Function& Function, SFC::Int& Int, CyberComposition::Simulink::TransConnector& SrcTransConnector, CyberComposition::Simulink::State& State, SFC::UserCode& UserCode)
{
	bool Gz_guard= false;
	return Int.val() == 1;;
	return Gz_guard;
}

void HasDefaultTransitionInt_94f::processInputPackets( const Packets_t& states_950, const Packets_t& srcTransConnectors_952, const Packets_t& functions_954, const Packets_t& compoundStatements_956)
{
	for( Packets_t::const_iterator itState_959= states_950.begin(), itSrcTransConnector_962= srcTransConnectors_952.begin(), itFunction_96b= functions_954.begin(), itCompoundStatement_974= compoundStatements_956.begin(); itState_959!= states_950.end(), itSrcTransConnector_962!= srcTransConnectors_952.end(), itFunction_96b!= functions_954.end(), itCompoundStatement_974!= compoundStatements_956.end(); ++itState_959, ++itSrcTransConnector_962, ++itFunction_96b, ++itCompoundStatement_974)
	{
		bool isUnique= isInputUnique( *itState_959, *itSrcTransConnector_962, *itFunction_96b, *itCompoundStatement_974);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_959, *itSrcTransConnector_962, *itFunction_96b, *itCompoundStatement_974);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( );
	}
}

bool HasDefaultTransitionInt_94f::patternMatcher( const Udm::Object& state_95a, const Udm::Object& srcTransConnector_963, const Udm::Object& function_96c, const Udm::Object& compoundStatement_975)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_95a.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_95f= CyberComposition::Simulink::State::Cast( state_95a);
		if( false== Uml::IsDerivedFrom( srcTransConnector_963.type(), CyberComposition::Simulink::TransConnector::meta))
			continue;
		CyberComposition::Simulink::TransConnector srcTransConnector_968= CyberComposition::Simulink::TransConnector::Cast( srcTransConnector_963);
		if( false== Uml::IsDerivedFrom( function_96c.type(), SFC::Function::meta))
			continue;
		SFC::Function function_971= SFC::Function::Cast( function_96c);
		if( false== Uml::IsDerivedFrom( compoundStatement_975.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_97a= SFC::CompoundStatement::Cast( compoundStatement_975);
		set< SFC::ConditionalBlock> conditionalBlocks_97c= compoundStatement_97a.ConditionalBlock_kind_children();
		for( set< SFC::ConditionalBlock>::const_iterator itConditionalBlock_97d= conditionalBlocks_97c.begin(); itConditionalBlock_97d!= conditionalBlocks_97c.end(); ++itConditionalBlock_97d)
		{
			SFC::ConditionalBlock currConditionalBlock_97e= *itConditionalBlock_97d;
			set< SFC::UserCode> userCodes_97f= currConditionalBlock_97e.UserCode_kind_children();
			for( set< SFC::UserCode>::const_iterator itUserCode_980= userCodes_97f.begin(); itUserCode_980!= userCodes_97f.end(); ++itUserCode_980)
			{
				SFC::UserCode currUserCode_981= *itUserCode_980;
				set< SFC::Int> ints_982= currUserCode_981.Int_kind_children();
				for( set< SFC::Int>::const_iterator itInt_983= ints_982.begin(); itInt_983!= ints_982.end(); ++itInt_983)
				{
					SFC::Int currInt_984= *itInt_983;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_988;
					if( !isValidBound(boundObjs_988, state_95f, true))
						continue;
					currMatch.state_989= state_95f;
					if( !isValidBound(boundObjs_988, srcTransConnector_968, true))
						continue;
					currMatch.srcTransConnector_98a= srcTransConnector_968;
					if( !isValidBound(boundObjs_988, function_971, true))
						continue;
					currMatch.function_98b= function_971;
					if( !isValidBound(boundObjs_988, compoundStatement_97a, true))
						continue;
					currMatch.compoundStatement_98c= compoundStatement_97a;
					if( !isValidBound(boundObjs_988, currUserCode_981, false))
						continue;
					currMatch.userCode_98d= currUserCode_981;
					if( !isValidBound(boundObjs_988, currInt_984, false))
						continue;
					currMatch.int_98e= currInt_984;
					if( !isValidBound(boundObjs_988, currConditionalBlock_97e, false))
						continue;
					currMatch.conditionalBlock_98f= currConditionalBlock_97e;
					bool Gz_guard= isGuardTrue( currMatch.compoundStatement_98c, currMatch.conditionalBlock_98f, currMatch.function_98b, currMatch.int_98e, currMatch.srcTransConnector_98a, currMatch.state_989, currMatch.userCode_98d);
					if( true== Gz_guard)
						_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void HasDefaultTransitionInt_94f::outputAppender()
{
}

bool NoDefault_997::operator()( const Packets_t& states_998, const Packets_t& transConnectors_99b, const Packets_t& functions_99e, const Packets_t& compoundStatements_9a1, Packets_t& states_99a, Packets_t& transConnectors_99d, Packets_t& functions_9a0, Packets_t& compoundStatements_9a3)
{
#ifdef PRINT_INFO
	printLog( "NoDefault_997" );
#endif
	_state_9a4= &states_99a;
	_transConnector_9a5= &transConnectors_99d;
	_function_9a6= &functions_9a0;
	_compoundStatement_9a7= &compoundStatements_9a3;
	processInputPackets( states_998, transConnectors_99b, functions_99e, compoundStatements_9a1);
	if( false== _matches.empty())
		return true;
	return false;
}

bool NoDefault_997::isInputUnique( const Udm::Object& state_9ac, const Udm::Object& transConnector_9b5, const Udm::Object& function_9be, const Udm::Object& compoundStatement_9c7)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_9ae= _state_9a8.begin(), itTransConnector_9b7= _transConnector_9b1.begin(), itFunction_9c0= _function_9ba.begin(), itCompoundStatement_9c9= _compoundStatement_9c3.begin(); itState_9ae!= _state_9a8.end(), itTransConnector_9b7!= _transConnector_9b1.end(), itFunction_9c0!= _function_9ba.end(), itCompoundStatement_9c9!= _compoundStatement_9c3.end(); ++itState_9ae, ++itTransConnector_9b7, ++itFunction_9c0, ++itCompoundStatement_9c9)
	{
		if( ( *itState_9ae== state_9ac)&& ( *itTransConnector_9b7== transConnector_9b5)&& ( *itFunction_9c0== function_9be)&& ( *itCompoundStatement_9c9== compoundStatement_9c7))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_9a8.push_back( state_9ac);
		_transConnector_9b1.push_back( transConnector_9b5);
		_function_9ba.push_back( function_9be);
		_compoundStatement_9c3.push_back( compoundStatement_9c7);
	}
	return isUnique;
}

bool NoDefault_997::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void NoDefault_997::processInputPackets( const Packets_t& states_998, const Packets_t& transConnectors_99b, const Packets_t& functions_99e, const Packets_t& compoundStatements_9a1)
{
	for( Packets_t::const_iterator itState_9a9= states_998.begin(), itTransConnector_9b2= transConnectors_99b.begin(), itFunction_9bb= functions_99e.begin(), itCompoundStatement_9c4= compoundStatements_9a1.begin(); itState_9a9!= states_998.end(), itTransConnector_9b2!= transConnectors_99b.end(), itFunction_9bb!= functions_99e.end(), itCompoundStatement_9c4!= compoundStatements_9a1.end(); ++itState_9a9, ++itTransConnector_9b2, ++itFunction_9bb, ++itCompoundStatement_9c4)
	{
		bool isUnique= isInputUnique( *itState_9a9, *itTransConnector_9b2, *itFunction_9bb, *itCompoundStatement_9c4);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_9a9, *itTransConnector_9b2, *itFunction_9bb, *itCompoundStatement_9c4);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_9d0, currMatch.transConnector_9d1, currMatch.function_9d2, currMatch.compoundStatement_9d3);
	}
}

bool NoDefault_997::patternMatcher( const Udm::Object& state_9aa, const Udm::Object& transConnector_9b3, const Udm::Object& function_9bc, const Udm::Object& compoundStatement_9c5)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_9aa.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_9af= CyberComposition::Simulink::State::Cast( state_9aa);
		if( false== Uml::IsDerivedFrom( transConnector_9b3.type(), CyberComposition::Simulink::TransConnector::meta))
			continue;
		CyberComposition::Simulink::TransConnector transConnector_9b8= CyberComposition::Simulink::TransConnector::Cast( transConnector_9b3);
		if( false== Uml::IsDerivedFrom( function_9bc.type(), SFC::Function::meta))
			continue;
		SFC::Function function_9c1= SFC::Function::Cast( function_9bc);
		if( false== Uml::IsDerivedFrom( compoundStatement_9c5.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_9ca= SFC::CompoundStatement::Cast( compoundStatement_9c5);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_9cf;
		if( !isValidBound(boundObjs_9cf, state_9af, true))
			continue;
		currMatch.state_9d0= state_9af;
		if( !isValidBound(boundObjs_9cf, transConnector_9b8, true))
			continue;
		currMatch.transConnector_9d1= transConnector_9b8;
		if( !isValidBound(boundObjs_9cf, function_9c1, true))
			continue;
		currMatch.function_9d2= function_9c1;
		if( !isValidBound(boundObjs_9cf, compoundStatement_9ca, true))
			continue;
		currMatch.compoundStatement_9d3= compoundStatement_9ca;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void NoDefault_997::outputAppender( const CyberComposition::Simulink::State& state_9d4, const CyberComposition::Simulink::TransConnector& transConnector_9d6, const SFC::Function& function_9d8, const SFC::CompoundStatement& compoundStatement_9da)
{
	_state_9a4->push_back( state_9d4);
	_transConnector_9a5->push_back( transConnector_9d6);
	_function_9a6->push_back( function_9d8);
	_compoundStatement_9a7->push_back( compoundStatement_9da);
}

void TransStartMap_a07::operator()( const Packets_t& states_a08, const Packets_t& css_a0a, Packets_t& states_a0c, Packets_t& css_a0d)
{
#ifdef PRINT_INFO
	printLog( "TransStartMap_a07" );
#endif
	_state_a0e= &states_a0c;
	_cs_a0f= &css_a0d;
	_state_a0e->insert( _state_a0e->end(), states_a08.begin(), states_a08.end());
	_cs_a0f->insert( _cs_a0f->end(), css_a0a.begin(), css_a0a.end());
	if( ( !states_a08.empty()))
		callInitTransConnectorMap_c1c( states_a08);
}

void TransStartMap_a07::callInitTransConnectorMap_c1c( const Packets_t& states_a11)
{
	Packets_t states_a13;
	Packets_t transStarts_a14;
	InitTransConnectorMap_a10 initTransConnectorMap_a10;
	initTransConnectorMap_a10( states_a11, states_a13, transStarts_a14);
	if( ( !states_a13.empty())&& ( !transStarts_a14.empty()))
		callTransConnectorMapRecurse_c1e( states_a13, transStarts_a14);
}

void TransStartMap_a07::callTransConnectorMapRecurse_c1e( const Packets_t& states_a2b, const Packets_t& tcs_a2d)
{
	TransConnectorMapRecurse_a2a transConnectorMapRecurse_a2a;
	transConnectorMapRecurse_a2a( states_a2b, tcs_a2d);
}

void InitTransConnectorMap_a10::operator()( const Packets_t& states_a11, Packets_t& states_a13, Packets_t& transStarts_a14)
{
#ifdef PRINT_INFO
	printLog( "InitTransConnectorMap_a10" );
#endif
	RTTGenerator::Instance()->generateRule(701, "InitTransConnectorMap");
	_state_a15= &states_a13;
	_transStart_a16= &transStarts_a14;
	processInputPackets( states_a11);
}

bool InitTransConnectorMap_a10::isInputUnique( const Udm::Object& state_a1b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_a1d= _state_a17.begin(); itState_a1d!= _state_a17.end(); ++itState_a1d)
	{
		if( ( *itState_a1d== state_a1b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_a17.push_back( state_a1b);
	return isUnique;
}

void InitTransConnectorMap_a10::processInputPackets( const Packets_t& states_a11)
{
	for( Packets_t::const_iterator itState_a18= states_a11.begin(); itState_a18!= states_a11.end(); ++itState_a18)
	{
		bool isUnique= isInputUnique( *itState_a18);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_a18);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InitTransConnectorMap_a10::patternMatcher( const Udm::Object& state_a19)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_a19.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_a1e= CyberComposition::Simulink::State::Cast( state_a19);
		set< CyberComposition::Simulink::TransStart> transStarts_a20= state_a1e.TransStart_kind_children();
		for( set< CyberComposition::Simulink::TransStart>::const_iterator itTransStart_a21= transStarts_a20.begin(); itTransStart_a21!= transStarts_a20.end(); ++itTransStart_a21)
		{
			CyberComposition::Simulink::TransStart currTransStart_a22= *itTransStart_a21;
			Match currMatch;
			currMatch.state_a24= state_a1e;
			currMatch.transStart_a25= currTransStart_a22;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void InitTransConnectorMap_a10::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		CyberComposition::Simulink::State& State= currMatch.state_a24;
		CyberComposition::Simulink::TransStart& TransStart= currMatch.transStart_a25;
		{
SFManager::StateTransConnectorMap::get_singleton().clearState( State );
};
		outputAppender( currMatch.state_a24, currMatch.transStart_a25);
	}
}

void InitTransConnectorMap_a10::outputAppender( const CyberComposition::Simulink::State& state_a26, const CyberComposition::Simulink::TransStart& transStart_a28)
{
	_state_a15->push_back( state_a26);
	_transStart_a16->push_back( transStart_a28);
}

void TransConnectorMapRecurse_a2a::operator()( const Packets_t& states_a2b, const Packets_t& tcs_a2d)
{
#ifdef PRINT_INFO
	printLog( "TransConnectorMapRecurse_a2a" );
#endif
	for( Packets_t::const_iterator itstate_a30= states_a2b.begin(), ittc_a37= tcs_a2d.begin(); itstate_a30!= states_a2b.end(), ittc_a37!= tcs_a2d.end(); ++itstate_a30, ++ittc_a37)
	{
		bool isUnique= isInputUnique( *itstate_a30, *ittc_a37);
		if( !isUnique)
			continue;
		Packets_t onestate_a34( 1, *itstate_a30);
		Packets_t onetc_a3b( 1, *ittc_a37);
		executeOne( onestate_a34, onetc_a3b);
	}
}

void TransConnectorMapRecurse_a2a::executeOne( const Packets_t& states_a2b, const Packets_t& tcs_a2d)
{
	if( ( !states_a2b.empty())&& ( !tcs_a2d.empty()))
		callProcessedFilter_c10( states_a2b, tcs_a2d);
}

bool TransConnectorMapRecurse_a2a::isInputUnique( const Udm::Object& state_a31, const Udm::Object& tc_a38)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_a33= _state_a2f.begin(), ittc_a3a= _tc_a36.begin(); itstate_a33!= _state_a2f.end(), ittc_a3a!= _tc_a36.end(); ++itstate_a33, ++ittc_a3a)
	{
		if( ( *itstate_a33== state_a31)&& ( *ittc_a3a== tc_a38))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_a2f.push_back( state_a31);
		_tc_a36.push_back( tc_a38);
	}
	return isUnique;
}

void TransConnectorMapRecurse_a2a::callProcessedFilter_c10( const Packets_t& states_bd6, const Packets_t& tcs_bd8)
{
	Packets_t states_bda;
	Packets_t tcs_bdb;
	ProcessedFilter_bd5 processedFilter_bd5;
	processedFilter_bd5( states_bd6, tcs_bd8, states_bda, tcs_bdb);
	if( ( !states_bda.empty())&& ( !tcs_bdb.empty()))
		callAddTransConnector_c13( states_bda, tcs_bdb);
}

void TransConnectorMapRecurse_a2a::callAddTransConnector_c13( const Packets_t& states_ad9, const Packets_t& transConnectors_adc)
{
	Packets_t states_adb;
	Packets_t transConnectors_ade;
	AddTransConnector_ad8 addTransConnector_ad8;
	addTransConnector_ad8( states_ad9, transConnectors_adc, states_adb, transConnectors_ade);
	if( ( !states_adb.empty())&& ( !transConnectors_ade.empty()))
		callGetAllTransitions_c16( states_adb, transConnectors_ade);
}

void TransConnectorMapRecurse_a2a::callGetAllTransitions_c16( const Packets_t& states_a3e, const Packets_t& tcs_a40)
{
	Packets_t states_a42;
	Packets_t transs_a43;
	GetAllTransitions_a3d getAllTransitions_a3d;
	getAllTransitions_a3d( states_a3e, tcs_a40, states_a42, transs_a43);
	if( ( !states_a42.empty())&& ( !transs_a43.empty()))
		callProcessTransitionsMap_c19( states_a42, transs_a43);
}

void TransConnectorMapRecurse_a2a::callProcessTransitionsMap_c19( const Packets_t& states_af7, const Packets_t& transs_af9)
{
	ProcessTransitionsMap_af6 processTransitionsMap_af6;
	processTransitionsMap_af6( states_af7, transs_af9);
}

void GetAllTransitions_a3d::operator()( const Packets_t& states_a3e, const Packets_t& tcs_a40, Packets_t& states_a42, Packets_t& transs_a43)
{
#ifdef PRINT_INFO
	printLog( "GetAllTransitions_a3d" );
#endif
	_state_a44= &states_a42;
	_trans_a45= &transs_a43;
	if( ( !states_a3e.empty())&& ( !tcs_a40.empty()))
		callGetTransitionsFromJunctionRefs_acf( states_a3e, tcs_a40);
	if( ( !states_a3e.empty())&& ( !tcs_a40.empty()))
		callGetDirectTransitions_ad2( states_a3e, tcs_a40);
	if( ( !states_a3e.empty())&& ( !tcs_a40.empty()))
		callGetTransitionsFromStateRefs_ad5( states_a3e, tcs_a40);
}

void GetAllTransitions_a3d::callGetTransitionsFromJunctionRefs_acf( const Packets_t& states_aa4, const Packets_t& junctions_aa8)
{
	Packets_t states_aa6;
	Packets_t transitions_aa7;
	GetTransitionsFromJunctionRefs_aa3 getTransitionsFromJunctionRefs_aa3;
	getTransitionsFromJunctionRefs_aa3( states_aa4, junctions_aa8, states_aa6, transitions_aa7);
	_state_a44->insert( _state_a44->end(), states_aa6.begin(), states_aa6.end());
	_trans_a45->insert( _trans_a45->end(), transitions_aa7.begin(), transitions_aa7.end());
}

void GetAllTransitions_a3d::callGetDirectTransitions_ad2( const Packets_t& states_a7c, const Packets_t& srcTransConnectors_a7f)
{
	Packets_t states_a7e;
	Packets_t transitions_a81;
	GetDirectTransitions_a7b getDirectTransitions_a7b;
	getDirectTransitions_a7b( states_a7c, srcTransConnectors_a7f, states_a7e, transitions_a81);
	_state_a44->insert( _state_a44->end(), states_a7e.begin(), states_a7e.end());
	_trans_a45->insert( _trans_a45->end(), transitions_a81.begin(), transitions_a81.end());
}

void GetAllTransitions_a3d::callGetTransitionsFromStateRefs_ad5( const Packets_t& states_a47, const Packets_t& tCStates_a4b)
{
	Packets_t states_a49;
	Packets_t transitions_a4a;
	GetTransitionsFromStateRefs_a46 getTransitionsFromStateRefs_a46;
	getTransitionsFromStateRefs_a46( states_a47, tCStates_a4b, states_a49, transitions_a4a);
	_state_a44->insert( _state_a44->end(), states_a49.begin(), states_a49.end());
	_trans_a45->insert( _trans_a45->end(), transitions_a4a.begin(), transitions_a4a.end());
}

void GetTransitionsFromStateRefs_a46::operator()( const Packets_t& states_a47, const Packets_t& tCStates_a4b, Packets_t& states_a49, Packets_t& transitions_a4a)
{
#ifdef PRINT_INFO
	printLog( "GetTransitionsFromStateRefs_a46" );
#endif
	RTTGenerator::Instance()->generateRule(2290, "GetTransitionsFromStateRefs");
	_state_a4d= &states_a49;
	_transition_a4e= &transitions_a4a;
	processInputPackets( states_a47, tCStates_a4b);
}

bool GetTransitionsFromStateRefs_a46::isInputUnique( const Udm::Object& state_a53, const Udm::Object& tCState_a5c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_a55= _state_a4f.begin(), itTCState_a5e= _tCState_a58.begin(); itState_a55!= _state_a4f.end(), itTCState_a5e!= _tCState_a58.end(); ++itState_a55, ++itTCState_a5e)
	{
		if( ( *itState_a55== state_a53)&& ( *itTCState_a5e== tCState_a5c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_a4f.push_back( state_a53);
		_tCState_a58.push_back( tCState_a5c);
	}
	return isUnique;
}

bool GetTransitionsFromStateRefs_a46::isGuardTrue( CyberComposition::Simulink::ConnectorRef& ConnectorRef, CyberComposition::Simulink::TransConnector& DstTransConnector, CyberComposition::Simulink::State& RefParentState, CyberComposition::Simulink::State& State, CyberComposition::Simulink::State& TCState, CyberComposition::Simulink::Transition& Transition)
{
	bool Gz_guard= false;
	return State != RefParentState;;
	return Gz_guard;
}

void GetTransitionsFromStateRefs_a46::processInputPackets( const Packets_t& states_a47, const Packets_t& tCStates_a4b)
{
	for( Packets_t::const_iterator itState_a50= states_a47.begin(), itTCState_a59= tCStates_a4b.begin(); itState_a50!= states_a47.end(), itTCState_a59!= tCStates_a4b.end(); ++itState_a50, ++itTCState_a59)
	{
		bool isUnique= isInputUnique( *itState_a50, *itTCState_a59);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_a50, *itTCState_a59);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetTransitionsFromStateRefs_a46::patternMatcher( const Udm::Object& state_a51, const Udm::Object& tCState_a5a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_a51.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_a56= CyberComposition::Simulink::State::Cast( state_a51);
		if( false== Uml::IsDerivedFrom( tCState_a5a.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State tCState_a5f= CyberComposition::Simulink::State::Cast( tCState_a5a);
		set< CyberComposition::Simulink::ConnectorRef> connectorRefs_a61= state_a56.referedbyConnectorRef();
		for( set< CyberComposition::Simulink::ConnectorRef>::const_iterator itConnectorRefs_a62= connectorRefs_a61.begin(); itConnectorRefs_a62!= connectorRefs_a61.end(); ++itConnectorRefs_a62)
		{
			CyberComposition::Simulink::ConnectorRef currConnectorRef_a63= *itConnectorRefs_a62;
			Udm::Object connectorRefParent_a64= currConnectorRef_a63.container();
			if( false== Uml::IsDerivedFrom( connectorRefParent_a64.type(), CyberComposition::Simulink::State::meta))
				continue;
			CyberComposition::Simulink::State refParentStateConnectorRef_a65= CyberComposition::Simulink::State::Cast( connectorRefParent_a64);
			set< CyberComposition::Simulink::Transition> transitions_a66= currConnectorRef_a63.dstTransition();
			for( set< CyberComposition::Simulink::Transition>::const_iterator itTransitions_a67= transitions_a66.begin(); itTransitions_a67!= transitions_a66.end(); ++itTransitions_a67)
			{
				CyberComposition::Simulink::Transition currTransition_a68= *itTransitions_a67;
				CyberComposition::Simulink::TransConnector dstTransConnector_a69= currTransition_a68.dstTransition_end();
				Match currMatch;
				currMatch.state_a6b= state_a56;
				currMatch.tCState_a6c= tCState_a5f;
				currMatch.refParentState_a6d= refParentStateConnectorRef_a65;
				currMatch.transition_a6e= currTransition_a68;
				currMatch.connectorRef_a6f= currConnectorRef_a63;
				currMatch.dstTransConnector_a70= dstTransConnector_a69;
				bool Gz_guard= isGuardTrue( currMatch.connectorRef_a6f, currMatch.dstTransConnector_a70, currMatch.refParentState_a6d, currMatch.state_a6b, currMatch.tCState_a6c, currMatch.transition_a6e);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetTransitionsFromStateRefs_a46::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_a6b, currMatch.transition_a6e);
	}
}

void GetTransitionsFromStateRefs_a46::outputAppender( const CyberComposition::Simulink::State& state_a77, const CyberComposition::Simulink::Transition& transition_a79)
{
	_state_a4d->push_back( state_a77);
	_transition_a4e->push_back( transition_a79);
}

void GetDirectTransitions_a7b::operator()( const Packets_t& states_a7c, const Packets_t& srcTransConnectors_a7f, Packets_t& states_a7e, Packets_t& transitions_a81)
{
#ifdef PRINT_INFO
	printLog( "GetDirectTransitions_a7b" );
#endif
	RTTGenerator::Instance()->generateRule(2301, "GetDirectTransitions");
	_state_a82= &states_a7e;
	_transition_a83= &transitions_a81;
	processInputPackets( states_a7c, srcTransConnectors_a7f);
}

bool GetDirectTransitions_a7b::isInputUnique( const Udm::Object& state_a88, const Udm::Object& srcTransConnector_a91)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_a8a= _state_a84.begin(), itSrcTransConnector_a93= _srcTransConnector_a8d.begin(); itState_a8a!= _state_a84.end(), itSrcTransConnector_a93!= _srcTransConnector_a8d.end(); ++itState_a8a, ++itSrcTransConnector_a93)
	{
		if( ( *itState_a8a== state_a88)&& ( *itSrcTransConnector_a93== srcTransConnector_a91))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_a84.push_back( state_a88);
		_srcTransConnector_a8d.push_back( srcTransConnector_a91);
	}
	return isUnique;
}

void GetDirectTransitions_a7b::processInputPackets( const Packets_t& states_a7c, const Packets_t& srcTransConnectors_a7f)
{
	for( Packets_t::const_iterator itState_a85= states_a7c.begin(), itSrcTransConnector_a8e= srcTransConnectors_a7f.begin(); itState_a85!= states_a7c.end(), itSrcTransConnector_a8e!= srcTransConnectors_a7f.end(); ++itState_a85, ++itSrcTransConnector_a8e)
	{
		bool isUnique= isInputUnique( *itState_a85, *itSrcTransConnector_a8e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_a85, *itSrcTransConnector_a8e);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetDirectTransitions_a7b::patternMatcher( const Udm::Object& state_a86, const Udm::Object& srcTransConnector_a8f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_a86.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_a8b= CyberComposition::Simulink::State::Cast( state_a86);
		if( false== Uml::IsDerivedFrom( srcTransConnector_a8f.type(), CyberComposition::Simulink::TransConnector::meta))
			continue;
		CyberComposition::Simulink::TransConnector srcTransConnector_a94= CyberComposition::Simulink::TransConnector::Cast( srcTransConnector_a8f);
		set< CyberComposition::Simulink::Transition> transitions_a96= srcTransConnector_a94.dstTransition();
		for( set< CyberComposition::Simulink::Transition>::const_iterator itTransitions_a97= transitions_a96.begin(); itTransitions_a97!= transitions_a96.end(); ++itTransitions_a97)
		{
			CyberComposition::Simulink::Transition currTransition_a98= *itTransitions_a97;
			CyberComposition::Simulink::TransConnector dstTransConnector_a99= currTransition_a98.dstTransition_end();
			Match currMatch;
			currMatch.state_a9b= state_a8b;
			currMatch.srcTransConnector_a9c= srcTransConnector_a94;
			currMatch.transition_a9d= currTransition_a98;
			currMatch.dstTransConnector_a9e= dstTransConnector_a99;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetDirectTransitions_a7b::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_a9b, currMatch.transition_a9d);
	}
}

void GetDirectTransitions_a7b::outputAppender( const CyberComposition::Simulink::State& state_a9f, const CyberComposition::Simulink::Transition& transition_aa1)
{
	_state_a82->push_back( state_a9f);
	_transition_a83->push_back( transition_aa1);
}

void GetTransitionsFromJunctionRefs_aa3::operator()( const Packets_t& states_aa4, const Packets_t& junctions_aa8, Packets_t& states_aa6, Packets_t& transitions_aa7)
{
#ifdef PRINT_INFO
	printLog( "GetTransitionsFromJunctionRefs_aa3" );
#endif
	RTTGenerator::Instance()->generateRule(2308, "GetTransitionsFromJunctionRefs");
	_state_aaa= &states_aa6;
	_transition_aab= &transitions_aa7;
	processInputPackets( states_aa4, junctions_aa8);
}

bool GetTransitionsFromJunctionRefs_aa3::isInputUnique( const Udm::Object& state_ab0, const Udm::Object& junction_ab9)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_ab2= _state_aac.begin(), itJunction_abb= _junction_ab5.begin(); itState_ab2!= _state_aac.end(), itJunction_abb!= _junction_ab5.end(); ++itState_ab2, ++itJunction_abb)
	{
		if( ( *itState_ab2== state_ab0)&& ( *itJunction_abb== junction_ab9))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_aac.push_back( state_ab0);
		_junction_ab5.push_back( junction_ab9);
	}
	return isUnique;
}

void GetTransitionsFromJunctionRefs_aa3::processInputPackets( const Packets_t& states_aa4, const Packets_t& junctions_aa8)
{
	for( Packets_t::const_iterator itState_aad= states_aa4.begin(), itJunction_ab6= junctions_aa8.begin(); itState_aad!= states_aa4.end(), itJunction_ab6!= junctions_aa8.end(); ++itState_aad, ++itJunction_ab6)
	{
		bool isUnique= isInputUnique( *itState_aad, *itJunction_ab6);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_aad, *itJunction_ab6);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetTransitionsFromJunctionRefs_aa3::patternMatcher( const Udm::Object& state_aae, const Udm::Object& junction_ab7)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_aae.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_ab3= CyberComposition::Simulink::State::Cast( state_aae);
		if( false== Uml::IsDerivedFrom( junction_ab7.type(), CyberComposition::Simulink::SF_Junction::meta))
			continue;
		CyberComposition::Simulink::SF_Junction junction_abc= CyberComposition::Simulink::SF_Junction::Cast( junction_ab7);
		set< CyberComposition::Simulink::ConnectorRef> connectorRefs_abe= junction_abc.referedbyConnectorRef();
		for( set< CyberComposition::Simulink::ConnectorRef>::const_iterator itConnectorRefs_abf= connectorRefs_abe.begin(); itConnectorRefs_abf!= connectorRefs_abe.end(); ++itConnectorRefs_abf)
		{
			CyberComposition::Simulink::ConnectorRef currConnectorRef_ac0= *itConnectorRefs_abf;
			set< CyberComposition::Simulink::Transition> transitions_ac1= currConnectorRef_ac0.dstTransition();
			for( set< CyberComposition::Simulink::Transition>::const_iterator itTransitions_ac2= transitions_ac1.begin(); itTransitions_ac2!= transitions_ac1.end(); ++itTransitions_ac2)
			{
				CyberComposition::Simulink::Transition currTransition_ac3= *itTransitions_ac2;
				CyberComposition::Simulink::TransConnector dstTransConnector_ac4= currTransition_ac3.dstTransition_end();
				Match currMatch;
				currMatch.state_ac6= state_ab3;
				currMatch.junction_ac7= junction_abc;
				currMatch.transition_ac8= currTransition_ac3;
				currMatch.connectorRef_ac9= currConnectorRef_ac0;
				currMatch.dstTransConnector_aca= dstTransConnector_ac4;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetTransitionsFromJunctionRefs_aa3::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_ac6, currMatch.transition_ac8);
	}
}

void GetTransitionsFromJunctionRefs_aa3::outputAppender( const CyberComposition::Simulink::State& state_acb, const CyberComposition::Simulink::Transition& transition_acd)
{
	_state_aaa->push_back( state_acb);
	_transition_aab->push_back( transition_acd);
}

void AddTransConnector_ad8::operator()( const Packets_t& states_ad9, const Packets_t& transConnectors_adc, Packets_t& states_adb, Packets_t& transConnectors_ade)
{
#ifdef PRINT_INFO
	printLog( "AddTransConnector_ad8" );
#endif
	RTTGenerator::Instance()->generateRule(2317, "AddTransConnector");
	_state_adf= &states_adb;
	_transConnector_ae0= &transConnectors_ade;
	processInputPackets( states_ad9, transConnectors_adc);
	forwardInputs( );
}

bool AddTransConnector_ad8::isInputUnique( const Udm::Object& state_ae5, const Udm::Object& transConnector_aee)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_ae7= _state_ae1.begin(), itTransConnector_af0= _transConnector_aea.begin(); itState_ae7!= _state_ae1.end(), itTransConnector_af0!= _transConnector_aea.end(); ++itState_ae7, ++itTransConnector_af0)
	{
		if( ( *itState_ae7== state_ae5)&& ( *itTransConnector_af0== transConnector_aee))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_ae1.push_back( state_ae5);
		_transConnector_aea.push_back( transConnector_aee);
	}
	return isUnique;
}

void AddTransConnector_ad8::processInputPackets( const Packets_t& states_ad9, const Packets_t& transConnectors_adc)
{
	for( Packets_t::const_iterator itState_ae2= states_ad9.begin(), itTransConnector_aeb= transConnectors_adc.begin(); itState_ae2!= states_ad9.end(), itTransConnector_aeb!= transConnectors_adc.end(); ++itState_ae2, ++itTransConnector_aeb)
	{
		bool isUnique= isInputUnique( *itState_ae2, *itTransConnector_aeb);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_ae2, *itTransConnector_aeb);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AddTransConnector_ad8::patternMatcher( const Udm::Object& state_ae3, const Udm::Object& transConnector_aec)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_ae3.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_ae8= CyberComposition::Simulink::State::Cast( state_ae3);
		if( false== Uml::IsDerivedFrom( transConnector_aec.type(), CyberComposition::Simulink::TransConnector::meta))
			continue;
		CyberComposition::Simulink::TransConnector transConnector_af1= CyberComposition::Simulink::TransConnector::Cast( transConnector_aec);
		Match currMatch;
		currMatch.state_af4= state_ae8;
		currMatch.transConnector_af5= transConnector_af1;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void AddTransConnector_ad8::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		CyberComposition::Simulink::State& State= currMatch.state_af4;
		CyberComposition::Simulink::TransConnector& TransConnector= currMatch.transConnector_af5;
		{
SFManager::StateTransConnectorMap::get_singleton().getTransConnectorMap( State ).addTransConnector( TransConnector );
};
	}
}

void AddTransConnector_ad8::forwardInputs()
{
	*_state_adf= _state_ae1;
	*_transConnector_ae0= _transConnector_aea;
}

void ProcessTransitionsMap_af6::operator()( const Packets_t& states_af7, const Packets_t& transs_af9)
{
#ifdef PRINT_INFO
	printLog( "ProcessTransitionsMap_af6" );
#endif
	if( ( !states_af7.empty())&& ( !transs_af9.empty()))
		callOrderTransitions_bc6( states_af7, transs_af9);
}

void ProcessTransitionsMap_af6::callOrderTransitions_bc6( const Packets_t& states_b7f, const Packets_t& transitions_b82)
{
	Packets_t states_b81;
	Packets_t transitions_b84;
	OrderTransitions_b7e orderTransitions_b7e;
	orderTransitions_b7e( states_b7f, transitions_b82, states_b81, transitions_b84);
	if( ( !states_b81.empty())&& ( !transitions_b84.empty()))
		callgetDstTransConnectors_bc9( states_b81, transitions_b84);
}

void ProcessTransitionsMap_af6::callgetDstTransConnectors_bc9( const Packets_t& states_ba1, const Packets_t& transitions_ba5)
{
	Packets_t states_ba3;
	Packets_t dstTransConnectors_ba4;
	GetDstTransConnectors_ba0 getDstTransConnectors_ba0;
	getDstTransConnectors_ba0( states_ba1, transitions_ba5, states_ba3, dstTransConnectors_ba4);
	if( ( !states_ba3.empty())&& ( !dstTransConnectors_ba4.empty()))
		callTransConnTest_bcc( states_ba3, dstTransConnectors_ba4);
}

void ProcessTransitionsMap_af6::callTransConnTest_bcc( const Packets_t& states_b20, const Packets_t& tcs_b22)
{
	Packets_t states_b24;
	Packets_t tcs_b25;
	Packets_t states_b26;
	Packets_t tcs_b27;
	TransConnTest_b1f transConnTest_b1f;
	transConnTest_b1f( states_b20, tcs_b22, states_b24, tcs_b25, states_b26, tcs_b27);
	if( ( !states_b26.empty())&& ( !tcs_b27.empty()))
		callTransConnectorMapRecurse_bcf( states_b26, tcs_b27);
	if( ( !states_b24.empty())&& ( !tcs_b25.empty()))
		callDerefConnRef_bd2( states_b24, tcs_b25);
}

void ProcessTransitionsMap_af6::callTransConnectorMapRecurse_bcf( const Packets_t& states_a2b, const Packets_t& tcs_a2d)
{
	TransConnectorMapRecurse_a2a transConnectorMapRecurse_a2a;
	transConnectorMapRecurse_a2a( states_a2b, tcs_a2d);
}

void ProcessTransitionsMap_af6::callDerefConnRef_bd2( const Packets_t& states_afc, const Packets_t& connectorRefs_aff)
{
	Packets_t states_afe;
	Packets_t transConnectors_b01;
	DerefConnRef_afb derefConnRef_afb;
	derefConnRef_afb( states_afc, connectorRefs_aff, states_afe, transConnectors_b01);
	if( ( !states_afe.empty())&& ( !transConnectors_b01.empty()))
		callTransConnTest_bcc( states_afe, transConnectors_b01);
}

void DerefConnRef_afb::operator()( const Packets_t& states_afc, const Packets_t& connectorRefs_aff, Packets_t& states_afe, Packets_t& transConnectors_b01)
{
#ifdef PRINT_INFO
	printLog( "DerefConnRef_afb" );
#endif
	RTTGenerator::Instance()->generateRule(2324, "DerefConnRef");
	_state_b02= &states_afe;
	_transConnector_b03= &transConnectors_b01;
	processInputPackets( states_afc, connectorRefs_aff);
}

bool DerefConnRef_afb::isInputUnique( const Udm::Object& state_b08, const Udm::Object& connectorRef_b11)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_b0a= _state_b04.begin(), itConnectorRef_b13= _connectorRef_b0d.begin(); itState_b0a!= _state_b04.end(), itConnectorRef_b13!= _connectorRef_b0d.end(); ++itState_b0a, ++itConnectorRef_b13)
	{
		if( ( *itState_b0a== state_b08)&& ( *itConnectorRef_b13== connectorRef_b11))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_b04.push_back( state_b08);
		_connectorRef_b0d.push_back( connectorRef_b11);
	}
	return isUnique;
}

void DerefConnRef_afb::processInputPackets( const Packets_t& states_afc, const Packets_t& connectorRefs_aff)
{
	for( Packets_t::const_iterator itState_b05= states_afc.begin(), itConnectorRef_b0e= connectorRefs_aff.begin(); itState_b05!= states_afc.end(), itConnectorRef_b0e!= connectorRefs_aff.end(); ++itState_b05, ++itConnectorRef_b0e)
	{
		bool isUnique= isInputUnique( *itState_b05, *itConnectorRef_b0e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_b05, *itConnectorRef_b0e);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool DerefConnRef_afb::patternMatcher( const Udm::Object& state_b06, const Udm::Object& connectorRef_b0f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_b06.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_b0b= CyberComposition::Simulink::State::Cast( state_b06);
		if( false== Uml::IsDerivedFrom( connectorRef_b0f.type(), CyberComposition::Simulink::ConnectorRef::meta))
			continue;
		CyberComposition::Simulink::ConnectorRef connectorRef_b14= CyberComposition::Simulink::ConnectorRef::Cast( connectorRef_b0f);
		CyberComposition::Simulink::TransConnector transConnector_b16= connectorRef_b14.ref();
		if( !transConnector_b16)
			continue;
		Match currMatch;
		currMatch.state_b18= state_b0b;
		currMatch.connectorRef_b19= connectorRef_b14;
		currMatch.transConnector_b1a= transConnector_b16;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void DerefConnRef_afb::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_b18, currMatch.transConnector_b1a);
	}
}

void DerefConnRef_afb::outputAppender( const CyberComposition::Simulink::State& state_b1b, const CyberComposition::Simulink::TransConnector& transConnector_b1d)
{
	_state_b02->push_back( state_b1b);
	_transConnector_b03->push_back( transConnector_b1d);
}

void TransConnTest_b1f::operator()( const Packets_t& states_b20, const Packets_t& tcs_b22, Packets_t& states_b24, Packets_t& tcs_b25, Packets_t& states_b26, Packets_t& tcs_b27)
{
#ifdef PRINT_INFO
	printLog( "TransConnTest_b1f" );
#endif
	_state_b28= &states_b24;
	_tc_b29= &tcs_b25;
	_state_b2a= &states_b26;
	_tc_b2b= &tcs_b27;
	for( Packets_t::const_iterator itstate_b2d= states_b20.begin(), ittc_b34= tcs_b22.begin(); itstate_b2d!= states_b20.end(), ittc_b34!= tcs_b22.end(); ++itstate_b2d, ++ittc_b34)
	{
		bool isUnique= isInputUnique( *itstate_b2d, *ittc_b34);
		if( !isUnique)
			continue;
		Packets_t onestate_b31( 1, *itstate_b2d);
		Packets_t onetc_b38( 1, *ittc_b34);
		executeOne( onestate_b31, onetc_b38);
	}
}

void TransConnTest_b1f::executeOne( const Packets_t& states_b20, const Packets_t& tcs_b22)
{
	Packets_t states_b3d;
	Packets_t connectorRefs_b40;
	IsConnectorRef_b3a isConnectorRef_b3a;
	bool isMatchIsConnectorRef_b3a= isConnectorRef_b3a( states_b20, tcs_b22, states_b3d, connectorRefs_b40);
	_state_b28->insert( _state_b28->end(), states_b3d.begin(), states_b3d.end());
	_tc_b29->insert( _tc_b29->end(), connectorRefs_b40.begin(), connectorRefs_b40.end());
	if( isMatchIsConnectorRef_b3a)
		return;
	Packets_t states_b5f;
	Packets_t junctions_b62;
	Otherwise_b5c otherwise_b5c;
	bool isMatchOtherwise_b5c= otherwise_b5c( states_b20, tcs_b22, states_b5f, junctions_b62);
	_state_b2a->insert( _state_b2a->end(), states_b5f.begin(), states_b5f.end());
	_tc_b2b->insert( _tc_b2b->end(), junctions_b62.begin(), junctions_b62.end());
	if( isMatchOtherwise_b5c)
		return;
}

bool TransConnTest_b1f::isInputUnique( const Udm::Object& state_b2e, const Udm::Object& tc_b35)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_b30= _state_b2c.begin(), ittc_b37= _tc_b33.begin(); itstate_b30!= _state_b2c.end(), ittc_b37!= _tc_b33.end(); ++itstate_b30, ++ittc_b37)
	{
		if( ( *itstate_b30== state_b2e)&& ( *ittc_b37== tc_b35))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_b2c.push_back( state_b2e);
		_tc_b33.push_back( tc_b35);
	}
	return isUnique;
}

bool IsConnectorRef_b3a::operator()( const Packets_t& states_b3b, const Packets_t& connectorRefs_b3e, Packets_t& states_b3d, Packets_t& connectorRefs_b40)
{
#ifdef PRINT_INFO
	printLog( "IsConnectorRef_b3a" );
#endif
	_state_b41= &states_b3d;
	_connectorRef_b42= &connectorRefs_b40;
	processInputPackets( states_b3b, connectorRefs_b3e);
	if( false== _matches.empty())
		return true;
	return false;
}

bool IsConnectorRef_b3a::isInputUnique( const Udm::Object& state_b47, const Udm::Object& connectorRef_b50)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_b49= _state_b43.begin(), itConnectorRef_b52= _connectorRef_b4c.begin(); itState_b49!= _state_b43.end(), itConnectorRef_b52!= _connectorRef_b4c.end(); ++itState_b49, ++itConnectorRef_b52)
	{
		if( ( *itState_b49== state_b47)&& ( *itConnectorRef_b52== connectorRef_b50))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_b43.push_back( state_b47);
		_connectorRef_b4c.push_back( connectorRef_b50);
	}
	return isUnique;
}

void IsConnectorRef_b3a::processInputPackets( const Packets_t& states_b3b, const Packets_t& connectorRefs_b3e)
{
	for( Packets_t::const_iterator itState_b44= states_b3b.begin(), itConnectorRef_b4d= connectorRefs_b3e.begin(); itState_b44!= states_b3b.end(), itConnectorRef_b4d!= connectorRefs_b3e.end(); ++itState_b44, ++itConnectorRef_b4d)
	{
		bool isUnique= isInputUnique( *itState_b44, *itConnectorRef_b4d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_b44, *itConnectorRef_b4d);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_b56, currMatch.connectorRef_b57);
	}
}

bool IsConnectorRef_b3a::patternMatcher( const Udm::Object& state_b45, const Udm::Object& connectorRef_b4e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_b45.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_b4a= CyberComposition::Simulink::State::Cast( state_b45);
		if( false== Uml::IsDerivedFrom( connectorRef_b4e.type(), CyberComposition::Simulink::ConnectorRef::meta))
			continue;
		CyberComposition::Simulink::ConnectorRef connectorRef_b53= CyberComposition::Simulink::ConnectorRef::Cast( connectorRef_b4e);
		Match currMatch;
		currMatch.state_b56= state_b4a;
		currMatch.connectorRef_b57= connectorRef_b53;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void IsConnectorRef_b3a::outputAppender( const CyberComposition::Simulink::State& state_b58, const CyberComposition::Simulink::ConnectorRef& connectorRef_b5a)
{
	_state_b41->push_back( state_b58);
	_connectorRef_b42->push_back( connectorRef_b5a);
}

bool Otherwise_b5c::operator()( const Packets_t& states_b5d, const Packets_t& junctions_b60, Packets_t& states_b5f, Packets_t& junctions_b62)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_b5c" );
#endif
	_state_b63= &states_b5f;
	_junction_b64= &junctions_b62;
	processInputPackets( states_b5d, junctions_b60);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_b5c::isInputUnique( const Udm::Object& state_b69, const Udm::Object& junction_b72)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_b6b= _state_b65.begin(), itJunction_b74= _junction_b6e.begin(); itState_b6b!= _state_b65.end(), itJunction_b74!= _junction_b6e.end(); ++itState_b6b, ++itJunction_b74)
	{
		if( ( *itState_b6b== state_b69)&& ( *itJunction_b74== junction_b72))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_b65.push_back( state_b69);
		_junction_b6e.push_back( junction_b72);
	}
	return isUnique;
}

void Otherwise_b5c::processInputPackets( const Packets_t& states_b5d, const Packets_t& junctions_b60)
{
	for( Packets_t::const_iterator itState_b66= states_b5d.begin(), itJunction_b6f= junctions_b60.begin(); itState_b66!= states_b5d.end(), itJunction_b6f!= junctions_b60.end(); ++itState_b66, ++itJunction_b6f)
	{
		bool isUnique= isInputUnique( *itState_b66, *itJunction_b6f);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_b66, *itJunction_b6f);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_b78, currMatch.junction_b79);
	}
}

bool Otherwise_b5c::patternMatcher( const Udm::Object& state_b67, const Udm::Object& junction_b70)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_b67.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_b6c= CyberComposition::Simulink::State::Cast( state_b67);
		if( false== Uml::IsDerivedFrom( junction_b70.type(), CyberComposition::Simulink::SF_Junction::meta))
			continue;
		CyberComposition::Simulink::SF_Junction junction_b75= CyberComposition::Simulink::SF_Junction::Cast( junction_b70);
		Match currMatch;
		currMatch.state_b78= state_b6c;
		currMatch.junction_b79= junction_b75;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_b5c::outputAppender( const CyberComposition::Simulink::State& state_b7a, const CyberComposition::Simulink::SF_Junction& junction_b7c)
{
	_state_b63->push_back( state_b7a);
	_junction_b64->push_back( junction_b7c);
}

void OrderTransitions_b7e::operator()( const Packets_t& states_b7f, const Packets_t& transitions_b82, Packets_t& states_b81, Packets_t& transitions_b84)
{
#ifdef PRINT_INFO
	printLog( "OrderTransitions_b7e" );
#endif
	RTTGenerator::Instance()->generateRule(2342, "OrderTransitions");
	_state_b85= &states_b81;
	_transition_b86= &transitions_b84;
	processInputPackets( states_b7f, transitions_b82);
	sortOutputs( );
}

bool OrderTransitions_b7e::isInputUnique( const Udm::Object& state_b8b, const Udm::Object& transition_b94)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_b8d= _state_b87.begin(), itTransition_b96= _transition_b90.begin(); itState_b8d!= _state_b87.end(), itTransition_b96!= _transition_b90.end(); ++itState_b8d, ++itTransition_b96)
	{
		if( ( *itState_b8d== state_b8b)&& ( *itTransition_b96== transition_b94))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_b87.push_back( state_b8b);
		_transition_b90.push_back( transition_b94);
	}
	return isUnique;
}

void OrderTransitions_b7e::processInputPackets( const Packets_t& states_b7f, const Packets_t& transitions_b82)
{
	for( Packets_t::const_iterator itState_b88= states_b7f.begin(), itTransition_b91= transitions_b82.begin(); itState_b88!= states_b7f.end(), itTransition_b91!= transitions_b82.end(); ++itState_b88, ++itTransition_b91)
	{
		bool isUnique= isInputUnique( *itState_b88, *itTransition_b91);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_b88, *itTransition_b91);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool OrderTransitions_b7e::patternMatcher( const Udm::Object& state_b89, const Udm::Object& transition_b92)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_b89.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_b8e= CyberComposition::Simulink::State::Cast( state_b89);
		if( false== Uml::IsDerivedFrom( transition_b92.type(), CyberComposition::Simulink::Transition::meta))
			continue;
		CyberComposition::Simulink::Transition transition_b97= CyberComposition::Simulink::Transition::Cast( transition_b92);
		Match currMatch;
		currMatch.state_b9a= state_b8e;
		currMatch.transition_b9b= transition_b97;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void OrderTransitions_b7e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_b9a, currMatch.transition_b9b);
	}
}

void OrderTransitions_b7e::outputAppender( const CyberComposition::Simulink::State& state_b9c, const CyberComposition::Simulink::Transition& transition_b9e)
{
	_state_b85->push_back( state_b9c);
	_transition_b86->push_back( transition_b9e);
}

void OrderTransitions_b7e::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::Transition, std::pointer_to_binary_function< const CyberComposition::Simulink::Transition&, const CyberComposition::Simulink::Transition&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::Transition&, const CyberComposition::Simulink::Transition&, bool> ptr_TransitionOrder( TransitionOrder< CyberComposition::Simulink::Transition>);
	SortedSet_t sortedSet( ptr_TransitionOrder);
	std::vector< int> permutationVector( _transition_b86->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _transition_b86->begin(); it!= _transition_b86->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::Transition::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _transition_b86->begin());
	// order rest of the containers
	permutate( permutationVector, *_state_b85);
}

void GetDstTransConnectors_ba0::operator()( const Packets_t& states_ba1, const Packets_t& transitions_ba5, Packets_t& states_ba3, Packets_t& dstTransConnectors_ba4)
{
#ifdef PRINT_INFO
	printLog( "GetDstTransConnectors_ba0" );
#endif
	RTTGenerator::Instance()->generateRule(2345, "getDstTransConnectors");
	_state_ba7= &states_ba3;
	_dstTransConnector_ba8= &dstTransConnectors_ba4;
	processInputPackets( states_ba1, transitions_ba5);
}

bool GetDstTransConnectors_ba0::isInputUnique( const Udm::Object& state_bad, const Udm::Object& transition_bb6)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_baf= _state_ba9.begin(), itTransition_bb8= _transition_bb2.begin(); itState_baf!= _state_ba9.end(), itTransition_bb8!= _transition_bb2.end(); ++itState_baf, ++itTransition_bb8)
	{
		if( ( *itState_baf== state_bad)&& ( *itTransition_bb8== transition_bb6))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_ba9.push_back( state_bad);
		_transition_bb2.push_back( transition_bb6);
	}
	return isUnique;
}

void GetDstTransConnectors_ba0::processInputPackets( const Packets_t& states_ba1, const Packets_t& transitions_ba5)
{
	for( Packets_t::const_iterator itState_baa= states_ba1.begin(), itTransition_bb3= transitions_ba5.begin(); itState_baa!= states_ba1.end(), itTransition_bb3!= transitions_ba5.end(); ++itState_baa, ++itTransition_bb3)
	{
		bool isUnique= isInputUnique( *itState_baa, *itTransition_bb3);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_baa, *itTransition_bb3);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetDstTransConnectors_ba0::patternMatcher( const Udm::Object& state_bab, const Udm::Object& transition_bb4)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_bab.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_bb0= CyberComposition::Simulink::State::Cast( state_bab);
		if( false== Uml::IsDerivedFrom( transition_bb4.type(), CyberComposition::Simulink::Transition::meta))
			continue;
		CyberComposition::Simulink::Transition transition_bb9= CyberComposition::Simulink::Transition::Cast( transition_bb4);
		CyberComposition::Simulink::TransConnector transConnector_bbb= transition_bb9.srcTransition_end();
		CyberComposition::Simulink::TransConnector dstTransConnector_bbc= transition_bb9.dstTransition_end();
		Match currMatch;
		currMatch.state_bbe= state_bb0;
		currMatch.transition_bbf= transition_bb9;
		currMatch.transConnector_bc0= transConnector_bbb;
		currMatch.dstTransConnector_bc1= dstTransConnector_bbc;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void GetDstTransConnectors_ba0::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_bbe, currMatch.dstTransConnector_bc1);
	}
}

void GetDstTransConnectors_ba0::outputAppender( const CyberComposition::Simulink::State& state_bc2, const CyberComposition::Simulink::TransConnector& dstTransConnector_bc4)
{
	_state_ba7->push_back( state_bc2);
	_dstTransConnector_ba8->push_back( dstTransConnector_bc4);
}

void ProcessedFilter_bd5::operator()( const Packets_t& states_bd6, const Packets_t& tcs_bd8, Packets_t& states_bda, Packets_t& tcs_bdb)
{
#ifdef PRINT_INFO
	printLog( "ProcessedFilter_bd5" );
#endif
	_state_bdc= &states_bda;
	_tc_bdd= &tcs_bdb;
	for( Packets_t::const_iterator itstate_bdf= states_bd6.begin(), ittc_be6= tcs_bd8.begin(); itstate_bdf!= states_bd6.end(), ittc_be6!= tcs_bd8.end(); ++itstate_bdf, ++ittc_be6)
	{
		bool isUnique= isInputUnique( *itstate_bdf, *ittc_be6);
		if( !isUnique)
			continue;
		Packets_t onestate_be3( 1, *itstate_bdf);
		Packets_t onetc_bea( 1, *ittc_be6);
		executeOne( onestate_be3, onetc_bea);
	}
}

void ProcessedFilter_bd5::executeOne( const Packets_t& states_bd6, const Packets_t& tcs_bd8)
{
	Packets_t states_bef;
	Packets_t transConnectors_bf2;
	TCNotProcessed_bec tCNotProcessed_bec;
	bool isMatchTCNotProcessed_bec= tCNotProcessed_bec( states_bd6, tcs_bd8, states_bef, transConnectors_bf2);
	_state_bdc->insert( _state_bdc->end(), states_bef.begin(), states_bef.end());
	_tc_bdd->insert( _tc_bdd->end(), transConnectors_bf2.begin(), transConnectors_bf2.end());
	if( isMatchTCNotProcessed_bec)
		return;
}

bool ProcessedFilter_bd5::isInputUnique( const Udm::Object& state_be0, const Udm::Object& tc_be7)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_be2= _state_bde.begin(), ittc_be9= _tc_be5.begin(); itstate_be2!= _state_bde.end(), ittc_be9!= _tc_be5.end(); ++itstate_be2, ++ittc_be9)
	{
		if( ( *itstate_be2== state_be0)&& ( *ittc_be9== tc_be7))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_bde.push_back( state_be0);
		_tc_be5.push_back( tc_be7);
	}
	return isUnique;
}

bool TCNotProcessed_bec::operator()( const Packets_t& states_bed, const Packets_t& transConnectors_bf0, Packets_t& states_bef, Packets_t& transConnectors_bf2)
{
#ifdef PRINT_INFO
	printLog( "TCNotProcessed_bec" );
#endif
	_state_bf3= &states_bef;
	_transConnector_bf4= &transConnectors_bf2;
	processInputPackets( states_bed, transConnectors_bf0);
	if( false== _matches.empty())
		return true;
	return false;
}

bool TCNotProcessed_bec::isInputUnique( const Udm::Object& state_bf9, const Udm::Object& transConnector_c02)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_bfb= _state_bf5.begin(), itTransConnector_c04= _transConnector_bfe.begin(); itState_bfb!= _state_bf5.end(), itTransConnector_c04!= _transConnector_bfe.end(); ++itState_bfb, ++itTransConnector_c04)
	{
		if( ( *itState_bfb== state_bf9)&& ( *itTransConnector_c04== transConnector_c02))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_bf5.push_back( state_bf9);
		_transConnector_bfe.push_back( transConnector_c02);
	}
	return isUnique;
}

bool TCNotProcessed_bec::isGuardTrue( CyberComposition::Simulink::State& State, CyberComposition::Simulink::TransConnector& TransConnector)
{
	bool Gz_guard= false;
	return !SFManager::StateTransConnectorMap::get_singleton().getTransConnectorMap( State ).hasTransConnector( TransConnector );;
	return Gz_guard;
}

void TCNotProcessed_bec::processInputPackets( const Packets_t& states_bed, const Packets_t& transConnectors_bf0)
{
	for( Packets_t::const_iterator itState_bf6= states_bed.begin(), itTransConnector_bff= transConnectors_bf0.begin(); itState_bf6!= states_bed.end(), itTransConnector_bff!= transConnectors_bf0.end(); ++itState_bf6, ++itTransConnector_bff)
	{
		bool isUnique= isInputUnique( *itState_bf6, *itTransConnector_bff);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_bf6, *itTransConnector_bff);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_c08, currMatch.transConnector_c09);
	}
}

bool TCNotProcessed_bec::patternMatcher( const Udm::Object& state_bf7, const Udm::Object& transConnector_c00)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_bf7.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_bfc= CyberComposition::Simulink::State::Cast( state_bf7);
		if( false== Uml::IsDerivedFrom( transConnector_c00.type(), CyberComposition::Simulink::TransConnector::meta))
			continue;
		CyberComposition::Simulink::TransConnector transConnector_c05= CyberComposition::Simulink::TransConnector::Cast( transConnector_c00);
		Match currMatch;
		currMatch.state_c08= state_bfc;
		currMatch.transConnector_c09= transConnector_c05;
		bool Gz_guard= isGuardTrue( currMatch.state_c08, currMatch.transConnector_c09);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void TCNotProcessed_bec::outputAppender( const CyberComposition::Simulink::State& state_c0c, const CyberComposition::Simulink::TransConnector& transConnector_c0e)
{
	_state_bf3->push_back( state_c0c);
	_transConnector_bf4->push_back( transConnector_c0e);
}

void PopulateEMFSFunction_c2e::operator()( const Packets_t& states_c2f, const Packets_t& programs_c31, Packets_t& states_c33, Packets_t& programs_c34)
{
#ifdef PRINT_INFO
	printLog( "PopulateEMFSFunction_c2e" );
#endif
	_state_c35= &states_c33;
	_program_c36= &programs_c34;
	if( ( !states_c2f.empty())&& ( !programs_c31.empty()))
		callGetEMFuncStateFunction_c85( states_c2f, programs_c31);
	_state_c35->insert( _state_c35->end(), states_c2f.begin(), states_c2f.end());
	_program_c36->insert( _program_c36->end(), programs_c31.begin(), programs_c31.end());
}

void PopulateEMFSFunction_c2e::callGetEMFuncStateFunction_c85( const Packets_t& states_c55, const Packets_t& programs_c58)
{
	Packets_t states_c57;
	Packets_t execs_c5a;
	GetEMFuncStateFunction_c54 getEMFuncStateFunction_c54;
	getEMFuncStateFunction_c54( states_c55, programs_c58, states_c57, execs_c5a);
	if( ( !states_c57.empty())&& ( !execs_c5a.empty()))
		callFunctionBody_c88( states_c57, execs_c5a);
}

void PopulateEMFSFunction_c2e::callFunctionBody_c88( const Packets_t& states_c38, const Packets_t& execs_c3a)
{
	FunctionBody_c37 functionBody_c37;
	functionBody_c37( states_c38, execs_c3a);
}

void FunctionBody_c37::operator()( const Packets_t& states_c38, const Packets_t& execs_c3a)
{
#ifdef PRINT_INFO
	printLog( "FunctionBody_c37" );
#endif
	RTTGenerator::Instance()->generateRule(65, "FunctionBody");
	processInputPackets( states_c38, execs_c3a);
}

bool FunctionBody_c37::isInputUnique( const Udm::Object& state_c40, const Udm::Object& exec_c49)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_c42= _state_c3c.begin(), itExec_c4b= _exec_c45.begin(); itState_c42!= _state_c3c.end(), itExec_c4b!= _exec_c45.end(); ++itState_c42, ++itExec_c4b)
	{
		if( ( *itState_c42== state_c40)&& ( *itExec_c4b== exec_c49))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_c3c.push_back( state_c40);
		_exec_c45.push_back( exec_c49);
	}
	return isUnique;
}

bool FunctionBody_c37::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void FunctionBody_c37::processInputPackets( const Packets_t& states_c38, const Packets_t& execs_c3a)
{
	for( Packets_t::const_iterator itState_c3d= states_c38.begin(), itExec_c46= execs_c3a.begin(); itState_c3d!= states_c38.end(), itExec_c46!= execs_c3a.end(); ++itState_c3d, ++itExec_c46)
	{
		bool isUnique= isInputUnique( *itState_c3d, *itExec_c46);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_c3d, *itExec_c46);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool FunctionBody_c37::patternMatcher( const Udm::Object& state_c3e, const Udm::Object& exec_c47)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_c3e.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_c43= CyberComposition::Simulink::State::Cast( state_c3e);
		if( false== Uml::IsDerivedFrom( exec_c47.type(), SFC::Function::meta))
			continue;
		SFC::Function exec_c4c= SFC::Function::Cast( exec_c47);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_c51;
		if( !isValidBound(boundObjs_c51, state_c43, true))
			continue;
		currMatch.state_c52= state_c43;
		if( !isValidBound(boundObjs_c51, exec_c4c, true))
			continue;
		currMatch.exec_c53= exec_c4c;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void FunctionBody_c37::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function& Exec= currMatch.exec_c53;
		CyberComposition::Simulink::State& State= currMatch.state_c52;
		{
SFManager::mstat2SFC( Exec, State.DuringAction() );
};
	}
}

void GetEMFuncStateFunction_c54::operator()( const Packets_t& states_c55, const Packets_t& programs_c58, Packets_t& states_c57, Packets_t& execs_c5a)
{
#ifdef PRINT_INFO
	printLog( "GetEMFuncStateFunction_c54" );
#endif
	RTTGenerator::Instance()->generateRule(69, "GetEMFuncStateFunction");
	_state_c5b= &states_c57;
	_exec_c5c= &execs_c5a;
	processInputPackets( states_c55, programs_c58);
}

bool GetEMFuncStateFunction_c54::isInputUnique( const Udm::Object& state_c61, const Udm::Object& program_c6a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_c63= _state_c5d.begin(), itProgram_c6c= _program_c66.begin(); itState_c63!= _state_c5d.end(), itProgram_c6c!= _program_c66.end(); ++itState_c63, ++itProgram_c6c)
	{
		if( ( *itState_c63== state_c61)&& ( *itProgram_c6c== program_c6a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_c5d.push_back( state_c61);
		_program_c66.push_back( program_c6a);
	}
	return isUnique;
}

bool GetEMFuncStateFunction_c54::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool GetEMFuncStateFunction_c54::isGuardTrue( SFC::Function& Exec, SFC::Program& Program, CyberComposition::Simulink::State& State, SFC::StateLabel& StateLabel)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( State.Decomposition() ) == "FUNC_STATE" &&
 static_cast< std::string >( State.Order() ) == "-2";;
	return Gz_guard;
}

void GetEMFuncStateFunction_c54::processInputPackets( const Packets_t& states_c55, const Packets_t& programs_c58)
{
	for( Packets_t::const_iterator itState_c5e= states_c55.begin(), itProgram_c67= programs_c58.begin(); itState_c5e!= states_c55.end(), itProgram_c67!= programs_c58.end(); ++itState_c5e, ++itProgram_c67)
	{
		bool isUnique= isInputUnique( *itState_c5e, *itProgram_c67);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_c5e, *itProgram_c67);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetEMFuncStateFunction_c54::patternMatcher( const Udm::Object& state_c5f, const Udm::Object& program_c68)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_c5f.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_c64= CyberComposition::Simulink::State::Cast( state_c5f);
		if( false== Uml::IsDerivedFrom( program_c68.type(), SFC::Program::meta))
			continue;
		SFC::Program program_c6d= SFC::Program::Cast( program_c68);
		set< SFC::Function> execs_c6f= state_c64.exec();
		for( set< SFC::Function>::const_iterator itExecs_c70= execs_c6f.begin(); itExecs_c70!= execs_c6f.end(); ++itExecs_c70)
		{
			SFC::Function currExec_c71= *itExecs_c70;
			set< SFC::StateLabel> stateLabels_c72= state_c64.src();
			for( set< SFC::StateLabel>::const_iterator itStateLabels_c73= stateLabels_c72.begin(); itStateLabels_c73!= stateLabels_c72.end(); ++itStateLabels_c73)
			{
				SFC::StateLabel currStateLabel_c74= *itStateLabels_c73;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_c78;
				if( !isValidBound(boundObjs_c78, state_c64, true))
					continue;
				currMatch.state_c79= state_c64;
				if( !isValidBound(boundObjs_c78, program_c6d, true))
					continue;
				currMatch.program_c7a= program_c6d;
				if( !isValidBound(boundObjs_c78, currStateLabel_c74, false))
					continue;
				currMatch.stateLabel_c7b= currStateLabel_c74;
				if( !isValidBound(boundObjs_c78, currExec_c71, false))
					continue;
				currMatch.exec_c7c= currExec_c71;
				bool Gz_guard= isGuardTrue( currMatch.exec_c7c, currMatch.program_c7a, currMatch.state_c79, currMatch.stateLabel_c7b);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetEMFuncStateFunction_c54::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_c79, currMatch.exec_c7c);
	}
}

void GetEMFuncStateFunction_c54::outputAppender( const CyberComposition::Simulink::State& state_c81, const SFC::Function& exec_c83)
{
	_state_c5b->push_back( state_c81);
	_exec_c5c->push_back( exec_c83);
}

void GetSubStates_c8b::operator()( const Packets_t& states_c8c, const Packets_t& parStmnts_c8f, Packets_t& subStates_c8e, Packets_t& parStmnts_c91)
{
#ifdef PRINT_INFO
	printLog( "GetSubStates_c8b" );
#endif
	RTTGenerator::Instance()->generateRule(1832, "GetSubStates");
	_subState_c92= &subStates_c8e;
	_parStmnt_c93= &parStmnts_c91;
	processInputPackets( states_c8c, parStmnts_c8f);
}

bool GetSubStates_c8b::isInputUnique( const Udm::Object& state_c98, const Udm::Object& parStmnt_ca1)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_c9a= _state_c94.begin(), itParStmnt_ca3= _parStmnt_c9d.begin(); itState_c9a!= _state_c94.end(), itParStmnt_ca3!= _parStmnt_c9d.end(); ++itState_c9a, ++itParStmnt_ca3)
	{
		if( ( *itState_c9a== state_c98)&& ( *itParStmnt_ca3== parStmnt_ca1))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_c94.push_back( state_c98);
		_parStmnt_c9d.push_back( parStmnt_ca1);
	}
	return isUnique;
}

bool GetSubStates_c8b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetSubStates_c8b::processInputPackets( const Packets_t& states_c8c, const Packets_t& parStmnts_c8f)
{
	for( Packets_t::const_iterator itState_c95= states_c8c.begin(), itParStmnt_c9e= parStmnts_c8f.begin(); itState_c95!= states_c8c.end(), itParStmnt_c9e!= parStmnts_c8f.end(); ++itState_c95, ++itParStmnt_c9e)
	{
		bool isUnique= isInputUnique( *itState_c95, *itParStmnt_c9e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_c95, *itParStmnt_c9e);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetSubStates_c8b::patternMatcher( const Udm::Object& state_c96, const Udm::Object& parStmnt_c9f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_c96.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_c9b= CyberComposition::Simulink::State::Cast( state_c96);
		if( false== Uml::IsDerivedFrom( parStmnt_c9f.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement parStmnt_ca4= SFC::CompoundStatement::Cast( parStmnt_c9f);
		set< CyberComposition::Simulink::State> subStates_ca6= state_c9b.State_kind_children();
		for( set< CyberComposition::Simulink::State>::const_iterator itSubState_ca7= subStates_ca6.begin(); itSubState_ca7!= subStates_ca6.end(); ++itSubState_ca7)
		{
			CyberComposition::Simulink::State currSubState_ca8= *itSubState_ca7;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_cac;
			if( !isValidBound(boundObjs_cac, state_c9b, true))
				continue;
			currMatch.state_cad= state_c9b;
			if( !isValidBound(boundObjs_cac, parStmnt_ca4, true))
				continue;
			currMatch.parStmnt_cae= parStmnt_ca4;
			if( !isValidBound(boundObjs_cac, currSubState_ca8, false))
				continue;
			currMatch.subState_caf= currSubState_ca8;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetSubStates_c8b::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subState_caf, currMatch.parStmnt_cae);
	}
}

void GetSubStates_c8b::outputAppender( const CyberComposition::Simulink::State& subState_cb0, const SFC::CompoundStatement& parStmnt_cb2)
{
	_subState_c92->push_back( subState_cb0);
	_parStmnt_c93->push_back( parStmnt_cb2);
}

void ClearTables_cbd::operator()( const Packets_t& states_cbe, const Packets_t& programs_cc1, Packets_t& states_cc0, Packets_t& programs_cc3)
{
#ifdef PRINT_INFO
	printLog( "ClearTables_cbd" );
#endif
	RTTGenerator::Instance()->generateRule(76, "ClearTables");
	_state_cc4= &states_cc0;
	_program_cc5= &programs_cc3;
	processInputPackets( states_cbe, programs_cc1);
	forwardInputs( );
}

bool ClearTables_cbd::isInputUnique( const Udm::Object& state_cca, const Udm::Object& program_cd3)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_ccc= _state_cc6.begin(), itProgram_cd5= _program_ccf.begin(); itState_ccc!= _state_cc6.end(), itProgram_cd5!= _program_ccf.end(); ++itState_ccc, ++itProgram_cd5)
	{
		if( ( *itState_ccc== state_cca)&& ( *itProgram_cd5== program_cd3))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_cc6.push_back( state_cca);
		_program_ccf.push_back( program_cd3);
	}
	return isUnique;
}

bool ClearTables_cbd::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void ClearTables_cbd::processInputPackets( const Packets_t& states_cbe, const Packets_t& programs_cc1)
{
	for( Packets_t::const_iterator itState_cc7= states_cbe.begin(), itProgram_cd0= programs_cc1.begin(); itState_cc7!= states_cbe.end(), itProgram_cd0!= programs_cc1.end(); ++itState_cc7, ++itProgram_cd0)
	{
		bool isUnique= isInputUnique( *itState_cc7, *itProgram_cd0);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_cc7, *itProgram_cd0);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ClearTables_cbd::patternMatcher( const Udm::Object& state_cc8, const Udm::Object& program_cd1)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_cc8.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_ccd= CyberComposition::Simulink::State::Cast( state_cc8);
		if( false== Uml::IsDerivedFrom( program_cd1.type(), SFC::Program::meta))
			continue;
		SFC::Program program_cd6= SFC::Program::Cast( program_cd1);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_cdb;
		if( !isValidBound(boundObjs_cdb, state_ccd, true))
			continue;
		currMatch.state_cdc= state_ccd;
		if( !isValidBound(boundObjs_cdb, program_cd6, true))
			continue;
		currMatch.program_cdd= program_cd6;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void ClearTables_cbd::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Program& Program= currMatch.program_cdd;
		CyberComposition::Simulink::State& State= currMatch.state_cdc;
		{
SFManager::getVarResolve().clear();
SFManager::getFunctionHash().clear();
getSFCSymbolTable().clear();
};
	}
}

void ClearTables_cbd::forwardInputs()
{
	*_state_cc4= _state_cc6;
	*_program_cc5= _program_ccf;
}

void CreateStateLabels_cde::operator()( const Packets_t& states_cdf, const Packets_t& programs_ce1, Packets_t& states_ce3, Packets_t& programs_ce4)
{
#ifdef PRINT_INFO
	printLog( "CreateStateLabels_cde" );
#endif
	_state_ce5= &states_ce3;
	_program_ce6= &programs_ce4;
	if( ( !states_cdf.empty())&& ( !programs_ce1.empty()))
		callCreateCompoundStates_eed( states_cdf, programs_ce1);
	_state_ce5->insert( _state_ce5->end(), states_cdf.begin(), states_cdf.end());
	_program_ce6->insert( _program_ce6->end(), programs_ce1.begin(), programs_ce1.end());
}

void CreateStateLabels_cde::callCreateCompoundStates_eed( const Packets_t& states_ce8, const Packets_t& programs_cea)
{
	Packets_t states_cec;
	Packets_t programs_ced;
	CreateCompoundStates_ce7 createCompoundStates_ce7;
	createCompoundStates_ce7( states_ce8, programs_cea, states_cec, programs_ced);
	if( ( !states_cec.empty())&& ( !programs_ced.empty()))
		callCreateStateVar_ef0( states_cec, programs_ced);
}

void CreateStateLabels_cde::callCreateStateVar_ef0( const Packets_t& states_dcc, const Packets_t& programs_dcf)
{
	Packets_t states_dce;
	Packets_t programs_dd1;
	CreateStateVar_dcb createStateVar_dcb;
	createStateVar_dcb( states_dcc, programs_dcf, states_dce, programs_dd1);
	if( ( !states_dce.empty())&& ( !programs_dd1.empty()))
		callCreateLeafStates_ef3( states_dce, programs_dd1);
}

void CreateStateLabels_cde::callCreateLeafStates_ef3( const Packets_t& states_dee, const Packets_t& programs_df0)
{
	Packets_t states_df2;
	Packets_t programs_df3;
	CreateLeafStates_ded createLeafStates_ded;
	createLeafStates_ded( states_dee, programs_df0, states_df2, programs_df3);
	if( ( !states_df2.empty())&& ( !programs_df3.empty()))
		callCreateFuncStates_psuedo_ef6( states_df2, programs_df3);
}

void CreateStateLabels_cde::callCreateFuncStates_psuedo_ef6( const Packets_t& states_e6e, const Packets_t& programs_e70)
{
	Packets_t states_e72;
	Packets_t programs_e73;
	CreateFuncStates_psuedo_e6d createFuncStates_psuedo_e6d;
	createFuncStates_psuedo_e6d( states_e6e, programs_e70, states_e72, programs_e73);
}

void CreateCompoundStates_ce7::operator()( const Packets_t& states_ce8, const Packets_t& programs_cea, Packets_t& states_cec, Packets_t& programs_ced)
{
#ifdef PRINT_INFO
	printLog( "CreateCompoundStates_ce7" );
#endif
	_state_cee= &states_cec;
	_program_cef= &programs_ced;
	_state_cee->insert( _state_cee->end(), states_ce8.begin(), states_ce8.end());
	_program_cef->insert( _program_cef->end(), programs_cea.begin(), programs_cea.end());
	if( ( !states_ce8.empty())&& ( !programs_cea.empty()))
		callIsANDORGROUPCompound_dc2( states_ce8, programs_cea);
}

void CreateCompoundStates_ce7::callIsANDORGROUPCompound_dc2( const Packets_t& states_d80, const Packets_t& programs_d82)
{
	Packets_t states_d84;
	Packets_t programs_d85;
	IsANDORGROUPCompound_d7f isANDORGROUPCompound_d7f;
	isANDORGROUPCompound_d7f( states_d80, programs_d82, states_d84, programs_d85);
	if( ( !states_d84.empty())&& ( !programs_d85.empty()))
		callCreateStateLabel_dc5( states_d84, programs_d85);
}

void CreateCompoundStates_ce7::callCreateStateLabel_dc5( const Packets_t& states_cf1, const Packets_t& programs_cf3)
{
	Packets_t states_cf5;
	Packets_t programs_cf6;
	CreateStateLabel_cf0 createStateLabel_cf0;
	createStateLabel_cf0( states_cf1, programs_cf3, states_cf5, programs_cf6);
	if( ( !states_cf5.empty())&& ( !programs_cf6.empty()))
		callGetSubStates_dc8( states_cf5, programs_cf6);
}

void CreateCompoundStates_ce7::callGetSubStates_dc8( const Packets_t& states_c8c, const Packets_t& parStmnts_c8f)
{
	Packets_t subStates_c8e;
	Packets_t parStmnts_c91;
	GetSubStates_c8b getSubStates_c8b;
	getSubStates_c8b( states_c8c, parStmnts_c8f, subStates_c8e, parStmnts_c91);
	if( ( !subStates_c8e.empty())&& ( !parStmnts_c91.empty()))
		callIsANDORGROUPCompound_dc2( subStates_c8e, parStmnts_c91);
}

void CreateStateLabel_cf0::operator()( const Packets_t& states_cf1, const Packets_t& programs_cf3, Packets_t& states_cf5, Packets_t& programs_cf6)
{
#ifdef PRINT_INFO
	printLog( "CreateStateLabel_cf0" );
#endif
	_state_cf7= &states_cf5;
	_program_cf8= &programs_cf6;
	if( ( !states_cf1.empty())&& ( !programs_cf3.empty()))
		callCreate_d76( states_cf1, programs_cf3);
	_state_cf7->insert( _state_cf7->end(), states_cf1.begin(), states_cf1.end());
	_program_cf8->insert( _program_cf8->end(), programs_cf3.begin(), programs_cf3.end());
}

void CreateStateLabel_cf0::callCreate_d76( const Packets_t& states_d22, const Packets_t& programs_d25)
{
	Packets_t states_d24;
	Packets_t stateLabels_d27;
	Create_d21 create_d21;
	create_d21( states_d22, programs_d25, states_d24, stateLabels_d27);
	if( ( !states_d24.empty())&& ( !stateLabels_d27.empty()))
		callInitMask_d79( states_d24, stateLabels_d27);
}

void CreateStateLabel_cf0::callInitMask_d79( const Packets_t& states_d48, const Packets_t& stateLabels_d4b)
{
	Packets_t states_d4a;
	Packets_t stateLabels_d4d;
	InitMask_d47 initMask_d47;
	initMask_d47( states_d48, stateLabels_d4b, states_d4a, stateLabels_d4d);
	if( ( !states_d4a.empty())&& ( !stateLabels_d4d.empty()))
		callSetPath_d7c( states_d4a, stateLabels_d4d);
}

void CreateStateLabel_cf0::callSetPath_d7c( const Packets_t& states_cfa, const Packets_t& stateLabels_cfd)
{
	Packets_t superStates_cfc;
	Packets_t stateLabels_cff;
	SetPath_cf9 setPath_cf9;
	setPath_cf9( states_cfa, stateLabels_cfd, superStates_cfc, stateLabels_cff);
	if( ( !superStates_cfc.empty())&& ( !stateLabels_cff.empty()))
		callSetPath_d7c( superStates_cfc, stateLabels_cff);
}

void SetPath_cf9::operator()( const Packets_t& states_cfa, const Packets_t& stateLabels_cfd, Packets_t& superStates_cfc, Packets_t& stateLabels_cff)
{
#ifdef PRINT_INFO
	printLog( "SetPath_cf9" );
#endif
	RTTGenerator::Instance()->generateRule(95, "SetPath");
	_superState_d00= &superStates_cfc;
	_stateLabel_d01= &stateLabels_cff;
	processInputPackets( states_cfa, stateLabels_cfd);
}

bool SetPath_cf9::isInputUnique( const Udm::Object& state_d06, const Udm::Object& stateLabel_d0f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_d08= _state_d02.begin(), itStateLabel_d11= _stateLabel_d0b.begin(); itState_d08!= _state_d02.end(), itStateLabel_d11!= _stateLabel_d0b.end(); ++itState_d08, ++itStateLabel_d11)
	{
		if( ( *itState_d08== state_d06)&& ( *itStateLabel_d11== stateLabel_d0f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_d02.push_back( state_d06);
		_stateLabel_d0b.push_back( stateLabel_d0f);
	}
	return isUnique;
}

bool SetPath_cf9::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void SetPath_cf9::processInputPackets( const Packets_t& states_cfa, const Packets_t& stateLabels_cfd)
{
	for( Packets_t::const_iterator itState_d03= states_cfa.begin(), itStateLabel_d0c= stateLabels_cfd.begin(); itState_d03!= states_cfa.end(), itStateLabel_d0c!= stateLabels_cfd.end(); ++itState_d03, ++itStateLabel_d0c)
	{
		bool isUnique= isInputUnique( *itState_d03, *itStateLabel_d0c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_d03, *itStateLabel_d0c);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool SetPath_cf9::patternMatcher( const Udm::Object& state_d04, const Udm::Object& stateLabel_d0d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_d04.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_d09= CyberComposition::Simulink::State::Cast( state_d04);
		if( false== Uml::IsDerivedFrom( stateLabel_d0d.type(), SFC::StateLabel::meta))
			continue;
		SFC::StateLabel stateLabel_d12= SFC::StateLabel::Cast( stateLabel_d0d);
		Udm::Object stateParent_d14= state_d09.container();
		if( false== Uml::IsDerivedFrom( stateParent_d14.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State superStateState_d15= CyberComposition::Simulink::State::Cast( stateParent_d14);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_d19;
		if( !isValidBound(boundObjs_d19, state_d09, true))
			continue;
		currMatch.state_d1a= state_d09;
		if( !isValidBound(boundObjs_d19, stateLabel_d12, true))
			continue;
		currMatch.stateLabel_d1b= stateLabel_d12;
		if( !isValidBound(boundObjs_d19, superStateState_d15, false))
			continue;
		currMatch.superState_d1c= superStateState_d15;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void SetPath_cf9::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		CyberComposition::Simulink::State& State= currMatch.state_d1a;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_d1b;
		CyberComposition::Simulink::State& SuperState= currMatch.superState_d1c;
		{
StateLabel.comment() =
 static_cast< std::string >( SuperState.name() ) + "/" +
 static_cast< std::string >( StateLabel.comment() );
};
		outputAppender( currMatch.superState_d1c, currMatch.stateLabel_d1b);
	}
}

void SetPath_cf9::outputAppender( const CyberComposition::Simulink::State& superState_d1d, const SFC::StateLabel& stateLabel_d1f)
{
	_superState_d00->push_back( superState_d1d);
	_stateLabel_d01->push_back( stateLabel_d1f);
}

void Create_d21::operator()( const Packets_t& states_d22, const Packets_t& programs_d25, Packets_t& states_d24, Packets_t& stateLabels_d27)
{
#ifdef PRINT_INFO
	printLog( "Create_d21" );
#endif
	RTTGenerator::Instance()->generateRule(101, "Create");
	_state_d28= &states_d24;
	_stateLabel_d29= &stateLabels_d27;
	processInputPackets( states_d22, programs_d25);
}

bool Create_d21::isInputUnique( const Udm::Object& state_d2e, const Udm::Object& program_d37)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_d30= _state_d2a.begin(), itProgram_d39= _program_d33.begin(); itState_d30!= _state_d2a.end(), itProgram_d39!= _program_d33.end(); ++itState_d30, ++itProgram_d39)
	{
		if( ( *itState_d30== state_d2e)&& ( *itProgram_d39== program_d37))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_d2a.push_back( state_d2e);
		_program_d33.push_back( program_d37);
	}
	return isUnique;
}

bool Create_d21::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Create_d21::processInputPackets( const Packets_t& states_d22, const Packets_t& programs_d25)
{
	for( Packets_t::const_iterator itState_d2b= states_d22.begin(), itProgram_d34= programs_d25.begin(); itState_d2b!= states_d22.end(), itProgram_d34!= programs_d25.end(); ++itState_d2b, ++itProgram_d34)
	{
		bool isUnique= isInputUnique( *itState_d2b, *itProgram_d34);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_d2b, *itProgram_d34);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool Create_d21::patternMatcher( const Udm::Object& state_d2c, const Udm::Object& program_d35)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_d2c.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_d31= CyberComposition::Simulink::State::Cast( state_d2c);
		if( false== Uml::IsDerivedFrom( program_d35.type(), SFC::Program::meta))
			continue;
		SFC::Program program_d3a= SFC::Program::Cast( program_d35);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_d3f;
		if( !isValidBound(boundObjs_d3f, state_d31, true))
			continue;
		currMatch.state_d40= state_d31;
		if( !isValidBound(boundObjs_d3f, program_d3a, true))
			continue;
		currMatch.program_d41= program_d3a;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Create_d21::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::StateLabel newStateLabel_d42= SFC::StateLabel::Create( currMatch.program_d41);
		SFC::Program& Program= currMatch.program_d41;
		CyberComposition::Simulink::State& State= currMatch.state_d40;
		SFC::StateLabel& StateLabel= newStateLabel_d42;
		{
std::string name = State.name();

StateLabel.comment() = name;

__int64 stateCount = Program.stateCount();
std::string nameUC = SFUtils::convertToCPlusPlusName(   std::string(  _strupr( (char *)name.c_str() )  )   ) + boost::lexical_cast< std::string >( stateCount );

StateLabel.name() = nameUC;
StateLabel.value() = stateCount++;
Program.stateCount() = stateCount;

StateLabel.dt() = SFCTypesManager::getSingleton().getBasicType( "int" );
};
		{
__int64 statementCount = Program.statementCount();
StateLabel.statementIndex() = statementCount++;
Program.statementCount() = statementCount;
};
		{
StateLabel.RefId() = State.RefId();
};
		newStateLabel_d42.dst()+= currMatch.state_d40;
		outputAppender( currMatch.state_d40, newStateLabel_d42);
	}
}

void Create_d21::outputAppender( const CyberComposition::Simulink::State& state_d43, const SFC::StateLabel& stateLabel_d45)
{
	_state_d28->push_back( state_d43);
	_stateLabel_d29->push_back( stateLabel_d45);
}

void InitMask_d47::operator()( const Packets_t& states_d48, const Packets_t& stateLabels_d4b, Packets_t& states_d4a, Packets_t& stateLabels_d4d)
{
#ifdef PRINT_INFO
	printLog( "InitMask_d47" );
#endif
	RTTGenerator::Instance()->generateRule(110, "InitMask");
	_state_d4e= &states_d4a;
	_stateLabel_d4f= &stateLabels_d4d;
	processInputPackets( states_d48, stateLabels_d4b);
	forwardInputs( );
}

bool InitMask_d47::isInputUnique( const Udm::Object& state_d54, const Udm::Object& stateLabel_d5d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_d56= _state_d50.begin(), itStateLabel_d5f= _stateLabel_d59.begin(); itState_d56!= _state_d50.end(), itStateLabel_d5f!= _stateLabel_d59.end(); ++itState_d56, ++itStateLabel_d5f)
	{
		if( ( *itState_d56== state_d54)&& ( *itStateLabel_d5f== stateLabel_d5d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_d50.push_back( state_d54);
		_stateLabel_d59.push_back( stateLabel_d5d);
	}
	return isUnique;
}

bool InitMask_d47::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool InitMask_d47::isGuardTrue( CyberComposition::Simulink::State& State, SFC::StateLabel& StateLabel, CyberComposition::Simulink::State& SuperState, SFC::StateLabel& SuperStateLabel)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( State.Decomposition() ) == "AND_STATE";;
	return Gz_guard;
}

void InitMask_d47::processInputPackets( const Packets_t& states_d48, const Packets_t& stateLabels_d4b)
{
	for( Packets_t::const_iterator itState_d51= states_d48.begin(), itStateLabel_d5a= stateLabels_d4b.begin(); itState_d51!= states_d48.end(), itStateLabel_d5a!= stateLabels_d4b.end(); ++itState_d51, ++itStateLabel_d5a)
	{
		bool isUnique= isInputUnique( *itState_d51, *itStateLabel_d5a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_d51, *itStateLabel_d5a);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InitMask_d47::patternMatcher( const Udm::Object& state_d52, const Udm::Object& stateLabel_d5b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_d52.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_d57= CyberComposition::Simulink::State::Cast( state_d52);
		if( false== Uml::IsDerivedFrom( stateLabel_d5b.type(), SFC::StateLabel::meta))
			continue;
		SFC::StateLabel stateLabel_d60= SFC::StateLabel::Cast( stateLabel_d5b);
		set< CyberComposition::Simulink::State> states_d62= stateLabel_d60.dst();
		for( set< CyberComposition::Simulink::State>::const_iterator itStates_d63= states_d62.begin(); itStates_d63!= states_d62.end(); ++itStates_d63)
		{
			CyberComposition::Simulink::State currState_d64= *itStates_d63;
			if( state_d57!= currState_d64)
				continue;
			Udm::Object stateParent_d65= state_d57.container();
			if( false== Uml::IsDerivedFrom( stateParent_d65.type(), CyberComposition::Simulink::State::meta))
				continue;
			CyberComposition::Simulink::State superStateState_d66= CyberComposition::Simulink::State::Cast( stateParent_d65);
			set< SFC::StateLabel> superStateLabels_d67= superStateState_d66.src();
			for( set< SFC::StateLabel>::const_iterator itSuperStateLabels_d68= superStateLabels_d67.begin(); itSuperStateLabels_d68!= superStateLabels_d67.end(); ++itSuperStateLabels_d68)
			{
				SFC::StateLabel currSuperStateLabel_d69= *itSuperStateLabels_d68;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_d6d;
				if( !isValidBound(boundObjs_d6d, state_d57, true))
					continue;
				currMatch.state_d6e= state_d57;
				if( !isValidBound(boundObjs_d6d, stateLabel_d60, true))
					continue;
				currMatch.stateLabel_d6f= stateLabel_d60;
				if( !isValidBound(boundObjs_d6d, superStateState_d66, false))
					continue;
				currMatch.superState_d70= superStateState_d66;
				if( !isValidBound(boundObjs_d6d, currSuperStateLabel_d69, false))
					continue;
				currMatch.superStateLabel_d71= currSuperStateLabel_d69;
				bool Gz_guard= isGuardTrue( currMatch.state_d6e, currMatch.stateLabel_d6f, currMatch.superState_d70, currMatch.superStateLabel_d71);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void InitMask_d47::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		CyberComposition::Simulink::State& State= currMatch.state_d6e;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_d6f;
		CyberComposition::Simulink::State& SuperState= currMatch.superState_d70;
		SFC::StateLabel& SuperStateLabel= currMatch.superStateLabel_d71;
		{
__int64 ss = SuperStateLabel.andSS();
__int64 sl = StateLabel.value();

sl = (1LL << (ss + 16)) | (sl & 0xffff);

StateLabel.value() = sl;
SuperStateLabel.andSS() = ++ss;
};
	}
}

void InitMask_d47::forwardInputs()
{
	*_state_d4e= _state_d50;
	*_stateLabel_d4f= _stateLabel_d59;
}

void IsANDORGROUPCompound_d7f::operator()( const Packets_t& states_d80, const Packets_t& programs_d82, Packets_t& states_d84, Packets_t& programs_d85)
{
#ifdef PRINT_INFO
	printLog( "IsANDORGROUPCompound_d7f" );
#endif
	_state_d86= &states_d84;
	_program_d87= &programs_d85;
	for( Packets_t::const_iterator itstate_d89= states_d80.begin(), itprogram_d90= programs_d82.begin(); itstate_d89!= states_d80.end(), itprogram_d90!= programs_d82.end(); ++itstate_d89, ++itprogram_d90)
	{
		bool isUnique= isInputUnique( *itstate_d89, *itprogram_d90);
		if( !isUnique)
			continue;
		Packets_t onestate_d8d( 1, *itstate_d89);
		Packets_t oneprogram_d94( 1, *itprogram_d90);
		executeOne( onestate_d8d, oneprogram_d94);
	}
}

void IsANDORGROUPCompound_d7f::executeOne( const Packets_t& states_d80, const Packets_t& programs_d82)
{
	Packets_t states_d99;
	Packets_t programs_d9c;
	HasSubstates_d96 hasSubstates_d96;
	bool isMatchHasSubstates_d96= hasSubstates_d96( states_d80, programs_d82, states_d99, programs_d9c);
	_state_d86->insert( _state_d86->end(), states_d99.begin(), states_d99.end());
	_program_d87->insert( _program_d87->end(), programs_d9c.begin(), programs_d9c.end());
	if( isMatchHasSubstates_d96)
		return;
}

bool IsANDORGROUPCompound_d7f::isInputUnique( const Udm::Object& state_d8a, const Udm::Object& program_d91)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_d8c= _state_d88.begin(), itprogram_d93= _program_d8f.begin(); itstate_d8c!= _state_d88.end(), itprogram_d93!= _program_d8f.end(); ++itstate_d8c, ++itprogram_d93)
	{
		if( ( *itstate_d8c== state_d8a)&& ( *itprogram_d93== program_d91))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_d88.push_back( state_d8a);
		_program_d8f.push_back( program_d91);
	}
	return isUnique;
}

bool HasSubstates_d96::operator()( const Packets_t& states_d97, const Packets_t& programs_d9a, Packets_t& states_d99, Packets_t& programs_d9c)
{
#ifdef PRINT_INFO
	printLog( "HasSubstates_d96" );
#endif
	_state_d9d= &states_d99;
	_program_d9e= &programs_d9c;
	processInputPackets( states_d97, programs_d9a);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasSubstates_d96::isInputUnique( const Udm::Object& state_da3, const Udm::Object& program_dac)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_da5= _state_d9f.begin(), itProgram_dae= _program_da8.begin(); itState_da5!= _state_d9f.end(), itProgram_dae!= _program_da8.end(); ++itState_da5, ++itProgram_dae)
	{
		if( ( *itState_da5== state_da3)&& ( *itProgram_dae== program_dac))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_d9f.push_back( state_da3);
		_program_da8.push_back( program_dac);
	}
	return isUnique;
}

bool HasSubstates_d96::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool HasSubstates_d96::isGuardTrue( SFC::Program& Program, CyberComposition::Simulink::State& State, CyberComposition::Simulink::State& SubState)
{
	bool Gz_guard= false;
	string s = State.Decomposition();
Gz_guard = !( s.compare("FUNC_STATE") == 0 );;
	return Gz_guard;
}

void HasSubstates_d96::processInputPackets( const Packets_t& states_d97, const Packets_t& programs_d9a)
{
	for( Packets_t::const_iterator itState_da0= states_d97.begin(), itProgram_da9= programs_d9a.begin(); itState_da0!= states_d97.end(), itProgram_da9!= programs_d9a.end(); ++itState_da0, ++itProgram_da9)
	{
		bool isUnique= isInputUnique( *itState_da0, *itProgram_da9);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_da0, *itProgram_da9);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_db8, currMatch.program_db9);
	}
}

bool HasSubstates_d96::patternMatcher( const Udm::Object& state_da1, const Udm::Object& program_daa)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_da1.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_da6= CyberComposition::Simulink::State::Cast( state_da1);
		if( false== Uml::IsDerivedFrom( program_daa.type(), SFC::Program::meta))
			continue;
		SFC::Program program_daf= SFC::Program::Cast( program_daa);
		set< CyberComposition::Simulink::State> subStates_db1= state_da6.State_kind_children();
		for( set< CyberComposition::Simulink::State>::const_iterator itSubState_db2= subStates_db1.begin(); itSubState_db2!= subStates_db1.end(); ++itSubState_db2)
		{
			CyberComposition::Simulink::State currSubState_db3= *itSubState_db2;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_db7;
			if( !isValidBound(boundObjs_db7, state_da6, true))
				continue;
			currMatch.state_db8= state_da6;
			if( !isValidBound(boundObjs_db7, program_daf, true))
				continue;
			currMatch.program_db9= program_daf;
			if( !isValidBound(boundObjs_db7, currSubState_db3, false))
				continue;
			currMatch.subState_dba= currSubState_db3;
			bool Gz_guard= isGuardTrue( currMatch.program_db9, currMatch.state_db8, currMatch.subState_dba);
			if( true== Gz_guard)
			{
				_matches.push_back( currMatch);
				return true;
			}
		}
	}
	return !_matches.empty();
}

void HasSubstates_d96::outputAppender( const CyberComposition::Simulink::State& state_dbe, const SFC::Program& program_dc0)
{
	_state_d9d->push_back( state_dbe);
	_program_d9e->push_back( program_dc0);
}

void CreateStateVar_dcb::operator()( const Packets_t& states_dcc, const Packets_t& programs_dcf, Packets_t& states_dce, Packets_t& programs_dd1)
{
#ifdef PRINT_INFO
	printLog( "CreateStateVar_dcb" );
#endif
	RTTGenerator::Instance()->generateRule(129, "CreateStateVar");
	_state_dd2= &states_dce;
	_program_dd3= &programs_dd1;
	processInputPackets( states_dcc, programs_dcf);
	forwardInputs( );
}

bool CreateStateVar_dcb::isInputUnique( const Udm::Object& state_dd8, const Udm::Object& program_de1)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_dda= _state_dd4.begin(), itProgram_de3= _program_ddd.begin(); itState_dda!= _state_dd4.end(), itProgram_de3!= _program_ddd.end(); ++itState_dda, ++itProgram_de3)
	{
		if( ( *itState_dda== state_dd8)&& ( *itProgram_de3== program_de1))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_dd4.push_back( state_dd8);
		_program_ddd.push_back( program_de1);
	}
	return isUnique;
}

bool CreateStateVar_dcb::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateStateVar_dcb::processInputPackets( const Packets_t& states_dcc, const Packets_t& programs_dcf)
{
	for( Packets_t::const_iterator itState_dd5= states_dcc.begin(), itProgram_dde= programs_dcf.begin(); itState_dd5!= states_dcc.end(), itProgram_dde!= programs_dcf.end(); ++itState_dd5, ++itProgram_dde)
	{
		bool isUnique= isInputUnique( *itState_dd5, *itProgram_dde);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_dd5, *itProgram_dde);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateStateVar_dcb::patternMatcher( const Udm::Object& state_dd6, const Udm::Object& program_ddf)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_dd6.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_ddb= CyberComposition::Simulink::State::Cast( state_dd6);
		if( false== Uml::IsDerivedFrom( program_ddf.type(), SFC::Program::meta))
			continue;
		SFC::Program program_de4= SFC::Program::Cast( program_ddf);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_de9;
		if( !isValidBound(boundObjs_de9, state_ddb, true))
			continue;
		currMatch.state_dea= state_ddb;
		if( !isValidBound(boundObjs_de9, program_de4, true))
			continue;
		currMatch.program_deb= program_de4;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateStateVar_dcb::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::StateVar newStateVar_dec= SFC::StateVar::Create( currMatch.program_deb, SFC::Program::meta_stmnt);
		SFC::Program& Program= currMatch.program_deb;
		CyberComposition::Simulink::State& State= currMatch.state_dea;
		SFC::StateVar& StateVar= newStateVar_dec;
		{
StateVar.RefId() = Program.RefId();
};
		{
__int64 stateCount = Program.stateCount();
StateVar.size() = stateCount;
StateVar.name() = "activeSubStates";
StateVar.dt() = SFCTypesManager::getSingleton().getBasicType( "int" );
};
		{
__int64 statementCount = Program.statementCount();
StateVar.statementIndex() = statementCount++;
Program.statementCount() = statementCount;
};
	}
}

void CreateStateVar_dcb::forwardInputs()
{
	*_state_dd2= _state_dd4;
	*_program_dd3= _program_ddd;
}

void CreateLeafStates_ded::operator()( const Packets_t& states_dee, const Packets_t& programs_df0, Packets_t& states_df2, Packets_t& programs_df3)
{
#ifdef PRINT_INFO
	printLog( "CreateLeafStates_ded" );
#endif
	_state_df4= &states_df2;
	_program_df5= &programs_df3;
	_state_df4->insert( _state_df4->end(), states_dee.begin(), states_dee.end());
	_program_df5->insert( _program_df5->end(), programs_df0.begin(), programs_df0.end());
	if( ( !states_dee.empty())&& ( !programs_df0.empty()))
		callIsLeaf_e64( states_dee, programs_df0);
}

void CreateLeafStates_ded::callIsLeaf_e64( const Packets_t& states_df7, const Packets_t& programs_df9)
{
	Packets_t states_dfb;
	Packets_t programs_dfc;
	Packets_t states_dfd;
	Packets_t programs_dfe;
	IsLeaf_df6 isLeaf_df6;
	isLeaf_df6( states_df7, programs_df9, states_dfb, programs_dfc, states_dfd, programs_dfe);
	if( ( !states_dfd.empty())&& ( !programs_dfe.empty()))
		callCreateStateLabel_e67( states_dfd, programs_dfe);
	if( ( !states_dfb.empty())&& ( !programs_dfc.empty()))
		callGetSubStates_e6a( states_dfb, programs_dfc);
}

void CreateLeafStates_ded::callCreateStateLabel_e67( const Packets_t& states_cf1, const Packets_t& programs_cf3)
{
	Packets_t states_cf5;
	Packets_t programs_cf6;
	CreateStateLabel_cf0 createStateLabel_cf0;
	createStateLabel_cf0( states_cf1, programs_cf3, states_cf5, programs_cf6);
}

void CreateLeafStates_ded::callGetSubStates_e6a( const Packets_t& states_c8c, const Packets_t& parStmnts_c8f)
{
	Packets_t subStates_c8e;
	Packets_t parStmnts_c91;
	GetSubStates_c8b getSubStates_c8b;
	getSubStates_c8b( states_c8c, parStmnts_c8f, subStates_c8e, parStmnts_c91);
	if( ( !subStates_c8e.empty())&& ( !parStmnts_c91.empty()))
		callIsLeaf_e64( subStates_c8e, parStmnts_c91);
}

void IsLeaf_df6::operator()( const Packets_t& states_df7, const Packets_t& programs_df9, Packets_t& states_dfb, Packets_t& programs_dfc, Packets_t& states_dfd, Packets_t& programs_dfe)
{
#ifdef PRINT_INFO
	printLog( "IsLeaf_df6" );
#endif
	_state_dff= &states_dfb;
	_program_e00= &programs_dfc;
	_state_e01= &states_dfd;
	_program_e02= &programs_dfe;
	for( Packets_t::const_iterator itstate_e04= states_df7.begin(), itprogram_e0b= programs_df9.begin(); itstate_e04!= states_df7.end(), itprogram_e0b!= programs_df9.end(); ++itstate_e04, ++itprogram_e0b)
	{
		bool isUnique= isInputUnique( *itstate_e04, *itprogram_e0b);
		if( !isUnique)
			continue;
		Packets_t onestate_e08( 1, *itstate_e04);
		Packets_t oneprogram_e0f( 1, *itprogram_e0b);
		executeOne( onestate_e08, oneprogram_e0f);
	}
}

void IsLeaf_df6::executeOne( const Packets_t& states_df7, const Packets_t& programs_df9)
{
	Packets_t states_e14;
	Packets_t programs_e17;
	HasSubstates_e11 hasSubstates_e11;
	bool isMatchHasSubstates_e11= hasSubstates_e11( states_df7, programs_df9, states_e14, programs_e17);
	_state_dff->insert( _state_dff->end(), states_e14.begin(), states_e14.end());
	_program_e00->insert( _program_e00->end(), programs_e17.begin(), programs_e17.end());
	if( isMatchHasSubstates_e11)
		return;
	Packets_t states_e40;
	Packets_t programs_e43;
	Otherwise_e3d otherwise_e3d;
	bool isMatchOtherwise_e3d= otherwise_e3d( states_df7, programs_df9, states_e40, programs_e43);
	_state_e01->insert( _state_e01->end(), states_e40.begin(), states_e40.end());
	_program_e02->insert( _program_e02->end(), programs_e43.begin(), programs_e43.end());
}

bool IsLeaf_df6::isInputUnique( const Udm::Object& state_e05, const Udm::Object& program_e0c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_e07= _state_e03.begin(), itprogram_e0e= _program_e0a.begin(); itstate_e07!= _state_e03.end(), itprogram_e0e!= _program_e0a.end(); ++itstate_e07, ++itprogram_e0e)
	{
		if( ( *itstate_e07== state_e05)&& ( *itprogram_e0e== program_e0c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_e03.push_back( state_e05);
		_program_e0a.push_back( program_e0c);
	}
	return isUnique;
}

bool HasSubstates_e11::operator()( const Packets_t& states_e12, const Packets_t& programs_e15, Packets_t& states_e14, Packets_t& programs_e17)
{
#ifdef PRINT_INFO
	printLog( "HasSubstates_e11" );
#endif
	_state_e18= &states_e14;
	_program_e19= &programs_e17;
	processInputPackets( states_e12, programs_e15);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasSubstates_e11::isInputUnique( const Udm::Object& state_e1e, const Udm::Object& program_e27)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_e20= _state_e1a.begin(), itProgram_e29= _program_e23.begin(); itState_e20!= _state_e1a.end(), itProgram_e29!= _program_e23.end(); ++itState_e20, ++itProgram_e29)
	{
		if( ( *itState_e20== state_e1e)&& ( *itProgram_e29== program_e27))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_e1a.push_back( state_e1e);
		_program_e23.push_back( program_e27);
	}
	return isUnique;
}

bool HasSubstates_e11::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool HasSubstates_e11::isGuardTrue( SFC::Program& Program, CyberComposition::Simulink::State& State, CyberComposition::Simulink::State& SubState)
{
	bool Gz_guard= false;
	string s;
State.GetStrValue("Decomposition", s);
Gz_guard = !( s.compare("FUNC_STATE") == 0 );;
	return Gz_guard;
}

void HasSubstates_e11::processInputPackets( const Packets_t& states_e12, const Packets_t& programs_e15)
{
	for( Packets_t::const_iterator itState_e1b= states_e12.begin(), itProgram_e24= programs_e15.begin(); itState_e1b!= states_e12.end(), itProgram_e24!= programs_e15.end(); ++itState_e1b, ++itProgram_e24)
	{
		bool isUnique= isInputUnique( *itState_e1b, *itProgram_e24);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_e1b, *itProgram_e24);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_e33, currMatch.program_e34);
	}
}

bool HasSubstates_e11::patternMatcher( const Udm::Object& state_e1c, const Udm::Object& program_e25)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_e1c.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_e21= CyberComposition::Simulink::State::Cast( state_e1c);
		if( false== Uml::IsDerivedFrom( program_e25.type(), SFC::Program::meta))
			continue;
		SFC::Program program_e2a= SFC::Program::Cast( program_e25);
		set< CyberComposition::Simulink::State> subStates_e2c= state_e21.State_kind_children();
		for( set< CyberComposition::Simulink::State>::const_iterator itSubState_e2d= subStates_e2c.begin(); itSubState_e2d!= subStates_e2c.end(); ++itSubState_e2d)
		{
			CyberComposition::Simulink::State currSubState_e2e= *itSubState_e2d;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_e32;
			if( !isValidBound(boundObjs_e32, state_e21, true))
				continue;
			currMatch.state_e33= state_e21;
			if( !isValidBound(boundObjs_e32, program_e2a, true))
				continue;
			currMatch.program_e34= program_e2a;
			if( !isValidBound(boundObjs_e32, currSubState_e2e, false))
				continue;
			currMatch.subState_e35= currSubState_e2e;
			bool Gz_guard= isGuardTrue( currMatch.program_e34, currMatch.state_e33, currMatch.subState_e35);
			if( true== Gz_guard)
			{
				_matches.push_back( currMatch);
				return true;
			}
		}
	}
	return !_matches.empty();
}

void HasSubstates_e11::outputAppender( const CyberComposition::Simulink::State& state_e39, const SFC::Program& program_e3b)
{
	_state_e18->push_back( state_e39);
	_program_e19->push_back( program_e3b);
}

bool Otherwise_e3d::operator()( const Packets_t& states_e3e, const Packets_t& programs_e41, Packets_t& states_e40, Packets_t& programs_e43)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_e3d" );
#endif
	_state_e44= &states_e40;
	_program_e45= &programs_e43;
	processInputPackets( states_e3e, programs_e41);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_e3d::isInputUnique( const Udm::Object& state_e4a, const Udm::Object& program_e53)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_e4c= _state_e46.begin(), itProgram_e55= _program_e4f.begin(); itState_e4c!= _state_e46.end(), itProgram_e55!= _program_e4f.end(); ++itState_e4c, ++itProgram_e55)
	{
		if( ( *itState_e4c== state_e4a)&& ( *itProgram_e55== program_e53))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_e46.push_back( state_e4a);
		_program_e4f.push_back( program_e53);
	}
	return isUnique;
}

bool Otherwise_e3d::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool Otherwise_e3d::isGuardTrue( SFC::Program& Program, CyberComposition::Simulink::State& State)
{
	bool Gz_guard= false;
	string s = State.Decomposition();
Gz_guard = !( s.compare("FUNC_STATE") == 0 );;
	return Gz_guard;
}

void Otherwise_e3d::processInputPackets( const Packets_t& states_e3e, const Packets_t& programs_e41)
{
	for( Packets_t::const_iterator itState_e47= states_e3e.begin(), itProgram_e50= programs_e41.begin(); itState_e47!= states_e3e.end(), itProgram_e50!= programs_e41.end(); ++itState_e47, ++itProgram_e50)
	{
		bool isUnique= isInputUnique( *itState_e47, *itProgram_e50);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_e47, *itProgram_e50);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_e5c, currMatch.program_e5d);
	}
}

bool Otherwise_e3d::patternMatcher( const Udm::Object& state_e48, const Udm::Object& program_e51)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_e48.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_e4d= CyberComposition::Simulink::State::Cast( state_e48);
		if( false== Uml::IsDerivedFrom( program_e51.type(), SFC::Program::meta))
			continue;
		SFC::Program program_e56= SFC::Program::Cast( program_e51);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_e5b;
		if( !isValidBound(boundObjs_e5b, state_e4d, true))
			continue;
		currMatch.state_e5c= state_e4d;
		if( !isValidBound(boundObjs_e5b, program_e56, true))
			continue;
		currMatch.program_e5d= program_e56;
		bool Gz_guard= isGuardTrue( currMatch.program_e5d, currMatch.state_e5c);
		if( true== Gz_guard)
		{
			_matches.push_back( currMatch);
			return true;
		}
	}
	return !_matches.empty();
}

void Otherwise_e3d::outputAppender( const CyberComposition::Simulink::State& state_e60, const SFC::Program& program_e62)
{
	_state_e44->push_back( state_e60);
	_program_e45->push_back( program_e62);
}

void CreateFuncStates_psuedo_e6d::operator()( const Packets_t& states_e6e, const Packets_t& programs_e70, Packets_t& states_e72, Packets_t& programs_e73)
{
#ifdef PRINT_INFO
	printLog( "CreateFuncStates_psuedo_e6d" );
#endif
	_state_e74= &states_e72;
	_program_e75= &programs_e73;
	if( ( !states_e6e.empty())&& ( !programs_e70.empty()))
		callIsFuncState_ee4( states_e6e, programs_e70);
	_state_e74->insert( _state_e74->end(), states_e6e.begin(), states_e6e.end());
	_program_e75->insert( _program_e75->end(), programs_e70.begin(), programs_e70.end());
}

void CreateFuncStates_psuedo_e6d::callIsFuncState_ee4( const Packets_t& states_e77, const Packets_t& programs_e79)
{
	Packets_t states_e7b;
	Packets_t programs_e7c;
	Packets_t states_e7d;
	Packets_t programs_e7e;
	IsFuncState_e76 isFuncState_e76;
	isFuncState_e76( states_e77, programs_e79, states_e7b, programs_e7c, states_e7d, programs_e7e);
	if( ( !states_e7b.empty())&& ( !programs_e7c.empty()))
		callGetSubStates_ee7( states_e7b, programs_e7c);
	if( ( !states_e7d.empty())&& ( !programs_e7e.empty()))
		callCreateStateLabel_eea( states_e7d, programs_e7e);
}

void CreateFuncStates_psuedo_e6d::callGetSubStates_ee7( const Packets_t& states_c8c, const Packets_t& parStmnts_c8f)
{
	Packets_t subStates_c8e;
	Packets_t parStmnts_c91;
	GetSubStates_c8b getSubStates_c8b;
	getSubStates_c8b( states_c8c, parStmnts_c8f, subStates_c8e, parStmnts_c91);
	if( ( !subStates_c8e.empty())&& ( !parStmnts_c91.empty()))
		callIsFuncState_ee4( subStates_c8e, parStmnts_c91);
}

void CreateFuncStates_psuedo_e6d::callCreateStateLabel_eea( const Packets_t& states_cf1, const Packets_t& programs_cf3)
{
	Packets_t states_cf5;
	Packets_t programs_cf6;
	CreateStateLabel_cf0 createStateLabel_cf0;
	createStateLabel_cf0( states_cf1, programs_cf3, states_cf5, programs_cf6);
	if( ( !states_cf5.empty())&& ( !programs_cf6.empty()))
		callGetSubStates_ee7( states_cf5, programs_cf6);
}

void IsFuncState_e76::operator()( const Packets_t& states_e77, const Packets_t& programs_e79, Packets_t& states_e7b, Packets_t& programs_e7c, Packets_t& states_e7d, Packets_t& programs_e7e)
{
#ifdef PRINT_INFO
	printLog( "IsFuncState_e76" );
#endif
	_state_e7f= &states_e7b;
	_program_e80= &programs_e7c;
	_state_e81= &states_e7d;
	_program_e82= &programs_e7e;
	for( Packets_t::const_iterator itstate_e84= states_e77.begin(), itprogram_e8b= programs_e79.begin(); itstate_e84!= states_e77.end(), itprogram_e8b!= programs_e79.end(); ++itstate_e84, ++itprogram_e8b)
	{
		bool isUnique= isInputUnique( *itstate_e84, *itprogram_e8b);
		if( !isUnique)
			continue;
		Packets_t onestate_e88( 1, *itstate_e84);
		Packets_t oneprogram_e8f( 1, *itprogram_e8b);
		executeOne( onestate_e88, oneprogram_e8f);
	}
}

void IsFuncState_e76::executeOne( const Packets_t& states_e77, const Packets_t& programs_e79)
{
	Packets_t states_e94;
	Packets_t programs_e97;
	HasSubstates_e91 hasSubstates_e91;
	bool isMatchHasSubstates_e91= hasSubstates_e91( states_e77, programs_e79, states_e94, programs_e97);
	_state_e7f->insert( _state_e7f->end(), states_e94.begin(), states_e94.end());
	_program_e80->insert( _program_e80->end(), programs_e97.begin(), programs_e97.end());
	if( isMatchHasSubstates_e91)
		return;
	Packets_t states_ec0;
	Packets_t programs_ec3;
	Otherwise_ebd otherwise_ebd;
	bool isMatchOtherwise_ebd= otherwise_ebd( states_e77, programs_e79, states_ec0, programs_ec3);
	_state_e81->insert( _state_e81->end(), states_ec0.begin(), states_ec0.end());
	_program_e82->insert( _program_e82->end(), programs_ec3.begin(), programs_ec3.end());
}

bool IsFuncState_e76::isInputUnique( const Udm::Object& state_e85, const Udm::Object& program_e8c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_e87= _state_e83.begin(), itprogram_e8e= _program_e8a.begin(); itstate_e87!= _state_e83.end(), itprogram_e8e!= _program_e8a.end(); ++itstate_e87, ++itprogram_e8e)
	{
		if( ( *itstate_e87== state_e85)&& ( *itprogram_e8e== program_e8c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_e83.push_back( state_e85);
		_program_e8a.push_back( program_e8c);
	}
	return isUnique;
}

bool HasSubstates_e91::operator()( const Packets_t& states_e92, const Packets_t& programs_e95, Packets_t& states_e94, Packets_t& programs_e97)
{
#ifdef PRINT_INFO
	printLog( "HasSubstates_e91" );
#endif
	_state_e98= &states_e94;
	_program_e99= &programs_e97;
	processInputPackets( states_e92, programs_e95);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasSubstates_e91::isInputUnique( const Udm::Object& state_e9e, const Udm::Object& program_ea7)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_ea0= _state_e9a.begin(), itProgram_ea9= _program_ea3.begin(); itState_ea0!= _state_e9a.end(), itProgram_ea9!= _program_ea3.end(); ++itState_ea0, ++itProgram_ea9)
	{
		if( ( *itState_ea0== state_e9e)&& ( *itProgram_ea9== program_ea7))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_e9a.push_back( state_e9e);
		_program_ea3.push_back( program_ea7);
	}
	return isUnique;
}

bool HasSubstates_e91::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool HasSubstates_e91::isGuardTrue( SFC::Program& Program, CyberComposition::Simulink::State& State, CyberComposition::Simulink::State& SubState)
{
	bool Gz_guard= false;
	Gz_guard  = static_cast< std::string >( State.Decomposition() ) != "FUNC_STATE";;
	return Gz_guard;
}

void HasSubstates_e91::processInputPackets( const Packets_t& states_e92, const Packets_t& programs_e95)
{
	for( Packets_t::const_iterator itState_e9b= states_e92.begin(), itProgram_ea4= programs_e95.begin(); itState_e9b!= states_e92.end(), itProgram_ea4!= programs_e95.end(); ++itState_e9b, ++itProgram_ea4)
	{
		bool isUnique= isInputUnique( *itState_e9b, *itProgram_ea4);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_e9b, *itProgram_ea4);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_eb3, currMatch.program_eb4);
	}
}

bool HasSubstates_e91::patternMatcher( const Udm::Object& state_e9c, const Udm::Object& program_ea5)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_e9c.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_ea1= CyberComposition::Simulink::State::Cast( state_e9c);
		if( false== Uml::IsDerivedFrom( program_ea5.type(), SFC::Program::meta))
			continue;
		SFC::Program program_eaa= SFC::Program::Cast( program_ea5);
		set< CyberComposition::Simulink::State> subStates_eac= state_ea1.State_kind_children();
		for( set< CyberComposition::Simulink::State>::const_iterator itSubState_ead= subStates_eac.begin(); itSubState_ead!= subStates_eac.end(); ++itSubState_ead)
		{
			CyberComposition::Simulink::State currSubState_eae= *itSubState_ead;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_eb2;
			if( !isValidBound(boundObjs_eb2, state_ea1, true))
				continue;
			currMatch.state_eb3= state_ea1;
			if( !isValidBound(boundObjs_eb2, program_eaa, true))
				continue;
			currMatch.program_eb4= program_eaa;
			if( !isValidBound(boundObjs_eb2, currSubState_eae, false))
				continue;
			currMatch.subState_eb5= currSubState_eae;
			bool Gz_guard= isGuardTrue( currMatch.program_eb4, currMatch.state_eb3, currMatch.subState_eb5);
			if( true== Gz_guard)
			{
				_matches.push_back( currMatch);
				return true;
			}
		}
	}
	return !_matches.empty();
}

void HasSubstates_e91::outputAppender( const CyberComposition::Simulink::State& state_eb9, const SFC::Program& program_ebb)
{
	_state_e98->push_back( state_eb9);
	_program_e99->push_back( program_ebb);
}

bool Otherwise_ebd::operator()( const Packets_t& states_ebe, const Packets_t& programs_ec1, Packets_t& states_ec0, Packets_t& programs_ec3)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_ebd" );
#endif
	_state_ec4= &states_ec0;
	_program_ec5= &programs_ec3;
	processInputPackets( states_ebe, programs_ec1);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_ebd::isInputUnique( const Udm::Object& state_eca, const Udm::Object& program_ed3)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_ecc= _state_ec6.begin(), itProgram_ed5= _program_ecf.begin(); itState_ecc!= _state_ec6.end(), itProgram_ed5!= _program_ecf.end(); ++itState_ecc, ++itProgram_ed5)
	{
		if( ( *itState_ecc== state_eca)&& ( *itProgram_ed5== program_ed3))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_ec6.push_back( state_eca);
		_program_ecf.push_back( program_ed3);
	}
	return isUnique;
}

bool Otherwise_ebd::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool Otherwise_ebd::isGuardTrue( SFC::Program& Program, CyberComposition::Simulink::State& State)
{
	bool Gz_guard= false;
	string s = State.Decomposition();
Gz_guard = ( s.compare("FUNC_STATE") == 0 );;
	return Gz_guard;
}

void Otherwise_ebd::processInputPackets( const Packets_t& states_ebe, const Packets_t& programs_ec1)
{
	for( Packets_t::const_iterator itState_ec7= states_ebe.begin(), itProgram_ed0= programs_ec1.begin(); itState_ec7!= states_ebe.end(), itProgram_ed0!= programs_ec1.end(); ++itState_ec7, ++itProgram_ed0)
	{
		bool isUnique= isInputUnique( *itState_ec7, *itProgram_ed0);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_ec7, *itProgram_ed0);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_edc, currMatch.program_edd);
	}
}

bool Otherwise_ebd::patternMatcher( const Udm::Object& state_ec8, const Udm::Object& program_ed1)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_ec8.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_ecd= CyberComposition::Simulink::State::Cast( state_ec8);
		if( false== Uml::IsDerivedFrom( program_ed1.type(), SFC::Program::meta))
			continue;
		SFC::Program program_ed6= SFC::Program::Cast( program_ed1);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_edb;
		if( !isValidBound(boundObjs_edb, state_ecd, true))
			continue;
		currMatch.state_edc= state_ecd;
		if( !isValidBound(boundObjs_edb, program_ed6, true))
			continue;
		currMatch.program_edd= program_ed6;
		bool Gz_guard= isGuardTrue( currMatch.program_edd, currMatch.state_edc);
		if( true== Gz_guard)
		{
			_matches.push_back( currMatch);
			return true;
		}
	}
	return !_matches.empty();
}

void Otherwise_ebd::outputAppender( const CyberComposition::Simulink::State& state_ee0, const SFC::Program& program_ee2)
{
	_state_ec4->push_back( state_ee0);
	_program_ec5->push_back( program_ee2);
}

void CreateFuncStateFunctions_ef9::operator()( const Packets_t& states_efa, const Packets_t& programs_efc, Packets_t& states_efe, Packets_t& programs_eff)
{
#ifdef PRINT_INFO
	printLog( "CreateFuncStateFunctions_ef9" );
#endif
	_state_f00= &states_efe;
	_program_f01= &programs_eff;
	if( ( !states_efa.empty())&& ( !programs_efc.empty()))
		callPopulateGRFSFunction_104e( states_efa, programs_efc);
	_state_f00->insert( _state_f00->end(), states_efa.begin(), states_efa.end());
	_program_f01->insert( _program_f01->end(), programs_efc.begin(), programs_efc.end());
}

void CreateFuncStateFunctions_ef9::callPopulateGRFSFunction_104e( const Packets_t& states_1011, const Packets_t& programs_1013)
{
	Packets_t states_1015;
	Packets_t programs_1016;
	PopulateGRFSFunction_1010 populateGRFSFunction_1010;
	populateGRFSFunction_1010( states_1011, programs_1013, states_1015, programs_1016);
	if( ( !states_1015.empty())&& ( !programs_1016.empty()))
		callPopulateEMFSFunction_1051( states_1015, programs_1016);
}

void CreateFuncStateFunctions_ef9::callPopulateEMFSFunction_1051( const Packets_t& states_f03, const Packets_t& programs_f05)
{
	Packets_t states_f07;
	Packets_t programs_f08;
	PopulateEMFSFunction_f02 populateEMFSFunction_f02;
	populateEMFSFunction_f02( states_f03, programs_f05, states_f07, programs_f08);
	if( ( !states_f07.empty())&& ( !programs_f08.empty()))
		callGetSubStates_1054( states_f07, programs_f08);
}

void CreateFuncStateFunctions_ef9::callGetSubStates_1054( const Packets_t& states_c8c, const Packets_t& parStmnts_c8f)
{
	Packets_t subStates_c8e;
	Packets_t parStmnts_c91;
	GetSubStates_c8b getSubStates_c8b;
	getSubStates_c8b( states_c8c, parStmnts_c8f, subStates_c8e, parStmnts_c91);
	if( ( !subStates_c8e.empty())&& ( !parStmnts_c91.empty()))
		callPopulateGRFSFunction_104e( subStates_c8e, parStmnts_c91);
}

void PopulateEMFSFunction_f02::operator()( const Packets_t& states_f03, const Packets_t& programs_f05, Packets_t& states_f07, Packets_t& programs_f08)
{
#ifdef PRINT_INFO
	printLog( "PopulateEMFSFunction_f02" );
#endif
	_state_f09= &states_f07;
	_program_f0a= &programs_f08;
	_state_f09->insert( _state_f09->end(), states_f03.begin(), states_f03.end());
	_program_f0a->insert( _program_f0a->end(), programs_f05.begin(), programs_f05.end());
	if( ( !states_f03.empty())&& ( !programs_f05.empty()))
		callCreateEMFuncStateFunction_100a( states_f03, programs_f05);
}

void PopulateEMFSFunction_f02::callCreateEMFuncStateFunction_100a( const Packets_t& states_f0c, const Packets_t& programs_f0f)
{
	Packets_t states_f0e;
	Packets_t execs_f11;
	CreateEMFuncStateFunction_f0b createEMFuncStateFunction_f0b;
	createEMFuncStateFunction_f0b( states_f0c, programs_f0f, states_f0e, execs_f11);
	if( ( !states_f0e.empty())&& ( !execs_f11.empty()))
		callFuncArgsAndVars_100d( states_f0e, execs_f11);
}

void PopulateEMFSFunction_f02::callFuncArgsAndVars_100d( const Packets_t& states_f39, const Packets_t& fcns_f3b)
{
	Packets_t states_f3d;
	Packets_t fcns_f3e;
	FuncArgsAndVars_f38 funcArgsAndVars_f38;
	funcArgsAndVars_f38( states_f39, fcns_f3b, states_f3d, fcns_f3e);
}

void CreateEMFuncStateFunction_f0b::operator()( const Packets_t& states_f0c, const Packets_t& programs_f0f, Packets_t& states_f0e, Packets_t& execs_f11)
{
#ifdef PRINT_INFO
	printLog( "CreateEMFuncStateFunction_f0b" );
#endif
	RTTGenerator::Instance()->generateRule(187, "CreateEMFuncStateFunction");
	_state_f12= &states_f0e;
	_exec_f13= &execs_f11;
	processInputPackets( states_f0c, programs_f0f);
}

bool CreateEMFuncStateFunction_f0b::isInputUnique( const Udm::Object& state_f18, const Udm::Object& program_f21)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_f1a= _state_f14.begin(), itProgram_f23= _program_f1d.begin(); itState_f1a!= _state_f14.end(), itProgram_f23!= _program_f1d.end(); ++itState_f1a, ++itProgram_f23)
	{
		if( ( *itState_f1a== state_f18)&& ( *itProgram_f23== program_f21))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_f14.push_back( state_f18);
		_program_f1d.push_back( program_f21);
	}
	return isUnique;
}

bool CreateEMFuncStateFunction_f0b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool CreateEMFuncStateFunction_f0b::isGuardTrue( SFC::Program& Program, CyberComposition::Simulink::State& State, SFC::StateLabel& StateLabel)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( State.Decomposition() ) == "FUNC_STATE" &&
 static_cast< std::string >( State.Order() ) == "-2";;
	return Gz_guard;
}

void CreateEMFuncStateFunction_f0b::processInputPackets( const Packets_t& states_f0c, const Packets_t& programs_f0f)
{
	for( Packets_t::const_iterator itState_f15= states_f0c.begin(), itProgram_f1e= programs_f0f.begin(); itState_f15!= states_f0c.end(), itProgram_f1e!= programs_f0f.end(); ++itState_f15, ++itProgram_f1e)
	{
		bool isUnique= isInputUnique( *itState_f15, *itProgram_f1e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_f15, *itProgram_f1e);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateEMFuncStateFunction_f0b::patternMatcher( const Udm::Object& state_f16, const Udm::Object& program_f1f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_f16.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_f1b= CyberComposition::Simulink::State::Cast( state_f16);
		if( false== Uml::IsDerivedFrom( program_f1f.type(), SFC::Program::meta))
			continue;
		SFC::Program program_f24= SFC::Program::Cast( program_f1f);
		set< SFC::StateLabel> stateLabels_f26= state_f1b.src();
		for( set< SFC::StateLabel>::const_iterator itStateLabels_f27= stateLabels_f26.begin(); itStateLabels_f27!= stateLabels_f26.end(); ++itStateLabels_f27)
		{
			SFC::StateLabel currStateLabel_f28= *itStateLabels_f27;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_f2c;
			if( !isValidBound(boundObjs_f2c, state_f1b, true))
				continue;
			currMatch.state_f2d= state_f1b;
			if( !isValidBound(boundObjs_f2c, program_f24, true))
				continue;
			currMatch.program_f2e= program_f24;
			if( !isValidBound(boundObjs_f2c, currStateLabel_f28, false))
				continue;
			currMatch.stateLabel_f2f= currStateLabel_f28;
			bool Gz_guard= isGuardTrue( currMatch.program_f2e, currMatch.state_f2d, currMatch.stateLabel_f2f);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateEMFuncStateFunction_f0b::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function newExec_f33= SFC::Function::Create( currMatch.program_f2e, SFC::Program::meta_stmnt);
		SFC::Function& Exec= newExec_f33;
		SFC::Program& Program= currMatch.program_f2e;
		CyberComposition::Simulink::State& State= currMatch.state_f2d;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_f2f;
		{
Exec.RefId() = State.RefId();
};
		{
__int64 statementCount = Program.statementCount();
Exec.statementIndex() = statementCount++;
Program.statementCount() = statementCount;
};
		{
Exec.name() = State.name();
Exec.scope() = StateLabel.comment();

SFManager::FunctionArgMapManager::get_singleton().parseFunctionSpec( Exec, State.EnterAction() );

SFManager::AddTypedEntityScope( Exec );
};
		newExec_f33.execSt()+= currMatch.state_f2d;
		outputAppender( currMatch.state_f2d, newExec_f33);
	}
}

void CreateEMFuncStateFunction_f0b::outputAppender( const CyberComposition::Simulink::State& state_f34, const SFC::Function& exec_f36)
{
	_state_f12->push_back( state_f34);
	_exec_f13->push_back( exec_f36);
}

void FuncArgsAndVars_f38::operator()( const Packets_t& states_f39, const Packets_t& fcns_f3b, Packets_t& states_f3d, Packets_t& fcns_f3e)
{
#ifdef PRINT_INFO
	printLog( "FuncArgsAndVars_f38" );
#endif
	_state_f3f= &states_f3d;
	_fcn_f40= &fcns_f3e;
	if( ( !states_f39.empty())&& ( !fcns_f3b.empty()))
		callFuncInputArgs_1001( states_f39, fcns_f3b);
}

void FuncArgsAndVars_f38::callFuncInputArgs_1001( const Packets_t& states_f42, const Packets_t& fcns_f44)
{
	Packets_t states_f46;
	Packets_t fcns_f47;
	FuncInputArgs_f41 funcInputArgs_f41;
	funcInputArgs_f41( states_f42, fcns_f44, states_f46, fcns_f47);
	if( ( !states_f46.empty())&& ( !fcns_f47.empty()))
		callFuncOutputArgs_1004( states_f46, fcns_f47);
}

void FuncArgsAndVars_f38::callFuncOutputArgs_1004( const Packets_t& states_f80, const Packets_t& fcns_f82)
{
	Packets_t states_f84;
	Packets_t fcns_f85;
	FuncOutputArgs_f7f funcOutputArgs_f7f;
	funcOutputArgs_f7f( states_f80, fcns_f82, states_f84, fcns_f85);
	if( ( !states_f84.empty())&& ( !fcns_f85.empty()))
		callFuncLocalVars_1007( states_f84, fcns_f85);
}

void FuncArgsAndVars_f38::callFuncLocalVars_1007( const Packets_t& states_fc1, const Packets_t& fcns_fc3)
{
	Packets_t states_fc5;
	Packets_t fcns_fc6;
	FuncLocalVars_fc0 funcLocalVars_fc0;
	funcLocalVars_fc0( states_fc1, fcns_fc3, states_fc5, fcns_fc6);
	_state_f3f->insert( _state_f3f->end(), states_fc5.begin(), states_fc5.end());
	_fcn_f40->insert( _fcn_f40->end(), fcns_fc6.begin(), fcns_fc6.end());
}

void FuncInputArgs_f41::operator()( const Packets_t& states_f42, const Packets_t& fcns_f44, Packets_t& states_f46, Packets_t& fcns_f47)
{
#ifdef PRINT_INFO
	printLog( "FuncInputArgs_f41" );
#endif
	_state_f48= &states_f46;
	_fcn_f49= &fcns_f47;
	_state_f48->insert( _state_f48->end(), states_f42.begin(), states_f42.end());
	_fcn_f49->insert( _fcn_f49->end(), fcns_f44.begin(), fcns_f44.end());
	if( ( !states_f42.empty())&& ( !fcns_f44.empty()))
		callInputArgs_f7c( states_f42, fcns_f44);
}

void FuncInputArgs_f41::callInputArgs_f7c( const Packets_t& states_f4b, const Packets_t& execs_f4d)
{
	InputArgs_f4a inputArgs_f4a;
	inputArgs_f4a( states_f4b, execs_f4d);
}

void InputArgs_f4a::operator()( const Packets_t& states_f4b, const Packets_t& execs_f4d)
{
#ifdef PRINT_INFO
	printLog( "InputArgs_f4a" );
#endif
	RTTGenerator::Instance()->generateRule(230, "InputArgs");
	processInputPackets( states_f4b, execs_f4d);
}

bool InputArgs_f4a::isInputUnique( const Udm::Object& state_f53, const Udm::Object& exec_f5c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_f55= _state_f4f.begin(), itExec_f5e= _exec_f58.begin(); itState_f55!= _state_f4f.end(), itExec_f5e!= _exec_f58.end(); ++itState_f55, ++itExec_f5e)
	{
		if( ( *itState_f55== state_f53)&& ( *itExec_f5e== exec_f5c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_f4f.push_back( state_f53);
		_exec_f58.push_back( exec_f5c);
	}
	return isUnique;
}

bool InputArgs_f4a::isGuardTrue( SFC::DT& DT, CyberComposition::Simulink::Data& Data, SFC::Function& Exec, CyberComposition::Simulink::State& State, SFC::StateLabel& StateLabel, CyberComposition::Simulink::SF_TypeBase& TypeBase, CyberComposition::Simulink::TypeBaseRef& TypeBaseRef)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( Data.Scope() ) == "INPUT_DATA";;
	return Gz_guard;
}

void InputArgs_f4a::processInputPackets( const Packets_t& states_f4b, const Packets_t& execs_f4d)
{
	for( Packets_t::const_iterator itState_f50= states_f4b.begin(), itExec_f59= execs_f4d.begin(); itState_f50!= states_f4b.end(), itExec_f59!= execs_f4d.end(); ++itState_f50, ++itExec_f59)
	{
		bool isUnique= isInputUnique( *itState_f50, *itExec_f59);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_f50, *itExec_f59);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InputArgs_f4a::patternMatcher( const Udm::Object& state_f51, const Udm::Object& exec_f5a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_f51.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_f56= CyberComposition::Simulink::State::Cast( state_f51);
		if( false== Uml::IsDerivedFrom( exec_f5a.type(), SFC::Function::meta))
			continue;
		SFC::Function exec_f5f= SFC::Function::Cast( exec_f5a);
		set< CyberComposition::Simulink::Data> datas_f61= state_f56.Data_kind_children();
		for( set< CyberComposition::Simulink::Data>::const_iterator itData_f62= datas_f61.begin(); itData_f62!= datas_f61.end(); ++itData_f62)
		{
			CyberComposition::Simulink::Data currData_f63= *itData_f62;
			set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_f64= currData_f63.TypeBaseRef_kind_children();
			for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_f65= typeBaseRefs_f64.begin(); itTypeBaseRef_f65!= typeBaseRefs_f64.end(); ++itTypeBaseRef_f65)
			{
				CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_f66= *itTypeBaseRef_f65;
				set< SFC::StateLabel> stateLabels_f67= state_f56.src();
				for( set< SFC::StateLabel>::const_iterator itStateLabels_f68= stateLabels_f67.begin(); itStateLabels_f68!= stateLabels_f67.end(); ++itStateLabels_f68)
				{
					SFC::StateLabel currStateLabel_f69= *itStateLabels_f68;
					CyberComposition::Simulink::SF_TypeBase typeBase_f6a= currTypeBaseRef_f66.ref();
					if( !typeBase_f6a)
						continue;
					SFC::DT dT_f6b= typeBase_f6a.dt();
					if( !dT_f6b)
						continue;
					Match currMatch;
					currMatch.state_f6d= state_f56;
					currMatch.exec_f6e= exec_f5f;
					currMatch.stateLabel_f6f= currStateLabel_f69;
					currMatch.data_f70= currData_f63;
					currMatch.typeBaseRef_f71= currTypeBaseRef_f66;
					currMatch.typeBase_f72= typeBase_f6a;
					currMatch.dT_f73= dT_f6b;
					bool Gz_guard= isGuardTrue( currMatch.dT_f73, currMatch.data_f70, currMatch.exec_f6e, currMatch.state_f6d, currMatch.stateLabel_f6f, currMatch.typeBase_f72, currMatch.typeBaseRef_f71);
					if( true== Gz_guard)
						_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void InputArgs_f4a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg newArg_f7b= SFC::Arg::Create( currMatch.exec_f6e);
		SFC::Arg& Arg= newArg_f7b;
		SFC::DT& DT= currMatch.dT_f73;
		CyberComposition::Simulink::Data& Data= currMatch.data_f70;
		SFC::Function& Exec= currMatch.exec_f6e;
		CyberComposition::Simulink::State& State= currMatch.state_f6d;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_f6f;
		CyberComposition::Simulink::SF_TypeBase& TypeBase= currMatch.typeBase_f72;
		CyberComposition::Simulink::TypeBaseRef& TypeBaseRef= currMatch.typeBaseRef_f71;
		{
Arg.RefId() = Data.RefId();
};
		{
std::string name = Data.name();
Arg.name() = name;
Arg.scope() = StateLabel.comment(); /* comment contains the extend state name */
Arg.argIndex() = SFManager::FunctionArgMapManager::get_singleton().getArgNo( Exec, name );
Arg.indexBase() = Data.ArrayFirstIndex();

Exec.argCount() = Exec.argCount() + 1;

SFManager::AddTypedEntityScope( Arg );
};
		newArg_f7b.dt()= currMatch.dT_f73;
	}
}

void FuncOutputArgs_f7f::operator()( const Packets_t& states_f80, const Packets_t& fcns_f82, Packets_t& states_f84, Packets_t& fcns_f85)
{
#ifdef PRINT_INFO
	printLog( "FuncOutputArgs_f7f" );
#endif
	_state_f86= &states_f84;
	_fcn_f87= &fcns_f85;
	_state_f86->insert( _state_f86->end(), states_f80.begin(), states_f80.end());
	_fcn_f87->insert( _fcn_f87->end(), fcns_f82.begin(), fcns_f82.end());
	if( ( !states_f80.empty())&& ( !fcns_f82.empty()))
		callOutputArgs_fbd( states_f80, fcns_f82);
}

void FuncOutputArgs_f7f::callOutputArgs_fbd( const Packets_t& states_f89, const Packets_t& execs_f8b)
{
	OutputArgs_f88 outputArgs_f88;
	outputArgs_f88( states_f89, execs_f8b);
}

void OutputArgs_f88::operator()( const Packets_t& states_f89, const Packets_t& execs_f8b)
{
#ifdef PRINT_INFO
	printLog( "OutputArgs_f88" );
#endif
	RTTGenerator::Instance()->generateRule(253, "OutputArgs");
	processInputPackets( states_f89, execs_f8b);
}

bool OutputArgs_f88::isInputUnique( const Udm::Object& state_f91, const Udm::Object& exec_f9a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_f93= _state_f8d.begin(), itExec_f9c= _exec_f96.begin(); itState_f93!= _state_f8d.end(), itExec_f9c!= _exec_f96.end(); ++itState_f93, ++itExec_f9c)
	{
		if( ( *itState_f93== state_f91)&& ( *itExec_f9c== exec_f9a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_f8d.push_back( state_f91);
		_exec_f96.push_back( exec_f9a);
	}
	return isUnique;
}

bool OutputArgs_f88::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool OutputArgs_f88::isGuardTrue( SFC::DT& DT, CyberComposition::Simulink::Data& Data, SFC::Function& Exec, CyberComposition::Simulink::State& State, SFC::StateLabel& StateLabel, CyberComposition::Simulink::SF_TypeBase& TypeBase, CyberComposition::Simulink::TypeBaseRef& TypeBaseRef)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( Data.Scope() ) == "OUTPUT_DATA";;
	return Gz_guard;
}

void OutputArgs_f88::processInputPackets( const Packets_t& states_f89, const Packets_t& execs_f8b)
{
	for( Packets_t::const_iterator itState_f8e= states_f89.begin(), itExec_f97= execs_f8b.begin(); itState_f8e!= states_f89.end(), itExec_f97!= execs_f8b.end(); ++itState_f8e, ++itExec_f97)
	{
		bool isUnique= isInputUnique( *itState_f8e, *itExec_f97);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_f8e, *itExec_f97);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool OutputArgs_f88::patternMatcher( const Udm::Object& state_f8f, const Udm::Object& exec_f98)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_f8f.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_f94= CyberComposition::Simulink::State::Cast( state_f8f);
		if( false== Uml::IsDerivedFrom( exec_f98.type(), SFC::Function::meta))
			continue;
		SFC::Function exec_f9d= SFC::Function::Cast( exec_f98);
		set< CyberComposition::Simulink::Data> datas_f9f= state_f94.Data_kind_children();
		for( set< CyberComposition::Simulink::Data>::const_iterator itData_fa0= datas_f9f.begin(); itData_fa0!= datas_f9f.end(); ++itData_fa0)
		{
			CyberComposition::Simulink::Data currData_fa1= *itData_fa0;
			set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_fa2= currData_fa1.TypeBaseRef_kind_children();
			for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_fa3= typeBaseRefs_fa2.begin(); itTypeBaseRef_fa3!= typeBaseRefs_fa2.end(); ++itTypeBaseRef_fa3)
			{
				CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_fa4= *itTypeBaseRef_fa3;
				set< SFC::StateLabel> stateLabels_fa5= state_f94.src();
				for( set< SFC::StateLabel>::const_iterator itStateLabels_fa6= stateLabels_fa5.begin(); itStateLabels_fa6!= stateLabels_fa5.end(); ++itStateLabels_fa6)
				{
					SFC::StateLabel currStateLabel_fa7= *itStateLabels_fa6;
					CyberComposition::Simulink::SF_TypeBase typeBase_fa8= currTypeBaseRef_fa4.ref();
					if( !typeBase_fa8)
						continue;
					SFC::DT dT_fa9= typeBase_fa8.dt();
					if( !dT_fa9)
						continue;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_fad;
					if( !isValidBound(boundObjs_fad, state_f94, true))
						continue;
					currMatch.state_fae= state_f94;
					if( !isValidBound(boundObjs_fad, exec_f9d, true))
						continue;
					currMatch.exec_faf= exec_f9d;
					if( !isValidBound(boundObjs_fad, currStateLabel_fa7, false))
						continue;
					currMatch.stateLabel_fb0= currStateLabel_fa7;
					if( !isValidBound(boundObjs_fad, currData_fa1, false))
						continue;
					currMatch.data_fb1= currData_fa1;
					if( !isValidBound(boundObjs_fad, currTypeBaseRef_fa4, false))
						continue;
					currMatch.typeBaseRef_fb2= currTypeBaseRef_fa4;
					if( !isValidBound(boundObjs_fad, typeBase_fa8, false))
						continue;
					currMatch.typeBase_fb3= typeBase_fa8;
					if( !isValidBound(boundObjs_fad, dT_fa9, false))
						continue;
					currMatch.dT_fb4= dT_fa9;
					bool Gz_guard= isGuardTrue( currMatch.dT_fb4, currMatch.data_fb1, currMatch.exec_faf, currMatch.state_fae, currMatch.stateLabel_fb0, currMatch.typeBase_fb3, currMatch.typeBaseRef_fb2);
					if( true== Gz_guard)
						_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void OutputArgs_f88::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg newArg_fbc= SFC::Arg::Create( currMatch.exec_faf);
		SFC::Arg& Arg= newArg_fbc;
		SFC::DT& DT= currMatch.dT_fb4;
		CyberComposition::Simulink::Data& Data= currMatch.data_fb1;
		SFC::Function& Exec= currMatch.exec_faf;
		CyberComposition::Simulink::State& State= currMatch.state_fae;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_fb0;
		CyberComposition::Simulink::SF_TypeBase& TypeBase= currMatch.typeBase_fb3;
		CyberComposition::Simulink::TypeBaseRef& TypeBaseRef= currMatch.typeBaseRef_fb2;
		{
Arg.RefId() = Data.RefId();
};
		{
std::string name = Data.name();
Arg.name() = name;
Arg.scope() = StateLabel.comment(); /* comment contains the extend state name */
Arg.argIndex() = SFManager::FunctionArgMapManager::get_singleton().getArgNo( Exec, name );
Arg.indexBase() = Data.ArrayFirstIndex();
Arg.ptr() = true;

Exec.argCount() = Exec.argCount() + 1;

SFManager::AddTypedEntityScope( Arg );
};
		newArg_fbc.dt()= currMatch.dT_fb4;
	}
}

void FuncLocalVars_fc0::operator()( const Packets_t& states_fc1, const Packets_t& fcns_fc3, Packets_t& states_fc5, Packets_t& fcns_fc6)
{
#ifdef PRINT_INFO
	printLog( "FuncLocalVars_fc0" );
#endif
	_state_fc7= &states_fc5;
	_fcn_fc8= &fcns_fc6;
	if( ( !states_fc1.empty())&& ( !fcns_fc3.empty()))
		callFuncLocalVars_ffe( states_fc1, fcns_fc3);
	_state_fc7->insert( _state_fc7->end(), states_fc1.begin(), states_fc1.end());
	_fcn_fc8->insert( _fcn_fc8->end(), fcns_fc3.begin(), fcns_fc3.end());
}

void FuncLocalVars_fc0::callFuncLocalVars_ffe( const Packets_t& states_fca, const Packets_t& execs_fcc)
{
	FuncLocalVars_fc9 funcLocalVars_fc9;
	funcLocalVars_fc9( states_fca, execs_fcc);
}

void FuncLocalVars_fc9::operator()( const Packets_t& states_fca, const Packets_t& execs_fcc)
{
#ifdef PRINT_INFO
	printLog( "FuncLocalVars_fc9" );
#endif
	RTTGenerator::Instance()->generateRule(276, "FuncLocalVars");
	processInputPackets( states_fca, execs_fcc);
}

bool FuncLocalVars_fc9::isInputUnique( const Udm::Object& state_fd2, const Udm::Object& exec_fdb)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_fd4= _state_fce.begin(), itExec_fdd= _exec_fd7.begin(); itState_fd4!= _state_fce.end(), itExec_fdd!= _exec_fd7.end(); ++itState_fd4, ++itExec_fdd)
	{
		if( ( *itState_fd4== state_fd2)&& ( *itExec_fdd== exec_fdb))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_fce.push_back( state_fd2);
		_exec_fd7.push_back( exec_fdb);
	}
	return isUnique;
}

bool FuncLocalVars_fc9::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool FuncLocalVars_fc9::isGuardTrue( SFC::DT& DT, CyberComposition::Simulink::Data& Data, SFC::Function& Exec, CyberComposition::Simulink::State& State, SFC::StateLabel& StateLabel, CyberComposition::Simulink::SF_TypeBase& TypeBase, CyberComposition::Simulink::TypeBaseRef& TypeBaseRef)
{
	bool Gz_guard= false;
	std::string scope = Data.Scope();
Gz_guard = scope != "INPUT_DATA" && scope != "OUTPUT_DATA";;
	return Gz_guard;
}

void FuncLocalVars_fc9::processInputPackets( const Packets_t& states_fca, const Packets_t& execs_fcc)
{
	for( Packets_t::const_iterator itState_fcf= states_fca.begin(), itExec_fd8= execs_fcc.begin(); itState_fcf!= states_fca.end(), itExec_fd8!= execs_fcc.end(); ++itState_fcf, ++itExec_fd8)
	{
		bool isUnique= isInputUnique( *itState_fcf, *itExec_fd8);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_fcf, *itExec_fd8);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool FuncLocalVars_fc9::patternMatcher( const Udm::Object& state_fd0, const Udm::Object& exec_fd9)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_fd0.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_fd5= CyberComposition::Simulink::State::Cast( state_fd0);
		if( false== Uml::IsDerivedFrom( exec_fd9.type(), SFC::Function::meta))
			continue;
		SFC::Function exec_fde= SFC::Function::Cast( exec_fd9);
		set< CyberComposition::Simulink::Data> datas_fe0= state_fd5.Data_kind_children();
		for( set< CyberComposition::Simulink::Data>::const_iterator itData_fe1= datas_fe0.begin(); itData_fe1!= datas_fe0.end(); ++itData_fe1)
		{
			CyberComposition::Simulink::Data currData_fe2= *itData_fe1;
			set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_fe3= currData_fe2.TypeBaseRef_kind_children();
			for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_fe4= typeBaseRefs_fe3.begin(); itTypeBaseRef_fe4!= typeBaseRefs_fe3.end(); ++itTypeBaseRef_fe4)
			{
				CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_fe5= *itTypeBaseRef_fe4;
				CyberComposition::Simulink::SF_TypeBase typeBase_fe6= currTypeBaseRef_fe5.ref();
				if( !typeBase_fe6)
					continue;
				SFC::DT dT_fe7= typeBase_fe6.dt();
				if( !dT_fe7)
					continue;
				set< SFC::StateLabel> stateLabels_fe8= state_fd5.src();
				for( set< SFC::StateLabel>::const_iterator itStateLabels_fe9= stateLabels_fe8.begin(); itStateLabels_fe9!= stateLabels_fe8.end(); ++itStateLabels_fe9)
				{
					SFC::StateLabel currStateLabel_fea= *itStateLabels_fe9;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_fee;
					if( !isValidBound(boundObjs_fee, state_fd5, true))
						continue;
					currMatch.state_fef= state_fd5;
					if( !isValidBound(boundObjs_fee, exec_fde, true))
						continue;
					currMatch.exec_ff0= exec_fde;
					if( !isValidBound(boundObjs_fee, currStateLabel_fea, false))
						continue;
					currMatch.stateLabel_ff1= currStateLabel_fea;
					if( !isValidBound(boundObjs_fee, currData_fe2, false))
						continue;
					currMatch.data_ff2= currData_fe2;
					if( !isValidBound(boundObjs_fee, currTypeBaseRef_fe5, false))
						continue;
					currMatch.typeBaseRef_ff3= currTypeBaseRef_fe5;
					if( !isValidBound(boundObjs_fee, typeBase_fe6, false))
						continue;
					currMatch.typeBase_ff4= typeBase_fe6;
					if( !isValidBound(boundObjs_fee, dT_fe7, false))
						continue;
					currMatch.dT_ff5= dT_fe7;
					bool Gz_guard= isGuardTrue( currMatch.dT_ff5, currMatch.data_ff2, currMatch.exec_ff0, currMatch.state_fef, currMatch.stateLabel_ff1, currMatch.typeBase_ff4, currMatch.typeBaseRef_ff3);
					if( true== Gz_guard)
						_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void FuncLocalVars_fc9::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newLocalVar_ffd= SFC::LocalVar::Create( currMatch.exec_ff0, SFC::Function::meta_stmnt);
		SFC::DT& DT= currMatch.dT_ff5;
		CyberComposition::Simulink::Data& Data= currMatch.data_ff2;
		SFC::Function& Exec= currMatch.exec_ff0;
		SFC::LocalVar& LocalVar= newLocalVar_ffd;
		CyberComposition::Simulink::State& State= currMatch.state_fef;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_ff1;
		CyberComposition::Simulink::SF_TypeBase& TypeBase= currMatch.typeBase_ff4;
		CyberComposition::Simulink::TypeBaseRef& TypeBaseRef= currMatch.typeBaseRef_ff3;
		{
LocalVar.RefId() = Data.RefId();
};
		{
std::string dataName = Data.Name();
if(dataName.empty())
	dataName = Data.name();
LocalVar.name() = dataName;
LocalVar.scope() = StateLabel.comment(); /* comment contains the extend state name */
LocalVar.initial() = Data.InitialValue();
LocalVar.indexBase() = Data.ArrayFirstIndex();

SFManager::AddTypedEntityScope( LocalVar );
};
		{
__int64 statementCount = Exec.statementCount();
LocalVar.statementIndex() = statementCount++;
Exec.statementCount() = statementCount;
};
		newLocalVar_ffd.dt()= currMatch.dT_ff5;
	}
}

void PopulateGRFSFunction_1010::operator()( const Packets_t& states_1011, const Packets_t& programs_1013, Packets_t& states_1015, Packets_t& programs_1016)
{
#ifdef PRINT_INFO
	printLog( "PopulateGRFSFunction_1010" );
#endif
	_state_1017= &states_1015;
	_program_1018= &programs_1016;
	if( ( !states_1011.empty())&& ( !programs_1013.empty()))
		callCreateGRFuncStateFunction_1048( states_1011, programs_1013);
	_state_1017->insert( _state_1017->end(), states_1011.begin(), states_1011.end());
	_program_1018->insert( _program_1018->end(), programs_1013.begin(), programs_1013.end());
}

void PopulateGRFSFunction_1010::callCreateGRFuncStateFunction_1048( const Packets_t& states_101a, const Packets_t& programs_101d)
{
	Packets_t states_101c;
	Packets_t execs_101f;
	CreateGRFuncStateFunction_1019 createGRFuncStateFunction_1019;
	createGRFuncStateFunction_1019( states_101a, programs_101d, states_101c, execs_101f);
	if( ( !states_101c.empty())&& ( !execs_101f.empty()))
		callFuncArgsAndVars_104b( states_101c, execs_101f);
}

void PopulateGRFSFunction_1010::callFuncArgsAndVars_104b( const Packets_t& states_f39, const Packets_t& fcns_f3b)
{
	Packets_t states_f3d;
	Packets_t fcns_f3e;
	FuncArgsAndVars_f38 funcArgsAndVars_f38;
	funcArgsAndVars_f38( states_f39, fcns_f3b, states_f3d, fcns_f3e);
}

void CreateGRFuncStateFunction_1019::operator()( const Packets_t& states_101a, const Packets_t& programs_101d, Packets_t& states_101c, Packets_t& execs_101f)
{
#ifdef PRINT_INFO
	printLog( "CreateGRFuncStateFunction_1019" );
#endif
	RTTGenerator::Instance()->generateRule(203, "CreateGRFuncStateFunction");
	_state_1020= &states_101c;
	_exec_1021= &execs_101f;
	processInputPackets( states_101a, programs_101d);
}

bool CreateGRFuncStateFunction_1019::isInputUnique( const Udm::Object& state_1026, const Udm::Object& program_102f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1028= _state_1022.begin(), itProgram_1031= _program_102b.begin(); itState_1028!= _state_1022.end(), itProgram_1031!= _program_102b.end(); ++itState_1028, ++itProgram_1031)
	{
		if( ( *itState_1028== state_1026)&& ( *itProgram_1031== program_102f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1022.push_back( state_1026);
		_program_102b.push_back( program_102f);
	}
	return isUnique;
}

bool CreateGRFuncStateFunction_1019::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool CreateGRFuncStateFunction_1019::isGuardTrue( SFC::Program& Program, CyberComposition::Simulink::State& State, SFC::StateLabel& StateLabel)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( State.Decomposition() ) == "FUNC_STATE" &&
 static_cast< std::string >( State.Order() ) == "-1";;
	return Gz_guard;
}

void CreateGRFuncStateFunction_1019::processInputPackets( const Packets_t& states_101a, const Packets_t& programs_101d)
{
	for( Packets_t::const_iterator itState_1023= states_101a.begin(), itProgram_102c= programs_101d.begin(); itState_1023!= states_101a.end(), itProgram_102c!= programs_101d.end(); ++itState_1023, ++itProgram_102c)
	{
		bool isUnique= isInputUnique( *itState_1023, *itProgram_102c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1023, *itProgram_102c);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateGRFuncStateFunction_1019::patternMatcher( const Udm::Object& state_1024, const Udm::Object& program_102d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1024.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1029= CyberComposition::Simulink::State::Cast( state_1024);
		if( false== Uml::IsDerivedFrom( program_102d.type(), SFC::Program::meta))
			continue;
		SFC::Program program_1032= SFC::Program::Cast( program_102d);
		set< SFC::StateLabel> stateLabels_1034= state_1029.src();
		for( set< SFC::StateLabel>::const_iterator itStateLabels_1035= stateLabels_1034.begin(); itStateLabels_1035!= stateLabels_1034.end(); ++itStateLabels_1035)
		{
			SFC::StateLabel currStateLabel_1036= *itStateLabels_1035;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_103a;
			if( !isValidBound(boundObjs_103a, state_1029, true))
				continue;
			currMatch.state_103b= state_1029;
			if( !isValidBound(boundObjs_103a, program_1032, true))
				continue;
			currMatch.program_103c= program_1032;
			if( !isValidBound(boundObjs_103a, currStateLabel_1036, false))
				continue;
			currMatch.stateLabel_103d= currStateLabel_1036;
			bool Gz_guard= isGuardTrue( currMatch.program_103c, currMatch.state_103b, currMatch.stateLabel_103d);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateGRFuncStateFunction_1019::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function newExec_1041= SFC::Function::Create( currMatch.program_103c, SFC::Program::meta_stmnt);
		SFC::LocalVar newExecTCVar_1042= SFC::LocalVar::Create( newExec_1041, SFC::Function::meta_stmnt);
		SFC::LocalVar newExecHTPVar_1043= SFC::LocalVar::Create( newExec_1041, SFC::Function::meta_stmnt);
		SFC::Function& Exec= newExec_1041;
		SFC::LocalVar& ExecHTPVar= newExecHTPVar_1043;
		SFC::LocalVar& ExecTCVar= newExecTCVar_1042;
		SFC::Program& Program= currMatch.program_103c;
		CyberComposition::Simulink::State& State= currMatch.state_103b;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_103d;
		{
Exec.RefId() = ExecHTPVar.RefId() = ExecTCVar.RefId() = State.RefId();
};
		{
ExecHTPVar.name() = "_HTPVar_";
ExecHTPVar.dt() = SFCTypesManager::getSingleton().getBasicType( "int32" );
ExecTCVar.name() = "_TCVar_";
ExecTCVar.dt() = SFCTypesManager::getSingleton().getBasicType( "int32" );
};
		{
__int64 statementCount = Exec.statementCount();
ExecTCVar.statementIndex() = statementCount++;
ExecHTPVar.statementIndex() = statementCount++;
Exec.statementCount() = statementCount;
};
		{
Exec.name() = State.name();
Exec.scope() = StateLabel.comment();

SFManager::FunctionArgMapManager::get_singleton().parseFunctionSpec( Exec, State.EnterAction() );

SFManager::AddTypedEntityScope( Exec );
};
		{
__int64 statementCount = Program.statementCount();
Exec.statementIndex() = statementCount++;
Program.statementCount() = statementCount;
};
		newExec_1041.execSt()+= currMatch.state_103b;
		outputAppender( currMatch.state_103b, newExec_1041);
	}
}

void CreateGRFuncStateFunction_1019::outputAppender( const CyberComposition::Simulink::State& state_1044, const SFC::Function& exec_1046)
{
	_state_1020->push_back( state_1044);
	_exec_1021->push_back( exec_1046);
}

void PopulateFunctions_1057::operator()( const Packets_t& states_1058, const Packets_t& programs_105a, Packets_t& states_105c, Packets_t& programs_105d)
{
#ifdef PRINT_INFO
	printLog( "PopulateFunctions_1057" );
#endif
	_state_105e= &states_105c;
	_program_105f= &programs_105d;
	if( ( !states_1058.empty())&& ( !programs_105a.empty()))
		callNoFunctionStates_1f41( states_1058, programs_105a);
	_state_105e->insert( _state_105e->end(), states_1058.begin(), states_1058.end());
	_program_105f->insert( _program_105f->end(), programs_105a.begin(), programs_105a.end());
}

void PopulateFunctions_1057::callNoFunctionStates_1f41( const Packets_t& states_1309, const Packets_t& programs_130b)
{
	Packets_t states_130d;
	Packets_t programs_130e;
	NoFunctionStates_1308 noFunctionStates_1308;
	noFunctionStates_1308( states_1309, programs_130b, states_130d, programs_130e);
	if( ( !states_130d.empty())&& ( !programs_130e.empty()))
		callPopulateEnterFunction_1f44( states_130d, programs_130e);
}

void PopulateFunctions_1057::callPopulateEnterFunction_1f44( const Packets_t& states_1c16, const Packets_t& programs_1c18)
{
	Packets_t states_1c1a;
	Packets_t programs_1c1b;
	PopulateEnterFunction_1c15 populateEnterFunction_1c15;
	populateEnterFunction_1c15( states_1c16, programs_1c18, states_1c1a, programs_1c1b);
	if( ( !states_1c1a.empty())&& ( !programs_1c1b.empty()))
		callPopulateExecFunction_1f47( states_1c1a, programs_1c1b);
}

void PopulateFunctions_1057::callPopulateExecFunction_1f47( const Packets_t& states_1347, const Packets_t& programs_1349)
{
	Packets_t states_134b;
	Packets_t programs_134c;
	PopulateExecFunction_1346 populateExecFunction_1346;
	populateExecFunction_1346( states_1347, programs_1349, states_134b, programs_134c);
	if( ( !states_134b.empty())&& ( !programs_134c.empty()))
		callPopulateExitFunction_1f4a( states_134b, programs_134c);
}

void PopulateFunctions_1057::callPopulateExitFunction_1f4a( const Packets_t& states_19ef, const Packets_t& programs_19f1)
{
	Packets_t states_19f3;
	Packets_t programs_19f4;
	PopulateExitFunction_19ee populateExitFunction_19ee;
	populateExitFunction_19ee( states_19ef, programs_19f1, states_19f3, programs_19f4);
	if( ( !states_19f3.empty())&& ( !programs_19f4.empty()))
		callPopulateStatusFunction_1f4d( states_19f3, programs_19f4);
}

void PopulateFunctions_1057::callPopulateStatusFunction_1f4d( const Packets_t& states_1061, const Packets_t& programs_1063)
{
	Packets_t states_1065;
	Packets_t programs_1066;
	PopulateStatusFunction_1060 populateStatusFunction_1060;
	populateStatusFunction_1060( states_1061, programs_1063, states_1065, programs_1066);
	if( ( !states_1065.empty())&& ( !programs_1066.empty()))
		callGetSubStates_1f50( states_1065, programs_1066);
}

void PopulateFunctions_1057::callGetSubStates_1f50( const Packets_t& states_c8c, const Packets_t& parStmnts_c8f)
{
	Packets_t subStates_c8e;
	Packets_t parStmnts_c91;
	GetSubStates_c8b getSubStates_c8b;
	getSubStates_c8b( states_c8c, parStmnts_c8f, subStates_c8e, parStmnts_c91);
	if( ( !subStates_c8e.empty())&& ( !parStmnts_c91.empty()))
		callNoFunctionStates_1f41( subStates_c8e, parStmnts_c91);
}

void PopulateStatusFunction_1060::operator()( const Packets_t& states_1061, const Packets_t& programs_1063, Packets_t& states_1065, Packets_t& programs_1066)
{
#ifdef PRINT_INFO
	printLog( "PopulateStatusFunction_1060" );
#endif
	_state_1067= &states_1065;
	_program_1068= &programs_1066;
	_state_1067->insert( _state_1067->end(), states_1061.begin(), states_1061.end());
	_program_1068->insert( _program_1068->end(), programs_1063.begin(), programs_1063.end());
	if( ( !states_1061.empty()))
		callGetStatusFunction_12ea( states_1061);
}

void PopulateStatusFunction_1060::callGetStatusFunction_12ea( const Packets_t& states_12c3)
{
	Packets_t states_12c5;
	Packets_t statuss_12c6;
	GetStatusFunction_12c2 getStatusFunction_12c2;
	getStatusFunction_12c2( states_12c3, states_12c5, statuss_12c6);
	if( ( !states_12c5.empty())&& ( !statuss_12c6.empty()))
		callHasChildren_12ec( states_12c5, statuss_12c6);
}

void PopulateStatusFunction_1060::callHasChildren_12ec( const Packets_t& states_1089, const Packets_t& statuss_108b)
{
	Packets_t states_108d;
	Packets_t statuss_108e;
	Packets_t states_108f;
	Packets_t statuss_1090;
	HasChildren_1088 hasChildren_1088;
	hasChildren_1088( states_1089, statuss_108b, states_108d, statuss_108e, states_108f, statuss_1090);
	if( ( !states_108f.empty())&& ( !statuss_1090.empty()))
		callElimState_12ef( states_108f, statuss_1090);
	if( ( !states_108d.empty())&& ( !statuss_108e.empty()))
		callnewIndent_12f2( states_108d, statuss_108e);
}

void PopulateStatusFunction_1060::callElimState_12ef( const Packets_t& states_106a, const Packets_t& statuss_106c)
{
	Packets_t statuss_106e;
	ElimState_1069 elimState_1069;
	elimState_1069( states_106a, statuss_106c, statuss_106e);
	if( ( !statuss_106e.empty()))
		callReturnValue_12f5( statuss_106e);
}

void PopulateStatusFunction_1060::callnewIndent_12f2( const Packets_t& states_10f5, const Packets_t& statuss_10f8)
{
	Packets_t states_10f7;
	Packets_t statuss_10fa;
	Packets_t stateVars_10fb;
	NewIndent_10f4 newIndent_10f4;
	newIndent_10f4( states_10f5, statuss_10f8, states_10f7, statuss_10fa, stateVars_10fb);
	if( ( !states_10f7.empty())&& ( !statuss_10fa.empty())&& ( !stateVars_10fb.empty()))
		callDecompTest_12f7( states_10f7, statuss_10fa, stateVars_10fb);
}

void PopulateStatusFunction_1060::callReturnValue_12f5( const Packets_t& statuss_1130)
{
	ReturnValue_112f returnValue_112f;
	returnValue_112f( statuss_1130);
}

void PopulateStatusFunction_1060::callDecompTest_12f7( const Packets_t& states_11ae, const Packets_t& statuss_11b0, const Packets_t& svs_11b2)
{
	Packets_t states_11b4;
	Packets_t statuss_11b5;
	Packets_t svs_11b6;
	Packets_t states_11b7;
	Packets_t statuss_11b8;
	Packets_t svs_11b9;
	DecompTest_11ad decompTest_11ad;
	decompTest_11ad( states_11ae, statuss_11b0, svs_11b2, states_11b4, statuss_11b5, svs_11b6, states_11b7, statuss_11b8, svs_11b9);
	if( ( !states_11b4.empty())&& ( !statuss_11b5.empty())&& ( !svs_11b6.empty()))
		callGetChildStates_12fb( states_11b4, statuss_11b5, svs_11b6);
	if( ( !states_11b7.empty())&& ( !statuss_11b8.empty())&& ( !svs_11b9.empty()))
		callCreateConditionalGroup_12ff( states_11b7, statuss_11b8, svs_11b9);
}

void PopulateStatusFunction_1060::callGetChildStates_12fb( const Packets_t& states_1250, const Packets_t& compoundStatements_1254, const Packets_t& stateVars_1257)
{
	Packets_t states_1252;
	Packets_t childStates_1253;
	Packets_t compoundStatements_1256;
	Packets_t stateVars_1259;
	GetChildStates_124f getChildStates_124f;
	getChildStates_124f( states_1250, compoundStatements_1254, stateVars_1257, states_1252, childStates_1253, compoundStatements_1256, stateVars_1259);
	if( ( !states_1252.empty())&& ( !childStates_1253.empty())&& ( !compoundStatements_1256.empty())&& ( !stateVars_1259.empty()))
		callCreateConditionals_1303( states_1252, childStates_1253, compoundStatements_1256, stateVars_1259);
}

void PopulateStatusFunction_1060::callCreateConditionalGroup_12ff( const Packets_t& states_128d, const Packets_t& statuss_1290, const Packets_t& stateVars_1293)
{
	Packets_t states_128f;
	Packets_t conditionalGroups_1292;
	Packets_t stateVars_1295;
	CreateConditionalGroup_128c createConditionalGroup_128c;
	createConditionalGroup_128c( states_128d, statuss_1290, stateVars_1293, states_128f, conditionalGroups_1292, stateVars_1295);
	if( ( !states_128f.empty())&& ( !conditionalGroups_1292.empty())&& ( !stateVars_1295.empty()))
		callGetChildStates_12fb( states_128f, conditionalGroups_1292, stateVars_1295);
}

void PopulateStatusFunction_1060::callCreateConditionals_1303( const Packets_t& states_1149, const Packets_t& childStates_114c, const Packets_t& compoundStatements_114e, const Packets_t& stateVars_1150)
{
	Packets_t statuss_114b;
	CreateConditionals_1148 createConditionals_1148;
	createConditionals_1148( states_1149, childStates_114c, compoundStatements_114e, stateVars_1150, statuss_114b);
	if( ( !statuss_114b.empty()))
		callReturnValue_12f5( statuss_114b);
}

void ElimState_1069::operator()( const Packets_t& states_106a, const Packets_t& statuss_106c, Packets_t& statuss_106e)
{
#ifdef PRINT_INFO
	printLog( "ElimState_1069" );
#endif
	RTTGenerator::Instance()->generateRule(305, "ElimState");
	_status_106f= &statuss_106e;
	processInputPackets( states_106a, statuss_106c);
	forwardInputs( );
}

bool ElimState_1069::isInputUnique( const Udm::Object& state_1074, const Udm::Object& status_107d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1076= _state_1070.begin(), itStatus_107f= _status_1079.begin(); itState_1076!= _state_1070.end(), itStatus_107f!= _status_1079.end(); ++itState_1076, ++itStatus_107f)
	{
		if( ( *itState_1076== state_1074)&& ( *itStatus_107f== status_107d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1070.push_back( state_1074);
		_status_1079.push_back( status_107d);
	}
	return isUnique;
}

bool ElimState_1069::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void ElimState_1069::processInputPackets( const Packets_t& states_106a, const Packets_t& statuss_106c)
{
	for( Packets_t::const_iterator itState_1071= states_106a.begin(), itStatus_107a= statuss_106c.begin(); itState_1071!= states_106a.end(), itStatus_107a!= statuss_106c.end(); ++itState_1071, ++itStatus_107a)
	{
		bool isUnique= isInputUnique( *itState_1071, *itStatus_107a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1071, *itStatus_107a);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ElimState_1069::patternMatcher( const Udm::Object& state_1072, const Udm::Object& status_107b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1072.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1077= CyberComposition::Simulink::State::Cast( state_1072);
		if( false== Uml::IsDerivedFrom( status_107b.type(), SFC::Function::meta))
			continue;
		SFC::Function status_1080= SFC::Function::Cast( status_107b);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1085;
		if( !isValidBound(boundObjs_1085, state_1077, true))
			continue;
		currMatch.state_1086= state_1077;
		if( !isValidBound(boundObjs_1085, status_1080, true))
			continue;
		currMatch.status_1087= status_1080;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void ElimState_1069::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
	}
}

void ElimState_1069::forwardInputs()
{
	*_status_106f= _status_1079;
}

void HasChildren_1088::operator()( const Packets_t& states_1089, const Packets_t& statuss_108b, Packets_t& states_108d, Packets_t& statuss_108e, Packets_t& states_108f, Packets_t& statuss_1090)
{
#ifdef PRINT_INFO
	printLog( "HasChildren_1088" );
#endif
	_state_1091= &states_108d;
	_status_1092= &statuss_108e;
	_state_1093= &states_108f;
	_status_1094= &statuss_1090;
	for( Packets_t::const_iterator itstate_1096= states_1089.begin(), itstatus_109d= statuss_108b.begin(); itstate_1096!= states_1089.end(), itstatus_109d!= statuss_108b.end(); ++itstate_1096, ++itstatus_109d)
	{
		bool isUnique= isInputUnique( *itstate_1096, *itstatus_109d);
		if( !isUnique)
			continue;
		Packets_t onestate_109a( 1, *itstate_1096);
		Packets_t onestatus_10a1( 1, *itstatus_109d);
		executeOne( onestate_109a, onestatus_10a1);
	}
}

void HasChildren_1088::executeOne( const Packets_t& states_1089, const Packets_t& statuss_108b)
{
	Packets_t states_10a6;
	Packets_t statuss_10a9;
	HasChildren_10a3 hasChildren_10a3;
	bool isMatchHasChildren_10a3= hasChildren_10a3( states_1089, statuss_108b, states_10a6, statuss_10a9);
	_state_1091->insert( _state_1091->end(), states_10a6.begin(), states_10a6.end());
	_status_1092->insert( _status_1092->end(), statuss_10a9.begin(), statuss_10a9.end());
	if( isMatchHasChildren_10a3)
		return;
	Packets_t states_10d2;
	Packets_t statuss_10d5;
	NoChildren_10cf noChildren_10cf;
	bool isMatchNoChildren_10cf= noChildren_10cf( states_1089, statuss_108b, states_10d2, statuss_10d5);
	_state_1093->insert( _state_1093->end(), states_10d2.begin(), states_10d2.end());
	_status_1094->insert( _status_1094->end(), statuss_10d5.begin(), statuss_10d5.end());
	if( isMatchNoChildren_10cf)
		return;
}

bool HasChildren_1088::isInputUnique( const Udm::Object& state_1097, const Udm::Object& status_109e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_1099= _state_1095.begin(), itstatus_10a0= _status_109c.begin(); itstate_1099!= _state_1095.end(), itstatus_10a0!= _status_109c.end(); ++itstate_1099, ++itstatus_10a0)
	{
		if( ( *itstate_1099== state_1097)&& ( *itstatus_10a0== status_109e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1095.push_back( state_1097);
		_status_109c.push_back( status_109e);
	}
	return isUnique;
}

bool HasChildren_10a3::operator()( const Packets_t& states_10a4, const Packets_t& statuss_10a7, Packets_t& states_10a6, Packets_t& statuss_10a9)
{
#ifdef PRINT_INFO
	printLog( "HasChildren_10a3" );
#endif
	_state_10aa= &states_10a6;
	_status_10ab= &statuss_10a9;
	processInputPackets( states_10a4, statuss_10a7);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasChildren_10a3::isInputUnique( const Udm::Object& state_10b0, const Udm::Object& status_10b9)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_10b2= _state_10ac.begin(), itStatus_10bb= _status_10b5.begin(); itState_10b2!= _state_10ac.end(), itStatus_10bb!= _status_10b5.end(); ++itState_10b2, ++itStatus_10bb)
	{
		if( ( *itState_10b2== state_10b0)&& ( *itStatus_10bb== status_10b9))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_10ac.push_back( state_10b0);
		_status_10b5.push_back( status_10b9);
	}
	return isUnique;
}

bool HasChildren_10a3::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool HasChildren_10a3::isGuardTrue( CyberComposition::Simulink::State& ChildState, CyberComposition::Simulink::State& State, SFC::Function& Status)
{
	bool Gz_guard= false;
	return static_cast< std::string >( ChildState.Decomposition() ) != "FUNC_STATE";;
	return Gz_guard;
}

void HasChildren_10a3::processInputPackets( const Packets_t& states_10a4, const Packets_t& statuss_10a7)
{
	for( Packets_t::const_iterator itState_10ad= states_10a4.begin(), itStatus_10b6= statuss_10a7.begin(); itState_10ad!= states_10a4.end(), itStatus_10b6!= statuss_10a7.end(); ++itState_10ad, ++itStatus_10b6)
	{
		bool isUnique= isInputUnique( *itState_10ad, *itStatus_10b6);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_10ad, *itStatus_10b6);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_10c5, currMatch.status_10c6);
	}
}

bool HasChildren_10a3::patternMatcher( const Udm::Object& state_10ae, const Udm::Object& status_10b7)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_10ae.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_10b3= CyberComposition::Simulink::State::Cast( state_10ae);
		if( false== Uml::IsDerivedFrom( status_10b7.type(), SFC::Function::meta))
			continue;
		SFC::Function status_10bc= SFC::Function::Cast( status_10b7);
		set< CyberComposition::Simulink::State> childStates_10be= state_10b3.State_kind_children();
		for( set< CyberComposition::Simulink::State>::const_iterator itChildState_10bf= childStates_10be.begin(); itChildState_10bf!= childStates_10be.end(); ++itChildState_10bf)
		{
			CyberComposition::Simulink::State currChildState_10c0= *itChildState_10bf;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_10c4;
			if( !isValidBound(boundObjs_10c4, state_10b3, true))
				continue;
			currMatch.state_10c5= state_10b3;
			if( !isValidBound(boundObjs_10c4, status_10bc, true))
				continue;
			currMatch.status_10c6= status_10bc;
			if( !isValidBound(boundObjs_10c4, currChildState_10c0, false))
				continue;
			currMatch.childState_10c7= currChildState_10c0;
			bool Gz_guard= isGuardTrue( currMatch.childState_10c7, currMatch.state_10c5, currMatch.status_10c6);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void HasChildren_10a3::outputAppender( const CyberComposition::Simulink::State& state_10cb, const SFC::Function& status_10cd)
{
	_state_10aa->push_back( state_10cb);
	_status_10ab->push_back( status_10cd);
}

bool NoChildren_10cf::operator()( const Packets_t& states_10d0, const Packets_t& statuss_10d3, Packets_t& states_10d2, Packets_t& statuss_10d5)
{
#ifdef PRINT_INFO
	printLog( "NoChildren_10cf" );
#endif
	_state_10d6= &states_10d2;
	_status_10d7= &statuss_10d5;
	processInputPackets( states_10d0, statuss_10d3);
	if( false== _matches.empty())
		return true;
	return false;
}

bool NoChildren_10cf::isInputUnique( const Udm::Object& state_10dc, const Udm::Object& status_10e5)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_10de= _state_10d8.begin(), itStatus_10e7= _status_10e1.begin(); itState_10de!= _state_10d8.end(), itStatus_10e7!= _status_10e1.end(); ++itState_10de, ++itStatus_10e7)
	{
		if( ( *itState_10de== state_10dc)&& ( *itStatus_10e7== status_10e5))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_10d8.push_back( state_10dc);
		_status_10e1.push_back( status_10e5);
	}
	return isUnique;
}

bool NoChildren_10cf::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void NoChildren_10cf::processInputPackets( const Packets_t& states_10d0, const Packets_t& statuss_10d3)
{
	for( Packets_t::const_iterator itState_10d9= states_10d0.begin(), itStatus_10e2= statuss_10d3.begin(); itState_10d9!= states_10d0.end(), itStatus_10e2!= statuss_10d3.end(); ++itState_10d9, ++itStatus_10e2)
	{
		bool isUnique= isInputUnique( *itState_10d9, *itStatus_10e2);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_10d9, *itStatus_10e2);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_10ee, currMatch.status_10ef);
	}
}

bool NoChildren_10cf::patternMatcher( const Udm::Object& state_10da, const Udm::Object& status_10e3)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_10da.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_10df= CyberComposition::Simulink::State::Cast( state_10da);
		if( false== Uml::IsDerivedFrom( status_10e3.type(), SFC::Function::meta))
			continue;
		SFC::Function status_10e8= SFC::Function::Cast( status_10e3);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_10ed;
		if( !isValidBound(boundObjs_10ed, state_10df, true))
			continue;
		currMatch.state_10ee= state_10df;
		if( !isValidBound(boundObjs_10ed, status_10e8, true))
			continue;
		currMatch.status_10ef= status_10e8;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void NoChildren_10cf::outputAppender( const CyberComposition::Simulink::State& state_10f0, const SFC::Function& status_10f2)
{
	_state_10d6->push_back( state_10f0);
	_status_10d7->push_back( status_10f2);
}

void NewIndent_10f4::operator()( const Packets_t& states_10f5, const Packets_t& statuss_10f8, Packets_t& states_10f7, Packets_t& statuss_10fa, Packets_t& stateVars_10fb)
{
#ifdef PRINT_INFO
	printLog( "NewIndent_10f4" );
#endif
	RTTGenerator::Instance()->generateRule(323, "newIndent");
	_state_10fc= &states_10f7;
	_status_10fd= &statuss_10fa;
	_stateVar_10fe= &stateVars_10fb;
	processInputPackets( states_10f5, statuss_10f8);
}

bool NewIndent_10f4::isInputUnique( const Udm::Object& state_1103, const Udm::Object& status_110c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1105= _state_10ff.begin(), itStatus_110e= _status_1108.begin(); itState_1105!= _state_10ff.end(), itStatus_110e!= _status_1108.end(); ++itState_1105, ++itStatus_110e)
	{
		if( ( *itState_1105== state_1103)&& ( *itStatus_110e== status_110c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_10ff.push_back( state_1103);
		_status_1108.push_back( status_110c);
	}
	return isUnique;
}

bool NewIndent_10f4::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void NewIndent_10f4::processInputPackets( const Packets_t& states_10f5, const Packets_t& statuss_10f8)
{
	for( Packets_t::const_iterator itState_1100= states_10f5.begin(), itStatus_1109= statuss_10f8.begin(); itState_1100!= states_10f5.end(), itStatus_1109!= statuss_10f8.end(); ++itState_1100, ++itStatus_1109)
	{
		bool isUnique= isInputUnique( *itState_1100, *itStatus_1109);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1100, *itStatus_1109);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool NewIndent_10f4::patternMatcher( const Udm::Object& state_1101, const Udm::Object& status_110a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1101.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1106= CyberComposition::Simulink::State::Cast( state_1101);
		if( false== Uml::IsDerivedFrom( status_110a.type(), SFC::Function::meta))
			continue;
		SFC::Function status_110f= SFC::Function::Cast( status_110a);
		Udm::Object statusParent_1111= status_110f.container();
		if( false== Uml::IsDerivedFrom( statusParent_1111.type(), SFC::Program::meta))
			continue;
		SFC::Program programStatus_1112= SFC::Program::Cast( statusParent_1111);
		set< SFC::Arg> args_1113= status_110f.Arg_kind_children();
		for( set< SFC::Arg>::const_iterator itArg_1114= args_1113.begin(); itArg_1114!= args_1113.end(); ++itArg_1114)
		{
			SFC::Arg currArg_1115= *itArg_1114;
			set< SFC::StateVar> stateVars_1116= programStatus_1112.StateVar_kind_children();
			for( set< SFC::StateVar>::const_iterator itStateVar_1117= stateVars_1116.begin(); itStateVar_1117!= stateVars_1116.end(); ++itStateVar_1117)
			{
				SFC::StateVar currStateVar_1118= *itStateVar_1117;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_111c;
				if( !isValidBound(boundObjs_111c, state_1106, true))
					continue;
				currMatch.state_111d= state_1106;
				if( !isValidBound(boundObjs_111c, status_110f, true))
					continue;
				currMatch.status_111e= status_110f;
				if( !isValidBound(boundObjs_111c, currArg_1115, false))
					continue;
				currMatch.arg_111f= currArg_1115;
				if( !isValidBound(boundObjs_111c, programStatus_1112, false))
					continue;
				currMatch.program_1120= programStatus_1112;
				if( !isValidBound(boundObjs_111c, currStateVar_1118, false))
					continue;
				currMatch.stateVar_1121= currStateVar_1118;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void NewIndent_10f4::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newnewIndent_1122= SFC::LocalVar::Create( currMatch.status_111e, SFC::Function::meta_stmnt);
		SFC::UserCode newnewIndentAssign_1123= SFC::UserCode::Create( currMatch.status_111e, SFC::Function::meta_stmnt);
		SFC::BinaryExprs newAssign_1124= SFC::BinaryExprs::Create( newnewIndentAssign_1123, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newArgDeclRef4_1125= SFC::ArgDeclRef::Create( newAssign_1124, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newPlus_1126= SFC::BinaryExprs::Create( newAssign_1124, SFC::BinaryExprs::meta_rightexpr);
		SFC::Str newStr_1127= SFC::Str::Create( newPlus_1126, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef3_1128= SFC::ArgDeclRef::Create( newPlus_1126, SFC::BinaryExprs::meta_leftexpr);
		SFC::Arg& Arg= currMatch.arg_111f;
		SFC::ArgDeclRef& ArgDeclRef3= newArgDeclRef3_1128;
		SFC::ArgDeclRef& ArgDeclRef4= newArgDeclRef4_1125;
		SFC::BinaryExprs& Assign= newAssign_1124;
		SFC::BinaryExprs& Plus= newPlus_1126;
		SFC::Program& Program= currMatch.program_1120;
		CyberComposition::Simulink::State& State= currMatch.state_111d;
		SFC::StateVar& StateVar= currMatch.stateVar_1121;
		SFC::Function& Status= currMatch.status_111e;
		SFC::Str& Str= newStr_1127;
		SFC::LocalVar& newIndent= newnewIndent_1122;
		SFC::UserCode& newIndentAssign= newnewIndentAssign_1123;
		{
newIndentAssign.RefId() = newIndent.RefId() = Status.RefId();
};
		{
Str.val() = "\\t";
};
		{
Plus.op() = "+";
};
		{
newIndent.name() = "newIndent";
newIndent.dt() = SFCTypesManager::getSingleton().getBasicType( "string" );
};
		{
Assign.op() = "=";
};
		{
__int64 statementCount = Status.statementCount();
newIndent.statementIndex() = statementCount++;
newIndentAssign.statementIndex() = statementCount++;
Status.statementCount() = statementCount;
};
		newArgDeclRef3_1128.argdecl()= currMatch.arg_111f;
		newArgDeclRef4_1125.argdecl()= newnewIndent_1122;
		outputAppender( currMatch.state_111d, currMatch.status_111e, currMatch.stateVar_1121);
	}
}

void NewIndent_10f4::outputAppender( const CyberComposition::Simulink::State& state_1129, const SFC::Function& status_112b, const SFC::StateVar& stateVar_112d)
{
	_state_10fc->push_back( state_1129);
	_status_10fd->push_back( status_112b);
	_stateVar_10fe->push_back( stateVar_112d);
}

void ReturnValue_112f::operator()( const Packets_t& statuss_1130)
{
#ifdef PRINT_INFO
	printLog( "ReturnValue_112f" );
#endif
	RTTGenerator::Instance()->generateRule(354, "ReturnValue");
	processInputPackets( statuss_1130);
}

bool ReturnValue_112f::isInputUnique( const Udm::Object& status_1136)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itStatus_1138= _status_1132.begin(); itStatus_1138!= _status_1132.end(); ++itStatus_1138)
	{
		if( ( *itStatus_1138== status_1136))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_status_1132.push_back( status_1136);
	return isUnique;
}

bool ReturnValue_112f::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool ReturnValue_112f::isGuardTrue( SFC::Function& Status, SFC::LocalVar& retval)
{
	bool Gz_guard= false;
	return static_cast< std::string >( retval.name() ) == "retval";;
	return Gz_guard;
}

void ReturnValue_112f::processInputPackets( const Packets_t& statuss_1130)
{
	for( Packets_t::const_iterator itStatus_1133= statuss_1130.begin(); itStatus_1133!= statuss_1130.end(); ++itStatus_1133)
	{
		bool isUnique= isInputUnique( *itStatus_1133);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itStatus_1133);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ReturnValue_112f::patternMatcher( const Udm::Object& status_1134)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( status_1134.type(), SFC::Function::meta))
			continue;
		SFC::Function status_1139= SFC::Function::Cast( status_1134);
		set< SFC::LocalVar> retvals_113b= status_1139.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itretval_113c= retvals_113b.begin(); itretval_113c!= retvals_113b.end(); ++itretval_113c)
		{
			SFC::LocalVar currretval_113d= *itretval_113c;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1141;
			if( !isValidBound(boundObjs_1141, status_1139, true))
				continue;
			currMatch.status_1142= status_1139;
			if( !isValidBound(boundObjs_1141, currretval_113d, false))
				continue;
			currMatch.retval_1143= currretval_113d;
			bool Gz_guard= isGuardTrue( currMatch.status_1142, currMatch.retval_1143);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void ReturnValue_112f::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Return newReturn_1146= SFC::Return::Create( currMatch.status_1142, SFC::Function::meta_stmnt);
		SFC::ArgDeclRef newArgDeclRef_1147= SFC::ArgDeclRef::Create( newReturn_1146, SFC::Return::meta_retexpr);
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_1147;
		SFC::Return& Return= newReturn_1146;
		SFC::Function& Status= currMatch.status_1142;
		SFC::LocalVar& retval= currMatch.retval_1143;
		{
Return.RefId() = Status.RefId();
};
		{
__int64 statementCount = Status.statementCount();
Return.statementIndex() = statementCount++;
Status.statementCount() = statementCount;
};
		newArgDeclRef_1147.argdecl()= currMatch.retval_1143;
	}
}

void CreateConditionals_1148::operator()( const Packets_t& states_1149, const Packets_t& childStates_114c, const Packets_t& compoundStatements_114e, const Packets_t& stateVars_1150, Packets_t& statuss_114b)
{
#ifdef PRINT_INFO
	printLog( "CreateConditionals_1148" );
#endif
	RTTGenerator::Instance()->generateRule(365, "CreateConditionals");
	_status_1152= &statuss_114b;
	processInputPackets( states_1149, childStates_114c, compoundStatements_114e, stateVars_1150);
}

bool CreateConditionals_1148::isInputUnique( const Udm::Object& state_1157, const Udm::Object& childState_1160, const Udm::Object& compoundStatement_1169, const Udm::Object& stateVar_1172)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1159= _state_1153.begin(), itChildState_1162= _childState_115c.begin(), itCompoundStatement_116b= _compoundStatement_1165.begin(), itStateVar_1174= _stateVar_116e.begin(); itState_1159!= _state_1153.end(), itChildState_1162!= _childState_115c.end(), itCompoundStatement_116b!= _compoundStatement_1165.end(), itStateVar_1174!= _stateVar_116e.end(); ++itState_1159, ++itChildState_1162, ++itCompoundStatement_116b, ++itStateVar_1174)
	{
		if( ( *itState_1159== state_1157)&& ( *itChildState_1162== childState_1160)&& ( *itCompoundStatement_116b== compoundStatement_1169)&& ( *itStateVar_1174== stateVar_1172))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1153.push_back( state_1157);
		_childState_115c.push_back( childState_1160);
		_compoundStatement_1165.push_back( compoundStatement_1169);
		_stateVar_116e.push_back( stateVar_1172);
	}
	return isUnique;
}

bool CreateConditionals_1148::isGuardTrue( CyberComposition::Simulink::State& ChildState, SFC::StateLabel& ChildStateLabel, SFC::Function& ChildStatus, SFC::CompoundStatement& CompoundStatement, SFC::Arg& IndentArg, CyberComposition::Simulink::State& State, SFC::StateLabel& StateLabel, SFC::StateVar& StateVar, SFC::Function& Status, SFC::LocalVar& newIndent, SFC::LocalVar& retval)
{
	bool Gz_guard= false;
	return static_cast< std::string >( retval.name() ) == "retval" && static_cast< std::string >( newIndent.name() ) == "newIndent";;
	return Gz_guard;
}

void CreateConditionals_1148::processInputPackets( const Packets_t& states_1149, const Packets_t& childStates_114c, const Packets_t& compoundStatements_114e, const Packets_t& stateVars_1150)
{
	for( Packets_t::const_iterator itState_1154= states_1149.begin(), itChildState_115d= childStates_114c.begin(), itCompoundStatement_1166= compoundStatements_114e.begin(), itStateVar_116f= stateVars_1150.begin(); itState_1154!= states_1149.end(), itChildState_115d!= childStates_114c.end(), itCompoundStatement_1166!= compoundStatements_114e.end(), itStateVar_116f!= stateVars_1150.end(); ++itState_1154, ++itChildState_115d, ++itCompoundStatement_1166, ++itStateVar_116f)
	{
		bool isUnique= isInputUnique( *itState_1154, *itChildState_115d, *itCompoundStatement_1166, *itStateVar_116f);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1154, *itChildState_115d, *itCompoundStatement_1166, *itStateVar_116f);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateConditionals_1148::patternMatcher( const Udm::Object& state_1155, const Udm::Object& childState_115e, const Udm::Object& compoundStatement_1167, const Udm::Object& stateVar_1170)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1155.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_115a= CyberComposition::Simulink::State::Cast( state_1155);
		if( false== Uml::IsDerivedFrom( childState_115e.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State childState_1163= CyberComposition::Simulink::State::Cast( childState_115e);
		if( false== Uml::IsDerivedFrom( compoundStatement_1167.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_116c= SFC::CompoundStatement::Cast( compoundStatement_1167);
		if( false== Uml::IsDerivedFrom( stateVar_1170.type(), SFC::StateVar::meta))
			continue;
		SFC::StateVar stateVar_1175= SFC::StateVar::Cast( stateVar_1170);
		set< SFC::Function> statuss_1177= state_115a.status();
		for( set< SFC::Function>::const_iterator itStatuss_1178= statuss_1177.begin(); itStatuss_1178!= statuss_1177.end(); ++itStatuss_1178)
		{
			SFC::Function currStatus_1179= *itStatuss_1178;
			set< SFC::LocalVar> newIndents_117a= currStatus_1179.LocalVar_kind_children();
			for( set< SFC::LocalVar>::const_iterator itnewIndent_117b= newIndents_117a.begin(); itnewIndent_117b!= newIndents_117a.end(); ++itnewIndent_117b)
			{
				SFC::LocalVar currnewIndent_117c= *itnewIndent_117b;
				set< SFC::LocalVar> retvals_117d= currStatus_1179.LocalVar_kind_children();
				for( set< SFC::LocalVar>::const_iterator itretval_117e= retvals_117d.begin(); itretval_117e!= retvals_117d.end(); ++itretval_117e)
				{
					SFC::LocalVar currretval_117f= *itretval_117e;
					set< SFC::Function> childStatuss_1180= childState_1163.status();
					for( set< SFC::Function>::const_iterator itChildStatuss_1181= childStatuss_1180.begin(); itChildStatuss_1181!= childStatuss_1180.end(); ++itChildStatuss_1181)
					{
						SFC::Function currChildStatus_1182= *itChildStatuss_1181;
						set< SFC::Arg> indentArgs_1183= currChildStatus_1182.Arg_kind_children();
						for( set< SFC::Arg>::const_iterator itIndentArg_1184= indentArgs_1183.begin(); itIndentArg_1184!= indentArgs_1183.end(); ++itIndentArg_1184)
						{
							SFC::Arg currIndentArg_1185= *itIndentArg_1184;
							set< SFC::StateLabel> childStateLabels_1186= childState_1163.src();
							for( set< SFC::StateLabel>::const_iterator itChildStateLabels_1187= childStateLabels_1186.begin(); itChildStateLabels_1187!= childStateLabels_1186.end(); ++itChildStateLabels_1187)
							{
								SFC::StateLabel currChildStateLabel_1188= *itChildStateLabels_1187;
								set< SFC::StateLabel> stateLabels_1189= state_115a.src();
								for( set< SFC::StateLabel>::const_iterator itStateLabels_118a= stateLabels_1189.begin(); itStateLabels_118a!= stateLabels_1189.end(); ++itStateLabels_118a)
								{
									SFC::StateLabel currStateLabel_118b= *itStateLabels_118a;
									Match currMatch;
									currMatch.state_118d= state_115a;
									currMatch.childState_118e= childState_1163;
									currMatch.compoundStatement_118f= compoundStatement_116c;
									currMatch.stateVar_1190= stateVar_1175;
									currMatch.status_1191= currStatus_1179;
									currMatch.retval_1192= currretval_117f;
									currMatch.indentArg_1193= currIndentArg_1185;
									currMatch.childStatus_1194= currChildStatus_1182;
									currMatch.newIndent_1195= currnewIndent_117c;
									currMatch.stateLabel_1196= currStateLabel_118b;
									currMatch.childStateLabel_1197= currChildStateLabel_1188;
									bool Gz_guard= isGuardTrue( currMatch.childState_118e, currMatch.childStateLabel_1197, currMatch.childStatus_1194, currMatch.compoundStatement_118f, currMatch.indentArg_1193, currMatch.state_118d, currMatch.stateLabel_1196, currMatch.stateVar_1190, currMatch.status_1191, currMatch.newIndent_1195, currMatch.retval_1192);
									if( true== Gz_guard)
										_matches.push_back( currMatch);
								}
							}
						}
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void CreateConditionals_1148::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_11a3= SFC::ConditionalBlock::Create( currMatch.compoundStatement_118f, SFC::CompoundStatement::meta_stmnt);
		SFC::UserCode newUserCode_11a4= SFC::UserCode::Create( newConditionalBlock_11a3, SFC::ConditionalBlock::meta_stmnt);
		SFC::BinaryExprs newAddEquals_11a5= SFC::BinaryExprs::Create( newUserCode_11a4, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newArgDeclRef2_11a6= SFC::ArgDeclRef::Create( newAddEquals_11a5, SFC::BinaryExprs::meta_leftexpr);
		SFC::FunctionCall newFunctionCall_11a7= SFC::FunctionCall::Create( newAddEquals_11a5, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgVal newArgVal_11a8= SFC::ArgVal::Create( newFunctionCall_11a7);
		SFC::ArgDeclRef newArgDeclRef1_11a9= SFC::ArgDeclRef::Create( newArgVal_11a8, SFC::ArgVal::meta_argexpr);
		SFC::CheckState newCheckState_11aa= SFC::CheckState::Create( newConditionalBlock_11a3, SFC::ConditionalBlock::meta_cond);
		SFC::BinaryExprs& AddEquals= newAddEquals_11a5;
		SFC::ArgDeclRef& ArgDeclRef1= newArgDeclRef1_11a9;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_11a6;
		SFC::ArgVal& ArgVal= newArgVal_11a8;
		SFC::CheckState& CheckState= newCheckState_11aa;
		CyberComposition::Simulink::State& ChildState= currMatch.childState_118e;
		SFC::StateLabel& ChildStateLabel= currMatch.childStateLabel_1197;
		SFC::Function& ChildStatus= currMatch.childStatus_1194;
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_118f;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_11a3;
		SFC::FunctionCall& FunctionCall= newFunctionCall_11a7;
		SFC::Arg& IndentArg= currMatch.indentArg_1193;
		CyberComposition::Simulink::State& State= currMatch.state_118d;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_1196;
		SFC::StateVar& StateVar= currMatch.stateVar_1190;
		SFC::Function& Status= currMatch.status_1191;
		SFC::UserCode& UserCode= newUserCode_11a4;
		SFC::LocalVar& newIndent= currMatch.newIndent_1195;
		SFC::LocalVar& retval= currMatch.retval_1192;
		{
ConditionalBlock.RefId() = UserCode.RefId() = CompoundStatement.RefId();
};
		{
CheckState.andState() = static_cast< std::string >( ChildState.Decomposition() ) == "AND_STATE";
};
		{
__int64 statementCount = ConditionalBlock.statementCount();
UserCode.statementIndex() = statementCount++;
ConditionalBlock.statementCount() = statementCount;
};
		{
__int64 statementCount = CompoundStatement.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		{
AddEquals.op() = "+=";
};
		newArgDeclRef1_11a9.argdecl()= currMatch.newIndent_1195;
		newArgVal_11a8.arg()+= currMatch.indentArg_1193;
		newArgDeclRef2_11a6.argdecl()= currMatch.retval_1192;
		newFunctionCall_11a7.callee()= currMatch.childStatus_1194;
		newCheckState_11aa.svar()= currMatch.stateVar_1190;
		newCheckState_11aa.value()= currMatch.childStateLabel_1197;
		newCheckState_11aa.index()= currMatch.stateLabel_1196;
		outputAppender( currMatch.status_1191);
	}
}

void CreateConditionals_1148::outputAppender( const SFC::Function& status_11ab)
{
	_status_1152->push_back( status_11ab);
}

void DecompTest_11ad::operator()( const Packets_t& states_11ae, const Packets_t& statuss_11b0, const Packets_t& svs_11b2, Packets_t& states_11b4, Packets_t& statuss_11b5, Packets_t& svs_11b6, Packets_t& states_11b7, Packets_t& statuss_11b8, Packets_t& svs_11b9)
{
#ifdef PRINT_INFO
	printLog( "DecompTest_11ad" );
#endif
	_state_11ba= &states_11b4;
	_status_11bb= &statuss_11b5;
	_sv_11bc= &svs_11b6;
	_state_11bd= &states_11b7;
	_status_11be= &statuss_11b8;
	_sv_11bf= &svs_11b9;
	for( Packets_t::const_iterator itstate_11c1= states_11ae.begin(), itstatus_11c8= statuss_11b0.begin(), itsv_11cf= svs_11b2.begin(); itstate_11c1!= states_11ae.end(), itstatus_11c8!= statuss_11b0.end(), itsv_11cf!= svs_11b2.end(); ++itstate_11c1, ++itstatus_11c8, ++itsv_11cf)
	{
		bool isUnique= isInputUnique( *itstate_11c1, *itstatus_11c8, *itsv_11cf);
		if( !isUnique)
			continue;
		Packets_t onestate_11c5( 1, *itstate_11c1);
		Packets_t onestatus_11cc( 1, *itstatus_11c8);
		Packets_t onesv_11d3( 1, *itsv_11cf);
		executeOne( onestate_11c5, onestatus_11cc, onesv_11d3);
	}
}

void DecompTest_11ad::executeOne( const Packets_t& states_11ae, const Packets_t& statuss_11b0, const Packets_t& svs_11b2)
{
	Packets_t states_11d8;
	Packets_t statuss_11db;
	Packets_t stateVars_11de;
	AndState_11d5 andState_11d5;
	bool isMatchAndState_11d5= andState_11d5( states_11ae, statuss_11b0, svs_11b2, states_11d8, statuss_11db, stateVars_11de);
	_state_11ba->insert( _state_11ba->end(), states_11d8.begin(), states_11d8.end());
	_status_11bb->insert( _status_11bb->end(), statuss_11db.begin(), statuss_11db.end());
	_sv_11bc->insert( _sv_11bc->end(), stateVars_11de.begin(), stateVars_11de.end());
	if( isMatchAndState_11d5)
		return;
	Packets_t states_1215;
	Packets_t statuss_1218;
	Packets_t stateVars_121b;
	OrState_1212 orState_1212;
	bool isMatchOrState_1212= orState_1212( states_11ae, statuss_11b0, svs_11b2, states_1215, statuss_1218, stateVars_121b);
	_state_11bd->insert( _state_11bd->end(), states_1215.begin(), states_1215.end());
	_status_11be->insert( _status_11be->end(), statuss_1218.begin(), statuss_1218.end());
	_sv_11bf->insert( _sv_11bf->end(), stateVars_121b.begin(), stateVars_121b.end());
	if( isMatchOrState_1212)
		return;
}

bool DecompTest_11ad::isInputUnique( const Udm::Object& state_11c2, const Udm::Object& status_11c9, const Udm::Object& sv_11d0)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_11c4= _state_11c0.begin(), itstatus_11cb= _status_11c7.begin(), itsv_11d2= _sv_11ce.begin(); itstate_11c4!= _state_11c0.end(), itstatus_11cb!= _status_11c7.end(), itsv_11d2!= _sv_11ce.end(); ++itstate_11c4, ++itstatus_11cb, ++itsv_11d2)
	{
		if( ( *itstate_11c4== state_11c2)&& ( *itstatus_11cb== status_11c9)&& ( *itsv_11d2== sv_11d0))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_11c0.push_back( state_11c2);
		_status_11c7.push_back( status_11c9);
		_sv_11ce.push_back( sv_11d0);
	}
	return isUnique;
}

bool AndState_11d5::operator()( const Packets_t& states_11d6, const Packets_t& statuss_11d9, const Packets_t& stateVars_11dc, Packets_t& states_11d8, Packets_t& statuss_11db, Packets_t& stateVars_11de)
{
#ifdef PRINT_INFO
	printLog( "AndState_11d5" );
#endif
	_state_11df= &states_11d8;
	_status_11e0= &statuss_11db;
	_stateVar_11e1= &stateVars_11de;
	processInputPackets( states_11d6, statuss_11d9, stateVars_11dc);
	if( false== _matches.empty())
		return true;
	return false;
}

bool AndState_11d5::isInputUnique( const Udm::Object& state_11e6, const Udm::Object& status_11ef, const Udm::Object& stateVar_11f8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_11e8= _state_11e2.begin(), itStatus_11f1= _status_11eb.begin(), itStateVar_11fa= _stateVar_11f4.begin(); itState_11e8!= _state_11e2.end(), itStatus_11f1!= _status_11eb.end(), itStateVar_11fa!= _stateVar_11f4.end(); ++itState_11e8, ++itStatus_11f1, ++itStateVar_11fa)
	{
		if( ( *itState_11e8== state_11e6)&& ( *itStatus_11f1== status_11ef)&& ( *itStateVar_11fa== stateVar_11f8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_11e2.push_back( state_11e6);
		_status_11eb.push_back( status_11ef);
		_stateVar_11f4.push_back( stateVar_11f8);
	}
	return isUnique;
}

bool AndState_11d5::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool AndState_11d5::isGuardTrue( CyberComposition::Simulink::State& ChildState, CyberComposition::Simulink::State& State, SFC::StateVar& StateVar, SFC::Function& Status)
{
	bool Gz_guard= false;
	return static_cast< std::string >( ChildState.Decomposition() ) == "AND_STATE";;
	return Gz_guard;
}

void AndState_11d5::processInputPackets( const Packets_t& states_11d6, const Packets_t& statuss_11d9, const Packets_t& stateVars_11dc)
{
	for( Packets_t::const_iterator itState_11e3= states_11d6.begin(), itStatus_11ec= statuss_11d9.begin(), itStateVar_11f5= stateVars_11dc.begin(); itState_11e3!= states_11d6.end(), itStatus_11ec!= statuss_11d9.end(), itStateVar_11f5!= stateVars_11dc.end(); ++itState_11e3, ++itStatus_11ec, ++itStateVar_11f5)
	{
		bool isUnique= isInputUnique( *itState_11e3, *itStatus_11ec, *itStateVar_11f5);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_11e3, *itStatus_11ec, *itStateVar_11f5);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_1204, currMatch.status_1205, currMatch.stateVar_1206);
	}
}

bool AndState_11d5::patternMatcher( const Udm::Object& state_11e4, const Udm::Object& status_11ed, const Udm::Object& stateVar_11f6)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_11e4.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_11e9= CyberComposition::Simulink::State::Cast( state_11e4);
		if( false== Uml::IsDerivedFrom( status_11ed.type(), SFC::Function::meta))
			continue;
		SFC::Function status_11f2= SFC::Function::Cast( status_11ed);
		if( false== Uml::IsDerivedFrom( stateVar_11f6.type(), SFC::StateVar::meta))
			continue;
		SFC::StateVar stateVar_11fb= SFC::StateVar::Cast( stateVar_11f6);
		set< CyberComposition::Simulink::State> childStates_11fd= state_11e9.State_kind_children();
		for( set< CyberComposition::Simulink::State>::const_iterator itChildState_11fe= childStates_11fd.begin(); itChildState_11fe!= childStates_11fd.end(); ++itChildState_11fe)
		{
			CyberComposition::Simulink::State currChildState_11ff= *itChildState_11fe;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1203;
			if( !isValidBound(boundObjs_1203, state_11e9, true))
				continue;
			currMatch.state_1204= state_11e9;
			if( !isValidBound(boundObjs_1203, status_11f2, true))
				continue;
			currMatch.status_1205= status_11f2;
			if( !isValidBound(boundObjs_1203, stateVar_11fb, true))
				continue;
			currMatch.stateVar_1206= stateVar_11fb;
			if( !isValidBound(boundObjs_1203, currChildState_11ff, false))
				continue;
			currMatch.childState_1207= currChildState_11ff;
			bool Gz_guard= isGuardTrue( currMatch.childState_1207, currMatch.state_1204, currMatch.stateVar_1206, currMatch.status_1205);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void AndState_11d5::outputAppender( const CyberComposition::Simulink::State& state_120c, const SFC::Function& status_120e, const SFC::StateVar& stateVar_1210)
{
	_state_11df->push_back( state_120c);
	_status_11e0->push_back( status_120e);
	_stateVar_11e1->push_back( stateVar_1210);
}

bool OrState_1212::operator()( const Packets_t& states_1213, const Packets_t& statuss_1216, const Packets_t& stateVars_1219, Packets_t& states_1215, Packets_t& statuss_1218, Packets_t& stateVars_121b)
{
#ifdef PRINT_INFO
	printLog( "OrState_1212" );
#endif
	_state_121c= &states_1215;
	_status_121d= &statuss_1218;
	_stateVar_121e= &stateVars_121b;
	processInputPackets( states_1213, statuss_1216, stateVars_1219);
	if( false== _matches.empty())
		return true;
	return false;
}

bool OrState_1212::isInputUnique( const Udm::Object& state_1223, const Udm::Object& status_122c, const Udm::Object& stateVar_1235)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1225= _state_121f.begin(), itStatus_122e= _status_1228.begin(), itStateVar_1237= _stateVar_1231.begin(); itState_1225!= _state_121f.end(), itStatus_122e!= _status_1228.end(), itStateVar_1237!= _stateVar_1231.end(); ++itState_1225, ++itStatus_122e, ++itStateVar_1237)
	{
		if( ( *itState_1225== state_1223)&& ( *itStatus_122e== status_122c)&& ( *itStateVar_1237== stateVar_1235))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_121f.push_back( state_1223);
		_status_1228.push_back( status_122c);
		_stateVar_1231.push_back( stateVar_1235);
	}
	return isUnique;
}

bool OrState_1212::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool OrState_1212::isGuardTrue( CyberComposition::Simulink::State& ChildState, CyberComposition::Simulink::State& State, SFC::StateVar& StateVar, SFC::Function& Status)
{
	bool Gz_guard= false;
	return static_cast< std::string >( ChildState.Decomposition() ) == "OR_STATE";;
	return Gz_guard;
}

void OrState_1212::processInputPackets( const Packets_t& states_1213, const Packets_t& statuss_1216, const Packets_t& stateVars_1219)
{
	for( Packets_t::const_iterator itState_1220= states_1213.begin(), itStatus_1229= statuss_1216.begin(), itStateVar_1232= stateVars_1219.begin(); itState_1220!= states_1213.end(), itStatus_1229!= statuss_1216.end(), itStateVar_1232!= stateVars_1219.end(); ++itState_1220, ++itStatus_1229, ++itStateVar_1232)
	{
		bool isUnique= isInputUnique( *itState_1220, *itStatus_1229, *itStateVar_1232);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1220, *itStatus_1229, *itStateVar_1232);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_1241, currMatch.status_1242, currMatch.stateVar_1243);
	}
}

bool OrState_1212::patternMatcher( const Udm::Object& state_1221, const Udm::Object& status_122a, const Udm::Object& stateVar_1233)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1221.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1226= CyberComposition::Simulink::State::Cast( state_1221);
		if( false== Uml::IsDerivedFrom( status_122a.type(), SFC::Function::meta))
			continue;
		SFC::Function status_122f= SFC::Function::Cast( status_122a);
		if( false== Uml::IsDerivedFrom( stateVar_1233.type(), SFC::StateVar::meta))
			continue;
		SFC::StateVar stateVar_1238= SFC::StateVar::Cast( stateVar_1233);
		set< CyberComposition::Simulink::State> childStates_123a= state_1226.State_kind_children();
		for( set< CyberComposition::Simulink::State>::const_iterator itChildState_123b= childStates_123a.begin(); itChildState_123b!= childStates_123a.end(); ++itChildState_123b)
		{
			CyberComposition::Simulink::State currChildState_123c= *itChildState_123b;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1240;
			if( !isValidBound(boundObjs_1240, state_1226, true))
				continue;
			currMatch.state_1241= state_1226;
			if( !isValidBound(boundObjs_1240, status_122f, true))
				continue;
			currMatch.status_1242= status_122f;
			if( !isValidBound(boundObjs_1240, stateVar_1238, true))
				continue;
			currMatch.stateVar_1243= stateVar_1238;
			if( !isValidBound(boundObjs_1240, currChildState_123c, false))
				continue;
			currMatch.childState_1244= currChildState_123c;
			bool Gz_guard= isGuardTrue( currMatch.childState_1244, currMatch.state_1241, currMatch.stateVar_1243, currMatch.status_1242);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void OrState_1212::outputAppender( const CyberComposition::Simulink::State& state_1249, const SFC::Function& status_124b, const SFC::StateVar& stateVar_124d)
{
	_state_121c->push_back( state_1249);
	_status_121d->push_back( status_124b);
	_stateVar_121e->push_back( stateVar_124d);
}

void GetChildStates_124f::operator()( const Packets_t& states_1250, const Packets_t& compoundStatements_1254, const Packets_t& stateVars_1257, Packets_t& states_1252, Packets_t& childStates_1253, Packets_t& compoundStatements_1256, Packets_t& stateVars_1259)
{
#ifdef PRINT_INFO
	printLog( "GetChildStates_124f" );
#endif
	RTTGenerator::Instance()->generateRule(434, "GetChildStates");
	_state_125a= &states_1252;
	_childState_125b= &childStates_1253;
	_compoundStatement_125c= &compoundStatements_1256;
	_stateVar_125d= &stateVars_1259;
	processInputPackets( states_1250, compoundStatements_1254, stateVars_1257);
	sortOutputs( );
}

bool GetChildStates_124f::isInputUnique( const Udm::Object& state_1262, const Udm::Object& compoundStatement_126b, const Udm::Object& stateVar_1274)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1264= _state_125e.begin(), itCompoundStatement_126d= _compoundStatement_1267.begin(), itStateVar_1276= _stateVar_1270.begin(); itState_1264!= _state_125e.end(), itCompoundStatement_126d!= _compoundStatement_1267.end(), itStateVar_1276!= _stateVar_1270.end(); ++itState_1264, ++itCompoundStatement_126d, ++itStateVar_1276)
	{
		if( ( *itState_1264== state_1262)&& ( *itCompoundStatement_126d== compoundStatement_126b)&& ( *itStateVar_1276== stateVar_1274))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_125e.push_back( state_1262);
		_compoundStatement_1267.push_back( compoundStatement_126b);
		_stateVar_1270.push_back( stateVar_1274);
	}
	return isUnique;
}

bool GetChildStates_124f::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetChildStates_124f::processInputPackets( const Packets_t& states_1250, const Packets_t& compoundStatements_1254, const Packets_t& stateVars_1257)
{
	for( Packets_t::const_iterator itState_125f= states_1250.begin(), itCompoundStatement_1268= compoundStatements_1254.begin(), itStateVar_1271= stateVars_1257.begin(); itState_125f!= states_1250.end(), itCompoundStatement_1268!= compoundStatements_1254.end(), itStateVar_1271!= stateVars_1257.end(); ++itState_125f, ++itCompoundStatement_1268, ++itStateVar_1271)
	{
		bool isUnique= isInputUnique( *itState_125f, *itCompoundStatement_1268, *itStateVar_1271);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_125f, *itCompoundStatement_1268, *itStateVar_1271);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetChildStates_124f::patternMatcher( const Udm::Object& state_1260, const Udm::Object& compoundStatement_1269, const Udm::Object& stateVar_1272)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1260.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1265= CyberComposition::Simulink::State::Cast( state_1260);
		if( false== Uml::IsDerivedFrom( compoundStatement_1269.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_126e= SFC::CompoundStatement::Cast( compoundStatement_1269);
		if( false== Uml::IsDerivedFrom( stateVar_1272.type(), SFC::StateVar::meta))
			continue;
		SFC::StateVar stateVar_1277= SFC::StateVar::Cast( stateVar_1272);
		set< CyberComposition::Simulink::State> childStates_1279= state_1265.State_kind_children();
		for( set< CyberComposition::Simulink::State>::const_iterator itChildState_127a= childStates_1279.begin(); itChildState_127a!= childStates_1279.end(); ++itChildState_127a)
		{
			CyberComposition::Simulink::State currChildState_127b= *itChildState_127a;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_127f;
			if( !isValidBound(boundObjs_127f, state_1265, true))
				continue;
			currMatch.state_1280= state_1265;
			if( !isValidBound(boundObjs_127f, compoundStatement_126e, true))
				continue;
			currMatch.compoundStatement_1281= compoundStatement_126e;
			if( !isValidBound(boundObjs_127f, stateVar_1277, true))
				continue;
			currMatch.stateVar_1282= stateVar_1277;
			if( !isValidBound(boundObjs_127f, currChildState_127b, false))
				continue;
			currMatch.childState_1283= currChildState_127b;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetChildStates_124f::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_1280, currMatch.childState_1283, currMatch.compoundStatement_1281, currMatch.stateVar_1282);
	}
}

void GetChildStates_124f::outputAppender( const CyberComposition::Simulink::State& state_1284, const CyberComposition::Simulink::State& childState_1286, const SFC::CompoundStatement& compoundStatement_1288, const SFC::StateVar& stateVar_128a)
{
	_state_125a->push_back( state_1284);
	_childState_125b->push_back( childState_1286);
	_compoundStatement_125c->push_back( compoundStatement_1288);
	_stateVar_125d->push_back( stateVar_128a);
}

void GetChildStates_124f::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::State, std::pointer_to_binary_function< const CyberComposition::Simulink::State&, const CyberComposition::Simulink::State&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::State&, const CyberComposition::Simulink::State&, bool> ptr_StateOrder( StateOrder< CyberComposition::Simulink::State>);
	SortedSet_t sortedSet( ptr_StateOrder);
	std::vector< int> permutationVector( _childState_125b->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _childState_125b->begin(); it!= _childState_125b->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::State::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _childState_125b->begin());
	// order rest of the containers
	permutate( permutationVector, *_state_125a);
	permutate( permutationVector, *_compoundStatement_125c);
	permutate( permutationVector, *_stateVar_125d);
}

void CreateConditionalGroup_128c::operator()( const Packets_t& states_128d, const Packets_t& statuss_1290, const Packets_t& stateVars_1293, Packets_t& states_128f, Packets_t& conditionalGroups_1292, Packets_t& stateVars_1295)
{
#ifdef PRINT_INFO
	printLog( "CreateConditionalGroup_128c" );
#endif
	RTTGenerator::Instance()->generateRule(440, "CreateConditionalGroup");
	_state_1296= &states_128f;
	_conditionalGroup_1297= &conditionalGroups_1292;
	_stateVar_1298= &stateVars_1295;
	processInputPackets( states_128d, statuss_1290, stateVars_1293);
}

bool CreateConditionalGroup_128c::isInputUnique( const Udm::Object& state_129d, const Udm::Object& status_12a6, const Udm::Object& stateVar_12af)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_129f= _state_1299.begin(), itStatus_12a8= _status_12a2.begin(), itStateVar_12b1= _stateVar_12ab.begin(); itState_129f!= _state_1299.end(), itStatus_12a8!= _status_12a2.end(), itStateVar_12b1!= _stateVar_12ab.end(); ++itState_129f, ++itStatus_12a8, ++itStateVar_12b1)
	{
		if( ( *itState_129f== state_129d)&& ( *itStatus_12a8== status_12a6)&& ( *itStateVar_12b1== stateVar_12af))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1299.push_back( state_129d);
		_status_12a2.push_back( status_12a6);
		_stateVar_12ab.push_back( stateVar_12af);
	}
	return isUnique;
}

bool CreateConditionalGroup_128c::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateConditionalGroup_128c::processInputPackets( const Packets_t& states_128d, const Packets_t& statuss_1290, const Packets_t& stateVars_1293)
{
	for( Packets_t::const_iterator itState_129a= states_128d.begin(), itStatus_12a3= statuss_1290.begin(), itStateVar_12ac= stateVars_1293.begin(); itState_129a!= states_128d.end(), itStatus_12a3!= statuss_1290.end(), itStateVar_12ac!= stateVars_1293.end(); ++itState_129a, ++itStatus_12a3, ++itStateVar_12ac)
	{
		bool isUnique= isInputUnique( *itState_129a, *itStatus_12a3, *itStateVar_12ac);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_129a, *itStatus_12a3, *itStateVar_12ac);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateConditionalGroup_128c::patternMatcher( const Udm::Object& state_129b, const Udm::Object& status_12a4, const Udm::Object& stateVar_12ad)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_129b.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_12a0= CyberComposition::Simulink::State::Cast( state_129b);
		if( false== Uml::IsDerivedFrom( status_12a4.type(), SFC::Function::meta))
			continue;
		SFC::Function status_12a9= SFC::Function::Cast( status_12a4);
		if( false== Uml::IsDerivedFrom( stateVar_12ad.type(), SFC::StateVar::meta))
			continue;
		SFC::StateVar stateVar_12b2= SFC::StateVar::Cast( stateVar_12ad);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_12b7;
		if( !isValidBound(boundObjs_12b7, state_12a0, true))
			continue;
		currMatch.state_12b8= state_12a0;
		if( !isValidBound(boundObjs_12b7, status_12a9, true))
			continue;
		currMatch.status_12b9= status_12a9;
		if( !isValidBound(boundObjs_12b7, stateVar_12b2, true))
			continue;
		currMatch.stateVar_12ba= stateVar_12b2;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateConditionalGroup_128c::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalGroup newConditionalGroup_12bb= SFC::ConditionalGroup::Create( currMatch.status_12b9, SFC::Function::meta_stmnt);
		SFC::ConditionalGroup& ConditionalGroup= newConditionalGroup_12bb;
		CyberComposition::Simulink::State& State= currMatch.state_12b8;
		SFC::StateVar& StateVar= currMatch.stateVar_12ba;
		SFC::Function& Status= currMatch.status_12b9;
		{
ConditionalGroup.RefId() = Status.RefId();
};
		{
__int64 statementCount = Status.statementCount();
ConditionalGroup.statementIndex() = statementCount++;
Status.statementCount() = statementCount;
};
		outputAppender( currMatch.state_12b8, newConditionalGroup_12bb, currMatch.stateVar_12ba);
	}
}

void CreateConditionalGroup_128c::outputAppender( const CyberComposition::Simulink::State& state_12bc, const SFC::ConditionalGroup& conditionalGroup_12be, const SFC::StateVar& stateVar_12c0)
{
	_state_1296->push_back( state_12bc);
	_conditionalGroup_1297->push_back( conditionalGroup_12be);
	_stateVar_1298->push_back( stateVar_12c0);
}

void GetStatusFunction_12c2::operator()( const Packets_t& states_12c3, Packets_t& states_12c5, Packets_t& statuss_12c6)
{
#ifdef PRINT_INFO
	printLog( "GetStatusFunction_12c2" );
#endif
	RTTGenerator::Instance()->generateRule(448, "GetStatusFunction");
	_state_12c7= &states_12c5;
	_status_12c8= &statuss_12c6;
	processInputPackets( states_12c3);
}

bool GetStatusFunction_12c2::isInputUnique( const Udm::Object& state_12cd)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_12cf= _state_12c9.begin(); itState_12cf!= _state_12c9.end(); ++itState_12cf)
	{
		if( ( *itState_12cf== state_12cd))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_12c9.push_back( state_12cd);
	return isUnique;
}

bool GetStatusFunction_12c2::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetStatusFunction_12c2::processInputPackets( const Packets_t& states_12c3)
{
	for( Packets_t::const_iterator itState_12ca= states_12c3.begin(); itState_12ca!= states_12c3.end(); ++itState_12ca)
	{
		bool isUnique= isInputUnique( *itState_12ca);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_12ca);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetStatusFunction_12c2::patternMatcher( const Udm::Object& state_12cb)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_12cb.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_12d0= CyberComposition::Simulink::State::Cast( state_12cb);
		set< SFC::Function> statuss_12d2= state_12d0.status();
		for( set< SFC::Function>::const_iterator itStatuss_12d3= statuss_12d2.begin(); itStatuss_12d3!= statuss_12d2.end(); ++itStatuss_12d3)
		{
			SFC::Function currStatus_12d4= *itStatuss_12d3;
			set< SFC::Arg> args_12d5= currStatus_12d4.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itArg_12d6= args_12d5.begin(); itArg_12d6!= args_12d5.end(); ++itArg_12d6)
			{
				SFC::Arg currArg_12d7= *itArg_12d6;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_12db;
				if( !isValidBound(boundObjs_12db, state_12d0, true))
					continue;
				currMatch.state_12dc= state_12d0;
				if( !isValidBound(boundObjs_12db, currStatus_12d4, false))
					continue;
				currMatch.status_12dd= currStatus_12d4;
				if( !isValidBound(boundObjs_12db, currArg_12d7, false))
					continue;
				currMatch.arg_12de= currArg_12d7;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetStatusFunction_12c2::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newretval_12df= SFC::LocalVar::Create( currMatch.status_12dd, SFC::Function::meta_stmnt);
		SFC::UserCode newretvalAssign_12e0= SFC::UserCode::Create( currMatch.status_12dd, SFC::Function::meta_stmnt);
		SFC::BinaryExprs newAssign_12e1= SFC::BinaryExprs::Create( newretvalAssign_12e0, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newPlus_12e2= SFC::BinaryExprs::Create( newAssign_12e1, SFC::BinaryExprs::meta_rightexpr);
		SFC::Str newStr_12e3= SFC::Str::Create( newPlus_12e2, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef1_12e4= SFC::ArgDeclRef::Create( newPlus_12e2, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_12e5= SFC::ArgDeclRef::Create( newAssign_12e1, SFC::BinaryExprs::meta_leftexpr);
		SFC::Arg& Arg= currMatch.arg_12de;
		SFC::ArgDeclRef& ArgDeclRef1= newArgDeclRef1_12e4;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_12e5;
		SFC::BinaryExprs& Assign= newAssign_12e1;
		SFC::BinaryExprs& Plus= newPlus_12e2;
		CyberComposition::Simulink::State& State= currMatch.state_12dc;
		SFC::Function& Status= currMatch.status_12dd;
		SFC::Str& Str= newStr_12e3;
		SFC::LocalVar& retval= newretval_12df;
		SFC::UserCode& retvalAssign= newretvalAssign_12e0;
		{
retval.RefId() = retvalAssign.RefId() = Status.RefId();
};
		{
Plus.op() = "+";
};
		{
Assign.op() = "=";
};
		{
Str.val() = static_cast< std::string >( State.name() ) + "\\n";
};
		{
retval.name() = "retval";
retval.dt() = SFCTypesManager::getSingleton().getBasicType( "string" );
};
		{
__int64 statementCount = Status.statementCount();
retval.statementIndex() = statementCount++;
retvalAssign.statementIndex() = statementCount++;
Status.statementCount() = statementCount;
};
		newArgDeclRef1_12e4.argdecl()= currMatch.arg_12de;
		newArgDeclRef2_12e5.argdecl()= newretval_12df;
		outputAppender( currMatch.state_12dc, currMatch.status_12dd);
	}
}

void GetStatusFunction_12c2::outputAppender( const CyberComposition::Simulink::State& state_12e6, const SFC::Function& status_12e8)
{
	_state_12c7->push_back( state_12e6);
	_status_12c8->push_back( status_12e8);
}

void NoFunctionStates_1308::operator()( const Packets_t& states_1309, const Packets_t& programs_130b, Packets_t& states_130d, Packets_t& programs_130e)
{
#ifdef PRINT_INFO
	printLog( "NoFunctionStates_1308" );
#endif
	_state_130f= &states_130d;
	_program_1310= &programs_130e;
	for( Packets_t::const_iterator itstate_1312= states_1309.begin(), itprogram_1319= programs_130b.begin(); itstate_1312!= states_1309.end(), itprogram_1319!= programs_130b.end(); ++itstate_1312, ++itprogram_1319)
	{
		bool isUnique= isInputUnique( *itstate_1312, *itprogram_1319);
		if( !isUnique)
			continue;
		Packets_t onestate_1316( 1, *itstate_1312);
		Packets_t oneprogram_131d( 1, *itprogram_1319);
		executeOne( onestate_1316, oneprogram_131d);
	}
}

void NoFunctionStates_1308::executeOne( const Packets_t& states_1309, const Packets_t& programs_130b)
{
	Packets_t states_1322;
	Packets_t programs_1325;
	NotFunctionState_131f notFunctionState_131f;
	bool isMatchNotFunctionState_131f= notFunctionState_131f( states_1309, programs_130b, states_1322, programs_1325);
	_state_130f->insert( _state_130f->end(), states_1322.begin(), states_1322.end());
	_program_1310->insert( _program_1310->end(), programs_1325.begin(), programs_1325.end());
	if( isMatchNotFunctionState_131f)
		return;
}

bool NoFunctionStates_1308::isInputUnique( const Udm::Object& state_1313, const Udm::Object& program_131a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_1315= _state_1311.begin(), itprogram_131c= _program_1318.begin(); itstate_1315!= _state_1311.end(), itprogram_131c!= _program_1318.end(); ++itstate_1315, ++itprogram_131c)
	{
		if( ( *itstate_1315== state_1313)&& ( *itprogram_131c== program_131a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1311.push_back( state_1313);
		_program_1318.push_back( program_131a);
	}
	return isUnique;
}

bool NotFunctionState_131f::operator()( const Packets_t& states_1320, const Packets_t& programs_1323, Packets_t& states_1322, Packets_t& programs_1325)
{
#ifdef PRINT_INFO
	printLog( "NotFunctionState_131f" );
#endif
	_state_1326= &states_1322;
	_program_1327= &programs_1325;
	processInputPackets( states_1320, programs_1323);
	if( false== _matches.empty())
		return true;
	return false;
}

bool NotFunctionState_131f::isInputUnique( const Udm::Object& state_132c, const Udm::Object& program_1335)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_132e= _state_1328.begin(), itProgram_1337= _program_1331.begin(); itState_132e!= _state_1328.end(), itProgram_1337!= _program_1331.end(); ++itState_132e, ++itProgram_1337)
	{
		if( ( *itState_132e== state_132c)&& ( *itProgram_1337== program_1335))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1328.push_back( state_132c);
		_program_1331.push_back( program_1335);
	}
	return isUnique;
}

bool NotFunctionState_131f::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool NotFunctionState_131f::isGuardTrue( SFC::Program& Program, CyberComposition::Simulink::State& State)
{
	bool Gz_guard= false;
	return static_cast< std::string >( State.Decomposition() ) != "FUNC_STATE";;
	return Gz_guard;
}

void NotFunctionState_131f::processInputPackets( const Packets_t& states_1320, const Packets_t& programs_1323)
{
	for( Packets_t::const_iterator itState_1329= states_1320.begin(), itProgram_1332= programs_1323.begin(); itState_1329!= states_1320.end(), itProgram_1332!= programs_1323.end(); ++itState_1329, ++itProgram_1332)
	{
		bool isUnique= isInputUnique( *itState_1329, *itProgram_1332);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1329, *itProgram_1332);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_133e, currMatch.program_133f);
	}
}

bool NotFunctionState_131f::patternMatcher( const Udm::Object& state_132a, const Udm::Object& program_1333)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_132a.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_132f= CyberComposition::Simulink::State::Cast( state_132a);
		if( false== Uml::IsDerivedFrom( program_1333.type(), SFC::Program::meta))
			continue;
		SFC::Program program_1338= SFC::Program::Cast( program_1333);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_133d;
		if( !isValidBound(boundObjs_133d, state_132f, true))
			continue;
		currMatch.state_133e= state_132f;
		if( !isValidBound(boundObjs_133d, program_1338, true))
			continue;
		currMatch.program_133f= program_1338;
		bool Gz_guard= isGuardTrue( currMatch.program_133f, currMatch.state_133e);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void NotFunctionState_131f::outputAppender( const CyberComposition::Simulink::State& state_1342, const SFC::Program& program_1344)
{
	_state_1326->push_back( state_1342);
	_program_1327->push_back( program_1344);
}

void PopulateExecFunction_1346::operator()( const Packets_t& states_1347, const Packets_t& programs_1349, Packets_t& states_134b, Packets_t& programs_134c)
{
#ifdef PRINT_INFO
	printLog( "PopulateExecFunction_1346" );
#endif
	_state_134d= &states_134b;
	_program_134e= &programs_134c;
	if( ( !states_1347.empty()))
		callInitTransConnMap_19e2( states_1347);
	_state_134d->insert( _state_134d->end(), states_1347.begin(), states_1347.end());
	_program_134e->insert( _program_134e->end(), programs_1349.begin(), programs_1349.end());
}

void PopulateExecFunction_1346::callInitTransConnMap_19e2( const Packets_t& states_19d9)
{
	Packets_t states_19db;
	InitTransConnMap_19d8 initTransConnMap_19d8;
	initTransConnMap_19d8( states_19d9, states_19db);
	if( ( !states_19db.empty()))
		callOuterTransitions_19e4( states_19db);
}

void PopulateExecFunction_1346::callOuterTransitions_19e4( const Packets_t& states_1963)
{
	Packets_t states_1965;
	OuterTransitions_1962 outerTransitions_1962;
	outerTransitions_1962( states_1963, states_1965);
	if( ( !states_1965.empty()))
		callDuringAction_19e6( states_1965);
}

void PopulateExecFunction_1346::callDuringAction_19e6( const Packets_t& states_194c)
{
	Packets_t states_194e;
	DuringAction_194b duringAction_194b;
	duringAction_194b( states_194c, states_194e);
	if( ( !states_194e.empty()))
		callInitTransConnMapInner_19e8( states_194e);
}

void PopulateExecFunction_1346::callInitTransConnMapInner_19e8( const Packets_t& states_18fe)
{
	Packets_t states_1900;
	InitTransConnMapInner_18fd initTransConnMapInner_18fd;
	initTransConnMapInner_18fd( states_18fe, states_1900);
	if( ( !states_1900.empty()))
		callInnerTransitions_19ea( states_1900);
}

void PopulateExecFunction_1346::callInnerTransitions_19ea( const Packets_t& states_164c)
{
	Packets_t states_164e;
	InnerTransitions_164b innerTransitions_164b;
	innerTransitions_164b( states_164c, states_164e);
	if( ( !states_164e.empty()))
		callExecChildren_19ec( states_164e);
}

void PopulateExecFunction_1346::callExecChildren_19ec( const Packets_t& states_1350)
{
	ExecChildren_134f execChildren_134f;
	execChildren_134f( states_1350);
}

void ExecChildren_134f::operator()( const Packets_t& states_1350)
{
#ifdef PRINT_INFO
	printLog( "ExecChildren_134f" );
#endif
	if( ( !states_1350.empty()))
		callGetExecFcn_1627( states_1350);
}

void ExecChildren_134f::callGetExecFcn_1627( const Packets_t& states_160e)
{
	Packets_t states_1610;
	Packets_t functions_1611;
	GetExecFcn_160d getExecFcn_160d;
	getExecFcn_160d( states_160e, states_1610, functions_1611);
	if( ( !states_1610.empty())&& ( !functions_1611.empty()))
		callChildStateType_1629( states_1610, functions_1611);
}

void ExecChildren_134f::callChildStateType_1629( const Packets_t& states_152f, const Packets_t& css_1531)
{
	Packets_t states_1533;
	Packets_t css_1534;
	Packets_t states_1535;
	Packets_t css_1536;
	ChildStateType_152e childStateType_152e;
	childStateType_152e( states_152f, css_1531, states_1533, css_1534, states_1535, css_1536);
	if( ( !states_1533.empty())&& ( !css_1534.empty()))
		callTopLevelState_162c( states_1533, css_1534);
	if( ( !states_1535.empty())&& ( !css_1536.empty()))
		callCG_162f( states_1535, css_1536);
}

void ExecChildren_134f::callTopLevelState_162c( const Packets_t& states_1499, const Packets_t& css_149b)
{
	Packets_t states_149d;
	Packets_t css_149e;
	Packets_t states_149f;
	Packets_t css_14a0;
	TopLevelState_1498 topLevelState_1498;
	topLevelState_1498( states_1499, css_149b, states_149d, css_149e, states_149f, css_14a0);
	if( ( !states_149f.empty())&& ( !css_14a0.empty()))
		callChildStatesExec_1632( states_149f, css_14a0);
	if( ( !states_149d.empty())&& ( !css_149e.empty()))
		callCreateCG_1635( states_149d, css_149e);
}

void ExecChildren_134f::callCG_162f( const Packets_t& states_15e8, const Packets_t& compoundStatements_15eb)
{
	Packets_t states_15ea;
	Packets_t conditionalGroups_15ed;
	CG_15e7 cG_15e7;
	cG_15e7( states_15e8, compoundStatements_15eb, states_15ea, conditionalGroups_15ed);
	if( ( !states_15ea.empty())&& ( !conditionalGroups_15ed.empty()))
		callCallActiveChildExec_1638( states_15ea, conditionalGroups_15ed);
}

void ExecChildren_134f::callChildStatesExec_1632( const Packets_t& states_1380, const Packets_t& css_1382)
{
	ChildStatesExec_137f childStatesExec_137f;
	childStatesExec_137f( states_1380, css_1382);
}

void ExecChildren_134f::callCreateCG_1635( const Packets_t& states_1473, const Packets_t& execs_1476)
{
	Packets_t states_1475;
	Packets_t conditionalGroups_1478;
	CreateCG_1472 createCG_1472;
	createCG_1472( states_1473, execs_1476, states_1475, conditionalGroups_1478);
	if( ( !states_1475.empty())&& ( !conditionalGroups_1478.empty()))
		callEnterFunctionCondition_163b( states_1475, conditionalGroups_1478);
}

void ExecChildren_134f::callCallActiveChildExec_1638( const Packets_t& states_159b, const Packets_t& css_159d)
{
	Packets_t states_159f;
	Packets_t css_15a0;
	CallActiveChildExec_159a callActiveChildExec_159a;
	callActiveChildExec_159a( states_159b, css_159d, states_159f, css_15a0);
	if( ( !states_159f.empty())&& ( !css_15a0.empty()))
		callTransStartMap_163e( states_159f, css_15a0);
}

void ExecChildren_134f::callEnterFunctionCondition_163b( const Packets_t& states_13ea, const Packets_t& cgs_13ec)
{
	Packets_t states_13ee;
	Packets_t cgs_13ef;
	EnterFunctionCondition_13e9 enterFunctionCondition_13e9;
	enterFunctionCondition_13e9( states_13ea, cgs_13ec, states_13ee, cgs_13ef);
	if( ( !states_13ee.empty())&& ( !cgs_13ef.empty()))
		callExecFunctionCondition_1641( states_13ee, cgs_13ef);
}

void ExecChildren_134f::callTransStartMap_163e( const Packets_t& states_a08, const Packets_t& css_a0a)
{
	Packets_t states_a0c;
	Packets_t css_a0d;
	TransStartMap_a07 transStartMap_a07;
	transStartMap_a07( states_a08, css_a0a, states_a0c, css_a0d);
	if( ( !states_a0c.empty())&& ( !css_a0d.empty()))
		callDefaultCondition_1644( states_a0c, css_a0d);
}

void ExecChildren_134f::callExecFunctionCondition_1641( const Packets_t& states_1353, const Packets_t& cgs_1355)
{
	ExecFunctionCondition_1352 execFunctionCondition_1352;
	execFunctionCondition_1352( states_1353, cgs_1355);
}

void ExecChildren_134f::callDefaultCondition_1644( const Packets_t& states_1502, const Packets_t& compoundStatements_1506)
{
	Packets_t states_1504;
	Packets_t functions_1505;
	Packets_t conditionalBlocks_1508;
	DefaultCondition_1501 defaultCondition_1501;
	defaultCondition_1501( states_1502, compoundStatements_1506, states_1504, functions_1505, conditionalBlocks_1508);
	if( ( !states_1504.empty())&& ( !functions_1505.empty())&& ( !conditionalBlocks_1508.empty()))
		callTransStartTransitions_1647( states_1504, functions_1505, conditionalBlocks_1508);
}

void ExecChildren_134f::callTransStartTransitions_1647( const Packets_t& states_b2, const Packets_t& fcns_b4, const Packets_t& css_b6)
{
	TransStartTransitions_b1 transStartTransitions_b1;
	transStartTransitions_b1( states_b2, fcns_b4, css_b6);
}

void ExecFunctionCondition_1352::operator()( const Packets_t& states_1353, const Packets_t& cgs_1355)
{
#ifdef PRINT_INFO
	printLog( "ExecFunctionCondition_1352" );
#endif
	if( ( !states_1353.empty())&& ( !cgs_1355.empty()))
		callCreateDefaultCB_13e3( states_1353, cgs_1355);
}

void ExecFunctionCondition_1352::callCreateDefaultCB_13e3( const Packets_t& states_1358, const Packets_t& conditionalGroups_135b)
{
	Packets_t states_135a;
	Packets_t conditionalBlocks_135d;
	CreateDefaultCB_1357 createDefaultCB_1357;
	createDefaultCB_1357( states_1358, conditionalGroups_135b, states_135a, conditionalBlocks_135d);
	if( ( !states_135a.empty())&& ( !conditionalBlocks_135d.empty()))
		callChildStatesExec_13e6( states_135a, conditionalBlocks_135d);
}

void ExecFunctionCondition_1352::callChildStatesExec_13e6( const Packets_t& states_1380, const Packets_t& css_1382)
{
	ChildStatesExec_137f childStatesExec_137f;
	childStatesExec_137f( states_1380, css_1382);
}

void CreateDefaultCB_1357::operator()( const Packets_t& states_1358, const Packets_t& conditionalGroups_135b, Packets_t& states_135a, Packets_t& conditionalBlocks_135d)
{
#ifdef PRINT_INFO
	printLog( "CreateDefaultCB_1357" );
#endif
	RTTGenerator::Instance()->generateRule(494, "CreateDefaultCB");
	_state_135e= &states_135a;
	_conditionalBlock_135f= &conditionalBlocks_135d;
	processInputPackets( states_1358, conditionalGroups_135b);
}

bool CreateDefaultCB_1357::isInputUnique( const Udm::Object& state_1364, const Udm::Object& conditionalGroup_136d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1366= _state_1360.begin(), itConditionalGroup_136f= _conditionalGroup_1369.begin(); itState_1366!= _state_1360.end(), itConditionalGroup_136f!= _conditionalGroup_1369.end(); ++itState_1366, ++itConditionalGroup_136f)
	{
		if( ( *itState_1366== state_1364)&& ( *itConditionalGroup_136f== conditionalGroup_136d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1360.push_back( state_1364);
		_conditionalGroup_1369.push_back( conditionalGroup_136d);
	}
	return isUnique;
}

bool CreateDefaultCB_1357::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateDefaultCB_1357::processInputPackets( const Packets_t& states_1358, const Packets_t& conditionalGroups_135b)
{
	for( Packets_t::const_iterator itState_1361= states_1358.begin(), itConditionalGroup_136a= conditionalGroups_135b.begin(); itState_1361!= states_1358.end(), itConditionalGroup_136a!= conditionalGroups_135b.end(); ++itState_1361, ++itConditionalGroup_136a)
	{
		bool isUnique= isInputUnique( *itState_1361, *itConditionalGroup_136a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1361, *itConditionalGroup_136a);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateDefaultCB_1357::patternMatcher( const Udm::Object& state_1362, const Udm::Object& conditionalGroup_136b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1362.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1367= CyberComposition::Simulink::State::Cast( state_1362);
		if( false== Uml::IsDerivedFrom( conditionalGroup_136b.type(), SFC::ConditionalGroup::meta))
			continue;
		SFC::ConditionalGroup conditionalGroup_1370= SFC::ConditionalGroup::Cast( conditionalGroup_136b);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1375;
		if( !isValidBound(boundObjs_1375, state_1367, true))
			continue;
		currMatch.state_1376= state_1367;
		if( !isValidBound(boundObjs_1375, conditionalGroup_1370, true))
			continue;
		currMatch.conditionalGroup_1377= conditionalGroup_1370;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateDefaultCB_1357::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_1378= SFC::ConditionalBlock::Create( currMatch.conditionalGroup_1377, SFC::ConditionalGroup::meta_stmnt);
		SFC::UserCode newUserCode_1379= SFC::UserCode::Create( newConditionalBlock_1378, SFC::ConditionalBlock::meta_cond);
		SFC::Int newOne_137a= SFC::Int::Create( newUserCode_1379, SFC::UserCode::meta_codeexpr);
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_1378;
		SFC::ConditionalGroup& ConditionalGroup= currMatch.conditionalGroup_1377;
		SFC::Int& One= newOne_137a;
		CyberComposition::Simulink::State& State= currMatch.state_1376;
		SFC::UserCode& UserCode= newUserCode_1379;
		{
ConditionalBlock.RefId() = UserCode.RefId() = ConditionalGroup.RefId();
};
		{
__int64 statementCount = ConditionalGroup.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
ConditionalGroup.statementCount() = statementCount;
};
		{
One.val() = 1;
};
		outputAppender( currMatch.state_1376, newConditionalBlock_1378);
	}
}

void CreateDefaultCB_1357::outputAppender( const CyberComposition::Simulink::State& state_137b, const SFC::ConditionalBlock& conditionalBlock_137d)
{
	_state_135e->push_back( state_137b);
	_conditionalBlock_135f->push_back( conditionalBlock_137d);
}

void ChildStatesExec_137f::operator()( const Packets_t& states_1380, const Packets_t& css_1382)
{
#ifdef PRINT_INFO
	printLog( "ChildStatesExec_137f" );
#endif
	if( ( !states_1380.empty())&& ( !css_1382.empty()))
		callGetChildStates_13dc( states_1380, css_1382);
}

void ChildStatesExec_137f::callGetChildStates_13dc( const Packets_t& states_13b0, const Packets_t& compoundStatements_13b4)
{
	Packets_t states_13b2;
	Packets_t childStates_13b3;
	Packets_t compoundStatements_13b6;
	GetChildStates_13af getChildStates_13af;
	getChildStates_13af( states_13b0, compoundStatements_13b4, states_13b2, childStates_13b3, compoundStatements_13b6);
	if( ( !states_13b2.empty())&& ( !childStates_13b3.empty())&& ( !compoundStatements_13b6.empty()))
		callExecChildAndStates_13df( states_13b2, childStates_13b3, compoundStatements_13b6);
}

void ChildStatesExec_137f::callExecChildAndStates_13df( const Packets_t& states_1385, const Packets_t& childStates_1387, const Packets_t& compoundStatements_1389)
{
	ExecChildAndStates_1384 execChildAndStates_1384;
	execChildAndStates_1384( states_1385, childStates_1387, compoundStatements_1389);
}

void ExecChildAndStates_1384::operator()( const Packets_t& states_1385, const Packets_t& childStates_1387, const Packets_t& compoundStatements_1389)
{
#ifdef PRINT_INFO
	printLog( "ExecChildAndStates_1384" );
#endif
	RTTGenerator::Instance()->generateRule(509, "ExecChildAndStates");
	processInputPackets( states_1385, childStates_1387, compoundStatements_1389);
}

bool ExecChildAndStates_1384::isInputUnique( const Udm::Object& state_138f, const Udm::Object& childState_1398, const Udm::Object& compoundStatement_13a1)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1391= _state_138b.begin(), itChildState_139a= _childState_1394.begin(), itCompoundStatement_13a3= _compoundStatement_139d.begin(); itState_1391!= _state_138b.end(), itChildState_139a!= _childState_1394.end(), itCompoundStatement_13a3!= _compoundStatement_139d.end(); ++itState_1391, ++itChildState_139a, ++itCompoundStatement_13a3)
	{
		if( ( *itState_1391== state_138f)&& ( *itChildState_139a== childState_1398)&& ( *itCompoundStatement_13a3== compoundStatement_13a1))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_138b.push_back( state_138f);
		_childState_1394.push_back( childState_1398);
		_compoundStatement_139d.push_back( compoundStatement_13a1);
	}
	return isUnique;
}

void ExecChildAndStates_1384::processInputPackets( const Packets_t& states_1385, const Packets_t& childStates_1387, const Packets_t& compoundStatements_1389)
{
	for( Packets_t::const_iterator itState_138c= states_1385.begin(), itChildState_1395= childStates_1387.begin(), itCompoundStatement_139e= compoundStatements_1389.begin(); itState_138c!= states_1385.end(), itChildState_1395!= childStates_1387.end(), itCompoundStatement_139e!= compoundStatements_1389.end(); ++itState_138c, ++itChildState_1395, ++itCompoundStatement_139e)
	{
		bool isUnique= isInputUnique( *itState_138c, *itChildState_1395, *itCompoundStatement_139e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_138c, *itChildState_1395, *itCompoundStatement_139e);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ExecChildAndStates_1384::patternMatcher( const Udm::Object& state_138d, const Udm::Object& childState_1396, const Udm::Object& compoundStatement_139f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_138d.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1392= CyberComposition::Simulink::State::Cast( state_138d);
		if( false== Uml::IsDerivedFrom( childState_1396.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State childState_139b= CyberComposition::Simulink::State::Cast( childState_1396);
		if( false== Uml::IsDerivedFrom( compoundStatement_139f.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_13a4= SFC::CompoundStatement::Cast( compoundStatement_139f);
		set< SFC::Function> functions_13a6= childState_139b.exec();
		for( set< SFC::Function>::const_iterator itFunctions_13a7= functions_13a6.begin(); itFunctions_13a7!= functions_13a6.end(); ++itFunctions_13a7)
		{
			SFC::Function currFunction_13a8= *itFunctions_13a7;
			Match currMatch;
			currMatch.state_13aa= state_1392;
			currMatch.childState_13ab= childState_139b;
			currMatch.compoundStatement_13ac= compoundStatement_13a4;
			currMatch.function_13ad= currFunction_13a8;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void ExecChildAndStates_1384::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::FunctionCall newFunctionCall_13ae= SFC::FunctionCall::Create( currMatch.compoundStatement_13ac, SFC::CompoundStatement::meta_stmnt);
		CyberComposition::Simulink::State& ChildState= currMatch.childState_13ab;
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_13ac;
		SFC::Function& Function= currMatch.function_13ad;
		SFC::FunctionCall& FunctionCall= newFunctionCall_13ae;
		CyberComposition::Simulink::State& State= currMatch.state_13aa;
		{
FunctionCall.RefId() = CompoundStatement.RefId();
};
		{
__int64 statementCount = CompoundStatement.statementCount();
FunctionCall.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		newFunctionCall_13ae.callee()= currMatch.function_13ad;
	}
}

void GetChildStates_13af::operator()( const Packets_t& states_13b0, const Packets_t& compoundStatements_13b4, Packets_t& states_13b2, Packets_t& childStates_13b3, Packets_t& compoundStatements_13b6)
{
#ifdef PRINT_INFO
	printLog( "GetChildStates_13af" );
#endif
	RTTGenerator::Instance()->generateRule(670, "GetChildStates");
	_state_13b7= &states_13b2;
	_childState_13b8= &childStates_13b3;
	_compoundStatement_13b9= &compoundStatements_13b6;
	processInputPackets( states_13b0, compoundStatements_13b4);
	sortOutputs( );
}

bool GetChildStates_13af::isInputUnique( const Udm::Object& state_13be, const Udm::Object& compoundStatement_13c7)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_13c0= _state_13ba.begin(), itCompoundStatement_13c9= _compoundStatement_13c3.begin(); itState_13c0!= _state_13ba.end(), itCompoundStatement_13c9!= _compoundStatement_13c3.end(); ++itState_13c0, ++itCompoundStatement_13c9)
	{
		if( ( *itState_13c0== state_13be)&& ( *itCompoundStatement_13c9== compoundStatement_13c7))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_13ba.push_back( state_13be);
		_compoundStatement_13c3.push_back( compoundStatement_13c7);
	}
	return isUnique;
}

bool GetChildStates_13af::isGuardTrue( CyberComposition::Simulink::State& ChildState, SFC::CompoundStatement& CompoundStatement, CyberComposition::Simulink::State& State)
{
	bool Gz_guard= false;
	return static_cast< std::string >( ChildState.Decomposition() ) != "FUNC_STATE";;
	return Gz_guard;
}

void GetChildStates_13af::processInputPackets( const Packets_t& states_13b0, const Packets_t& compoundStatements_13b4)
{
	for( Packets_t::const_iterator itState_13bb= states_13b0.begin(), itCompoundStatement_13c4= compoundStatements_13b4.begin(); itState_13bb!= states_13b0.end(), itCompoundStatement_13c4!= compoundStatements_13b4.end(); ++itState_13bb, ++itCompoundStatement_13c4)
	{
		bool isUnique= isInputUnique( *itState_13bb, *itCompoundStatement_13c4);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_13bb, *itCompoundStatement_13c4);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetChildStates_13af::patternMatcher( const Udm::Object& state_13bc, const Udm::Object& compoundStatement_13c5)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_13bc.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_13c1= CyberComposition::Simulink::State::Cast( state_13bc);
		if( false== Uml::IsDerivedFrom( compoundStatement_13c5.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_13ca= SFC::CompoundStatement::Cast( compoundStatement_13c5);
		set< CyberComposition::Simulink::State> childStates_13cc= state_13c1.State_kind_children();
		for( set< CyberComposition::Simulink::State>::const_iterator itChildState_13cd= childStates_13cc.begin(); itChildState_13cd!= childStates_13cc.end(); ++itChildState_13cd)
		{
			CyberComposition::Simulink::State currChildState_13ce= *itChildState_13cd;
			Match currMatch;
			currMatch.state_13d0= state_13c1;
			currMatch.compoundStatement_13d1= compoundStatement_13ca;
			currMatch.childState_13d2= currChildState_13ce;
			bool Gz_guard= isGuardTrue( currMatch.childState_13d2, currMatch.compoundStatement_13d1, currMatch.state_13d0);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetChildStates_13af::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_13d0, currMatch.childState_13d2, currMatch.compoundStatement_13d1);
	}
}

void GetChildStates_13af::outputAppender( const CyberComposition::Simulink::State& state_13d6, const CyberComposition::Simulink::State& childState_13d8, const SFC::CompoundStatement& compoundStatement_13da)
{
	_state_13b7->push_back( state_13d6);
	_childState_13b8->push_back( childState_13d8);
	_compoundStatement_13b9->push_back( compoundStatement_13da);
}

void GetChildStates_13af::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::State, std::pointer_to_binary_function< const CyberComposition::Simulink::State&, const CyberComposition::Simulink::State&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::State&, const CyberComposition::Simulink::State&, bool> ptr_StateOrder( StateOrder< CyberComposition::Simulink::State>);
	SortedSet_t sortedSet( ptr_StateOrder);
	std::vector< int> permutationVector( _childState_13b8->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _childState_13b8->begin(); it!= _childState_13b8->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::State::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _childState_13b8->begin());
	// order rest of the containers
	permutate( permutationVector, *_state_13b7);
	permutate( permutationVector, *_compoundStatement_13b9);
}

void EnterFunctionCondition_13e9::operator()( const Packets_t& states_13ea, const Packets_t& cgs_13ec, Packets_t& states_13ee, Packets_t& cgs_13ef)
{
#ifdef PRINT_INFO
	printLog( "EnterFunctionCondition_13e9" );
#endif
	_state_13f0= &states_13ee;
	_cg_13f1= &cgs_13ef;
	if( ( !states_13ea.empty())&& ( !cgs_13ec.empty()))
		callCreateCB_1468( states_13ea, cgs_13ec);
	_state_13f0->insert( _state_13f0->end(), states_13ea.begin(), states_13ea.end());
	_cg_13f1->insert( _cg_13f1->end(), cgs_13ec.begin(), cgs_13ec.end());
}

void EnterFunctionCondition_13e9::callCreateCB_1468( const Packets_t& states_1433, const Packets_t& conditionalGroups_1436)
{
	Packets_t states_1435;
	Packets_t conditionalBlocks_1438;
	CreateCB_1432 createCB_1432;
	createCB_1432( states_1433, conditionalGroups_1436, states_1435, conditionalBlocks_1438);
	if( ( !states_1435.empty())&& ( !conditionalBlocks_1438.empty()))
		callGetChildStates_146b( states_1435, conditionalBlocks_1438);
}

void EnterFunctionCondition_13e9::callGetChildStates_146b( const Packets_t& states_13b0, const Packets_t& compoundStatements_13b4)
{
	Packets_t states_13b2;
	Packets_t childStates_13b3;
	Packets_t compoundStatements_13b6;
	GetChildStates_13af getChildStates_13af;
	getChildStates_13af( states_13b0, compoundStatements_13b4, states_13b2, childStates_13b3, compoundStatements_13b6);
	if( ( !states_13b2.empty())&& ( !childStates_13b3.empty())&& ( !compoundStatements_13b6.empty()))
		callCallChildren_146e( states_13b2, childStates_13b3, compoundStatements_13b6);
}

void EnterFunctionCondition_13e9::callCallChildren_146e( const Packets_t& states_13f3, const Packets_t& childStates_13f5, const Packets_t& compoundStatements_13f7)
{
	CallChildren_13f2 callChildren_13f2;
	callChildren_13f2( states_13f3, childStates_13f5, compoundStatements_13f7);
}

void CallChildren_13f2::operator()( const Packets_t& states_13f3, const Packets_t& childStates_13f5, const Packets_t& compoundStatements_13f7)
{
#ifdef PRINT_INFO
	printLog( "CallChildren_13f2" );
#endif
	RTTGenerator::Instance()->generateRule(525, "CallChildren");
	processInputPackets( states_13f3, childStates_13f5, compoundStatements_13f7);
}

bool CallChildren_13f2::isInputUnique( const Udm::Object& state_13fd, const Udm::Object& childState_1406, const Udm::Object& compoundStatement_140f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_13ff= _state_13f9.begin(), itChildState_1408= _childState_1402.begin(), itCompoundStatement_1411= _compoundStatement_140b.begin(); itState_13ff!= _state_13f9.end(), itChildState_1408!= _childState_1402.end(), itCompoundStatement_1411!= _compoundStatement_140b.end(); ++itState_13ff, ++itChildState_1408, ++itCompoundStatement_1411)
	{
		if( ( *itState_13ff== state_13fd)&& ( *itChildState_1408== childState_1406)&& ( *itCompoundStatement_1411== compoundStatement_140f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_13f9.push_back( state_13fd);
		_childState_1402.push_back( childState_1406);
		_compoundStatement_140b.push_back( compoundStatement_140f);
	}
	return isUnique;
}

bool CallChildren_13f2::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool CallChildren_13f2::isGuardTrue( SFC::Arg& ChildArg0, SFC::Arg& ChildArg1, SFC::Function& ChildEnter, CyberComposition::Simulink::State& ChildState, SFC::CompoundStatement& CompoundStatement, CyberComposition::Simulink::State& State)
{
	bool Gz_guard= false;
	return ChildArg0.argIndex() == 0 && ChildArg1.argIndex() == 1;;
	return Gz_guard;
}

void CallChildren_13f2::processInputPackets( const Packets_t& states_13f3, const Packets_t& childStates_13f5, const Packets_t& compoundStatements_13f7)
{
	for( Packets_t::const_iterator itState_13fa= states_13f3.begin(), itChildState_1403= childStates_13f5.begin(), itCompoundStatement_140c= compoundStatements_13f7.begin(); itState_13fa!= states_13f3.end(), itChildState_1403!= childStates_13f5.end(), itCompoundStatement_140c!= compoundStatements_13f7.end(); ++itState_13fa, ++itChildState_1403, ++itCompoundStatement_140c)
	{
		bool isUnique= isInputUnique( *itState_13fa, *itChildState_1403, *itCompoundStatement_140c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_13fa, *itChildState_1403, *itCompoundStatement_140c);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CallChildren_13f2::patternMatcher( const Udm::Object& state_13fb, const Udm::Object& childState_1404, const Udm::Object& compoundStatement_140d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_13fb.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1400= CyberComposition::Simulink::State::Cast( state_13fb);
		if( false== Uml::IsDerivedFrom( childState_1404.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State childState_1409= CyberComposition::Simulink::State::Cast( childState_1404);
		if( false== Uml::IsDerivedFrom( compoundStatement_140d.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_1412= SFC::CompoundStatement::Cast( compoundStatement_140d);
		set< SFC::Function> childEnters_1414= childState_1409.enter();
		for( set< SFC::Function>::const_iterator itChildEnters_1415= childEnters_1414.begin(); itChildEnters_1415!= childEnters_1414.end(); ++itChildEnters_1415)
		{
			SFC::Function currChildEnter_1416= *itChildEnters_1415;
			set< SFC::Arg> childArg0s_1417= currChildEnter_1416.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itChildArg0_1418= childArg0s_1417.begin(); itChildArg0_1418!= childArg0s_1417.end(); ++itChildArg0_1418)
			{
				SFC::Arg currChildArg0_1419= *itChildArg0_1418;
				set< SFC::Arg> childArg1s_141a= currChildEnter_1416.Arg_kind_children();
				for( set< SFC::Arg>::const_iterator itChildArg1_141b= childArg1s_141a.begin(); itChildArg1_141b!= childArg1s_141a.end(); ++itChildArg1_141b)
				{
					SFC::Arg currChildArg1_141c= *itChildArg1_141b;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_1420;
					if( !isValidBound(boundObjs_1420, state_1400, true))
						continue;
					currMatch.state_1421= state_1400;
					if( !isValidBound(boundObjs_1420, childState_1409, true))
						continue;
					currMatch.childState_1422= childState_1409;
					if( !isValidBound(boundObjs_1420, compoundStatement_1412, true))
						continue;
					currMatch.compoundStatement_1423= compoundStatement_1412;
					if( !isValidBound(boundObjs_1420, currChildArg0_1419, false))
						continue;
					currMatch.childArg0_1424= currChildArg0_1419;
					if( !isValidBound(boundObjs_1420, currChildArg1_141c, false))
						continue;
					currMatch.childArg1_1425= currChildArg1_141c;
					if( !isValidBound(boundObjs_1420, currChildEnter_1416, false))
						continue;
					currMatch.childEnter_1426= currChildEnter_1416;
					bool Gz_guard= isGuardTrue( currMatch.childArg0_1424, currMatch.childArg1_1425, currMatch.childEnter_1426, currMatch.childState_1422, currMatch.compoundStatement_1423, currMatch.state_1421);
					if( true== Gz_guard)
						_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void CallChildren_13f2::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::FunctionCall newFunctionCall_142d= SFC::FunctionCall::Create( currMatch.compoundStatement_1423, SFC::CompoundStatement::meta_stmnt);
		SFC::ArgVal newArgVal0_142e= SFC::ArgVal::Create( newFunctionCall_142d);
		SFC::Int newTwo_142f= SFC::Int::Create( newArgVal0_142e, SFC::ArgVal::meta_argexpr);
		SFC::ArgVal newArgVal1_1430= SFC::ArgVal::Create( newFunctionCall_142d);
		SFC::Int newZero_1431= SFC::Int::Create( newArgVal1_1430, SFC::ArgVal::meta_argexpr);
		SFC::ArgVal& ArgVal0= newArgVal0_142e;
		SFC::ArgVal& ArgVal1= newArgVal1_1430;
		SFC::Arg& ChildArg0= currMatch.childArg0_1424;
		SFC::Arg& ChildArg1= currMatch.childArg1_1425;
		SFC::Function& ChildEnter= currMatch.childEnter_1426;
		CyberComposition::Simulink::State& ChildState= currMatch.childState_1422;
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_1423;
		SFC::FunctionCall& FunctionCall= newFunctionCall_142d;
		CyberComposition::Simulink::State& State= currMatch.state_1421;
		SFC::Int& Two= newTwo_142f;
		SFC::Int& Zero= newZero_1431;
		{
FunctionCall.RefId() = CompoundStatement.RefId();
};
		{
Zero.val() = 0;
};
		{
ArgVal0.argIndex() = 0;
};
		{
ArgVal1.argIndex() = 1;
};
		{
Two.val() = 2;
};
		{
__int64 statementCount = CompoundStatement.statementCount();
FunctionCall.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		{
FunctionCall.argCount() = 2;
};
		newArgVal0_142e.arg()+= currMatch.childArg0_1424;
		newArgVal1_1430.arg()+= currMatch.childArg1_1425;
		newFunctionCall_142d.callee()= currMatch.childEnter_1426;
	}
}

void CreateCB_1432::operator()( const Packets_t& states_1433, const Packets_t& conditionalGroups_1436, Packets_t& states_1435, Packets_t& conditionalBlocks_1438)
{
#ifdef PRINT_INFO
	printLog( "CreateCB_1432" );
#endif
	RTTGenerator::Instance()->generateRule(555, "CreateCB");
	_state_1439= &states_1435;
	_conditionalBlock_143a= &conditionalBlocks_1438;
	processInputPackets( states_1433, conditionalGroups_1436);
}

bool CreateCB_1432::isInputUnique( const Udm::Object& state_143f, const Udm::Object& conditionalGroup_1448)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1441= _state_143b.begin(), itConditionalGroup_144a= _conditionalGroup_1444.begin(); itState_1441!= _state_143b.end(), itConditionalGroup_144a!= _conditionalGroup_1444.end(); ++itState_1441, ++itConditionalGroup_144a)
	{
		if( ( *itState_1441== state_143f)&& ( *itConditionalGroup_144a== conditionalGroup_1448))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_143b.push_back( state_143f);
		_conditionalGroup_1444.push_back( conditionalGroup_1448);
	}
	return isUnique;
}

bool CreateCB_1432::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateCB_1432::processInputPackets( const Packets_t& states_1433, const Packets_t& conditionalGroups_1436)
{
	for( Packets_t::const_iterator itState_143c= states_1433.begin(), itConditionalGroup_1445= conditionalGroups_1436.begin(); itState_143c!= states_1433.end(), itConditionalGroup_1445!= conditionalGroups_1436.end(); ++itState_143c, ++itConditionalGroup_1445)
	{
		bool isUnique= isInputUnique( *itState_143c, *itConditionalGroup_1445);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_143c, *itConditionalGroup_1445);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateCB_1432::patternMatcher( const Udm::Object& state_143d, const Udm::Object& conditionalGroup_1446)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_143d.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1442= CyberComposition::Simulink::State::Cast( state_143d);
		if( false== Uml::IsDerivedFrom( conditionalGroup_1446.type(), SFC::ConditionalGroup::meta))
			continue;
		SFC::ConditionalGroup conditionalGroup_144b= SFC::ConditionalGroup::Cast( conditionalGroup_1446);
		Udm::Object conditionalGroupParent_144d= conditionalGroup_144b.container();
		if( false== Uml::IsDerivedFrom( conditionalGroupParent_144d.type(), SFC::Function::meta))
			continue;
		SFC::Function functionConditionalGroup_144e= SFC::Function::Cast( conditionalGroupParent_144d);
		Udm::Object functionParent_144f= functionConditionalGroup_144e.container();
		if( false== Uml::IsDerivedFrom( functionParent_144f.type(), SFC::Program::meta))
			continue;
		SFC::Program programFunction_1450= SFC::Program::Cast( functionParent_144f);
		set< SFC::StateVar> stateVars_1451= programFunction_1450.StateVar_kind_children();
		for( set< SFC::StateVar>::const_iterator itStateVar_1452= stateVars_1451.begin(); itStateVar_1452!= stateVars_1451.end(); ++itStateVar_1452)
		{
			SFC::StateVar currStateVar_1453= *itStateVar_1452;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1457;
			if( !isValidBound(boundObjs_1457, state_1442, true))
				continue;
			currMatch.state_1458= state_1442;
			if( !isValidBound(boundObjs_1457, conditionalGroup_144b, true))
				continue;
			currMatch.conditionalGroup_1459= conditionalGroup_144b;
			if( !isValidBound(boundObjs_1457, functionConditionalGroup_144e, false))
				continue;
			currMatch.function_145a= functionConditionalGroup_144e;
			if( !isValidBound(boundObjs_1457, programFunction_1450, false))
				continue;
			currMatch.program_145b= programFunction_1450;
			if( !isValidBound(boundObjs_1457, currStateVar_1453, false))
				continue;
			currMatch.stateVar_145c= currStateVar_1453;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateCB_1432::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_145d= SFC::ConditionalBlock::Create( currMatch.conditionalGroup_1459, SFC::ConditionalGroup::meta_stmnt);
		SFC::UserCode newUserCode_145e= SFC::UserCode::Create( newConditionalBlock_145d, SFC::ConditionalBlock::meta_cond);
		SFC::BinaryExprs newLE_145f= SFC::BinaryExprs::Create( newUserCode_145e, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newIndexOp_1460= SFC::BinaryExprs::Create( newLE_145f, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef_1461= SFC::ArgDeclRef::Create( newIndexOp_1460, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newZero2_1462= SFC::Int::Create( newIndexOp_1460, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newZero1_1463= SFC::Int::Create( newLE_145f, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_1461;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_145d;
		SFC::ConditionalGroup& ConditionalGroup= currMatch.conditionalGroup_1459;
		SFC::Function& Function= currMatch.function_145a;
		SFC::BinaryExprs& IndexOp= newIndexOp_1460;
		SFC::BinaryExprs& LE= newLE_145f;
		SFC::Program& Program= currMatch.program_145b;
		CyberComposition::Simulink::State& State= currMatch.state_1458;
		SFC::StateVar& StateVar= currMatch.stateVar_145c;
		SFC::UserCode& UserCode= newUserCode_145e;
		SFC::Int& Zero1= newZero1_1463;
		SFC::Int& Zero2= newZero2_1462;
		{
ConditionalBlock.RefId() = UserCode.RefId() = ConditionalGroup.RefId();
};
		{
Zero2.val() = 0;
};
		{
IndexOp.op() = "[";
};
		{
Zero1.val() = 0;
};
		{
LE.op() = "<=";
};
		{
__int64 statementCount = ConditionalGroup.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
ConditionalGroup.statementCount() = statementCount;
};
		newArgDeclRef_1461.argdecl()= currMatch.stateVar_145c;
		outputAppender( currMatch.state_1458, newConditionalBlock_145d);
	}
}

void CreateCB_1432::outputAppender( const CyberComposition::Simulink::State& state_1464, const SFC::ConditionalBlock& conditionalBlock_1466)
{
	_state_1439->push_back( state_1464);
	_conditionalBlock_143a->push_back( conditionalBlock_1466);
}

void CreateCG_1472::operator()( const Packets_t& states_1473, const Packets_t& execs_1476, Packets_t& states_1475, Packets_t& conditionalGroups_1478)
{
#ifdef PRINT_INFO
	printLog( "CreateCG_1472" );
#endif
	RTTGenerator::Instance()->generateRule(585, "CreateCG");
	_state_1479= &states_1475;
	_conditionalGroup_147a= &conditionalGroups_1478;
	processInputPackets( states_1473, execs_1476);
}

bool CreateCG_1472::isInputUnique( const Udm::Object& state_147f, const Udm::Object& exec_1488)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1481= _state_147b.begin(), itExec_148a= _exec_1484.begin(); itState_1481!= _state_147b.end(), itExec_148a!= _exec_1484.end(); ++itState_1481, ++itExec_148a)
	{
		if( ( *itState_1481== state_147f)&& ( *itExec_148a== exec_1488))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_147b.push_back( state_147f);
		_exec_1484.push_back( exec_1488);
	}
	return isUnique;
}

bool CreateCG_1472::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateCG_1472::processInputPackets( const Packets_t& states_1473, const Packets_t& execs_1476)
{
	for( Packets_t::const_iterator itState_147c= states_1473.begin(), itExec_1485= execs_1476.begin(); itState_147c!= states_1473.end(), itExec_1485!= execs_1476.end(); ++itState_147c, ++itExec_1485)
	{
		bool isUnique= isInputUnique( *itState_147c, *itExec_1485);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_147c, *itExec_1485);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateCG_1472::patternMatcher( const Udm::Object& state_147d, const Udm::Object& exec_1486)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_147d.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1482= CyberComposition::Simulink::State::Cast( state_147d);
		if( false== Uml::IsDerivedFrom( exec_1486.type(), SFC::Function::meta))
			continue;
		SFC::Function exec_148b= SFC::Function::Cast( exec_1486);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1490;
		if( !isValidBound(boundObjs_1490, state_1482, true))
			continue;
		currMatch.state_1491= state_1482;
		if( !isValidBound(boundObjs_1490, exec_148b, true))
			continue;
		currMatch.exec_1492= exec_148b;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateCG_1472::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalGroup newConditionalGroup_1493= SFC::ConditionalGroup::Create( currMatch.exec_1492, SFC::Function::meta_stmnt);
		SFC::ConditionalGroup& ConditionalGroup= newConditionalGroup_1493;
		SFC::Function& Exec= currMatch.exec_1492;
		CyberComposition::Simulink::State& State= currMatch.state_1491;
		{
ConditionalGroup.RefId() = Exec.RefId();
};
		{
__int64 statementCount = Exec.statementCount();
ConditionalGroup.statementIndex() = statementCount++;
Exec.statementCount() = statementCount;
};
		outputAppender( currMatch.state_1491, newConditionalGroup_1493);
	}
}

void CreateCG_1472::outputAppender( const CyberComposition::Simulink::State& state_1494, const SFC::ConditionalGroup& conditionalGroup_1496)
{
	_state_1479->push_back( state_1494);
	_conditionalGroup_147a->push_back( conditionalGroup_1496);
}

void TopLevelState_1498::operator()( const Packets_t& states_1499, const Packets_t& css_149b, Packets_t& states_149d, Packets_t& css_149e, Packets_t& states_149f, Packets_t& css_14a0)
{
#ifdef PRINT_INFO
	printLog( "TopLevelState_1498" );
#endif
	_state_14a1= &states_149d;
	_cs_14a2= &css_149e;
	_state_14a3= &states_149f;
	_cs_14a4= &css_14a0;
	for( Packets_t::const_iterator itstate_14a6= states_1499.begin(), itcs_14ad= css_149b.begin(); itstate_14a6!= states_1499.end(), itcs_14ad!= css_149b.end(); ++itstate_14a6, ++itcs_14ad)
	{
		bool isUnique= isInputUnique( *itstate_14a6, *itcs_14ad);
		if( !isUnique)
			continue;
		Packets_t onestate_14aa( 1, *itstate_14a6);
		Packets_t onecs_14b1( 1, *itcs_14ad);
		executeOne( onestate_14aa, onecs_14b1);
	}
}

void TopLevelState_1498::executeOne( const Packets_t& states_1499, const Packets_t& css_149b)
{
	Packets_t states_14b6;
	Packets_t compoundStatements_14b9;
	IsTopLevelState_14b3 isTopLevelState_14b3;
	bool isMatchIsTopLevelState_14b3= isTopLevelState_14b3( states_1499, css_149b, states_14b6, compoundStatements_14b9);
	_state_14a1->insert( _state_14a1->end(), states_14b6.begin(), states_14b6.end());
	_cs_14a2->insert( _cs_14a2->end(), compoundStatements_14b9.begin(), compoundStatements_14b9.end());
	if( isMatchIsTopLevelState_14b3)
		return;
	Packets_t states_14df;
	Packets_t compoundStatements_14e2;
	Otherwise_14dc otherwise_14dc;
	bool isMatchOtherwise_14dc= otherwise_14dc( states_1499, css_149b, states_14df, compoundStatements_14e2);
	_state_14a3->insert( _state_14a3->end(), states_14df.begin(), states_14df.end());
	_cs_14a4->insert( _cs_14a4->end(), compoundStatements_14e2.begin(), compoundStatements_14e2.end());
	if( isMatchOtherwise_14dc)
		return;
}

bool TopLevelState_1498::isInputUnique( const Udm::Object& state_14a7, const Udm::Object& cs_14ae)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_14a9= _state_14a5.begin(), itcs_14b0= _cs_14ac.begin(); itstate_14a9!= _state_14a5.end(), itcs_14b0!= _cs_14ac.end(); ++itstate_14a9, ++itcs_14b0)
	{
		if( ( *itstate_14a9== state_14a7)&& ( *itcs_14b0== cs_14ae))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_14a5.push_back( state_14a7);
		_cs_14ac.push_back( cs_14ae);
	}
	return isUnique;
}

bool IsTopLevelState_14b3::operator()( const Packets_t& states_14b4, const Packets_t& compoundStatements_14b7, Packets_t& states_14b6, Packets_t& compoundStatements_14b9)
{
#ifdef PRINT_INFO
	printLog( "IsTopLevelState_14b3" );
#endif
	_state_14ba= &states_14b6;
	_compoundStatement_14bb= &compoundStatements_14b9;
	processInputPackets( states_14b4, compoundStatements_14b7);
	if( false== _matches.empty())
		return true;
	return false;
}

bool IsTopLevelState_14b3::isInputUnique( const Udm::Object& state_14c0, const Udm::Object& compoundStatement_14c9)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_14c2= _state_14bc.begin(), itCompoundStatement_14cb= _compoundStatement_14c5.begin(); itState_14c2!= _state_14bc.end(), itCompoundStatement_14cb!= _compoundStatement_14c5.end(); ++itState_14c2, ++itCompoundStatement_14cb)
	{
		if( ( *itState_14c2== state_14c0)&& ( *itCompoundStatement_14cb== compoundStatement_14c9))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_14bc.push_back( state_14c0);
		_compoundStatement_14c5.push_back( compoundStatement_14c9);
	}
	return isUnique;
}

bool IsTopLevelState_14b3::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void IsTopLevelState_14b3::processInputPackets( const Packets_t& states_14b4, const Packets_t& compoundStatements_14b7)
{
	for( Packets_t::const_iterator itState_14bd= states_14b4.begin(), itCompoundStatement_14c6= compoundStatements_14b7.begin(); itState_14bd!= states_14b4.end(), itCompoundStatement_14c6!= compoundStatements_14b7.end(); ++itState_14bd, ++itCompoundStatement_14c6)
	{
		bool isUnique= isInputUnique( *itState_14bd, *itCompoundStatement_14c6);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_14bd, *itCompoundStatement_14c6);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_14d5, currMatch.compoundStatement_14d6);
	}
}

bool IsTopLevelState_14b3::patternMatcher( const Udm::Object& state_14be, const Udm::Object& compoundStatement_14c7)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_14be.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_14c3= CyberComposition::Simulink::State::Cast( state_14be);
		if( false== Uml::IsDerivedFrom( compoundStatement_14c7.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_14cc= SFC::CompoundStatement::Cast( compoundStatement_14c7);
		set< CyberComposition::Simulink::ConnectorRef> connectorRefs_14ce= state_14c3.referedbyConnectorRef();
		for( set< CyberComposition::Simulink::ConnectorRef>::const_iterator itConnectorRefs_14cf= connectorRefs_14ce.begin(); itConnectorRefs_14cf!= connectorRefs_14ce.end(); ++itConnectorRefs_14cf)
		{
			CyberComposition::Simulink::ConnectorRef currConnectorRef_14d0= *itConnectorRefs_14cf;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_14d4;
			if( !isValidBound(boundObjs_14d4, state_14c3, true))
				continue;
			currMatch.state_14d5= state_14c3;
			if( !isValidBound(boundObjs_14d4, compoundStatement_14cc, true))
				continue;
			currMatch.compoundStatement_14d6= compoundStatement_14cc;
			if( !isValidBound(boundObjs_14d4, currConnectorRef_14d0, false))
				continue;
			currMatch.connectorRef_14d7= currConnectorRef_14d0;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void IsTopLevelState_14b3::outputAppender( const CyberComposition::Simulink::State& state_14d8, const SFC::CompoundStatement& compoundStatement_14da)
{
	_state_14ba->push_back( state_14d8);
	_compoundStatement_14bb->push_back( compoundStatement_14da);
}

bool Otherwise_14dc::operator()( const Packets_t& states_14dd, const Packets_t& compoundStatements_14e0, Packets_t& states_14df, Packets_t& compoundStatements_14e2)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_14dc" );
#endif
	_state_14e3= &states_14df;
	_compoundStatement_14e4= &compoundStatements_14e2;
	processInputPackets( states_14dd, compoundStatements_14e0);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_14dc::isInputUnique( const Udm::Object& state_14e9, const Udm::Object& compoundStatement_14f2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_14eb= _state_14e5.begin(), itCompoundStatement_14f4= _compoundStatement_14ee.begin(); itState_14eb!= _state_14e5.end(), itCompoundStatement_14f4!= _compoundStatement_14ee.end(); ++itState_14eb, ++itCompoundStatement_14f4)
	{
		if( ( *itState_14eb== state_14e9)&& ( *itCompoundStatement_14f4== compoundStatement_14f2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_14e5.push_back( state_14e9);
		_compoundStatement_14ee.push_back( compoundStatement_14f2);
	}
	return isUnique;
}

bool Otherwise_14dc::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_14dc::processInputPackets( const Packets_t& states_14dd, const Packets_t& compoundStatements_14e0)
{
	for( Packets_t::const_iterator itState_14e6= states_14dd.begin(), itCompoundStatement_14ef= compoundStatements_14e0.begin(); itState_14e6!= states_14dd.end(), itCompoundStatement_14ef!= compoundStatements_14e0.end(); ++itState_14e6, ++itCompoundStatement_14ef)
	{
		bool isUnique= isInputUnique( *itState_14e6, *itCompoundStatement_14ef);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_14e6, *itCompoundStatement_14ef);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_14fb, currMatch.compoundStatement_14fc);
	}
}

bool Otherwise_14dc::patternMatcher( const Udm::Object& state_14e7, const Udm::Object& compoundStatement_14f0)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_14e7.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_14ec= CyberComposition::Simulink::State::Cast( state_14e7);
		if( false== Uml::IsDerivedFrom( compoundStatement_14f0.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_14f5= SFC::CompoundStatement::Cast( compoundStatement_14f0);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_14fa;
		if( !isValidBound(boundObjs_14fa, state_14ec, true))
			continue;
		currMatch.state_14fb= state_14ec;
		if( !isValidBound(boundObjs_14fa, compoundStatement_14f5, true))
			continue;
		currMatch.compoundStatement_14fc= compoundStatement_14f5;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_14dc::outputAppender( const CyberComposition::Simulink::State& state_14fd, const SFC::CompoundStatement& compoundStatement_14ff)
{
	_state_14e3->push_back( state_14fd);
	_compoundStatement_14e4->push_back( compoundStatement_14ff);
}

void DefaultCondition_1501::operator()( const Packets_t& states_1502, const Packets_t& compoundStatements_1506, Packets_t& states_1504, Packets_t& functions_1505, Packets_t& conditionalBlocks_1508)
{
#ifdef PRINT_INFO
	printLog( "DefaultCondition_1501" );
#endif
	RTTGenerator::Instance()->generateRule(607, "DefaultCondition");
	_state_1509= &states_1504;
	_function_150a= &functions_1505;
	_conditionalBlock_150b= &conditionalBlocks_1508;
	processInputPackets( states_1502, compoundStatements_1506);
}

bool DefaultCondition_1501::isInputUnique( const Udm::Object& state_1510, const Udm::Object& compoundStatement_1519)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1512= _state_150c.begin(), itCompoundStatement_151b= _compoundStatement_1515.begin(); itState_1512!= _state_150c.end(), itCompoundStatement_151b!= _compoundStatement_1515.end(); ++itState_1512, ++itCompoundStatement_151b)
	{
		if( ( *itState_1512== state_1510)&& ( *itCompoundStatement_151b== compoundStatement_1519))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_150c.push_back( state_1510);
		_compoundStatement_1515.push_back( compoundStatement_1519);
	}
	return isUnique;
}

void DefaultCondition_1501::processInputPackets( const Packets_t& states_1502, const Packets_t& compoundStatements_1506)
{
	for( Packets_t::const_iterator itState_150d= states_1502.begin(), itCompoundStatement_1516= compoundStatements_1506.begin(); itState_150d!= states_1502.end(), itCompoundStatement_1516!= compoundStatements_1506.end(); ++itState_150d, ++itCompoundStatement_1516)
	{
		bool isUnique= isInputUnique( *itState_150d, *itCompoundStatement_1516);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_150d, *itCompoundStatement_1516);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool DefaultCondition_1501::patternMatcher( const Udm::Object& state_150e, const Udm::Object& compoundStatement_1517)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_150e.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1513= CyberComposition::Simulink::State::Cast( state_150e);
		if( false== Uml::IsDerivedFrom( compoundStatement_1517.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_151c= SFC::CompoundStatement::Cast( compoundStatement_1517);
		set< SFC::Function> functions_151e= state_1513.exec();
		for( set< SFC::Function>::const_iterator itFunctions_151f= functions_151e.begin(); itFunctions_151f!= functions_151e.end(); ++itFunctions_151f)
		{
			SFC::Function currFunction_1520= *itFunctions_151f;
			Match currMatch;
			currMatch.state_1522= state_1513;
			currMatch.compoundStatement_1523= compoundStatement_151c;
			currMatch.function_1524= currFunction_1520;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void DefaultCondition_1501::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_1525= SFC::ConditionalBlock::Create( currMatch.compoundStatement_1523, SFC::CompoundStatement::meta_stmnt);
		SFC::UserCode newUserCode_1526= SFC::UserCode::Create( newConditionalBlock_1525, SFC::ConditionalBlock::meta_cond);
		SFC::Int newOne_1527= SFC::Int::Create( newUserCode_1526, SFC::UserCode::meta_codeexpr);
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_1523;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_1525;
		SFC::Function& Function= currMatch.function_1524;
		SFC::Int& One= newOne_1527;
		CyberComposition::Simulink::State& State= currMatch.state_1522;
		SFC::UserCode& UserCode= newUserCode_1526;
		{
ConditionalBlock.RefId() = UserCode.RefId() = CompoundStatement.RefId();
};
		{
One.val() = 1;
};
		{
__int64 statementCount = CompoundStatement.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		outputAppender( currMatch.state_1522, currMatch.function_1524, newConditionalBlock_1525);
	}
}

void DefaultCondition_1501::outputAppender( const CyberComposition::Simulink::State& state_1528, const SFC::Function& function_152a, const SFC::ConditionalBlock& conditionalBlock_152c)
{
	_state_1509->push_back( state_1528);
	_function_150a->push_back( function_152a);
	_conditionalBlock_150b->push_back( conditionalBlock_152c);
}

void ChildStateType_152e::operator()( const Packets_t& states_152f, const Packets_t& css_1531, Packets_t& states_1533, Packets_t& css_1534, Packets_t& states_1535, Packets_t& css_1536)
{
#ifdef PRINT_INFO
	printLog( "ChildStateType_152e" );
#endif
	_state_1537= &states_1533;
	_cs_1538= &css_1534;
	_state_1539= &states_1535;
	_cs_153a= &css_1536;
	for( Packets_t::const_iterator itstate_153c= states_152f.begin(), itcs_1543= css_1531.begin(); itstate_153c!= states_152f.end(), itcs_1543!= css_1531.end(); ++itstate_153c, ++itcs_1543)
	{
		bool isUnique= isInputUnique( *itstate_153c, *itcs_1543);
		if( !isUnique)
			continue;
		Packets_t onestate_1540( 1, *itstate_153c);
		Packets_t onecs_1547( 1, *itcs_1543);
		executeOne( onestate_1540, onecs_1547);
	}
}

void ChildStateType_152e::executeOne( const Packets_t& states_152f, const Packets_t& css_1531)
{
	Packets_t states_154c;
	Packets_t compoundStatements_154f;
	ChildANDStates_1549 childANDStates_1549;
	bool isMatchChildANDStates_1549= childANDStates_1549( states_152f, css_1531, states_154c, compoundStatements_154f);
	_state_1537->insert( _state_1537->end(), states_154c.begin(), states_154c.end());
	_cs_1538->insert( _cs_1538->end(), compoundStatements_154f.begin(), compoundStatements_154f.end());
	if( isMatchChildANDStates_1549)
		return;
	Packets_t states_1578;
	Packets_t compoundStatements_157b;
	Otherwise_1575 otherwise_1575;
	bool isMatchOtherwise_1575= otherwise_1575( states_152f, css_1531, states_1578, compoundStatements_157b);
	_state_1539->insert( _state_1539->end(), states_1578.begin(), states_1578.end());
	_cs_153a->insert( _cs_153a->end(), compoundStatements_157b.begin(), compoundStatements_157b.end());
	if( isMatchOtherwise_1575)
		return;
}

bool ChildStateType_152e::isInputUnique( const Udm::Object& state_153d, const Udm::Object& cs_1544)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_153f= _state_153b.begin(), itcs_1546= _cs_1542.begin(); itstate_153f!= _state_153b.end(), itcs_1546!= _cs_1542.end(); ++itstate_153f, ++itcs_1546)
	{
		if( ( *itstate_153f== state_153d)&& ( *itcs_1546== cs_1544))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_153b.push_back( state_153d);
		_cs_1542.push_back( cs_1544);
	}
	return isUnique;
}

bool ChildANDStates_1549::operator()( const Packets_t& states_154a, const Packets_t& compoundStatements_154d, Packets_t& states_154c, Packets_t& compoundStatements_154f)
{
#ifdef PRINT_INFO
	printLog( "ChildANDStates_1549" );
#endif
	_state_1550= &states_154c;
	_compoundStatement_1551= &compoundStatements_154f;
	processInputPackets( states_154a, compoundStatements_154d);
	if( false== _matches.empty())
		return true;
	return false;
}

bool ChildANDStates_1549::isInputUnique( const Udm::Object& state_1556, const Udm::Object& compoundStatement_155f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1558= _state_1552.begin(), itCompoundStatement_1561= _compoundStatement_155b.begin(); itState_1558!= _state_1552.end(), itCompoundStatement_1561!= _compoundStatement_155b.end(); ++itState_1558, ++itCompoundStatement_1561)
	{
		if( ( *itState_1558== state_1556)&& ( *itCompoundStatement_1561== compoundStatement_155f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1552.push_back( state_1556);
		_compoundStatement_155b.push_back( compoundStatement_155f);
	}
	return isUnique;
}

bool ChildANDStates_1549::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool ChildANDStates_1549::isGuardTrue( CyberComposition::Simulink::State& ChildState, SFC::CompoundStatement& CompoundStatement, CyberComposition::Simulink::State& State)
{
	bool Gz_guard= false;
	return static_cast< std::string >( ChildState.Decomposition() ) == "AND_STATE";;
	return Gz_guard;
}

void ChildANDStates_1549::processInputPackets( const Packets_t& states_154a, const Packets_t& compoundStatements_154d)
{
	for( Packets_t::const_iterator itState_1553= states_154a.begin(), itCompoundStatement_155c= compoundStatements_154d.begin(); itState_1553!= states_154a.end(), itCompoundStatement_155c!= compoundStatements_154d.end(); ++itState_1553, ++itCompoundStatement_155c)
	{
		bool isUnique= isInputUnique( *itState_1553, *itCompoundStatement_155c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1553, *itCompoundStatement_155c);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_156b, currMatch.compoundStatement_156c);
	}
}

bool ChildANDStates_1549::patternMatcher( const Udm::Object& state_1554, const Udm::Object& compoundStatement_155d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1554.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1559= CyberComposition::Simulink::State::Cast( state_1554);
		if( false== Uml::IsDerivedFrom( compoundStatement_155d.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_1562= SFC::CompoundStatement::Cast( compoundStatement_155d);
		set< CyberComposition::Simulink::State> childStates_1564= state_1559.State_kind_children();
		for( set< CyberComposition::Simulink::State>::const_iterator itChildState_1565= childStates_1564.begin(); itChildState_1565!= childStates_1564.end(); ++itChildState_1565)
		{
			CyberComposition::Simulink::State currChildState_1566= *itChildState_1565;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_156a;
			if( !isValidBound(boundObjs_156a, state_1559, true))
				continue;
			currMatch.state_156b= state_1559;
			if( !isValidBound(boundObjs_156a, compoundStatement_1562, true))
				continue;
			currMatch.compoundStatement_156c= compoundStatement_1562;
			if( !isValidBound(boundObjs_156a, currChildState_1566, false))
				continue;
			currMatch.childState_156d= currChildState_1566;
			bool Gz_guard= isGuardTrue( currMatch.childState_156d, currMatch.compoundStatement_156c, currMatch.state_156b);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void ChildANDStates_1549::outputAppender( const CyberComposition::Simulink::State& state_1571, const SFC::CompoundStatement& compoundStatement_1573)
{
	_state_1550->push_back( state_1571);
	_compoundStatement_1551->push_back( compoundStatement_1573);
}

bool Otherwise_1575::operator()( const Packets_t& states_1576, const Packets_t& compoundStatements_1579, Packets_t& states_1578, Packets_t& compoundStatements_157b)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_1575" );
#endif
	_state_157c= &states_1578;
	_compoundStatement_157d= &compoundStatements_157b;
	processInputPackets( states_1576, compoundStatements_1579);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_1575::isInputUnique( const Udm::Object& state_1582, const Udm::Object& compoundStatement_158b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1584= _state_157e.begin(), itCompoundStatement_158d= _compoundStatement_1587.begin(); itState_1584!= _state_157e.end(), itCompoundStatement_158d!= _compoundStatement_1587.end(); ++itState_1584, ++itCompoundStatement_158d)
	{
		if( ( *itState_1584== state_1582)&& ( *itCompoundStatement_158d== compoundStatement_158b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_157e.push_back( state_1582);
		_compoundStatement_1587.push_back( compoundStatement_158b);
	}
	return isUnique;
}

bool Otherwise_1575::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_1575::processInputPackets( const Packets_t& states_1576, const Packets_t& compoundStatements_1579)
{
	for( Packets_t::const_iterator itState_157f= states_1576.begin(), itCompoundStatement_1588= compoundStatements_1579.begin(); itState_157f!= states_1576.end(), itCompoundStatement_1588!= compoundStatements_1579.end(); ++itState_157f, ++itCompoundStatement_1588)
	{
		bool isUnique= isInputUnique( *itState_157f, *itCompoundStatement_1588);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_157f, *itCompoundStatement_1588);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_1594, currMatch.compoundStatement_1595);
	}
}

bool Otherwise_1575::patternMatcher( const Udm::Object& state_1580, const Udm::Object& compoundStatement_1589)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1580.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1585= CyberComposition::Simulink::State::Cast( state_1580);
		if( false== Uml::IsDerivedFrom( compoundStatement_1589.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_158e= SFC::CompoundStatement::Cast( compoundStatement_1589);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1593;
		if( !isValidBound(boundObjs_1593, state_1585, true))
			continue;
		currMatch.state_1594= state_1585;
		if( !isValidBound(boundObjs_1593, compoundStatement_158e, true))
			continue;
		currMatch.compoundStatement_1595= compoundStatement_158e;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_1575::outputAppender( const CyberComposition::Simulink::State& state_1596, const SFC::CompoundStatement& compoundStatement_1598)
{
	_state_157c->push_back( state_1596);
	_compoundStatement_157d->push_back( compoundStatement_1598);
}

void CallActiveChildExec_159a::operator()( const Packets_t& states_159b, const Packets_t& css_159d, Packets_t& states_159f, Packets_t& css_15a0)
{
#ifdef PRINT_INFO
	printLog( "CallActiveChildExec_159a" );
#endif
	_state_15a1= &states_159f;
	_cs_15a2= &css_15a0;
	if( ( !states_159b.empty())&& ( !css_159d.empty()))
		callGetChildStates_15e0( states_159b, css_159d);
	_state_15a1->insert( _state_15a1->end(), states_159b.begin(), states_159b.end());
	_cs_15a2->insert( _cs_15a2->end(), css_159d.begin(), css_159d.end());
}

void CallActiveChildExec_159a::callGetChildStates_15e0( const Packets_t& states_13b0, const Packets_t& compoundStatements_13b4)
{
	Packets_t states_13b2;
	Packets_t childStates_13b3;
	Packets_t compoundStatements_13b6;
	GetChildStates_13af getChildStates_13af;
	getChildStates_13af( states_13b0, compoundStatements_13b4, states_13b2, childStates_13b3, compoundStatements_13b6);
	if( ( !states_13b2.empty())&& ( !childStates_13b3.empty())&& ( !compoundStatements_13b6.empty()))
		callExecActiveChildState_15e3( states_13b2, childStates_13b3, compoundStatements_13b6);
}

void CallActiveChildExec_159a::callExecActiveChildState_15e3( const Packets_t& states_15a4, const Packets_t& childStates_15a6, const Packets_t& compoundStatements_15a8)
{
	ExecActiveChildState_15a3 execActiveChildState_15a3;
	execActiveChildState_15a3( states_15a4, childStates_15a6, compoundStatements_15a8);
}

void ExecActiveChildState_15a3::operator()( const Packets_t& states_15a4, const Packets_t& childStates_15a6, const Packets_t& compoundStatements_15a8)
{
#ifdef PRINT_INFO
	printLog( "ExecActiveChildState_15a3" );
#endif
	RTTGenerator::Instance()->generateRule(641, "ExecActiveChildState");
	processInputPackets( states_15a4, childStates_15a6, compoundStatements_15a8);
}

bool ExecActiveChildState_15a3::isInputUnique( const Udm::Object& state_15ae, const Udm::Object& childState_15b7, const Udm::Object& compoundStatement_15c0)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_15b0= _state_15aa.begin(), itChildState_15b9= _childState_15b3.begin(), itCompoundStatement_15c2= _compoundStatement_15bc.begin(); itState_15b0!= _state_15aa.end(), itChildState_15b9!= _childState_15b3.end(), itCompoundStatement_15c2!= _compoundStatement_15bc.end(); ++itState_15b0, ++itChildState_15b9, ++itCompoundStatement_15c2)
	{
		if( ( *itState_15b0== state_15ae)&& ( *itChildState_15b9== childState_15b7)&& ( *itCompoundStatement_15c2== compoundStatement_15c0))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_15aa.push_back( state_15ae);
		_childState_15b3.push_back( childState_15b7);
		_compoundStatement_15bc.push_back( compoundStatement_15c0);
	}
	return isUnique;
}

void ExecActiveChildState_15a3::processInputPackets( const Packets_t& states_15a4, const Packets_t& childStates_15a6, const Packets_t& compoundStatements_15a8)
{
	for( Packets_t::const_iterator itState_15ab= states_15a4.begin(), itChildState_15b4= childStates_15a6.begin(), itCompoundStatement_15bd= compoundStatements_15a8.begin(); itState_15ab!= states_15a4.end(), itChildState_15b4!= childStates_15a6.end(), itCompoundStatement_15bd!= compoundStatements_15a8.end(); ++itState_15ab, ++itChildState_15b4, ++itCompoundStatement_15bd)
	{
		bool isUnique= isInputUnique( *itState_15ab, *itChildState_15b4, *itCompoundStatement_15bd);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_15ab, *itChildState_15b4, *itCompoundStatement_15bd);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ExecActiveChildState_15a3::patternMatcher( const Udm::Object& state_15ac, const Udm::Object& childState_15b5, const Udm::Object& compoundStatement_15be)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_15ac.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_15b1= CyberComposition::Simulink::State::Cast( state_15ac);
		if( false== Uml::IsDerivedFrom( childState_15b5.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State childState_15ba= CyberComposition::Simulink::State::Cast( childState_15b5);
		if( false== Uml::IsDerivedFrom( compoundStatement_15be.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_15c3= SFC::CompoundStatement::Cast( compoundStatement_15be);
		set< SFC::StateLabel> childStateLabels_15c5= childState_15ba.src();
		for( set< SFC::StateLabel>::const_iterator itChildStateLabels_15c6= childStateLabels_15c5.begin(); itChildStateLabels_15c6!= childStateLabels_15c5.end(); ++itChildStateLabels_15c6)
		{
			SFC::StateLabel currChildStateLabel_15c7= *itChildStateLabels_15c6;
			set< SFC::Function> functions_15c8= childState_15ba.exec();
			for( set< SFC::Function>::const_iterator itFunctions_15c9= functions_15c8.begin(); itFunctions_15c9!= functions_15c8.end(); ++itFunctions_15c9)
			{
				SFC::Function currFunction_15ca= *itFunctions_15c9;
				Udm::Object functionParent_15cb= currFunction_15ca.container();
				if( false== Uml::IsDerivedFrom( functionParent_15cb.type(), SFC::Program::meta))
					continue;
				SFC::Program programFunction_15cc= SFC::Program::Cast( functionParent_15cb);
				set< SFC::StateVar> stateVars_15cd= programFunction_15cc.StateVar_kind_children();
				for( set< SFC::StateVar>::const_iterator itStateVar_15ce= stateVars_15cd.begin(); itStateVar_15ce!= stateVars_15cd.end(); ++itStateVar_15ce)
				{
					SFC::StateVar currStateVar_15cf= *itStateVar_15ce;
					set< SFC::StateLabel> stateLabels_15d0= state_15b1.src();
					for( set< SFC::StateLabel>::const_iterator itStateLabels_15d1= stateLabels_15d0.begin(); itStateLabels_15d1!= stateLabels_15d0.end(); ++itStateLabels_15d1)
					{
						SFC::StateLabel currStateLabel_15d2= *itStateLabels_15d1;
						Match currMatch;
						currMatch.state_15d4= state_15b1;
						currMatch.childState_15d5= childState_15ba;
						currMatch.compoundStatement_15d6= compoundStatement_15c3;
						currMatch.stateLabel_15d7= currStateLabel_15d2;
						currMatch.childStateLabel_15d8= currChildStateLabel_15c7;
						currMatch.function_15d9= currFunction_15ca;
						currMatch.program_15da= programFunction_15cc;
						currMatch.stateVar_15db= currStateVar_15cf;
						_matches.push_back( currMatch);
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void ExecActiveChildState_15a3::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_15dc= SFC::ConditionalBlock::Create( currMatch.compoundStatement_15d6, SFC::CompoundStatement::meta_stmnt);
		SFC::Return newReturn_15dd= SFC::Return::Create( newConditionalBlock_15dc, SFC::ConditionalBlock::meta_stmnt);
		SFC::FunctionCall newFunctionCall_15de= SFC::FunctionCall::Create( newConditionalBlock_15dc, SFC::ConditionalBlock::meta_stmnt);
		SFC::CheckState newCheckState_15df= SFC::CheckState::Create( newConditionalBlock_15dc, SFC::ConditionalBlock::meta_cond);
		SFC::CheckState& CheckState= newCheckState_15df;
		CyberComposition::Simulink::State& ChildState= currMatch.childState_15d5;
		SFC::StateLabel& ChildStateLabel= currMatch.childStateLabel_15d8;
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_15d6;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_15dc;
		SFC::Function& Function= currMatch.function_15d9;
		SFC::FunctionCall& FunctionCall= newFunctionCall_15de;
		SFC::Program& Program= currMatch.program_15da;
		SFC::Return& Return= newReturn_15dd;
		CyberComposition::Simulink::State& State= currMatch.state_15d4;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_15d7;
		SFC::StateVar& StateVar= currMatch.stateVar_15db;
		{
ConditionalBlock.RefId() = FunctionCall.RefId() = Return.RefId() = CompoundStatement.RefId();
};
		{
__int64 statementCount = CompoundStatement.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		{
__int64 statementCount = ConditionalBlock.statementCount();
FunctionCall.statementIndex() = statementCount++;
Return.statementIndex() = statementCount++;
ConditionalBlock.statementCount() = statementCount;
};
		newFunctionCall_15de.callee()= currMatch.function_15d9;
		newCheckState_15df.index()= currMatch.stateLabel_15d7;
		newCheckState_15df.svar()= currMatch.stateVar_15db;
		newCheckState_15df.value()= currMatch.childStateLabel_15d8;
	}
}

void CG_15e7::operator()( const Packets_t& states_15e8, const Packets_t& compoundStatements_15eb, Packets_t& states_15ea, Packets_t& conditionalGroups_15ed)
{
#ifdef PRINT_INFO
	printLog( "CG_15e7" );
#endif
	RTTGenerator::Instance()->generateRule(675, "CG");
	_state_15ee= &states_15ea;
	_conditionalGroup_15ef= &conditionalGroups_15ed;
	processInputPackets( states_15e8, compoundStatements_15eb);
}

bool CG_15e7::isInputUnique( const Udm::Object& state_15f4, const Udm::Object& compoundStatement_15fd)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_15f6= _state_15f0.begin(), itCompoundStatement_15ff= _compoundStatement_15f9.begin(); itState_15f6!= _state_15f0.end(), itCompoundStatement_15ff!= _compoundStatement_15f9.end(); ++itState_15f6, ++itCompoundStatement_15ff)
	{
		if( ( *itState_15f6== state_15f4)&& ( *itCompoundStatement_15ff== compoundStatement_15fd))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_15f0.push_back( state_15f4);
		_compoundStatement_15f9.push_back( compoundStatement_15fd);
	}
	return isUnique;
}

bool CG_15e7::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CG_15e7::processInputPackets( const Packets_t& states_15e8, const Packets_t& compoundStatements_15eb)
{
	for( Packets_t::const_iterator itState_15f1= states_15e8.begin(), itCompoundStatement_15fa= compoundStatements_15eb.begin(); itState_15f1!= states_15e8.end(), itCompoundStatement_15fa!= compoundStatements_15eb.end(); ++itState_15f1, ++itCompoundStatement_15fa)
	{
		bool isUnique= isInputUnique( *itState_15f1, *itCompoundStatement_15fa);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_15f1, *itCompoundStatement_15fa);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CG_15e7::patternMatcher( const Udm::Object& state_15f2, const Udm::Object& compoundStatement_15fb)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_15f2.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_15f7= CyberComposition::Simulink::State::Cast( state_15f2);
		if( false== Uml::IsDerivedFrom( compoundStatement_15fb.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_1600= SFC::CompoundStatement::Cast( compoundStatement_15fb);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1605;
		if( !isValidBound(boundObjs_1605, state_15f7, true))
			continue;
		currMatch.state_1606= state_15f7;
		if( !isValidBound(boundObjs_1605, compoundStatement_1600, true))
			continue;
		currMatch.compoundStatement_1607= compoundStatement_1600;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CG_15e7::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalGroup newConditionalGroup_1608= SFC::ConditionalGroup::Create( currMatch.compoundStatement_1607, SFC::CompoundStatement::meta_stmnt);
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_1607;
		SFC::ConditionalGroup& ConditionalGroup= newConditionalGroup_1608;
		CyberComposition::Simulink::State& State= currMatch.state_1606;
		{
ConditionalGroup.RefId() = CompoundStatement.RefId();
};
		{
__int64 statementCount = CompoundStatement.statementCount();
ConditionalGroup.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		outputAppender( currMatch.state_1606, newConditionalGroup_1608);
	}
}

void CG_15e7::outputAppender( const CyberComposition::Simulink::State& state_1609, const SFC::ConditionalGroup& conditionalGroup_160b)
{
	_state_15ee->push_back( state_1609);
	_conditionalGroup_15ef->push_back( conditionalGroup_160b);
}

void GetExecFcn_160d::operator()( const Packets_t& states_160e, Packets_t& states_1610, Packets_t& functions_1611)
{
#ifdef PRINT_INFO
	printLog( "GetExecFcn_160d" );
#endif
	RTTGenerator::Instance()->generateRule(682, "GetExecFcn");
	_state_1612= &states_1610;
	_function_1613= &functions_1611;
	processInputPackets( states_160e);
}

bool GetExecFcn_160d::isInputUnique( const Udm::Object& state_1618)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_161a= _state_1614.begin(); itState_161a!= _state_1614.end(); ++itState_161a)
	{
		if( ( *itState_161a== state_1618))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_1614.push_back( state_1618);
	return isUnique;
}

void GetExecFcn_160d::processInputPackets( const Packets_t& states_160e)
{
	for( Packets_t::const_iterator itState_1615= states_160e.begin(); itState_1615!= states_160e.end(); ++itState_1615)
	{
		bool isUnique= isInputUnique( *itState_1615);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1615);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetExecFcn_160d::patternMatcher( const Udm::Object& state_1616)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1616.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_161b= CyberComposition::Simulink::State::Cast( state_1616);
		set< SFC::Function> functions_161d= state_161b.exec();
		for( set< SFC::Function>::const_iterator itFunctions_161e= functions_161d.begin(); itFunctions_161e!= functions_161d.end(); ++itFunctions_161e)
		{
			SFC::Function currFunction_161f= *itFunctions_161e;
			Match currMatch;
			currMatch.state_1621= state_161b;
			currMatch.function_1622= currFunction_161f;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetExecFcn_160d::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_1621, currMatch.function_1622);
	}
}

void GetExecFcn_160d::outputAppender( const CyberComposition::Simulink::State& state_1623, const SFC::Function& function_1625)
{
	_state_1612->push_back( state_1623);
	_function_1613->push_back( function_1625);
}

void InnerTransitions_164b::operator()( const Packets_t& states_164c, Packets_t& states_164e)
{
#ifdef PRINT_INFO
	printLog( "InnerTransitions_164b" );
#endif
	_state_164f= &states_164e;
	if( ( !states_164c.empty()))
		callCheckForInnerTransitions_18ea( states_164c);
	_state_164f->insert( _state_164f->end(), states_164c.begin(), states_164c.end());
}

void InnerTransitions_164b::callCheckForInnerTransitions_18ea( const Packets_t& states_1822)
{
	Packets_t states_1824;
	CheckForInnerTransitions_1821 checkForInnerTransitions_1821;
	checkForInnerTransitions_1821( states_1822, states_1824);
	if( ( !states_1824.empty()))
		callInit_18ec( states_1824);
}

void InnerTransitions_164b::callInit_18ec( const Packets_t& states_184f)
{
	Packets_t states_1851;
	Packets_t tcs_1852;
	Packets_t fcns_1853;
	Packets_t cgs_1854;
	Init_184e init_184e;
	init_184e( states_184f, states_1851, tcs_1852, fcns_1853, cgs_1854);
	if( ( !states_1851.empty())&& ( !tcs_1852.empty())&& ( !fcns_1853.empty())&& ( !cgs_1854.empty()))
		callCreateTransitionCG_18ee( states_1851, tcs_1852, fcns_1853, cgs_1854);
}

void InnerTransitions_164b::callCreateTransitionCG_18ee( const Packets_t& states_7c9, const Packets_t& transConnectors_7cc, const Packets_t& functions_7cf, const Packets_t& tCVarCGs_7d3)
{
	Packets_t states_7cb;
	Packets_t transConnectors_7ce;
	Packets_t functions_7d1;
	Packets_t transitionCGs_7d2;
	CreateTransitionCG_7c8 createTransitionCG_7c8;
	createTransitionCG_7c8( states_7c9, transConnectors_7cc, functions_7cf, tCVarCGs_7d3, states_7cb, transConnectors_7ce, functions_7d1, transitionCGs_7d2);
	if( ( !states_7cb.empty())&& ( !transConnectors_7ce.empty())&& ( !functions_7d1.empty())&& ( !transitionCGs_7d2.empty()))
		callExecInnerTransitions_18f3( states_7cb, transConnectors_7ce, functions_7d1, transitionCGs_7d2);
}

void InnerTransitions_164b::callExecInnerTransitions_18f3( const Packets_t& states_1651, const Packets_t& tcs_1653, const Packets_t& fcns_1655, const Packets_t& css_1657)
{
	Packets_t states_1659;
	Packets_t tcs_165a;
	Packets_t fcns_165b;
	Packets_t css_165c;
	ExecInnerTransitions_1650 execInnerTransitions_1650;
	execInnerTransitions_1650( states_1651, tcs_1653, fcns_1655, css_1657, states_1659, tcs_165a, fcns_165b, css_165c);
	if( ( !states_1659.empty())&& ( !tcs_165a.empty())&& ( !fcns_165b.empty())&& ( !css_165c.empty()))
		callNoDefaultTransition_18f8( states_1659, tcs_165a, fcns_165b, css_165c);
}

void InnerTransitions_164b::callNoDefaultTransition_18f8( const Packets_t& states_88d, const Packets_t& tcs_88f, const Packets_t& fcns_891, const Packets_t& css_893)
{
	NoDefaultTransition_88c noDefaultTransition_88c;
	noDefaultTransition_88c( states_88d, tcs_88f, fcns_891, css_893);
}

void ExecInnerTransitions_1650::operator()( const Packets_t& states_1651, const Packets_t& tcs_1653, const Packets_t& fcns_1655, const Packets_t& css_1657, Packets_t& states_1659, Packets_t& tcs_165a, Packets_t& fcns_165b, Packets_t& css_165c)
{
#ifdef PRINT_INFO
	printLog( "ExecInnerTransitions_1650" );
#endif
	_state_165d= &states_1659;
	_tc_165e= &tcs_165a;
	_fcn_165f= &fcns_165b;
	_cs_1660= &css_165c;
	if( ( !states_1651.empty())&& ( !tcs_1653.empty())&& ( !fcns_1655.empty())&& ( !css_1657.empty()))
		callGetInnerTransitions_1817( states_1651, tcs_1653, fcns_1655, css_1657);
	_state_165d->insert( _state_165d->end(), states_1651.begin(), states_1651.end());
	_tc_165e->insert( _tc_165e->end(), tcs_1653.begin(), tcs_1653.end());
	_fcn_165f->insert( _fcn_165f->end(), fcns_1655.begin(), fcns_1655.end());
	_cs_1660->insert( _cs_1660->end(), css_1657.begin(), css_1657.end());
}

void ExecInnerTransitions_1650::callGetInnerTransitions_1817( const Packets_t& states_1662, const Packets_t& parentStates_1665, const Packets_t& functions_1668, const Packets_t& compoundStatements_166b)
{
	Packets_t states_1664;
	Packets_t transitions_1667;
	Packets_t functions_166a;
	Packets_t compoundStatements_166d;
	GetInnerTransitions_1661 getInnerTransitions_1661;
	getInnerTransitions_1661( states_1662, parentStates_1665, functions_1668, compoundStatements_166b, states_1664, transitions_1667, functions_166a, compoundStatements_166d);
	if( ( !states_1664.empty())&& ( !transitions_1667.empty())&& ( !functions_166a.empty())&& ( !compoundStatements_166d.empty()))
		callExecProcessTransitions_181c( states_1664, transitions_1667, functions_166a, compoundStatements_166d);
}

void ExecInnerTransitions_1650::callExecProcessTransitions_181c( const Packets_t& states_16b0, const Packets_t& transs_16b2, const Packets_t& fcns_16b4, const Packets_t& css_16b6)
{
	ExecProcessTransitions_16af execProcessTransitions_16af;
	execProcessTransitions_16af( states_16b0, transs_16b2, fcns_16b4, css_16b6);
}

void GetInnerTransitions_1661::operator()( const Packets_t& states_1662, const Packets_t& parentStates_1665, const Packets_t& functions_1668, const Packets_t& compoundStatements_166b, Packets_t& states_1664, Packets_t& transitions_1667, Packets_t& functions_166a, Packets_t& compoundStatements_166d)
{
#ifdef PRINT_INFO
	printLog( "GetInnerTransitions_1661" );
#endif
	RTTGenerator::Instance()->generateRule(718, "GetInnerTransitions");
	_state_166e= &states_1664;
	_transition_166f= &transitions_1667;
	_function_1670= &functions_166a;
	_compoundStatement_1671= &compoundStatements_166d;
	processInputPackets( states_1662, parentStates_1665, functions_1668, compoundStatements_166b);
}

bool GetInnerTransitions_1661::isInputUnique( const Udm::Object& state_1676, const Udm::Object& parentState_167f, const Udm::Object& function_1688, const Udm::Object& compoundStatement_1691)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1678= _state_1672.begin(), itParentState_1681= _parentState_167b.begin(), itFunction_168a= _function_1684.begin(), itCompoundStatement_1693= _compoundStatement_168d.begin(); itState_1678!= _state_1672.end(), itParentState_1681!= _parentState_167b.end(), itFunction_168a!= _function_1684.end(), itCompoundStatement_1693!= _compoundStatement_168d.end(); ++itState_1678, ++itParentState_1681, ++itFunction_168a, ++itCompoundStatement_1693)
	{
		if( ( *itState_1678== state_1676)&& ( *itParentState_1681== parentState_167f)&& ( *itFunction_168a== function_1688)&& ( *itCompoundStatement_1693== compoundStatement_1691))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1672.push_back( state_1676);
		_parentState_167b.push_back( parentState_167f);
		_function_1684.push_back( function_1688);
		_compoundStatement_168d.push_back( compoundStatement_1691);
	}
	return isUnique;
}

void GetInnerTransitions_1661::processInputPackets( const Packets_t& states_1662, const Packets_t& parentStates_1665, const Packets_t& functions_1668, const Packets_t& compoundStatements_166b)
{
	for( Packets_t::const_iterator itState_1673= states_1662.begin(), itParentState_167c= parentStates_1665.begin(), itFunction_1685= functions_1668.begin(), itCompoundStatement_168e= compoundStatements_166b.begin(); itState_1673!= states_1662.end(), itParentState_167c!= parentStates_1665.end(), itFunction_1685!= functions_1668.end(), itCompoundStatement_168e!= compoundStatements_166b.end(); ++itState_1673, ++itParentState_167c, ++itFunction_1685, ++itCompoundStatement_168e)
	{
		bool isUnique= isInputUnique( *itState_1673, *itParentState_167c, *itFunction_1685, *itCompoundStatement_168e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1673, *itParentState_167c, *itFunction_1685, *itCompoundStatement_168e);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetInnerTransitions_1661::patternMatcher( const Udm::Object& state_1674, const Udm::Object& parentState_167d, const Udm::Object& function_1686, const Udm::Object& compoundStatement_168f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1674.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1679= CyberComposition::Simulink::State::Cast( state_1674);
		if( false== Uml::IsDerivedFrom( parentState_167d.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State parentState_1682= CyberComposition::Simulink::State::Cast( parentState_167d);
		if( false== Uml::IsDerivedFrom( function_1686.type(), SFC::Function::meta))
			continue;
		SFC::Function function_168b= SFC::Function::Cast( function_1686);
		if( false== Uml::IsDerivedFrom( compoundStatement_168f.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_1694= SFC::CompoundStatement::Cast( compoundStatement_168f);
		set< CyberComposition::Simulink::ConnectorRef> connectorRefs_1696= parentState_1682.ConnectorRef_kind_children();
		for( set< CyberComposition::Simulink::ConnectorRef>::const_iterator itConnectorRef_1697= connectorRefs_1696.begin(); itConnectorRef_1697!= connectorRefs_1696.end(); ++itConnectorRef_1697)
		{
			CyberComposition::Simulink::ConnectorRef currConnectorRef_1698= *itConnectorRef_1697;
			CyberComposition::Simulink::TransConnector parentState_1699= currConnectorRef_1698.ref();
			if( false== Uml::IsDerivedFrom( parentState_1699.type(), CyberComposition::Simulink::State::meta))
				continue;
			CyberComposition::Simulink::State parentState_169a= CyberComposition::Simulink::State::Cast( parentState_1699);
			if( !parentState_169a)
				continue;
			if( parentState_1682!= parentState_169a)
				continue;
			set< CyberComposition::Simulink::Transition> transitions_169b= currConnectorRef_1698.dstTransition();
			for( set< CyberComposition::Simulink::Transition>::const_iterator itTransitions_169c= transitions_169b.begin(); itTransitions_169c!= transitions_169b.end(); ++itTransitions_169c)
			{
				CyberComposition::Simulink::Transition currTransition_169d= *itTransitions_169c;
				CyberComposition::Simulink::TransConnector transConnector_169e= currTransition_169d.dstTransition_end();
				Match currMatch;
				currMatch.state_16a0= state_1679;
				currMatch.parentState_16a1= parentState_1682;
				currMatch.function_16a2= function_168b;
				currMatch.compoundStatement_16a3= compoundStatement_1694;
				currMatch.connectorRef_16a4= currConnectorRef_1698;
				currMatch.transConnector_16a5= transConnector_169e;
				currMatch.transition_16a6= currTransition_169d;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetInnerTransitions_1661::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_16a0, currMatch.transition_16a6, currMatch.function_16a2, currMatch.compoundStatement_16a3);
	}
}

void GetInnerTransitions_1661::outputAppender( const CyberComposition::Simulink::State& state_16a7, const CyberComposition::Simulink::Transition& transition_16a9, const SFC::Function& function_16ab, const SFC::CompoundStatement& compoundStatement_16ad)
{
	_state_166e->push_back( state_16a7);
	_transition_166f->push_back( transition_16a9);
	_function_1670->push_back( function_16ab);
	_compoundStatement_1671->push_back( compoundStatement_16ad);
}

void ExecProcessTransitions_16af::operator()( const Packets_t& states_16b0, const Packets_t& transs_16b2, const Packets_t& fcns_16b4, const Packets_t& css_16b6)
{
#ifdef PRINT_INFO
	printLog( "ExecProcessTransitions_16af" );
#endif
	if( ( !states_16b0.empty())&& ( !transs_16b2.empty())&& ( !fcns_16b4.empty())&& ( !css_16b6.empty()))
		callOrderTransitions_17de( states_16b0, transs_16b2, fcns_16b4, css_16b6);
}

void ExecProcessTransitions_16af::callOrderTransitions_17de( const Packets_t& states_63f, const Packets_t& transitions_642, const Packets_t& functions_645, const Packets_t& compoundStatements_648)
{
	Packets_t states_641;
	Packets_t transitions_644;
	Packets_t functions_647;
	Packets_t compoundStatements_64a;
	OrderTransitions_63e orderTransitions_63e;
	orderTransitions_63e( states_63f, transitions_642, functions_645, compoundStatements_648, states_641, transitions_644, functions_647, compoundStatements_64a);
	if( ( !states_641.empty())&& ( !transitions_644.empty())&& ( !functions_647.empty())&& ( !compoundStatements_64a.empty()))
		callTransCond_17e3( states_641, transitions_644, functions_647, compoundStatements_64a);
}

void ExecProcessTransitions_16af::callTransCond_17e3( const Packets_t& states_331, const Packets_t& transitions_335, const Packets_t& functions_338, const Packets_t& transitionCGs_33b)
{
	Packets_t states_333;
	Packets_t dstTransConnectors_334;
	Packets_t transitions_337;
	Packets_t functions_33a;
	Packets_t conditionalBlocks_33d;
	TransCond_330 transCond_330;
	transCond_330( states_331, transitions_335, functions_338, transitionCGs_33b, states_333, dstTransConnectors_334, transitions_337, functions_33a, conditionalBlocks_33d);
	if( ( !states_333.empty())&& ( !dstTransConnectors_334.empty())&& ( !transitions_337.empty())&& ( !functions_33a.empty())&& ( !conditionalBlocks_33d.empty()))
		callHighestTransParent_17e8( states_333, dstTransConnectors_334, transitions_337, functions_33a, conditionalBlocks_33d);
}

void ExecProcessTransitions_16af::callHighestTransParent_17e8( const Packets_t& states_16b9, const Packets_t& dstTransConnectors_16bc, const Packets_t& transitions_16bf, const Packets_t& functions_16c2, const Packets_t& conditionalBlocks_16c5)
{
	Packets_t states_16bb;
	Packets_t dstTransConnectors_16be;
	Packets_t transitions_16c1;
	Packets_t functions_16c4;
	Packets_t conditionalBlocks_16c7;
	HighestTransParent_16b8 highestTransParent_16b8;
	highestTransParent_16b8( states_16b9, dstTransConnectors_16bc, transitions_16bf, functions_16c2, conditionalBlocks_16c5, states_16bb, dstTransConnectors_16be, transitions_16c1, functions_16c4, conditionalBlocks_16c7);
	if( ( !states_16bb.empty())&& ( !dstTransConnectors_16be.empty())&& ( !transitions_16c1.empty())&& ( !functions_16c4.empty())&& ( !conditionalBlocks_16c7.empty()))
		callTest_17ee( states_16bb, dstTransConnectors_16be, transitions_16c1, functions_16c4, conditionalBlocks_16c7);
}

void ExecProcessTransitions_16af::callTest_17ee( const Packets_t& states_37c, const Packets_t& dsts_37e, const Packets_t& transs_380, const Packets_t& fcns_382, const Packets_t& cbs_384)
{
	Packets_t states_386;
	Packets_t dsts_387;
	Packets_t transs_388;
	Packets_t fcns_389;
	Packets_t cbs_38a;
	Packets_t states_38b;
	Packets_t dsts_38c;
	Packets_t transs_38d;
	Packets_t fcns_38e;
	Packets_t cbs_38f;
	Packets_t states_390;
	Packets_t dsts_391;
	Packets_t transs_392;
	Packets_t fcns_393;
	Packets_t cbs_394;
	Packets_t states_395;
	Packets_t dsts_396;
	Packets_t transs_397;
	Packets_t fcns_398;
	Packets_t cbs_399;
	Packets_t states_39a;
	Packets_t dsts_39b;
	Packets_t transs_39c;
	Packets_t fcns_39d;
	Packets_t cbs_39e;
	Test_37b test_37b;
	test_37b( states_37c, dsts_37e, transs_380, fcns_382, cbs_384, states_386, dsts_387, transs_388, fcns_389, cbs_38a, states_38b, dsts_38c, transs_38d, fcns_38e, cbs_38f, states_390, dsts_391, transs_392, fcns_393, cbs_394, states_395, dsts_396, transs_397, fcns_398, cbs_399, states_39a, dsts_39b, transs_39c, fcns_39d, cbs_39e);
	if( ( !states_395.empty())&& ( !dsts_396.empty())&& ( !transs_397.empty())&& ( !fcns_398.empty())&& ( !cbs_399.empty()))
		callGetDstJuncFromRef_17f4( states_395, dsts_396, transs_397, fcns_398, cbs_399);
	if( ( !states_38b.empty())&& ( !dsts_38c.empty())&& ( !transs_38d.empty())&& ( !fcns_38e.empty())&& ( !cbs_38f.empty()))
		callGetDstStateFromRef_17fa( states_38b, dsts_38c, transs_38d, fcns_38e, cbs_38f);
	if( ( !states_39a.empty())&& ( !dsts_39b.empty())&& ( !transs_39c.empty())&& ( !fcns_39d.empty())&& ( !cbs_39e.empty()))
		callDeadEndJunction_1800( states_39a, dsts_39b, transs_39c, fcns_39d, cbs_39e);
	if( ( !states_390.empty())&& ( !dsts_391.empty())&& ( !transs_392.empty())&& ( !fcns_393.empty())&& ( !cbs_394.empty()))
		callNextJunction_1806( states_390, dsts_391, transs_392, fcns_393, cbs_394);
	if( ( !states_386.empty())&& ( !dsts_387.empty())&& ( !transs_388.empty())&& ( !fcns_389.empty())&& ( !cbs_38a.empty()))
		callExecNextState_180c( states_386, dsts_387, transs_388, fcns_389, cbs_38a);
}

void ExecProcessTransitions_16af::callGetDstJuncFromRef_17f4( const Packets_t& states_23b, const Packets_t& connectorRefs_23e, const Packets_t& transitions_241, const Packets_t& functions_244, const Packets_t& conditionalBlocks_247)
{
	Packets_t states_23d;
	Packets_t junctions_240;
	Packets_t transitions_243;
	Packets_t functions_246;
	Packets_t conditionalBlocks_249;
	GetDstJuncFromRef_23a getDstJuncFromRef_23a;
	getDstJuncFromRef_23a( states_23b, connectorRefs_23e, transitions_241, functions_244, conditionalBlocks_247, states_23d, junctions_240, transitions_243, functions_246, conditionalBlocks_249);
	if( ( !states_23d.empty())&& ( !junctions_240.empty())&& ( !transitions_243.empty())&& ( !functions_246.empty())&& ( !conditionalBlocks_249.empty()))
		callNextJunction_1806( states_23d, junctions_240, transitions_243, functions_246, conditionalBlocks_249);
}

void ExecProcessTransitions_16af::callGetDstStateFromRef_17fa( const Packets_t& states_290, const Packets_t& connectorRefs_294, const Packets_t& transitions_296, const Packets_t& functions_299, const Packets_t& conditionalBlocks_29c)
{
	Packets_t states_292;
	Packets_t dstStates_293;
	Packets_t transitions_298;
	Packets_t functions_29b;
	Packets_t conditionalBlocks_29e;
	GetDstStateFromRef_28f getDstStateFromRef_28f;
	getDstStateFromRef_28f( states_290, connectorRefs_294, transitions_296, functions_299, conditionalBlocks_29c, states_292, dstStates_293, transitions_298, functions_29b, conditionalBlocks_29e);
	if( ( !states_292.empty())&& ( !dstStates_293.empty())&& ( !transitions_298.empty())&& ( !functions_29b.empty())&& ( !conditionalBlocks_29e.empty()))
		callExecNextState_180c( states_292, dstStates_293, transitions_298, functions_29b, conditionalBlocks_29e);
}

void ExecProcessTransitions_16af::callDeadEndJunction_1800( const Packets_t& states_2e5, const Packets_t& transConnectors_2e7, const Packets_t& transitions_2e9, const Packets_t& functions_2eb, const Packets_t& transitionCBs_2ed)
{
	DeadEndJunction_2e4 deadEndJunction_2e4;
	deadEndJunction_2e4( states_2e5, transConnectors_2e7, transitions_2e9, functions_2eb, transitionCBs_2ed);
}

void ExecProcessTransitions_16af::callNextJunction_1806( const Packets_t& states_1d3, const Packets_t& junctions_1d6, const Packets_t& transitions_1d9, const Packets_t& functions_1db, const Packets_t& transitionCBs_1de)
{
	Packets_t states_1d5;
	Packets_t junctions_1d8;
	Packets_t functions_1dd;
	Packets_t conditionalGroups_1e0;
	NextJunction_1d2 nextJunction_1d2;
	nextJunction_1d2( states_1d3, junctions_1d6, transitions_1d9, functions_1db, transitionCBs_1de, states_1d5, junctions_1d8, functions_1dd, conditionalGroups_1e0);
	if( ( !states_1d5.empty())&& ( !junctions_1d8.empty())&& ( !functions_1dd.empty())&& ( !conditionalGroups_1e0.empty()))
		callExecTransConnectorRecurse_1812( states_1d5, junctions_1d8, functions_1dd, conditionalGroups_1e0);
}

void ExecProcessTransitions_16af::callExecNextState_180c( const Packets_t& states_1721, const Packets_t& dstStates_1723, const Packets_t& transitions_1725, const Packets_t& functions_1727, const Packets_t& transitionCBs_1729)
{
	ExecNextState_1720 execNextState_1720;
	execNextState_1720( states_1721, dstStates_1723, transitions_1725, functions_1727, transitionCBs_1729);
}

void ExecProcessTransitions_16af::callExecTransConnectorRecurse_1812( const Packets_t& states_178b, const Packets_t& tcs_178d, const Packets_t& fcns_178f, const Packets_t& cgs_1791)
{
	ExecTransConnectorRecurse_178a execTransConnectorRecurse_178a;
	execTransConnectorRecurse_178a( states_178b, tcs_178d, fcns_178f, cgs_1791);
}

void HighestTransParent_16b8::operator()( const Packets_t& states_16b9, const Packets_t& dstTransConnectors_16bc, const Packets_t& transitions_16bf, const Packets_t& functions_16c2, const Packets_t& conditionalBlocks_16c5, Packets_t& states_16bb, Packets_t& dstTransConnectors_16be, Packets_t& transitions_16c1, Packets_t& functions_16c4, Packets_t& conditionalBlocks_16c7)
{
#ifdef PRINT_INFO
	printLog( "HighestTransParent_16b8" );
#endif
	RTTGenerator::Instance()->generateRule(2468, "HighestTransParent");
	_state_16c8= &states_16bb;
	_dstTransConnector_16c9= &dstTransConnectors_16be;
	_transition_16ca= &transitions_16c1;
	_function_16cb= &functions_16c4;
	_conditionalBlock_16cc= &conditionalBlocks_16c7;
	processInputPackets( states_16b9, dstTransConnectors_16bc, transitions_16bf, functions_16c2, conditionalBlocks_16c5);
	forwardInputs( );
}

bool HighestTransParent_16b8::isInputUnique( const Udm::Object& state_16d1, const Udm::Object& dstTransConnector_16da, const Udm::Object& transition_16e3, const Udm::Object& function_16ec, const Udm::Object& conditionalBlock_16f5)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_16d3= _state_16cd.begin(), itDstTransConnector_16dc= _dstTransConnector_16d6.begin(), itTransition_16e5= _transition_16df.begin(), itFunction_16ee= _function_16e8.begin(), itConditionalBlock_16f7= _conditionalBlock_16f1.begin(); itState_16d3!= _state_16cd.end(), itDstTransConnector_16dc!= _dstTransConnector_16d6.end(), itTransition_16e5!= _transition_16df.end(), itFunction_16ee!= _function_16e8.end(), itConditionalBlock_16f7!= _conditionalBlock_16f1.end(); ++itState_16d3, ++itDstTransConnector_16dc, ++itTransition_16e5, ++itFunction_16ee, ++itConditionalBlock_16f7)
	{
		if( ( *itState_16d3== state_16d1)&& ( *itDstTransConnector_16dc== dstTransConnector_16da)&& ( *itTransition_16e5== transition_16e3)&& ( *itFunction_16ee== function_16ec)&& ( *itConditionalBlock_16f7== conditionalBlock_16f5))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_16cd.push_back( state_16d1);
		_dstTransConnector_16d6.push_back( dstTransConnector_16da);
		_transition_16df.push_back( transition_16e3);
		_function_16e8.push_back( function_16ec);
		_conditionalBlock_16f1.push_back( conditionalBlock_16f5);
	}
	return isUnique;
}

bool HighestTransParent_16b8::isGuardTrue( SFC::ConditionalBlock& ConditionalBlock, CyberComposition::Simulink::TransConnector& DstTransConnector, SFC::Function& Function, SFC::LocalVar& HTPVar, CyberComposition::Simulink::State& State, SFC::StateLabel& StateLabel, CyberComposition::Simulink::Transition& Transition, CyberComposition::Simulink::State& TransitionParentState)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( HTPVar.name() ) == "_HTPVar_";;
	return Gz_guard;
}

void HighestTransParent_16b8::processInputPackets( const Packets_t& states_16b9, const Packets_t& dstTransConnectors_16bc, const Packets_t& transitions_16bf, const Packets_t& functions_16c2, const Packets_t& conditionalBlocks_16c5)
{
	for( Packets_t::const_iterator itState_16ce= states_16b9.begin(), itDstTransConnector_16d7= dstTransConnectors_16bc.begin(), itTransition_16e0= transitions_16bf.begin(), itFunction_16e9= functions_16c2.begin(), itConditionalBlock_16f2= conditionalBlocks_16c5.begin(); itState_16ce!= states_16b9.end(), itDstTransConnector_16d7!= dstTransConnectors_16bc.end(), itTransition_16e0!= transitions_16bf.end(), itFunction_16e9!= functions_16c2.end(), itConditionalBlock_16f2!= conditionalBlocks_16c5.end(); ++itState_16ce, ++itDstTransConnector_16d7, ++itTransition_16e0, ++itFunction_16e9, ++itConditionalBlock_16f2)
	{
		bool isUnique= isInputUnique( *itState_16ce, *itDstTransConnector_16d7, *itTransition_16e0, *itFunction_16e9, *itConditionalBlock_16f2);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_16ce, *itDstTransConnector_16d7, *itTransition_16e0, *itFunction_16e9, *itConditionalBlock_16f2);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool HighestTransParent_16b8::patternMatcher( const Udm::Object& state_16cf, const Udm::Object& dstTransConnector_16d8, const Udm::Object& transition_16e1, const Udm::Object& function_16ea, const Udm::Object& conditionalBlock_16f3)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_16cf.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_16d4= CyberComposition::Simulink::State::Cast( state_16cf);
		if( false== Uml::IsDerivedFrom( dstTransConnector_16d8.type(), CyberComposition::Simulink::TransConnector::meta))
			continue;
		CyberComposition::Simulink::TransConnector dstTransConnector_16dd= CyberComposition::Simulink::TransConnector::Cast( dstTransConnector_16d8);
		if( false== Uml::IsDerivedFrom( transition_16e1.type(), CyberComposition::Simulink::Transition::meta))
			continue;
		CyberComposition::Simulink::Transition transition_16e6= CyberComposition::Simulink::Transition::Cast( transition_16e1);
		if( false== Uml::IsDerivedFrom( function_16ea.type(), SFC::Function::meta))
			continue;
		SFC::Function function_16ef= SFC::Function::Cast( function_16ea);
		if( false== Uml::IsDerivedFrom( conditionalBlock_16f3.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlock_16f8= SFC::ConditionalBlock::Cast( conditionalBlock_16f3);
		set< SFC::LocalVar> hTPVars_16fa= function_16ef.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itHTPVar_16fb= hTPVars_16fa.begin(); itHTPVar_16fb!= hTPVars_16fa.end(); ++itHTPVar_16fb)
		{
			SFC::LocalVar currHTPVar_16fc= *itHTPVar_16fb;
			Udm::Object transitionParent_16fd= transition_16e6.container();
			if( false== Uml::IsDerivedFrom( transitionParent_16fd.type(), CyberComposition::Simulink::State::meta))
				continue;
			CyberComposition::Simulink::State transitionParentStateTransition_16fe= CyberComposition::Simulink::State::Cast( transitionParent_16fd);
			set< SFC::StateLabel> stateLabels_16ff= transitionParentStateTransition_16fe.src();
			for( set< SFC::StateLabel>::const_iterator itStateLabels_1700= stateLabels_16ff.begin(); itStateLabels_1700!= stateLabels_16ff.end(); ++itStateLabels_1700)
			{
				SFC::StateLabel currStateLabel_1701= *itStateLabels_1700;
				Match currMatch;
				currMatch.state_1703= state_16d4;
				currMatch.dstTransConnector_1704= dstTransConnector_16dd;
				currMatch.transition_1705= transition_16e6;
				currMatch.function_1706= function_16ef;
				currMatch.conditionalBlock_1707= conditionalBlock_16f8;
				currMatch.transitionParentState_1708= transitionParentStateTransition_16fe;
				currMatch.stateLabel_1709= currStateLabel_1701;
				currMatch.hTPVar_170a= currHTPVar_16fc;
				bool Gz_guard= isGuardTrue( currMatch.conditionalBlock_1707, currMatch.dstTransConnector_1704, currMatch.function_1706, currMatch.hTPVar_170a, currMatch.state_1703, currMatch.stateLabel_1709, currMatch.transition_1705, currMatch.transitionParentState_1708);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void HighestTransParent_16b8::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newHighestTransitionCB_1713= SFC::ConditionalBlock::Create( currMatch.conditionalBlock_1707, SFC::ConditionalBlock::meta_stmnt);
		SFC::UserCode newTakeMin_1714= SFC::UserCode::Create( newHighestTransitionCB_1713, SFC::ConditionalBlock::meta_stmnt);
		SFC::BinaryExprs newAssign_1715= SFC::BinaryExprs::Create( newTakeMin_1714, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newSLArgDeclRef2_1716= SFC::ArgDeclRef::Create( newAssign_1715, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newHTPArgDeclRef2_1717= SFC::ArgDeclRef::Create( newAssign_1715, SFC::BinaryExprs::meta_leftexpr);
		SFC::UserCode newTestMin_1718= SFC::UserCode::Create( newHighestTransitionCB_1713, SFC::ConditionalBlock::meta_cond);
		SFC::BinaryExprs newLessThan_1719= SFC::BinaryExprs::Create( newTestMin_1718, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newLBitAnd_171a= SFC::BinaryExprs::Create( newLessThan_1719, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newRBitAnd_171b= SFC::BinaryExprs::Create( newLessThan_1719, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newRInt_171c= SFC::Int::Create( newRBitAnd_171b, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newHTPArgDeclRef1_171d= SFC::ArgDeclRef::Create( newRBitAnd_171b, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newSLArgDeclRef1_171e= SFC::ArgDeclRef::Create( newLBitAnd_171a, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newLInt_171f= SFC::Int::Create( newLBitAnd_171a, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs& Assign= newAssign_1715;
		SFC::ConditionalBlock& ConditionalBlock= currMatch.conditionalBlock_1707;
		CyberComposition::Simulink::TransConnector& DstTransConnector= currMatch.dstTransConnector_1704;
		SFC::Function& Function= currMatch.function_1706;
		SFC::ArgDeclRef& HTPArgDeclRef1= newHTPArgDeclRef1_171d;
		SFC::ArgDeclRef& HTPArgDeclRef2= newHTPArgDeclRef2_1717;
		SFC::LocalVar& HTPVar= currMatch.hTPVar_170a;
		SFC::ConditionalBlock& HighestTransitionCB= newHighestTransitionCB_1713;
		SFC::BinaryExprs& LBitAnd= newLBitAnd_171a;
		SFC::Int& LInt= newLInt_171f;
		SFC::BinaryExprs& LessThan= newLessThan_1719;
		SFC::BinaryExprs& RBitAnd= newRBitAnd_171b;
		SFC::Int& RInt= newRInt_171c;
		SFC::ArgDeclRef& SLArgDeclRef1= newSLArgDeclRef1_171e;
		SFC::ArgDeclRef& SLArgDeclRef2= newSLArgDeclRef2_1716;
		CyberComposition::Simulink::State& State= currMatch.state_1703;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_1709;
		SFC::UserCode& TakeMin= newTakeMin_1714;
		SFC::UserCode& TestMin= newTestMin_1718;
		CyberComposition::Simulink::Transition& Transition= currMatch.transition_1705;
		CyberComposition::Simulink::State& TransitionParentState= currMatch.transitionParentState_1708;
		{
HighestTransitionCB.RefId() = TestMin.RefId() = TakeMin.RefId() = ConditionalBlock.RefId();
};
		{
__int64 statementCount = ConditionalBlock.statementCount();
HighestTransitionCB.statementIndex() = statementCount++;
ConditionalBlock.statementCount() = statementCount;

};
		{
RBitAnd.op() = "&";
};
		{
LInt.val() = 0xFFFF;
};
		{
LessThan.op() = "<";
};
		{
RInt.val() = 0xFFFF;
};
		{
Assign.op() = "=";
};
		{
LBitAnd.op() = "&";
};
		{
__int64 statementCount = HighestTransitionCB.statementCount();
TakeMin.statementIndex() = statementCount++;
HighestTransitionCB.statementCount() = statementCount;
};
		newSLArgDeclRef2_1716.argdecl()= currMatch.stateLabel_1709;
		newHTPArgDeclRef2_1717.argdecl()= currMatch.hTPVar_170a;
		newSLArgDeclRef1_171e.argdecl()= currMatch.stateLabel_1709;
		newHTPArgDeclRef1_171d.argdecl()= currMatch.hTPVar_170a;
	}
}

void HighestTransParent_16b8::forwardInputs()
{
	*_state_16c8= _state_16cd;
	*_dstTransConnector_16c9= _dstTransConnector_16d6;
	*_transition_16ca= _transition_16df;
	*_function_16cb= _function_16e8;
	*_conditionalBlock_16cc= _conditionalBlock_16f1;
}

void ExecNextState_1720::operator()( const Packets_t& states_1721, const Packets_t& dstStates_1723, const Packets_t& transitions_1725, const Packets_t& functions_1727, const Packets_t& transitionCBs_1729)
{
#ifdef PRINT_INFO
	printLog( "ExecNextState_1720" );
#endif
	RTTGenerator::Instance()->generateRule(2519, "ExecNextState");
	processInputPackets( states_1721, dstStates_1723, transitions_1725, functions_1727, transitionCBs_1729);
}

bool ExecNextState_1720::isInputUnique( const Udm::Object& state_172f, const Udm::Object& dstState_1738, const Udm::Object& transition_1741, const Udm::Object& function_174a, const Udm::Object& transitionCB_1753)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1731= _state_172b.begin(), itDstState_173a= _dstState_1734.begin(), itTransition_1743= _transition_173d.begin(), itFunction_174c= _function_1746.begin(), itTransitionCB_1755= _transitionCB_174f.begin(); itState_1731!= _state_172b.end(), itDstState_173a!= _dstState_1734.end(), itTransition_1743!= _transition_173d.end(), itFunction_174c!= _function_1746.end(), itTransitionCB_1755!= _transitionCB_174f.end(); ++itState_1731, ++itDstState_173a, ++itTransition_1743, ++itFunction_174c, ++itTransitionCB_1755)
	{
		if( ( *itState_1731== state_172f)&& ( *itDstState_173a== dstState_1738)&& ( *itTransition_1743== transition_1741)&& ( *itFunction_174c== function_174a)&& ( *itTransitionCB_1755== transitionCB_1753))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_172b.push_back( state_172f);
		_dstState_1734.push_back( dstState_1738);
		_transition_173d.push_back( transition_1741);
		_function_1746.push_back( function_174a);
		_transitionCB_174f.push_back( transitionCB_1753);
	}
	return isUnique;
}

bool ExecNextState_1720::isGuardTrue( CyberComposition::Simulink::State& DstState, SFC::Function& Enter, SFC::Arg& EnterArg0, SFC::Arg& EnterArg1, SFC::Function& Exit, SFC::Arg& ExitArg, SFC::Function& Function, SFC::LocalVar& HTPVar, CyberComposition::Simulink::State& State, CyberComposition::Simulink::Transition& Transition, SFC::ConditionalBlock& TransitionCB)
{
	bool Gz_guard= false;
	return static_cast< std::string >( HTPVar.name() ) == "_HTPVar_" && EnterArg0.argIndex() == 0 && EnterArg1.argIndex() == 1;;
	return Gz_guard;
}

void ExecNextState_1720::processInputPackets( const Packets_t& states_1721, const Packets_t& dstStates_1723, const Packets_t& transitions_1725, const Packets_t& functions_1727, const Packets_t& transitionCBs_1729)
{
	for( Packets_t::const_iterator itState_172c= states_1721.begin(), itDstState_1735= dstStates_1723.begin(), itTransition_173e= transitions_1725.begin(), itFunction_1747= functions_1727.begin(), itTransitionCB_1750= transitionCBs_1729.begin(); itState_172c!= states_1721.end(), itDstState_1735!= dstStates_1723.end(), itTransition_173e!= transitions_1725.end(), itFunction_1747!= functions_1727.end(), itTransitionCB_1750!= transitionCBs_1729.end(); ++itState_172c, ++itDstState_1735, ++itTransition_173e, ++itFunction_1747, ++itTransitionCB_1750)
	{
		bool isUnique= isInputUnique( *itState_172c, *itDstState_1735, *itTransition_173e, *itFunction_1747, *itTransitionCB_1750);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_172c, *itDstState_1735, *itTransition_173e, *itFunction_1747, *itTransitionCB_1750);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ExecNextState_1720::patternMatcher( const Udm::Object& state_172d, const Udm::Object& dstState_1736, const Udm::Object& transition_173f, const Udm::Object& function_1748, const Udm::Object& transitionCB_1751)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_172d.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1732= CyberComposition::Simulink::State::Cast( state_172d);
		if( false== Uml::IsDerivedFrom( dstState_1736.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State dstState_173b= CyberComposition::Simulink::State::Cast( dstState_1736);
		if( false== Uml::IsDerivedFrom( transition_173f.type(), CyberComposition::Simulink::Transition::meta))
			continue;
		CyberComposition::Simulink::Transition transition_1744= CyberComposition::Simulink::Transition::Cast( transition_173f);
		if( false== Uml::IsDerivedFrom( function_1748.type(), SFC::Function::meta))
			continue;
		SFC::Function function_174d= SFC::Function::Cast( function_1748);
		if( false== Uml::IsDerivedFrom( transitionCB_1751.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock transitionCB_1756= SFC::ConditionalBlock::Cast( transitionCB_1751);
		set< SFC::LocalVar> hTPVars_1758= function_174d.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itHTPVar_1759= hTPVars_1758.begin(); itHTPVar_1759!= hTPVars_1758.end(); ++itHTPVar_1759)
		{
			SFC::LocalVar currHTPVar_175a= *itHTPVar_1759;
			set< SFC::Function> exits_175b= state_1732.exit();
			for( set< SFC::Function>::const_iterator itExits_175c= exits_175b.begin(); itExits_175c!= exits_175b.end(); ++itExits_175c)
			{
				SFC::Function currExit_175d= *itExits_175c;
				set< SFC::Arg> exitArgs_175e= currExit_175d.Arg_kind_children();
				for( set< SFC::Arg>::const_iterator itExitArg_175f= exitArgs_175e.begin(); itExitArg_175f!= exitArgs_175e.end(); ++itExitArg_175f)
				{
					SFC::Arg currExitArg_1760= *itExitArg_175f;
					set< SFC::Function> enters_1761= dstState_173b.enter();
					for( set< SFC::Function>::const_iterator itEnters_1762= enters_1761.begin(); itEnters_1762!= enters_1761.end(); ++itEnters_1762)
					{
						SFC::Function currEnter_1763= *itEnters_1762;
						set< SFC::Arg> enterArg0s_1764= currEnter_1763.Arg_kind_children();
						for( set< SFC::Arg>::const_iterator itEnterArg0_1765= enterArg0s_1764.begin(); itEnterArg0_1765!= enterArg0s_1764.end(); ++itEnterArg0_1765)
						{
							SFC::Arg currEnterArg0_1766= *itEnterArg0_1765;
							set< SFC::Arg> enterArg1s_1767= currEnter_1763.Arg_kind_children();
							for( set< SFC::Arg>::const_iterator itEnterArg1_1768= enterArg1s_1767.begin(); itEnterArg1_1768!= enterArg1s_1767.end(); ++itEnterArg1_1768)
							{
								SFC::Arg currEnterArg1_1769= *itEnterArg1_1768;
								Match currMatch;
								currMatch.state_176b= state_1732;
								currMatch.dstState_176c= dstState_173b;
								currMatch.transition_176d= transition_1744;
								currMatch.function_176e= function_174d;
								currMatch.transitionCB_176f= transitionCB_1756;
								currMatch.exitArg_1770= currExitArg_1760;
								currMatch.exit_1771= currExit_175d;
								currMatch.enterArg0_1772= currEnterArg0_1766;
								currMatch.enter_1773= currEnter_1763;
								currMatch.enterArg1_1774= currEnterArg1_1769;
								currMatch.hTPVar_1775= currHTPVar_175a;
								bool Gz_guard= isGuardTrue( currMatch.dstState_176c, currMatch.enter_1773, currMatch.enterArg0_1772, currMatch.enterArg1_1774, currMatch.exit_1771, currMatch.exitArg_1770, currMatch.function_176e, currMatch.hTPVar_1775, currMatch.state_176b, currMatch.transition_176d, currMatch.transitionCB_176f);
								if( true== Gz_guard)
									_matches.push_back( currMatch);
							}
						}
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void ExecNextState_1720::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::FunctionCall newExitFunctionCall_1781= SFC::FunctionCall::Create( currMatch.transitionCB_176f, SFC::ConditionalBlock::meta_stmnt);
		SFC::ArgVal newExitArgVal_1782= SFC::ArgVal::Create( newExitFunctionCall_1781);
		SFC::ArgDeclRef newExitArgDeclRef_1783= SFC::ArgDeclRef::Create( newExitArgVal_1782, SFC::ArgVal::meta_argexpr);
		SFC::Return newReturn_1784= SFC::Return::Create( currMatch.transitionCB_176f, SFC::ConditionalBlock::meta_stmnt);
		SFC::FunctionCall newEnterFunctionCall_1785= SFC::FunctionCall::Create( currMatch.transitionCB_176f, SFC::ConditionalBlock::meta_stmnt);
		SFC::ArgVal newEnterArgVal0_1786= SFC::ArgVal::Create( newEnterFunctionCall_1785);
		SFC::Int newZero_1787= SFC::Int::Create( newEnterArgVal0_1786, SFC::ArgVal::meta_argexpr);
		SFC::ArgVal newEnterArgVal1_1788= SFC::ArgVal::Create( newEnterFunctionCall_1785);
		SFC::ArgDeclRef newEnterArgDeclRef_1789= SFC::ArgDeclRef::Create( newEnterArgVal1_1788, SFC::ArgVal::meta_argexpr);
		CyberComposition::Simulink::State& DstState= currMatch.dstState_176c;
		SFC::Function& Enter= currMatch.enter_1773;
		SFC::Arg& EnterArg0= currMatch.enterArg0_1772;
		SFC::Arg& EnterArg1= currMatch.enterArg1_1774;
		SFC::ArgDeclRef& EnterArgDeclRef= newEnterArgDeclRef_1789;
		SFC::ArgVal& EnterArgVal0= newEnterArgVal0_1786;
		SFC::ArgVal& EnterArgVal1= newEnterArgVal1_1788;
		SFC::FunctionCall& EnterFunctionCall= newEnterFunctionCall_1785;
		SFC::Function& Exit= currMatch.exit_1771;
		SFC::Arg& ExitArg= currMatch.exitArg_1770;
		SFC::ArgDeclRef& ExitArgDeclRef= newExitArgDeclRef_1783;
		SFC::ArgVal& ExitArgVal= newExitArgVal_1782;
		SFC::FunctionCall& ExitFunctionCall= newExitFunctionCall_1781;
		SFC::Function& Function= currMatch.function_176e;
		SFC::LocalVar& HTPVar= currMatch.hTPVar_1775;
		SFC::Return& Return= newReturn_1784;
		CyberComposition::Simulink::State& State= currMatch.state_176b;
		CyberComposition::Simulink::Transition& Transition= currMatch.transition_176d;
		SFC::ConditionalBlock& TransitionCB= currMatch.transitionCB_176f;
		SFC::Int& Zero= newZero_1787;
		{
EnterFunctionCall.RefId() = ExitFunctionCall.RefId() = Return.RefId() = TransitionCB.RefId();
};
		{
EnterArgVal0.argIndex() = 0;
};
		{
Zero.val() = 0;
};
		{
__int64 statementCount = TransitionCB.statementCount();
ExitFunctionCall.statementIndex() = statementCount++;
TransitionCB.statementCount() = statementCount;

SFManager::mstat2SFC( TransitionCB, Transition.Action() );

statementCount = TransitionCB.statementCount();
EnterFunctionCall.statementIndex() = statementCount++;
Return.statementIndex() = statementCount++;
TransitionCB.statementCount() = statementCount;
};
		{
EnterArgVal1.argIndex() = 1;
};
		newEnterArgVal0_1786.arg()+= currMatch.enterArg0_1772;
		newExitFunctionCall_1781.callee()= currMatch.exit_1771;
		newExitArgDeclRef_1783.argdecl()= currMatch.hTPVar_1775;
		newEnterFunctionCall_1785.callee()= currMatch.enter_1773;
		newEnterArgVal1_1788.arg()+= currMatch.enterArg1_1774;
		newEnterArgDeclRef_1789.argdecl()= currMatch.hTPVar_1775;
		newExitArgVal_1782.arg()+= currMatch.exitArg_1770;
	}
}

void ExecTransConnectorRecurse_178a::operator()( const Packets_t& states_178b, const Packets_t& tcs_178d, const Packets_t& fcns_178f, const Packets_t& cgs_1791)
{
#ifdef PRINT_INFO
	printLog( "ExecTransConnectorRecurse_178a" );
#endif
	for( Packets_t::const_iterator itstate_1794= states_178b.begin(), ittc_179b= tcs_178d.begin(), itfcn_17a2= fcns_178f.begin(), itcg_17a9= cgs_1791.begin(); itstate_1794!= states_178b.end(), ittc_179b!= tcs_178d.end(), itfcn_17a2!= fcns_178f.end(), itcg_17a9!= cgs_1791.end(); ++itstate_1794, ++ittc_179b, ++itfcn_17a2, ++itcg_17a9)
	{
		bool isUnique= isInputUnique( *itstate_1794, *ittc_179b, *itfcn_17a2, *itcg_17a9);
		if( !isUnique)
			continue;
		Packets_t onestate_1798( 1, *itstate_1794);
		Packets_t onetc_179f( 1, *ittc_179b);
		Packets_t onefcn_17a6( 1, *itfcn_17a2);
		Packets_t onecg_17ad( 1, *itcg_17a9);
		executeOne( onestate_1798, onetc_179f, onefcn_17a6, onecg_17ad);
	}
}

void ExecTransConnectorRecurse_178a::executeOne( const Packets_t& states_178b, const Packets_t& tcs_178d, const Packets_t& fcns_178f, const Packets_t& cgs_1791)
{
	if( ( !states_178b.empty())&& ( !tcs_178d.empty())&& ( !fcns_178f.empty())&& ( !cgs_1791.empty()))
		callProcessedFilter_17ca( states_178b, tcs_178d, fcns_178f, cgs_1791);
}

bool ExecTransConnectorRecurse_178a::isInputUnique( const Udm::Object& state_1795, const Udm::Object& tc_179c, const Udm::Object& fcn_17a3, const Udm::Object& cg_17aa)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_1797= _state_1793.begin(), ittc_179e= _tc_179a.begin(), itfcn_17a5= _fcn_17a1.begin(), itcg_17ac= _cg_17a8.begin(); itstate_1797!= _state_1793.end(), ittc_179e!= _tc_179a.end(), itfcn_17a5!= _fcn_17a1.end(), itcg_17ac!= _cg_17a8.end(); ++itstate_1797, ++ittc_179e, ++itfcn_17a5, ++itcg_17ac)
	{
		if( ( *itstate_1797== state_1795)&& ( *ittc_179e== tc_179c)&& ( *itfcn_17a5== fcn_17a3)&& ( *itcg_17ac== cg_17aa))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1793.push_back( state_1795);
		_tc_179a.push_back( tc_179c);
		_fcn_17a1.push_back( fcn_17a3);
		_cg_17a8.push_back( cg_17aa);
	}
	return isUnique;
}

void ExecTransConnectorRecurse_178a::callProcessedFilter_17ca( const Packets_t& states_81a, const Packets_t& tcs_81c, const Packets_t& fcns_81e, const Packets_t& cgs_820)
{
	Packets_t states_822;
	Packets_t tcs_823;
	Packets_t fcns_824;
	Packets_t cgs_825;
	ProcessedFilter_819 processedFilter_819;
	processedFilter_819( states_81a, tcs_81c, fcns_81e, cgs_820, states_822, tcs_823, fcns_824, cgs_825);
	if( ( !states_822.empty())&& ( !tcs_823.empty())&& ( !fcns_824.empty())&& ( !cgs_825.empty()))
		callCreateTransitionCG_17cf( states_822, tcs_823, fcns_824, cgs_825);
}

void ExecTransConnectorRecurse_178a::callCreateTransitionCG_17cf( const Packets_t& states_7c9, const Packets_t& transConnectors_7cc, const Packets_t& functions_7cf, const Packets_t& tCVarCGs_7d3)
{
	Packets_t states_7cb;
	Packets_t transConnectors_7ce;
	Packets_t functions_7d1;
	Packets_t transitionCGs_7d2;
	CreateTransitionCG_7c8 createTransitionCG_7c8;
	createTransitionCG_7c8( states_7c9, transConnectors_7cc, functions_7cf, tCVarCGs_7d3, states_7cb, transConnectors_7ce, functions_7d1, transitionCGs_7d2);
	if( ( !states_7cb.empty())&& ( !transConnectors_7ce.empty())&& ( !functions_7d1.empty())&& ( !transitionCGs_7d2.empty()))
		callExecTransitions_17d4( states_7cb, transConnectors_7ce, functions_7d1, transitionCGs_7d2);
}

void ExecTransConnectorRecurse_178a::callExecTransitions_17d4( const Packets_t& states_17b0, const Packets_t& tcs_17b2, const Packets_t& fcns_17b4, const Packets_t& css_17b6)
{
	Packets_t states_17b8;
	Packets_t tcs_17b9;
	Packets_t fcns_17ba;
	Packets_t css_17bb;
	ExecTransitions_17af execTransitions_17af;
	execTransitions_17af( states_17b0, tcs_17b2, fcns_17b4, css_17b6, states_17b8, tcs_17b9, fcns_17ba, css_17bb);
	if( ( !states_17b8.empty())&& ( !tcs_17b9.empty())&& ( !fcns_17ba.empty())&& ( !css_17bb.empty()))
		callNoDefaultTransition_17d9( states_17b8, tcs_17b9, fcns_17ba, css_17bb);
}

void ExecTransConnectorRecurse_178a::callNoDefaultTransition_17d9( const Packets_t& states_88d, const Packets_t& tcs_88f, const Packets_t& fcns_891, const Packets_t& css_893)
{
	NoDefaultTransition_88c noDefaultTransition_88c;
	noDefaultTransition_88c( states_88d, tcs_88f, fcns_891, css_893);
}

void ExecTransitions_17af::operator()( const Packets_t& states_17b0, const Packets_t& tcs_17b2, const Packets_t& fcns_17b4, const Packets_t& css_17b6, Packets_t& states_17b8, Packets_t& tcs_17b9, Packets_t& fcns_17ba, Packets_t& css_17bb)
{
#ifdef PRINT_INFO
	printLog( "ExecTransitions_17af" );
#endif
	_state_17bc= &states_17b8;
	_tc_17bd= &tcs_17b9;
	_fcn_17be= &fcns_17ba;
	_cs_17bf= &css_17bb;
	_state_17bc->insert( _state_17bc->end(), states_17b0.begin(), states_17b0.end());
	_tc_17bd->insert( _tc_17bd->end(), tcs_17b2.begin(), tcs_17b2.end());
	_fcn_17be->insert( _fcn_17be->end(), fcns_17b4.begin(), fcns_17b4.end());
	_cs_17bf->insert( _cs_17bf->end(), css_17b6.begin(), css_17b6.end());
	if( ( !states_17b0.empty())&& ( !tcs_17b2.empty())&& ( !fcns_17b4.empty())&& ( !css_17b6.empty()))
		callGetAllTransitions_17c0( states_17b0, tcs_17b2, fcns_17b4, css_17b6);
}

void ExecTransitions_17af::callGetAllTransitions_17c0( const Packets_t& states_6b4, const Packets_t& tcs_6b6, const Packets_t& fcns_6b8, const Packets_t& css_6ba)
{
	Packets_t states_6bc;
	Packets_t transs_6bd;
	Packets_t fcns_6be;
	Packets_t css_6bf;
	GetAllTransitions_6b3 getAllTransitions_6b3;
	getAllTransitions_6b3( states_6b4, tcs_6b6, fcns_6b8, css_6ba, states_6bc, transs_6bd, fcns_6be, css_6bf);
	if( ( !states_6bc.empty())&& ( !transs_6bd.empty())&& ( !fcns_6be.empty())&& ( !css_6bf.empty()))
		callExecProcessTransitions_17c5( states_6bc, transs_6bd, fcns_6be, css_6bf);
}

void ExecTransitions_17af::callExecProcessTransitions_17c5( const Packets_t& states_16b0, const Packets_t& transs_16b2, const Packets_t& fcns_16b4, const Packets_t& css_16b6)
{
	ExecProcessTransitions_16af execProcessTransitions_16af;
	execProcessTransitions_16af( states_16b0, transs_16b2, fcns_16b4, css_16b6);
}

void CheckForInnerTransitions_1821::operator()( const Packets_t& states_1822, Packets_t& states_1824)
{
#ifdef PRINT_INFO
	printLog( "CheckForInnerTransitions_1821" );
#endif
	_state_1825= &states_1824;
	for( Packets_t::const_iterator itstate_1827= states_1822.begin(); itstate_1827!= states_1822.end(); ++itstate_1827)
	{
		bool isUnique= isInputUnique( *itstate_1827);
		if( !isUnique)
			continue;
		Packets_t onestate_182b( 1, *itstate_1827);
		executeOne( onestate_182b);
	}
}

void CheckForInnerTransitions_1821::executeOne( const Packets_t& states_1822)
{
	Packets_t states_1830;
	HasInnerTransition_182d hasInnerTransition_182d;
	bool isMatchHasInnerTransition_182d= hasInnerTransition_182d( states_1822, states_1830);
	_state_1825->insert( _state_1825->end(), states_1830.begin(), states_1830.end());
	if( isMatchHasInnerTransition_182d)
		return;
}

bool CheckForInnerTransitions_1821::isInputUnique( const Udm::Object& state_1828)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_182a= _state_1826.begin(); itstate_182a!= _state_1826.end(); ++itstate_182a)
	{
		if( ( *itstate_182a== state_1828))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_1826.push_back( state_1828);
	return isUnique;
}

bool HasInnerTransition_182d::operator()( const Packets_t& states_182e, Packets_t& states_1830)
{
#ifdef PRINT_INFO
	printLog( "HasInnerTransition_182d" );
#endif
	_state_1831= &states_1830;
	processInputPackets( states_182e);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasInnerTransition_182d::isInputUnique( const Udm::Object& state_1836)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1838= _state_1832.begin(); itState_1838!= _state_1832.end(); ++itState_1838)
	{
		if( ( *itState_1838== state_1836))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_1832.push_back( state_1836);
	return isUnique;
}

bool HasInnerTransition_182d::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void HasInnerTransition_182d::processInputPackets( const Packets_t& states_182e)
{
	for( Packets_t::const_iterator itState_1833= states_182e.begin(); itState_1833!= states_182e.end(); ++itState_1833)
	{
		bool isUnique= isInputUnique( *itState_1833);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1833);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_1848);
	}
}

bool HasInnerTransition_182d::patternMatcher( const Udm::Object& state_1834)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1834.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1839= CyberComposition::Simulink::State::Cast( state_1834);
		set< CyberComposition::Simulink::ConnectorRef> connectorRefs_183b= state_1839.ConnectorRef_kind_children();
		for( set< CyberComposition::Simulink::ConnectorRef>::const_iterator itConnectorRef_183c= connectorRefs_183b.begin(); itConnectorRef_183c!= connectorRefs_183b.end(); ++itConnectorRef_183c)
		{
			CyberComposition::Simulink::ConnectorRef currConnectorRef_183d= *itConnectorRef_183c;
			CyberComposition::Simulink::TransConnector state_183e= currConnectorRef_183d.ref();
			if( false== Uml::IsDerivedFrom( state_183e.type(), CyberComposition::Simulink::State::meta))
				continue;
			CyberComposition::Simulink::State state_183f= CyberComposition::Simulink::State::Cast( state_183e);
			if( !state_183f)
				continue;
			if( state_1839!= state_183f)
				continue;
			set< CyberComposition::Simulink::Transition> transitions_1840= currConnectorRef_183d.dstTransition();
			for( set< CyberComposition::Simulink::Transition>::const_iterator itTransitions_1841= transitions_1840.begin(); itTransitions_1841!= transitions_1840.end(); ++itTransitions_1841)
			{
				CyberComposition::Simulink::Transition currTransition_1842= *itTransitions_1841;
				CyberComposition::Simulink::TransConnector transConnector_1843= currTransition_1842.dstTransition_end();
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_1847;
				if( !isValidBound(boundObjs_1847, state_1839, true))
					continue;
				currMatch.state_1848= state_1839;
				if( !isValidBound(boundObjs_1847, currTransition_1842, false))
					continue;
				currMatch.transition_1849= currTransition_1842;
				if( !isValidBound(boundObjs_1847, currConnectorRef_183d, false))
					continue;
				currMatch.connectorRef_184a= currConnectorRef_183d;
				if( !isValidBound(boundObjs_1847, transConnector_1843, false))
					continue;
				currMatch.transConnector_184b= transConnector_1843;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void HasInnerTransition_182d::outputAppender( const CyberComposition::Simulink::State& state_184c)
{
	_state_1831->push_back( state_184c);
}

void Init_184e::operator()( const Packets_t& states_184f, Packets_t& states_1851, Packets_t& tcs_1852, Packets_t& fcns_1853, Packets_t& cgs_1854)
{
#ifdef PRINT_INFO
	printLog( "Init_184e" );
#endif
	_state_1855= &states_1851;
	_tc_1856= &tcs_1852;
	_fcn_1857= &fcns_1853;
	_cg_1858= &cgs_1854;
	if( ( !states_184f.empty()))
		callGetExecFunction_18dc( states_184f);
}

void Init_184e::callGetExecFunction_18dc( const Packets_t& states_18c3)
{
	Packets_t states_18c5;
	Packets_t execs_18c6;
	GetExecFunction_18c2 getExecFunction_18c2;
	getExecFunction_18c2( states_18c3, states_18c5, execs_18c6);
	if( ( !states_18c5.empty())&& ( !execs_18c6.empty())&& ( !execs_18c6.empty()))
		callInitHTPVar_18de( states_18c5, execs_18c6, execs_18c6);
}

void Init_184e::callInitHTPVar_18de( const Packets_t& states_1886, const Packets_t& functions_1889, const Packets_t& compoundStatements_188c)
{
	Packets_t states_1888;
	Packets_t functions_188b;
	Packets_t compoundStatements_188e;
	InitHTPVar_1885 initHTPVar_1885;
	initHTPVar_1885( states_1886, functions_1889, compoundStatements_188c, states_1888, functions_188b, compoundStatements_188e);
	if( ( !states_1888.empty())&& ( !functions_188b.empty())&& ( !compoundStatements_188e.empty()))
		callInitTCVarLoop_18e2( states_1888, functions_188b, compoundStatements_188e);
}

void Init_184e::callInitTCVarLoop_18e2( const Packets_t& states_f3, const Packets_t& functions_f6, const Packets_t& compoundStatements_f9)
{
	Packets_t states_f5;
	Packets_t functions_f8;
	Packets_t conditionalGroups_fb;
	InitTCVarLoop_f2 initTCVarLoop_f2;
	initTCVarLoop_f2( states_f3, functions_f6, compoundStatements_f9, states_f5, functions_f8, conditionalGroups_fb);
	if( ( !states_f5.empty())&& ( !functions_f8.empty())&& ( !conditionalGroups_fb.empty()))
		callGetStartTC_18e6( states_f5, functions_f8, conditionalGroups_fb);
}

void Init_184e::callGetStartTC_18e6( const Packets_t& states_185a, const Packets_t& functions_185d, const Packets_t& conditionalGroups_1860)
{
	Packets_t states_185c;
	Packets_t functions_185f;
	Packets_t conditionalGroups_1862;
	GetStartTC_1859 getStartTC_1859;
	getStartTC_1859( states_185a, functions_185d, conditionalGroups_1860, states_185c, functions_185f, conditionalGroups_1862);
	_tc_1856->insert( _tc_1856->end(), states_185c.begin(), states_185c.end());
	_state_1855->insert( _state_1855->end(), states_185c.begin(), states_185c.end());
	_fcn_1857->insert( _fcn_1857->end(), functions_185f.begin(), functions_185f.end());
	_cg_1858->insert( _cg_1858->end(), conditionalGroups_1862.begin(), conditionalGroups_1862.end());
}

void GetStartTC_1859::operator()( const Packets_t& states_185a, const Packets_t& functions_185d, const Packets_t& conditionalGroups_1860, Packets_t& states_185c, Packets_t& functions_185f, Packets_t& conditionalGroups_1862)
{
#ifdef PRINT_INFO
	printLog( "GetStartTC_1859" );
#endif
	RTTGenerator::Instance()->generateRule(797, "GetStartTC");
	_state_1863= &states_185c;
	_function_1864= &functions_185f;
	_conditionalGroup_1865= &conditionalGroups_1862;
	processInputPackets( states_185a, functions_185d, conditionalGroups_1860);
	forwardInputs( );
}

bool GetStartTC_1859::isInputUnique( const Udm::Object& state_186a, const Udm::Object& function_1873, const Udm::Object& conditionalGroup_187c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_186c= _state_1866.begin(), itFunction_1875= _function_186f.begin(), itConditionalGroup_187e= _conditionalGroup_1878.begin(); itState_186c!= _state_1866.end(), itFunction_1875!= _function_186f.end(), itConditionalGroup_187e!= _conditionalGroup_1878.end(); ++itState_186c, ++itFunction_1875, ++itConditionalGroup_187e)
	{
		if( ( *itState_186c== state_186a)&& ( *itFunction_1875== function_1873)&& ( *itConditionalGroup_187e== conditionalGroup_187c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1866.push_back( state_186a);
		_function_186f.push_back( function_1873);
		_conditionalGroup_1878.push_back( conditionalGroup_187c);
	}
	return isUnique;
}

void GetStartTC_1859::processInputPackets( const Packets_t& states_185a, const Packets_t& functions_185d, const Packets_t& conditionalGroups_1860)
{
	for( Packets_t::const_iterator itState_1867= states_185a.begin(), itFunction_1870= functions_185d.begin(), itConditionalGroup_1879= conditionalGroups_1860.begin(); itState_1867!= states_185a.end(), itFunction_1870!= functions_185d.end(), itConditionalGroup_1879!= conditionalGroups_1860.end(); ++itState_1867, ++itFunction_1870, ++itConditionalGroup_1879)
	{
		bool isUnique= isInputUnique( *itState_1867, *itFunction_1870, *itConditionalGroup_1879);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1867, *itFunction_1870, *itConditionalGroup_1879);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetStartTC_1859::patternMatcher( const Udm::Object& state_1868, const Udm::Object& function_1871, const Udm::Object& conditionalGroup_187a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1868.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_186d= CyberComposition::Simulink::State::Cast( state_1868);
		if( false== Uml::IsDerivedFrom( function_1871.type(), SFC::Function::meta))
			continue;
		SFC::Function function_1876= SFC::Function::Cast( function_1871);
		if( false== Uml::IsDerivedFrom( conditionalGroup_187a.type(), SFC::ConditionalGroup::meta))
			continue;
		SFC::ConditionalGroup conditionalGroup_187f= SFC::ConditionalGroup::Cast( conditionalGroup_187a);
		Match currMatch;
		currMatch.state_1882= state_186d;
		currMatch.function_1883= function_1876;
		currMatch.conditionalGroup_1884= conditionalGroup_187f;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void GetStartTC_1859::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
	}
}

void GetStartTC_1859::forwardInputs()
{
	*_state_1863= _state_1866;
	*_function_1864= _function_186f;
	*_conditionalGroup_1865= _conditionalGroup_1878;
}

void InitHTPVar_1885::operator()( const Packets_t& states_1886, const Packets_t& functions_1889, const Packets_t& compoundStatements_188c, Packets_t& states_1888, Packets_t& functions_188b, Packets_t& compoundStatements_188e)
{
#ifdef PRINT_INFO
	printLog( "InitHTPVar_1885" );
#endif
	RTTGenerator::Instance()->generateRule(801, "InitHTPVar");
	_state_188f= &states_1888;
	_function_1890= &functions_188b;
	_compoundStatement_1891= &compoundStatements_188e;
	processInputPackets( states_1886, functions_1889, compoundStatements_188c);
	forwardInputs( );
}

bool InitHTPVar_1885::isInputUnique( const Udm::Object& state_1896, const Udm::Object& function_189f, const Udm::Object& compoundStatement_18a8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1898= _state_1892.begin(), itFunction_18a1= _function_189b.begin(), itCompoundStatement_18aa= _compoundStatement_18a4.begin(); itState_1898!= _state_1892.end(), itFunction_18a1!= _function_189b.end(), itCompoundStatement_18aa!= _compoundStatement_18a4.end(); ++itState_1898, ++itFunction_18a1, ++itCompoundStatement_18aa)
	{
		if( ( *itState_1898== state_1896)&& ( *itFunction_18a1== function_189f)&& ( *itCompoundStatement_18aa== compoundStatement_18a8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1892.push_back( state_1896);
		_function_189b.push_back( function_189f);
		_compoundStatement_18a4.push_back( compoundStatement_18a8);
	}
	return isUnique;
}

bool InitHTPVar_1885::isGuardTrue( SFC::CompoundStatement& CompoundStatement, SFC::Function& Function, SFC::LocalVar& HTPVar, CyberComposition::Simulink::State& State, SFC::StateLabel& StateLabel)
{
	bool Gz_guard= false;
	return static_cast< std::string >( HTPVar.name() ) == "_HTPVar_";;
	return Gz_guard;
}

void InitHTPVar_1885::processInputPackets( const Packets_t& states_1886, const Packets_t& functions_1889, const Packets_t& compoundStatements_188c)
{
	for( Packets_t::const_iterator itState_1893= states_1886.begin(), itFunction_189c= functions_1889.begin(), itCompoundStatement_18a5= compoundStatements_188c.begin(); itState_1893!= states_1886.end(), itFunction_189c!= functions_1889.end(), itCompoundStatement_18a5!= compoundStatements_188c.end(); ++itState_1893, ++itFunction_189c, ++itCompoundStatement_18a5)
	{
		bool isUnique= isInputUnique( *itState_1893, *itFunction_189c, *itCompoundStatement_18a5);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1893, *itFunction_189c, *itCompoundStatement_18a5);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InitHTPVar_1885::patternMatcher( const Udm::Object& state_1894, const Udm::Object& function_189d, const Udm::Object& compoundStatement_18a6)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1894.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1899= CyberComposition::Simulink::State::Cast( state_1894);
		if( false== Uml::IsDerivedFrom( function_189d.type(), SFC::Function::meta))
			continue;
		SFC::Function function_18a2= SFC::Function::Cast( function_189d);
		if( false== Uml::IsDerivedFrom( compoundStatement_18a6.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_18ab= SFC::CompoundStatement::Cast( compoundStatement_18a6);
		set< SFC::LocalVar> hTPVars_18ad= function_18a2.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itHTPVar_18ae= hTPVars_18ad.begin(); itHTPVar_18ae!= hTPVars_18ad.end(); ++itHTPVar_18ae)
		{
			SFC::LocalVar currHTPVar_18af= *itHTPVar_18ae;
			set< SFC::StateLabel> stateLabels_18b0= state_1899.src();
			for( set< SFC::StateLabel>::const_iterator itStateLabels_18b1= stateLabels_18b0.begin(); itStateLabels_18b1!= stateLabels_18b0.end(); ++itStateLabels_18b1)
			{
				SFC::StateLabel currStateLabel_18b2= *itStateLabels_18b1;
				Match currMatch;
				currMatch.state_18b4= state_1899;
				currMatch.function_18b5= function_18a2;
				currMatch.compoundStatement_18b6= compoundStatement_18ab;
				currMatch.stateLabel_18b7= currStateLabel_18b2;
				currMatch.hTPVar_18b8= currHTPVar_18af;
				bool Gz_guard= isGuardTrue( currMatch.compoundStatement_18b6, currMatch.function_18b5, currMatch.hTPVar_18b8, currMatch.state_18b4, currMatch.stateLabel_18b7);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void InitHTPVar_1885::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newInitHTPVar_18be= SFC::UserCode::Create( currMatch.compoundStatement_18b6, SFC::CompoundStatement::meta_stmnt);
		SFC::BinaryExprs newAssignHTPVar_18bf= SFC::BinaryExprs::Create( newInitHTPVar_18be, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newHTPArgDeclRef_18c0= SFC::ArgDeclRef::Create( newAssignHTPVar_18bf, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef_18c1= SFC::ArgDeclRef::Create( newAssignHTPVar_18bf, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_18c1;
		SFC::BinaryExprs& AssignHTPVar= newAssignHTPVar_18bf;
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_18b6;
		SFC::Function& Function= currMatch.function_18b5;
		SFC::ArgDeclRef& HTPArgDeclRef= newHTPArgDeclRef_18c0;
		SFC::LocalVar& HTPVar= currMatch.hTPVar_18b8;
		SFC::UserCode& InitHTPVar= newInitHTPVar_18be;
		CyberComposition::Simulink::State& State= currMatch.state_18b4;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_18b7;
		{
InitHTPVar.RefId() = CompoundStatement.RefId();
};
		{
__int64 statementCount = CompoundStatement.statementCount();
InitHTPVar.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		{
AssignHTPVar.op() = "=";
};
		newArgDeclRef_18c1.argdecl()= currMatch.stateLabel_18b7;
		newHTPArgDeclRef_18c0.argdecl()= currMatch.hTPVar_18b8;
	}
}

void InitHTPVar_1885::forwardInputs()
{
	*_state_188f= _state_1892;
	*_function_1890= _function_189b;
	*_compoundStatement_1891= _compoundStatement_18a4;
}

void GetExecFunction_18c2::operator()( const Packets_t& states_18c3, Packets_t& states_18c5, Packets_t& execs_18c6)
{
#ifdef PRINT_INFO
	printLog( "GetExecFunction_18c2" );
#endif
	RTTGenerator::Instance()->generateRule(822, "GetExecFunction");
	_state_18c7= &states_18c5;
	_exec_18c8= &execs_18c6;
	processInputPackets( states_18c3);
}

bool GetExecFunction_18c2::isInputUnique( const Udm::Object& state_18cd)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_18cf= _state_18c9.begin(); itState_18cf!= _state_18c9.end(); ++itState_18cf)
	{
		if( ( *itState_18cf== state_18cd))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_18c9.push_back( state_18cd);
	return isUnique;
}

void GetExecFunction_18c2::processInputPackets( const Packets_t& states_18c3)
{
	for( Packets_t::const_iterator itState_18ca= states_18c3.begin(); itState_18ca!= states_18c3.end(); ++itState_18ca)
	{
		bool isUnique= isInputUnique( *itState_18ca);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_18ca);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetExecFunction_18c2::patternMatcher( const Udm::Object& state_18cb)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_18cb.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_18d0= CyberComposition::Simulink::State::Cast( state_18cb);
		set< SFC::Function> execs_18d2= state_18d0.exec();
		for( set< SFC::Function>::const_iterator itExecs_18d3= execs_18d2.begin(); itExecs_18d3!= execs_18d2.end(); ++itExecs_18d3)
		{
			SFC::Function currExec_18d4= *itExecs_18d3;
			Match currMatch;
			currMatch.state_18d6= state_18d0;
			currMatch.exec_18d7= currExec_18d4;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetExecFunction_18c2::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_18d6, currMatch.exec_18d7);
	}
}

void GetExecFunction_18c2::outputAppender( const CyberComposition::Simulink::State& state_18d8, const SFC::Function& exec_18da)
{
	_state_18c7->push_back( state_18d8);
	_exec_18c8->push_back( exec_18da);
}

void InitTransConnMapInner_18fd::operator()( const Packets_t& states_18fe, Packets_t& states_1900)
{
#ifdef PRINT_INFO
	printLog( "InitTransConnMapInner_18fd" );
#endif
	_state_1901= &states_1900;
	if( ( !states_18fe.empty()))
		callInitTransConnectorMap_1940( states_18fe);
	_state_1901->insert( _state_1901->end(), states_18fe.begin(), states_18fe.end());
}

void InitTransConnMapInner_18fd::callInitTransConnectorMap_1940( const Packets_t& states_1931)
{
	Packets_t states_1933;
	InitTransConnectorMap_1930 initTransConnectorMap_1930;
	initTransConnectorMap_1930( states_1931, states_1933);
	if( ( !states_1933.empty())&& ( !states_1933.empty()))
		callAddTransConnector_1942( states_1933, states_1933);
}

void InitTransConnMapInner_18fd::callAddTransConnector_1942( const Packets_t& states_ad9, const Packets_t& transConnectors_adc)
{
	Packets_t states_adb;
	Packets_t transConnectors_ade;
	AddTransConnector_ad8 addTransConnector_ad8;
	addTransConnector_ad8( states_ad9, transConnectors_adc, states_adb, transConnectors_ade);
	if( ( !states_adb.empty())&& ( !transConnectors_ade.empty()))
		callGetInnerTransitions_1945( states_adb, transConnectors_ade);
}

void InitTransConnMapInner_18fd::callGetInnerTransitions_1945( const Packets_t& states_1903, const Packets_t& states_1907)
{
	Packets_t states_1905;
	Packets_t transitions_1906;
	GetInnerTransitions_1902 getInnerTransitions_1902;
	getInnerTransitions_1902( states_1903, states_1907, states_1905, transitions_1906);
	if( ( !states_1905.empty())&& ( !transitions_1906.empty()))
		callProcessTransitionsMap_1948( states_1905, transitions_1906);
}

void InitTransConnMapInner_18fd::callProcessTransitionsMap_1948( const Packets_t& states_af7, const Packets_t& transs_af9)
{
	ProcessTransitionsMap_af6 processTransitionsMap_af6;
	processTransitionsMap_af6( states_af7, transs_af9);
}

void GetInnerTransitions_1902::operator()( const Packets_t& states_1903, const Packets_t& states_1907, Packets_t& states_1905, Packets_t& transitions_1906)
{
#ifdef PRINT_INFO
	printLog( "GetInnerTransitions_1902" );
#endif
	RTTGenerator::Instance()->generateRule(745, "GetInnerTransitions");
	_state_1909= &states_1905;
	_transition_190a= &transitions_1906;
	processInputPackets( states_1903, states_1907);
}

bool GetInnerTransitions_1902::isInputUnique( const Udm::Object& state_190f, const Udm::Object& state_1918)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1911= _state_190b.begin(), itState_191a= _state_1914.begin(); itState_1911!= _state_190b.end(), itState_191a!= _state_1914.end(); ++itState_1911, ++itState_191a)
	{
		if( ( *itState_1911== state_190f)&& ( *itState_191a== state_1918))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_190b.push_back( state_190f);
		_state_1914.push_back( state_1918);
	}
	return isUnique;
}

void GetInnerTransitions_1902::processInputPackets( const Packets_t& states_1903, const Packets_t& states_1907)
{
	for( Packets_t::const_iterator itState_190c= states_1903.begin(), itState_1915= states_1907.begin(); itState_190c!= states_1903.end(), itState_1915!= states_1907.end(); ++itState_190c, ++itState_1915)
	{
		bool isUnique= isInputUnique( *itState_190c, *itState_1915);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_190c, *itState_1915);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetInnerTransitions_1902::patternMatcher( const Udm::Object& state_190d, const Udm::Object& state_1916)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_190d.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1912= CyberComposition::Simulink::State::Cast( state_190d);
		if( false== Uml::IsDerivedFrom( state_1916.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_191b= CyberComposition::Simulink::State::Cast( state_1916);
		set< CyberComposition::Simulink::ConnectorRef> connectorRefs_191d= state_191b.ConnectorRef_kind_children();
		for( set< CyberComposition::Simulink::ConnectorRef>::const_iterator itConnectorRef_191e= connectorRefs_191d.begin(); itConnectorRef_191e!= connectorRefs_191d.end(); ++itConnectorRef_191e)
		{
			CyberComposition::Simulink::ConnectorRef currConnectorRef_191f= *itConnectorRef_191e;
			CyberComposition::Simulink::TransConnector state_1920= currConnectorRef_191f.ref();
			if( false== Uml::IsDerivedFrom( state_1920.type(), CyberComposition::Simulink::State::meta))
				continue;
			CyberComposition::Simulink::State state_1921= CyberComposition::Simulink::State::Cast( state_1920);
			if( !state_1921)
				continue;
			if( state_191b!= state_1921)
				continue;
			set< CyberComposition::Simulink::Transition> transitions_1922= currConnectorRef_191f.dstTransition();
			for( set< CyberComposition::Simulink::Transition>::const_iterator itTransitions_1923= transitions_1922.begin(); itTransitions_1923!= transitions_1922.end(); ++itTransitions_1923)
			{
				CyberComposition::Simulink::Transition currTransition_1924= *itTransitions_1923;
				CyberComposition::Simulink::TransConnector dstTransConnector_1925= currTransition_1924.dstTransition_end();
				Match currMatch;
				currMatch.state_1927= state_1912;
				currMatch.state_1928= state_191b;
				currMatch.dstTransConnector_1929= dstTransConnector_1925;
				currMatch.transition_192a= currTransition_1924;
				currMatch.connectorRef_192b= currConnectorRef_191f;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetInnerTransitions_1902::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_1927, currMatch.transition_192a);
	}
}

void GetInnerTransitions_1902::outputAppender( const CyberComposition::Simulink::State& state_192c, const CyberComposition::Simulink::Transition& transition_192e)
{
	_state_1909->push_back( state_192c);
	_transition_190a->push_back( transition_192e);
}

void InitTransConnectorMap_1930::operator()( const Packets_t& states_1931, Packets_t& states_1933)
{
#ifdef PRINT_INFO
	printLog( "InitTransConnectorMap_1930" );
#endif
	RTTGenerator::Instance()->generateRule(864, "InitTransConnectorMap");
	_state_1934= &states_1933;
	processInputPackets( states_1931);
	forwardInputs( );
}

bool InitTransConnectorMap_1930::isInputUnique( const Udm::Object& state_1939)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_193b= _state_1935.begin(); itState_193b!= _state_1935.end(); ++itState_193b)
	{
		if( ( *itState_193b== state_1939))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_1935.push_back( state_1939);
	return isUnique;
}

void InitTransConnectorMap_1930::processInputPackets( const Packets_t& states_1931)
{
	for( Packets_t::const_iterator itState_1936= states_1931.begin(); itState_1936!= states_1931.end(); ++itState_1936)
	{
		bool isUnique= isInputUnique( *itState_1936);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1936);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InitTransConnectorMap_1930::patternMatcher( const Udm::Object& state_1937)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1937.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_193c= CyberComposition::Simulink::State::Cast( state_1937);
		Match currMatch;
		currMatch.state_193f= state_193c;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void InitTransConnectorMap_1930::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		CyberComposition::Simulink::State& State= currMatch.state_193f;
		{
SFManager::StateTransConnectorMap::get_singleton().clearState( State );
};
	}
}

void InitTransConnectorMap_1930::forwardInputs()
{
	*_state_1934= _state_1935;
}

void DuringAction_194b::operator()( const Packets_t& states_194c, Packets_t& states_194e)
{
#ifdef PRINT_INFO
	printLog( "DuringAction_194b" );
#endif
	RTTGenerator::Instance()->generateRule(755, "DuringAction");
	_state_194f= &states_194e;
	processInputPackets( states_194c);
	forwardInputs( );
}

bool DuringAction_194b::isInputUnique( const Udm::Object& state_1954)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1956= _state_1950.begin(); itState_1956!= _state_1950.end(); ++itState_1956)
	{
		if( ( *itState_1956== state_1954))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_1950.push_back( state_1954);
	return isUnique;
}

bool DuringAction_194b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void DuringAction_194b::processInputPackets( const Packets_t& states_194c)
{
	for( Packets_t::const_iterator itState_1951= states_194c.begin(); itState_1951!= states_194c.end(); ++itState_1951)
	{
		bool isUnique= isInputUnique( *itState_1951);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1951);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool DuringAction_194b::patternMatcher( const Udm::Object& state_1952)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1952.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1957= CyberComposition::Simulink::State::Cast( state_1952);
		set< SFC::Function> execs_1959= state_1957.exec();
		for( set< SFC::Function>::const_iterator itExecs_195a= execs_1959.begin(); itExecs_195a!= execs_1959.end(); ++itExecs_195a)
		{
			SFC::Function currExec_195b= *itExecs_195a;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_195f;
			if( !isValidBound(boundObjs_195f, state_1957, true))
				continue;
			currMatch.state_1960= state_1957;
			if( !isValidBound(boundObjs_195f, currExec_195b, false))
				continue;
			currMatch.exec_1961= currExec_195b;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void DuringAction_194b::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function& Exec= currMatch.exec_1961;
		CyberComposition::Simulink::State& State= currMatch.state_1960;
		{
std::string duringAction = State.DuringAction();
SFManager::mstat2SFC( Exec, duringAction );
};
	}
}

void DuringAction_194b::forwardInputs()
{
	*_state_194f= _state_1950;
}

void OuterTransitions_1962::operator()( const Packets_t& states_1963, Packets_t& states_1965)
{
#ifdef PRINT_INFO
	printLog( "OuterTransitions_1962" );
#endif
	_state_1966= &states_1965;
	if( ( !states_1963.empty()))
		callCheckForOuterTransitions_19cf( states_1963);
	_state_1966->insert( _state_1966->end(), states_1963.begin(), states_1963.end());
}

void OuterTransitions_1962::callCheckForOuterTransitions_19cf( const Packets_t& states_1968)
{
	Packets_t states_196a;
	CheckForOuterTransitions_1967 checkForOuterTransitions_1967;
	checkForOuterTransitions_1967( states_1968, states_196a);
	if( ( !states_196a.empty()))
		callInit_19d1( states_196a);
}

void OuterTransitions_1962::callInit_19d1( const Packets_t& states_184f)
{
	Packets_t states_1851;
	Packets_t tcs_1852;
	Packets_t fcns_1853;
	Packets_t cgs_1854;
	Init_184e init_184e;
	init_184e( states_184f, states_1851, tcs_1852, fcns_1853, cgs_1854);
	if( ( !states_1851.empty())&& ( !tcs_1852.empty())&& ( !fcns_1853.empty())&& ( !cgs_1854.empty()))
		callExecTransConnectorRecurse_19d3( states_1851, tcs_1852, fcns_1853, cgs_1854);
}

void OuterTransitions_1962::callExecTransConnectorRecurse_19d3( const Packets_t& states_178b, const Packets_t& tcs_178d, const Packets_t& fcns_178f, const Packets_t& cgs_1791)
{
	ExecTransConnectorRecurse_178a execTransConnectorRecurse_178a;
	execTransConnectorRecurse_178a( states_178b, tcs_178d, fcns_178f, cgs_1791);
}

void CheckForOuterTransitions_1967::operator()( const Packets_t& states_1968, Packets_t& states_196a)
{
#ifdef PRINT_INFO
	printLog( "CheckForOuterTransitions_1967" );
#endif
	_state_196b= &states_196a;
	for( Packets_t::const_iterator itstate_196d= states_1968.begin(); itstate_196d!= states_1968.end(); ++itstate_196d)
	{
		bool isUnique= isInputUnique( *itstate_196d);
		if( !isUnique)
			continue;
		Packets_t onestate_1971( 1, *itstate_196d);
		executeOne( onestate_1971);
	}
}

void CheckForOuterTransitions_1967::executeOne( const Packets_t& states_1968)
{
	Packets_t states_1976;
	HasOuterTransition_1973 hasOuterTransition_1973;
	bool isMatchHasOuterTransition_1973= hasOuterTransition_1973( states_1968, states_1976);
	_state_196b->insert( _state_196b->end(), states_1976.begin(), states_1976.end());
	if( isMatchHasOuterTransition_1973)
		return;
	HasInnerTransition_198b hasInnerTransition_198b;
	bool isMatchHasInnerTransition_198b= hasInnerTransition_198b( states_1968);
	if( isMatchHasInnerTransition_198b)
		return;
	Packets_t states_19a8;
	HasRefOuterTransition_19a5 hasRefOuterTransition_19a5;
	bool isMatchHasRefOuterTransition_19a5= hasRefOuterTransition_19a5( states_1968, states_19a8);
	_state_196b->insert( _state_196b->end(), states_19a8.begin(), states_19a8.end());
	if( isMatchHasRefOuterTransition_19a5)
		return;
	Otherwise_19c1 otherwise_19c1;
	bool isMatchOtherwise_19c1= otherwise_19c1( states_1968);
	if( isMatchOtherwise_19c1)
		return;
}

bool CheckForOuterTransitions_1967::isInputUnique( const Udm::Object& state_196e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_1970= _state_196c.begin(); itstate_1970!= _state_196c.end(); ++itstate_1970)
	{
		if( ( *itstate_1970== state_196e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_196c.push_back( state_196e);
	return isUnique;
}

bool HasOuterTransition_1973::operator()( const Packets_t& states_1974, Packets_t& states_1976)
{
#ifdef PRINT_INFO
	printLog( "HasOuterTransition_1973" );
#endif
	_state_1977= &states_1976;
	processInputPackets( states_1974);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasOuterTransition_1973::isInputUnique( const Udm::Object& state_197c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_197e= _state_1978.begin(); itState_197e!= _state_1978.end(); ++itState_197e)
	{
		if( ( *itState_197e== state_197c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_1978.push_back( state_197c);
	return isUnique;
}

void HasOuterTransition_1973::processInputPackets( const Packets_t& states_1974)
{
	for( Packets_t::const_iterator itState_1979= states_1974.begin(); itState_1979!= states_1974.end(); ++itState_1979)
	{
		bool isUnique= isInputUnique( *itState_1979);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1979);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_1986);
	}
}

bool HasOuterTransition_1973::patternMatcher( const Udm::Object& state_197a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_197a.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_197f= CyberComposition::Simulink::State::Cast( state_197a);
		set< CyberComposition::Simulink::Transition> transitions_1981= state_197f.dstTransition();
		for( set< CyberComposition::Simulink::Transition>::const_iterator itTransitions_1982= transitions_1981.begin(); itTransitions_1982!= transitions_1981.end(); ++itTransitions_1982)
		{
			CyberComposition::Simulink::Transition currTransition_1983= *itTransitions_1982;
			CyberComposition::Simulink::TransConnector transConnector_1984= currTransition_1983.dstTransition_end();
			Match currMatch;
			currMatch.state_1986= state_197f;
			currMatch.transition_1987= currTransition_1983;
			currMatch.transConnector_1988= transConnector_1984;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void HasOuterTransition_1973::outputAppender( const CyberComposition::Simulink::State& state_1989)
{
	_state_1977->push_back( state_1989);
}

bool HasInnerTransition_198b::operator()( const Packets_t& states_198c)
{
#ifdef PRINT_INFO
	printLog( "HasInnerTransition_198b" );
#endif
	processInputPackets( states_198c);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasInnerTransition_198b::isInputUnique( const Udm::Object& state_1992)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1994= _state_198e.begin(); itState_1994!= _state_198e.end(); ++itState_1994)
	{
		if( ( *itState_1994== state_1992))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_198e.push_back( state_1992);
	return isUnique;
}

void HasInnerTransition_198b::processInputPackets( const Packets_t& states_198c)
{
	for( Packets_t::const_iterator itState_198f= states_198c.begin(); itState_198f!= states_198c.end(); ++itState_198f)
	{
		bool isUnique= isInputUnique( *itState_198f);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_198f);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( );
	}
}

bool HasInnerTransition_198b::patternMatcher( const Udm::Object& state_1990)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1990.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1995= CyberComposition::Simulink::State::Cast( state_1990);
		set< CyberComposition::Simulink::ConnectorRef> connectorRefs_1997= state_1995.ConnectorRef_kind_children();
		for( set< CyberComposition::Simulink::ConnectorRef>::const_iterator itConnectorRef_1998= connectorRefs_1997.begin(); itConnectorRef_1998!= connectorRefs_1997.end(); ++itConnectorRef_1998)
		{
			CyberComposition::Simulink::ConnectorRef currConnectorRef_1999= *itConnectorRef_1998;
			CyberComposition::Simulink::TransConnector state_199a= currConnectorRef_1999.ref();
			if( false== Uml::IsDerivedFrom( state_199a.type(), CyberComposition::Simulink::State::meta))
				continue;
			CyberComposition::Simulink::State state_199b= CyberComposition::Simulink::State::Cast( state_199a);
			if( !state_199b)
				continue;
			if( state_1995!= state_199b)
				continue;
			set< CyberComposition::Simulink::Transition> transitions_199c= currConnectorRef_1999.dstTransition();
			for( set< CyberComposition::Simulink::Transition>::const_iterator itTransitions_199d= transitions_199c.begin(); itTransitions_199d!= transitions_199c.end(); ++itTransitions_199d)
			{
				CyberComposition::Simulink::Transition currTransition_199e= *itTransitions_199d;
				CyberComposition::Simulink::TransConnector transConnector_199f= currTransition_199e.dstTransition_end();
				Match currMatch;
				currMatch.state_19a1= state_1995;
				currMatch.transition_19a2= currTransition_199e;
				currMatch.connectorRef_19a3= currConnectorRef_1999;
				currMatch.transConnector_19a4= transConnector_199f;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void HasInnerTransition_198b::outputAppender()
{
}

bool HasRefOuterTransition_19a5::operator()( const Packets_t& states_19a6, Packets_t& states_19a8)
{
#ifdef PRINT_INFO
	printLog( "HasRefOuterTransition_19a5" );
#endif
	_state_19a9= &states_19a8;
	processInputPackets( states_19a6);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasRefOuterTransition_19a5::isInputUnique( const Udm::Object& state_19ae)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_19b0= _state_19aa.begin(); itState_19b0!= _state_19aa.end(); ++itState_19b0)
	{
		if( ( *itState_19b0== state_19ae))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_19aa.push_back( state_19ae);
	return isUnique;
}

void HasRefOuterTransition_19a5::processInputPackets( const Packets_t& states_19a6)
{
	for( Packets_t::const_iterator itState_19ab= states_19a6.begin(); itState_19ab!= states_19a6.end(); ++itState_19ab)
	{
		bool isUnique= isInputUnique( *itState_19ab);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_19ab);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_19bb);
	}
}

bool HasRefOuterTransition_19a5::patternMatcher( const Udm::Object& state_19ac)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_19ac.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_19b1= CyberComposition::Simulink::State::Cast( state_19ac);
		set< CyberComposition::Simulink::ConnectorRef> connectorRefs_19b3= state_19b1.referedbyConnectorRef();
		for( set< CyberComposition::Simulink::ConnectorRef>::const_iterator itConnectorRefs_19b4= connectorRefs_19b3.begin(); itConnectorRefs_19b4!= connectorRefs_19b3.end(); ++itConnectorRefs_19b4)
		{
			CyberComposition::Simulink::ConnectorRef currConnectorRef_19b5= *itConnectorRefs_19b4;
			set< CyberComposition::Simulink::Transition> transitions_19b6= currConnectorRef_19b5.dstTransition();
			for( set< CyberComposition::Simulink::Transition>::const_iterator itTransitions_19b7= transitions_19b6.begin(); itTransitions_19b7!= transitions_19b6.end(); ++itTransitions_19b7)
			{
				CyberComposition::Simulink::Transition currTransition_19b8= *itTransitions_19b7;
				CyberComposition::Simulink::TransConnector transConnector_19b9= currTransition_19b8.dstTransition_end();
				Match currMatch;
				currMatch.state_19bb= state_19b1;
				currMatch.transition_19bc= currTransition_19b8;
				currMatch.connectorRef_19bd= currConnectorRef_19b5;
				currMatch.transConnector_19be= transConnector_19b9;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void HasRefOuterTransition_19a5::outputAppender( const CyberComposition::Simulink::State& state_19bf)
{
	_state_19a9->push_back( state_19bf);
}

bool Otherwise_19c1::operator()( const Packets_t& states_19c2)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_19c1" );
#endif
	processInputPackets( states_19c2);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_19c1::isInputUnique( const Udm::Object& state_19c8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_19ca= _state_19c4.begin(); itState_19ca!= _state_19c4.end(); ++itState_19ca)
	{
		if( ( *itState_19ca== state_19c8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_19c4.push_back( state_19c8);
	return isUnique;
}

void Otherwise_19c1::processInputPackets( const Packets_t& states_19c2)
{
	for( Packets_t::const_iterator itState_19c5= states_19c2.begin(); itState_19c5!= states_19c2.end(); ++itState_19c5)
	{
		bool isUnique= isInputUnique( *itState_19c5);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_19c5);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( );
	}
}

bool Otherwise_19c1::patternMatcher( const Udm::Object& state_19c6)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_19c6.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_19cb= CyberComposition::Simulink::State::Cast( state_19c6);
		Match currMatch;
		currMatch.state_19ce= state_19cb;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_19c1::outputAppender()
{
}

void InitTransConnMap_19d8::operator()( const Packets_t& states_19d9, Packets_t& states_19db)
{
#ifdef PRINT_INFO
	printLog( "InitTransConnMap_19d8" );
#endif
	_state_19dc= &states_19db;
	if( ( !states_19d9.empty()))
		callInitTransConnectorMap_19dd( states_19d9);
	_state_19dc->insert( _state_19dc->end(), states_19d9.begin(), states_19d9.end());
}

void InitTransConnMap_19d8::callInitTransConnectorMap_19dd( const Packets_t& states_1931)
{
	Packets_t states_1933;
	InitTransConnectorMap_1930 initTransConnectorMap_1930;
	initTransConnectorMap_1930( states_1931, states_1933);
	if( ( !states_1933.empty())&& ( !states_1933.empty()))
		callTransConnectorMapRecurse_19df( states_1933, states_1933);
}

void InitTransConnMap_19d8::callTransConnectorMapRecurse_19df( const Packets_t& states_a2b, const Packets_t& tcs_a2d)
{
	TransConnectorMapRecurse_a2a transConnectorMapRecurse_a2a;
	transConnectorMapRecurse_a2a( states_a2b, tcs_a2d);
}

void PopulateExitFunction_19ee::operator()( const Packets_t& states_19ef, const Packets_t& programs_19f1, Packets_t& states_19f3, Packets_t& programs_19f4)
{
#ifdef PRINT_INFO
	printLog( "PopulateExitFunction_19ee" );
#endif
	_state_19f5= &states_19f3;
	_program_19f6= &programs_19f4;
	if( ( !states_19ef.empty()))
		callGetExitFunction_1c0d( states_19ef);
	_state_19f5->insert( _state_19f5->end(), states_19ef.begin(), states_19ef.end());
	_program_19f6->insert( _program_19f6->end(), programs_19f1.begin(), programs_19f1.end());
}

void PopulateExitFunction_19ee::callGetExitFunction_1c0d( const Packets_t& states_1bf1)
{
	Packets_t states_1bf3;
	Packets_t exits_1bf4;
	GetExitFunction_1bf0 getExitFunction_1bf0;
	getExitFunction_1bf0( states_1bf1, states_1bf3, exits_1bf4);
	if( ( !states_1bf3.empty())&& ( !exits_1bf4.empty()))
		callExitChildStates_1c0f( states_1bf3, exits_1bf4);
}

void PopulateExitFunction_19ee::callExitChildStates_1c0f( const Packets_t& states_1a33, const Packets_t& fcns_1a35)
{
	Packets_t states_1a37;
	Packets_t fcns_1a38;
	ExitChildStates_1a32 exitChildStates_1a32;
	exitChildStates_1a32( states_1a33, fcns_1a35, states_1a37, fcns_1a38);
	if( ( !states_1a37.empty())&& ( !fcns_1a38.empty()))
		callGoToParent_1c12( states_1a37, fcns_1a38);
}

void PopulateExitFunction_19ee::callGoToParent_1c12( const Packets_t& states_19f8, const Packets_t& fcns_19fa)
{
	Packets_t states_19fc;
	Packets_t fcns_19fd;
	GoToParent_19f7 goToParent_19f7;
	goToParent_19f7( states_19f8, fcns_19fa, states_19fc, fcns_19fd);
}

void GoToParent_19f7::operator()( const Packets_t& states_19f8, const Packets_t& fcns_19fa, Packets_t& states_19fc, Packets_t& fcns_19fd)
{
#ifdef PRINT_INFO
	printLog( "GoToParent_19f7" );
#endif
	_state_19fe= &states_19fc;
	_fcn_19ff= &fcns_19fd;
	if( ( !states_19f8.empty())&& ( !fcns_19fa.empty()))
		callArgToParent_1a2f( states_19f8, fcns_19fa);
	_state_19fe->insert( _state_19fe->end(), states_19f8.begin(), states_19f8.end());
	_fcn_19ff->insert( _fcn_19ff->end(), fcns_19fa.begin(), fcns_19fa.end());
}

void GoToParent_19f7::callArgToParent_1a2f( const Packets_t& states_1a01, const Packets_t& functions_1a03)
{
	ArgToParent_1a00 argToParent_1a00;
	argToParent_1a00( states_1a01, functions_1a03);
}

void ArgToParent_1a00::operator()( const Packets_t& states_1a01, const Packets_t& functions_1a03)
{
#ifdef PRINT_INFO
	printLog( "ArgToParent_1a00" );
#endif
	RTTGenerator::Instance()->generateRule(877, "ArgToParent");
	processInputPackets( states_1a01, functions_1a03);
}

bool ArgToParent_1a00::isInputUnique( const Udm::Object& state_1a09, const Udm::Object& function_1a12)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1a0b= _state_1a05.begin(), itFunction_1a14= _function_1a0e.begin(); itState_1a0b!= _state_1a05.end(), itFunction_1a14!= _function_1a0e.end(); ++itState_1a0b, ++itFunction_1a14)
	{
		if( ( *itState_1a0b== state_1a09)&& ( *itFunction_1a14== function_1a12))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1a05.push_back( state_1a09);
		_function_1a0e.push_back( function_1a12);
	}
	return isUnique;
}

bool ArgToParent_1a00::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void ArgToParent_1a00::processInputPackets( const Packets_t& states_1a01, const Packets_t& functions_1a03)
{
	for( Packets_t::const_iterator itState_1a06= states_1a01.begin(), itFunction_1a0f= functions_1a03.begin(); itState_1a06!= states_1a01.end(), itFunction_1a0f!= functions_1a03.end(); ++itState_1a06, ++itFunction_1a0f)
	{
		bool isUnique= isInputUnique( *itState_1a06, *itFunction_1a0f);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1a06, *itFunction_1a0f);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ArgToParent_1a00::patternMatcher( const Udm::Object& state_1a07, const Udm::Object& function_1a10)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1a07.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1a0c= CyberComposition::Simulink::State::Cast( state_1a07);
		if( false== Uml::IsDerivedFrom( function_1a10.type(), SFC::Function::meta))
			continue;
		SFC::Function function_1a15= SFC::Function::Cast( function_1a10);
		set< SFC::Arg> args_1a17= function_1a15.Arg_kind_children();
		for( set< SFC::Arg>::const_iterator itArg_1a18= args_1a17.begin(); itArg_1a18!= args_1a17.end(); ++itArg_1a18)
		{
			SFC::Arg currArg_1a19= *itArg_1a18;
			Udm::Object stateParent_1a1a= state_1a0c.container();
			if( false== Uml::IsDerivedFrom( stateParent_1a1a.type(), CyberComposition::Simulink::State::meta))
				continue;
			CyberComposition::Simulink::State parentStateState_1a1b= CyberComposition::Simulink::State::Cast( stateParent_1a1a);
			set< SFC::Function> parentExits_1a1c= parentStateState_1a1b.exit();
			for( set< SFC::Function>::const_iterator itParentExits_1a1d= parentExits_1a1c.begin(); itParentExits_1a1d!= parentExits_1a1c.end(); ++itParentExits_1a1d)
			{
				SFC::Function currParentExit_1a1e= *itParentExits_1a1d;
				set< SFC::Arg> parentArgs_1a1f= currParentExit_1a1e.Arg_kind_children();
				for( set< SFC::Arg>::const_iterator itParentArg_1a20= parentArgs_1a1f.begin(); itParentArg_1a20!= parentArgs_1a1f.end(); ++itParentArg_1a20)
				{
					SFC::Arg currParentArg_1a21= *itParentArg_1a20;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_1a25;
					if( !isValidBound(boundObjs_1a25, state_1a0c, true))
						continue;
					currMatch.state_1a26= state_1a0c;
					if( !isValidBound(boundObjs_1a25, function_1a15, true))
						continue;
					currMatch.function_1a27= function_1a15;
					if( !isValidBound(boundObjs_1a25, parentStateState_1a1b, false))
						continue;
					currMatch.parentState_1a28= parentStateState_1a1b;
					if( !isValidBound(boundObjs_1a25, currParentArg_1a21, false))
						continue;
					currMatch.parentArg_1a29= currParentArg_1a21;
					if( !isValidBound(boundObjs_1a25, currParentExit_1a1e, false))
						continue;
					currMatch.parentExit_1a2a= currParentExit_1a1e;
					if( !isValidBound(boundObjs_1a25, currArg_1a19, false))
						continue;
					currMatch.arg_1a2b= currArg_1a19;
					_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void ArgToParent_1a00::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::FunctionCall newFunctionCall_1a2c= SFC::FunctionCall::Create( currMatch.function_1a27, SFC::Function::meta_stmnt);
		SFC::ArgVal newArgVal_1a2d= SFC::ArgVal::Create( newFunctionCall_1a2c);
		SFC::ArgDeclRef newArgDeclRef_1a2e= SFC::ArgDeclRef::Create( newArgVal_1a2d, SFC::ArgVal::meta_argexpr);
		SFC::Arg& Arg= currMatch.arg_1a2b;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_1a2e;
		SFC::ArgVal& ArgVal= newArgVal_1a2d;
		SFC::Function& Function= currMatch.function_1a27;
		SFC::FunctionCall& FunctionCall= newFunctionCall_1a2c;
		SFC::Arg& ParentArg= currMatch.parentArg_1a29;
		SFC::Function& ParentExit= currMatch.parentExit_1a2a;
		CyberComposition::Simulink::State& ParentState= currMatch.parentState_1a28;
		CyberComposition::Simulink::State& State= currMatch.state_1a26;
		{
FunctionCall.RefId() = Function.RefId();
};
		{
__int64 statementCount = Function.statementCount();
FunctionCall.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		newFunctionCall_1a2c.callee()= currMatch.parentExit_1a2a;
		newArgVal_1a2d.arg()+= currMatch.parentArg_1a29;
		newArgDeclRef_1a2e.argdecl()= currMatch.arg_1a2b;
	}
}

void ExitChildStates_1a32::operator()( const Packets_t& states_1a33, const Packets_t& fcns_1a35, Packets_t& states_1a37, Packets_t& fcns_1a38)
{
#ifdef PRINT_INFO
	printLog( "ExitChildStates_1a32" );
#endif
	_state_1a39= &states_1a37;
	_fcn_1a3a= &fcns_1a38;
	if( ( !states_1a33.empty())&& ( !fcns_1a35.empty()))
		callArgNegOneOrState_1be5( states_1a33, fcns_1a35);
	_state_1a39->insert( _state_1a39->end(), states_1a33.begin(), states_1a33.end());
	_fcn_1a3a->insert( _fcn_1a3a->end(), fcns_1a35.begin(), fcns_1a35.end());
}

void ExitChildStates_1a32::callArgNegOneOrState_1be5( const Packets_t& states_1bac, const Packets_t& functions_1bb0)
{
	Packets_t states_1bae;
	Packets_t args_1baf;
	Packets_t conditionalBlocks_1bb2;
	ArgNegOneOrState_1bab argNegOneOrState_1bab;
	argNegOneOrState_1bab( states_1bac, functions_1bb0, states_1bae, args_1baf, conditionalBlocks_1bb2);
	if( ( !states_1bae.empty())&& ( !args_1baf.empty())&& ( !conditionalBlocks_1bb2.empty()))
		callCallChildExits_1be8( states_1bae, args_1baf, conditionalBlocks_1bb2);
}

void ExitChildStates_1a32::callCallChildExits_1be8( const Packets_t& states_1a82, const Packets_t& args_1a84, const Packets_t& cbs_1a86)
{
	Packets_t states_1a88;
	Packets_t args_1a89;
	Packets_t cbs_1a8a;
	CallChildExits_1a81 callChildExits_1a81;
	callChildExits_1a81( states_1a82, args_1a84, cbs_1a86, states_1a88, args_1a89, cbs_1a8a);
	if( ( !states_1a88.empty())&& ( !args_1a89.empty())&& ( !cbs_1a8a.empty()))
		callDeactivateState_1bec( states_1a88, args_1a89, cbs_1a8a);
}

void ExitChildStates_1a32::callDeactivateState_1bec( const Packets_t& states_1a3c, const Packets_t& args_1a3e, const Packets_t& childrenCalledCBs_1a40)
{
	DeactivateState_1a3b deactivateState_1a3b;
	deactivateState_1a3b( states_1a3c, args_1a3e, childrenCalledCBs_1a40);
}

void DeactivateState_1a3b::operator()( const Packets_t& states_1a3c, const Packets_t& args_1a3e, const Packets_t& childrenCalledCBs_1a40)
{
#ifdef PRINT_INFO
	printLog( "DeactivateState_1a3b" );
#endif
	RTTGenerator::Instance()->generateRule(904, "DeactivateState");
	processInputPackets( states_1a3c, args_1a3e, childrenCalledCBs_1a40);
}

bool DeactivateState_1a3b::isInputUnique( const Udm::Object& state_1a46, const Udm::Object& arg_1a4f, const Udm::Object& childrenCalledCB_1a58)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1a48= _state_1a42.begin(), itArg_1a51= _arg_1a4b.begin(), itChildrenCalledCB_1a5a= _childrenCalledCB_1a54.begin(); itState_1a48!= _state_1a42.end(), itArg_1a51!= _arg_1a4b.end(), itChildrenCalledCB_1a5a!= _childrenCalledCB_1a54.end(); ++itState_1a48, ++itArg_1a51, ++itChildrenCalledCB_1a5a)
	{
		if( ( *itState_1a48== state_1a46)&& ( *itArg_1a51== arg_1a4f)&& ( *itChildrenCalledCB_1a5a== childrenCalledCB_1a58))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1a42.push_back( state_1a46);
		_arg_1a4b.push_back( arg_1a4f);
		_childrenCalledCB_1a54.push_back( childrenCalledCB_1a58);
	}
	return isUnique;
}

bool DeactivateState_1a3b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void DeactivateState_1a3b::processInputPackets( const Packets_t& states_1a3c, const Packets_t& args_1a3e, const Packets_t& childrenCalledCBs_1a40)
{
	for( Packets_t::const_iterator itState_1a43= states_1a3c.begin(), itArg_1a4c= args_1a3e.begin(), itChildrenCalledCB_1a55= childrenCalledCBs_1a40.begin(); itState_1a43!= states_1a3c.end(), itArg_1a4c!= args_1a3e.end(), itChildrenCalledCB_1a55!= childrenCalledCBs_1a40.end(); ++itState_1a43, ++itArg_1a4c, ++itChildrenCalledCB_1a55)
	{
		bool isUnique= isInputUnique( *itState_1a43, *itArg_1a4c, *itChildrenCalledCB_1a55);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1a43, *itArg_1a4c, *itChildrenCalledCB_1a55);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool DeactivateState_1a3b::patternMatcher( const Udm::Object& state_1a44, const Udm::Object& arg_1a4d, const Udm::Object& childrenCalledCB_1a56)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1a44.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1a49= CyberComposition::Simulink::State::Cast( state_1a44);
		if( false== Uml::IsDerivedFrom( arg_1a4d.type(), SFC::Arg::meta))
			continue;
		SFC::Arg arg_1a52= SFC::Arg::Cast( arg_1a4d);
		if( false== Uml::IsDerivedFrom( childrenCalledCB_1a56.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock childrenCalledCB_1a5b= SFC::ConditionalBlock::Cast( childrenCalledCB_1a56);
		Udm::Object stateParent_1a5d= state_1a49.container();
		if( false== Uml::IsDerivedFrom( stateParent_1a5d.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State parentStateState_1a5e= CyberComposition::Simulink::State::Cast( stateParent_1a5d);
		set< SFC::Function> functions_1a5f= parentStateState_1a5e.exit();
		for( set< SFC::Function>::const_iterator itFunctions_1a60= functions_1a5f.begin(); itFunctions_1a60!= functions_1a5f.end(); ++itFunctions_1a60)
		{
			SFC::Function currFunction_1a61= *itFunctions_1a60;
			Udm::Object functionParent_1a62= currFunction_1a61.container();
			if( false== Uml::IsDerivedFrom( functionParent_1a62.type(), SFC::Program::meta))
				continue;
			SFC::Program programFunction_1a63= SFC::Program::Cast( functionParent_1a62);
			set< SFC::StateVar> stateVars_1a64= programFunction_1a63.StateVar_kind_children();
			for( set< SFC::StateVar>::const_iterator itStateVar_1a65= stateVars_1a64.begin(); itStateVar_1a65!= stateVars_1a64.end(); ++itStateVar_1a65)
			{
				SFC::StateVar currStateVar_1a66= *itStateVar_1a65;
				set< SFC::StateLabel> parentStateLabels_1a67= parentStateState_1a5e.src();
				for( set< SFC::StateLabel>::const_iterator itParentStateLabels_1a68= parentStateLabels_1a67.begin(); itParentStateLabels_1a68!= parentStateLabels_1a67.end(); ++itParentStateLabels_1a68)
				{
					SFC::StateLabel currParentStateLabel_1a69= *itParentStateLabels_1a68;
					set< SFC::StateLabel> stateLabels_1a6a= state_1a49.src();
					for( set< SFC::StateLabel>::const_iterator itStateLabels_1a6b= stateLabels_1a6a.begin(); itStateLabels_1a6b!= stateLabels_1a6a.end(); ++itStateLabels_1a6b)
					{
						SFC::StateLabel currStateLabel_1a6c= *itStateLabels_1a6b;
						Match currMatch;
						set< pair<int, Udm::Object> > boundObjs_1a70;
						if( !isValidBound(boundObjs_1a70, state_1a49, true))
							continue;
						currMatch.state_1a71= state_1a49;
						if( !isValidBound(boundObjs_1a70, arg_1a52, true))
							continue;
						currMatch.arg_1a72= arg_1a52;
						if( !isValidBound(boundObjs_1a70, childrenCalledCB_1a5b, true))
							continue;
						currMatch.childrenCalledCB_1a73= childrenCalledCB_1a5b;
						if( !isValidBound(boundObjs_1a70, parentStateState_1a5e, false))
							continue;
						currMatch.parentState_1a74= parentStateState_1a5e;
						if( !isValidBound(boundObjs_1a70, currFunction_1a61, false))
							continue;
						currMatch.function_1a75= currFunction_1a61;
						if( !isValidBound(boundObjs_1a70, currStateLabel_1a6c, false))
							continue;
						currMatch.stateLabel_1a76= currStateLabel_1a6c;
						if( !isValidBound(boundObjs_1a70, currParentStateLabel_1a69, false))
							continue;
						currMatch.parentStateLabel_1a77= currParentStateLabel_1a69;
						if( !isValidBound(boundObjs_1a70, programFunction_1a63, false))
							continue;
						currMatch.program_1a78= programFunction_1a63;
						if( !isValidBound(boundObjs_1a70, currStateVar_1a66, false))
							continue;
						currMatch.stateVar_1a79= currStateVar_1a66;
						_matches.push_back( currMatch);
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void DeactivateState_1a3b::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Return newReturn_1a7a= SFC::Return::Create( currMatch.childrenCalledCB_1a73, SFC::ConditionalBlock::meta_stmnt);
		SFC::ConditionalBlock newConditionalBlock_1a7b= SFC::ConditionalBlock::Create( currMatch.childrenCalledCB_1a73, SFC::ConditionalBlock::meta_stmnt);
		SFC::SetState newSetState_1a7c= SFC::SetState::Create( newConditionalBlock_1a7b, SFC::ConditionalBlock::meta_stmnt);
		SFC::UserCode newUserCode_1a7d= SFC::UserCode::Create( newConditionalBlock_1a7b, SFC::ConditionalBlock::meta_cond);
		SFC::BinaryExprs newEqual_1a7e= SFC::BinaryExprs::Create( newUserCode_1a7d, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newArgDeclRef_1a7f= SFC::ArgDeclRef::Create( newEqual_1a7e, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newInt_1a80= SFC::Int::Create( newEqual_1a7e, SFC::BinaryExprs::meta_rightexpr);
		SFC::Arg& Arg= currMatch.arg_1a72;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_1a7f;
		SFC::ConditionalBlock& ChildrenCalledCB= currMatch.childrenCalledCB_1a73;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_1a7b;
		SFC::BinaryExprs& Equal= newEqual_1a7e;
		SFC::Function& Function= currMatch.function_1a75;
		SFC::Int& Int= newInt_1a80;
		CyberComposition::Simulink::State& ParentState= currMatch.parentState_1a74;
		SFC::StateLabel& ParentStateLabel= currMatch.parentStateLabel_1a77;
		SFC::Program& Program= currMatch.program_1a78;
		SFC::Return& Return= newReturn_1a7a;
		SFC::SetState& SetState= newSetState_1a7c;
		CyberComposition::Simulink::State& State= currMatch.state_1a71;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_1a76;
		SFC::StateVar& StateVar= currMatch.stateVar_1a79;
		SFC::UserCode& UserCode= newUserCode_1a7d;
		{
ConditionalBlock.RefId() = UserCode.RefId() = SetState.RefId() = Return.RefId() = ChildrenCalledCB.RefId();
};
		{
std::string exitAction = State.ExitAction();
exitAction = SFManager::trim( exitAction );

SFManager::mstat2SFC( ConditionalBlock, exitAction );

__int64 statementCount = ConditionalBlock.statementCount();
SetState.statementIndex() = statementCount++;
ConditionalBlock.statementCount() = statementCount;

};
		{
SetState.invert() = true;
SetState.andState() = static_cast< std::string >( State.Decomposition() ) == "AND_STATE";
};
		{
__int64 statementCount = ChildrenCalledCB.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
Return.statementIndex() = statementCount++;
ChildrenCalledCB.statementCount() = statementCount;
};
		{
Equal.op() = "==";
Int.val() = -1;
};
		newSetState_1a7c.index()= currMatch.parentStateLabel_1a77;
		newSetState_1a7c.value()= currMatch.stateLabel_1a76;
		newSetState_1a7c.svar()= currMatch.stateVar_1a79;
		newArgDeclRef_1a7f.argdecl()= currMatch.arg_1a72;
	}
}

void CallChildExits_1a81::operator()( const Packets_t& states_1a82, const Packets_t& args_1a84, const Packets_t& cbs_1a86, Packets_t& states_1a88, Packets_t& args_1a89, Packets_t& cbs_1a8a)
{
#ifdef PRINT_INFO
	printLog( "CallChildExits_1a81" );
#endif
	_state_1a8b= &states_1a88;
	_arg_1a8c= &args_1a89;
	_cb_1a8d= &cbs_1a8a;
	if( ( !states_1a82.empty())&& ( !cbs_1a86.empty()))
		callOrStateCG_1ba1( states_1a82, cbs_1a86);
	_state_1a8b->insert( _state_1a8b->end(), states_1a82.begin(), states_1a82.end());
	_arg_1a8c->insert( _arg_1a8c->end(), args_1a84.begin(), args_1a84.end());
	_cb_1a8d->insert( _cb_1a8d->end(), cbs_1a86.begin(), cbs_1a86.end());
}

void CallChildExits_1a81::callOrStateCG_1ba1( const Packets_t& states_1a8f, const Packets_t& css_1a91)
{
	Packets_t states_1a93;
	Packets_t css_1a94;
	OrStateCG_1a8e orStateCG_1a8e;
	orStateCG_1a8e( states_1a8f, css_1a91, states_1a93, css_1a94);
	if( ( !states_1a93.empty())&& ( !css_1a94.empty()))
		callROrderChildStates_1ba4( states_1a93, css_1a94);
}

void CallChildExits_1a81::callROrderChildStates_1ba4( const Packets_t& states_1b30, const Packets_t& compoundStatements_1b34)
{
	Packets_t states_1b32;
	Packets_t states_1b33;
	Packets_t compoundStatements_1b36;
	ROrderChildStates_1b2f rOrderChildStates_1b2f;
	rOrderChildStates_1b2f( states_1b30, compoundStatements_1b34, states_1b32, states_1b33, compoundStatements_1b36);
	if( ( !states_1b32.empty())&& ( !states_1b33.empty())&& ( !compoundStatements_1b36.empty()))
		callExitChildStates_1ba7( states_1b32, states_1b33, compoundStatements_1b36);
}

void CallChildExits_1a81::callExitChildStates_1ba7( const Packets_t& states_1b5d, const Packets_t& childStates_1b5f, const Packets_t& compoundStatements_1b61)
{
	ExitChildStates_1b5c exitChildStates_1b5c;
	exitChildStates_1b5c( states_1b5d, childStates_1b5f, compoundStatements_1b61);
}

void OrStateCG_1a8e::operator()( const Packets_t& states_1a8f, const Packets_t& css_1a91, Packets_t& states_1a93, Packets_t& css_1a94)
{
#ifdef PRINT_INFO
	printLog( "OrStateCG_1a8e" );
#endif
	_state_1a95= &states_1a93;
	_cs_1a96= &css_1a94;
	if( ( !states_1a8f.empty())&& ( !css_1a91.empty()))
		callChildStateType_1b29( states_1a8f, css_1a91);
}

void OrStateCG_1a8e::callChildStateType_1b29( const Packets_t& states_1abe, const Packets_t& css_1ac0)
{
	Packets_t states_1ac2;
	Packets_t css_1ac3;
	Packets_t states_1ac4;
	Packets_t css_1ac5;
	ChildStateType_1abd childStateType_1abd;
	childStateType_1abd( states_1abe, css_1ac0, states_1ac2, css_1ac3, states_1ac4, css_1ac5);
	_state_1a95->insert( _state_1a95->end(), states_1ac2.begin(), states_1ac2.end());
	_cs_1a96->insert( _cs_1a96->end(), css_1ac3.begin(), css_1ac3.end());
	if( ( !states_1ac4.empty())&& ( !css_1ac5.empty()))
		callCG_1b2c( states_1ac4, css_1ac5);
}

void OrStateCG_1a8e::callCG_1b2c( const Packets_t& states_1a98, const Packets_t& compoundStatements_1a9b)
{
	Packets_t states_1a9a;
	Packets_t conditionalGroups_1a9d;
	CG_1a97 cG_1a97;
	cG_1a97( states_1a98, compoundStatements_1a9b, states_1a9a, conditionalGroups_1a9d);
	_state_1a95->insert( _state_1a95->end(), states_1a9a.begin(), states_1a9a.end());
	_cs_1a96->insert( _cs_1a96->end(), conditionalGroups_1a9d.begin(), conditionalGroups_1a9d.end());
}

void CG_1a97::operator()( const Packets_t& states_1a98, const Packets_t& compoundStatements_1a9b, Packets_t& states_1a9a, Packets_t& conditionalGroups_1a9d)
{
#ifdef PRINT_INFO
	printLog( "CG_1a97" );
#endif
	RTTGenerator::Instance()->generateRule(955, "CG");
	_state_1a9e= &states_1a9a;
	_conditionalGroup_1a9f= &conditionalGroups_1a9d;
	processInputPackets( states_1a98, compoundStatements_1a9b);
}

bool CG_1a97::isInputUnique( const Udm::Object& state_1aa4, const Udm::Object& compoundStatement_1aad)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1aa6= _state_1aa0.begin(), itCompoundStatement_1aaf= _compoundStatement_1aa9.begin(); itState_1aa6!= _state_1aa0.end(), itCompoundStatement_1aaf!= _compoundStatement_1aa9.end(); ++itState_1aa6, ++itCompoundStatement_1aaf)
	{
		if( ( *itState_1aa6== state_1aa4)&& ( *itCompoundStatement_1aaf== compoundStatement_1aad))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1aa0.push_back( state_1aa4);
		_compoundStatement_1aa9.push_back( compoundStatement_1aad);
	}
	return isUnique;
}

bool CG_1a97::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CG_1a97::processInputPackets( const Packets_t& states_1a98, const Packets_t& compoundStatements_1a9b)
{
	for( Packets_t::const_iterator itState_1aa1= states_1a98.begin(), itCompoundStatement_1aaa= compoundStatements_1a9b.begin(); itState_1aa1!= states_1a98.end(), itCompoundStatement_1aaa!= compoundStatements_1a9b.end(); ++itState_1aa1, ++itCompoundStatement_1aaa)
	{
		bool isUnique= isInputUnique( *itState_1aa1, *itCompoundStatement_1aaa);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1aa1, *itCompoundStatement_1aaa);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CG_1a97::patternMatcher( const Udm::Object& state_1aa2, const Udm::Object& compoundStatement_1aab)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1aa2.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1aa7= CyberComposition::Simulink::State::Cast( state_1aa2);
		if( false== Uml::IsDerivedFrom( compoundStatement_1aab.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_1ab0= SFC::CompoundStatement::Cast( compoundStatement_1aab);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1ab5;
		if( !isValidBound(boundObjs_1ab5, state_1aa7, true))
			continue;
		currMatch.state_1ab6= state_1aa7;
		if( !isValidBound(boundObjs_1ab5, compoundStatement_1ab0, true))
			continue;
		currMatch.compoundStatement_1ab7= compoundStatement_1ab0;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CG_1a97::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalGroup newConditionalGroup_1ab8= SFC::ConditionalGroup::Create( currMatch.compoundStatement_1ab7, SFC::CompoundStatement::meta_stmnt);
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_1ab7;
		SFC::ConditionalGroup& ConditionalGroup= newConditionalGroup_1ab8;
		CyberComposition::Simulink::State& State= currMatch.state_1ab6;
		{
ConditionalGroup.RefId() = CompoundStatement.RefId();
};
		{
__int64 statementCount = CompoundStatement.statementCount();
ConditionalGroup.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		outputAppender( currMatch.state_1ab6, newConditionalGroup_1ab8);
	}
}

void CG_1a97::outputAppender( const CyberComposition::Simulink::State& state_1ab9, const SFC::ConditionalGroup& conditionalGroup_1abb)
{
	_state_1a9e->push_back( state_1ab9);
	_conditionalGroup_1a9f->push_back( conditionalGroup_1abb);
}

void ChildStateType_1abd::operator()( const Packets_t& states_1abe, const Packets_t& css_1ac0, Packets_t& states_1ac2, Packets_t& css_1ac3, Packets_t& states_1ac4, Packets_t& css_1ac5)
{
#ifdef PRINT_INFO
	printLog( "ChildStateType_1abd" );
#endif
	_state_1ac6= &states_1ac2;
	_cs_1ac7= &css_1ac3;
	_state_1ac8= &states_1ac4;
	_cs_1ac9= &css_1ac5;
	for( Packets_t::const_iterator itstate_1acb= states_1abe.begin(), itcs_1ad2= css_1ac0.begin(); itstate_1acb!= states_1abe.end(), itcs_1ad2!= css_1ac0.end(); ++itstate_1acb, ++itcs_1ad2)
	{
		bool isUnique= isInputUnique( *itstate_1acb, *itcs_1ad2);
		if( !isUnique)
			continue;
		Packets_t onestate_1acf( 1, *itstate_1acb);
		Packets_t onecs_1ad6( 1, *itcs_1ad2);
		executeOne( onestate_1acf, onecs_1ad6);
	}
}

void ChildStateType_1abd::executeOne( const Packets_t& states_1abe, const Packets_t& css_1ac0)
{
	Packets_t states_1adb;
	Packets_t compoundStatements_1ade;
	ChildAndStates_1ad8 childAndStates_1ad8;
	bool isMatchChildAndStates_1ad8= childAndStates_1ad8( states_1abe, css_1ac0, states_1adb, compoundStatements_1ade);
	_state_1ac6->insert( _state_1ac6->end(), states_1adb.begin(), states_1adb.end());
	_cs_1ac7->insert( _cs_1ac7->end(), compoundStatements_1ade.begin(), compoundStatements_1ade.end());
	if( isMatchChildAndStates_1ad8)
		return;
	Packets_t states_1b07;
	Packets_t compoundStatements_1b0a;
	ChildOrStates_1b04 childOrStates_1b04;
	bool isMatchChildOrStates_1b04= childOrStates_1b04( states_1abe, css_1ac0, states_1b07, compoundStatements_1b0a);
	_state_1ac8->insert( _state_1ac8->end(), states_1b07.begin(), states_1b07.end());
	_cs_1ac9->insert( _cs_1ac9->end(), compoundStatements_1b0a.begin(), compoundStatements_1b0a.end());
	if( isMatchChildOrStates_1b04)
		return;
}

bool ChildStateType_1abd::isInputUnique( const Udm::Object& state_1acc, const Udm::Object& cs_1ad3)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_1ace= _state_1aca.begin(), itcs_1ad5= _cs_1ad1.begin(); itstate_1ace!= _state_1aca.end(), itcs_1ad5!= _cs_1ad1.end(); ++itstate_1ace, ++itcs_1ad5)
	{
		if( ( *itstate_1ace== state_1acc)&& ( *itcs_1ad5== cs_1ad3))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1aca.push_back( state_1acc);
		_cs_1ad1.push_back( cs_1ad3);
	}
	return isUnique;
}

bool ChildAndStates_1ad8::operator()( const Packets_t& states_1ad9, const Packets_t& compoundStatements_1adc, Packets_t& states_1adb, Packets_t& compoundStatements_1ade)
{
#ifdef PRINT_INFO
	printLog( "ChildAndStates_1ad8" );
#endif
	_state_1adf= &states_1adb;
	_compoundStatement_1ae0= &compoundStatements_1ade;
	processInputPackets( states_1ad9, compoundStatements_1adc);
	if( false== _matches.empty())
		return true;
	return false;
}

bool ChildAndStates_1ad8::isInputUnique( const Udm::Object& state_1ae5, const Udm::Object& compoundStatement_1aee)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1ae7= _state_1ae1.begin(), itCompoundStatement_1af0= _compoundStatement_1aea.begin(); itState_1ae7!= _state_1ae1.end(), itCompoundStatement_1af0!= _compoundStatement_1aea.end(); ++itState_1ae7, ++itCompoundStatement_1af0)
	{
		if( ( *itState_1ae7== state_1ae5)&& ( *itCompoundStatement_1af0== compoundStatement_1aee))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1ae1.push_back( state_1ae5);
		_compoundStatement_1aea.push_back( compoundStatement_1aee);
	}
	return isUnique;
}

bool ChildAndStates_1ad8::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool ChildAndStates_1ad8::isGuardTrue( CyberComposition::Simulink::State& ChildState, SFC::CompoundStatement& CompoundStatement, CyberComposition::Simulink::State& State)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( ChildState.Decomposition() ) == "AND_STATE";;
	return Gz_guard;
}

void ChildAndStates_1ad8::processInputPackets( const Packets_t& states_1ad9, const Packets_t& compoundStatements_1adc)
{
	for( Packets_t::const_iterator itState_1ae2= states_1ad9.begin(), itCompoundStatement_1aeb= compoundStatements_1adc.begin(); itState_1ae2!= states_1ad9.end(), itCompoundStatement_1aeb!= compoundStatements_1adc.end(); ++itState_1ae2, ++itCompoundStatement_1aeb)
	{
		bool isUnique= isInputUnique( *itState_1ae2, *itCompoundStatement_1aeb);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1ae2, *itCompoundStatement_1aeb);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_1afa, currMatch.compoundStatement_1afb);
	}
}

bool ChildAndStates_1ad8::patternMatcher( const Udm::Object& state_1ae3, const Udm::Object& compoundStatement_1aec)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1ae3.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1ae8= CyberComposition::Simulink::State::Cast( state_1ae3);
		if( false== Uml::IsDerivedFrom( compoundStatement_1aec.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_1af1= SFC::CompoundStatement::Cast( compoundStatement_1aec);
		set< CyberComposition::Simulink::State> childStates_1af3= state_1ae8.State_kind_children();
		for( set< CyberComposition::Simulink::State>::const_iterator itChildState_1af4= childStates_1af3.begin(); itChildState_1af4!= childStates_1af3.end(); ++itChildState_1af4)
		{
			CyberComposition::Simulink::State currChildState_1af5= *itChildState_1af4;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1af9;
			if( !isValidBound(boundObjs_1af9, state_1ae8, true))
				continue;
			currMatch.state_1afa= state_1ae8;
			if( !isValidBound(boundObjs_1af9, compoundStatement_1af1, true))
				continue;
			currMatch.compoundStatement_1afb= compoundStatement_1af1;
			if( !isValidBound(boundObjs_1af9, currChildState_1af5, false))
				continue;
			currMatch.childState_1afc= currChildState_1af5;
			bool Gz_guard= isGuardTrue( currMatch.childState_1afc, currMatch.compoundStatement_1afb, currMatch.state_1afa);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void ChildAndStates_1ad8::outputAppender( const CyberComposition::Simulink::State& state_1b00, const SFC::CompoundStatement& compoundStatement_1b02)
{
	_state_1adf->push_back( state_1b00);
	_compoundStatement_1ae0->push_back( compoundStatement_1b02);
}

bool ChildOrStates_1b04::operator()( const Packets_t& states_1b05, const Packets_t& compoundStatements_1b08, Packets_t& states_1b07, Packets_t& compoundStatements_1b0a)
{
#ifdef PRINT_INFO
	printLog( "ChildOrStates_1b04" );
#endif
	_state_1b0b= &states_1b07;
	_compoundStatement_1b0c= &compoundStatements_1b0a;
	processInputPackets( states_1b05, compoundStatements_1b08);
	if( false== _matches.empty())
		return true;
	return false;
}

bool ChildOrStates_1b04::isInputUnique( const Udm::Object& state_1b11, const Udm::Object& compoundStatement_1b1a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1b13= _state_1b0d.begin(), itCompoundStatement_1b1c= _compoundStatement_1b16.begin(); itState_1b13!= _state_1b0d.end(), itCompoundStatement_1b1c!= _compoundStatement_1b16.end(); ++itState_1b13, ++itCompoundStatement_1b1c)
	{
		if( ( *itState_1b13== state_1b11)&& ( *itCompoundStatement_1b1c== compoundStatement_1b1a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1b0d.push_back( state_1b11);
		_compoundStatement_1b16.push_back( compoundStatement_1b1a);
	}
	return isUnique;
}

bool ChildOrStates_1b04::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void ChildOrStates_1b04::processInputPackets( const Packets_t& states_1b05, const Packets_t& compoundStatements_1b08)
{
	for( Packets_t::const_iterator itState_1b0e= states_1b05.begin(), itCompoundStatement_1b17= compoundStatements_1b08.begin(); itState_1b0e!= states_1b05.end(), itCompoundStatement_1b17!= compoundStatements_1b08.end(); ++itState_1b0e, ++itCompoundStatement_1b17)
	{
		bool isUnique= isInputUnique( *itState_1b0e, *itCompoundStatement_1b17);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1b0e, *itCompoundStatement_1b17);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_1b23, currMatch.compoundStatement_1b24);
	}
}

bool ChildOrStates_1b04::patternMatcher( const Udm::Object& state_1b0f, const Udm::Object& compoundStatement_1b18)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1b0f.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1b14= CyberComposition::Simulink::State::Cast( state_1b0f);
		if( false== Uml::IsDerivedFrom( compoundStatement_1b18.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_1b1d= SFC::CompoundStatement::Cast( compoundStatement_1b18);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1b22;
		if( !isValidBound(boundObjs_1b22, state_1b14, true))
			continue;
		currMatch.state_1b23= state_1b14;
		if( !isValidBound(boundObjs_1b22, compoundStatement_1b1d, true))
			continue;
		currMatch.compoundStatement_1b24= compoundStatement_1b1d;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void ChildOrStates_1b04::outputAppender( const CyberComposition::Simulink::State& state_1b25, const SFC::CompoundStatement& compoundStatement_1b27)
{
	_state_1b0b->push_back( state_1b25);
	_compoundStatement_1b0c->push_back( compoundStatement_1b27);
}

void ROrderChildStates_1b2f::operator()( const Packets_t& states_1b30, const Packets_t& compoundStatements_1b34, Packets_t& states_1b32, Packets_t& states_1b33, Packets_t& compoundStatements_1b36)
{
#ifdef PRINT_INFO
	printLog( "ROrderChildStates_1b2f" );
#endif
	RTTGenerator::Instance()->generateRule(977, "ROrderChildStates");
	_state_1b37= &states_1b32;
	_state_1b38= &states_1b33;
	_compoundStatement_1b39= &compoundStatements_1b36;
	processInputPackets( states_1b30, compoundStatements_1b34);
	sortOutputs( );
}

bool ROrderChildStates_1b2f::isInputUnique( const Udm::Object& state_1b3e, const Udm::Object& compoundStatement_1b47)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1b40= _state_1b3a.begin(), itCompoundStatement_1b49= _compoundStatement_1b43.begin(); itState_1b40!= _state_1b3a.end(), itCompoundStatement_1b49!= _compoundStatement_1b43.end(); ++itState_1b40, ++itCompoundStatement_1b49)
	{
		if( ( *itState_1b40== state_1b3e)&& ( *itCompoundStatement_1b49== compoundStatement_1b47))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1b3a.push_back( state_1b3e);
		_compoundStatement_1b43.push_back( compoundStatement_1b47);
	}
	return isUnique;
}

bool ROrderChildStates_1b2f::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void ROrderChildStates_1b2f::processInputPackets( const Packets_t& states_1b30, const Packets_t& compoundStatements_1b34)
{
	for( Packets_t::const_iterator itState_1b3b= states_1b30.begin(), itCompoundStatement_1b44= compoundStatements_1b34.begin(); itState_1b3b!= states_1b30.end(), itCompoundStatement_1b44!= compoundStatements_1b34.end(); ++itState_1b3b, ++itCompoundStatement_1b44)
	{
		bool isUnique= isInputUnique( *itState_1b3b, *itCompoundStatement_1b44);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1b3b, *itCompoundStatement_1b44);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ROrderChildStates_1b2f::patternMatcher( const Udm::Object& state_1b3c, const Udm::Object& compoundStatement_1b45)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1b3c.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1b41= CyberComposition::Simulink::State::Cast( state_1b3c);
		if( false== Uml::IsDerivedFrom( compoundStatement_1b45.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_1b4a= SFC::CompoundStatement::Cast( compoundStatement_1b45);
		set< CyberComposition::Simulink::State> states_1b4c= state_1b41.State_kind_children();
		for( set< CyberComposition::Simulink::State>::const_iterator itState_1b4d= states_1b4c.begin(); itState_1b4d!= states_1b4c.end(); ++itState_1b4d)
		{
			CyberComposition::Simulink::State currState_1b4e= *itState_1b4d;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1b52;
			if( !isValidBound(boundObjs_1b52, state_1b41, true))
				continue;
			currMatch.state_1b53= state_1b41;
			if( !isValidBound(boundObjs_1b52, compoundStatement_1b4a, true))
				continue;
			currMatch.compoundStatement_1b54= compoundStatement_1b4a;
			if( !isValidBound(boundObjs_1b52, currState_1b4e, false))
				continue;
			currMatch.state_1b55= currState_1b4e;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void ROrderChildStates_1b2f::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_1b53, currMatch.state_1b55, currMatch.compoundStatement_1b54);
	}
}

void ROrderChildStates_1b2f::outputAppender( const CyberComposition::Simulink::State& state_1b56, const CyberComposition::Simulink::State& state_1b58, const SFC::CompoundStatement& compoundStatement_1b5a)
{
	_state_1b37->push_back( state_1b56);
	_state_1b38->push_back( state_1b58);
	_compoundStatement_1b39->push_back( compoundStatement_1b5a);
}

void ROrderChildStates_1b2f::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::State, std::pointer_to_binary_function< const CyberComposition::Simulink::State&, const CyberComposition::Simulink::State&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::State&, const CyberComposition::Simulink::State&, bool> ptr_StateRevOrder( StateRevOrder< CyberComposition::Simulink::State>);
	SortedSet_t sortedSet( ptr_StateRevOrder);
	std::vector< int> permutationVector( _state_1b38->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _state_1b38->begin(); it!= _state_1b38->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::State::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _state_1b38->begin());
	// order rest of the containers
	permutate( permutationVector, *_state_1b37);
	permutate( permutationVector, *_compoundStatement_1b39);
}

void ExitChildStates_1b5c::operator()( const Packets_t& states_1b5d, const Packets_t& childStates_1b5f, const Packets_t& compoundStatements_1b61)
{
#ifdef PRINT_INFO
	printLog( "ExitChildStates_1b5c" );
#endif
	RTTGenerator::Instance()->generateRule(982, "ExitChildStates");
	processInputPackets( states_1b5d, childStates_1b5f, compoundStatements_1b61);
}

bool ExitChildStates_1b5c::isInputUnique( const Udm::Object& state_1b67, const Udm::Object& childState_1b70, const Udm::Object& compoundStatement_1b79)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1b69= _state_1b63.begin(), itChildState_1b72= _childState_1b6c.begin(), itCompoundStatement_1b7b= _compoundStatement_1b75.begin(); itState_1b69!= _state_1b63.end(), itChildState_1b72!= _childState_1b6c.end(), itCompoundStatement_1b7b!= _compoundStatement_1b75.end(); ++itState_1b69, ++itChildState_1b72, ++itCompoundStatement_1b7b)
	{
		if( ( *itState_1b69== state_1b67)&& ( *itChildState_1b72== childState_1b70)&& ( *itCompoundStatement_1b7b== compoundStatement_1b79))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1b63.push_back( state_1b67);
		_childState_1b6c.push_back( childState_1b70);
		_compoundStatement_1b75.push_back( compoundStatement_1b79);
	}
	return isUnique;
}

bool ExitChildStates_1b5c::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void ExitChildStates_1b5c::processInputPackets( const Packets_t& states_1b5d, const Packets_t& childStates_1b5f, const Packets_t& compoundStatements_1b61)
{
	for( Packets_t::const_iterator itState_1b64= states_1b5d.begin(), itChildState_1b6d= childStates_1b5f.begin(), itCompoundStatement_1b76= compoundStatements_1b61.begin(); itState_1b64!= states_1b5d.end(), itChildState_1b6d!= childStates_1b5f.end(), itCompoundStatement_1b76!= compoundStatements_1b61.end(); ++itState_1b64, ++itChildState_1b6d, ++itCompoundStatement_1b76)
	{
		bool isUnique= isInputUnique( *itState_1b64, *itChildState_1b6d, *itCompoundStatement_1b76);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1b64, *itChildState_1b6d, *itCompoundStatement_1b76);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ExitChildStates_1b5c::patternMatcher( const Udm::Object& state_1b65, const Udm::Object& childState_1b6e, const Udm::Object& compoundStatement_1b77)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1b65.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1b6a= CyberComposition::Simulink::State::Cast( state_1b65);
		if( false== Uml::IsDerivedFrom( childState_1b6e.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State childState_1b73= CyberComposition::Simulink::State::Cast( childState_1b6e);
		if( false== Uml::IsDerivedFrom( compoundStatement_1b77.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_1b7c= SFC::CompoundStatement::Cast( compoundStatement_1b77);
		set< SFC::StateLabel> stateLabels_1b7e= state_1b6a.src();
		for( set< SFC::StateLabel>::const_iterator itStateLabels_1b7f= stateLabels_1b7e.begin(); itStateLabels_1b7f!= stateLabels_1b7e.end(); ++itStateLabels_1b7f)
		{
			SFC::StateLabel currStateLabel_1b80= *itStateLabels_1b7f;
			set< SFC::Function> exits_1b81= childState_1b73.exit();
			for( set< SFC::Function>::const_iterator itExits_1b82= exits_1b81.begin(); itExits_1b82!= exits_1b81.end(); ++itExits_1b82)
			{
				SFC::Function currExit_1b83= *itExits_1b82;
				Udm::Object exitParent_1b84= currExit_1b83.container();
				if( false== Uml::IsDerivedFrom( exitParent_1b84.type(), SFC::Program::meta))
					continue;
				SFC::Program programExit_1b85= SFC::Program::Cast( exitParent_1b84);
				set< SFC::StateVar> stateVars_1b86= programExit_1b85.StateVar_kind_children();
				for( set< SFC::StateVar>::const_iterator itStateVar_1b87= stateVars_1b86.begin(); itStateVar_1b87!= stateVars_1b86.end(); ++itStateVar_1b87)
				{
					SFC::StateVar currStateVar_1b88= *itStateVar_1b87;
					set< SFC::Arg> args_1b89= currExit_1b83.Arg_kind_children();
					for( set< SFC::Arg>::const_iterator itArg_1b8a= args_1b89.begin(); itArg_1b8a!= args_1b89.end(); ++itArg_1b8a)
					{
						SFC::Arg currArg_1b8b= *itArg_1b8a;
						set< SFC::StateLabel> childStateLabels_1b8c= childState_1b73.src();
						for( set< SFC::StateLabel>::const_iterator itChildStateLabels_1b8d= childStateLabels_1b8c.begin(); itChildStateLabels_1b8d!= childStateLabels_1b8c.end(); ++itChildStateLabels_1b8d)
						{
							SFC::StateLabel currChildStateLabel_1b8e= *itChildStateLabels_1b8d;
							Match currMatch;
							set< pair<int, Udm::Object> > boundObjs_1b92;
							if( !isValidBound(boundObjs_1b92, state_1b6a, true))
								continue;
							currMatch.state_1b93= state_1b6a;
							if( !isValidBound(boundObjs_1b92, childState_1b73, true))
								continue;
							currMatch.childState_1b94= childState_1b73;
							if( !isValidBound(boundObjs_1b92, compoundStatement_1b7c, true))
								continue;
							currMatch.compoundStatement_1b95= compoundStatement_1b7c;
							if( !isValidBound(boundObjs_1b92, currChildStateLabel_1b8e, false))
								continue;
							currMatch.childStateLabel_1b96= currChildStateLabel_1b8e;
							if( !isValidBound(boundObjs_1b92, currStateLabel_1b80, false))
								continue;
							currMatch.stateLabel_1b97= currStateLabel_1b80;
							if( !isValidBound(boundObjs_1b92, currStateVar_1b88, false))
								continue;
							currMatch.stateVar_1b98= currStateVar_1b88;
							if( !isValidBound(boundObjs_1b92, currArg_1b8b, false))
								continue;
							currMatch.arg_1b99= currArg_1b8b;
							if( !isValidBound(boundObjs_1b92, currExit_1b83, false))
								continue;
							currMatch.exit_1b9a= currExit_1b83;
							if( !isValidBound(boundObjs_1b92, programExit_1b85, false))
								continue;
							currMatch.program_1b9b= programExit_1b85;
							_matches.push_back( currMatch);
						}
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void ExitChildStates_1b5c::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_1b9c= SFC::ConditionalBlock::Create( currMatch.compoundStatement_1b95, SFC::CompoundStatement::meta_stmnt);
		SFC::CheckState newCheckState_1b9d= SFC::CheckState::Create( newConditionalBlock_1b9c, SFC::ConditionalBlock::meta_cond);
		SFC::FunctionCall newFunctionCall_1b9e= SFC::FunctionCall::Create( newConditionalBlock_1b9c, SFC::ConditionalBlock::meta_stmnt);
		SFC::ArgVal newArgVal_1b9f= SFC::ArgVal::Create( newFunctionCall_1b9e);
		SFC::Int newInt_1ba0= SFC::Int::Create( newArgVal_1b9f, SFC::ArgVal::meta_argexpr);
		SFC::Arg& Arg= currMatch.arg_1b99;
		SFC::ArgVal& ArgVal= newArgVal_1b9f;
		SFC::CheckState& CheckState= newCheckState_1b9d;
		CyberComposition::Simulink::State& ChildState= currMatch.childState_1b94;
		SFC::StateLabel& ChildStateLabel= currMatch.childStateLabel_1b96;
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_1b95;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_1b9c;
		SFC::Function& Exit= currMatch.exit_1b9a;
		SFC::FunctionCall& FunctionCall= newFunctionCall_1b9e;
		SFC::Int& Int= newInt_1ba0;
		SFC::Program& Program= currMatch.program_1b9b;
		CyberComposition::Simulink::State& State= currMatch.state_1b93;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_1b97;
		SFC::StateVar& StateVar= currMatch.stateVar_1b98;
		{
ConditionalBlock.RefId() = FunctionCall.RefId() = CompoundStatement.RefId();
};
		{
Int.val() = -1;
};
		{
__int64 statementCount = CompoundStatement.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		{
__int64 statementCount = ConditionalBlock.statementCount();
FunctionCall.statementIndex() = statementCount++;
ConditionalBlock.statementCount() = statementCount;
};
		newFunctionCall_1b9e.callee()= currMatch.exit_1b9a;
		newCheckState_1b9d.svar()= currMatch.stateVar_1b98;
		newArgVal_1b9f.arg()+= currMatch.arg_1b99;
		newCheckState_1b9d.value()= currMatch.childStateLabel_1b96;
		newCheckState_1b9d.index()= currMatch.stateLabel_1b97;
	}
}

void ArgNegOneOrState_1bab::operator()( const Packets_t& states_1bac, const Packets_t& functions_1bb0, Packets_t& states_1bae, Packets_t& args_1baf, Packets_t& conditionalBlocks_1bb2)
{
#ifdef PRINT_INFO
	printLog( "ArgNegOneOrState_1bab" );
#endif
	RTTGenerator::Instance()->generateRule(1017, "ArgNegOneOrState");
	_state_1bb3= &states_1bae;
	_arg_1bb4= &args_1baf;
	_conditionalBlock_1bb5= &conditionalBlocks_1bb2;
	processInputPackets( states_1bac, functions_1bb0);
}

bool ArgNegOneOrState_1bab::isInputUnique( const Udm::Object& state_1bba, const Udm::Object& function_1bc3)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1bbc= _state_1bb6.begin(), itFunction_1bc5= _function_1bbf.begin(); itState_1bbc!= _state_1bb6.end(), itFunction_1bc5!= _function_1bbf.end(); ++itState_1bbc, ++itFunction_1bc5)
	{
		if( ( *itState_1bbc== state_1bba)&& ( *itFunction_1bc5== function_1bc3))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1bb6.push_back( state_1bba);
		_function_1bbf.push_back( function_1bc3);
	}
	return isUnique;
}

bool ArgNegOneOrState_1bab::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void ArgNegOneOrState_1bab::processInputPackets( const Packets_t& states_1bac, const Packets_t& functions_1bb0)
{
	for( Packets_t::const_iterator itState_1bb7= states_1bac.begin(), itFunction_1bc0= functions_1bb0.begin(); itState_1bb7!= states_1bac.end(), itFunction_1bc0!= functions_1bb0.end(); ++itState_1bb7, ++itFunction_1bc0)
	{
		bool isUnique= isInputUnique( *itState_1bb7, *itFunction_1bc0);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1bb7, *itFunction_1bc0);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ArgNegOneOrState_1bab::patternMatcher( const Udm::Object& state_1bb8, const Udm::Object& function_1bc1)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1bb8.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1bbd= CyberComposition::Simulink::State::Cast( state_1bb8);
		if( false== Uml::IsDerivedFrom( function_1bc1.type(), SFC::Function::meta))
			continue;
		SFC::Function function_1bc6= SFC::Function::Cast( function_1bc1);
		set< SFC::Arg> args_1bc8= function_1bc6.Arg_kind_children();
		for( set< SFC::Arg>::const_iterator itArg_1bc9= args_1bc8.begin(); itArg_1bc9!= args_1bc8.end(); ++itArg_1bc9)
		{
			SFC::Arg currArg_1bca= *itArg_1bc9;
			set< SFC::StateLabel> stateLabels_1bcb= state_1bbd.src();
			for( set< SFC::StateLabel>::const_iterator itStateLabels_1bcc= stateLabels_1bcb.begin(); itStateLabels_1bcc!= stateLabels_1bcb.end(); ++itStateLabels_1bcc)
			{
				SFC::StateLabel currStateLabel_1bcd= *itStateLabels_1bcc;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_1bd1;
				if( !isValidBound(boundObjs_1bd1, state_1bbd, true))
					continue;
				currMatch.state_1bd2= state_1bbd;
				if( !isValidBound(boundObjs_1bd1, function_1bc6, true))
					continue;
				currMatch.function_1bd3= function_1bc6;
				if( !isValidBound(boundObjs_1bd1, currStateLabel_1bcd, false))
					continue;
				currMatch.stateLabel_1bd4= currStateLabel_1bcd;
				if( !isValidBound(boundObjs_1bd1, currArg_1bca, false))
					continue;
				currMatch.arg_1bd5= currArg_1bca;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void ArgNegOneOrState_1bab::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_1bd6= SFC::ConditionalBlock::Create( currMatch.function_1bd3, SFC::Function::meta_stmnt);
		SFC::UserCode newUserCode_1bd7= SFC::UserCode::Create( newConditionalBlock_1bd6, SFC::ConditionalBlock::meta_cond);
		SFC::BinaryExprs newLogOR_1bd8= SFC::BinaryExprs::Create( newUserCode_1bd7, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newEqual2_1bd9= SFC::BinaryExprs::Create( newLogOR_1bd8, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_1bda= SFC::ArgDeclRef::Create( newEqual2_1bd9, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_1bdb= SFC::ArgDeclRef::Create( newEqual2_1bd9, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newEqual1_1bdc= SFC::BinaryExprs::Create( newLogOR_1bd8, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRe1f_1bdd= SFC::ArgDeclRef::Create( newEqual1_1bdc, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newInt_1bde= SFC::Int::Create( newEqual1_1bdc, SFC::BinaryExprs::meta_rightexpr);
		SFC::Arg& Arg= currMatch.arg_1bd5;
		SFC::ArgDeclRef& ArgDeclRe1f= newArgDeclRe1f_1bdd;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_1bda;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_1bdb;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_1bd6;
		SFC::BinaryExprs& Equal1= newEqual1_1bdc;
		SFC::BinaryExprs& Equal2= newEqual2_1bd9;
		SFC::Function& Function= currMatch.function_1bd3;
		SFC::Int& Int= newInt_1bde;
		SFC::BinaryExprs& LogOR= newLogOR_1bd8;
		CyberComposition::Simulink::State& State= currMatch.state_1bd2;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_1bd4;
		SFC::UserCode& UserCode= newUserCode_1bd7;
		{
ConditionalBlock.RefId() = UserCode.RefId() = Function.RefId();
};
		{
Equal2.op() = "==";
};
		{
LogOR.op() = "||";
};
		{
Equal1.op() = "==";
Int.val() = -1;
};
		{
__int64 statementCount = Function.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		newArgDeclRef2_1bdb.argdecl()= currMatch.stateLabel_1bd4;
		newArgDeclRef_1bda.argdecl()= currMatch.arg_1bd5;
		newArgDeclRe1f_1bdd.argdecl()= currMatch.arg_1bd5;
		outputAppender( currMatch.state_1bd2, currMatch.arg_1bd5, newConditionalBlock_1bd6);
	}
}

void ArgNegOneOrState_1bab::outputAppender( const CyberComposition::Simulink::State& state_1bdf, const SFC::Arg& arg_1be1, const SFC::ConditionalBlock& conditionalBlock_1be3)
{
	_state_1bb3->push_back( state_1bdf);
	_arg_1bb4->push_back( arg_1be1);
	_conditionalBlock_1bb5->push_back( conditionalBlock_1be3);
}

void GetExitFunction_1bf0::operator()( const Packets_t& states_1bf1, Packets_t& states_1bf3, Packets_t& exits_1bf4)
{
#ifdef PRINT_INFO
	printLog( "GetExitFunction_1bf0" );
#endif
	RTTGenerator::Instance()->generateRule(1050, "GetExitFunction");
	_state_1bf5= &states_1bf3;
	_exit_1bf6= &exits_1bf4;
	processInputPackets( states_1bf1);
}

bool GetExitFunction_1bf0::isInputUnique( const Udm::Object& state_1bfb)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1bfd= _state_1bf7.begin(); itState_1bfd!= _state_1bf7.end(); ++itState_1bfd)
	{
		if( ( *itState_1bfd== state_1bfb))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_1bf7.push_back( state_1bfb);
	return isUnique;
}

bool GetExitFunction_1bf0::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetExitFunction_1bf0::processInputPackets( const Packets_t& states_1bf1)
{
	for( Packets_t::const_iterator itState_1bf8= states_1bf1.begin(); itState_1bf8!= states_1bf1.end(); ++itState_1bf8)
	{
		bool isUnique= isInputUnique( *itState_1bf8);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1bf8);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetExitFunction_1bf0::patternMatcher( const Udm::Object& state_1bf9)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1bf9.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1bfe= CyberComposition::Simulink::State::Cast( state_1bf9);
		set< SFC::Function> exits_1c00= state_1bfe.exit();
		for( set< SFC::Function>::const_iterator itExits_1c01= exits_1c00.begin(); itExits_1c01!= exits_1c00.end(); ++itExits_1c01)
		{
			SFC::Function currExit_1c02= *itExits_1c01;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1c06;
			if( !isValidBound(boundObjs_1c06, state_1bfe, true))
				continue;
			currMatch.state_1c07= state_1bfe;
			if( !isValidBound(boundObjs_1c06, currExit_1c02, false))
				continue;
			currMatch.exit_1c08= currExit_1c02;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetExitFunction_1bf0::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_1c07, currMatch.exit_1c08);
	}
}

void GetExitFunction_1bf0::outputAppender( const CyberComposition::Simulink::State& state_1c09, const SFC::Function& exit_1c0b)
{
	_state_1bf5->push_back( state_1c09);
	_exit_1bf6->push_back( exit_1c0b);
}

void PopulateEnterFunction_1c15::operator()( const Packets_t& states_1c16, const Packets_t& programs_1c18, Packets_t& states_1c1a, Packets_t& programs_1c1b)
{
#ifdef PRINT_INFO
	printLog( "PopulateEnterFunction_1c15" );
#endif
	_state_1c1c= &states_1c1a;
	_program_1c1d= &programs_1c1b;
	if( ( !states_1c16.empty()))
		callTestEAIOff_1f35( states_1c16);
	_state_1c1c->insert( _state_1c1c->end(), states_1c16.begin(), states_1c16.end());
	_program_1c1d->insert( _program_1c1d->end(), programs_1c18.begin(), programs_1c18.end());
}

void PopulateEnterFunction_1c15::callTestEAIOff_1f35( const Packets_t& states_1eeb)
{
	Packets_t states_1eed;
	Packets_t states_1eee;
	TestEAIOff_1eea testEAIOff_1eea;
	testEAIOff_1eea( states_1eeb, states_1eed, states_1eee);
	if( ( !states_1eee.empty()))
		callReturnAtTopState_1f37( states_1eee);
}

void PopulateEnterFunction_1c15::callReturnAtTopState_1f37( const Packets_t& states_1ebd)
{
	Packets_t states_1ebf;
	ReturnAtTopState_1ebc returnAtTopState_1ebc;
	returnAtTopState_1ebc( states_1ebd, states_1ebf);
	if( ( !states_1ebf.empty()))
		callMode0or1_1f39( states_1ebf);
}

void PopulateEnterFunction_1c15::callMode0or1_1f39( const Packets_t& states_1e34)
{
	Packets_t states_1e36;
	Mode0or1_1e33 mode0or1_1e33;
	mode0or1_1e33( states_1e34, states_1e36);
	if( ( !states_1e36.empty()))
		callMode0or1or2_1f3b( states_1e36);
}

void PopulateEnterFunction_1c15::callMode0or1or2_1f3b( const Packets_t& states_1df3)
{
	Packets_t states_1df5;
	Mode0or1or2_1df2 mode0or1or2_1df2;
	mode0or1or2_1df2( states_1df3, states_1df5);
	if( ( !states_1df5.empty()))
		callMode0or2_1f3d( states_1df5);
}

void PopulateEnterFunction_1c15::callMode0or2_1f3d( const Packets_t& states_1d5d)
{
	Packets_t states_1d5f;
	Mode0or2_1d5c mode0or2_1d5c;
	mode0or2_1d5c( states_1d5d, states_1d5f);
	if( ( !states_1d5f.empty()))
		callMode0or3_1f3f( states_1d5f);
}

void PopulateEnterFunction_1c15::callMode0or3_1f3f( const Packets_t& states_1c1f)
{
	Packets_t states_1c21;
	Mode0or3_1c1e mode0or3_1c1e;
	mode0or3_1c1e( states_1c1f, states_1c21);
}

void Mode0or3_1c1e::operator()( const Packets_t& states_1c1f, Packets_t& states_1c21)
{
#ifdef PRINT_INFO
	printLog( "Mode0or3_1c1e" );
#endif
	_state_1c22= &states_1c21;
	_state_1c22->insert( _state_1c22->end(), states_1c1f.begin(), states_1c1f.end());
	if( ( !states_1c1f.empty()))
		callTestMode03_1d54( states_1c1f);
}

void Mode0or3_1c1e::callTestMode03_1d54( const Packets_t& states_1d2b)
{
	Packets_t states_1d2d;
	Packets_t conditionalBlocks_1d2e;
	TestMode03_1d2a testMode03_1d2a;
	testMode03_1d2a( states_1d2b, states_1d2d, conditionalBlocks_1d2e);
	if( ( !states_1d2d.empty())&& ( !conditionalBlocks_1d2e.empty()))
		callCallLOSibs_1d56( states_1d2d, conditionalBlocks_1d2e);
}

void Mode0or3_1c1e::callCallLOSibs_1d56( const Packets_t& states_1c24, const Packets_t& css_1c26)
{
	Packets_t states_1c28;
	Packets_t css_1c29;
	CallLOSibs_1c23 callLOSibs_1c23;
	callLOSibs_1c23( states_1c24, css_1c26, states_1c28, css_1c29);
	if( ( !states_1c28.empty())&& ( !css_1c29.empty()))
		callCallParent_1d59( states_1c28, css_1c29);
}

void Mode0or3_1c1e::callCallParent_1d59( const Packets_t& states_1ced, const Packets_t& conditionalBlocks_1cef)
{
	CallParent_1cec callParent_1cec;
	callParent_1cec( states_1ced, conditionalBlocks_1cef);
}

void CallLOSibs_1c23::operator()( const Packets_t& states_1c24, const Packets_t& css_1c26, Packets_t& states_1c28, Packets_t& css_1c29)
{
#ifdef PRINT_INFO
	printLog( "CallLOSibs_1c23" );
#endif
	_state_1c2a= &states_1c28;
	_cs_1c2b= &css_1c29;
	if( ( !states_1c24.empty())&& ( !css_1c26.empty()))
		callIsAndState_1ce2( states_1c24, css_1c26);
	_state_1c2a->insert( _state_1c2a->end(), states_1c24.begin(), states_1c24.end());
	_cs_1c2b->insert( _cs_1c2b->end(), css_1c26.begin(), css_1c26.end());
}

void CallLOSibs_1c23::callIsAndState_1ce2( const Packets_t& states_1c5e, const Packets_t& css_1c60)
{
	Packets_t states_1c62;
	Packets_t css_1c63;
	IsAndState_1c5d isAndState_1c5d;
	isAndState_1c5d( states_1c5e, css_1c60, states_1c62, css_1c63);
	if( ( !states_1c62.empty())&& ( !css_1c63.empty()))
		callGetLOSibs_1ce5( states_1c62, css_1c63);
}

void CallLOSibs_1c23::callGetLOSibs_1ce5( const Packets_t& states_1c2d, const Packets_t& compoundStatements_1c31)
{
	Packets_t states_1c2f;
	Packets_t sibStates_1c30;
	Packets_t compoundStatements_1c33;
	GetLOSibs_1c2c getLOSibs_1c2c;
	getLOSibs_1c2c( states_1c2d, compoundStatements_1c31, states_1c2f, sibStates_1c30, compoundStatements_1c33);
	if( ( !states_1c2f.empty())&& ( !sibStates_1c30.empty())&& ( !compoundStatements_1c33.empty()))
		callCallSibsOrChildren_1ce8( states_1c2f, sibStates_1c30, compoundStatements_1c33);
}

void CallLOSibs_1c23::callCallSibsOrChildren_1ce8( const Packets_t& states_1c99, const Packets_t& sOCStates_1c9b, const Packets_t& compoundStatements_1c9d)
{
	CallSibsOrChildren_1c98 callSibsOrChildren_1c98;
	callSibsOrChildren_1c98( states_1c99, sOCStates_1c9b, compoundStatements_1c9d);
}

void GetLOSibs_1c2c::operator()( const Packets_t& states_1c2d, const Packets_t& compoundStatements_1c31, Packets_t& states_1c2f, Packets_t& sibStates_1c30, Packets_t& compoundStatements_1c33)
{
#ifdef PRINT_INFO
	printLog( "GetLOSibs_1c2c" );
#endif
	RTTGenerator::Instance()->generateRule(1067, "GetLOSibs");
	_state_1c34= &states_1c2f;
	_sibState_1c35= &sibStates_1c30;
	_compoundStatement_1c36= &compoundStatements_1c33;
	processInputPackets( states_1c2d, compoundStatements_1c31);
	sortOutputs( );
}

bool GetLOSibs_1c2c::isInputUnique( const Udm::Object& state_1c3b, const Udm::Object& compoundStatement_1c44)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1c3d= _state_1c37.begin(), itCompoundStatement_1c46= _compoundStatement_1c40.begin(); itState_1c3d!= _state_1c37.end(), itCompoundStatement_1c46!= _compoundStatement_1c40.end(); ++itState_1c3d, ++itCompoundStatement_1c46)
	{
		if( ( *itState_1c3d== state_1c3b)&& ( *itCompoundStatement_1c46== compoundStatement_1c44))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1c37.push_back( state_1c3b);
		_compoundStatement_1c40.push_back( compoundStatement_1c44);
	}
	return isUnique;
}

bool GetLOSibs_1c2c::isGuardTrue( SFC::CompoundStatement& CompoundStatement, CyberComposition::Simulink::State& ParentState, CyberComposition::Simulink::State& SibState, CyberComposition::Simulink::State& State)
{
	bool Gz_guard= false;
	std::string stateOrder = SFManager::trim(  static_cast< std::string >( State.Order() )  );
if ( stateOrder.empty() ) stateOrder = "0";

std::string sibStateOrder = SFManager::trim(  static_cast< std::string >( SibState.Order() )  );
if ( sibStateOrder.empty() ) sibStateOrder = "0";

return boost::lexical_cast< int >( stateOrder ) > boost::lexical_cast< int >( sibStateOrder );;
	return Gz_guard;
}

void GetLOSibs_1c2c::processInputPackets( const Packets_t& states_1c2d, const Packets_t& compoundStatements_1c31)
{
	for( Packets_t::const_iterator itState_1c38= states_1c2d.begin(), itCompoundStatement_1c41= compoundStatements_1c31.begin(); itState_1c38!= states_1c2d.end(), itCompoundStatement_1c41!= compoundStatements_1c31.end(); ++itState_1c38, ++itCompoundStatement_1c41)
	{
		bool isUnique= isInputUnique( *itState_1c38, *itCompoundStatement_1c41);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1c38, *itCompoundStatement_1c41);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetLOSibs_1c2c::patternMatcher( const Udm::Object& state_1c39, const Udm::Object& compoundStatement_1c42)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1c39.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1c3e= CyberComposition::Simulink::State::Cast( state_1c39);
		if( false== Uml::IsDerivedFrom( compoundStatement_1c42.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_1c47= SFC::CompoundStatement::Cast( compoundStatement_1c42);
		Udm::Object stateParent_1c49= state_1c3e.container();
		if( false== Uml::IsDerivedFrom( stateParent_1c49.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State parentStateState_1c4a= CyberComposition::Simulink::State::Cast( stateParent_1c49);
		set< CyberComposition::Simulink::State> sibStates_1c4b= parentStateState_1c4a.State_kind_children();
		for( set< CyberComposition::Simulink::State>::const_iterator itSibState_1c4c= sibStates_1c4b.begin(); itSibState_1c4c!= sibStates_1c4b.end(); ++itSibState_1c4c)
		{
			CyberComposition::Simulink::State currSibState_1c4d= *itSibState_1c4c;
			Match currMatch;
			currMatch.state_1c4f= state_1c3e;
			currMatch.compoundStatement_1c50= compoundStatement_1c47;
			currMatch.parentState_1c51= parentStateState_1c4a;
			currMatch.sibState_1c52= currSibState_1c4d;
			bool Gz_guard= isGuardTrue( currMatch.compoundStatement_1c50, currMatch.parentState_1c51, currMatch.sibState_1c52, currMatch.state_1c4f);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetLOSibs_1c2c::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_1c4f, currMatch.sibState_1c52, currMatch.compoundStatement_1c50);
	}
}

void GetLOSibs_1c2c::outputAppender( const CyberComposition::Simulink::State& state_1c57, const CyberComposition::Simulink::State& sibState_1c59, const SFC::CompoundStatement& compoundStatement_1c5b)
{
	_state_1c34->push_back( state_1c57);
	_sibState_1c35->push_back( sibState_1c59);
	_compoundStatement_1c36->push_back( compoundStatement_1c5b);
}

void GetLOSibs_1c2c::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::State, std::pointer_to_binary_function< const CyberComposition::Simulink::State&, const CyberComposition::Simulink::State&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::State&, const CyberComposition::Simulink::State&, bool> ptr_StateOrder( StateOrder< CyberComposition::Simulink::State>);
	SortedSet_t sortedSet( ptr_StateOrder);
	std::vector< int> permutationVector( _sibState_1c35->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _sibState_1c35->begin(); it!= _sibState_1c35->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::State::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _sibState_1c35->begin());
	// order rest of the containers
	permutate( permutationVector, *_state_1c34);
	permutate( permutationVector, *_compoundStatement_1c36);
}

void IsAndState_1c5d::operator()( const Packets_t& states_1c5e, const Packets_t& css_1c60, Packets_t& states_1c62, Packets_t& css_1c63)
{
#ifdef PRINT_INFO
	printLog( "IsAndState_1c5d" );
#endif
	_state_1c64= &states_1c62;
	_cs_1c65= &css_1c63;
	for( Packets_t::const_iterator itstate_1c67= states_1c5e.begin(), itcs_1c6e= css_1c60.begin(); itstate_1c67!= states_1c5e.end(), itcs_1c6e!= css_1c60.end(); ++itstate_1c67, ++itcs_1c6e)
	{
		bool isUnique= isInputUnique( *itstate_1c67, *itcs_1c6e);
		if( !isUnique)
			continue;
		Packets_t onestate_1c6b( 1, *itstate_1c67);
		Packets_t onecs_1c72( 1, *itcs_1c6e);
		executeOne( onestate_1c6b, onecs_1c72);
	}
}

void IsAndState_1c5d::executeOne( const Packets_t& states_1c5e, const Packets_t& css_1c60)
{
	Packets_t states_1c77;
	Packets_t compoundStatements_1c7a;
	AndState_1c74 andState_1c74;
	bool isMatchAndState_1c74= andState_1c74( states_1c5e, css_1c60, states_1c77, compoundStatements_1c7a);
	_state_1c64->insert( _state_1c64->end(), states_1c77.begin(), states_1c77.end());
	_cs_1c65->insert( _cs_1c65->end(), compoundStatements_1c7a.begin(), compoundStatements_1c7a.end());
	if( isMatchAndState_1c74)
		return;
}

bool IsAndState_1c5d::isInputUnique( const Udm::Object& state_1c68, const Udm::Object& cs_1c6f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_1c6a= _state_1c66.begin(), itcs_1c71= _cs_1c6d.begin(); itstate_1c6a!= _state_1c66.end(), itcs_1c71!= _cs_1c6d.end(); ++itstate_1c6a, ++itcs_1c71)
	{
		if( ( *itstate_1c6a== state_1c68)&& ( *itcs_1c71== cs_1c6f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1c66.push_back( state_1c68);
		_cs_1c6d.push_back( cs_1c6f);
	}
	return isUnique;
}

bool AndState_1c74::operator()( const Packets_t& states_1c75, const Packets_t& compoundStatements_1c78, Packets_t& states_1c77, Packets_t& compoundStatements_1c7a)
{
#ifdef PRINT_INFO
	printLog( "AndState_1c74" );
#endif
	_state_1c7b= &states_1c77;
	_compoundStatement_1c7c= &compoundStatements_1c7a;
	processInputPackets( states_1c75, compoundStatements_1c78);
	if( false== _matches.empty())
		return true;
	return false;
}

bool AndState_1c74::isInputUnique( const Udm::Object& state_1c81, const Udm::Object& compoundStatement_1c8a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1c83= _state_1c7d.begin(), itCompoundStatement_1c8c= _compoundStatement_1c86.begin(); itState_1c83!= _state_1c7d.end(), itCompoundStatement_1c8c!= _compoundStatement_1c86.end(); ++itState_1c83, ++itCompoundStatement_1c8c)
	{
		if( ( *itState_1c83== state_1c81)&& ( *itCompoundStatement_1c8c== compoundStatement_1c8a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1c7d.push_back( state_1c81);
		_compoundStatement_1c86.push_back( compoundStatement_1c8a);
	}
	return isUnique;
}

bool AndState_1c74::isGuardTrue( SFC::CompoundStatement& CompoundStatement, CyberComposition::Simulink::State& State)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( State.Decomposition() ) == "AND_STATE";;
	return Gz_guard;
}

void AndState_1c74::processInputPackets( const Packets_t& states_1c75, const Packets_t& compoundStatements_1c78)
{
	for( Packets_t::const_iterator itState_1c7e= states_1c75.begin(), itCompoundStatement_1c87= compoundStatements_1c78.begin(); itState_1c7e!= states_1c75.end(), itCompoundStatement_1c87!= compoundStatements_1c78.end(); ++itState_1c7e, ++itCompoundStatement_1c87)
	{
		bool isUnique= isInputUnique( *itState_1c7e, *itCompoundStatement_1c87);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1c7e, *itCompoundStatement_1c87);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_1c90, currMatch.compoundStatement_1c91);
	}
}

bool AndState_1c74::patternMatcher( const Udm::Object& state_1c7f, const Udm::Object& compoundStatement_1c88)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1c7f.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1c84= CyberComposition::Simulink::State::Cast( state_1c7f);
		if( false== Uml::IsDerivedFrom( compoundStatement_1c88.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_1c8d= SFC::CompoundStatement::Cast( compoundStatement_1c88);
		Match currMatch;
		currMatch.state_1c90= state_1c84;
		currMatch.compoundStatement_1c91= compoundStatement_1c8d;
		bool Gz_guard= isGuardTrue( currMatch.compoundStatement_1c91, currMatch.state_1c90);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void AndState_1c74::outputAppender( const CyberComposition::Simulink::State& state_1c94, const SFC::CompoundStatement& compoundStatement_1c96)
{
	_state_1c7b->push_back( state_1c94);
	_compoundStatement_1c7c->push_back( compoundStatement_1c96);
}

void CallSibsOrChildren_1c98::operator()( const Packets_t& states_1c99, const Packets_t& sOCStates_1c9b, const Packets_t& compoundStatements_1c9d)
{
#ifdef PRINT_INFO
	printLog( "CallSibsOrChildren_1c98" );
#endif
	RTTGenerator::Instance()->generateRule(1323, "CallSibsOrChildren");
	processInputPackets( states_1c99, sOCStates_1c9b, compoundStatements_1c9d);
}

bool CallSibsOrChildren_1c98::isInputUnique( const Udm::Object& state_1ca3, const Udm::Object& sOCState_1cac, const Udm::Object& compoundStatement_1cb5)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1ca5= _state_1c9f.begin(), itSOCState_1cae= _sOCState_1ca8.begin(), itCompoundStatement_1cb7= _compoundStatement_1cb1.begin(); itState_1ca5!= _state_1c9f.end(), itSOCState_1cae!= _sOCState_1ca8.end(), itCompoundStatement_1cb7!= _compoundStatement_1cb1.end(); ++itState_1ca5, ++itSOCState_1cae, ++itCompoundStatement_1cb7)
	{
		if( ( *itState_1ca5== state_1ca3)&& ( *itSOCState_1cae== sOCState_1cac)&& ( *itCompoundStatement_1cb7== compoundStatement_1cb5))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1c9f.push_back( state_1ca3);
		_sOCState_1ca8.push_back( sOCState_1cac);
		_compoundStatement_1cb1.push_back( compoundStatement_1cb5);
	}
	return isUnique;
}

bool CallSibsOrChildren_1c98::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool CallSibsOrChildren_1c98::isGuardTrue( SFC::Arg& Arg1, SFC::CompoundStatement& CompoundStatement, SFC::Function& Enter, SFC::Arg& SOCArg0, SFC::Arg& SOCArg1, SFC::Function& SOCEnter, CyberComposition::Simulink::State& SOCState, CyberComposition::Simulink::State& State)
{
	bool Gz_guard= false;
	return SOCArg0.argIndex() == 0 && SOCArg1.argIndex() == 1 && Arg1.argIndex() == 1;;
	return Gz_guard;
}

void CallSibsOrChildren_1c98::processInputPackets( const Packets_t& states_1c99, const Packets_t& sOCStates_1c9b, const Packets_t& compoundStatements_1c9d)
{
	for( Packets_t::const_iterator itState_1ca0= states_1c99.begin(), itSOCState_1ca9= sOCStates_1c9b.begin(), itCompoundStatement_1cb2= compoundStatements_1c9d.begin(); itState_1ca0!= states_1c99.end(), itSOCState_1ca9!= sOCStates_1c9b.end(), itCompoundStatement_1cb2!= compoundStatements_1c9d.end(); ++itState_1ca0, ++itSOCState_1ca9, ++itCompoundStatement_1cb2)
	{
		bool isUnique= isInputUnique( *itState_1ca0, *itSOCState_1ca9, *itCompoundStatement_1cb2);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1ca0, *itSOCState_1ca9, *itCompoundStatement_1cb2);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CallSibsOrChildren_1c98::patternMatcher( const Udm::Object& state_1ca1, const Udm::Object& sOCState_1caa, const Udm::Object& compoundStatement_1cb3)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1ca1.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1ca6= CyberComposition::Simulink::State::Cast( state_1ca1);
		if( false== Uml::IsDerivedFrom( sOCState_1caa.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State sOCState_1caf= CyberComposition::Simulink::State::Cast( sOCState_1caa);
		if( false== Uml::IsDerivedFrom( compoundStatement_1cb3.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_1cb8= SFC::CompoundStatement::Cast( compoundStatement_1cb3);
		set< SFC::Function> sOCEnters_1cba= sOCState_1caf.enter();
		for( set< SFC::Function>::const_iterator itSOCEnters_1cbb= sOCEnters_1cba.begin(); itSOCEnters_1cbb!= sOCEnters_1cba.end(); ++itSOCEnters_1cbb)
		{
			SFC::Function currSOCEnter_1cbc= *itSOCEnters_1cbb;
			set< SFC::Arg> sOCArg1s_1cbd= currSOCEnter_1cbc.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itSOCArg1_1cbe= sOCArg1s_1cbd.begin(); itSOCArg1_1cbe!= sOCArg1s_1cbd.end(); ++itSOCArg1_1cbe)
			{
				SFC::Arg currSOCArg1_1cbf= *itSOCArg1_1cbe;
				set< SFC::Arg> sOCArg0s_1cc0= currSOCEnter_1cbc.Arg_kind_children();
				for( set< SFC::Arg>::const_iterator itSOCArg0_1cc1= sOCArg0s_1cc0.begin(); itSOCArg0_1cc1!= sOCArg0s_1cc0.end(); ++itSOCArg0_1cc1)
				{
					SFC::Arg currSOCArg0_1cc2= *itSOCArg0_1cc1;
					set< SFC::Function> enters_1cc3= state_1ca6.enter();
					for( set< SFC::Function>::const_iterator itEnters_1cc4= enters_1cc3.begin(); itEnters_1cc4!= enters_1cc3.end(); ++itEnters_1cc4)
					{
						SFC::Function currEnter_1cc5= *itEnters_1cc4;
						set< SFC::Arg> arg1s_1cc6= currEnter_1cc5.Arg_kind_children();
						for( set< SFC::Arg>::const_iterator itArg1_1cc7= arg1s_1cc6.begin(); itArg1_1cc7!= arg1s_1cc6.end(); ++itArg1_1cc7)
						{
							SFC::Arg currArg1_1cc8= *itArg1_1cc7;
							Match currMatch;
							set< pair<int, Udm::Object> > boundObjs_1ccc;
							if( !isValidBound(boundObjs_1ccc, state_1ca6, true))
								continue;
							currMatch.state_1ccd= state_1ca6;
							if( !isValidBound(boundObjs_1ccc, sOCState_1caf, true))
								continue;
							currMatch.sOCState_1cce= sOCState_1caf;
							if( !isValidBound(boundObjs_1ccc, compoundStatement_1cb8, true))
								continue;
							currMatch.compoundStatement_1ccf= compoundStatement_1cb8;
							if( !isValidBound(boundObjs_1ccc, currEnter_1cc5, false))
								continue;
							currMatch.enter_1cd0= currEnter_1cc5;
							if( !isValidBound(boundObjs_1ccc, currSOCArg0_1cc2, false))
								continue;
							currMatch.sOCArg0_1cd1= currSOCArg0_1cc2;
							if( !isValidBound(boundObjs_1ccc, currSOCArg1_1cbf, false))
								continue;
							currMatch.sOCArg1_1cd2= currSOCArg1_1cbf;
							if( !isValidBound(boundObjs_1ccc, currArg1_1cc8, false))
								continue;
							currMatch.arg1_1cd3= currArg1_1cc8;
							if( !isValidBound(boundObjs_1ccc, currSOCEnter_1cbc, false))
								continue;
							currMatch.sOCEnter_1cd4= currSOCEnter_1cbc;
							bool Gz_guard= isGuardTrue( currMatch.arg1_1cd3, currMatch.compoundStatement_1ccf, currMatch.enter_1cd0, currMatch.sOCArg0_1cd1, currMatch.sOCArg1_1cd2, currMatch.sOCEnter_1cd4, currMatch.sOCState_1cce, currMatch.state_1ccd);
							if( true== Gz_guard)
								_matches.push_back( currMatch);
						}
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void CallSibsOrChildren_1c98::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::FunctionCall newFunctionCall_1cdd= SFC::FunctionCall::Create( currMatch.compoundStatement_1ccf, SFC::CompoundStatement::meta_stmnt);
		SFC::ArgVal newArgVal1_1cde= SFC::ArgVal::Create( newFunctionCall_1cdd);
		SFC::ArgDeclRef newArgDeclRef_1cdf= SFC::ArgDeclRef::Create( newArgVal1_1cde, SFC::ArgVal::meta_argexpr);
		SFC::ArgVal newArgVal0_1ce0= SFC::ArgVal::Create( newFunctionCall_1cdd);
		SFC::Int newTwo_1ce1= SFC::Int::Create( newArgVal0_1ce0, SFC::ArgVal::meta_argexpr);
		SFC::Arg& Arg1= currMatch.arg1_1cd3;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_1cdf;
		SFC::ArgVal& ArgVal0= newArgVal0_1ce0;
		SFC::ArgVal& ArgVal1= newArgVal1_1cde;
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_1ccf;
		SFC::Function& Enter= currMatch.enter_1cd0;
		SFC::FunctionCall& FunctionCall= newFunctionCall_1cdd;
		SFC::Arg& SOCArg0= currMatch.sOCArg0_1cd1;
		SFC::Arg& SOCArg1= currMatch.sOCArg1_1cd2;
		SFC::Function& SOCEnter= currMatch.sOCEnter_1cd4;
		CyberComposition::Simulink::State& SOCState= currMatch.sOCState_1cce;
		CyberComposition::Simulink::State& State= currMatch.state_1ccd;
		SFC::Int& Two= newTwo_1ce1;
		{
FunctionCall.RefId() = CompoundStatement.RefId();
};
		{
FunctionCall.argCount() = 2;
};
		{
__int64 statementCount = CompoundStatement.statementCount();
FunctionCall.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		{
Two.val() = 2;
};
		{
ArgVal1.argIndex() = 1;
};
		{
ArgVal0.argIndex() = 0;
};
		newFunctionCall_1cdd.callee()= currMatch.sOCEnter_1cd4;
		newArgDeclRef_1cdf.argdecl()= currMatch.arg1_1cd3;
		newArgVal1_1cde.arg()+= currMatch.sOCArg1_1cd2;
		newArgVal0_1ce0.arg()+= currMatch.sOCArg0_1cd1;
	}
}

void CallParent_1cec::operator()( const Packets_t& states_1ced, const Packets_t& conditionalBlocks_1cef)
{
#ifdef PRINT_INFO
	printLog( "CallParent_1cec" );
#endif
	RTTGenerator::Instance()->generateRule(1074, "CallParent");
	processInputPackets( states_1ced, conditionalBlocks_1cef);
}

bool CallParent_1cec::isInputUnique( const Udm::Object& state_1cf5, const Udm::Object& conditionalBlock_1cfe)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1cf7= _state_1cf1.begin(), itConditionalBlock_1d00= _conditionalBlock_1cfa.begin(); itState_1cf7!= _state_1cf1.end(), itConditionalBlock_1d00!= _conditionalBlock_1cfa.end(); ++itState_1cf7, ++itConditionalBlock_1d00)
	{
		if( ( *itState_1cf7== state_1cf5)&& ( *itConditionalBlock_1d00== conditionalBlock_1cfe))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1cf1.push_back( state_1cf5);
		_conditionalBlock_1cfa.push_back( conditionalBlock_1cfe);
	}
	return isUnique;
}

bool CallParent_1cec::isGuardTrue( SFC::Arg& Arg1, SFC::ConditionalBlock& ConditionalBlock, SFC::Function& Enter, SFC::Arg& ParentArg0, SFC::Arg& ParentArg1, SFC::Function& ParentEnter, CyberComposition::Simulink::State& ParentState, CyberComposition::Simulink::State& State)
{
	bool Gz_guard= false;
	return Arg1.argIndex() == 1 && ParentArg0.argIndex() == 0 && ParentArg1.argIndex() == 1;;
	return Gz_guard;
}

void CallParent_1cec::processInputPackets( const Packets_t& states_1ced, const Packets_t& conditionalBlocks_1cef)
{
	for( Packets_t::const_iterator itState_1cf2= states_1ced.begin(), itConditionalBlock_1cfb= conditionalBlocks_1cef.begin(); itState_1cf2!= states_1ced.end(), itConditionalBlock_1cfb!= conditionalBlocks_1cef.end(); ++itState_1cf2, ++itConditionalBlock_1cfb)
	{
		bool isUnique= isInputUnique( *itState_1cf2, *itConditionalBlock_1cfb);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1cf2, *itConditionalBlock_1cfb);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CallParent_1cec::patternMatcher( const Udm::Object& state_1cf3, const Udm::Object& conditionalBlock_1cfc)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1cf3.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1cf8= CyberComposition::Simulink::State::Cast( state_1cf3);
		if( false== Uml::IsDerivedFrom( conditionalBlock_1cfc.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlock_1d01= SFC::ConditionalBlock::Cast( conditionalBlock_1cfc);
		Udm::Object stateParent_1d03= state_1cf8.container();
		if( false== Uml::IsDerivedFrom( stateParent_1d03.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State parentStateState_1d04= CyberComposition::Simulink::State::Cast( stateParent_1d03);
		set< SFC::Function> enters_1d05= state_1cf8.enter();
		for( set< SFC::Function>::const_iterator itEnters_1d06= enters_1d05.begin(); itEnters_1d06!= enters_1d05.end(); ++itEnters_1d06)
		{
			SFC::Function currEnter_1d07= *itEnters_1d06;
			set< SFC::Arg> arg1s_1d08= currEnter_1d07.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itArg1_1d09= arg1s_1d08.begin(); itArg1_1d09!= arg1s_1d08.end(); ++itArg1_1d09)
			{
				SFC::Arg currArg1_1d0a= *itArg1_1d09;
				set< SFC::Function> parentEnters_1d0b= parentStateState_1d04.enter();
				for( set< SFC::Function>::const_iterator itParentEnters_1d0c= parentEnters_1d0b.begin(); itParentEnters_1d0c!= parentEnters_1d0b.end(); ++itParentEnters_1d0c)
				{
					SFC::Function currParentEnter_1d0d= *itParentEnters_1d0c;
					set< SFC::Arg> parentArg0s_1d0e= currParentEnter_1d0d.Arg_kind_children();
					for( set< SFC::Arg>::const_iterator itParentArg0_1d0f= parentArg0s_1d0e.begin(); itParentArg0_1d0f!= parentArg0s_1d0e.end(); ++itParentArg0_1d0f)
					{
						SFC::Arg currParentArg0_1d10= *itParentArg0_1d0f;
						set< SFC::Arg> parentArg1s_1d11= currParentEnter_1d0d.Arg_kind_children();
						for( set< SFC::Arg>::const_iterator itParentArg1_1d12= parentArg1s_1d11.begin(); itParentArg1_1d12!= parentArg1s_1d11.end(); ++itParentArg1_1d12)
						{
							SFC::Arg currParentArg1_1d13= *itParentArg1_1d12;
							Match currMatch;
							currMatch.state_1d15= state_1cf8;
							currMatch.conditionalBlock_1d16= conditionalBlock_1d01;
							currMatch.parentState_1d17= parentStateState_1d04;
							currMatch.parentArg1_1d18= currParentArg1_1d13;
							currMatch.parentArg0_1d19= currParentArg0_1d10;
							currMatch.parentEnter_1d1a= currParentEnter_1d0d;
							currMatch.enter_1d1b= currEnter_1d07;
							currMatch.arg1_1d1c= currArg1_1d0a;
							bool Gz_guard= isGuardTrue( currMatch.arg1_1d1c, currMatch.conditionalBlock_1d16, currMatch.enter_1d1b, currMatch.parentArg0_1d19, currMatch.parentArg1_1d18, currMatch.parentEnter_1d1a, currMatch.parentState_1d17, currMatch.state_1d15);
							if( true== Gz_guard)
								_matches.push_back( currMatch);
						}
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void CallParent_1cec::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::FunctionCall newFunctionCall_1d25= SFC::FunctionCall::Create( currMatch.conditionalBlock_1d16, SFC::ConditionalBlock::meta_stmnt);
		SFC::ArgVal newArgVal1_1d26= SFC::ArgVal::Create( newFunctionCall_1d25);
		SFC::ArgDeclRef newArgDeclRef_1d27= SFC::ArgDeclRef::Create( newArgVal1_1d26, SFC::ArgVal::meta_argexpr);
		SFC::ArgVal newArgVal0_1d28= SFC::ArgVal::Create( newFunctionCall_1d25);
		SFC::Int newThree_1d29= SFC::Int::Create( newArgVal0_1d28, SFC::ArgVal::meta_argexpr);
		SFC::Arg& Arg1= currMatch.arg1_1d1c;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_1d27;
		SFC::ArgVal& ArgVal0= newArgVal0_1d28;
		SFC::ArgVal& ArgVal1= newArgVal1_1d26;
		SFC::ConditionalBlock& ConditionalBlock= currMatch.conditionalBlock_1d16;
		SFC::Function& Enter= currMatch.enter_1d1b;
		SFC::FunctionCall& FunctionCall= newFunctionCall_1d25;
		SFC::Arg& ParentArg0= currMatch.parentArg0_1d19;
		SFC::Arg& ParentArg1= currMatch.parentArg1_1d18;
		SFC::Function& ParentEnter= currMatch.parentEnter_1d1a;
		CyberComposition::Simulink::State& ParentState= currMatch.parentState_1d17;
		CyberComposition::Simulink::State& State= currMatch.state_1d15;
		SFC::Int& Three= newThree_1d29;
		{
FunctionCall.RefId() = ConditionalBlock.RefId();
};
		{
FunctionCall.argCount() = 2;
};
		{
ArgVal0.argIndex() = 0;
};
		{
Three.val() = 3;
};
		{
__int64 statementCount = ConditionalBlock.statementCount();
FunctionCall.statementIndex() = statementCount++;
ConditionalBlock.statementCount() = statementCount;
};
		{
ArgVal1.argIndex() = 1;
};
		newFunctionCall_1d25.callee()= currMatch.parentEnter_1d1a;
		newArgDeclRef_1d27.argdecl()= currMatch.arg1_1d1c;
		newArgVal0_1d28.arg()+= currMatch.parentArg0_1d19;
		newArgVal1_1d26.arg()+= currMatch.parentArg1_1d18;
	}
}

void TestMode03_1d2a::operator()( const Packets_t& states_1d2b, Packets_t& states_1d2d, Packets_t& conditionalBlocks_1d2e)
{
#ifdef PRINT_INFO
	printLog( "TestMode03_1d2a" );
#endif
	RTTGenerator::Instance()->generateRule(1109, "TestMode03");
	_state_1d2f= &states_1d2d;
	_conditionalBlock_1d30= &conditionalBlocks_1d2e;
	processInputPackets( states_1d2b);
}

bool TestMode03_1d2a::isInputUnique( const Udm::Object& state_1d35)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1d37= _state_1d31.begin(); itState_1d37!= _state_1d31.end(); ++itState_1d37)
	{
		if( ( *itState_1d37== state_1d35))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_1d31.push_back( state_1d35);
	return isUnique;
}

bool TestMode03_1d2a::isGuardTrue( SFC::Arg& Arg0, SFC::Function& Enter, CyberComposition::Simulink::State& State)
{
	bool Gz_guard= false;
	Gz_guard = Arg0.argIndex() == 0;;
	return Gz_guard;
}

void TestMode03_1d2a::processInputPackets( const Packets_t& states_1d2b)
{
	for( Packets_t::const_iterator itState_1d32= states_1d2b.begin(); itState_1d32!= states_1d2b.end(); ++itState_1d32)
	{
		bool isUnique= isInputUnique( *itState_1d32);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1d32);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool TestMode03_1d2a::patternMatcher( const Udm::Object& state_1d33)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1d33.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1d38= CyberComposition::Simulink::State::Cast( state_1d33);
		set< SFC::Function> enters_1d3a= state_1d38.enter();
		for( set< SFC::Function>::const_iterator itEnters_1d3b= enters_1d3a.begin(); itEnters_1d3b!= enters_1d3a.end(); ++itEnters_1d3b)
		{
			SFC::Function currEnter_1d3c= *itEnters_1d3b;
			set< SFC::Arg> arg0s_1d3d= currEnter_1d3c.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itArg0_1d3e= arg0s_1d3d.begin(); itArg0_1d3e!= arg0s_1d3d.end(); ++itArg0_1d3e)
			{
				SFC::Arg currArg0_1d3f= *itArg0_1d3e;
				Match currMatch;
				currMatch.state_1d41= state_1d38;
				currMatch.arg0_1d42= currArg0_1d3f;
				currMatch.enter_1d43= currEnter_1d3c;
				bool Gz_guard= isGuardTrue( currMatch.arg0_1d42, currMatch.enter_1d43, currMatch.state_1d41);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void TestMode03_1d2a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_1d47= SFC::ConditionalBlock::Create( currMatch.enter_1d43, SFC::Function::meta_stmnt);
		SFC::UserCode newUserCode_1d48= SFC::UserCode::Create( newConditionalBlock_1d47, SFC::ConditionalBlock::meta_cond);
		SFC::BinaryExprs newLOR_1d49= SFC::BinaryExprs::Create( newUserCode_1d48, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newEquals1_1d4a= SFC::BinaryExprs::Create( newLOR_1d49, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newZero_1d4b= SFC::Int::Create( newEquals1_1d4a, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef1_1d4c= SFC::ArgDeclRef::Create( newEquals1_1d4a, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newEquals2_1d4d= SFC::BinaryExprs::Create( newLOR_1d49, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newThree_1d4e= SFC::Int::Create( newEquals2_1d4d, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef2_1d4f= SFC::ArgDeclRef::Create( newEquals2_1d4d, SFC::BinaryExprs::meta_leftexpr);
		SFC::Arg& Arg0= currMatch.arg0_1d42;
		SFC::ArgDeclRef& ArgDeclRef1= newArgDeclRef1_1d4c;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_1d4f;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_1d47;
		SFC::Function& Enter= currMatch.enter_1d43;
		SFC::BinaryExprs& Equals1= newEquals1_1d4a;
		SFC::BinaryExprs& Equals2= newEquals2_1d4d;
		SFC::BinaryExprs& LOR= newLOR_1d49;
		CyberComposition::Simulink::State& State= currMatch.state_1d41;
		SFC::Int& Three= newThree_1d4e;
		SFC::UserCode& UserCode= newUserCode_1d48;
		SFC::Int& Zero= newZero_1d4b;
		{
ConditionalBlock.RefId() = UserCode.RefId() = Enter.RefId();
};
		{
Equals2.op() = "==";
};
		{
Three.val() = 3;
};
		{
LOR.op() = "||";
};
		{
Zero.val() = 0;
};
		{
Equals1.op() = "==";
};
		{
__int64 statementCount = Enter.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
Enter.statementCount() = statementCount;
};
		newArgDeclRef2_1d4f.argdecl()= currMatch.arg0_1d42;
		newArgDeclRef1_1d4c.argdecl()= currMatch.arg0_1d42;
		outputAppender( currMatch.state_1d41, newConditionalBlock_1d47);
	}
}

void TestMode03_1d2a::outputAppender( const CyberComposition::Simulink::State& state_1d50, const SFC::ConditionalBlock& conditionalBlock_1d52)
{
	_state_1d2f->push_back( state_1d50);
	_conditionalBlock_1d30->push_back( conditionalBlock_1d52);
}

void Mode0or2_1d5c::operator()( const Packets_t& states_1d5d, Packets_t& states_1d5f)
{
#ifdef PRINT_INFO
	printLog( "Mode0or2_1d5c" );
#endif
	_state_1d60= &states_1d5f;
	if( ( !states_1d5d.empty()))
		callChildTest_1dda( states_1d5d);
	_state_1d60->insert( _state_1d60->end(), states_1d5d.begin(), states_1d5d.end());
}

void Mode0or2_1d5c::callChildTest_1dda( const Packets_t& states_1d62)
{
	Packets_t states_1d64;
	ChildTest_1d61 childTest_1d61;
	childTest_1d61( states_1d62, states_1d64);
	if( ( !states_1d64.empty()))
		callTestMode02_1ddc( states_1d64);
}

void Mode0or2_1d5c::callTestMode02_1ddc( const Packets_t& states_1db1)
{
	Packets_t states_1db3;
	Packets_t conditionalBlocks_1db4;
	TestMode02_1db0 testMode02_1db0;
	testMode02_1db0( states_1db1, states_1db3, conditionalBlocks_1db4);
	if( ( !states_1db3.empty())&& ( !conditionalBlocks_1db4.empty()))
		callChildStateType_1dde( states_1db3, conditionalBlocks_1db4);
}

void Mode0or2_1d5c::callChildStateType_1dde( const Packets_t& states_152f, const Packets_t& css_1531)
{
	Packets_t states_1533;
	Packets_t css_1534;
	Packets_t states_1535;
	Packets_t css_1536;
	ChildStateType_152e childStateType_152e;
	childStateType_152e( states_152f, css_1531, states_1533, css_1534, states_1535, css_1536);
	if( ( !states_1535.empty())&& ( !css_1536.empty()))
		callTransStartMap_1de1( states_1535, css_1536);
	if( ( !states_1533.empty())&& ( !css_1534.empty()))
		callGetChildStates_1de4( states_1533, css_1534);
}

void Mode0or2_1d5c::callTransStartMap_1de1( const Packets_t& states_a08, const Packets_t& css_a0a)
{
	Packets_t states_a0c;
	Packets_t css_a0d;
	TransStartMap_a07 transStartMap_a07;
	transStartMap_a07( states_a08, css_a0a, states_a0c, css_a0d);
	if( ( !states_a0c.empty())&& ( !css_a0d.empty()))
		callRefetchEnterFcn_1de7( states_a0c, css_a0d);
}

void Mode0or2_1d5c::callGetChildStates_1de4( const Packets_t& states_13b0, const Packets_t& compoundStatements_13b4)
{
	Packets_t states_13b2;
	Packets_t childStates_13b3;
	Packets_t compoundStatements_13b6;
	GetChildStates_13af getChildStates_13af;
	getChildStates_13af( states_13b0, compoundStatements_13b4, states_13b2, childStates_13b3, compoundStatements_13b6);
	if( ( !states_13b2.empty())&& ( !childStates_13b3.empty())&& ( !compoundStatements_13b6.empty()))
		callCallSibsOrChildren_1dea( states_13b2, childStates_13b3, compoundStatements_13b6);
}

void Mode0or2_1d5c::callRefetchEnterFcn_1de7( const Packets_t& states_1d87, const Packets_t& compoundStatements_1d8b)
{
	Packets_t states_1d89;
	Packets_t functions_1d8a;
	Packets_t compoundStatements_1d8d;
	RefetchEnterFcn_1d86 refetchEnterFcn_1d86;
	refetchEnterFcn_1d86( states_1d87, compoundStatements_1d8b, states_1d89, functions_1d8a, compoundStatements_1d8d);
	if( ( !states_1d89.empty())&& ( !functions_1d8a.empty())&& ( !compoundStatements_1d8d.empty()))
		callTransStartTransitions_1dee( states_1d89, functions_1d8a, compoundStatements_1d8d);
}

void Mode0or2_1d5c::callCallSibsOrChildren_1dea( const Packets_t& states_1c99, const Packets_t& sOCStates_1c9b, const Packets_t& compoundStatements_1c9d)
{
	CallSibsOrChildren_1c98 callSibsOrChildren_1c98;
	callSibsOrChildren_1c98( states_1c99, sOCStates_1c9b, compoundStatements_1c9d);
}

void Mode0or2_1d5c::callTransStartTransitions_1dee( const Packets_t& states_b2, const Packets_t& fcns_b4, const Packets_t& css_b6)
{
	TransStartTransitions_b1 transStartTransitions_b1;
	transStartTransitions_b1( states_b2, fcns_b4, css_b6);
}

void ChildTest_1d61::operator()( const Packets_t& states_1d62, Packets_t& states_1d64)
{
#ifdef PRINT_INFO
	printLog( "ChildTest_1d61" );
#endif
	_state_1d65= &states_1d64;
	for( Packets_t::const_iterator itstate_1d67= states_1d62.begin(); itstate_1d67!= states_1d62.end(); ++itstate_1d67)
	{
		bool isUnique= isInputUnique( *itstate_1d67);
		if( !isUnique)
			continue;
		Packets_t onestate_1d6b( 1, *itstate_1d67);
		executeOne( onestate_1d6b);
	}
}

void ChildTest_1d61::executeOne( const Packets_t& states_1d62)
{
	Packets_t states_1d70;
	HasChildTransConnector_1d6d hasChildTransConnector_1d6d;
	bool isMatchHasChildTransConnector_1d6d= hasChildTransConnector_1d6d( states_1d62, states_1d70);
	_state_1d65->insert( _state_1d65->end(), states_1d70.begin(), states_1d70.end());
	if( isMatchHasChildTransConnector_1d6d)
		return;
}

bool ChildTest_1d61::isInputUnique( const Udm::Object& state_1d68)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_1d6a= _state_1d66.begin(); itstate_1d6a!= _state_1d66.end(); ++itstate_1d6a)
	{
		if( ( *itstate_1d6a== state_1d68))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_1d66.push_back( state_1d68);
	return isUnique;
}

bool HasChildTransConnector_1d6d::operator()( const Packets_t& states_1d6e, Packets_t& states_1d70)
{
#ifdef PRINT_INFO
	printLog( "HasChildTransConnector_1d6d" );
#endif
	_state_1d71= &states_1d70;
	processInputPackets( states_1d6e);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasChildTransConnector_1d6d::isInputUnique( const Udm::Object& state_1d76)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1d78= _state_1d72.begin(); itState_1d78!= _state_1d72.end(); ++itState_1d78)
	{
		if( ( *itState_1d78== state_1d76))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_1d72.push_back( state_1d76);
	return isUnique;
}

bool HasChildTransConnector_1d6d::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void HasChildTransConnector_1d6d::processInputPackets( const Packets_t& states_1d6e)
{
	for( Packets_t::const_iterator itState_1d73= states_1d6e.begin(); itState_1d73!= states_1d6e.end(); ++itState_1d73)
	{
		bool isUnique= isInputUnique( *itState_1d73);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1d73);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_1d82);
	}
}

bool HasChildTransConnector_1d6d::patternMatcher( const Udm::Object& state_1d74)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1d74.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1d79= CyberComposition::Simulink::State::Cast( state_1d74);
		set< CyberComposition::Simulink::TransConnector> transConnectors_1d7b= state_1d79.TransConnector_kind_children();
		for( set< CyberComposition::Simulink::TransConnector>::const_iterator itTransConnector_1d7c= transConnectors_1d7b.begin(); itTransConnector_1d7c!= transConnectors_1d7b.end(); ++itTransConnector_1d7c)
		{
			CyberComposition::Simulink::TransConnector currTransConnector_1d7d= *itTransConnector_1d7c;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1d81;
			if( !isValidBound(boundObjs_1d81, state_1d79, true))
				continue;
			currMatch.state_1d82= state_1d79;
			if( !isValidBound(boundObjs_1d81, currTransConnector_1d7d, false))
				continue;
			currMatch.transConnector_1d83= currTransConnector_1d7d;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void HasChildTransConnector_1d6d::outputAppender( const CyberComposition::Simulink::State& state_1d84)
{
	_state_1d71->push_back( state_1d84);
}

void RefetchEnterFcn_1d86::operator()( const Packets_t& states_1d87, const Packets_t& compoundStatements_1d8b, Packets_t& states_1d89, Packets_t& functions_1d8a, Packets_t& compoundStatements_1d8d)
{
#ifdef PRINT_INFO
	printLog( "RefetchEnterFcn_1d86" );
#endif
	RTTGenerator::Instance()->generateRule(1152, "RefetchEnterFcn");
	_state_1d8e= &states_1d89;
	_function_1d8f= &functions_1d8a;
	_compoundStatement_1d90= &compoundStatements_1d8d;
	processInputPackets( states_1d87, compoundStatements_1d8b);
}

bool RefetchEnterFcn_1d86::isInputUnique( const Udm::Object& state_1d95, const Udm::Object& compoundStatement_1d9e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1d97= _state_1d91.begin(), itCompoundStatement_1da0= _compoundStatement_1d9a.begin(); itState_1d97!= _state_1d91.end(), itCompoundStatement_1da0!= _compoundStatement_1d9a.end(); ++itState_1d97, ++itCompoundStatement_1da0)
	{
		if( ( *itState_1d97== state_1d95)&& ( *itCompoundStatement_1da0== compoundStatement_1d9e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1d91.push_back( state_1d95);
		_compoundStatement_1d9a.push_back( compoundStatement_1d9e);
	}
	return isUnique;
}

void RefetchEnterFcn_1d86::processInputPackets( const Packets_t& states_1d87, const Packets_t& compoundStatements_1d8b)
{
	for( Packets_t::const_iterator itState_1d92= states_1d87.begin(), itCompoundStatement_1d9b= compoundStatements_1d8b.begin(); itState_1d92!= states_1d87.end(), itCompoundStatement_1d9b!= compoundStatements_1d8b.end(); ++itState_1d92, ++itCompoundStatement_1d9b)
	{
		bool isUnique= isInputUnique( *itState_1d92, *itCompoundStatement_1d9b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1d92, *itCompoundStatement_1d9b);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool RefetchEnterFcn_1d86::patternMatcher( const Udm::Object& state_1d93, const Udm::Object& compoundStatement_1d9c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1d93.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1d98= CyberComposition::Simulink::State::Cast( state_1d93);
		if( false== Uml::IsDerivedFrom( compoundStatement_1d9c.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_1da1= SFC::CompoundStatement::Cast( compoundStatement_1d9c);
		set< SFC::Function> functions_1da3= state_1d98.enter();
		for( set< SFC::Function>::const_iterator itFunctions_1da4= functions_1da3.begin(); itFunctions_1da4!= functions_1da3.end(); ++itFunctions_1da4)
		{
			SFC::Function currFunction_1da5= *itFunctions_1da4;
			Match currMatch;
			currMatch.state_1da7= state_1d98;
			currMatch.compoundStatement_1da8= compoundStatement_1da1;
			currMatch.function_1da9= currFunction_1da5;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void RefetchEnterFcn_1d86::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_1da7, currMatch.function_1da9, currMatch.compoundStatement_1da8);
	}
}

void RefetchEnterFcn_1d86::outputAppender( const CyberComposition::Simulink::State& state_1daa, const SFC::Function& function_1dac, const SFC::CompoundStatement& compoundStatement_1dae)
{
	_state_1d8e->push_back( state_1daa);
	_function_1d8f->push_back( function_1dac);
	_compoundStatement_1d90->push_back( compoundStatement_1dae);
}

void TestMode02_1db0::operator()( const Packets_t& states_1db1, Packets_t& states_1db3, Packets_t& conditionalBlocks_1db4)
{
#ifdef PRINT_INFO
	printLog( "TestMode02_1db0" );
#endif
	RTTGenerator::Instance()->generateRule(1157, "TestMode02");
	_state_1db5= &states_1db3;
	_conditionalBlock_1db6= &conditionalBlocks_1db4;
	processInputPackets( states_1db1);
}

bool TestMode02_1db0::isInputUnique( const Udm::Object& state_1dbb)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1dbd= _state_1db7.begin(); itState_1dbd!= _state_1db7.end(); ++itState_1dbd)
	{
		if( ( *itState_1dbd== state_1dbb))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_1db7.push_back( state_1dbb);
	return isUnique;
}

bool TestMode02_1db0::isGuardTrue( SFC::Arg& Arg0, SFC::Function& Enter, CyberComposition::Simulink::State& State)
{
	bool Gz_guard= false;
	Gz_guard = Arg0.argIndex() == 0;;
	return Gz_guard;
}

void TestMode02_1db0::processInputPackets( const Packets_t& states_1db1)
{
	for( Packets_t::const_iterator itState_1db8= states_1db1.begin(); itState_1db8!= states_1db1.end(); ++itState_1db8)
	{
		bool isUnique= isInputUnique( *itState_1db8);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1db8);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool TestMode02_1db0::patternMatcher( const Udm::Object& state_1db9)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1db9.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1dbe= CyberComposition::Simulink::State::Cast( state_1db9);
		set< SFC::Function> enters_1dc0= state_1dbe.enter();
		for( set< SFC::Function>::const_iterator itEnters_1dc1= enters_1dc0.begin(); itEnters_1dc1!= enters_1dc0.end(); ++itEnters_1dc1)
		{
			SFC::Function currEnter_1dc2= *itEnters_1dc1;
			set< SFC::Arg> arg0s_1dc3= currEnter_1dc2.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itArg0_1dc4= arg0s_1dc3.begin(); itArg0_1dc4!= arg0s_1dc3.end(); ++itArg0_1dc4)
			{
				SFC::Arg currArg0_1dc5= *itArg0_1dc4;
				Match currMatch;
				currMatch.state_1dc7= state_1dbe;
				currMatch.arg0_1dc8= currArg0_1dc5;
				currMatch.enter_1dc9= currEnter_1dc2;
				bool Gz_guard= isGuardTrue( currMatch.arg0_1dc8, currMatch.enter_1dc9, currMatch.state_1dc7);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void TestMode02_1db0::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_1dcd= SFC::ConditionalBlock::Create( currMatch.enter_1dc9, SFC::Function::meta_stmnt);
		SFC::UserCode newUserCode_1dce= SFC::UserCode::Create( newConditionalBlock_1dcd, SFC::ConditionalBlock::meta_cond);
		SFC::BinaryExprs newLOR_1dcf= SFC::BinaryExprs::Create( newUserCode_1dce, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newEquals1_1dd0= SFC::BinaryExprs::Create( newLOR_1dcf, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newZero_1dd1= SFC::Int::Create( newEquals1_1dd0, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef1_1dd2= SFC::ArgDeclRef::Create( newEquals1_1dd0, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newEquals2_1dd3= SFC::BinaryExprs::Create( newLOR_1dcf, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newTwo_1dd4= SFC::Int::Create( newEquals2_1dd3, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef2_1dd5= SFC::ArgDeclRef::Create( newEquals2_1dd3, SFC::BinaryExprs::meta_leftexpr);
		SFC::Arg& Arg0= currMatch.arg0_1dc8;
		SFC::ArgDeclRef& ArgDeclRef1= newArgDeclRef1_1dd2;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_1dd5;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_1dcd;
		SFC::Function& Enter= currMatch.enter_1dc9;
		SFC::BinaryExprs& Equals1= newEquals1_1dd0;
		SFC::BinaryExprs& Equals2= newEquals2_1dd3;
		SFC::BinaryExprs& LOR= newLOR_1dcf;
		CyberComposition::Simulink::State& State= currMatch.state_1dc7;
		SFC::Int& Two= newTwo_1dd4;
		SFC::UserCode& UserCode= newUserCode_1dce;
		SFC::Int& Zero= newZero_1dd1;
		{
ConditionalBlock.RefId() = UserCode.RefId() = Enter.RefId();
};
		{
Equals2.op() = "==";
};
		{
Two.val() = 2;
};
		{
LOR.op() = "||";
};
		{
Zero.val() = 0;
};
		{
Equals1.op() = "==";
};
		{
__int64 statementCount = Enter.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
Enter.statementCount() = statementCount;
};
		newArgDeclRef2_1dd5.argdecl()= currMatch.arg0_1dc8;
		newArgDeclRef1_1dd2.argdecl()= currMatch.arg0_1dc8;
		outputAppender( currMatch.state_1dc7, newConditionalBlock_1dcd);
	}
}

void TestMode02_1db0::outputAppender( const CyberComposition::Simulink::State& state_1dd6, const SFC::ConditionalBlock& conditionalBlock_1dd8)
{
	_state_1db5->push_back( state_1dd6);
	_conditionalBlock_1db6->push_back( conditionalBlock_1dd8);
}

void Mode0or1or2_1df2::operator()( const Packets_t& states_1df3, Packets_t& states_1df5)
{
#ifdef PRINT_INFO
	printLog( "Mode0or1or2_1df2" );
#endif
	_state_1df6= &states_1df5;
	_state_1df6->insert( _state_1df6->end(), states_1df3.begin(), states_1df3.end());
	if( ( !states_1df3.empty()))
		callTestMode012EnterAction_1e31( states_1df3);
}

void Mode0or1or2_1df2::callTestMode012EnterAction_1e31( const Packets_t& states_1df8)
{
	TestMode012EnterAction_1df7 testMode012EnterAction_1df7;
	testMode012EnterAction_1df7( states_1df8);
}

void TestMode012EnterAction_1df7::operator()( const Packets_t& states_1df8)
{
#ifdef PRINT_INFO
	printLog( "TestMode012EnterAction_1df7" );
#endif
	RTTGenerator::Instance()->generateRule(1193, "TestMode012EnterAction");
	processInputPackets( states_1df8);
}

bool TestMode012EnterAction_1df7::isInputUnique( const Udm::Object& state_1dfe)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1e00= _state_1dfa.begin(); itState_1e00!= _state_1dfa.end(); ++itState_1e00)
	{
		if( ( *itState_1e00== state_1dfe))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_1dfa.push_back( state_1dfe);
	return isUnique;
}

bool TestMode012EnterAction_1df7::isGuardTrue( SFC::Arg& Arg0, SFC::Function& Enter, CyberComposition::Simulink::State& ParentState, SFC::StateLabel& ParentStateLabel, SFC::Program& Program, CyberComposition::Simulink::State& State, SFC::StateLabel& StateLabel, SFC::StateVar& StateVar)
{
	bool Gz_guard= false;
	Gz_guard = Arg0.argIndex() == 0;;
	return Gz_guard;
}

void TestMode012EnterAction_1df7::processInputPackets( const Packets_t& states_1df8)
{
	for( Packets_t::const_iterator itState_1dfb= states_1df8.begin(); itState_1dfb!= states_1df8.end(); ++itState_1dfb)
	{
		bool isUnique= isInputUnique( *itState_1dfb);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1dfb);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool TestMode012EnterAction_1df7::patternMatcher( const Udm::Object& state_1dfc)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1dfc.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1e01= CyberComposition::Simulink::State::Cast( state_1dfc);
		Udm::Object stateParent_1e03= state_1e01.container();
		if( false== Uml::IsDerivedFrom( stateParent_1e03.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State parentStateState_1e04= CyberComposition::Simulink::State::Cast( stateParent_1e03);
		set< SFC::StateLabel> stateLabels_1e05= state_1e01.src();
		for( set< SFC::StateLabel>::const_iterator itStateLabels_1e06= stateLabels_1e05.begin(); itStateLabels_1e06!= stateLabels_1e05.end(); ++itStateLabels_1e06)
		{
			SFC::StateLabel currStateLabel_1e07= *itStateLabels_1e06;
			set< SFC::StateLabel> parentStateLabels_1e08= parentStateState_1e04.src();
			for( set< SFC::StateLabel>::const_iterator itParentStateLabels_1e09= parentStateLabels_1e08.begin(); itParentStateLabels_1e09!= parentStateLabels_1e08.end(); ++itParentStateLabels_1e09)
			{
				SFC::StateLabel currParentStateLabel_1e0a= *itParentStateLabels_1e09;
				set< SFC::Function> enters_1e0b= state_1e01.enter();
				for( set< SFC::Function>::const_iterator itEnters_1e0c= enters_1e0b.begin(); itEnters_1e0c!= enters_1e0b.end(); ++itEnters_1e0c)
				{
					SFC::Function currEnter_1e0d= *itEnters_1e0c;
					Udm::Object enterParent_1e0e= currEnter_1e0d.container();
					if( false== Uml::IsDerivedFrom( enterParent_1e0e.type(), SFC::Program::meta))
						continue;
					SFC::Program programEnter_1e0f= SFC::Program::Cast( enterParent_1e0e);
					set< SFC::StateVar> stateVars_1e10= programEnter_1e0f.StateVar_kind_children();
					for( set< SFC::StateVar>::const_iterator itStateVar_1e11= stateVars_1e10.begin(); itStateVar_1e11!= stateVars_1e10.end(); ++itStateVar_1e11)
					{
						SFC::StateVar currStateVar_1e12= *itStateVar_1e11;
						set< SFC::Arg> arg0s_1e13= currEnter_1e0d.Arg_kind_children();
						for( set< SFC::Arg>::const_iterator itArg0_1e14= arg0s_1e13.begin(); itArg0_1e14!= arg0s_1e13.end(); ++itArg0_1e14)
						{
							SFC::Arg currArg0_1e15= *itArg0_1e14;
							Match currMatch;
							currMatch.state_1e17= state_1e01;
							currMatch.parentState_1e18= parentStateState_1e04;
							currMatch.parentStateLabel_1e19= currParentStateLabel_1e0a;
							currMatch.stateLabel_1e1a= currStateLabel_1e07;
							currMatch.arg0_1e1b= currArg0_1e15;
							currMatch.enter_1e1c= currEnter_1e0d;
							currMatch.program_1e1d= programEnter_1e0f;
							currMatch.stateVar_1e1e= currStateVar_1e12;
							bool Gz_guard= isGuardTrue( currMatch.arg0_1e1b, currMatch.enter_1e1c, currMatch.parentState_1e18, currMatch.parentStateLabel_1e19, currMatch.program_1e1d, currMatch.state_1e17, currMatch.stateLabel_1e1a, currMatch.stateVar_1e1e);
							if( true== Gz_guard)
								_matches.push_back( currMatch);
						}
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void TestMode012EnterAction_1df7::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_1e27= SFC::ConditionalBlock::Create( currMatch.enter_1e1c, SFC::Function::meta_stmnt);
		SFC::SetState newSetState_1e28= SFC::SetState::Create( newConditionalBlock_1e27, SFC::ConditionalBlock::meta_stmnt);
		SFC::UserCode newUserCode_1e29= SFC::UserCode::Create( newConditionalBlock_1e27, SFC::ConditionalBlock::meta_cond);
		SFC::BinaryExprs newLAND_1e2a= SFC::BinaryExprs::Create( newUserCode_1e29, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newGE_1e2b= SFC::BinaryExprs::Create( newLAND_1e2a, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newZero_1e2c= SFC::Int::Create( newGE_1e2b, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef1_1e2d= SFC::ArgDeclRef::Create( newGE_1e2b, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newLE_1e2e= SFC::BinaryExprs::Create( newLAND_1e2a, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newTwo_1e2f= SFC::Int::Create( newLE_1e2e, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef2_1e30= SFC::ArgDeclRef::Create( newLE_1e2e, SFC::BinaryExprs::meta_leftexpr);
		SFC::Arg& Arg0= currMatch.arg0_1e1b;
		SFC::ArgDeclRef& ArgDeclRef1= newArgDeclRef1_1e2d;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_1e30;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_1e27;
		SFC::Function& Enter= currMatch.enter_1e1c;
		SFC::BinaryExprs& GE= newGE_1e2b;
		SFC::BinaryExprs& LAND= newLAND_1e2a;
		SFC::BinaryExprs& LE= newLE_1e2e;
		CyberComposition::Simulink::State& ParentState= currMatch.parentState_1e18;
		SFC::StateLabel& ParentStateLabel= currMatch.parentStateLabel_1e19;
		SFC::Program& Program= currMatch.program_1e1d;
		SFC::SetState& SetState= newSetState_1e28;
		CyberComposition::Simulink::State& State= currMatch.state_1e17;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_1e1a;
		SFC::StateVar& StateVar= currMatch.stateVar_1e1e;
		SFC::Int& Two= newTwo_1e2f;
		SFC::UserCode& UserCode= newUserCode_1e29;
		SFC::Int& Zero= newZero_1e2c;
		{
ConditionalBlock.RefId() = UserCode.RefId() = SetState.RefId() = Enter.RefId();
};
		{
SetState.invert() = false;
SetState.andState() = static_cast< std::string >( State.Decomposition() ) == "AND_STATE";
};
		{
__int64 statementCount = ConditionalBlock.statementCount();
SetState.statementIndex() = statementCount++;
ConditionalBlock.statementCount() = statementCount;

SFManager::mstat2SFC( ConditionalBlock, State.EnterAction() );
};
		{
LE.op() = "<=";
};
		{
Two.val() = 2;
};
		{
LAND.op() = "&&";
};
		{
Zero.val() = 0;
};
		{
GE.op() = ">=";
};
		{
__int64 statementCount = Enter.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
Enter.statementCount() = statementCount;
};
		newSetState_1e28.index()= currMatch.parentStateLabel_1e19;
		newSetState_1e28.value()= currMatch.stateLabel_1e1a;
		newSetState_1e28.svar()= currMatch.stateVar_1e1e;
		newArgDeclRef2_1e30.argdecl()= currMatch.arg0_1e1b;
		newArgDeclRef1_1e2d.argdecl()= currMatch.arg0_1e1b;
	}
}

void Mode0or1_1e33::operator()( const Packets_t& states_1e34, Packets_t& states_1e36)
{
#ifdef PRINT_INFO
	printLog( "Mode0or1_1e33" );
#endif
	_state_1e37= &states_1e36;
	_state_1e37->insert( _state_1e37->end(), states_1e34.begin(), states_1e34.end());
	if( ( !states_1e34.empty()))
		callTestMode01CallParent_1eb0( states_1e34);
}

void Mode0or1_1e33::callTestMode01CallParent_1eb0( const Packets_t& states_1e6a)
{
	Packets_t states_1e6c;
	Packets_t conditionalBlocks_1e6d;
	TestMode01CallParent_1e69 testMode01CallParent_1e69;
	testMode01CallParent_1e69( states_1e6a, states_1e6c, conditionalBlocks_1e6d);
	if( ( !states_1e6c.empty())&& ( !conditionalBlocks_1e6d.empty()))
		callIsAndState_1eb2( states_1e6c, conditionalBlocks_1e6d);
}

void Mode0or1_1e33::callIsAndState_1eb2( const Packets_t& states_1c5e, const Packets_t& css_1c60)
{
	Packets_t states_1c62;
	Packets_t css_1c63;
	IsAndState_1c5d isAndState_1c5d;
	isAndState_1c5d( states_1c5e, css_1c60, states_1c62, css_1c63);
	if( ( !states_1c62.empty())&& ( !css_1c63.empty()))
		callGetHOSibs_1eb5( states_1c62, css_1c63);
}

void Mode0or1_1e33::callGetHOSibs_1eb5( const Packets_t& states_1e39, const Packets_t& compoundStatements_1e3d)
{
	Packets_t states_1e3b;
	Packets_t sibStates_1e3c;
	Packets_t compoundStatements_1e3f;
	GetHOSibs_1e38 getHOSibs_1e38;
	getHOSibs_1e38( states_1e39, compoundStatements_1e3d, states_1e3b, sibStates_1e3c, compoundStatements_1e3f);
	if( ( !states_1e3b.empty())&& ( !sibStates_1e3c.empty())&& ( !compoundStatements_1e3f.empty()))
		callCallSibsOrChildren_1eb8( states_1e3b, sibStates_1e3c, compoundStatements_1e3f);
}

void Mode0or1_1e33::callCallSibsOrChildren_1eb8( const Packets_t& states_1c99, const Packets_t& sOCStates_1c9b, const Packets_t& compoundStatements_1c9d)
{
	CallSibsOrChildren_1c98 callSibsOrChildren_1c98;
	callSibsOrChildren_1c98( states_1c99, sOCStates_1c9b, compoundStatements_1c9d);
}

void GetHOSibs_1e38::operator()( const Packets_t& states_1e39, const Packets_t& compoundStatements_1e3d, Packets_t& states_1e3b, Packets_t& sibStates_1e3c, Packets_t& compoundStatements_1e3f)
{
#ifdef PRINT_INFO
	printLog( "GetHOSibs_1e38" );
#endif
	RTTGenerator::Instance()->generateRule(1246, "GetHOSibs");
	_state_1e40= &states_1e3b;
	_sibState_1e41= &sibStates_1e3c;
	_compoundStatement_1e42= &compoundStatements_1e3f;
	processInputPackets( states_1e39, compoundStatements_1e3d);
	sortOutputs( );
}

bool GetHOSibs_1e38::isInputUnique( const Udm::Object& state_1e47, const Udm::Object& compoundStatement_1e50)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1e49= _state_1e43.begin(), itCompoundStatement_1e52= _compoundStatement_1e4c.begin(); itState_1e49!= _state_1e43.end(), itCompoundStatement_1e52!= _compoundStatement_1e4c.end(); ++itState_1e49, ++itCompoundStatement_1e52)
	{
		if( ( *itState_1e49== state_1e47)&& ( *itCompoundStatement_1e52== compoundStatement_1e50))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1e43.push_back( state_1e47);
		_compoundStatement_1e4c.push_back( compoundStatement_1e50);
	}
	return isUnique;
}

bool GetHOSibs_1e38::isGuardTrue( SFC::CompoundStatement& CompoundStatement, CyberComposition::Simulink::State& ParentState, CyberComposition::Simulink::State& SibState, CyberComposition::Simulink::State& State)
{
	bool Gz_guard= false;
	std::string stateOrder = SFManager::trim(  static_cast< std::string >( State.Order() )  );
if ( stateOrder.empty() ) stateOrder = "0";

std::string sibStateOrder = SFManager::trim(  static_cast< std::string >( SibState.Order() )  );
if ( sibStateOrder.empty() ) sibStateOrder = "0";

return boost::lexical_cast< int >( stateOrder ) < boost::lexical_cast< int >( sibStateOrder );;
	return Gz_guard;
}

void GetHOSibs_1e38::processInputPackets( const Packets_t& states_1e39, const Packets_t& compoundStatements_1e3d)
{
	for( Packets_t::const_iterator itState_1e44= states_1e39.begin(), itCompoundStatement_1e4d= compoundStatements_1e3d.begin(); itState_1e44!= states_1e39.end(), itCompoundStatement_1e4d!= compoundStatements_1e3d.end(); ++itState_1e44, ++itCompoundStatement_1e4d)
	{
		bool isUnique= isInputUnique( *itState_1e44, *itCompoundStatement_1e4d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1e44, *itCompoundStatement_1e4d);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetHOSibs_1e38::patternMatcher( const Udm::Object& state_1e45, const Udm::Object& compoundStatement_1e4e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1e45.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1e4a= CyberComposition::Simulink::State::Cast( state_1e45);
		if( false== Uml::IsDerivedFrom( compoundStatement_1e4e.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_1e53= SFC::CompoundStatement::Cast( compoundStatement_1e4e);
		Udm::Object stateParent_1e55= state_1e4a.container();
		if( false== Uml::IsDerivedFrom( stateParent_1e55.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State parentStateState_1e56= CyberComposition::Simulink::State::Cast( stateParent_1e55);
		set< CyberComposition::Simulink::State> sibStates_1e57= parentStateState_1e56.State_kind_children();
		for( set< CyberComposition::Simulink::State>::const_iterator itSibState_1e58= sibStates_1e57.begin(); itSibState_1e58!= sibStates_1e57.end(); ++itSibState_1e58)
		{
			CyberComposition::Simulink::State currSibState_1e59= *itSibState_1e58;
			Match currMatch;
			currMatch.state_1e5b= state_1e4a;
			currMatch.compoundStatement_1e5c= compoundStatement_1e53;
			currMatch.parentState_1e5d= parentStateState_1e56;
			currMatch.sibState_1e5e= currSibState_1e59;
			bool Gz_guard= isGuardTrue( currMatch.compoundStatement_1e5c, currMatch.parentState_1e5d, currMatch.sibState_1e5e, currMatch.state_1e5b);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetHOSibs_1e38::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_1e5b, currMatch.sibState_1e5e, currMatch.compoundStatement_1e5c);
	}
}

void GetHOSibs_1e38::outputAppender( const CyberComposition::Simulink::State& state_1e63, const CyberComposition::Simulink::State& sibState_1e65, const SFC::CompoundStatement& compoundStatement_1e67)
{
	_state_1e40->push_back( state_1e63);
	_sibState_1e41->push_back( sibState_1e65);
	_compoundStatement_1e42->push_back( compoundStatement_1e67);
}

void GetHOSibs_1e38::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::State, std::pointer_to_binary_function< const CyberComposition::Simulink::State&, const CyberComposition::Simulink::State&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::State&, const CyberComposition::Simulink::State&, bool> ptr_StateOrder( StateOrder< CyberComposition::Simulink::State>);
	SortedSet_t sortedSet( ptr_StateOrder);
	std::vector< int> permutationVector( _sibState_1e41->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _sibState_1e41->begin(); it!= _sibState_1e41->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::State::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _sibState_1e41->begin());
	// order rest of the containers
	permutate( permutationVector, *_state_1e40);
	permutate( permutationVector, *_compoundStatement_1e42);
}

void TestMode01CallParent_1e69::operator()( const Packets_t& states_1e6a, Packets_t& states_1e6c, Packets_t& conditionalBlocks_1e6d)
{
#ifdef PRINT_INFO
	printLog( "TestMode01CallParent_1e69" );
#endif
	RTTGenerator::Instance()->generateRule(1253, "TestMode01CallParent");
	_state_1e6e= &states_1e6c;
	_conditionalBlock_1e6f= &conditionalBlocks_1e6d;
	processInputPackets( states_1e6a);
}

bool TestMode01CallParent_1e69::isInputUnique( const Udm::Object& state_1e74)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1e76= _state_1e70.begin(); itState_1e76!= _state_1e70.end(); ++itState_1e76)
	{
		if( ( *itState_1e76== state_1e74))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_1e70.push_back( state_1e74);
	return isUnique;
}

bool TestMode01CallParent_1e69::isGuardTrue( SFC::Arg& Arg0, SFC::Arg& Arg1, SFC::Function& Enter, SFC::Arg& ParentArg0, SFC::Arg& ParentArg1, SFC::Function& ParentEnter, CyberComposition::Simulink::State& ParentState, CyberComposition::Simulink::State& State)
{
	bool Gz_guard= false;
	return ParentArg0.argIndex() == 0 && ParentArg1.argIndex() == 1 && Arg0.argIndex() == 0 && Arg1.argIndex() == 1;;
	return Gz_guard;
}

void TestMode01CallParent_1e69::processInputPackets( const Packets_t& states_1e6a)
{
	for( Packets_t::const_iterator itState_1e71= states_1e6a.begin(); itState_1e71!= states_1e6a.end(); ++itState_1e71)
	{
		bool isUnique= isInputUnique( *itState_1e71);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1e71);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool TestMode01CallParent_1e69::patternMatcher( const Udm::Object& state_1e72)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1e72.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1e77= CyberComposition::Simulink::State::Cast( state_1e72);
		Udm::Object stateParent_1e79= state_1e77.container();
		if( false== Uml::IsDerivedFrom( stateParent_1e79.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State parentStateState_1e7a= CyberComposition::Simulink::State::Cast( stateParent_1e79);
		set< SFC::Function> parentEnters_1e7b= parentStateState_1e7a.enter();
		for( set< SFC::Function>::const_iterator itParentEnters_1e7c= parentEnters_1e7b.begin(); itParentEnters_1e7c!= parentEnters_1e7b.end(); ++itParentEnters_1e7c)
		{
			SFC::Function currParentEnter_1e7d= *itParentEnters_1e7c;
			set< SFC::Arg> parentArg1s_1e7e= currParentEnter_1e7d.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itParentArg1_1e7f= parentArg1s_1e7e.begin(); itParentArg1_1e7f!= parentArg1s_1e7e.end(); ++itParentArg1_1e7f)
			{
				SFC::Arg currParentArg1_1e80= *itParentArg1_1e7f;
				set< SFC::Arg> parentArg0s_1e81= currParentEnter_1e7d.Arg_kind_children();
				for( set< SFC::Arg>::const_iterator itParentArg0_1e82= parentArg0s_1e81.begin(); itParentArg0_1e82!= parentArg0s_1e81.end(); ++itParentArg0_1e82)
				{
					SFC::Arg currParentArg0_1e83= *itParentArg0_1e82;
					set< SFC::Function> enters_1e84= state_1e77.enter();
					for( set< SFC::Function>::const_iterator itEnters_1e85= enters_1e84.begin(); itEnters_1e85!= enters_1e84.end(); ++itEnters_1e85)
					{
						SFC::Function currEnter_1e86= *itEnters_1e85;
						set< SFC::Arg> arg0s_1e87= currEnter_1e86.Arg_kind_children();
						for( set< SFC::Arg>::const_iterator itArg0_1e88= arg0s_1e87.begin(); itArg0_1e88!= arg0s_1e87.end(); ++itArg0_1e88)
						{
							SFC::Arg currArg0_1e89= *itArg0_1e88;
							set< SFC::Arg> arg1s_1e8a= currEnter_1e86.Arg_kind_children();
							for( set< SFC::Arg>::const_iterator itArg1_1e8b= arg1s_1e8a.begin(); itArg1_1e8b!= arg1s_1e8a.end(); ++itArg1_1e8b)
							{
								SFC::Arg currArg1_1e8c= *itArg1_1e8b;
								Match currMatch;
								currMatch.state_1e8e= state_1e77;
								currMatch.parentState_1e8f= parentStateState_1e7a;
								currMatch.parentArg0_1e90= currParentArg0_1e83;
								currMatch.parentEnter_1e91= currParentEnter_1e7d;
								currMatch.arg0_1e92= currArg0_1e89;
								currMatch.arg1_1e93= currArg1_1e8c;
								currMatch.parentArg1_1e94= currParentArg1_1e80;
								currMatch.enter_1e95= currEnter_1e86;
								bool Gz_guard= isGuardTrue( currMatch.arg0_1e92, currMatch.arg1_1e93, currMatch.enter_1e95, currMatch.parentArg0_1e90, currMatch.parentArg1_1e94, currMatch.parentEnter_1e91, currMatch.parentState_1e8f, currMatch.state_1e8e);
								if( true== Gz_guard)
									_matches.push_back( currMatch);
							}
						}
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void TestMode01CallParent_1e69::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_1e9e= SFC::ConditionalBlock::Create( currMatch.enter_1e95, SFC::Function::meta_stmnt);
		SFC::FunctionCall newFunctionCall_1e9f= SFC::FunctionCall::Create( newConditionalBlock_1e9e, SFC::ConditionalBlock::meta_stmnt);
		SFC::ArgVal newArgVal1_1ea0= SFC::ArgVal::Create( newFunctionCall_1e9f);
		SFC::ArgDeclRef newFCArgDeclRef_1ea1= SFC::ArgDeclRef::Create( newArgVal1_1ea0, SFC::ArgVal::meta_argexpr);
		SFC::ArgVal newArgVal0_1ea2= SFC::ArgVal::Create( newFunctionCall_1e9f);
		SFC::Int newArgOne_1ea3= SFC::Int::Create( newArgVal0_1ea2, SFC::ArgVal::meta_argexpr);
		SFC::UserCode newUserCode_1ea4= SFC::UserCode::Create( newConditionalBlock_1e9e, SFC::ConditionalBlock::meta_cond);
		SFC::BinaryExprs newLOR_1ea5= SFC::BinaryExprs::Create( newUserCode_1ea4, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newEquals2_1ea6= SFC::BinaryExprs::Create( newLOR_1ea5, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newOne_1ea7= SFC::Int::Create( newEquals2_1ea6, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef2_1ea8= SFC::ArgDeclRef::Create( newEquals2_1ea6, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newEquals1_1ea9= SFC::BinaryExprs::Create( newLOR_1ea5, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef1_1eaa= SFC::ArgDeclRef::Create( newEquals1_1ea9, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newZero_1eab= SFC::Int::Create( newEquals1_1ea9, SFC::BinaryExprs::meta_rightexpr);
		SFC::Arg& Arg0= currMatch.arg0_1e92;
		SFC::Arg& Arg1= currMatch.arg1_1e93;
		SFC::ArgDeclRef& ArgDeclRef1= newArgDeclRef1_1eaa;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_1ea8;
		SFC::Int& ArgOne= newArgOne_1ea3;
		SFC::ArgVal& ArgVal0= newArgVal0_1ea2;
		SFC::ArgVal& ArgVal1= newArgVal1_1ea0;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_1e9e;
		SFC::Function& Enter= currMatch.enter_1e95;
		SFC::BinaryExprs& Equals1= newEquals1_1ea9;
		SFC::BinaryExprs& Equals2= newEquals2_1ea6;
		SFC::ArgDeclRef& FCArgDeclRef= newFCArgDeclRef_1ea1;
		SFC::FunctionCall& FunctionCall= newFunctionCall_1e9f;
		SFC::BinaryExprs& LOR= newLOR_1ea5;
		SFC::Int& One= newOne_1ea7;
		SFC::Arg& ParentArg0= currMatch.parentArg0_1e90;
		SFC::Arg& ParentArg1= currMatch.parentArg1_1e94;
		SFC::Function& ParentEnter= currMatch.parentEnter_1e91;
		CyberComposition::Simulink::State& ParentState= currMatch.parentState_1e8f;
		CyberComposition::Simulink::State& State= currMatch.state_1e8e;
		SFC::UserCode& UserCode= newUserCode_1ea4;
		SFC::Int& Zero= newZero_1eab;
		{
ConditionalBlock.RefId() = UserCode.RefId() = FunctionCall.RefId() = Enter.RefId();
};
		{
ArgOne.val() = 1;
};
		{
FunctionCall.argCount() = 2;
};
		{
ArgVal0.argIndex() = 0;
};
		{
ArgVal1.argIndex() = 1;
};
		{
__int64 statementCount = Enter.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
Enter.statementCount() = statementCount;
};
		{
__int64 statementCount = ConditionalBlock.statementCount();
FunctionCall.statementIndex() = statementCount++;
ConditionalBlock.statementCount() = statementCount;
};
		{
Zero.val() = 0;
};
		{
One.val() = 1;
};
		{
Equals2.op() = "==";
};
		{
Equals1.op() = "==";
};
		{
LOR.op() = "||";
};
		newFunctionCall_1e9f.callee()= currMatch.parentEnter_1e91;
		newArgVal0_1ea2.arg()+= currMatch.parentArg0_1e90;
		newArgVal1_1ea0.arg()+= currMatch.parentArg1_1e94;
		newFCArgDeclRef_1ea1.argdecl()= currMatch.arg1_1e93;
		newArgDeclRef1_1eaa.argdecl()= currMatch.arg0_1e92;
		newArgDeclRef2_1ea8.argdecl()= currMatch.arg0_1e92;
		outputAppender( currMatch.state_1e8e, newConditionalBlock_1e9e);
	}
}

void TestMode01CallParent_1e69::outputAppender( const CyberComposition::Simulink::State& state_1eac, const SFC::ConditionalBlock& conditionalBlock_1eae)
{
	_state_1e6e->push_back( state_1eac);
	_conditionalBlock_1e6f->push_back( conditionalBlock_1eae);
}

void ReturnAtTopState_1ebc::operator()( const Packets_t& states_1ebd, Packets_t& states_1ebf)
{
#ifdef PRINT_INFO
	printLog( "ReturnAtTopState_1ebc" );
#endif
	_state_1ec0= &states_1ebf;
	if( ( !states_1ebd.empty()))
		callTopState_1ee8( states_1ebd);
	_state_1ec0->insert( _state_1ec0->end(), states_1ebd.begin(), states_1ebd.end());
}

void ReturnAtTopState_1ebc::callTopState_1ee8( const Packets_t& states_1ec2)
{
	TopState_1ec1 topState_1ec1;
	topState_1ec1( states_1ec2);
}

void TopState_1ec1::operator()( const Packets_t& states_1ec2)
{
#ifdef PRINT_INFO
	printLog( "TopState_1ec1" );
#endif
	RTTGenerator::Instance()->generateRule(1360, "TopState");
	processInputPackets( states_1ec2);
}

bool TopState_1ec1::isInputUnique( const Udm::Object& state_1ec8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1eca= _state_1ec4.begin(); itState_1eca!= _state_1ec4.end(); ++itState_1eca)
	{
		if( ( *itState_1eca== state_1ec8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_1ec4.push_back( state_1ec8);
	return isUnique;
}

bool TopState_1ec1::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool TopState_1ec1::isGuardTrue( SFC::Arg& Arg, SFC::Function& Enter, CyberComposition::Simulink::State& State, SFC::StateLabel& StateLabel)
{
	bool Gz_guard= false;
	Gz_guard = Arg.argIndex() == 1;;
	return Gz_guard;
}

void TopState_1ec1::processInputPackets( const Packets_t& states_1ec2)
{
	for( Packets_t::const_iterator itState_1ec5= states_1ec2.begin(); itState_1ec5!= states_1ec2.end(); ++itState_1ec5)
	{
		bool isUnique= isInputUnique( *itState_1ec5);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1ec5);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool TopState_1ec1::patternMatcher( const Udm::Object& state_1ec6)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1ec6.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1ecb= CyberComposition::Simulink::State::Cast( state_1ec6);
		set< SFC::Function> enters_1ecd= state_1ecb.enter();
		for( set< SFC::Function>::const_iterator itEnters_1ece= enters_1ecd.begin(); itEnters_1ece!= enters_1ecd.end(); ++itEnters_1ece)
		{
			SFC::Function currEnter_1ecf= *itEnters_1ece;
			set< SFC::Arg> args_1ed0= currEnter_1ecf.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itArg_1ed1= args_1ed0.begin(); itArg_1ed1!= args_1ed0.end(); ++itArg_1ed1)
			{
				SFC::Arg currArg_1ed2= *itArg_1ed1;
				set< SFC::StateLabel> stateLabels_1ed3= state_1ecb.src();
				for( set< SFC::StateLabel>::const_iterator itStateLabels_1ed4= stateLabels_1ed3.begin(); itStateLabels_1ed4!= stateLabels_1ed3.end(); ++itStateLabels_1ed4)
				{
					SFC::StateLabel currStateLabel_1ed5= *itStateLabels_1ed4;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_1ed9;
					if( !isValidBound(boundObjs_1ed9, state_1ecb, true))
						continue;
					currMatch.state_1eda= state_1ecb;
					if( !isValidBound(boundObjs_1ed9, currStateLabel_1ed5, false))
						continue;
					currMatch.stateLabel_1edb= currStateLabel_1ed5;
					if( !isValidBound(boundObjs_1ed9, currEnter_1ecf, false))
						continue;
					currMatch.enter_1edc= currEnter_1ecf;
					if( !isValidBound(boundObjs_1ed9, currArg_1ed2, false))
						continue;
					currMatch.arg_1edd= currArg_1ed2;
					bool Gz_guard= isGuardTrue( currMatch.arg_1edd, currMatch.enter_1edc, currMatch.state_1eda, currMatch.stateLabel_1edb);
					if( true== Gz_guard)
						_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void TopState_1ec1::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_1ee2= SFC::ConditionalBlock::Create( currMatch.enter_1edc, SFC::Function::meta_stmnt);
		SFC::UserCode newUserCode_1ee3= SFC::UserCode::Create( newConditionalBlock_1ee2, SFC::ConditionalBlock::meta_cond);
		SFC::Return newReturn_1ee4= SFC::Return::Create( newConditionalBlock_1ee2, SFC::ConditionalBlock::meta_stmnt);
		SFC::BinaryExprs newEquals_1ee5= SFC::BinaryExprs::Create( newUserCode_1ee3, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newArgDeclRef_1ee6= SFC::ArgDeclRef::Create( newEquals_1ee5, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newSLArgDeclRef_1ee7= SFC::ArgDeclRef::Create( newEquals_1ee5, SFC::BinaryExprs::meta_rightexpr);
		SFC::Arg& Arg= currMatch.arg_1edd;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_1ee6;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_1ee2;
		SFC::Function& Enter= currMatch.enter_1edc;
		SFC::BinaryExprs& Equals= newEquals_1ee5;
		SFC::Return& Return= newReturn_1ee4;
		SFC::ArgDeclRef& SLArgDeclRef= newSLArgDeclRef_1ee7;
		CyberComposition::Simulink::State& State= currMatch.state_1eda;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_1edb;
		SFC::UserCode& UserCode= newUserCode_1ee3;
		{
ConditionalBlock.RefId() = Return.RefId() = UserCode.RefId() = Enter.RefId();
};
		{
Equals.op() = "==";
};
		{
__int64 statementCount = Enter.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
Enter.statementCount() = statementCount;
};
		{
__int64 statementCount = ConditionalBlock.statementCount();
Return.statementIndex() = statementCount++;
ConditionalBlock.statementCount() = statementCount;
};
		newArgDeclRef_1ee6.argdecl()= currMatch.arg_1edd;
		newSLArgDeclRef_1ee7.argdecl()= currMatch.stateLabel_1edb;
	}
}

void TestEAIOff_1eea::operator()( const Packets_t& states_1eeb, Packets_t& states_1eed, Packets_t& states_1eee)
{
#ifdef PRINT_INFO
	printLog( "TestEAIOff_1eea" );
#endif
	_state_1eef= &states_1eed;
	_state_1ef0= &states_1eee;
	for( Packets_t::const_iterator itstate_1ef2= states_1eeb.begin(); itstate_1ef2!= states_1eeb.end(); ++itstate_1ef2)
	{
		bool isUnique= isInputUnique( *itstate_1ef2);
		if( !isUnique)
			continue;
		Packets_t onestate_1ef6( 1, *itstate_1ef2);
		executeOne( onestate_1ef6);
	}
}

void TestEAIOff_1eea::executeOne( const Packets_t& states_1eeb)
{
	Packets_t states_1efb;
	EAIOff_1ef8 eAIOff_1ef8;
	bool isMatchEAIOff_1ef8= eAIOff_1ef8( states_1eeb, states_1efb);
	_state_1eef->insert( _state_1eef->end(), states_1efb.begin(), states_1efb.end());
	if( isMatchEAIOff_1ef8)
		return;
	Packets_t states_1f23;
	Otherwise_1f20 otherwise_1f20;
	bool isMatchOtherwise_1f20= otherwise_1f20( states_1eeb, states_1f23);
	_state_1ef0->insert( _state_1ef0->end(), states_1f23.begin(), states_1f23.end());
	if( isMatchOtherwise_1f20)
		return;
}

bool TestEAIOff_1eea::isInputUnique( const Udm::Object& state_1ef3)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_1ef5= _state_1ef1.begin(); itstate_1ef5!= _state_1ef1.end(); ++itstate_1ef5)
	{
		if( ( *itstate_1ef5== state_1ef3))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_1ef1.push_back( state_1ef3);
	return isUnique;
}

bool EAIOff_1ef8::operator()( const Packets_t& states_1ef9, Packets_t& states_1efb)
{
#ifdef PRINT_INFO
	printLog( "EAIOff_1ef8" );
#endif
	_state_1efc= &states_1efb;
	processInputPackets( states_1ef9);
	if( false== _matches.empty())
		return true;
	return false;
}

bool EAIOff_1ef8::isInputUnique( const Udm::Object& state_1f01)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1f03= _state_1efd.begin(); itState_1f03!= _state_1efd.end(); ++itState_1f03)
	{
		if( ( *itState_1f03== state_1f01))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_1efd.push_back( state_1f01);
	return isUnique;
}

bool EAIOff_1ef8::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool EAIOff_1ef8::isGuardTrue( CyberComposition::Simulink::ConnectorRef& ConnectorRef, CyberComposition::Simulink::SF_Parameter& Parameter, CyberComposition::Simulink::Primitive& Primitive, CyberComposition::Simulink::State& State, CyberComposition::Simulink::Subsystem& Subsystem)
{
	bool Gz_guard= false;
	return static_cast< std::string >( Parameter.name() ) == "ExecuteAtInitialization" &&
 static_cast< std::string >(  Parameter.Value() ) == "off";;
	return Gz_guard;
}

void EAIOff_1ef8::processInputPackets( const Packets_t& states_1ef9)
{
	for( Packets_t::const_iterator itState_1efe= states_1ef9.begin(); itState_1efe!= states_1ef9.end(); ++itState_1efe)
	{
		bool isUnique= isInputUnique( *itState_1efe);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1efe);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_1f14);
	}
}

bool EAIOff_1ef8::patternMatcher( const Udm::Object& state_1eff)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1eff.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1f04= CyberComposition::Simulink::State::Cast( state_1eff);
		set< CyberComposition::Simulink::ConnectorRef> connectorRefs_1f06= state_1f04.referedbyConnectorRef();
		for( set< CyberComposition::Simulink::ConnectorRef>::const_iterator itConnectorRefs_1f07= connectorRefs_1f06.begin(); itConnectorRefs_1f07!= connectorRefs_1f06.end(); ++itConnectorRefs_1f07)
		{
			CyberComposition::Simulink::ConnectorRef currConnectorRef_1f08= *itConnectorRefs_1f07;
			Udm::Object connectorRefParent_1f09= currConnectorRef_1f08.container();
			if( false== Uml::IsDerivedFrom( connectorRefParent_1f09.type(), CyberComposition::Simulink::Primitive::meta))
				continue;
			CyberComposition::Simulink::Primitive primitiveConnectorRef_1f0a= CyberComposition::Simulink::Primitive::Cast( connectorRefParent_1f09);
			Udm::Object primitiveParent_1f0b= primitiveConnectorRef_1f0a.container();
			if( false== Uml::IsDerivedFrom( primitiveParent_1f0b.type(), CyberComposition::Simulink::Subsystem::meta))
				continue;
			CyberComposition::Simulink::Subsystem subsystemPrimitive_1f0c= CyberComposition::Simulink::Subsystem::Cast( primitiveParent_1f0b);
			set< CyberComposition::Simulink::SF_Parameter> parameters_1f0d= subsystemPrimitive_1f0c.SF_Parameter_kind_children();
			for( set< CyberComposition::Simulink::SF_Parameter>::const_iterator itParameter_1f0e= parameters_1f0d.begin(); itParameter_1f0e!= parameters_1f0d.end(); ++itParameter_1f0e)
			{
				CyberComposition::Simulink::SF_Parameter currParameter_1f0f= *itParameter_1f0e;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_1f13;
				if( !isValidBound(boundObjs_1f13, state_1f04, true))
					continue;
				currMatch.state_1f14= state_1f04;
				if( !isValidBound(boundObjs_1f13, currConnectorRef_1f08, false))
					continue;
				currMatch.connectorRef_1f15= currConnectorRef_1f08;
				if( !isValidBound(boundObjs_1f13, primitiveConnectorRef_1f0a, false))
					continue;
				currMatch.primitive_1f16= primitiveConnectorRef_1f0a;
				if( !isValidBound(boundObjs_1f13, currParameter_1f0f, false))
					continue;
				currMatch.parameter_1f17= currParameter_1f0f;
				if( !isValidBound(boundObjs_1f13, subsystemPrimitive_1f0c, false))
					continue;
				currMatch.subsystem_1f18= subsystemPrimitive_1f0c;
				bool Gz_guard= isGuardTrue( currMatch.connectorRef_1f15, currMatch.parameter_1f17, currMatch.primitive_1f16, currMatch.state_1f14, currMatch.subsystem_1f18);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void EAIOff_1ef8::outputAppender( const CyberComposition::Simulink::State& state_1f1e)
{
	_state_1efc->push_back( state_1f1e);
}

bool Otherwise_1f20::operator()( const Packets_t& states_1f21, Packets_t& states_1f23)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_1f20" );
#endif
	_state_1f24= &states_1f23;
	processInputPackets( states_1f21);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_1f20::isInputUnique( const Udm::Object& state_1f29)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1f2b= _state_1f25.begin(); itState_1f2b!= _state_1f25.end(); ++itState_1f2b)
	{
		if( ( *itState_1f2b== state_1f29))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_1f25.push_back( state_1f29);
	return isUnique;
}

bool Otherwise_1f20::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_1f20::processInputPackets( const Packets_t& states_1f21)
{
	for( Packets_t::const_iterator itState_1f26= states_1f21.begin(); itState_1f26!= states_1f21.end(); ++itState_1f26)
	{
		bool isUnique= isInputUnique( *itState_1f26);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1f26);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_1f32);
	}
}

bool Otherwise_1f20::patternMatcher( const Udm::Object& state_1f27)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1f27.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1f2c= CyberComposition::Simulink::State::Cast( state_1f27);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1f31;
		if( !isValidBound(boundObjs_1f31, state_1f2c, true))
			continue;
		currMatch.state_1f32= state_1f2c;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_1f20::outputAppender( const CyberComposition::Simulink::State& state_1f33)
{
	_state_1f24->push_back( state_1f33);
}

void CreateRootFunction_1f53::operator()( const Packets_t& states_1f54, const Packets_t& programs_1f56, Packets_t& states_1f58, Packets_t& programs_1f59)
{
#ifdef PRINT_INFO
	printLog( "CreateRootFunction_1f53" );
#endif
	_state_1f5a= &states_1f58;
	_program_1f5b= &programs_1f59;
	if( ( !states_1f54.empty())&& ( !programs_1f56.empty()))
		callCreateRootFunction_21ed( states_1f54, programs_1f56);
	_state_1f5a->insert( _state_1f5a->end(), states_1f54.begin(), states_1f54.end());
	_program_1f5b->insert( _program_1f5b->end(), programs_1f56.begin(), programs_1f56.end());
}

void CreateRootFunction_1f53::callCreateRootFunction_21ed( const Packets_t& states_1f83, const Packets_t& programs_1f86)
{
	Packets_t states_1f85;
	Packets_t rootFunctions_1f88;
	CreateRootFunction_1f82 createRootFunction_1f82;
	createRootFunction_1f82( states_1f83, programs_1f86, states_1f85, rootFunctions_1f88);
	if( ( !states_1f85.empty())&& ( !rootFunctions_1f88.empty()))
		callCreateInputArgs_21f0( states_1f85, rootFunctions_1f88);
}

void CreateRootFunction_1f53::callCreateInputArgs_21f0( const Packets_t& states_1fa9, const Packets_t& rootFxns_1fab)
{
	Packets_t states_1fad;
	Packets_t rootFxns_1fae;
	CreateInputArgs_1fa8 createInputArgs_1fa8;
	createInputArgs_1fa8( states_1fa9, rootFxns_1fab, states_1fad, rootFxns_1fae);
	if( ( !states_1fad.empty())&& ( !rootFxns_1fae.empty()))
		callCreateRootExecCall_21f3( states_1fad, rootFxns_1fae);
}

void CreateRootFunction_1f53::callCreateRootExecCall_21f3( const Packets_t& states_1f5d, const Packets_t& rootFunctions_1f60)
{
	Packets_t states_1f5f;
	Packets_t rootFunctions_1f62;
	CreateRootExecCall_1f5c createRootExecCall_1f5c;
	createRootExecCall_1f5c( states_1f5d, rootFunctions_1f60, states_1f5f, rootFunctions_1f62);
	if( ( !states_1f5f.empty())&& ( !rootFunctions_1f62.empty()))
		callCreateOutputArgs_21f6( states_1f5f, rootFunctions_1f62);
}

void CreateRootFunction_1f53::callCreateOutputArgs_21f6( const Packets_t& states_2119, const Packets_t& rootFxns_211b)
{
	Packets_t states_211d;
	Packets_t rootFxns_211e;
	CreateOutputArgs_2118 createOutputArgs_2118;
	createOutputArgs_2118( states_2119, rootFxns_211b, states_211d, rootFxns_211e);
}

void CreateRootExecCall_1f5c::operator()( const Packets_t& states_1f5d, const Packets_t& rootFunctions_1f60, Packets_t& states_1f5f, Packets_t& rootFunctions_1f62)
{
#ifdef PRINT_INFO
	printLog( "CreateRootExecCall_1f5c" );
#endif
	RTTGenerator::Instance()->generateRule(1407, "CreateRootExecCall");
	_state_1f63= &states_1f5f;
	_rootFunction_1f64= &rootFunctions_1f62;
	processInputPackets( states_1f5d, rootFunctions_1f60);
	forwardInputs( );
}

bool CreateRootExecCall_1f5c::isInputUnique( const Udm::Object& state_1f69, const Udm::Object& rootFunction_1f72)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1f6b= _state_1f65.begin(), itRootFunction_1f74= _rootFunction_1f6e.begin(); itState_1f6b!= _state_1f65.end(), itRootFunction_1f74!= _rootFunction_1f6e.end(); ++itState_1f6b, ++itRootFunction_1f74)
	{
		if( ( *itState_1f6b== state_1f69)&& ( *itRootFunction_1f74== rootFunction_1f72))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1f65.push_back( state_1f69);
		_rootFunction_1f6e.push_back( rootFunction_1f72);
	}
	return isUnique;
}

bool CreateRootExecCall_1f5c::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateRootExecCall_1f5c::processInputPackets( const Packets_t& states_1f5d, const Packets_t& rootFunctions_1f60)
{
	for( Packets_t::const_iterator itState_1f66= states_1f5d.begin(), itRootFunction_1f6f= rootFunctions_1f60.begin(); itState_1f66!= states_1f5d.end(), itRootFunction_1f6f!= rootFunctions_1f60.end(); ++itState_1f66, ++itRootFunction_1f6f)
	{
		bool isUnique= isInputUnique( *itState_1f66, *itRootFunction_1f6f);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1f66, *itRootFunction_1f6f);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateRootExecCall_1f5c::patternMatcher( const Udm::Object& state_1f67, const Udm::Object& rootFunction_1f70)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1f67.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1f6c= CyberComposition::Simulink::State::Cast( state_1f67);
		if( false== Uml::IsDerivedFrom( rootFunction_1f70.type(), SFC::Function::meta))
			continue;
		SFC::Function rootFunction_1f75= SFC::Function::Cast( rootFunction_1f70);
		set< SFC::Function> execs_1f77= state_1f6c.exec();
		for( set< SFC::Function>::const_iterator itExecs_1f78= execs_1f77.begin(); itExecs_1f78!= execs_1f77.end(); ++itExecs_1f78)
		{
			SFC::Function currExec_1f79= *itExecs_1f78;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1f7d;
			if( !isValidBound(boundObjs_1f7d, state_1f6c, true))
				continue;
			currMatch.state_1f7e= state_1f6c;
			if( !isValidBound(boundObjs_1f7d, rootFunction_1f75, true))
				continue;
			currMatch.rootFunction_1f7f= rootFunction_1f75;
			if( !isValidBound(boundObjs_1f7d, currExec_1f79, false))
				continue;
			currMatch.exec_1f80= currExec_1f79;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateRootExecCall_1f5c::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::FunctionCall newFunctionCall_1f81= SFC::FunctionCall::Create( currMatch.rootFunction_1f7f, SFC::Function::meta_stmnt);
		SFC::Function& Exec= currMatch.exec_1f80;
		SFC::FunctionCall& FunctionCall= newFunctionCall_1f81;
		SFC::Function& RootFunction= currMatch.rootFunction_1f7f;
		CyberComposition::Simulink::State& State= currMatch.state_1f7e;
		{
FunctionCall.RefId() = RootFunction.RefId();
};
		{
__int64 statementCount = RootFunction.statementCount();
FunctionCall.statementIndex() = statementCount++;
RootFunction.statementCount() = statementCount;
};
		newFunctionCall_1f81.callee()= currMatch.exec_1f80;
	}
}

void CreateRootExecCall_1f5c::forwardInputs()
{
	*_state_1f63= _state_1f65;
	*_rootFunction_1f64= _rootFunction_1f6e;
}

void CreateRootFunction_1f82::operator()( const Packets_t& states_1f83, const Packets_t& programs_1f86, Packets_t& states_1f85, Packets_t& rootFunctions_1f88)
{
#ifdef PRINT_INFO
	printLog( "CreateRootFunction_1f82" );
#endif
	RTTGenerator::Instance()->generateRule(1417, "CreateRootFunction");
	_state_1f89= &states_1f85;
	_rootFunction_1f8a= &rootFunctions_1f88;
	processInputPackets( states_1f83, programs_1f86);
}

bool CreateRootFunction_1f82::isInputUnique( const Udm::Object& state_1f8f, const Udm::Object& program_1f98)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1f91= _state_1f8b.begin(), itProgram_1f9a= _program_1f94.begin(); itState_1f91!= _state_1f8b.end(), itProgram_1f9a!= _program_1f94.end(); ++itState_1f91, ++itProgram_1f9a)
	{
		if( ( *itState_1f91== state_1f8f)&& ( *itProgram_1f9a== program_1f98))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1f8b.push_back( state_1f8f);
		_program_1f94.push_back( program_1f98);
	}
	return isUnique;
}

bool CreateRootFunction_1f82::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateRootFunction_1f82::processInputPackets( const Packets_t& states_1f83, const Packets_t& programs_1f86)
{
	for( Packets_t::const_iterator itState_1f8c= states_1f83.begin(), itProgram_1f95= programs_1f86.begin(); itState_1f8c!= states_1f83.end(), itProgram_1f95!= programs_1f86.end(); ++itState_1f8c, ++itProgram_1f95)
	{
		bool isUnique= isInputUnique( *itState_1f8c, *itProgram_1f95);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1f8c, *itProgram_1f95);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateRootFunction_1f82::patternMatcher( const Udm::Object& state_1f8d, const Udm::Object& program_1f96)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1f8d.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1f92= CyberComposition::Simulink::State::Cast( state_1f8d);
		if( false== Uml::IsDerivedFrom( program_1f96.type(), SFC::Program::meta))
			continue;
		SFC::Program program_1f9b= SFC::Program::Cast( program_1f96);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1fa0;
		if( !isValidBound(boundObjs_1fa0, state_1f92, true))
			continue;
		currMatch.state_1fa1= state_1f92;
		if( !isValidBound(boundObjs_1fa0, program_1f9b, true))
			continue;
		currMatch.program_1fa2= program_1f9b;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateRootFunction_1f82::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function newRootFunction_1fa3= SFC::Function::Create( currMatch.program_1fa2);
		SFC::Program& Program= currMatch.program_1fa2;
		SFC::Function& RootFunction= newRootFunction_1fa3;
		CyberComposition::Simulink::State& State= currMatch.state_1fa1;
		{
RootFunction.RefId() = State.RefId();
};
		{
RootFunction.name() = static_cast< std::string >( State.name() ) + "_main";
};
		{
__int64 statementCount = Program.statementCount();
RootFunction.statementIndex() = statementCount++;
Program.statementCount() = statementCount;
};
		outputAppender( currMatch.state_1fa1, newRootFunction_1fa3);
	}
}

void CreateRootFunction_1f82::outputAppender( const CyberComposition::Simulink::State& state_1fa4, const SFC::Function& rootFunction_1fa6)
{
	_state_1f89->push_back( state_1fa4);
	_rootFunction_1f8a->push_back( rootFunction_1fa6);
}

void CreateInputArgs_1fa8::operator()( const Packets_t& states_1fa9, const Packets_t& rootFxns_1fab, Packets_t& states_1fad, Packets_t& rootFxns_1fae)
{
#ifdef PRINT_INFO
	printLog( "CreateInputArgs_1fa8" );
#endif
	_state_1faf= &states_1fad;
	_rootFxn_1fb0= &rootFxns_1fae;
	_state_1faf->insert( _state_1faf->end(), states_1fa9.begin(), states_1fa9.end());
	_rootFxn_1fb0->insert( _rootFxn_1fb0->end(), rootFxns_1fab.begin(), rootFxns_1fab.end());
	if( ( !states_1fa9.empty())&& ( !rootFxns_1fab.empty()))
		callCheckStateDecomp_2109( states_1fa9, rootFxns_1fab);
}

void CreateInputArgs_1fa8::callCheckStateDecomp_2109( const Packets_t& states_20a3, const Packets_t& programs_20a5)
{
	Packets_t states_20a7;
	Packets_t programs_20a8;
	Packets_t states_20a9;
	Packets_t programs_20aa;
	CheckStateDecomp_20a2 checkStateDecomp_20a2;
	checkStateDecomp_20a2( states_20a3, programs_20a5, states_20a7, programs_20a8, states_20a9, programs_20aa);
	if( ( !states_20a7.empty())&& ( !programs_20a8.empty()))
		callGetSubStates_210c( states_20a7, programs_20a8);
	if( ( !states_20a9.empty())&& ( !programs_20aa.empty()))
		callCreateIDArgs_210f( states_20a9, programs_20aa);
}

void CreateInputArgs_1fa8::callGetSubStates_210c( const Packets_t& states_c8c, const Packets_t& parStmnts_c8f)
{
	Packets_t subStates_c8e;
	Packets_t parStmnts_c91;
	GetSubStates_c8b getSubStates_c8b;
	getSubStates_c8b( states_c8c, parStmnts_c8f, subStates_c8e, parStmnts_c91);
	if( ( !subStates_c8e.empty())&& ( !parStmnts_c91.empty()))
		callCheckStateDecomp_2109( subStates_c8e, parStmnts_c91);
}

void CreateInputArgs_1fa8::callCreateIDArgs_210f( const Packets_t& states_1fe3, const Packets_t& rootFxns_1fe5)
{
	Packets_t states_1fe7;
	Packets_t rootFxns_1fe8;
	CreateIDArgs_1fe2 createIDArgs_1fe2;
	createIDArgs_1fe2( states_1fe3, rootFxns_1fe5, states_1fe7, rootFxns_1fe8);
	if( ( !states_1fe7.empty())&& ( !rootFxns_1fe8.empty()))
		callCreateIEArgs_2112( states_1fe7, rootFxns_1fe8);
}

void CreateInputArgs_1fa8::callCreateIEArgs_2112( const Packets_t& states_2043, const Packets_t& rootFxns_2045)
{
	Packets_t states_2047;
	Packets_t rootFxns_2048;
	CreateIEArgs_2042 createIEArgs_2042;
	createIEArgs_2042( states_2043, rootFxns_2045, states_2047, rootFxns_2048);
	if( ( !states_2047.empty())&& ( !rootFxns_2048.empty()))
		callCreateLEInit_2115( states_2047, rootFxns_2048);
}

void CreateInputArgs_1fa8::callCreateLEInit_2115( const Packets_t& states_1fb2, const Packets_t& rootFunctions_1fb5)
{
	Packets_t states_1fb4;
	Packets_t rootFunctions_1fb7;
	CreateLEInit_1fb1 createLEInit_1fb1;
	createLEInit_1fb1( states_1fb2, rootFunctions_1fb5, states_1fb4, rootFunctions_1fb7);
	if( ( !states_1fb4.empty())&& ( !rootFunctions_1fb7.empty()))
		callGetSubStates_210c( states_1fb4, rootFunctions_1fb7);
}

void CreateLEInit_1fb1::operator()( const Packets_t& states_1fb2, const Packets_t& rootFunctions_1fb5, Packets_t& states_1fb4, Packets_t& rootFunctions_1fb7)
{
#ifdef PRINT_INFO
	printLog( "CreateLEInit_1fb1" );
#endif
	RTTGenerator::Instance()->generateRule(1430, "CreateLEInit");
	_state_1fb8= &states_1fb4;
	_rootFunction_1fb9= &rootFunctions_1fb7;
	processInputPackets( states_1fb2, rootFunctions_1fb5);
	forwardInputs( );
}

bool CreateLEInit_1fb1::isInputUnique( const Udm::Object& state_1fbe, const Udm::Object& rootFunction_1fc7)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1fc0= _state_1fba.begin(), itRootFunction_1fc9= _rootFunction_1fc3.begin(); itState_1fc0!= _state_1fba.end(), itRootFunction_1fc9!= _rootFunction_1fc3.end(); ++itState_1fc0, ++itRootFunction_1fc9)
	{
		if( ( *itState_1fc0== state_1fbe)&& ( *itRootFunction_1fc9== rootFunction_1fc7))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1fba.push_back( state_1fbe);
		_rootFunction_1fc3.push_back( rootFunction_1fc7);
	}
	return isUnique;
}

bool CreateLEInit_1fb1::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool CreateLEInit_1fb1::isGuardTrue( CyberComposition::Simulink::Event& Event, SFC::LocalVar& LocalVar, SFC::Function& RootFunction, CyberComposition::Simulink::State& State)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( Event.Scope() ) == "LOCAL_EVENT";;
	return Gz_guard;
}

void CreateLEInit_1fb1::processInputPackets( const Packets_t& states_1fb2, const Packets_t& rootFunctions_1fb5)
{
	for( Packets_t::const_iterator itState_1fbb= states_1fb2.begin(), itRootFunction_1fc4= rootFunctions_1fb5.begin(); itState_1fbb!= states_1fb2.end(), itRootFunction_1fc4!= rootFunctions_1fb5.end(); ++itState_1fbb, ++itRootFunction_1fc4)
	{
		bool isUnique= isInputUnique( *itState_1fbb, *itRootFunction_1fc4);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1fbb, *itRootFunction_1fc4);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateLEInit_1fb1::patternMatcher( const Udm::Object& state_1fbc, const Udm::Object& rootFunction_1fc5)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1fbc.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1fc1= CyberComposition::Simulink::State::Cast( state_1fbc);
		if( false== Uml::IsDerivedFrom( rootFunction_1fc5.type(), SFC::Function::meta))
			continue;
		SFC::Function rootFunction_1fca= SFC::Function::Cast( rootFunction_1fc5);
		set< CyberComposition::Simulink::Event> events_1fcc= state_1fc1.Event_kind_children();
		for( set< CyberComposition::Simulink::Event>::const_iterator itEvent_1fcd= events_1fcc.begin(); itEvent_1fcd!= events_1fcc.end(); ++itEvent_1fcd)
		{
			CyberComposition::Simulink::Event currEvent_1fce= *itEvent_1fcd;
			set< SFC::LocalVar> localVars_1fcf= currEvent_1fce.src();
			for( set< SFC::LocalVar>::const_iterator itLocalVars_1fd0= localVars_1fcf.begin(); itLocalVars_1fd0!= localVars_1fcf.end(); ++itLocalVars_1fd0)
			{
				SFC::LocalVar currLocalVar_1fd1= *itLocalVars_1fd0;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_1fd5;
				if( !isValidBound(boundObjs_1fd5, state_1fc1, true))
					continue;
				currMatch.state_1fd6= state_1fc1;
				if( !isValidBound(boundObjs_1fd5, rootFunction_1fca, true))
					continue;
				currMatch.rootFunction_1fd7= rootFunction_1fca;
				if( !isValidBound(boundObjs_1fd5, currEvent_1fce, false))
					continue;
				currMatch.event_1fd8= currEvent_1fce;
				if( !isValidBound(boundObjs_1fd5, currLocalVar_1fd1, false))
					continue;
				currMatch.localVar_1fd9= currLocalVar_1fd1;
				bool Gz_guard= isGuardTrue( currMatch.event_1fd8, currMatch.localVar_1fd9, currMatch.rootFunction_1fd7, currMatch.state_1fd6);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void CreateLEInit_1fb1::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newInitEventCode_1fde= SFC::UserCode::Create( currMatch.rootFunction_1fd7, SFC::Function::meta_stmnt);
		SFC::BinaryExprs newBinaryExprs_1fdf= SFC::BinaryExprs::Create( newInitEventCode_1fde, SFC::UserCode::meta_codeexpr);
		SFC::Int newInt_1fe0= SFC::Int::Create( newBinaryExprs_1fdf, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_1fe1= SFC::ArgDeclRef::Create( newBinaryExprs_1fdf, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_1fe1;
		SFC::BinaryExprs& BinaryExprs= newBinaryExprs_1fdf;
		CyberComposition::Simulink::Event& Event= currMatch.event_1fd8;
		SFC::UserCode& InitEventCode= newInitEventCode_1fde;
		SFC::Int& Int= newInt_1fe0;
		SFC::LocalVar& LocalVar= currMatch.localVar_1fd9;
		SFC::Function& RootFunction= currMatch.rootFunction_1fd7;
		CyberComposition::Simulink::State& State= currMatch.state_1fd6;
		{
InitEventCode.RefId() = RootFunction.RefId();
};
		{
__int64 statementCount = RootFunction.statementCount();
InitEventCode.statementIndex() = statementCount++;
RootFunction.statementCount() = statementCount;
};
		{
Int.val() = 0;
};
		{
BinaryExprs.op() = "=";
};
		newArgDeclRef_1fe1.argdecl()= currMatch.localVar_1fd9;
	}
}

void CreateLEInit_1fb1::forwardInputs()
{
	*_state_1fb8= _state_1fba;
	*_rootFunction_1fb9= _rootFunction_1fc3;
}

void CreateIDArgs_1fe2::operator()( const Packets_t& states_1fe3, const Packets_t& rootFxns_1fe5, Packets_t& states_1fe7, Packets_t& rootFxns_1fe8)
{
#ifdef PRINT_INFO
	printLog( "CreateIDArgs_1fe2" );
#endif
	_state_1fe9= &states_1fe7;
	_rootFxn_1fea= &rootFxns_1fe8;
	_state_1fe9->insert( _state_1fe9->end(), states_1fe3.begin(), states_1fe3.end());
	_rootFxn_1fea->insert( _rootFxn_1fea->end(), rootFxns_1fe5.begin(), rootFxns_1fe5.end());
	if( ( !states_1fe3.empty())&& ( !rootFxns_1fe5.empty()))
		callGetInData_203c( states_1fe3, rootFxns_1fe5);
}

void CreateIDArgs_1fe2::callGetInData_203c( const Packets_t& states_2012, const Packets_t& rootFunctions_2014)
{
	Packets_t datas_2011;
	Packets_t rootFunctions_2016;
	GetInData_2010 getInData_2010;
	getInData_2010( states_2012, rootFunctions_2014, datas_2011, rootFunctions_2016);
	if( ( !datas_2011.empty())&& ( !rootFunctions_2016.empty()))
		callCreateIDArg_203f( datas_2011, rootFunctions_2016);
}

void CreateIDArgs_1fe2::callCreateIDArg_203f( const Packets_t& datas_1fec, const Packets_t& rootFunctions_1fee)
{
	CreateIDArg_1feb createIDArg_1feb;
	createIDArg_1feb( datas_1fec, rootFunctions_1fee);
}

void CreateIDArg_1feb::operator()( const Packets_t& datas_1fec, const Packets_t& rootFunctions_1fee)
{
#ifdef PRINT_INFO
	printLog( "CreateIDArg_1feb" );
#endif
	RTTGenerator::Instance()->generateRule(1455, "CreateIDArg");
	processInputPackets( datas_1fec, rootFunctions_1fee);
}

bool CreateIDArg_1feb::isInputUnique( const Udm::Object& data_1ff4, const Udm::Object& rootFunction_1ffd)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itData_1ff6= _data_1ff0.begin(), itRootFunction_1fff= _rootFunction_1ff9.begin(); itData_1ff6!= _data_1ff0.end(), itRootFunction_1fff!= _rootFunction_1ff9.end(); ++itData_1ff6, ++itRootFunction_1fff)
	{
		if( ( *itData_1ff6== data_1ff4)&& ( *itRootFunction_1fff== rootFunction_1ffd))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_data_1ff0.push_back( data_1ff4);
		_rootFunction_1ff9.push_back( rootFunction_1ffd);
	}
	return isUnique;
}

bool CreateIDArg_1feb::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateIDArg_1feb::processInputPackets( const Packets_t& datas_1fec, const Packets_t& rootFunctions_1fee)
{
	for( Packets_t::const_iterator itData_1ff1= datas_1fec.begin(), itRootFunction_1ffa= rootFunctions_1fee.begin(); itData_1ff1!= datas_1fec.end(), itRootFunction_1ffa!= rootFunctions_1fee.end(); ++itData_1ff1, ++itRootFunction_1ffa)
	{
		bool isUnique= isInputUnique( *itData_1ff1, *itRootFunction_1ffa);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itData_1ff1, *itRootFunction_1ffa);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateIDArg_1feb::patternMatcher( const Udm::Object& data_1ff2, const Udm::Object& rootFunction_1ffb)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( data_1ff2.type(), CyberComposition::Simulink::Data::meta))
			continue;
		CyberComposition::Simulink::Data data_1ff7= CyberComposition::Simulink::Data::Cast( data_1ff2);
		if( false== Uml::IsDerivedFrom( rootFunction_1ffb.type(), SFC::Function::meta))
			continue;
		SFC::Function rootFunction_2000= SFC::Function::Cast( rootFunction_1ffb);
		set< SFC::LocalVar> localVars_2002= data_1ff7.src();
		for( set< SFC::LocalVar>::const_iterator itLocalVars_2003= localVars_2002.begin(); itLocalVars_2003!= localVars_2002.end(); ++itLocalVars_2003)
		{
			SFC::LocalVar currLocalVar_2004= *itLocalVars_2003;
			SFC::DT dT_2005= currLocalVar_2004.dt();
			if( !dT_2005)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2009;
			if( !isValidBound(boundObjs_2009, data_1ff7, true))
				continue;
			currMatch.data_200a= data_1ff7;
			if( !isValidBound(boundObjs_2009, rootFunction_2000, true))
				continue;
			currMatch.rootFunction_200b= rootFunction_2000;
			if( !isValidBound(boundObjs_2009, currLocalVar_2004, false))
				continue;
			currMatch.localVar_200c= currLocalVar_2004;
			if( !isValidBound(boundObjs_2009, dT_2005, false))
				continue;
			currMatch.dT_200d= dT_2005;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateIDArg_1feb::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg newArg_200e= SFC::Arg::Create( currMatch.rootFunction_200b);
		SFC::SetVar newSetVar_200f= SFC::SetVar::Create( currMatch.rootFunction_200b);
		SFC::Arg& Arg= newArg_200e;
		SFC::DT& DT= currMatch.dT_200d;
		CyberComposition::Simulink::Data& Data= currMatch.data_200a;
		SFC::LocalVar& LocalVar= currMatch.localVar_200c;
		SFC::Function& RootFunction= currMatch.rootFunction_200b;
		SFC::SetVar& SetVar= newSetVar_200f;
		{
Arg.RefId() = SetVar.RefId() = LocalVar.RefId();
};
		{
Arg.name() = static_cast< std::string >( Data.Name() ) + "_";
Arg.indexBase() = Data.ArrayFirstIndex();
};
		{
__int64 argCount = RootFunction.argCount();
Arg.argIndex() = argCount++;
RootFunction.argCount() = argCount;
};
		{
__int64 statementCount = RootFunction.statementCount();
SetVar.statementIndex() = statementCount++;
RootFunction.statementCount() = statementCount;
};
		newArg_200e.dt()= currMatch.dT_200d;
		newSetVar_200f.arg_end()= newArg_200e;
		newSetVar_200f.lvar_end()= currMatch.localVar_200c;
	}
}

void GetInData_2010::operator()( const Packets_t& states_2012, const Packets_t& rootFunctions_2014, Packets_t& datas_2011, Packets_t& rootFunctions_2016)
{
#ifdef PRINT_INFO
	printLog( "GetInData_2010" );
#endif
	RTTGenerator::Instance()->generateRule(1473, "GetInData");
	_data_2017= &datas_2011;
	_rootFunction_2018= &rootFunctions_2016;
	processInputPackets( states_2012, rootFunctions_2014);
	sortOutputs( );
}

bool GetInData_2010::isInputUnique( const Udm::Object& state_201d, const Udm::Object& rootFunction_2026)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_201f= _state_2019.begin(), itRootFunction_2028= _rootFunction_2022.begin(); itState_201f!= _state_2019.end(), itRootFunction_2028!= _rootFunction_2022.end(); ++itState_201f, ++itRootFunction_2028)
	{
		if( ( *itState_201f== state_201d)&& ( *itRootFunction_2028== rootFunction_2026))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_2019.push_back( state_201d);
		_rootFunction_2022.push_back( rootFunction_2026);
	}
	return isUnique;
}

bool GetInData_2010::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool GetInData_2010::isGuardTrue( CyberComposition::Simulink::Data& Data, SFC::Function& RootFunction, CyberComposition::Simulink::State& State)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( Data.Scope() ) == "INPUT_DATA";;
	return Gz_guard;
}

void GetInData_2010::processInputPackets( const Packets_t& states_2012, const Packets_t& rootFunctions_2014)
{
	for( Packets_t::const_iterator itState_201a= states_2012.begin(), itRootFunction_2023= rootFunctions_2014.begin(); itState_201a!= states_2012.end(), itRootFunction_2023!= rootFunctions_2014.end(); ++itState_201a, ++itRootFunction_2023)
	{
		bool isUnique= isInputUnique( *itState_201a, *itRootFunction_2023);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_201a, *itRootFunction_2023);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetInData_2010::patternMatcher( const Udm::Object& state_201b, const Udm::Object& rootFunction_2024)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_201b.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_2020= CyberComposition::Simulink::State::Cast( state_201b);
		if( false== Uml::IsDerivedFrom( rootFunction_2024.type(), SFC::Function::meta))
			continue;
		SFC::Function rootFunction_2029= SFC::Function::Cast( rootFunction_2024);
		set< CyberComposition::Simulink::Data> datas_202b= state_2020.Data_kind_children();
		for( set< CyberComposition::Simulink::Data>::const_iterator itData_202c= datas_202b.begin(); itData_202c!= datas_202b.end(); ++itData_202c)
		{
			CyberComposition::Simulink::Data currData_202d= *itData_202c;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2031;
			if( !isValidBound(boundObjs_2031, state_2020, true))
				continue;
			currMatch.state_2032= state_2020;
			if( !isValidBound(boundObjs_2031, rootFunction_2029, true))
				continue;
			currMatch.rootFunction_2033= rootFunction_2029;
			if( !isValidBound(boundObjs_2031, currData_202d, false))
				continue;
			currMatch.data_2034= currData_202d;
			bool Gz_guard= isGuardTrue( currMatch.data_2034, currMatch.rootFunction_2033, currMatch.state_2032);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetInData_2010::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.data_2034, currMatch.rootFunction_2033);
	}
}

void GetInData_2010::outputAppender( const CyberComposition::Simulink::Data& data_2038, const SFC::Function& rootFunction_203a)
{
	_data_2017->push_back( data_2038);
	_rootFunction_2018->push_back( rootFunction_203a);
}

void GetInData_2010::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::Data, std::pointer_to_binary_function< const CyberComposition::Simulink::Data&, const CyberComposition::Simulink::Data&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::Data&, const CyberComposition::Simulink::Data&, bool> ptr_DEOrder( DEOrder< CyberComposition::Simulink::Data>);
	SortedSet_t sortedSet( ptr_DEOrder);
	std::vector< int> permutationVector( _data_2017->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _data_2017->begin(); it!= _data_2017->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::Data::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _data_2017->begin());
	// order rest of the containers
	permutate( permutationVector, *_rootFunction_2018);
}

void CreateIEArgs_2042::operator()( const Packets_t& states_2043, const Packets_t& rootFxns_2045, Packets_t& states_2047, Packets_t& rootFxns_2048)
{
#ifdef PRINT_INFO
	printLog( "CreateIEArgs_2042" );
#endif
	_state_2049= &states_2047;
	_rootFxn_204a= &rootFxns_2048;
	_state_2049->insert( _state_2049->end(), states_2043.begin(), states_2043.end());
	_rootFxn_204a->insert( _rootFxn_204a->end(), rootFxns_2045.begin(), rootFxns_2045.end());
	if( ( !states_2043.empty())&& ( !rootFxns_2045.empty()))
		callGetInEvent_209c( states_2043, rootFxns_2045);
}

void CreateIEArgs_2042::callGetInEvent_209c( const Packets_t& states_2071, const Packets_t& rootFunctions_2074)
{
	Packets_t events_2073;
	Packets_t rootFunctions_2076;
	GetInEvent_2070 getInEvent_2070;
	getInEvent_2070( states_2071, rootFunctions_2074, events_2073, rootFunctions_2076);
	if( ( !events_2073.empty())&& ( !rootFunctions_2076.empty()))
		callCreateIEArg_209f( events_2073, rootFunctions_2076);
}

void CreateIEArgs_2042::callCreateIEArg_209f( const Packets_t& events_204c, const Packets_t& rootFunctions_204e)
{
	CreateIEArg_204b createIEArg_204b;
	createIEArg_204b( events_204c, rootFunctions_204e);
}

void CreateIEArg_204b::operator()( const Packets_t& events_204c, const Packets_t& rootFunctions_204e)
{
#ifdef PRINT_INFO
	printLog( "CreateIEArg_204b" );
#endif
	RTTGenerator::Instance()->generateRule(1483, "CreateIEArg");
	processInputPackets( events_204c, rootFunctions_204e);
}

bool CreateIEArg_204b::isInputUnique( const Udm::Object& event_2054, const Udm::Object& rootFunction_205d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itEvent_2056= _event_2050.begin(), itRootFunction_205f= _rootFunction_2059.begin(); itEvent_2056!= _event_2050.end(), itRootFunction_205f!= _rootFunction_2059.end(); ++itEvent_2056, ++itRootFunction_205f)
	{
		if( ( *itEvent_2056== event_2054)&& ( *itRootFunction_205f== rootFunction_205d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_event_2050.push_back( event_2054);
		_rootFunction_2059.push_back( rootFunction_205d);
	}
	return isUnique;
}

bool CreateIEArg_204b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateIEArg_204b::processInputPackets( const Packets_t& events_204c, const Packets_t& rootFunctions_204e)
{
	for( Packets_t::const_iterator itEvent_2051= events_204c.begin(), itRootFunction_205a= rootFunctions_204e.begin(); itEvent_2051!= events_204c.end(), itRootFunction_205a!= rootFunctions_204e.end(); ++itEvent_2051, ++itRootFunction_205a)
	{
		bool isUnique= isInputUnique( *itEvent_2051, *itRootFunction_205a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itEvent_2051, *itRootFunction_205a);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateIEArg_204b::patternMatcher( const Udm::Object& event_2052, const Udm::Object& rootFunction_205b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( event_2052.type(), CyberComposition::Simulink::Event::meta))
			continue;
		CyberComposition::Simulink::Event event_2057= CyberComposition::Simulink::Event::Cast( event_2052);
		if( false== Uml::IsDerivedFrom( rootFunction_205b.type(), SFC::Function::meta))
			continue;
		SFC::Function rootFunction_2060= SFC::Function::Cast( rootFunction_205b);
		set< SFC::LocalVar> localVars_2062= event_2057.src();
		for( set< SFC::LocalVar>::const_iterator itLocalVars_2063= localVars_2062.begin(); itLocalVars_2063!= localVars_2062.end(); ++itLocalVars_2063)
		{
			SFC::LocalVar currLocalVar_2064= *itLocalVars_2063;
			SFC::DT dT_2065= currLocalVar_2064.dt();
			if( !dT_2065)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2069;
			if( !isValidBound(boundObjs_2069, event_2057, true))
				continue;
			currMatch.event_206a= event_2057;
			if( !isValidBound(boundObjs_2069, rootFunction_2060, true))
				continue;
			currMatch.rootFunction_206b= rootFunction_2060;
			if( !isValidBound(boundObjs_2069, currLocalVar_2064, false))
				continue;
			currMatch.localVar_206c= currLocalVar_2064;
			if( !isValidBound(boundObjs_2069, dT_2065, false))
				continue;
			currMatch.dT_206d= dT_2065;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateIEArg_204b::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg newArg_206e= SFC::Arg::Create( currMatch.rootFunction_206b);
		SFC::SetVar newSetVar_206f= SFC::SetVar::Create( currMatch.rootFunction_206b);
		SFC::Arg& Arg= newArg_206e;
		SFC::DT& DT= currMatch.dT_206d;
		CyberComposition::Simulink::Event& Event= currMatch.event_206a;
		SFC::LocalVar& LocalVar= currMatch.localVar_206c;
		SFC::Function& RootFunction= currMatch.rootFunction_206b;
		SFC::SetVar& SetVar= newSetVar_206f;
		{
Arg.RefId() = SetVar.RefId() = LocalVar.RefId();
};
		{
Arg.name() = static_cast< std::string >( Event.Name() ) + "_";

};
		{
__int64 statementCount = RootFunction.statementCount();
SetVar.statementIndex() = statementCount++;
RootFunction.statementCount() = statementCount;
};
		{
__int64 argCount = RootFunction.argCount();
Arg.argIndex() = argCount++;
RootFunction.argCount() = argCount;
};
		newArg_206e.dt()= currMatch.dT_206d;
		newSetVar_206f.arg_end()= newArg_206e;
		newSetVar_206f.lvar_end()= currMatch.localVar_206c;
	}
}

void GetInEvent_2070::operator()( const Packets_t& states_2071, const Packets_t& rootFunctions_2074, Packets_t& events_2073, Packets_t& rootFunctions_2076)
{
#ifdef PRINT_INFO
	printLog( "GetInEvent_2070" );
#endif
	RTTGenerator::Instance()->generateRule(1501, "GetInEvent");
	_event_2077= &events_2073;
	_rootFunction_2078= &rootFunctions_2076;
	processInputPackets( states_2071, rootFunctions_2074);
	sortOutputs( );
}

bool GetInEvent_2070::isInputUnique( const Udm::Object& state_207d, const Udm::Object& rootFunction_2086)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_207f= _state_2079.begin(), itRootFunction_2088= _rootFunction_2082.begin(); itState_207f!= _state_2079.end(), itRootFunction_2088!= _rootFunction_2082.end(); ++itState_207f, ++itRootFunction_2088)
	{
		if( ( *itState_207f== state_207d)&& ( *itRootFunction_2088== rootFunction_2086))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_2079.push_back( state_207d);
		_rootFunction_2082.push_back( rootFunction_2086);
	}
	return isUnique;
}

bool GetInEvent_2070::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool GetInEvent_2070::isGuardTrue( CyberComposition::Simulink::Event& Event, SFC::Function& RootFunction, CyberComposition::Simulink::State& State)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( Event.Scope() ) == "INPUT_EVENT";;
	return Gz_guard;
}

void GetInEvent_2070::processInputPackets( const Packets_t& states_2071, const Packets_t& rootFunctions_2074)
{
	for( Packets_t::const_iterator itState_207a= states_2071.begin(), itRootFunction_2083= rootFunctions_2074.begin(); itState_207a!= states_2071.end(), itRootFunction_2083!= rootFunctions_2074.end(); ++itState_207a, ++itRootFunction_2083)
	{
		bool isUnique= isInputUnique( *itState_207a, *itRootFunction_2083);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_207a, *itRootFunction_2083);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetInEvent_2070::patternMatcher( const Udm::Object& state_207b, const Udm::Object& rootFunction_2084)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_207b.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_2080= CyberComposition::Simulink::State::Cast( state_207b);
		if( false== Uml::IsDerivedFrom( rootFunction_2084.type(), SFC::Function::meta))
			continue;
		SFC::Function rootFunction_2089= SFC::Function::Cast( rootFunction_2084);
		set< CyberComposition::Simulink::Event> events_208b= state_2080.Event_kind_children();
		for( set< CyberComposition::Simulink::Event>::const_iterator itEvent_208c= events_208b.begin(); itEvent_208c!= events_208b.end(); ++itEvent_208c)
		{
			CyberComposition::Simulink::Event currEvent_208d= *itEvent_208c;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2091;
			if( !isValidBound(boundObjs_2091, state_2080, true))
				continue;
			currMatch.state_2092= state_2080;
			if( !isValidBound(boundObjs_2091, rootFunction_2089, true))
				continue;
			currMatch.rootFunction_2093= rootFunction_2089;
			if( !isValidBound(boundObjs_2091, currEvent_208d, false))
				continue;
			currMatch.event_2094= currEvent_208d;
			bool Gz_guard= isGuardTrue( currMatch.event_2094, currMatch.rootFunction_2093, currMatch.state_2092);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetInEvent_2070::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.event_2094, currMatch.rootFunction_2093);
	}
}

void GetInEvent_2070::outputAppender( const CyberComposition::Simulink::Event& event_2098, const SFC::Function& rootFunction_209a)
{
	_event_2077->push_back( event_2098);
	_rootFunction_2078->push_back( rootFunction_209a);
}

void GetInEvent_2070::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::Event, std::pointer_to_binary_function< const CyberComposition::Simulink::Event&, const CyberComposition::Simulink::Event&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::Event&, const CyberComposition::Simulink::Event&, bool> ptr_DEOrder( DEOrder< CyberComposition::Simulink::Event>);
	SortedSet_t sortedSet( ptr_DEOrder);
	std::vector< int> permutationVector( _event_2077->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _event_2077->begin(); it!= _event_2077->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::Event::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _event_2077->begin());
	// order rest of the containers
	permutate( permutationVector, *_rootFunction_2078);
}

void CheckStateDecomp_20a2::operator()( const Packets_t& states_20a3, const Packets_t& programs_20a5, Packets_t& states_20a7, Packets_t& programs_20a8, Packets_t& states_20a9, Packets_t& programs_20aa)
{
#ifdef PRINT_INFO
	printLog( "CheckStateDecomp_20a2" );
#endif
	_state_20ab= &states_20a7;
	_program_20ac= &programs_20a8;
	_state_20ad= &states_20a9;
	_program_20ae= &programs_20aa;
	for( Packets_t::const_iterator itstate_20b0= states_20a3.begin(), itprogram_20b7= programs_20a5.begin(); itstate_20b0!= states_20a3.end(), itprogram_20b7!= programs_20a5.end(); ++itstate_20b0, ++itprogram_20b7)
	{
		bool isUnique= isInputUnique( *itstate_20b0, *itprogram_20b7);
		if( !isUnique)
			continue;
		Packets_t onestate_20b4( 1, *itstate_20b0);
		Packets_t oneprogram_20bb( 1, *itprogram_20b7);
		executeOne( onestate_20b4, oneprogram_20bb);
	}
}

void CheckStateDecomp_20a2::executeOne( const Packets_t& states_20a3, const Packets_t& programs_20a5)
{
	Packets_t states_20c0;
	Packets_t programs_20c3;
	IsFuncState_20bd isFuncState_20bd;
	bool isMatchIsFuncState_20bd= isFuncState_20bd( states_20a3, programs_20a5, states_20c0, programs_20c3);
	_state_20ab->insert( _state_20ab->end(), states_20c0.begin(), states_20c0.end());
	_program_20ac->insert( _program_20ac->end(), programs_20c3.begin(), programs_20c3.end());
	if( isMatchIsFuncState_20bd)
		return;
	Packets_t states_20e7;
	Packets_t programs_20ea;
	Otherwise_20e4 otherwise_20e4;
	bool isMatchOtherwise_20e4= otherwise_20e4( states_20a3, programs_20a5, states_20e7, programs_20ea);
	_state_20ad->insert( _state_20ad->end(), states_20e7.begin(), states_20e7.end());
	_program_20ae->insert( _program_20ae->end(), programs_20ea.begin(), programs_20ea.end());
}

bool CheckStateDecomp_20a2::isInputUnique( const Udm::Object& state_20b1, const Udm::Object& program_20b8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_20b3= _state_20af.begin(), itprogram_20ba= _program_20b6.begin(); itstate_20b3!= _state_20af.end(), itprogram_20ba!= _program_20b6.end(); ++itstate_20b3, ++itprogram_20ba)
	{
		if( ( *itstate_20b3== state_20b1)&& ( *itprogram_20ba== program_20b8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_20af.push_back( state_20b1);
		_program_20b6.push_back( program_20b8);
	}
	return isUnique;
}

bool IsFuncState_20bd::operator()( const Packets_t& states_20be, const Packets_t& programs_20c1, Packets_t& states_20c0, Packets_t& programs_20c3)
{
#ifdef PRINT_INFO
	printLog( "IsFuncState_20bd" );
#endif
	_state_20c4= &states_20c0;
	_program_20c5= &programs_20c3;
	processInputPackets( states_20be, programs_20c1);
	if( false== _matches.empty())
		return true;
	return false;
}

bool IsFuncState_20bd::isInputUnique( const Udm::Object& state_20ca, const Udm::Object& program_20d3)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_20cc= _state_20c6.begin(), itProgram_20d5= _program_20cf.begin(); itState_20cc!= _state_20c6.end(), itProgram_20d5!= _program_20cf.end(); ++itState_20cc, ++itProgram_20d5)
	{
		if( ( *itState_20cc== state_20ca)&& ( *itProgram_20d5== program_20d3))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_20c6.push_back( state_20ca);
		_program_20cf.push_back( program_20d3);
	}
	return isUnique;
}

bool IsFuncState_20bd::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool IsFuncState_20bd::isGuardTrue( SFC::CompoundStatement& Program, CyberComposition::Simulink::State& State)
{
	bool Gz_guard= false;
	return static_cast< std::string >( State.Decomposition() ) == "FUNC_STATE";;
	return Gz_guard;
}

void IsFuncState_20bd::processInputPackets( const Packets_t& states_20be, const Packets_t& programs_20c1)
{
	for( Packets_t::const_iterator itState_20c7= states_20be.begin(), itProgram_20d0= programs_20c1.begin(); itState_20c7!= states_20be.end(), itProgram_20d0!= programs_20c1.end(); ++itState_20c7, ++itProgram_20d0)
	{
		bool isUnique= isInputUnique( *itState_20c7, *itProgram_20d0);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_20c7, *itProgram_20d0);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_20dc, currMatch.program_20dd);
	}
}

bool IsFuncState_20bd::patternMatcher( const Udm::Object& state_20c8, const Udm::Object& program_20d1)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_20c8.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_20cd= CyberComposition::Simulink::State::Cast( state_20c8);
		if( false== Uml::IsDerivedFrom( program_20d1.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement program_20d6= SFC::CompoundStatement::Cast( program_20d1);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_20db;
		if( !isValidBound(boundObjs_20db, state_20cd, true))
			continue;
		currMatch.state_20dc= state_20cd;
		if( !isValidBound(boundObjs_20db, program_20d6, true))
			continue;
		currMatch.program_20dd= program_20d6;
		bool Gz_guard= isGuardTrue( currMatch.program_20dd, currMatch.state_20dc);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void IsFuncState_20bd::outputAppender( const CyberComposition::Simulink::State& state_20e0, const SFC::CompoundStatement& program_20e2)
{
	_state_20c4->push_back( state_20e0);
	_program_20c5->push_back( program_20e2);
}

bool Otherwise_20e4::operator()( const Packets_t& states_20e5, const Packets_t& programs_20e8, Packets_t& states_20e7, Packets_t& programs_20ea)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_20e4" );
#endif
	_state_20eb= &states_20e7;
	_program_20ec= &programs_20ea;
	processInputPackets( states_20e5, programs_20e8);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_20e4::isInputUnique( const Udm::Object& state_20f1, const Udm::Object& program_20fa)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_20f3= _state_20ed.begin(), itProgram_20fc= _program_20f6.begin(); itState_20f3!= _state_20ed.end(), itProgram_20fc!= _program_20f6.end(); ++itState_20f3, ++itProgram_20fc)
	{
		if( ( *itState_20f3== state_20f1)&& ( *itProgram_20fc== program_20fa))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_20ed.push_back( state_20f1);
		_program_20f6.push_back( program_20fa);
	}
	return isUnique;
}

bool Otherwise_20e4::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_20e4::processInputPackets( const Packets_t& states_20e5, const Packets_t& programs_20e8)
{
	for( Packets_t::const_iterator itState_20ee= states_20e5.begin(), itProgram_20f7= programs_20e8.begin(); itState_20ee!= states_20e5.end(), itProgram_20f7!= programs_20e8.end(); ++itState_20ee, ++itProgram_20f7)
	{
		bool isUnique= isInputUnique( *itState_20ee, *itProgram_20f7);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_20ee, *itProgram_20f7);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_2103, currMatch.program_2104);
	}
}

bool Otherwise_20e4::patternMatcher( const Udm::Object& state_20ef, const Udm::Object& program_20f8)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_20ef.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_20f4= CyberComposition::Simulink::State::Cast( state_20ef);
		if( false== Uml::IsDerivedFrom( program_20f8.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement program_20fd= SFC::CompoundStatement::Cast( program_20f8);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2102;
		if( !isValidBound(boundObjs_2102, state_20f4, true))
			continue;
		currMatch.state_2103= state_20f4;
		if( !isValidBound(boundObjs_2102, program_20fd, true))
			continue;
		currMatch.program_2104= program_20fd;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_20e4::outputAppender( const CyberComposition::Simulink::State& state_2105, const SFC::CompoundStatement& program_2107)
{
	_state_20eb->push_back( state_2105);
	_program_20ec->push_back( program_2107);
}

void CreateOutputArgs_2118::operator()( const Packets_t& states_2119, const Packets_t& rootFxns_211b, Packets_t& states_211d, Packets_t& rootFxns_211e)
{
#ifdef PRINT_INFO
	printLog( "CreateOutputArgs_2118" );
#endif
	_state_211f= &states_211d;
	_rootFxn_2120= &rootFxns_211e;
	_state_211f->insert( _state_211f->end(), states_2119.begin(), states_2119.end());
	_rootFxn_2120->insert( _rootFxn_2120->end(), rootFxns_211b.begin(), rootFxns_211b.end());
	if( ( !states_2119.empty())&& ( !rootFxns_211b.empty()))
		callCheckStateDecomp_21e1( states_2119, rootFxns_211b);
}

void CreateOutputArgs_2118::callCheckStateDecomp_21e1( const Packets_t& states_20a3, const Packets_t& programs_20a5)
{
	Packets_t states_20a7;
	Packets_t programs_20a8;
	Packets_t states_20a9;
	Packets_t programs_20aa;
	CheckStateDecomp_20a2 checkStateDecomp_20a2;
	checkStateDecomp_20a2( states_20a3, programs_20a5, states_20a7, programs_20a8, states_20a9, programs_20aa);
	if( ( !states_20a7.empty())&& ( !programs_20a8.empty()))
		callGetSubStates_21e4( states_20a7, programs_20a8);
	if( ( !states_20a9.empty())&& ( !programs_20aa.empty()))
		callCreateODArgs_21e7( states_20a9, programs_20aa);
}

void CreateOutputArgs_2118::callGetSubStates_21e4( const Packets_t& states_c8c, const Packets_t& parStmnts_c8f)
{
	Packets_t subStates_c8e;
	Packets_t parStmnts_c91;
	GetSubStates_c8b getSubStates_c8b;
	getSubStates_c8b( states_c8c, parStmnts_c8f, subStates_c8e, parStmnts_c91);
	if( ( !subStates_c8e.empty())&& ( !parStmnts_c91.empty()))
		callCheckStateDecomp_21e1( subStates_c8e, parStmnts_c91);
}

void CreateOutputArgs_2118::callCreateODArgs_21e7( const Packets_t& states_2122, const Packets_t& rootFxns_2124)
{
	Packets_t states_2126;
	Packets_t rootFxns_2127;
	CreateODArgs_2121 createODArgs_2121;
	createODArgs_2121( states_2122, rootFxns_2124, states_2126, rootFxns_2127);
	if( ( !states_2126.empty())&& ( !rootFxns_2127.empty()))
		callCreateOEArgs_21ea( states_2126, rootFxns_2127);
}

void CreateOutputArgs_2118::callCreateOEArgs_21ea( const Packets_t& states_2182, const Packets_t& rootFxns_2184)
{
	Packets_t states_2186;
	Packets_t rootFxns_2187;
	CreateOEArgs_2181 createOEArgs_2181;
	createOEArgs_2181( states_2182, rootFxns_2184, states_2186, rootFxns_2187);
	if( ( !states_2186.empty())&& ( !rootFxns_2187.empty()))
		callGetSubStates_21e4( states_2186, rootFxns_2187);
}

void CreateODArgs_2121::operator()( const Packets_t& states_2122, const Packets_t& rootFxns_2124, Packets_t& states_2126, Packets_t& rootFxns_2127)
{
#ifdef PRINT_INFO
	printLog( "CreateODArgs_2121" );
#endif
	_state_2128= &states_2126;
	_rootFxn_2129= &rootFxns_2127;
	_state_2128->insert( _state_2128->end(), states_2122.begin(), states_2122.end());
	_rootFxn_2129->insert( _rootFxn_2129->end(), rootFxns_2124.begin(), rootFxns_2124.end());
	if( ( !states_2122.empty())&& ( !rootFxns_2124.empty()))
		callGetOutData_217b( states_2122, rootFxns_2124);
}

void CreateODArgs_2121::callGetOutData_217b( const Packets_t& states_212c, const Packets_t& rootFunctions_212e)
{
	Packets_t datas_212b;
	Packets_t rootFunctions_2130;
	GetOutData_212a getOutData_212a;
	getOutData_212a( states_212c, rootFunctions_212e, datas_212b, rootFunctions_2130);
	if( ( !datas_212b.empty())&& ( !rootFunctions_2130.empty()))
		callCreateODArg_217e( datas_212b, rootFunctions_2130);
}

void CreateODArgs_2121::callCreateODArg_217e( const Packets_t& datas_2157, const Packets_t& rootFunctions_2159)
{
	CreateODArg_2156 createODArg_2156;
	createODArg_2156( datas_2157, rootFunctions_2159);
}

void GetOutData_212a::operator()( const Packets_t& states_212c, const Packets_t& rootFunctions_212e, Packets_t& datas_212b, Packets_t& rootFunctions_2130)
{
#ifdef PRINT_INFO
	printLog( "GetOutData_212a" );
#endif
	RTTGenerator::Instance()->generateRule(1516, "GetOutData");
	_data_2131= &datas_212b;
	_rootFunction_2132= &rootFunctions_2130;
	processInputPackets( states_212c, rootFunctions_212e);
	sortOutputs( );
}

bool GetOutData_212a::isInputUnique( const Udm::Object& state_2137, const Udm::Object& rootFunction_2140)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_2139= _state_2133.begin(), itRootFunction_2142= _rootFunction_213c.begin(); itState_2139!= _state_2133.end(), itRootFunction_2142!= _rootFunction_213c.end(); ++itState_2139, ++itRootFunction_2142)
	{
		if( ( *itState_2139== state_2137)&& ( *itRootFunction_2142== rootFunction_2140))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_2133.push_back( state_2137);
		_rootFunction_213c.push_back( rootFunction_2140);
	}
	return isUnique;
}

bool GetOutData_212a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool GetOutData_212a::isGuardTrue( CyberComposition::Simulink::Data& Data, SFC::Function& RootFunction, CyberComposition::Simulink::State& State)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( Data.Scope() ) == "OUTPUT_DATA";;
	return Gz_guard;
}

void GetOutData_212a::processInputPackets( const Packets_t& states_212c, const Packets_t& rootFunctions_212e)
{
	for( Packets_t::const_iterator itState_2134= states_212c.begin(), itRootFunction_213d= rootFunctions_212e.begin(); itState_2134!= states_212c.end(), itRootFunction_213d!= rootFunctions_212e.end(); ++itState_2134, ++itRootFunction_213d)
	{
		bool isUnique= isInputUnique( *itState_2134, *itRootFunction_213d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_2134, *itRootFunction_213d);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetOutData_212a::patternMatcher( const Udm::Object& state_2135, const Udm::Object& rootFunction_213e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_2135.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_213a= CyberComposition::Simulink::State::Cast( state_2135);
		if( false== Uml::IsDerivedFrom( rootFunction_213e.type(), SFC::Function::meta))
			continue;
		SFC::Function rootFunction_2143= SFC::Function::Cast( rootFunction_213e);
		set< CyberComposition::Simulink::Data> datas_2145= state_213a.Data_kind_children();
		for( set< CyberComposition::Simulink::Data>::const_iterator itData_2146= datas_2145.begin(); itData_2146!= datas_2145.end(); ++itData_2146)
		{
			CyberComposition::Simulink::Data currData_2147= *itData_2146;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_214b;
			if( !isValidBound(boundObjs_214b, state_213a, true))
				continue;
			currMatch.state_214c= state_213a;
			if( !isValidBound(boundObjs_214b, rootFunction_2143, true))
				continue;
			currMatch.rootFunction_214d= rootFunction_2143;
			if( !isValidBound(boundObjs_214b, currData_2147, false))
				continue;
			currMatch.data_214e= currData_2147;
			bool Gz_guard= isGuardTrue( currMatch.data_214e, currMatch.rootFunction_214d, currMatch.state_214c);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetOutData_212a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.data_214e, currMatch.rootFunction_214d);
	}
}

void GetOutData_212a::outputAppender( const CyberComposition::Simulink::Data& data_2152, const SFC::Function& rootFunction_2154)
{
	_data_2131->push_back( data_2152);
	_rootFunction_2132->push_back( rootFunction_2154);
}

void GetOutData_212a::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::Data, std::pointer_to_binary_function< const CyberComposition::Simulink::Data&, const CyberComposition::Simulink::Data&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::Data&, const CyberComposition::Simulink::Data&, bool> ptr_DEOrder( DEOrder< CyberComposition::Simulink::Data>);
	SortedSet_t sortedSet( ptr_DEOrder);
	std::vector< int> permutationVector( _data_2131->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _data_2131->begin(); it!= _data_2131->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::Data::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _data_2131->begin());
	// order rest of the containers
	permutate( permutationVector, *_rootFunction_2132);
}

void CreateODArg_2156::operator()( const Packets_t& datas_2157, const Packets_t& rootFunctions_2159)
{
#ifdef PRINT_INFO
	printLog( "CreateODArg_2156" );
#endif
	RTTGenerator::Instance()->generateRule(1521, "CreateODArg");
	processInputPackets( datas_2157, rootFunctions_2159);
}

bool CreateODArg_2156::isInputUnique( const Udm::Object& data_215f, const Udm::Object& rootFunction_2168)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itData_2161= _data_215b.begin(), itRootFunction_216a= _rootFunction_2164.begin(); itData_2161!= _data_215b.end(), itRootFunction_216a!= _rootFunction_2164.end(); ++itData_2161, ++itRootFunction_216a)
	{
		if( ( *itData_2161== data_215f)&& ( *itRootFunction_216a== rootFunction_2168))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_data_215b.push_back( data_215f);
		_rootFunction_2164.push_back( rootFunction_2168);
	}
	return isUnique;
}

bool CreateODArg_2156::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateODArg_2156::processInputPackets( const Packets_t& datas_2157, const Packets_t& rootFunctions_2159)
{
	for( Packets_t::const_iterator itData_215c= datas_2157.begin(), itRootFunction_2165= rootFunctions_2159.begin(); itData_215c!= datas_2157.end(), itRootFunction_2165!= rootFunctions_2159.end(); ++itData_215c, ++itRootFunction_2165)
	{
		bool isUnique= isInputUnique( *itData_215c, *itRootFunction_2165);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itData_215c, *itRootFunction_2165);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateODArg_2156::patternMatcher( const Udm::Object& data_215d, const Udm::Object& rootFunction_2166)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( data_215d.type(), CyberComposition::Simulink::Data::meta))
			continue;
		CyberComposition::Simulink::Data data_2162= CyberComposition::Simulink::Data::Cast( data_215d);
		if( false== Uml::IsDerivedFrom( rootFunction_2166.type(), SFC::Function::meta))
			continue;
		SFC::Function rootFunction_216b= SFC::Function::Cast( rootFunction_2166);
		set< SFC::LocalVar> localVars_216d= data_2162.src();
		for( set< SFC::LocalVar>::const_iterator itLocalVars_216e= localVars_216d.begin(); itLocalVars_216e!= localVars_216d.end(); ++itLocalVars_216e)
		{
			SFC::LocalVar currLocalVar_216f= *itLocalVars_216e;
			SFC::DT dT_2170= currLocalVar_216f.dt();
			if( !dT_2170)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2174;
			if( !isValidBound(boundObjs_2174, data_2162, true))
				continue;
			currMatch.data_2175= data_2162;
			if( !isValidBound(boundObjs_2174, rootFunction_216b, true))
				continue;
			currMatch.rootFunction_2176= rootFunction_216b;
			if( !isValidBound(boundObjs_2174, currLocalVar_216f, false))
				continue;
			currMatch.localVar_2177= currLocalVar_216f;
			if( !isValidBound(boundObjs_2174, dT_2170, false))
				continue;
			currMatch.dT_2178= dT_2170;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateODArg_2156::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::SetVar newSetVar_2179= SFC::SetVar::Create( currMatch.rootFunction_2176);
		SFC::Arg newArg_217a= SFC::Arg::Create( currMatch.rootFunction_2176);
		SFC::Arg& Arg= newArg_217a;
		SFC::DT& DT= currMatch.dT_2178;
		CyberComposition::Simulink::Data& Data= currMatch.data_2175;
		SFC::LocalVar& LocalVar= currMatch.localVar_2177;
		SFC::Function& RootFunction= currMatch.rootFunction_2176;
		SFC::SetVar& SetVar= newSetVar_2179;
		{
Arg.RefId() = SetVar.RefId() = LocalVar.RefId();
};
		{
__int64 statementCount = RootFunction.statementCount();
SetVar.statementIndex() = statementCount++;
RootFunction.statementCount() = statementCount;
};
		{
__int64 argCount = RootFunction.argCount();
Arg.argIndex() = argCount++;
RootFunction.argCount() = argCount;
};
		{
Arg.name() = static_cast< std::string >( Data.Name() ) + "_";
Arg.indexBase() = Data.ArrayFirstIndex();
Arg.ptr() = true;
};
		{
SetVar.invert() = true;
};
		newArg_217a.dt()= currMatch.dT_2178;
		newSetVar_2179.arg_end()= newArg_217a;
		newSetVar_2179.lvar_end()= currMatch.localVar_2177;
	}
}

void CreateOEArgs_2181::operator()( const Packets_t& states_2182, const Packets_t& rootFxns_2184, Packets_t& states_2186, Packets_t& rootFxns_2187)
{
#ifdef PRINT_INFO
	printLog( "CreateOEArgs_2181" );
#endif
	_state_2188= &states_2186;
	_rootFxn_2189= &rootFxns_2187;
	_state_2188->insert( _state_2188->end(), states_2182.begin(), states_2182.end());
	_rootFxn_2189->insert( _rootFxn_2189->end(), rootFxns_2184.begin(), rootFxns_2184.end());
	if( ( !states_2182.empty())&& ( !rootFxns_2184.empty()))
		callGetOutEvent_21db( states_2182, rootFxns_2184);
}

void CreateOEArgs_2181::callGetOutEvent_21db( const Packets_t& states_218b, const Packets_t& rootFunctions_218e)
{
	Packets_t events_218d;
	Packets_t rootFunctions_2190;
	GetOutEvent_218a getOutEvent_218a;
	getOutEvent_218a( states_218b, rootFunctions_218e, events_218d, rootFunctions_2190);
	if( ( !events_218d.empty())&& ( !rootFunctions_2190.empty()))
		callCreateOEArg_21de( events_218d, rootFunctions_2190);
}

void CreateOEArgs_2181::callCreateOEArg_21de( const Packets_t& events_21b7, const Packets_t& rootFunctions_21b9)
{
	CreateOEArg_21b6 createOEArg_21b6;
	createOEArg_21b6( events_21b7, rootFunctions_21b9);
}

void GetOutEvent_218a::operator()( const Packets_t& states_218b, const Packets_t& rootFunctions_218e, Packets_t& events_218d, Packets_t& rootFunctions_2190)
{
#ifdef PRINT_INFO
	printLog( "GetOutEvent_218a" );
#endif
	RTTGenerator::Instance()->generateRule(1545, "GetOutEvent");
	_event_2191= &events_218d;
	_rootFunction_2192= &rootFunctions_2190;
	processInputPackets( states_218b, rootFunctions_218e);
	sortOutputs( );
}

bool GetOutEvent_218a::isInputUnique( const Udm::Object& state_2197, const Udm::Object& rootFunction_21a0)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_2199= _state_2193.begin(), itRootFunction_21a2= _rootFunction_219c.begin(); itState_2199!= _state_2193.end(), itRootFunction_21a2!= _rootFunction_219c.end(); ++itState_2199, ++itRootFunction_21a2)
	{
		if( ( *itState_2199== state_2197)&& ( *itRootFunction_21a2== rootFunction_21a0))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_2193.push_back( state_2197);
		_rootFunction_219c.push_back( rootFunction_21a0);
	}
	return isUnique;
}

bool GetOutEvent_218a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool GetOutEvent_218a::isGuardTrue( CyberComposition::Simulink::Event& Event, SFC::Function& RootFunction, CyberComposition::Simulink::State& State)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( Event.Scope() ) == "OUTPUT_EVENT";;
	return Gz_guard;
}

void GetOutEvent_218a::processInputPackets( const Packets_t& states_218b, const Packets_t& rootFunctions_218e)
{
	for( Packets_t::const_iterator itState_2194= states_218b.begin(), itRootFunction_219d= rootFunctions_218e.begin(); itState_2194!= states_218b.end(), itRootFunction_219d!= rootFunctions_218e.end(); ++itState_2194, ++itRootFunction_219d)
	{
		bool isUnique= isInputUnique( *itState_2194, *itRootFunction_219d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_2194, *itRootFunction_219d);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetOutEvent_218a::patternMatcher( const Udm::Object& state_2195, const Udm::Object& rootFunction_219e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_2195.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_219a= CyberComposition::Simulink::State::Cast( state_2195);
		if( false== Uml::IsDerivedFrom( rootFunction_219e.type(), SFC::Function::meta))
			continue;
		SFC::Function rootFunction_21a3= SFC::Function::Cast( rootFunction_219e);
		set< CyberComposition::Simulink::Event> events_21a5= state_219a.Event_kind_children();
		for( set< CyberComposition::Simulink::Event>::const_iterator itEvent_21a6= events_21a5.begin(); itEvent_21a6!= events_21a5.end(); ++itEvent_21a6)
		{
			CyberComposition::Simulink::Event currEvent_21a7= *itEvent_21a6;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_21ab;
			if( !isValidBound(boundObjs_21ab, state_219a, true))
				continue;
			currMatch.state_21ac= state_219a;
			if( !isValidBound(boundObjs_21ab, rootFunction_21a3, true))
				continue;
			currMatch.rootFunction_21ad= rootFunction_21a3;
			if( !isValidBound(boundObjs_21ab, currEvent_21a7, false))
				continue;
			currMatch.event_21ae= currEvent_21a7;
			bool Gz_guard= isGuardTrue( currMatch.event_21ae, currMatch.rootFunction_21ad, currMatch.state_21ac);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetOutEvent_218a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.event_21ae, currMatch.rootFunction_21ad);
	}
}

void GetOutEvent_218a::outputAppender( const CyberComposition::Simulink::Event& event_21b2, const SFC::Function& rootFunction_21b4)
{
	_event_2191->push_back( event_21b2);
	_rootFunction_2192->push_back( rootFunction_21b4);
}

void GetOutEvent_218a::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::Event, std::pointer_to_binary_function< const CyberComposition::Simulink::Event&, const CyberComposition::Simulink::Event&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::Event&, const CyberComposition::Simulink::Event&, bool> ptr_DEOrder( DEOrder< CyberComposition::Simulink::Event>);
	SortedSet_t sortedSet( ptr_DEOrder);
	std::vector< int> permutationVector( _event_2191->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _event_2191->begin(); it!= _event_2191->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::Event::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _event_2191->begin());
	// order rest of the containers
	permutate( permutationVector, *_rootFunction_2192);
}

void CreateOEArg_21b6::operator()( const Packets_t& events_21b7, const Packets_t& rootFunctions_21b9)
{
#ifdef PRINT_INFO
	printLog( "CreateOEArg_21b6" );
#endif
	RTTGenerator::Instance()->generateRule(1550, "CreateOEArg");
	processInputPackets( events_21b7, rootFunctions_21b9);
}

bool CreateOEArg_21b6::isInputUnique( const Udm::Object& event_21bf, const Udm::Object& rootFunction_21c8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itEvent_21c1= _event_21bb.begin(), itRootFunction_21ca= _rootFunction_21c4.begin(); itEvent_21c1!= _event_21bb.end(), itRootFunction_21ca!= _rootFunction_21c4.end(); ++itEvent_21c1, ++itRootFunction_21ca)
	{
		if( ( *itEvent_21c1== event_21bf)&& ( *itRootFunction_21ca== rootFunction_21c8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_event_21bb.push_back( event_21bf);
		_rootFunction_21c4.push_back( rootFunction_21c8);
	}
	return isUnique;
}

bool CreateOEArg_21b6::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateOEArg_21b6::processInputPackets( const Packets_t& events_21b7, const Packets_t& rootFunctions_21b9)
{
	for( Packets_t::const_iterator itEvent_21bc= events_21b7.begin(), itRootFunction_21c5= rootFunctions_21b9.begin(); itEvent_21bc!= events_21b7.end(), itRootFunction_21c5!= rootFunctions_21b9.end(); ++itEvent_21bc, ++itRootFunction_21c5)
	{
		bool isUnique= isInputUnique( *itEvent_21bc, *itRootFunction_21c5);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itEvent_21bc, *itRootFunction_21c5);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateOEArg_21b6::patternMatcher( const Udm::Object& event_21bd, const Udm::Object& rootFunction_21c6)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( event_21bd.type(), CyberComposition::Simulink::Event::meta))
			continue;
		CyberComposition::Simulink::Event event_21c2= CyberComposition::Simulink::Event::Cast( event_21bd);
		if( false== Uml::IsDerivedFrom( rootFunction_21c6.type(), SFC::Function::meta))
			continue;
		SFC::Function rootFunction_21cb= SFC::Function::Cast( rootFunction_21c6);
		set< SFC::LocalVar> localVars_21cd= event_21c2.src();
		for( set< SFC::LocalVar>::const_iterator itLocalVars_21ce= localVars_21cd.begin(); itLocalVars_21ce!= localVars_21cd.end(); ++itLocalVars_21ce)
		{
			SFC::LocalVar currLocalVar_21cf= *itLocalVars_21ce;
			SFC::DT dT_21d0= currLocalVar_21cf.dt();
			if( !dT_21d0)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_21d4;
			if( !isValidBound(boundObjs_21d4, event_21c2, true))
				continue;
			currMatch.event_21d5= event_21c2;
			if( !isValidBound(boundObjs_21d4, rootFunction_21cb, true))
				continue;
			currMatch.rootFunction_21d6= rootFunction_21cb;
			if( !isValidBound(boundObjs_21d4, currLocalVar_21cf, false))
				continue;
			currMatch.localVar_21d7= currLocalVar_21cf;
			if( !isValidBound(boundObjs_21d4, dT_21d0, false))
				continue;
			currMatch.dT_21d8= dT_21d0;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateOEArg_21b6::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::SetVar newSetVar_21d9= SFC::SetVar::Create( currMatch.rootFunction_21d6);
		SFC::Arg newArg_21da= SFC::Arg::Create( currMatch.rootFunction_21d6);
		SFC::Arg& Arg= newArg_21da;
		SFC::DT& DT= currMatch.dT_21d8;
		CyberComposition::Simulink::Event& Event= currMatch.event_21d5;
		SFC::LocalVar& LocalVar= currMatch.localVar_21d7;
		SFC::Function& RootFunction= currMatch.rootFunction_21d6;
		SFC::SetVar& SetVar= newSetVar_21d9;
		{
Arg.RefId() = SetVar.RefId() = LocalVar.RefId();
};
		{
__int64 argCount = RootFunction.argCount();
Arg.argIndex() = argCount++;
RootFunction.argCount() = argCount;
};
		{
__int64 statementCount = RootFunction.statementCount();
SetVar.statementIndex() = statementCount++;
RootFunction.statementCount() = statementCount;
};
		{
Arg.name() = static_cast< std::string >( Event.Name() ) + "_";
Arg.ptr() = true;
};
		{
SetVar.invert() = true;
};
		newArg_21da.dt()= currMatch.dT_21d8;
		newSetVar_21d9.arg_end()= newArg_21da;
		newSetVar_21d9.lvar_end()= currMatch.localVar_21d7;
	}
}

void CreateInitFunction_21f9::operator()( const Packets_t& states_21fa, const Packets_t& programs_21fc, Packets_t& states_21fe, Packets_t& programs_21ff)
{
#ifdef PRINT_INFO
	printLog( "CreateInitFunction_21f9" );
#endif
	_state_2200= &states_21fe;
	_program_2201= &programs_21ff;
	_state_2200->insert( _state_2200->end(), states_21fa.begin(), states_21fa.end());
	_program_2201->insert( _program_2201->end(), programs_21fc.begin(), programs_21fc.end());
	if( ( !states_21fa.empty())&& ( !programs_21fc.empty()))
		callCreateInitFunction_242b( states_21fa, programs_21fc);
}

void CreateInitFunction_21f9::callCreateInitFunction_242b( const Packets_t& states_225a, const Packets_t& programs_225d)
{
	Packets_t states_225c;
	Packets_t programs_225f;
	Packets_t initFunctions_2260;
	Packets_t initIdxs_2261;
	CreateInitFunction_2259 createInitFunction_2259;
	createInitFunction_2259( states_225a, programs_225d, states_225c, programs_225f, initFunctions_2260, initIdxs_2261);
	if( ( !states_225c.empty())&& ( !programs_225f.empty())&& ( !initFunctions_2260.empty())&& ( !initIdxs_2261.empty()))
		callInitLocalVars_242e( states_225c, programs_225f, initFunctions_2260, initIdxs_2261);
}

void CreateInitFunction_21f9::callInitLocalVars_242e( const Packets_t& states_228d, const Packets_t& programs_228f, const Packets_t& initFns_2291, const Packets_t& initIdxs_2293)
{
	Packets_t states_2295;
	Packets_t initfns_2296;
	InitLocalVars_228c initLocalVars_228c;
	initLocalVars_228c( states_228d, programs_228f, initFns_2291, initIdxs_2293, states_2295, initfns_2296);
	if( ( !states_2295.empty())&& ( !initfns_2296.empty()))
		callTestEAIOn_2433( states_2295, initfns_2296);
}

void CreateInitFunction_21f9::callTestEAIOn_2433( const Packets_t& states_23dc, const Packets_t& initfns_23de)
{
	Packets_t states_23e0;
	Packets_t initfns_23e1;
	TestEAIOn_23db testEAIOn_23db;
	testEAIOn_23db( states_23dc, initfns_23de, states_23e0, initfns_23e1);
	if( ( !states_23e0.empty())&& ( !initfns_23e1.empty()))
		callCreateFunction_FunctionCall_2436( states_23e0, initfns_23e1);
}

void CreateInitFunction_21f9::callCreateFunction_FunctionCall_2436( const Packets_t& states_2203, const Packets_t& initFns_2206)
{
	Packets_t enters_2205;
	Packets_t functionCalls_2208;
	CreateFunction_FunctionCall_2202 createFunction_FunctionCall_2202;
	createFunction_FunctionCall_2202( states_2203, initFns_2206, enters_2205, functionCalls_2208);
	if( ( !enters_2205.empty())&& ( !functionCalls_2208.empty()))
		callFunctionCall_Vals_2439( enters_2205, functionCalls_2208);
}

void CreateInitFunction_21f9::callFunctionCall_Vals_2439( const Packets_t& enters_222d, const Packets_t& functionCalls_222f)
{
	FunctionCall_Vals_222c functionCall_Vals_222c;
	functionCall_Vals_222c( enters_222d, functionCalls_222f);
}

void CreateFunction_FunctionCall_2202::operator()( const Packets_t& states_2203, const Packets_t& initFns_2206, Packets_t& enters_2205, Packets_t& functionCalls_2208)
{
#ifdef PRINT_INFO
	printLog( "CreateFunction_FunctionCall_2202" );
#endif
	RTTGenerator::Instance()->generateRule(1574, "CreateFunction_FunctionCall");
	_enter_2209= &enters_2205;
	_functionCall_220a= &functionCalls_2208;
	processInputPackets( states_2203, initFns_2206);
}

bool CreateFunction_FunctionCall_2202::isInputUnique( const Udm::Object& state_220f, const Udm::Object& initFn_2218)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_2211= _state_220b.begin(), itInitFn_221a= _initFn_2214.begin(); itState_2211!= _state_220b.end(), itInitFn_221a!= _initFn_2214.end(); ++itState_2211, ++itInitFn_221a)
	{
		if( ( *itState_2211== state_220f)&& ( *itInitFn_221a== initFn_2218))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_220b.push_back( state_220f);
		_initFn_2214.push_back( initFn_2218);
	}
	return isUnique;
}

bool CreateFunction_FunctionCall_2202::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateFunction_FunctionCall_2202::processInputPackets( const Packets_t& states_2203, const Packets_t& initFns_2206)
{
	for( Packets_t::const_iterator itState_220c= states_2203.begin(), itInitFn_2215= initFns_2206.begin(); itState_220c!= states_2203.end(), itInitFn_2215!= initFns_2206.end(); ++itState_220c, ++itInitFn_2215)
	{
		bool isUnique= isInputUnique( *itState_220c, *itInitFn_2215);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_220c, *itInitFn_2215);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateFunction_FunctionCall_2202::patternMatcher( const Udm::Object& state_220d, const Udm::Object& initFn_2216)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_220d.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_2212= CyberComposition::Simulink::State::Cast( state_220d);
		if( false== Uml::IsDerivedFrom( initFn_2216.type(), SFC::Function::meta))
			continue;
		SFC::Function initFn_221b= SFC::Function::Cast( initFn_2216);
		set< SFC::Function> enters_221d= state_2212.enter();
		for( set< SFC::Function>::const_iterator itEnters_221e= enters_221d.begin(); itEnters_221e!= enters_221d.end(); ++itEnters_221e)
		{
			SFC::Function currEnter_221f= *itEnters_221e;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2223;
			if( !isValidBound(boundObjs_2223, state_2212, true))
				continue;
			currMatch.state_2224= state_2212;
			if( !isValidBound(boundObjs_2223, initFn_221b, true))
				continue;
			currMatch.initFn_2225= initFn_221b;
			if( !isValidBound(boundObjs_2223, currEnter_221f, false))
				continue;
			currMatch.enter_2226= currEnter_221f;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateFunction_FunctionCall_2202::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::FunctionCall newFunctionCall_2227= SFC::FunctionCall::Create( currMatch.initFn_2225);
		SFC::Function& Enter= currMatch.enter_2226;
		SFC::FunctionCall& FunctionCall= newFunctionCall_2227;
		SFC::Function& InitFn= currMatch.initFn_2225;
		CyberComposition::Simulink::State& State= currMatch.state_2224;
		{
FunctionCall.RefId() = InitFn.RefId();
};
		{
__int64 statementCount = InitFn.statementCount();
FunctionCall.statementIndex() = statementCount++;
InitFn.statementCount() = statementCount;
};
		newFunctionCall_2227.callee()= currMatch.enter_2226;
		outputAppender( currMatch.enter_2226, newFunctionCall_2227);
	}
}

void CreateFunction_FunctionCall_2202::outputAppender( const SFC::Function& enter_2228, const SFC::FunctionCall& functionCall_222a)
{
	_enter_2209->push_back( enter_2228);
	_functionCall_220a->push_back( functionCall_222a);
}

void FunctionCall_Vals_222c::operator()( const Packets_t& enters_222d, const Packets_t& functionCalls_222f)
{
#ifdef PRINT_INFO
	printLog( "FunctionCall_Vals_222c" );
#endif
	RTTGenerator::Instance()->generateRule(1584, "FunctionCall_Vals");
	processInputPackets( enters_222d, functionCalls_222f);
}

bool FunctionCall_Vals_222c::isInputUnique( const Udm::Object& enter_2235, const Udm::Object& functionCall_223e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itEnter_2237= _enter_2231.begin(), itFunctionCall_2240= _functionCall_223a.begin(); itEnter_2237!= _enter_2231.end(), itFunctionCall_2240!= _functionCall_223a.end(); ++itEnter_2237, ++itFunctionCall_2240)
	{
		if( ( *itEnter_2237== enter_2235)&& ( *itFunctionCall_2240== functionCall_223e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_enter_2231.push_back( enter_2235);
		_functionCall_223a.push_back( functionCall_223e);
	}
	return isUnique;
}

bool FunctionCall_Vals_222c::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool FunctionCall_Vals_222c::isGuardTrue( SFC::Arg& Arg0, SFC::Arg& Arg1, SFC::Function& Enter, SFC::FunctionCall& FunctionCall)
{
	bool Gz_guard= false;
	return Arg0.argIndex() == 0 && Arg1.argIndex() == 1;;
	return Gz_guard;
}

void FunctionCall_Vals_222c::processInputPackets( const Packets_t& enters_222d, const Packets_t& functionCalls_222f)
{
	for( Packets_t::const_iterator itEnter_2232= enters_222d.begin(), itFunctionCall_223b= functionCalls_222f.begin(); itEnter_2232!= enters_222d.end(), itFunctionCall_223b!= functionCalls_222f.end(); ++itEnter_2232, ++itFunctionCall_223b)
	{
		bool isUnique= isInputUnique( *itEnter_2232, *itFunctionCall_223b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itEnter_2232, *itFunctionCall_223b);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool FunctionCall_Vals_222c::patternMatcher( const Udm::Object& enter_2233, const Udm::Object& functionCall_223c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( enter_2233.type(), SFC::Function::meta))
			continue;
		SFC::Function enter_2238= SFC::Function::Cast( enter_2233);
		if( false== Uml::IsDerivedFrom( functionCall_223c.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall functionCall_2241= SFC::FunctionCall::Cast( functionCall_223c);
		set< SFC::Arg> arg1s_2243= enter_2238.Arg_kind_children();
		for( set< SFC::Arg>::const_iterator itArg1_2244= arg1s_2243.begin(); itArg1_2244!= arg1s_2243.end(); ++itArg1_2244)
		{
			SFC::Arg currArg1_2245= *itArg1_2244;
			set< SFC::Arg> arg0s_2246= enter_2238.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itArg0_2247= arg0s_2246.begin(); itArg0_2247!= arg0s_2246.end(); ++itArg0_2247)
			{
				SFC::Arg currArg0_2248= *itArg0_2247;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_224c;
				if( !isValidBound(boundObjs_224c, enter_2238, true))
					continue;
				currMatch.enter_224d= enter_2238;
				if( !isValidBound(boundObjs_224c, functionCall_2241, true))
					continue;
				currMatch.functionCall_224e= functionCall_2241;
				if( !isValidBound(boundObjs_224c, currArg0_2248, false))
					continue;
				currMatch.arg0_224f= currArg0_2248;
				if( !isValidBound(boundObjs_224c, currArg1_2245, false))
					continue;
				currMatch.arg1_2250= currArg1_2245;
				bool Gz_guard= isGuardTrue( currMatch.arg0_224f, currMatch.arg1_2250, currMatch.enter_224d, currMatch.functionCall_224e);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void FunctionCall_Vals_222c::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ArgVal newArgVal1_2255= SFC::ArgVal::Create( currMatch.functionCall_224e);
		SFC::Int newNegOne_2256= SFC::Int::Create( newArgVal1_2255);
		SFC::ArgVal newArgVal0_2257= SFC::ArgVal::Create( currMatch.functionCall_224e);
		SFC::Int newZero_2258= SFC::Int::Create( newArgVal0_2257);
		SFC::Arg& Arg0= currMatch.arg0_224f;
		SFC::Arg& Arg1= currMatch.arg1_2250;
		SFC::ArgVal& ArgVal0= newArgVal0_2257;
		SFC::ArgVal& ArgVal1= newArgVal1_2255;
		SFC::Function& Enter= currMatch.enter_224d;
		SFC::FunctionCall& FunctionCall= currMatch.functionCall_224e;
		SFC::Int& NegOne= newNegOne_2256;
		SFC::Int& Zero= newZero_2258;
		{
ArgVal1.argIndex() = Arg1.argIndex();
};
		{
ArgVal0.argIndex() = Arg0.argIndex();
};
		{
FunctionCall.argCount() = FunctionCall.argCount() + 2;
};
		{
NegOne.val() = -1;
};
		{
Zero.val() = 0;
};
		newArgVal1_2255.arg()+= currMatch.arg1_2250;
		newArgVal0_2257.arg()+= currMatch.arg0_224f;
	}
}

void CreateInitFunction_2259::operator()( const Packets_t& states_225a, const Packets_t& programs_225d, Packets_t& states_225c, Packets_t& programs_225f, Packets_t& initFunctions_2260, Packets_t& initIdxs_2261)
{
#ifdef PRINT_INFO
	printLog( "CreateInitFunction_2259" );
#endif
	RTTGenerator::Instance()->generateRule(1606, "CreateInitFunction");
	_state_2262= &states_225c;
	_program_2263= &programs_225f;
	_initFunction_2264= &initFunctions_2260;
	_initIdx_2265= &initIdxs_2261;
	processInputPackets( states_225a, programs_225d);
}

bool CreateInitFunction_2259::isInputUnique( const Udm::Object& state_226a, const Udm::Object& program_2273)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_226c= _state_2266.begin(), itProgram_2275= _program_226f.begin(); itState_226c!= _state_2266.end(), itProgram_2275!= _program_226f.end(); ++itState_226c, ++itProgram_2275)
	{
		if( ( *itState_226c== state_226a)&& ( *itProgram_2275== program_2273))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_2266.push_back( state_226a);
		_program_226f.push_back( program_2273);
	}
	return isUnique;
}

bool CreateInitFunction_2259::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateInitFunction_2259::processInputPackets( const Packets_t& states_225a, const Packets_t& programs_225d)
{
	for( Packets_t::const_iterator itState_2267= states_225a.begin(), itProgram_2270= programs_225d.begin(); itState_2267!= states_225a.end(), itProgram_2270!= programs_225d.end(); ++itState_2267, ++itProgram_2270)
	{
		bool isUnique= isInputUnique( *itState_2267, *itProgram_2270);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_2267, *itProgram_2270);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateInitFunction_2259::patternMatcher( const Udm::Object& state_2268, const Udm::Object& program_2271)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_2268.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_226d= CyberComposition::Simulink::State::Cast( state_2268);
		if( false== Uml::IsDerivedFrom( program_2271.type(), SFC::Program::meta))
			continue;
		SFC::Program program_2276= SFC::Program::Cast( program_2271);
		set< SFC::StateVar> stateVars_2278= program_2276.StateVar_kind_children();
		for( set< SFC::StateVar>::const_iterator itStateVar_2279= stateVars_2278.begin(); itStateVar_2279!= stateVars_2278.end(); ++itStateVar_2279)
		{
			SFC::StateVar currStateVar_227a= *itStateVar_2279;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_227e;
			if( !isValidBound(boundObjs_227e, state_226d, true))
				continue;
			currMatch.state_227f= state_226d;
			if( !isValidBound(boundObjs_227e, program_2276, true))
				continue;
			currMatch.program_2280= program_2276;
			if( !isValidBound(boundObjs_227e, currStateVar_227a, false))
				continue;
			currMatch.stateVar_2281= currStateVar_227a;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateInitFunction_2259::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function newInitFunction_2282= SFC::Function::Create( currMatch.program_2280);
		SFC::LocalVar newInitIdx_2283= SFC::LocalVar::Create( newInitFunction_2282);
		SFC::Function& InitFunction= newInitFunction_2282;
		SFC::LocalVar& InitIdx= newInitIdx_2283;
		SFC::Program& Program= currMatch.program_2280;
		CyberComposition::Simulink::State& State= currMatch.state_227f;
		SFC::StateVar& StateVar= currMatch.stateVar_2281;
		{
InitFunction.RefId() = InitIdx.RefId() = State.RefId();
};
		{
__int64 sc;
sc = Program.statementCount();
InitFunction.statementIndex() = sc++;
Program.statementCount() = sc;
};
		{
InitFunction.name() = static_cast< std::string >( State.name() ) + "_init";
};
		{
__int64 sc;
sc = InitFunction.statementCount();
InitIdx.statementIndex() = sc++;
InitFunction.statementCount() = sc;
};
		{
InitIdx.name() = "i";
InitIdx.dt() = SFCTypesManager::getSingleton().getBasicType( "int" );
InitIdx.initial() = "0";
};
		outputAppender( currMatch.state_227f, currMatch.program_2280, newInitFunction_2282, newInitIdx_2283);
	}
}

void CreateInitFunction_2259::outputAppender( const CyberComposition::Simulink::State& state_2284, const SFC::Program& program_2286, const SFC::Function& initFunction_2288, const SFC::LocalVar& initIdx_228a)
{
	_state_2262->push_back( state_2284);
	_program_2263->push_back( program_2286);
	_initFunction_2264->push_back( initFunction_2288);
	_initIdx_2265->push_back( initIdx_228a);
}

void InitLocalVars_228c::operator()( const Packets_t& states_228d, const Packets_t& programs_228f, const Packets_t& initFns_2291, const Packets_t& initIdxs_2293, Packets_t& states_2295, Packets_t& initfns_2296)
{
#ifdef PRINT_INFO
	printLog( "InitLocalVars_228c" );
#endif
	_state_2297= &states_2295;
	_initfn_2298= &initfns_2296;
	_state_2297->insert( _state_2297->end(), states_228d.begin(), states_228d.end());
	_initfn_2298->insert( _initfn_2298->end(), initFns_2291.begin(), initFns_2291.end());
	if( ( !programs_228f.empty())&& ( !initFns_2291.empty())&& ( !initIdxs_2293.empty()))
		callGetSortedVars_23cb( programs_228f, initFns_2291, initIdxs_2293);
}

void InitLocalVars_228c::callGetSortedVars_23cb( const Packets_t& programs_229a, const Packets_t& initFns_229d, const Packets_t& initIdxs_22a0)
{
	Packets_t vars_229c;
	Packets_t initFns_229f;
	Packets_t initIdxs_22a2;
	GetSortedVars_2299 getSortedVars_2299;
	getSortedVars_2299( programs_229a, initFns_229d, initIdxs_22a0, vars_229c, initFns_229f, initIdxs_22a2);
	if( ( !vars_229c.empty())&& ( !initFns_229f.empty())&& ( !initIdxs_22a2.empty()))
		callArrayVars_23cf( vars_229c, initFns_229f, initIdxs_22a2);
}

void InitLocalVars_228c::callArrayVars_23cf( const Packets_t& programs_230e, const Packets_t& initFns_2310, const Packets_t& initIdxs_2312)
{
	Packets_t vars_2314;
	Packets_t initfns_2315;
	Packets_t initidxs_2316;
	Packets_t vars_2317;
	Packets_t initfns_2318;
	Packets_t initidxs_2319;
	ArrayVars_230d arrayVars_230d;
	arrayVars_230d( programs_230e, initFns_2310, initIdxs_2312, vars_2314, initfns_2315, initidxs_2316, vars_2317, initfns_2318, initidxs_2319);
	if( ( !vars_2314.empty())&& ( !initfns_2315.empty())&& ( !initidxs_2316.empty()))
		callInitArrayVar_23d3( vars_2314, initfns_2315, initidxs_2316);
	if( ( !vars_2317.empty())&& ( !initfns_2318.empty())&& ( !initidxs_2319.empty()))
		callInitScalarVar_23d7( vars_2317, initfns_2318, initidxs_2319);
}

void InitLocalVars_228c::callInitArrayVar_23d3( const Packets_t& vars_22d3, const Packets_t& initFns_22d5, const Packets_t& idxVars_22d7)
{
	InitArrayVar_22d2 initArrayVar_22d2;
	initArrayVar_22d2( vars_22d3, initFns_22d5, idxVars_22d7);
}

void InitLocalVars_228c::callInitScalarVar_23d7( const Packets_t& vars_23a3, const Packets_t& initFns_23a5, const Packets_t& idxVars_23a7)
{
	InitScalarVar_23a2 initScalarVar_23a2;
	initScalarVar_23a2( vars_23a3, initFns_23a5, idxVars_23a7);
}

void GetSortedVars_2299::operator()( const Packets_t& programs_229a, const Packets_t& initFns_229d, const Packets_t& initIdxs_22a0, Packets_t& vars_229c, Packets_t& initFns_229f, Packets_t& initIdxs_22a2)
{
#ifdef PRINT_INFO
	printLog( "GetSortedVars_2299" );
#endif
	RTTGenerator::Instance()->generateRule(1627, "GetSortedVars");
	_var_22a3= &vars_229c;
	_initFn_22a4= &initFns_229f;
	_initIdx_22a5= &initIdxs_22a2;
	processInputPackets( programs_229a, initFns_229d, initIdxs_22a0);
	sortOutputs( );
}

bool GetSortedVars_2299::isInputUnique( const Udm::Object& program_22aa, const Udm::Object& initFn_22b3, const Udm::Object& initIdx_22bc)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itProgram_22ac= _program_22a6.begin(), itInitFn_22b5= _initFn_22af.begin(), itInitIdx_22be= _initIdx_22b8.begin(); itProgram_22ac!= _program_22a6.end(), itInitFn_22b5!= _initFn_22af.end(), itInitIdx_22be!= _initIdx_22b8.end(); ++itProgram_22ac, ++itInitFn_22b5, ++itInitIdx_22be)
	{
		if( ( *itProgram_22ac== program_22aa)&& ( *itInitFn_22b5== initFn_22b3)&& ( *itInitIdx_22be== initIdx_22bc))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_program_22a6.push_back( program_22aa);
		_initFn_22af.push_back( initFn_22b3);
		_initIdx_22b8.push_back( initIdx_22bc);
	}
	return isUnique;
}

bool GetSortedVars_2299::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetSortedVars_2299::processInputPackets( const Packets_t& programs_229a, const Packets_t& initFns_229d, const Packets_t& initIdxs_22a0)
{
	for( Packets_t::const_iterator itProgram_22a7= programs_229a.begin(), itInitFn_22b0= initFns_229d.begin(), itInitIdx_22b9= initIdxs_22a0.begin(); itProgram_22a7!= programs_229a.end(), itInitFn_22b0!= initFns_229d.end(), itInitIdx_22b9!= initIdxs_22a0.end(); ++itProgram_22a7, ++itInitFn_22b0, ++itInitIdx_22b9)
	{
		bool isUnique= isInputUnique( *itProgram_22a7, *itInitFn_22b0, *itInitIdx_22b9);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itProgram_22a7, *itInitFn_22b0, *itInitIdx_22b9);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetSortedVars_2299::patternMatcher( const Udm::Object& program_22a8, const Udm::Object& initFn_22b1, const Udm::Object& initIdx_22ba)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( program_22a8.type(), SFC::Program::meta))
			continue;
		SFC::Program program_22ad= SFC::Program::Cast( program_22a8);
		if( false== Uml::IsDerivedFrom( initFn_22b1.type(), SFC::Function::meta))
			continue;
		SFC::Function initFn_22b6= SFC::Function::Cast( initFn_22b1);
		if( false== Uml::IsDerivedFrom( initIdx_22ba.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar initIdx_22bf= SFC::LocalVar::Cast( initIdx_22ba);
		set< SFC::Var> vars_22c1= program_22ad.Var_kind_children();
		for( set< SFC::Var>::const_iterator itVar_22c2= vars_22c1.begin(); itVar_22c2!= vars_22c1.end(); ++itVar_22c2)
		{
			SFC::Var currVar_22c3= *itVar_22c2;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_22c7;
			if( !isValidBound(boundObjs_22c7, program_22ad, true))
				continue;
			currMatch.program_22c8= program_22ad;
			if( !isValidBound(boundObjs_22c7, initFn_22b6, true))
				continue;
			currMatch.initFn_22c9= initFn_22b6;
			if( !isValidBound(boundObjs_22c7, initIdx_22bf, true))
				continue;
			currMatch.initIdx_22ca= initIdx_22bf;
			if( !isValidBound(boundObjs_22c7, currVar_22c3, false))
				continue;
			currMatch.var_22cb= currVar_22c3;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetSortedVars_2299::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.var_22cb, currMatch.initFn_22c9, currMatch.initIdx_22ca);
	}
}

void GetSortedVars_2299::outputAppender( const SFC::Var& var_22cc, const SFC::Function& initFn_22ce, const SFC::LocalVar& initIdx_22d0)
{
	_var_22a3->push_back( var_22cc);
	_initFn_22a4->push_back( initFn_22ce);
	_initIdx_22a5->push_back( initIdx_22d0);
}

void GetSortedVars_2299::sortOutputs()
{
	typedef std::multiset< SFC::Var, std::pointer_to_binary_function< const SFC::Var&, const SFC::Var&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const SFC::Var&, const SFC::Var&, bool> ptr_StatementOrder( StatementOrder< SFC::Var>);
	SortedSet_t sortedSet( ptr_StatementOrder);
	std::vector< int> permutationVector( _var_22a3->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _var_22a3->begin(); it!= _var_22a3->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( SFC::Var::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _var_22a3->begin());
	// order rest of the containers
	permutate( permutationVector, *_initFn_22a4);
	permutate( permutationVector, *_initIdx_22a5);
}

void InitArrayVar_22d2::operator()( const Packets_t& vars_22d3, const Packets_t& initFns_22d5, const Packets_t& idxVars_22d7)
{
#ifdef PRINT_INFO
	printLog( "InitArrayVar_22d2" );
#endif
	RTTGenerator::Instance()->generateRule(1633, "InitArrayVar");
	processInputPackets( vars_22d3, initFns_22d5, idxVars_22d7);
}

bool InitArrayVar_22d2::isInputUnique( const Udm::Object& var_22dd, const Udm::Object& initFn_22e6, const Udm::Object& idxVar_22ef)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itVar_22df= _var_22d9.begin(), itInitFn_22e8= _initFn_22e2.begin(), itIdxVar_22f1= _idxVar_22eb.begin(); itVar_22df!= _var_22d9.end(), itInitFn_22e8!= _initFn_22e2.end(), itIdxVar_22f1!= _idxVar_22eb.end(); ++itVar_22df, ++itInitFn_22e8, ++itIdxVar_22f1)
	{
		if( ( *itVar_22df== var_22dd)&& ( *itInitFn_22e8== initFn_22e6)&& ( *itIdxVar_22f1== idxVar_22ef))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_var_22d9.push_back( var_22dd);
		_initFn_22e2.push_back( initFn_22e6);
		_idxVar_22eb.push_back( idxVar_22ef);
	}
	return isUnique;
}

bool InitArrayVar_22d2::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void InitArrayVar_22d2::processInputPackets( const Packets_t& vars_22d3, const Packets_t& initFns_22d5, const Packets_t& idxVars_22d7)
{
	for( Packets_t::const_iterator itVar_22da= vars_22d3.begin(), itInitFn_22e3= initFns_22d5.begin(), itIdxVar_22ec= idxVars_22d7.begin(); itVar_22da!= vars_22d3.end(), itInitFn_22e3!= initFns_22d5.end(), itIdxVar_22ec!= idxVars_22d7.end(); ++itVar_22da, ++itInitFn_22e3, ++itIdxVar_22ec)
	{
		bool isUnique= isInputUnique( *itVar_22da, *itInitFn_22e3, *itIdxVar_22ec);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itVar_22da, *itInitFn_22e3, *itIdxVar_22ec);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InitArrayVar_22d2::patternMatcher( const Udm::Object& var_22db, const Udm::Object& initFn_22e4, const Udm::Object& idxVar_22ed)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( var_22db.type(), SFC::Var::meta))
			continue;
		SFC::Var var_22e0= SFC::Var::Cast( var_22db);
		if( false== Uml::IsDerivedFrom( initFn_22e4.type(), SFC::Function::meta))
			continue;
		SFC::Function initFn_22e9= SFC::Function::Cast( initFn_22e4);
		if( false== Uml::IsDerivedFrom( idxVar_22ed.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar idxVar_22f2= SFC::LocalVar::Cast( idxVar_22ed);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_22f7;
		if( !isValidBound(boundObjs_22f7, var_22e0, true))
			continue;
		currMatch.var_22f8= var_22e0;
		if( !isValidBound(boundObjs_22f7, initFn_22e9, true))
			continue;
		currMatch.initFn_22f9= initFn_22e9;
		if( !isValidBound(boundObjs_22f7, idxVar_22f2, true))
			continue;
		currMatch.idxVar_22fa= idxVar_22f2;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void InitArrayVar_22d2::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newInitIdxVar_22fb= SFC::UserCode::Create( currMatch.initFn_22f9);
		SFC::BinaryExprs newopAssign_22fc= SFC::BinaryExprs::Create( newInitIdxVar_22fb, SFC::UserCode::meta_codeexpr);
		SFC::Int newzeroVal_22fd= SFC::Int::Create( newopAssign_22fc, SFC::BinaryExprs::meta_rightexpr);
		SFC::IterativeBlock newloopBlock_22fe= SFC::IterativeBlock::Create( currMatch.initFn_22f9);
		SFC::UserCode newincIdxVar_22ff= SFC::UserCode::Create( newloopBlock_22fe, SFC::IterativeBlock::meta_stmnt);
		SFC::UnaryExprs newopInc_2300= SFC::UnaryExprs::Create( newincIdxVar_22ff, SFC::UserCode::meta_codeexpr);
		SFC::UserCode newloopCond_2301= SFC::UserCode::Create( newloopBlock_22fe, SFC::IterativeBlock::meta_cond);
		SFC::BinaryExprs newopLe_2302= SFC::BinaryExprs::Create( newloopCond_2301, SFC::UserCode::meta_codeexpr);
		SFC::Int newloopBound_2303= SFC::Int::Create( newopLe_2302, SFC::BinaryExprs::meta_rightexpr);
		SFC::UserCode newloopAction_2304= SFC::UserCode::Create( newloopBlock_22fe, SFC::IterativeBlock::meta_stmnt);
		SFC::ArgDeclRef newidxVarRef_2305= SFC::ArgDeclRef::Create( newopAssign_22fc, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newidxVarRef2_2306= SFC::ArgDeclRef::Create( newopInc_2300, SFC::UnaryExprs::meta_subexpr);
		SFC::ArgDeclRef newidxVarRef3_2307= SFC::ArgDeclRef::Create( newopLe_2302, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newVarAssign_2308= SFC::BinaryExprs::Create( newloopAction_2304, SFC::UserCode::meta_codeexpr);
		SFC::Int newZero_2309= SFC::Int::Create( newVarAssign_2308, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newVarIndexOp_230a= SFC::BinaryExprs::Create( newVarAssign_2308, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newidxVarRef4_230b= SFC::ArgDeclRef::Create( newVarIndexOp_230a, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newVarRef_230c= SFC::ArgDeclRef::Create( newVarIndexOp_230a, SFC::BinaryExprs::meta_leftexpr);
		SFC::LocalVar& IdxVar= currMatch.idxVar_22fa;
		SFC::Function& InitFn= currMatch.initFn_22f9;
		SFC::UserCode& InitIdxVar= newInitIdxVar_22fb;
		SFC::Var& Var= currMatch.var_22f8;
		SFC::BinaryExprs& VarAssign= newVarAssign_2308;
		SFC::BinaryExprs& VarIndexOp= newVarIndexOp_230a;
		SFC::ArgDeclRef& VarRef= newVarRef_230c;
		SFC::Int& Zero= newZero_2309;
		SFC::ArgDeclRef& idxVarRef= newidxVarRef_2305;
		SFC::ArgDeclRef& idxVarRef2= newidxVarRef2_2306;
		SFC::ArgDeclRef& idxVarRef3= newidxVarRef3_2307;
		SFC::ArgDeclRef& idxVarRef4= newidxVarRef4_230b;
		SFC::UserCode& incIdxVar= newincIdxVar_22ff;
		SFC::UserCode& loopAction= newloopAction_2304;
		SFC::IterativeBlock& loopBlock= newloopBlock_22fe;
		SFC::Int& loopBound= newloopBound_2303;
		SFC::UserCode& loopCond= newloopCond_2301;
		SFC::BinaryExprs& opAssign= newopAssign_22fc;
		SFC::UnaryExprs& opInc= newopInc_2300;
		SFC::BinaryExprs& opLe= newopLe_2302;
		SFC::Int& zeroVal= newzeroVal_22fd;
		{
InitIdxVar.RefId() = loopBlock.RefId() = loopCond.RefId() = incIdxVar.RefId() = InitFn.RefId();
loopAction.RefId() = Var.RefId();
};
		{
Zero.val() = 0;
};
		{
__int64 sc;
sc = loopBlock.statementCount();
loopAction.statementIndex() = sc++;
incIdxVar.statementIndex() = sc++;
loopBlock.statementCount() = sc;
};
		{
__int64 sc;
sc = InitFn.statementCount();
InitIdxVar.statementIndex() = sc++;
loopBlock.statementIndex() = sc++;
InitFn.statementCount() = sc;
};
		{
opAssign.op() = string("=");
opInc.op() = string("++");
opLe.op() = string("<");
};
		{
zeroVal.val() = 0;
loopBound.val() = Var.size();
};
		{
loopAction.expr() = "";

VarAssign.op() = "=";
VarIndexOp.op() = "[";
VarRef.unres() = "";
idxVarRef4.unres() = "";

};
		{
idxVarRef.unres() = "";
idxVarRef2.unres() = "";
idxVarRef3.unres() = "";

};
		newidxVarRef_2305.argdecl()= currMatch.idxVar_22fa;
		newidxVarRef2_2306.argdecl()= currMatch.idxVar_22fa;
		newidxVarRef3_2307.argdecl()= currMatch.idxVar_22fa;
		newidxVarRef4_230b.argdecl()= currMatch.idxVar_22fa;
		newVarRef_230c.argdecl()= currMatch.var_22f8;
	}
}

void ArrayVars_230d::operator()( const Packets_t& programs_230e, const Packets_t& initFns_2310, const Packets_t& initIdxs_2312, Packets_t& vars_2314, Packets_t& initfns_2315, Packets_t& initidxs_2316, Packets_t& vars_2317, Packets_t& initfns_2318, Packets_t& initidxs_2319)
{
#ifdef PRINT_INFO
	printLog( "ArrayVars_230d" );
#endif
	_var_231a= &vars_2314;
	_initfn_231b= &initfns_2315;
	_initidx_231c= &initidxs_2316;
	_var_231d= &vars_2317;
	_initfn_231e= &initfns_2318;
	_initidx_231f= &initidxs_2319;
	for( Packets_t::const_iterator itprogram_2321= programs_230e.begin(), itinitFn_2328= initFns_2310.begin(), itinitIdx_232f= initIdxs_2312.begin(); itprogram_2321!= programs_230e.end(), itinitFn_2328!= initFns_2310.end(), itinitIdx_232f!= initIdxs_2312.end(); ++itprogram_2321, ++itinitFn_2328, ++itinitIdx_232f)
	{
		bool isUnique= isInputUnique( *itprogram_2321, *itinitFn_2328, *itinitIdx_232f);
		if( !isUnique)
			continue;
		Packets_t oneprogram_2325( 1, *itprogram_2321);
		Packets_t oneinitFn_232c( 1, *itinitFn_2328);
		Packets_t oneinitIdx_2333( 1, *itinitIdx_232f);
		executeOne( oneprogram_2325, oneinitFn_232c, oneinitIdx_2333);
	}
}

void ArrayVars_230d::executeOne( const Packets_t& programs_230e, const Packets_t& initFns_2310, const Packets_t& initIdxs_2312)
{
	Packets_t vars_2338;
	Packets_t initFns_233b;
	Packets_t initIdxs_233e;
	ArrayVar_2335 arrayVar_2335;
	bool isMatchArrayVar_2335= arrayVar_2335( programs_230e, initFns_2310, initIdxs_2312, vars_2338, initFns_233b, initIdxs_233e);
	_var_231a->insert( _var_231a->end(), vars_2338.begin(), vars_2338.end());
	_initfn_231b->insert( _initfn_231b->end(), initFns_233b.begin(), initFns_233b.end());
	_initidx_231c->insert( _initidx_231c->end(), initIdxs_233e.begin(), initIdxs_233e.end());
	if( isMatchArrayVar_2335)
		return;
	Packets_t vars_2370;
	Packets_t initFns_2373;
	Packets_t initIdxs_2376;
	Otherwise_236d otherwise_236d;
	bool isMatchOtherwise_236d= otherwise_236d( programs_230e, initFns_2310, initIdxs_2312, vars_2370, initFns_2373, initIdxs_2376);
	_var_231d->insert( _var_231d->end(), vars_2370.begin(), vars_2370.end());
	_initfn_231e->insert( _initfn_231e->end(), initFns_2373.begin(), initFns_2373.end());
	_initidx_231f->insert( _initidx_231f->end(), initIdxs_2376.begin(), initIdxs_2376.end());
	if( isMatchOtherwise_236d)
		return;
}

bool ArrayVars_230d::isInputUnique( const Udm::Object& program_2322, const Udm::Object& initFn_2329, const Udm::Object& initIdx_2330)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itprogram_2324= _program_2320.begin(), itinitFn_232b= _initFn_2327.begin(), itinitIdx_2332= _initIdx_232e.begin(); itprogram_2324!= _program_2320.end(), itinitFn_232b!= _initFn_2327.end(), itinitIdx_2332!= _initIdx_232e.end(); ++itprogram_2324, ++itinitFn_232b, ++itinitIdx_2332)
	{
		if( ( *itprogram_2324== program_2322)&& ( *itinitFn_232b== initFn_2329)&& ( *itinitIdx_2332== initIdx_2330))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_program_2320.push_back( program_2322);
		_initFn_2327.push_back( initFn_2329);
		_initIdx_232e.push_back( initIdx_2330);
	}
	return isUnique;
}

bool ArrayVar_2335::operator()( const Packets_t& vars_2336, const Packets_t& initFns_2339, const Packets_t& initIdxs_233c, Packets_t& vars_2338, Packets_t& initFns_233b, Packets_t& initIdxs_233e)
{
#ifdef PRINT_INFO
	printLog( "ArrayVar_2335" );
#endif
	_var_233f= &vars_2338;
	_initFn_2340= &initFns_233b;
	_initIdx_2341= &initIdxs_233e;
	processInputPackets( vars_2336, initFns_2339, initIdxs_233c);
	sortOutputs( );
	if( false== _matches.empty())
		return true;
	return false;
}

bool ArrayVar_2335::isInputUnique( const Udm::Object& var_2346, const Udm::Object& initFn_234f, const Udm::Object& initIdx_2358)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itVar_2348= _var_2342.begin(), itInitFn_2351= _initFn_234b.begin(), itInitIdx_235a= _initIdx_2354.begin(); itVar_2348!= _var_2342.end(), itInitFn_2351!= _initFn_234b.end(), itInitIdx_235a!= _initIdx_2354.end(); ++itVar_2348, ++itInitFn_2351, ++itInitIdx_235a)
	{
		if( ( *itVar_2348== var_2346)&& ( *itInitFn_2351== initFn_234f)&& ( *itInitIdx_235a== initIdx_2358))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_var_2342.push_back( var_2346);
		_initFn_234b.push_back( initFn_234f);
		_initIdx_2354.push_back( initIdx_2358);
	}
	return isUnique;
}

bool ArrayVar_2335::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool ArrayVar_2335::isGuardTrue( SFC::Function& InitFn, SFC::LocalVar& InitIdx, SFC::Var& Var)
{
	bool Gz_guard= false;
	__int64 sz = Var.size();
const Udm::Object& o = Var;
Gz_guard = (sz > 1) || Udm::IsDerivedFrom(o.type(), SFC::StateVar::meta);;
	return Gz_guard;
}

void ArrayVar_2335::processInputPackets( const Packets_t& vars_2336, const Packets_t& initFns_2339, const Packets_t& initIdxs_233c)
{
	for( Packets_t::const_iterator itVar_2343= vars_2336.begin(), itInitFn_234c= initFns_2339.begin(), itInitIdx_2355= initIdxs_233c.begin(); itVar_2343!= vars_2336.end(), itInitFn_234c!= initFns_2339.end(), itInitIdx_2355!= initIdxs_233c.end(); ++itVar_2343, ++itInitFn_234c, ++itInitIdx_2355)
	{
		bool isUnique= isInputUnique( *itVar_2343, *itInitFn_234c, *itInitIdx_2355);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itVar_2343, *itInitFn_234c, *itInitIdx_2355);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.var_2361, currMatch.initFn_2362, currMatch.initIdx_2363);
	}
}

bool ArrayVar_2335::patternMatcher( const Udm::Object& var_2344, const Udm::Object& initFn_234d, const Udm::Object& initIdx_2356)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( var_2344.type(), SFC::Var::meta))
			continue;
		SFC::Var var_2349= SFC::Var::Cast( var_2344);
		if( false== Uml::IsDerivedFrom( initFn_234d.type(), SFC::Function::meta))
			continue;
		SFC::Function initFn_2352= SFC::Function::Cast( initFn_234d);
		if( false== Uml::IsDerivedFrom( initIdx_2356.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar initIdx_235b= SFC::LocalVar::Cast( initIdx_2356);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2360;
		if( !isValidBound(boundObjs_2360, var_2349, true))
			continue;
		currMatch.var_2361= var_2349;
		if( !isValidBound(boundObjs_2360, initFn_2352, true))
			continue;
		currMatch.initFn_2362= initFn_2352;
		if( !isValidBound(boundObjs_2360, initIdx_235b, true))
			continue;
		currMatch.initIdx_2363= initIdx_235b;
		bool Gz_guard= isGuardTrue( currMatch.initFn_2362, currMatch.initIdx_2363, currMatch.var_2361);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void ArrayVar_2335::outputAppender( const SFC::Var& var_2367, const SFC::Function& initFn_2369, const SFC::LocalVar& initIdx_236b)
{
	_var_233f->push_back( var_2367);
	_initFn_2340->push_back( initFn_2369);
	_initIdx_2341->push_back( initIdx_236b);
}

void ArrayVar_2335::sortOutputs()
{
	typedef std::multiset< SFC::Var, std::pointer_to_binary_function< const SFC::Var&, const SFC::Var&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const SFC::Var&, const SFC::Var&, bool> ptr_StatementOrder( StatementOrder< SFC::Var>);
	SortedSet_t sortedSet( ptr_StatementOrder);
	std::vector< int> permutationVector( _var_233f->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _var_233f->begin(); it!= _var_233f->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( SFC::Var::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _var_233f->begin());
	// order rest of the containers
	permutate( permutationVector, *_initFn_2340);
	permutate( permutationVector, *_initIdx_2341);
}

bool Otherwise_236d::operator()( const Packets_t& vars_236e, const Packets_t& initFns_2371, const Packets_t& initIdxs_2374, Packets_t& vars_2370, Packets_t& initFns_2373, Packets_t& initIdxs_2376)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_236d" );
#endif
	_var_2377= &vars_2370;
	_initFn_2378= &initFns_2373;
	_initIdx_2379= &initIdxs_2376;
	processInputPackets( vars_236e, initFns_2371, initIdxs_2374);
	sortOutputs( );
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_236d::isInputUnique( const Udm::Object& var_237e, const Udm::Object& initFn_2387, const Udm::Object& initIdx_2390)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itVar_2380= _var_237a.begin(), itInitFn_2389= _initFn_2383.begin(), itInitIdx_2392= _initIdx_238c.begin(); itVar_2380!= _var_237a.end(), itInitFn_2389!= _initFn_2383.end(), itInitIdx_2392!= _initIdx_238c.end(); ++itVar_2380, ++itInitFn_2389, ++itInitIdx_2392)
	{
		if( ( *itVar_2380== var_237e)&& ( *itInitFn_2389== initFn_2387)&& ( *itInitIdx_2392== initIdx_2390))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_var_237a.push_back( var_237e);
		_initFn_2383.push_back( initFn_2387);
		_initIdx_238c.push_back( initIdx_2390);
	}
	return isUnique;
}

bool Otherwise_236d::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_236d::processInputPackets( const Packets_t& vars_236e, const Packets_t& initFns_2371, const Packets_t& initIdxs_2374)
{
	for( Packets_t::const_iterator itVar_237b= vars_236e.begin(), itInitFn_2384= initFns_2371.begin(), itInitIdx_238d= initIdxs_2374.begin(); itVar_237b!= vars_236e.end(), itInitFn_2384!= initFns_2371.end(), itInitIdx_238d!= initIdxs_2374.end(); ++itVar_237b, ++itInitFn_2384, ++itInitIdx_238d)
	{
		bool isUnique= isInputUnique( *itVar_237b, *itInitFn_2384, *itInitIdx_238d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itVar_237b, *itInitFn_2384, *itInitIdx_238d);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.var_2399, currMatch.initFn_239a, currMatch.initIdx_239b);
	}
}

bool Otherwise_236d::patternMatcher( const Udm::Object& var_237c, const Udm::Object& initFn_2385, const Udm::Object& initIdx_238e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( var_237c.type(), SFC::Var::meta))
			continue;
		SFC::Var var_2381= SFC::Var::Cast( var_237c);
		if( false== Uml::IsDerivedFrom( initFn_2385.type(), SFC::Function::meta))
			continue;
		SFC::Function initFn_238a= SFC::Function::Cast( initFn_2385);
		if( false== Uml::IsDerivedFrom( initIdx_238e.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar initIdx_2393= SFC::LocalVar::Cast( initIdx_238e);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2398;
		if( !isValidBound(boundObjs_2398, var_2381, true))
			continue;
		currMatch.var_2399= var_2381;
		if( !isValidBound(boundObjs_2398, initFn_238a, true))
			continue;
		currMatch.initFn_239a= initFn_238a;
		if( !isValidBound(boundObjs_2398, initIdx_2393, true))
			continue;
		currMatch.initIdx_239b= initIdx_2393;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_236d::outputAppender( const SFC::Var& var_239c, const SFC::Function& initFn_239e, const SFC::LocalVar& initIdx_23a0)
{
	_var_2377->push_back( var_239c);
	_initFn_2378->push_back( initFn_239e);
	_initIdx_2379->push_back( initIdx_23a0);
}

void Otherwise_236d::sortOutputs()
{
	typedef std::multiset< SFC::Var, std::pointer_to_binary_function< const SFC::Var&, const SFC::Var&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const SFC::Var&, const SFC::Var&, bool> ptr_StatementOrder( StatementOrder< SFC::Var>);
	SortedSet_t sortedSet( ptr_StatementOrder);
	std::vector< int> permutationVector( _var_2377->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _var_2377->begin(); it!= _var_2377->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( SFC::Var::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _var_2377->begin());
	// order rest of the containers
	permutate( permutationVector, *_initFn_2378);
	permutate( permutationVector, *_initIdx_2379);
}

void InitScalarVar_23a2::operator()( const Packets_t& vars_23a3, const Packets_t& initFns_23a5, const Packets_t& idxVars_23a7)
{
#ifdef PRINT_INFO
	printLog( "InitScalarVar_23a2" );
#endif
	RTTGenerator::Instance()->generateRule(1704, "InitScalarVar");
	processInputPackets( vars_23a3, initFns_23a5, idxVars_23a7);
}

bool InitScalarVar_23a2::isInputUnique( const Udm::Object& var_23ad, const Udm::Object& initFn_23b6, const Udm::Object& idxVar_23bf)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itVar_23af= _var_23a9.begin(), itInitFn_23b8= _initFn_23b2.begin(), itIdxVar_23c1= _idxVar_23bb.begin(); itVar_23af!= _var_23a9.end(), itInitFn_23b8!= _initFn_23b2.end(), itIdxVar_23c1!= _idxVar_23bb.end(); ++itVar_23af, ++itInitFn_23b8, ++itIdxVar_23c1)
	{
		if( ( *itVar_23af== var_23ad)&& ( *itInitFn_23b8== initFn_23b6)&& ( *itIdxVar_23c1== idxVar_23bf))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_var_23a9.push_back( var_23ad);
		_initFn_23b2.push_back( initFn_23b6);
		_idxVar_23bb.push_back( idxVar_23bf);
	}
	return isUnique;
}

bool InitScalarVar_23a2::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void InitScalarVar_23a2::processInputPackets( const Packets_t& vars_23a3, const Packets_t& initFns_23a5, const Packets_t& idxVars_23a7)
{
	for( Packets_t::const_iterator itVar_23aa= vars_23a3.begin(), itInitFn_23b3= initFns_23a5.begin(), itIdxVar_23bc= idxVars_23a7.begin(); itVar_23aa!= vars_23a3.end(), itInitFn_23b3!= initFns_23a5.end(), itIdxVar_23bc!= idxVars_23a7.end(); ++itVar_23aa, ++itInitFn_23b3, ++itIdxVar_23bc)
	{
		bool isUnique= isInputUnique( *itVar_23aa, *itInitFn_23b3, *itIdxVar_23bc);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itVar_23aa, *itInitFn_23b3, *itIdxVar_23bc);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InitScalarVar_23a2::patternMatcher( const Udm::Object& var_23ab, const Udm::Object& initFn_23b4, const Udm::Object& idxVar_23bd)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( var_23ab.type(), SFC::Var::meta))
			continue;
		SFC::Var var_23b0= SFC::Var::Cast( var_23ab);
		if( false== Uml::IsDerivedFrom( initFn_23b4.type(), SFC::Function::meta))
			continue;
		SFC::Function initFn_23b9= SFC::Function::Cast( initFn_23b4);
		if( false== Uml::IsDerivedFrom( idxVar_23bd.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar idxVar_23c2= SFC::LocalVar::Cast( idxVar_23bd);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_23c7;
		if( !isValidBound(boundObjs_23c7, var_23b0, true))
			continue;
		currMatch.var_23c8= var_23b0;
		if( !isValidBound(boundObjs_23c7, initFn_23b9, true))
			continue;
		currMatch.initFn_23c9= initFn_23b9;
		if( !isValidBound(boundObjs_23c7, idxVar_23c2, true))
			continue;
		currMatch.idxVar_23ca= idxVar_23c2;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void InitScalarVar_23a2::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar& IdxVar= currMatch.idxVar_23ca;
		SFC::Function& InitFn= currMatch.initFn_23c9;
		SFC::Var& Var= currMatch.var_23c8;
		{
SFManager::initVar( InitFn, Var );
};
	}
}

void TestEAIOn_23db::operator()( const Packets_t& states_23dc, const Packets_t& initfns_23de, Packets_t& states_23e0, Packets_t& initfns_23e1)
{
#ifdef PRINT_INFO
	printLog( "TestEAIOn_23db" );
#endif
	_state_23e2= &states_23e0;
	_initfn_23e3= &initfns_23e1;
	for( Packets_t::const_iterator itstate_23e5= states_23dc.begin(), itinitfn_23ec= initfns_23de.begin(); itstate_23e5!= states_23dc.end(), itinitfn_23ec!= initfns_23de.end(); ++itstate_23e5, ++itinitfn_23ec)
	{
		bool isUnique= isInputUnique( *itstate_23e5, *itinitfn_23ec);
		if( !isUnique)
			continue;
		Packets_t onestate_23e9( 1, *itstate_23e5);
		Packets_t oneinitfn_23f0( 1, *itinitfn_23ec);
		executeOne( onestate_23e9, oneinitfn_23f0);
	}
}

void TestEAIOn_23db::executeOne( const Packets_t& states_23dc, const Packets_t& initfns_23de)
{
	Packets_t states_23f5;
	Packets_t initFns_23f8;
	EAIOn_23f2 eAIOn_23f2;
	bool isMatchEAIOn_23f2= eAIOn_23f2( states_23dc, initfns_23de, states_23f5, initFns_23f8);
	_state_23e2->insert( _state_23e2->end(), states_23f5.begin(), states_23f5.end());
	_initfn_23e3->insert( _initfn_23e3->end(), initFns_23f8.begin(), initFns_23f8.end());
}

bool TestEAIOn_23db::isInputUnique( const Udm::Object& state_23e6, const Udm::Object& initfn_23ed)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_23e8= _state_23e4.begin(), itinitfn_23ef= _initfn_23eb.begin(); itstate_23e8!= _state_23e4.end(), itinitfn_23ef!= _initfn_23eb.end(); ++itstate_23e8, ++itinitfn_23ef)
	{
		if( ( *itstate_23e8== state_23e6)&& ( *itinitfn_23ef== initfn_23ed))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_23e4.push_back( state_23e6);
		_initfn_23eb.push_back( initfn_23ed);
	}
	return isUnique;
}

bool EAIOn_23f2::operator()( const Packets_t& states_23f3, const Packets_t& initFns_23f6, Packets_t& states_23f5, Packets_t& initFns_23f8)
{
#ifdef PRINT_INFO
	printLog( "EAIOn_23f2" );
#endif
	_state_23f9= &states_23f5;
	_initFn_23fa= &initFns_23f8;
	processInputPackets( states_23f3, initFns_23f6);
	if( false== _matches.empty())
		return true;
	return false;
}

bool EAIOn_23f2::isInputUnique( const Udm::Object& state_23ff, const Udm::Object& initFn_2408)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_2401= _state_23fb.begin(), itInitFn_240a= _initFn_2404.begin(); itState_2401!= _state_23fb.end(), itInitFn_240a!= _initFn_2404.end(); ++itState_2401, ++itInitFn_240a)
	{
		if( ( *itState_2401== state_23ff)&& ( *itInitFn_240a== initFn_2408))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_23fb.push_back( state_23ff);
		_initFn_2404.push_back( initFn_2408);
	}
	return isUnique;
}

bool EAIOn_23f2::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool EAIOn_23f2::isGuardTrue( CyberComposition::Simulink::ConnectorRef& ConnectorRef, SFC::Function& InitFn, CyberComposition::Simulink::SF_Parameter& Parameter, CyberComposition::Simulink::Primitive& Primitive, CyberComposition::Simulink::State& State, CyberComposition::Simulink::Subsystem& Subsystem)
{
	bool Gz_guard= false;
	return static_cast< std::string >( Parameter.name() ) == "ExecuteAtInitialization" &&
 static_cast< std::string >(  Parameter.Value() ) == "on";;
	return Gz_guard;
}

void EAIOn_23f2::processInputPackets( const Packets_t& states_23f3, const Packets_t& initFns_23f6)
{
	for( Packets_t::const_iterator itState_23fc= states_23f3.begin(), itInitFn_2405= initFns_23f6.begin(); itState_23fc!= states_23f3.end(), itInitFn_2405!= initFns_23f6.end(); ++itState_23fc, ++itInitFn_2405)
	{
		bool isUnique= isInputUnique( *itState_23fc, *itInitFn_2405);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_23fc, *itInitFn_2405);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_241b, currMatch.initFn_241c);
	}
}

bool EAIOn_23f2::patternMatcher( const Udm::Object& state_23fd, const Udm::Object& initFn_2406)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_23fd.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_2402= CyberComposition::Simulink::State::Cast( state_23fd);
		if( false== Uml::IsDerivedFrom( initFn_2406.type(), SFC::Function::meta))
			continue;
		SFC::Function initFn_240b= SFC::Function::Cast( initFn_2406);
		set< CyberComposition::Simulink::ConnectorRef> connectorRefs_240d= state_2402.referedbyConnectorRef();
		for( set< CyberComposition::Simulink::ConnectorRef>::const_iterator itConnectorRefs_240e= connectorRefs_240d.begin(); itConnectorRefs_240e!= connectorRefs_240d.end(); ++itConnectorRefs_240e)
		{
			CyberComposition::Simulink::ConnectorRef currConnectorRef_240f= *itConnectorRefs_240e;
			Udm::Object connectorRefParent_2410= currConnectorRef_240f.container();
			if( false== Uml::IsDerivedFrom( connectorRefParent_2410.type(), CyberComposition::Simulink::Primitive::meta))
				continue;
			CyberComposition::Simulink::Primitive primitiveConnectorRef_2411= CyberComposition::Simulink::Primitive::Cast( connectorRefParent_2410);
			Udm::Object primitiveParent_2412= primitiveConnectorRef_2411.container();
			if( false== Uml::IsDerivedFrom( primitiveParent_2412.type(), CyberComposition::Simulink::Subsystem::meta))
				continue;
			CyberComposition::Simulink::Subsystem subsystemPrimitive_2413= CyberComposition::Simulink::Subsystem::Cast( primitiveParent_2412);
			set< CyberComposition::Simulink::SF_Parameter> parameters_2414= subsystemPrimitive_2413.SF_Parameter_kind_children();
			for( set< CyberComposition::Simulink::SF_Parameter>::const_iterator itParameter_2415= parameters_2414.begin(); itParameter_2415!= parameters_2414.end(); ++itParameter_2415)
			{
				CyberComposition::Simulink::SF_Parameter currParameter_2416= *itParameter_2415;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_241a;
				if( !isValidBound(boundObjs_241a, state_2402, true))
					continue;
				currMatch.state_241b= state_2402;
				if( !isValidBound(boundObjs_241a, initFn_240b, true))
					continue;
				currMatch.initFn_241c= initFn_240b;
				if( !isValidBound(boundObjs_241a, currConnectorRef_240f, false))
					continue;
				currMatch.connectorRef_241d= currConnectorRef_240f;
				if( !isValidBound(boundObjs_241a, primitiveConnectorRef_2411, false))
					continue;
				currMatch.primitive_241e= primitiveConnectorRef_2411;
				if( !isValidBound(boundObjs_241a, currParameter_2416, false))
					continue;
				currMatch.parameter_241f= currParameter_2416;
				if( !isValidBound(boundObjs_241a, subsystemPrimitive_2413, false))
					continue;
				currMatch.subsystem_2420= subsystemPrimitive_2413;
				bool Gz_guard= isGuardTrue( currMatch.connectorRef_241d, currMatch.initFn_241c, currMatch.parameter_241f, currMatch.primitive_241e, currMatch.state_241b, currMatch.subsystem_2420);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void EAIOn_23f2::outputAppender( const CyberComposition::Simulink::State& state_2427, const SFC::Function& initFn_2429)
{
	_state_23f9->push_back( state_2427);
	_initFn_23fa->push_back( initFn_2429);
}

void MarkLegacy_243c::operator()( const Packets_t& states_243d, const Packets_t& programs_243f)
{
#ifdef PRINT_INFO
	printLog( "MarkLegacy_243c" );
#endif
	RTTGenerator::Instance()->generateRule(1725, "MarkLegacy");
	processInputPackets( states_243d, programs_243f);
}

bool MarkLegacy_243c::isInputUnique( const Udm::Object& state_2445, const Udm::Object& program_244e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_2447= _state_2441.begin(), itProgram_2450= _program_244a.begin(); itState_2447!= _state_2441.end(), itProgram_2450!= _program_244a.end(); ++itState_2447, ++itProgram_2450)
	{
		if( ( *itState_2447== state_2445)&& ( *itProgram_2450== program_244e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_2441.push_back( state_2445);
		_program_244a.push_back( program_244e);
	}
	return isUnique;
}

bool MarkLegacy_243c::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void MarkLegacy_243c::processInputPackets( const Packets_t& states_243d, const Packets_t& programs_243f)
{
	for( Packets_t::const_iterator itState_2442= states_243d.begin(), itProgram_244b= programs_243f.begin(); itState_2442!= states_243d.end(), itProgram_244b!= programs_243f.end(); ++itState_2442, ++itProgram_244b)
	{
		bool isUnique= isInputUnique( *itState_2442, *itProgram_244b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_2442, *itProgram_244b);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool MarkLegacy_243c::patternMatcher( const Udm::Object& state_2443, const Udm::Object& program_244c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_2443.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_2448= CyberComposition::Simulink::State::Cast( state_2443);
		if( false== Uml::IsDerivedFrom( program_244c.type(), SFC::Program::meta))
			continue;
		SFC::Program program_2451= SFC::Program::Cast( program_244c);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2456;
		if( !isValidBound(boundObjs_2456, state_2448, true))
			continue;
		currMatch.state_2457= state_2448;
		if( !isValidBound(boundObjs_2456, program_2451, true))
			continue;
		currMatch.program_2458= program_2451;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void MarkLegacy_243c::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Program& Program= currMatch.program_2458;
		CyberComposition::Simulink::State& State= currMatch.state_2457;
		{
__int64 statementCount = Program.statementCount();
if ( statementCount > 0 ) statementCount = -statementCount;
Program.statementCount() = statementCount;
};
	}
}

void CreateFunctions_2459::operator()( const Packets_t& states_245a, const Packets_t& programs_245c, Packets_t& states_245e, Packets_t& programs_245f)
{
#ifdef PRINT_INFO
	printLog( "CreateFunctions_2459" );
#endif
	_state_2460= &states_245e;
	_program_2461= &programs_245f;
	_state_2460->insert( _state_2460->end(), states_245a.begin(), states_245a.end());
	_program_2461->insert( _program_2461->end(), programs_245c.begin(), programs_245c.end());
	if( ( !states_245a.empty())&& ( !programs_245c.empty()))
		callCreateFunctions_2495( states_245a, programs_245c);
}

void CreateFunctions_2459::callCreateFunctions_2495( const Packets_t& states_2463, const Packets_t& programs_2466)
{
	Packets_t states_2465;
	Packets_t programs_2468;
	CreateFunctions_2462 createFunctions_2462;
	createFunctions_2462( states_2463, programs_2466, states_2465, programs_2468);
	if( ( !states_2465.empty())&& ( !programs_2468.empty()))
		callGetSubStates_2498( states_2465, programs_2468);
}

void CreateFunctions_2459::callGetSubStates_2498( const Packets_t& states_c8c, const Packets_t& parStmnts_c8f)
{
	Packets_t subStates_c8e;
	Packets_t parStmnts_c91;
	GetSubStates_c8b getSubStates_c8b;
	getSubStates_c8b( states_c8c, parStmnts_c8f, subStates_c8e, parStmnts_c91);
	if( ( !subStates_c8e.empty())&& ( !parStmnts_c91.empty()))
		callCreateFunctions_2495( subStates_c8e, parStmnts_c91);
}

void CreateFunctions_2462::operator()( const Packets_t& states_2463, const Packets_t& programs_2466, Packets_t& states_2465, Packets_t& programs_2468)
{
#ifdef PRINT_INFO
	printLog( "CreateFunctions_2462" );
#endif
	RTTGenerator::Instance()->generateRule(1734, "CreateFunctions");
	_state_2469= &states_2465;
	_program_246a= &programs_2468;
	processInputPackets( states_2463, programs_2466);
	forwardInputs( );
}

bool CreateFunctions_2462::isInputUnique( const Udm::Object& state_246f, const Udm::Object& program_2478)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_2471= _state_246b.begin(), itProgram_247a= _program_2474.begin(); itState_2471!= _state_246b.end(), itProgram_247a!= _program_2474.end(); ++itState_2471, ++itProgram_247a)
	{
		if( ( *itState_2471== state_246f)&& ( *itProgram_247a== program_2478))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_246b.push_back( state_246f);
		_program_2474.push_back( program_2478);
	}
	return isUnique;
}

bool CreateFunctions_2462::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool CreateFunctions_2462::isGuardTrue( SFC::Program& Program, CyberComposition::Simulink::State& State, SFC::StateLabel& StateLabel)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( State.Decomposition() ) != "FUNC_STATE";;
	return Gz_guard;
}

void CreateFunctions_2462::processInputPackets( const Packets_t& states_2463, const Packets_t& programs_2466)
{
	for( Packets_t::const_iterator itState_246c= states_2463.begin(), itProgram_2475= programs_2466.begin(); itState_246c!= states_2463.end(), itProgram_2475!= programs_2466.end(); ++itState_246c, ++itProgram_2475)
	{
		bool isUnique= isInputUnique( *itState_246c, *itProgram_2475);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_246c, *itProgram_2475);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateFunctions_2462::patternMatcher( const Udm::Object& state_246d, const Udm::Object& program_2476)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_246d.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_2472= CyberComposition::Simulink::State::Cast( state_246d);
		if( false== Uml::IsDerivedFrom( program_2476.type(), SFC::Program::meta))
			continue;
		SFC::Program program_247b= SFC::Program::Cast( program_2476);
		set< SFC::StateLabel> stateLabels_247d= state_2472.src();
		for( set< SFC::StateLabel>::const_iterator itStateLabels_247e= stateLabels_247d.begin(); itStateLabels_247e!= stateLabels_247d.end(); ++itStateLabels_247e)
		{
			SFC::StateLabel currStateLabel_247f= *itStateLabels_247e;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2483;
			if( !isValidBound(boundObjs_2483, state_2472, true))
				continue;
			currMatch.state_2484= state_2472;
			if( !isValidBound(boundObjs_2483, program_247b, true))
				continue;
			currMatch.program_2485= program_247b;
			if( !isValidBound(boundObjs_2483, currStateLabel_247f, false))
				continue;
			currMatch.stateLabel_2486= currStateLabel_247f;
			bool Gz_guard= isGuardTrue( currMatch.program_2485, currMatch.state_2484, currMatch.stateLabel_2486);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateFunctions_2462::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function newStatus_248a= SFC::Function::Create( currMatch.program_2485, SFC::Program::meta_stmnt);
		SFC::Arg newIndentArg_248b= SFC::Arg::Create( newStatus_248a);
		SFC::Function newEnter_248c= SFC::Function::Create( currMatch.program_2485, SFC::Program::meta_stmnt);
		SFC::Arg newModeArg_248d= SFC::Arg::Create( newEnter_248c);
		SFC::Function newExec_248e= SFC::Function::Create( currMatch.program_2485, SFC::Program::meta_stmnt);
		SFC::LocalVar newExecTCVar_248f= SFC::LocalVar::Create( newExec_248e, SFC::Function::meta_stmnt);
		SFC::LocalVar newEnterTCVar_2490= SFC::LocalVar::Create( newEnter_248c, SFC::Function::meta_stmnt);
		SFC::Function newExit_2491= SFC::Function::Create( currMatch.program_2485, SFC::Program::meta_stmnt);
		SFC::Arg newTrParArg_2492= SFC::Arg::Create( newExit_2491);
		SFC::LocalVar newExecHTPVar_2493= SFC::LocalVar::Create( newExec_248e, SFC::Function::meta_stmnt);
		SFC::Arg newTrPathParArg_2494= SFC::Arg::Create( newEnter_248c);
		SFC::Function& Enter= newEnter_248c;
		SFC::LocalVar& EnterTCVar= newEnterTCVar_2490;
		SFC::Function& Exec= newExec_248e;
		SFC::LocalVar& ExecHTPVar= newExecHTPVar_2493;
		SFC::LocalVar& ExecTCVar= newExecTCVar_248f;
		SFC::Function& Exit= newExit_2491;
		SFC::Arg& IndentArg= newIndentArg_248b;
		SFC::Arg& ModeArg= newModeArg_248d;
		SFC::Program& Program= currMatch.program_2485;
		CyberComposition::Simulink::State& State= currMatch.state_2484;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_2486;
		SFC::Function& Status= newStatus_248a;
		SFC::Arg& TrParArg= newTrParArg_2492;
		SFC::Arg& TrPathParArg= newTrPathParArg_2494;
		{
__int64 statementCount = Program.statementCount();
Enter.statementIndex() = statementCount++;
Exec.statementIndex()  = statementCount++;
Exit.statementIndex()  = statementCount++;
Status.statementIndex()  = statementCount++;
Program.statementCount() = statementCount;
};
		{
__int64 statementCount = Enter.statementCount();
EnterTCVar.statementIndex() = statementCount++;
Enter.statementCount() = statementCount;
};
		{
__int64 statementCount = Exec.statementCount();
ExecTCVar.statementIndex() = statementCount++;
ExecHTPVar.statementIndex() = statementCount++;
Exec.statementCount() = statementCount;
};
		{
ModeArg.name() = "entryMode";
ModeArg.dt() = SFCTypesManager::getSingleton().getBasicType( "int" );
ModeArg.argIndex() = 0;

TrPathParArg.name() = "tpp";
TrPathParArg.dt() = SFCTypesManager::getSingleton().getBasicType( "int" );
TrPathParArg.argIndex() = 1;

Enter.argCount() = 2;
};
		{
Status.dt() = SFCTypesManager::getSingleton().getBasicType( "string" );
};
		{
TrParArg.name() = "_transitionParent_";
TrParArg.dt() = SFCTypesManager::getSingleton().getBasicType( "int" );
TrParArg.argIndex() = 0;

Exit.argCount() = 1;
};
		{
Enter.annotation() = State.Description();
};
		{
Enter.RefId() = Exec.RefId() = Exit.RefId() = Status.RefId() = EnterTCVar.RefId() = ExecHTPVar.RefId() = ExecTCVar.RefId() = ModeArg.RefId() = TrPathParArg.RefId() = TrParArg.RefId() = IndentArg.RefId() = State.RefId();
};
		{
EnterTCVar.name() = "_TCVar_";
EnterTCVar.dt() = SFCTypesManager::getSingleton().getBasicType( "int32" );
};
		{
__int64 argCount = Status.argCount();
IndentArg.argIndex() = argCount++;
Status.argCount() = argCount;

IndentArg.dt() = SFCTypesManager::getSingleton().getBasicType( "string" );
IndentArg.name() = "indent";
};
		{
std::string name = static_cast< std::string >( State.name() ) + "_" + boost::lexical_cast< std::string >( State.uniqueId() );
Enter.name() = name + "_enter";
Enter.scope() = StateLabel.comment();
Exec.name() = name + "_exec";
Exec.scope() = StateLabel.comment();
Exit.name() = name + "_exit";
Exit.scope() = StateLabel.comment();
Status.name() = name + "_status";
Status.scope() = StateLabel.comment();
};
		{
ExecHTPVar.name() = "_HTPVar_";
ExecHTPVar.dt() = SFCTypesManager::getSingleton().getBasicType( "int32" );
ExecTCVar.name() = "_TCVar_";
ExecTCVar.dt() = SFCTypesManager::getSingleton().getBasicType( "int32" );
};
		newEnter_248c.enterSt()+= currMatch.state_2484;
		newExit_2491.exitSt()+= currMatch.state_2484;
		newExec_248e.execSt()+= currMatch.state_2484;
		newStatus_248a.statusSt()+= currMatch.state_2484;
	}
}

void CreateFunctions_2462::forwardInputs()
{
	*_state_2469= _state_246b;
	*_program_246a= _program_2474;
}

void CreateDEVars_249b::operator()( const Packets_t& states_249c, const Packets_t& programs_249e, Packets_t& states_24a0, Packets_t& programs_24a1)
{
#ifdef PRINT_INFO
	printLog( "CreateDEVars_249b" );
#endif
	_state_24a2= &states_24a0;
	_program_24a3= &programs_24a1;
	if( ( !states_249c.empty())&& ( !programs_249e.empty()))
		callCheckStateDecomp_27d7( states_249c, programs_249e);
	_state_24a2->insert( _state_24a2->end(), states_249c.begin(), states_249c.end());
	_program_24a3->insert( _program_24a3->end(), programs_249e.begin(), programs_249e.end());
}

void CreateDEVars_249b::callCheckStateDecomp_27d7( const Packets_t& states_20a3, const Packets_t& programs_20a5)
{
	Packets_t states_20a7;
	Packets_t programs_20a8;
	Packets_t states_20a9;
	Packets_t programs_20aa;
	CheckStateDecomp_20a2 checkStateDecomp_20a2;
	checkStateDecomp_20a2( states_20a3, programs_20a5, states_20a7, programs_20a8, states_20a9, programs_20aa);
	if( ( !states_20a9.empty())&& ( !programs_20aa.empty()))
		callCreateDataVar_27da( states_20a9, programs_20aa);
	if( ( !states_20a7.empty())&& ( !programs_20a8.empty()))
		callGetSubStates_27dd( states_20a7, programs_20a8);
}

void CreateDEVars_249b::callCreateDataVar_27da( const Packets_t& states_24a5, const Packets_t& programs_24a7)
{
	Packets_t states_24a9;
	Packets_t programs_24aa;
	CreateDataVar_24a4 createDataVar_24a4;
	createDataVar_24a4( states_24a5, programs_24a7, states_24a9, programs_24aa);
	if( ( !states_24a9.empty())&& ( !programs_24aa.empty()))
		callCreateStoreVar_27e0( states_24a9, programs_24aa);
}

void CreateDEVars_249b::callGetSubStates_27dd( const Packets_t& states_c8c, const Packets_t& parStmnts_c8f)
{
	Packets_t subStates_c8e;
	Packets_t parStmnts_c91;
	GetSubStates_c8b getSubStates_c8b;
	getSubStates_c8b( states_c8c, parStmnts_c8f, subStates_c8e, parStmnts_c91);
	if( ( !subStates_c8e.empty())&& ( !parStmnts_c91.empty()))
		callCheckStateDecomp_27d7( subStates_c8e, parStmnts_c91);
}

void CreateDEVars_249b::callCreateStoreVar_27e0( const Packets_t& states_2520, const Packets_t& programs_2522)
{
	Packets_t states_2524;
	Packets_t programs_2525;
	CreateStoreVar_251f createStoreVar_251f;
	createStoreVar_251f( states_2520, programs_2522, states_2524, programs_2525);
	if( ( !states_2524.empty())&& ( !programs_2525.empty()))
		callCreateEventVar_27e3( states_2524, programs_2525);
}

void CreateDEVars_249b::callCreateEventVar_27e3( const Packets_t& states_24e6, const Packets_t& programs_24e8)
{
	Packets_t states_24ea;
	Packets_t programs_24eb;
	CreateEventVar_24e5 createEventVar_24e5;
	createEventVar_24e5( states_24e6, programs_24e8, states_24ea, programs_24eb);
	if( ( !states_24ea.empty())&& ( !programs_24eb.empty()))
		callGetSubStates_27dd( states_24ea, programs_24eb);
}

void CreateDataVar_24a4::operator()( const Packets_t& states_24a5, const Packets_t& programs_24a7, Packets_t& states_24a9, Packets_t& programs_24aa)
{
#ifdef PRINT_INFO
	printLog( "CreateDataVar_24a4" );
#endif
	_state_24ab= &states_24a9;
	_program_24ac= &programs_24aa;
	if( ( !states_24a5.empty())&& ( !programs_24a7.empty()))
		callCreateDataVar_24e2( states_24a5, programs_24a7);
	_state_24ab->insert( _state_24ab->end(), states_24a5.begin(), states_24a5.end());
	_program_24ac->insert( _program_24ac->end(), programs_24a7.begin(), programs_24a7.end());
}

void CreateDataVar_24a4::callCreateDataVar_24e2( const Packets_t& states_24ae, const Packets_t& programs_24b0)
{
	CreateDataVar_24ad createDataVar_24ad;
	createDataVar_24ad( states_24ae, programs_24b0);
}

void CreateDataVar_24ad::operator()( const Packets_t& states_24ae, const Packets_t& programs_24b0)
{
#ifdef PRINT_INFO
	printLog( "CreateDataVar_24ad" );
#endif
	RTTGenerator::Instance()->generateRule(1787, "CreateDataVar");
	processInputPackets( states_24ae, programs_24b0);
}

bool CreateDataVar_24ad::isInputUnique( const Udm::Object& state_24b6, const Udm::Object& program_24bf)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_24b8= _state_24b2.begin(), itProgram_24c1= _program_24bb.begin(); itState_24b8!= _state_24b2.end(), itProgram_24c1!= _program_24bb.end(); ++itState_24b8, ++itProgram_24c1)
	{
		if( ( *itState_24b8== state_24b6)&& ( *itProgram_24c1== program_24bf))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_24b2.push_back( state_24b6);
		_program_24bb.push_back( program_24bf);
	}
	return isUnique;
}

bool CreateDataVar_24ad::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool CreateDataVar_24ad::isGuardTrue( SFC::DT& DT, CyberComposition::Simulink::Data& Data, SFC::Program& Program, CyberComposition::Simulink::State& State, SFC::StateLabel& StateLabel, CyberComposition::Simulink::SF_TypeBase& TypeBase, CyberComposition::Simulink::TypeBaseRef& TypeBaseRef)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( Data.Scope() ) != "STORE_DATA";;
	return Gz_guard;
}

void CreateDataVar_24ad::processInputPackets( const Packets_t& states_24ae, const Packets_t& programs_24b0)
{
	for( Packets_t::const_iterator itState_24b3= states_24ae.begin(), itProgram_24bc= programs_24b0.begin(); itState_24b3!= states_24ae.end(), itProgram_24bc!= programs_24b0.end(); ++itState_24b3, ++itProgram_24bc)
	{
		bool isUnique= isInputUnique( *itState_24b3, *itProgram_24bc);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_24b3, *itProgram_24bc);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateDataVar_24ad::patternMatcher( const Udm::Object& state_24b4, const Udm::Object& program_24bd)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_24b4.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_24b9= CyberComposition::Simulink::State::Cast( state_24b4);
		if( false== Uml::IsDerivedFrom( program_24bd.type(), SFC::Program::meta))
			continue;
		SFC::Program program_24c2= SFC::Program::Cast( program_24bd);
		set< CyberComposition::Simulink::Data> datas_24c4= state_24b9.Data_kind_children();
		for( set< CyberComposition::Simulink::Data>::const_iterator itData_24c5= datas_24c4.begin(); itData_24c5!= datas_24c4.end(); ++itData_24c5)
		{
			CyberComposition::Simulink::Data currData_24c6= *itData_24c5;
			set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_24c7= currData_24c6.TypeBaseRef_kind_children();
			for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_24c8= typeBaseRefs_24c7.begin(); itTypeBaseRef_24c8!= typeBaseRefs_24c7.end(); ++itTypeBaseRef_24c8)
			{
				CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_24c9= *itTypeBaseRef_24c8;
				CyberComposition::Simulink::SF_TypeBase typeBase_24ca= currTypeBaseRef_24c9.ref();
				if( !typeBase_24ca)
					continue;
				SFC::DT dT_24cb= typeBase_24ca.dt();
				if( !dT_24cb)
					continue;
				set< SFC::StateLabel> stateLabels_24cc= state_24b9.src();
				for( set< SFC::StateLabel>::const_iterator itStateLabels_24cd= stateLabels_24cc.begin(); itStateLabels_24cd!= stateLabels_24cc.end(); ++itStateLabels_24cd)
				{
					SFC::StateLabel currStateLabel_24ce= *itStateLabels_24cd;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_24d2;
					if( !isValidBound(boundObjs_24d2, state_24b9, true))
						continue;
					currMatch.state_24d3= state_24b9;
					if( !isValidBound(boundObjs_24d2, program_24c2, true))
						continue;
					currMatch.program_24d4= program_24c2;
					if( !isValidBound(boundObjs_24d2, currStateLabel_24ce, false))
						continue;
					currMatch.stateLabel_24d5= currStateLabel_24ce;
					if( !isValidBound(boundObjs_24d2, currData_24c6, false))
						continue;
					currMatch.data_24d6= currData_24c6;
					if( !isValidBound(boundObjs_24d2, currTypeBaseRef_24c9, false))
						continue;
					currMatch.typeBaseRef_24d7= currTypeBaseRef_24c9;
					if( !isValidBound(boundObjs_24d2, typeBase_24ca, false))
						continue;
					currMatch.typeBase_24d8= typeBase_24ca;
					if( !isValidBound(boundObjs_24d2, dT_24cb, false))
						continue;
					currMatch.dT_24d9= dT_24cb;
					bool Gz_guard= isGuardTrue( currMatch.dT_24d9, currMatch.data_24d6, currMatch.program_24d4, currMatch.state_24d3, currMatch.stateLabel_24d5, currMatch.typeBase_24d8, currMatch.typeBaseRef_24d7);
					if( true== Gz_guard)
						_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void CreateDataVar_24ad::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newLocalVar_24e1= SFC::LocalVar::Create( currMatch.program_24d4);
		SFC::DT& DT= currMatch.dT_24d9;
		CyberComposition::Simulink::Data& Data= currMatch.data_24d6;
		SFC::LocalVar& LocalVar= newLocalVar_24e1;
		SFC::Program& Program= currMatch.program_24d4;
		CyberComposition::Simulink::State& State= currMatch.state_24d3;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_24d5;
		CyberComposition::Simulink::SF_TypeBase& TypeBase= currMatch.typeBase_24d8;
		CyberComposition::Simulink::TypeBaseRef& TypeBaseRef= currMatch.typeBaseRef_24d7;
		{
LocalVar.RefId() = Data.RefId();
};
		{
__int64 statementCount = Program.statementCount();
LocalVar.statementIndex() = statementCount++;
Program.statementCount() = statementCount;
};
		{
std::string dataName = Data.Name();
if(dataName.empty())
	dataName = Data.name();
LocalVar.name() = dataName;
LocalVar.scope() = StateLabel.comment(); /* comment contains the extend state name */
LocalVar.initial() = Data.InitialValue();
LocalVar.indexBase() = Data.ArrayFirstIndex();

SFManager::AddTypedEntityScope( LocalVar );
};
		newLocalVar_24e1.dt()= currMatch.dT_24d9;
		newLocalVar_24e1.data()+= currMatch.data_24d6;
	}
}

void CreateEventVar_24e5::operator()( const Packets_t& states_24e6, const Packets_t& programs_24e8, Packets_t& states_24ea, Packets_t& programs_24eb)
{
#ifdef PRINT_INFO
	printLog( "CreateEventVar_24e5" );
#endif
	_state_24ec= &states_24ea;
	_program_24ed= &programs_24eb;
	if( ( !states_24e6.empty())&& ( !programs_24e8.empty()))
		callCreateEventVar_251c( states_24e6, programs_24e8);
	_state_24ec->insert( _state_24ec->end(), states_24e6.begin(), states_24e6.end());
	_program_24ed->insert( _program_24ed->end(), programs_24e8.begin(), programs_24e8.end());
}

void CreateEventVar_24e5::callCreateEventVar_251c( const Packets_t& states_24ef, const Packets_t& programs_24f1)
{
	CreateEventVar_24ee createEventVar_24ee;
	createEventVar_24ee( states_24ef, programs_24f1);
}

void CreateEventVar_24ee::operator()( const Packets_t& states_24ef, const Packets_t& programs_24f1)
{
#ifdef PRINT_INFO
	printLog( "CreateEventVar_24ee" );
#endif
	RTTGenerator::Instance()->generateRule(1812, "CreateEventVar");
	processInputPackets( states_24ef, programs_24f1);
}

bool CreateEventVar_24ee::isInputUnique( const Udm::Object& state_24f7, const Udm::Object& program_2500)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_24f9= _state_24f3.begin(), itProgram_2502= _program_24fc.begin(); itState_24f9!= _state_24f3.end(), itProgram_2502!= _program_24fc.end(); ++itState_24f9, ++itProgram_2502)
	{
		if( ( *itState_24f9== state_24f7)&& ( *itProgram_2502== program_2500))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_24f3.push_back( state_24f7);
		_program_24fc.push_back( program_2500);
	}
	return isUnique;
}

bool CreateEventVar_24ee::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateEventVar_24ee::processInputPackets( const Packets_t& states_24ef, const Packets_t& programs_24f1)
{
	for( Packets_t::const_iterator itState_24f4= states_24ef.begin(), itProgram_24fd= programs_24f1.begin(); itState_24f4!= states_24ef.end(), itProgram_24fd!= programs_24f1.end(); ++itState_24f4, ++itProgram_24fd)
	{
		bool isUnique= isInputUnique( *itState_24f4, *itProgram_24fd);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_24f4, *itProgram_24fd);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateEventVar_24ee::patternMatcher( const Udm::Object& state_24f5, const Udm::Object& program_24fe)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_24f5.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_24fa= CyberComposition::Simulink::State::Cast( state_24f5);
		if( false== Uml::IsDerivedFrom( program_24fe.type(), SFC::Program::meta))
			continue;
		SFC::Program program_2503= SFC::Program::Cast( program_24fe);
		set< CyberComposition::Simulink::Event> events_2505= state_24fa.Event_kind_children();
		for( set< CyberComposition::Simulink::Event>::const_iterator itEvent_2506= events_2505.begin(); itEvent_2506!= events_2505.end(); ++itEvent_2506)
		{
			CyberComposition::Simulink::Event currEvent_2507= *itEvent_2506;
			set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_2508= currEvent_2507.TypeBaseRef_kind_children();
			for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_2509= typeBaseRefs_2508.begin(); itTypeBaseRef_2509!= typeBaseRefs_2508.end(); ++itTypeBaseRef_2509)
			{
				CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_250a= *itTypeBaseRef_2509;
				CyberComposition::Simulink::SF_TypeBase typeBase_250b= currTypeBaseRef_250a.ref();
				if( !typeBase_250b)
					continue;
				SFC::DT dT_250c= typeBase_250b.dt();
				if( !dT_250c)
					continue;
				set< SFC::StateLabel> stateLabels_250d= state_24fa.src();
				for( set< SFC::StateLabel>::const_iterator itStateLabels_250e= stateLabels_250d.begin(); itStateLabels_250e!= stateLabels_250d.end(); ++itStateLabels_250e)
				{
					SFC::StateLabel currStateLabel_250f= *itStateLabels_250e;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_2513;
					if( !isValidBound(boundObjs_2513, state_24fa, true))
						continue;
					currMatch.state_2514= state_24fa;
					if( !isValidBound(boundObjs_2513, program_2503, true))
						continue;
					currMatch.program_2515= program_2503;
					if( !isValidBound(boundObjs_2513, currStateLabel_250f, false))
						continue;
					currMatch.stateLabel_2516= currStateLabel_250f;
					if( !isValidBound(boundObjs_2513, currEvent_2507, false))
						continue;
					currMatch.event_2517= currEvent_2507;
					if( !isValidBound(boundObjs_2513, currTypeBaseRef_250a, false))
						continue;
					currMatch.typeBaseRef_2518= currTypeBaseRef_250a;
					if( !isValidBound(boundObjs_2513, typeBase_250b, false))
						continue;
					currMatch.typeBase_2519= typeBase_250b;
					if( !isValidBound(boundObjs_2513, dT_250c, false))
						continue;
					currMatch.dT_251a= dT_250c;
					_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void CreateEventVar_24ee::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newLocalVar_251b= SFC::LocalVar::Create( currMatch.program_2515);
		SFC::DT& DT= currMatch.dT_251a;
		CyberComposition::Simulink::Event& Event= currMatch.event_2517;
		SFC::LocalVar& LocalVar= newLocalVar_251b;
		SFC::Program& Program= currMatch.program_2515;
		CyberComposition::Simulink::State& State= currMatch.state_2514;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_2516;
		CyberComposition::Simulink::SF_TypeBase& TypeBase= currMatch.typeBase_2519;
		CyberComposition::Simulink::TypeBaseRef& TypeBaseRef= currMatch.typeBaseRef_2518;
		{
LocalVar.RefId() = Event.RefId();
};
		{
__int64 sc;
Program.GetIntValue("statementCount", sc);
LocalVar.SetIntValue("statementIndex", sc++);
Program.SetIntValue("statementCount", sc);
};
		{
LocalVar.name() = Event.name();
LocalVar.initial() = "0";
LocalVar.scope() = StateLabel.comment();

SFManager::AddTypedEntityScope( LocalVar );
};
		newLocalVar_251b.dt()= currMatch.dT_251a;
		newLocalVar_251b.event()+= currMatch.event_2517;
	}
}

void CreateStoreVar_251f::operator()( const Packets_t& states_2520, const Packets_t& programs_2522, Packets_t& states_2524, Packets_t& programs_2525)
{
#ifdef PRINT_INFO
	printLog( "CreateStoreVar_251f" );
#endif
	_state_2526= &states_2524;
	_program_2527= &programs_2525;
	_state_2526->insert( _state_2526->end(), states_2520.begin(), states_2520.end());
	_program_2527->insert( _program_2527->end(), programs_2522.begin(), programs_2522.end());
	if( ( !states_2520.empty())&& ( !programs_2522.empty()))
		callCreateDataVar_27c5( states_2520, programs_2522);
}

void CreateStoreVar_251f::callCreateDataVar_27c5( const Packets_t& states_2627, const Packets_t& programs_262b)
{
	Packets_t states_2629;
	Packets_t localVars_262a;
	CreateDataVar_2626 createDataVar_2626;
	createDataVar_2626( states_2627, programs_262b, states_2629, localVars_262a);
	if( ( !states_2629.empty())&& ( !localVars_262a.empty()))
		callGetHighestState_27c8( states_2629, localVars_262a);
}

void CreateStoreVar_251f::callGetHighestState_27c8( const Packets_t& states_2668, const Packets_t& localVars_266a)
{
	Packets_t states_266c;
	Packets_t localVars_266d;
	GetHighestState_2667 getHighestState_2667;
	getHighestState_2667( states_2668, localVars_266a, states_266c, localVars_266d);
	if( ( !states_266c.empty())&& ( !localVars_266d.empty()))
		callGetContainingSubsystem_27cb( states_266c, localVars_266d);
}

void CreateStoreVar_251f::callGetContainingSubsystem_27cb( const Packets_t& states_25f5, const Packets_t& localVars_25f8)
{
	Packets_t subsystems_25f7;
	Packets_t localVars_25fa;
	GetContainingSubsystem_25f4 getContainingSubsystem_25f4;
	getContainingSubsystem_25f4( states_25f5, localVars_25f8, subsystems_25f7, localVars_25fa);
	if( ( !subsystems_25f7.empty())&& ( !localVars_25fa.empty()))
		callGetStoreSubsystem_27ce( subsystems_25f7, localVars_25fa);
}

void CreateStoreVar_251f::callGetStoreSubsystem_27ce( const Packets_t& systems_2529, const Packets_t& localVars_252b)
{
	Packets_t systems_252d;
	Packets_t localVars_252e;
	GetStoreSubsystem_2528 getStoreSubsystem_2528;
	getStoreSubsystem_2528( systems_2529, localVars_252b, systems_252d, localVars_252e);
	if( ( !systems_252d.empty())&& ( !localVars_252e.empty()))
		callGetScope_27d1( systems_252d, localVars_252e);
}

void CreateStoreVar_251f::callGetScope_27d1( const Packets_t& systems_2727, const Packets_t& localVars_2729)
{
	Packets_t systems_272b;
	Packets_t localVars_272c;
	GetScope_2726 getScope_2726;
	getScope_2726( systems_2727, localVars_2729, systems_272b, localVars_272c);
	if( ( !systems_272b.empty())&& ( !localVars_272c.empty()))
		callRegister_27d4( systems_272b, localVars_272c);
}

void CreateStoreVar_251f::callRegister_27d4( const Packets_t& subsystems_270a, const Packets_t& localVars_270c)
{
	Register_2709 register_2709;
	register_2709( subsystems_270a, localVars_270c);
}

void GetStoreSubsystem_2528::operator()( const Packets_t& systems_2529, const Packets_t& localVars_252b, Packets_t& systems_252d, Packets_t& localVars_252e)
{
#ifdef PRINT_INFO
	printLog( "GetStoreSubsystem_2528" );
#endif
	_system_252f= &systems_252d;
	_localVar_2530= &localVars_252e;
	if( ( !systems_2529.empty())&& ( !localVars_252b.empty()))
		callStoreTest_25eb( systems_2529, localVars_252b);
}

void GetStoreSubsystem_2528::callStoreTest_25eb( const Packets_t& systems_257b, const Packets_t& localVars_257d)
{
	Packets_t systems_257f;
	Packets_t localVars_2580;
	Packets_t systems_2581;
	Packets_t localVars_2582;
	StoreTest_257a storeTest_257a;
	storeTest_257a( systems_257b, localVars_257d, systems_257f, localVars_2580, systems_2581, localVars_2582);
	if( ( !systems_257f.empty())&& ( !localVars_2580.empty()))
		callInitScope_25ee( systems_257f, localVars_2580);
	if( ( !systems_2581.empty())&& ( !localVars_2582.empty()))
		callNextHigherSubsystem_25f1( systems_2581, localVars_2582);
}

void GetStoreSubsystem_2528::callInitScope_25ee( const Packets_t& subsystems_2532, const Packets_t& localVars_2535)
{
	Packets_t subsystems_2534;
	Packets_t localVars_2537;
	InitScope_2531 initScope_2531;
	initScope_2531( subsystems_2532, localVars_2535, subsystems_2534, localVars_2537);
	_system_252f->insert( _system_252f->end(), subsystems_2534.begin(), subsystems_2534.end());
	_localVar_2530->insert( _localVar_2530->end(), localVars_2537.begin(), localVars_2537.end());
}

void GetStoreSubsystem_2528::callNextHigherSubsystem_25f1( const Packets_t& subSubsystems_2553, const Packets_t& localVars_2556)
{
	Packets_t subsystems_2555;
	Packets_t localVars_2558;
	NextHigherSubsystem_2552 nextHigherSubsystem_2552;
	nextHigherSubsystem_2552( subSubsystems_2553, localVars_2556, subsystems_2555, localVars_2558);
	if( ( !subsystems_2555.empty())&& ( !localVars_2558.empty()))
		callStoreTest_25eb( subsystems_2555, localVars_2558);
}

void InitScope_2531::operator()( const Packets_t& subsystems_2532, const Packets_t& localVars_2535, Packets_t& subsystems_2534, Packets_t& localVars_2537)
{
#ifdef PRINT_INFO
	printLog( "InitScope_2531" );
#endif
	RTTGenerator::Instance()->generateRule(1847, "InitScope");
	_subsystem_2538= &subsystems_2534;
	_localVar_2539= &localVars_2537;
	processInputPackets( subsystems_2532, localVars_2535);
	forwardInputs( );
}

bool InitScope_2531::isInputUnique( const Udm::Object& subsystem_253e, const Udm::Object& localVar_2547)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_2540= _subsystem_253a.begin(), itLocalVar_2549= _localVar_2543.begin(); itSubsystem_2540!= _subsystem_253a.end(), itLocalVar_2549!= _localVar_2543.end(); ++itSubsystem_2540, ++itLocalVar_2549)
	{
		if( ( *itSubsystem_2540== subsystem_253e)&& ( *itLocalVar_2549== localVar_2547))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_253a.push_back( subsystem_253e);
		_localVar_2543.push_back( localVar_2547);
	}
	return isUnique;
}

bool InitScope_2531::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void InitScope_2531::processInputPackets( const Packets_t& subsystems_2532, const Packets_t& localVars_2535)
{
	for( Packets_t::const_iterator itSubsystem_253b= subsystems_2532.begin(), itLocalVar_2544= localVars_2535.begin(); itSubsystem_253b!= subsystems_2532.end(), itLocalVar_2544!= localVars_2535.end(); ++itSubsystem_253b, ++itLocalVar_2544)
	{
		bool isUnique= isInputUnique( *itSubsystem_253b, *itLocalVar_2544);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_253b, *itLocalVar_2544);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InitScope_2531::patternMatcher( const Udm::Object& subsystem_253c, const Udm::Object& localVar_2545)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_253c.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_2541= CyberComposition::Simulink::Subsystem::Cast( subsystem_253c);
		if( false== Uml::IsDerivedFrom( localVar_2545.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_254a= SFC::LocalVar::Cast( localVar_2545);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_254f;
		if( !isValidBound(boundObjs_254f, subsystem_2541, true))
			continue;
		currMatch.subsystem_2550= subsystem_2541;
		if( !isValidBound(boundObjs_254f, localVar_254a, true))
			continue;
		currMatch.localVar_2551= localVar_254a;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void InitScope_2531::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar& LocalVar= currMatch.localVar_2551;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_2550;
		{
LocalVar.scope() = Subsystem.name();
};
	}
}

void InitScope_2531::forwardInputs()
{
	*_subsystem_2538= _subsystem_253a;
	*_localVar_2539= _localVar_2543;
}

void NextHigherSubsystem_2552::operator()( const Packets_t& subSubsystems_2553, const Packets_t& localVars_2556, Packets_t& subsystems_2555, Packets_t& localVars_2558)
{
#ifdef PRINT_INFO
	printLog( "NextHigherSubsystem_2552" );
#endif
	RTTGenerator::Instance()->generateRule(1851, "NextHigherSubsystem");
	_subsystem_2559= &subsystems_2555;
	_localVar_255a= &localVars_2558;
	processInputPackets( subSubsystems_2553, localVars_2556);
}

bool NextHigherSubsystem_2552::isInputUnique( const Udm::Object& subSubsystem_255f, const Udm::Object& localVar_2568)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubSubsystem_2561= _subSubsystem_255b.begin(), itLocalVar_256a= _localVar_2564.begin(); itSubSubsystem_2561!= _subSubsystem_255b.end(), itLocalVar_256a!= _localVar_2564.end(); ++itSubSubsystem_2561, ++itLocalVar_256a)
	{
		if( ( *itSubSubsystem_2561== subSubsystem_255f)&& ( *itLocalVar_256a== localVar_2568))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subSubsystem_255b.push_back( subSubsystem_255f);
		_localVar_2564.push_back( localVar_2568);
	}
	return isUnique;
}

bool NextHigherSubsystem_2552::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void NextHigherSubsystem_2552::processInputPackets( const Packets_t& subSubsystems_2553, const Packets_t& localVars_2556)
{
	for( Packets_t::const_iterator itSubSubsystem_255c= subSubsystems_2553.begin(), itLocalVar_2565= localVars_2556.begin(); itSubSubsystem_255c!= subSubsystems_2553.end(), itLocalVar_2565!= localVars_2556.end(); ++itSubSubsystem_255c, ++itLocalVar_2565)
	{
		bool isUnique= isInputUnique( *itSubSubsystem_255c, *itLocalVar_2565);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubSubsystem_255c, *itLocalVar_2565);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool NextHigherSubsystem_2552::patternMatcher( const Udm::Object& subSubsystem_255d, const Udm::Object& localVar_2566)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subSubsystem_255d.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subSubsystem_2562= CyberComposition::Simulink::Subsystem::Cast( subSubsystem_255d);
		if( false== Uml::IsDerivedFrom( localVar_2566.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_256b= SFC::LocalVar::Cast( localVar_2566);
		Udm::Object subSubsystemParent_256d= subSubsystem_2562.container();
		if( false== Uml::IsDerivedFrom( subSubsystemParent_256d.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystemSubSubsystem_256e= CyberComposition::Simulink::Subsystem::Cast( subSubsystemParent_256d);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2572;
		if( !isValidBound(boundObjs_2572, subSubsystem_2562, true))
			continue;
		currMatch.subSubsystem_2573= subSubsystem_2562;
		if( !isValidBound(boundObjs_2572, localVar_256b, true))
			continue;
		currMatch.localVar_2574= localVar_256b;
		if( !isValidBound(boundObjs_2572, subsystemSubSubsystem_256e, false))
			continue;
		currMatch.subsystem_2575= subsystemSubSubsystem_256e;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void NextHigherSubsystem_2552::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_2575, currMatch.localVar_2574);
	}
}

void NextHigherSubsystem_2552::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_2576, const SFC::LocalVar& localVar_2578)
{
	_subsystem_2559->push_back( subsystem_2576);
	_localVar_255a->push_back( localVar_2578);
}

void StoreTest_257a::operator()( const Packets_t& systems_257b, const Packets_t& localVars_257d, Packets_t& systems_257f, Packets_t& localVars_2580, Packets_t& systems_2581, Packets_t& localVars_2582)
{
#ifdef PRINT_INFO
	printLog( "StoreTest_257a" );
#endif
	_system_2583= &systems_257f;
	_localVar_2584= &localVars_2580;
	_system_2585= &systems_2581;
	_localVar_2586= &localVars_2582;
	for( Packets_t::const_iterator itsystem_2588= systems_257b.begin(), itlocalVar_258f= localVars_257d.begin(); itsystem_2588!= systems_257b.end(), itlocalVar_258f!= localVars_257d.end(); ++itsystem_2588, ++itlocalVar_258f)
	{
		bool isUnique= isInputUnique( *itsystem_2588, *itlocalVar_258f);
		if( !isUnique)
			continue;
		Packets_t onesystem_258c( 1, *itsystem_2588);
		Packets_t onelocalVar_2593( 1, *itlocalVar_258f);
		executeOne( onesystem_258c, onelocalVar_2593);
	}
}

void StoreTest_257a::executeOne( const Packets_t& systems_257b, const Packets_t& localVars_257d)
{
	Packets_t subsystems_2598;
	Packets_t localVars_259b;
	HasStore_2595 hasStore_2595;
	bool isMatchHasStore_2595= hasStore_2595( systems_257b, localVars_257d, subsystems_2598, localVars_259b);
	_system_2583->insert( _system_2583->end(), subsystems_2598.begin(), subsystems_2598.end());
	_localVar_2584->insert( _localVar_2584->end(), localVars_259b.begin(), localVars_259b.end());
	if( isMatchHasStore_2595)
		return;
	Packets_t subsystems_25c9;
	Packets_t localVars_25cc;
	Otherwise_25c6 otherwise_25c6;
	bool isMatchOtherwise_25c6= otherwise_25c6( systems_257b, localVars_257d, subsystems_25c9, localVars_25cc);
	_system_2585->insert( _system_2585->end(), subsystems_25c9.begin(), subsystems_25c9.end());
	_localVar_2586->insert( _localVar_2586->end(), localVars_25cc.begin(), localVars_25cc.end());
	if( isMatchOtherwise_25c6)
		return;
}

bool StoreTest_257a::isInputUnique( const Udm::Object& system_2589, const Udm::Object& localVar_2590)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itsystem_258b= _system_2587.begin(), itlocalVar_2592= _localVar_258e.begin(); itsystem_258b!= _system_2587.end(), itlocalVar_2592!= _localVar_258e.end(); ++itsystem_258b, ++itlocalVar_2592)
	{
		if( ( *itsystem_258b== system_2589)&& ( *itlocalVar_2592== localVar_2590))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_system_2587.push_back( system_2589);
		_localVar_258e.push_back( localVar_2590);
	}
	return isUnique;
}

bool HasStore_2595::operator()( const Packets_t& subsystems_2596, const Packets_t& localVars_2599, Packets_t& subsystems_2598, Packets_t& localVars_259b)
{
#ifdef PRINT_INFO
	printLog( "HasStore_2595" );
#endif
	_subsystem_259c= &subsystems_2598;
	_localVar_259d= &localVars_259b;
	processInputPackets( subsystems_2596, localVars_2599);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasStore_2595::isInputUnique( const Udm::Object& subsystem_25a2, const Udm::Object& localVar_25ab)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_25a4= _subsystem_259e.begin(), itLocalVar_25ad= _localVar_25a7.begin(); itSubsystem_25a4!= _subsystem_259e.end(), itLocalVar_25ad!= _localVar_25a7.end(); ++itSubsystem_25a4, ++itLocalVar_25ad)
	{
		if( ( *itSubsystem_25a4== subsystem_25a2)&& ( *itLocalVar_25ad== localVar_25ab))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_259e.push_back( subsystem_25a2);
		_localVar_25a7.push_back( localVar_25ab);
	}
	return isUnique;
}

bool HasStore_2595::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool HasStore_2595::isGuardTrue( SFC::LocalVar& LocalVar, CyberComposition::Simulink::SF_Parameter& Parameter, CyberComposition::Simulink::Primitive& Primitive, CyberComposition::Simulink::Subsystem& Subsystem)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( Parameter.Value() ) ==
 static_cast< std::string >( LocalVar.name() );;
	return Gz_guard;
}

void HasStore_2595::processInputPackets( const Packets_t& subsystems_2596, const Packets_t& localVars_2599)
{
	for( Packets_t::const_iterator itSubsystem_259f= subsystems_2596.begin(), itLocalVar_25a8= localVars_2599.begin(); itSubsystem_259f!= subsystems_2596.end(), itLocalVar_25a8!= localVars_2599.end(); ++itSubsystem_259f, ++itLocalVar_25a8)
	{
		bool isUnique= isInputUnique( *itSubsystem_259f, *itLocalVar_25a8);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_259f, *itLocalVar_25a8);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_25ba, currMatch.localVar_25bb);
	}
}

bool HasStore_2595::patternMatcher( const Udm::Object& subsystem_25a0, const Udm::Object& localVar_25a9)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_25a0.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_25a5= CyberComposition::Simulink::Subsystem::Cast( subsystem_25a0);
		if( false== Uml::IsDerivedFrom( localVar_25a9.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_25ae= SFC::LocalVar::Cast( localVar_25a9);
		set< CyberComposition::Simulink::Primitive> primitives_25b0= subsystem_25a5.Primitive_kind_children();
		for( set< CyberComposition::Simulink::Primitive>::const_iterator itPrimitive_25b1= primitives_25b0.begin(); itPrimitive_25b1!= primitives_25b0.end(); ++itPrimitive_25b1)
		{
			CyberComposition::Simulink::Primitive currPrimitive_25b2= *itPrimitive_25b1;
			set< CyberComposition::Simulink::SF_Parameter> parameters_25b3= currPrimitive_25b2.SF_Parameter_kind_children();
			for( set< CyberComposition::Simulink::SF_Parameter>::const_iterator itParameter_25b4= parameters_25b3.begin(); itParameter_25b4!= parameters_25b3.end(); ++itParameter_25b4)
			{
				CyberComposition::Simulink::SF_Parameter currParameter_25b5= *itParameter_25b4;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_25b9;
				if( !isValidBound(boundObjs_25b9, subsystem_25a5, true))
					continue;
				currMatch.subsystem_25ba= subsystem_25a5;
				if( !isValidBound(boundObjs_25b9, localVar_25ae, true))
					continue;
				currMatch.localVar_25bb= localVar_25ae;
				if( !isValidBound(boundObjs_25b9, currParameter_25b5, false))
					continue;
				currMatch.parameter_25bc= currParameter_25b5;
				if( !isValidBound(boundObjs_25b9, currPrimitive_25b2, false))
					continue;
				currMatch.primitive_25bd= currPrimitive_25b2;
				bool Gz_guard= isGuardTrue( currMatch.localVar_25bb, currMatch.parameter_25bc, currMatch.primitive_25bd, currMatch.subsystem_25ba);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void HasStore_2595::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_25c2, const SFC::LocalVar& localVar_25c4)
{
	_subsystem_259c->push_back( subsystem_25c2);
	_localVar_259d->push_back( localVar_25c4);
}

bool Otherwise_25c6::operator()( const Packets_t& subsystems_25c7, const Packets_t& localVars_25ca, Packets_t& subsystems_25c9, Packets_t& localVars_25cc)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_25c6" );
#endif
	_subsystem_25cd= &subsystems_25c9;
	_localVar_25ce= &localVars_25cc;
	processInputPackets( subsystems_25c7, localVars_25ca);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_25c6::isInputUnique( const Udm::Object& subsystem_25d3, const Udm::Object& localVar_25dc)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_25d5= _subsystem_25cf.begin(), itLocalVar_25de= _localVar_25d8.begin(); itSubsystem_25d5!= _subsystem_25cf.end(), itLocalVar_25de!= _localVar_25d8.end(); ++itSubsystem_25d5, ++itLocalVar_25de)
	{
		if( ( *itSubsystem_25d5== subsystem_25d3)&& ( *itLocalVar_25de== localVar_25dc))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_25cf.push_back( subsystem_25d3);
		_localVar_25d8.push_back( localVar_25dc);
	}
	return isUnique;
}

bool Otherwise_25c6::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_25c6::processInputPackets( const Packets_t& subsystems_25c7, const Packets_t& localVars_25ca)
{
	for( Packets_t::const_iterator itSubsystem_25d0= subsystems_25c7.begin(), itLocalVar_25d9= localVars_25ca.begin(); itSubsystem_25d0!= subsystems_25c7.end(), itLocalVar_25d9!= localVars_25ca.end(); ++itSubsystem_25d0, ++itLocalVar_25d9)
	{
		bool isUnique= isInputUnique( *itSubsystem_25d0, *itLocalVar_25d9);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_25d0, *itLocalVar_25d9);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_25e5, currMatch.localVar_25e6);
	}
}

bool Otherwise_25c6::patternMatcher( const Udm::Object& subsystem_25d1, const Udm::Object& localVar_25da)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_25d1.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_25d6= CyberComposition::Simulink::Subsystem::Cast( subsystem_25d1);
		if( false== Uml::IsDerivedFrom( localVar_25da.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_25df= SFC::LocalVar::Cast( localVar_25da);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_25e4;
		if( !isValidBound(boundObjs_25e4, subsystem_25d6, true))
			continue;
		currMatch.subsystem_25e5= subsystem_25d6;
		if( !isValidBound(boundObjs_25e4, localVar_25df, true))
			continue;
		currMatch.localVar_25e6= localVar_25df;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_25c6::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_25e7, const SFC::LocalVar& localVar_25e9)
{
	_subsystem_25cd->push_back( subsystem_25e7);
	_localVar_25ce->push_back( localVar_25e9);
}

void GetContainingSubsystem_25f4::operator()( const Packets_t& states_25f5, const Packets_t& localVars_25f8, Packets_t& subsystems_25f7, Packets_t& localVars_25fa)
{
#ifdef PRINT_INFO
	printLog( "GetContainingSubsystem_25f4" );
#endif
	RTTGenerator::Instance()->generateRule(1873, "GetContainingSubsystem");
	_subsystem_25fb= &subsystems_25f7;
	_localVar_25fc= &localVars_25fa;
	processInputPackets( states_25f5, localVars_25f8);
}

bool GetContainingSubsystem_25f4::isInputUnique( const Udm::Object& state_2601, const Udm::Object& localVar_260a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_2603= _state_25fd.begin(), itLocalVar_260c= _localVar_2606.begin(); itState_2603!= _state_25fd.end(), itLocalVar_260c!= _localVar_2606.end(); ++itState_2603, ++itLocalVar_260c)
	{
		if( ( *itState_2603== state_2601)&& ( *itLocalVar_260c== localVar_260a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_25fd.push_back( state_2601);
		_localVar_2606.push_back( localVar_260a);
	}
	return isUnique;
}

bool GetContainingSubsystem_25f4::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetContainingSubsystem_25f4::processInputPackets( const Packets_t& states_25f5, const Packets_t& localVars_25f8)
{
	for( Packets_t::const_iterator itState_25fe= states_25f5.begin(), itLocalVar_2607= localVars_25f8.begin(); itState_25fe!= states_25f5.end(), itLocalVar_2607!= localVars_25f8.end(); ++itState_25fe, ++itLocalVar_2607)
	{
		bool isUnique= isInputUnique( *itState_25fe, *itLocalVar_2607);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_25fe, *itLocalVar_2607);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetContainingSubsystem_25f4::patternMatcher( const Udm::Object& state_25ff, const Udm::Object& localVar_2608)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_25ff.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_2604= CyberComposition::Simulink::State::Cast( state_25ff);
		if( false== Uml::IsDerivedFrom( localVar_2608.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_260d= SFC::LocalVar::Cast( localVar_2608);
		set< CyberComposition::Simulink::ConnectorRef> connectorRefs_260f= state_2604.referedbyConnectorRef();
		for( set< CyberComposition::Simulink::ConnectorRef>::const_iterator itConnectorRefs_2610= connectorRefs_260f.begin(); itConnectorRefs_2610!= connectorRefs_260f.end(); ++itConnectorRefs_2610)
		{
			CyberComposition::Simulink::ConnectorRef currConnectorRef_2611= *itConnectorRefs_2610;
			Udm::Object connectorRefParent_2612= currConnectorRef_2611.container();
			if( false== Uml::IsDerivedFrom( connectorRefParent_2612.type(), CyberComposition::Simulink::Primitive::meta))
				continue;
			CyberComposition::Simulink::Primitive primitiveConnectorRef_2613= CyberComposition::Simulink::Primitive::Cast( connectorRefParent_2612);
			Udm::Object primitiveParent_2614= primitiveConnectorRef_2613.container();
			if( false== Uml::IsDerivedFrom( primitiveParent_2614.type(), CyberComposition::Simulink::Subsystem::meta))
				continue;
			CyberComposition::Simulink::Subsystem subSubsystemPrimitive_2615= CyberComposition::Simulink::Subsystem::Cast( primitiveParent_2614);
			Udm::Object subSubsystemParent_2616= subSubsystemPrimitive_2615.container();
			if( false== Uml::IsDerivedFrom( subSubsystemParent_2616.type(), CyberComposition::Simulink::Subsystem::meta))
				continue;
			CyberComposition::Simulink::Subsystem subsystemSubSubsystem_2617= CyberComposition::Simulink::Subsystem::Cast( subSubsystemParent_2616);
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_261b;
			if( !isValidBound(boundObjs_261b, state_2604, true))
				continue;
			currMatch.state_261c= state_2604;
			if( !isValidBound(boundObjs_261b, localVar_260d, true))
				continue;
			currMatch.localVar_261d= localVar_260d;
			if( !isValidBound(boundObjs_261b, subSubsystemPrimitive_2615, false))
				continue;
			currMatch.subSubsystem_261e= subSubsystemPrimitive_2615;
			if( !isValidBound(boundObjs_261b, subsystemSubSubsystem_2617, false))
				continue;
			currMatch.subsystem_261f= subsystemSubSubsystem_2617;
			if( !isValidBound(boundObjs_261b, currConnectorRef_2611, false))
				continue;
			currMatch.connectorRef_2620= currConnectorRef_2611;
			if( !isValidBound(boundObjs_261b, primitiveConnectorRef_2613, false))
				continue;
			currMatch.primitive_2621= primitiveConnectorRef_2613;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetContainingSubsystem_25f4::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_261f, currMatch.localVar_261d);
	}
}

void GetContainingSubsystem_25f4::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_2622, const SFC::LocalVar& localVar_2624)
{
	_subsystem_25fb->push_back( subsystem_2622);
	_localVar_25fc->push_back( localVar_2624);
}

void CreateDataVar_2626::operator()( const Packets_t& states_2627, const Packets_t& programs_262b, Packets_t& states_2629, Packets_t& localVars_262a)
{
#ifdef PRINT_INFO
	printLog( "CreateDataVar_2626" );
#endif
	RTTGenerator::Instance()->generateRule(1884, "CreateDataVar");
	_state_262d= &states_2629;
	_localVar_262e= &localVars_262a;
	processInputPackets( states_2627, programs_262b);
}

bool CreateDataVar_2626::isInputUnique( const Udm::Object& state_2633, const Udm::Object& program_263c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_2635= _state_262f.begin(), itProgram_263e= _program_2638.begin(); itState_2635!= _state_262f.end(), itProgram_263e!= _program_2638.end(); ++itState_2635, ++itProgram_263e)
	{
		if( ( *itState_2635== state_2633)&& ( *itProgram_263e== program_263c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_262f.push_back( state_2633);
		_program_2638.push_back( program_263c);
	}
	return isUnique;
}

bool CreateDataVar_2626::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool CreateDataVar_2626::isGuardTrue( SFC::DT& DT, CyberComposition::Simulink::Data& Data, SFC::Program& Program, SFC::Project& Project, CyberComposition::Simulink::State& State, SFC::StateLabel& StateLabel, CyberComposition::Simulink::SF_TypeBase& TypeBase, CyberComposition::Simulink::TypeBaseRef& TypeBaseRef)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( Data.Scope() ) == "STORE_DATA";;
	return Gz_guard;
}

void CreateDataVar_2626::processInputPackets( const Packets_t& states_2627, const Packets_t& programs_262b)
{
	for( Packets_t::const_iterator itState_2630= states_2627.begin(), itProgram_2639= programs_262b.begin(); itState_2630!= states_2627.end(), itProgram_2639!= programs_262b.end(); ++itState_2630, ++itProgram_2639)
	{
		bool isUnique= isInputUnique( *itState_2630, *itProgram_2639);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_2630, *itProgram_2639);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateDataVar_2626::patternMatcher( const Udm::Object& state_2631, const Udm::Object& program_263a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_2631.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_2636= CyberComposition::Simulink::State::Cast( state_2631);
		if( false== Uml::IsDerivedFrom( program_263a.type(), SFC::Program::meta))
			continue;
		SFC::Program program_263f= SFC::Program::Cast( program_263a);
		set< CyberComposition::Simulink::Data> datas_2641= state_2636.Data_kind_children();
		for( set< CyberComposition::Simulink::Data>::const_iterator itData_2642= datas_2641.begin(); itData_2642!= datas_2641.end(); ++itData_2642)
		{
			CyberComposition::Simulink::Data currData_2643= *itData_2642;
			Udm::Object programParent_2644= program_263f.container();
			if( false== Uml::IsDerivedFrom( programParent_2644.type(), SFC::Project::meta))
				continue;
			SFC::Project projectProgram_2645= SFC::Project::Cast( programParent_2644);
			set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_2646= currData_2643.TypeBaseRef_kind_children();
			for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_2647= typeBaseRefs_2646.begin(); itTypeBaseRef_2647!= typeBaseRefs_2646.end(); ++itTypeBaseRef_2647)
			{
				CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_2648= *itTypeBaseRef_2647;
				set< SFC::StateLabel> stateLabels_2649= state_2636.src();
				for( set< SFC::StateLabel>::const_iterator itStateLabels_264a= stateLabels_2649.begin(); itStateLabels_264a!= stateLabels_2649.end(); ++itStateLabels_264a)
				{
					SFC::StateLabel currStateLabel_264b= *itStateLabels_264a;
					CyberComposition::Simulink::SF_TypeBase typeBase_264c= currTypeBaseRef_2648.ref();
					if( !typeBase_264c)
						continue;
					SFC::DT dT_264d= typeBase_264c.dt();
					if( !dT_264d)
						continue;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_2651;
					if( !isValidBound(boundObjs_2651, state_2636, true))
						continue;
					currMatch.state_2652= state_2636;
					if( !isValidBound(boundObjs_2651, program_263f, true))
						continue;
					currMatch.program_2653= program_263f;
					if( !isValidBound(boundObjs_2651, currStateLabel_264b, false))
						continue;
					currMatch.stateLabel_2654= currStateLabel_264b;
					if( !isValidBound(boundObjs_2651, currData_2643, false))
						continue;
					currMatch.data_2655= currData_2643;
					if( !isValidBound(boundObjs_2651, currTypeBaseRef_2648, false))
						continue;
					currMatch.typeBaseRef_2656= currTypeBaseRef_2648;
					if( !isValidBound(boundObjs_2651, typeBase_264c, false))
						continue;
					currMatch.typeBase_2657= typeBase_264c;
					if( !isValidBound(boundObjs_2651, dT_264d, false))
						continue;
					currMatch.dT_2658= dT_264d;
					if( !isValidBound(boundObjs_2651, projectProgram_2645, false))
						continue;
					currMatch.project_2659= projectProgram_2645;
					bool Gz_guard= isGuardTrue( currMatch.dT_2658, currMatch.data_2655, currMatch.program_2653, currMatch.project_2659, currMatch.state_2652, currMatch.stateLabel_2654, currMatch.typeBase_2657, currMatch.typeBaseRef_2656);
					if( true== Gz_guard)
						_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void CreateDataVar_2626::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newLocalVar_2662= SFC::LocalVar::Create( currMatch.project_2659);
		SFC::DT& DT= currMatch.dT_2658;
		CyberComposition::Simulink::Data& Data= currMatch.data_2655;
		SFC::LocalVar& LocalVar= newLocalVar_2662;
		SFC::Program& Program= currMatch.program_2653;
		SFC::Project& Project= currMatch.project_2659;
		CyberComposition::Simulink::State& State= currMatch.state_2652;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_2654;
		CyberComposition::Simulink::SF_TypeBase& TypeBase= currMatch.typeBase_2657;
		CyberComposition::Simulink::TypeBaseRef& TypeBaseRef= currMatch.typeBaseRef_2656;
		{
LocalVar.RefId() = Data.RefId();
};
		{
__int64 statementCount = Project.statementCount();
LocalVar.statementIndex() = statementCount++;
Project.statementCount() = statementCount;
};
		{
std::string dataName = Data.Name();
if(dataName.empty())
	dataName = Data.name();
LocalVar.initial() = Data.InitialValue();
LocalVar.indexBase() = Data.ArrayFirstIndex();
};
		newLocalVar_2662.data()+= currMatch.data_2655;
		newLocalVar_2662.dt()= currMatch.dT_2658;
		outputAppender( currMatch.state_2652, newLocalVar_2662);
	}
}

void CreateDataVar_2626::outputAppender( const CyberComposition::Simulink::State& state_2663, const SFC::LocalVar& localVar_2665)
{
	_state_262d->push_back( state_2663);
	_localVar_262e->push_back( localVar_2665);
}

void GetHighestState_2667::operator()( const Packets_t& states_2668, const Packets_t& localVars_266a, Packets_t& states_266c, Packets_t& localVars_266d)
{
#ifdef PRINT_INFO
	printLog( "GetHighestState_2667" );
#endif
	_state_266e= &states_266c;
	_localVar_266f= &localVars_266d;
	if( ( !states_2668.empty())&& ( !localVars_266a.empty()))
		callHighestStateTest_2703( states_2668, localVars_266a);
}

void GetHighestState_2667::callHighestStateTest_2703( const Packets_t& states_2671, const Packets_t& localVars_2673)
{
	Packets_t states_2675;
	Packets_t localVars_2676;
	Packets_t states_2677;
	Packets_t localVars_2678;
	HighestStateTest_2670 highestStateTest_2670;
	highestStateTest_2670( states_2671, localVars_2673, states_2675, localVars_2676, states_2677, localVars_2678);
	_state_266e->insert( _state_266e->end(), states_2675.begin(), states_2675.end());
	_localVar_266f->insert( _localVar_266f->end(), localVars_2676.begin(), localVars_2676.end());
	if( ( !states_2677.empty())&& ( !localVars_2678.empty()))
		callNextHigherState_2706( states_2677, localVars_2678);
}

void GetHighestState_2667::callNextHigherState_2706( const Packets_t& subStates_26dc, const Packets_t& localVars_26df)
{
	Packets_t states_26de;
	Packets_t localVars_26e1;
	NextHigherState_26db nextHigherState_26db;
	nextHigherState_26db( subStates_26dc, localVars_26df, states_26de, localVars_26e1);
	if( ( !states_26de.empty())&& ( !localVars_26e1.empty()))
		callHighestStateTest_2703( states_26de, localVars_26e1);
}

void HighestStateTest_2670::operator()( const Packets_t& states_2671, const Packets_t& localVars_2673, Packets_t& states_2675, Packets_t& localVars_2676, Packets_t& states_2677, Packets_t& localVars_2678)
{
#ifdef PRINT_INFO
	printLog( "HighestStateTest_2670" );
#endif
	_state_2679= &states_2675;
	_localVar_267a= &localVars_2676;
	_state_267b= &states_2677;
	_localVar_267c= &localVars_2678;
	for( Packets_t::const_iterator itstate_267e= states_2671.begin(), itlocalVar_2685= localVars_2673.begin(); itstate_267e!= states_2671.end(), itlocalVar_2685!= localVars_2673.end(); ++itstate_267e, ++itlocalVar_2685)
	{
		bool isUnique= isInputUnique( *itstate_267e, *itlocalVar_2685);
		if( !isUnique)
			continue;
		Packets_t onestate_2682( 1, *itstate_267e);
		Packets_t onelocalVar_2689( 1, *itlocalVar_2685);
		executeOne( onestate_2682, onelocalVar_2689);
	}
}

void HighestStateTest_2670::executeOne( const Packets_t& states_2671, const Packets_t& localVars_2673)
{
	Packets_t subStates_268e;
	Packets_t localVars_2691;
	HighestState_268b highestState_268b;
	bool isMatchHighestState_268b= highestState_268b( states_2671, localVars_2673, subStates_268e, localVars_2691);
	_state_2679->insert( _state_2679->end(), subStates_268e.begin(), subStates_268e.end());
	_localVar_267a->insert( _localVar_267a->end(), localVars_2691.begin(), localVars_2691.end());
	if( isMatchHighestState_268b)
		return;
	Packets_t states_26b9;
	Packets_t localVars_26bc;
	Otherwise_26b6 otherwise_26b6;
	bool isMatchOtherwise_26b6= otherwise_26b6( states_2671, localVars_2673, states_26b9, localVars_26bc);
	_state_267b->insert( _state_267b->end(), states_26b9.begin(), states_26b9.end());
	_localVar_267c->insert( _localVar_267c->end(), localVars_26bc.begin(), localVars_26bc.end());
	if( isMatchOtherwise_26b6)
		return;
}

bool HighestStateTest_2670::isInputUnique( const Udm::Object& state_267f, const Udm::Object& localVar_2686)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_2681= _state_267d.begin(), itlocalVar_2688= _localVar_2684.begin(); itstate_2681!= _state_267d.end(), itlocalVar_2688!= _localVar_2684.end(); ++itstate_2681, ++itlocalVar_2688)
	{
		if( ( *itstate_2681== state_267f)&& ( *itlocalVar_2688== localVar_2686))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_267d.push_back( state_267f);
		_localVar_2684.push_back( localVar_2686);
	}
	return isUnique;
}

bool HighestState_268b::operator()( const Packets_t& subStates_268c, const Packets_t& localVars_268f, Packets_t& subStates_268e, Packets_t& localVars_2691)
{
#ifdef PRINT_INFO
	printLog( "HighestState_268b" );
#endif
	_subState_2692= &subStates_268e;
	_localVar_2693= &localVars_2691;
	processInputPackets( subStates_268c, localVars_268f);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HighestState_268b::isInputUnique( const Udm::Object& subState_2698, const Udm::Object& localVar_26a1)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubState_269a= _subState_2694.begin(), itLocalVar_26a3= _localVar_269d.begin(); itSubState_269a!= _subState_2694.end(), itLocalVar_26a3!= _localVar_269d.end(); ++itSubState_269a, ++itLocalVar_26a3)
	{
		if( ( *itSubState_269a== subState_2698)&& ( *itLocalVar_26a3== localVar_26a1))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subState_2694.push_back( subState_2698);
		_localVar_269d.push_back( localVar_26a1);
	}
	return isUnique;
}

bool HighestState_268b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void HighestState_268b::processInputPackets( const Packets_t& subStates_268c, const Packets_t& localVars_268f)
{
	for( Packets_t::const_iterator itSubState_2695= subStates_268c.begin(), itLocalVar_269e= localVars_268f.begin(); itSubState_2695!= subStates_268c.end(), itLocalVar_269e!= localVars_268f.end(); ++itSubState_2695, ++itLocalVar_269e)
	{
		bool isUnique= isInputUnique( *itSubState_2695, *itLocalVar_269e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubState_2695, *itLocalVar_269e);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subState_26ae, currMatch.localVar_26af);
	}
}

bool HighestState_268b::patternMatcher( const Udm::Object& subState_2696, const Udm::Object& localVar_269f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subState_2696.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State subState_269b= CyberComposition::Simulink::State::Cast( subState_2696);
		if( false== Uml::IsDerivedFrom( localVar_269f.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_26a4= SFC::LocalVar::Cast( localVar_269f);
		Udm::Object subStateParent_26a6= subState_269b.container();
		if( false== Uml::IsDerivedFrom( subStateParent_26a6.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State stateSubState_26a7= CyberComposition::Simulink::State::Cast( subStateParent_26a6);
		Udm::Object stateParent_26a8= stateSubState_26a7.container();
		if( false== Uml::IsDerivedFrom( stateParent_26a8.type(), CyberComposition::Simulink::Block::meta))
			continue;
		CyberComposition::Simulink::Block stateflowState_26a9= CyberComposition::Simulink::Block::Cast( stateParent_26a8);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_26ad;
		if( !isValidBound(boundObjs_26ad, subState_269b, true))
			continue;
		currMatch.subState_26ae= subState_269b;
		if( !isValidBound(boundObjs_26ad, localVar_26a4, true))
			continue;
		currMatch.localVar_26af= localVar_26a4;
		if( !isValidBound(boundObjs_26ad, stateSubState_26a7, false))
			continue;
		currMatch.state_26b0= stateSubState_26a7;
		if( !isValidBound(boundObjs_26ad, stateflowState_26a9, false))
			continue;
		currMatch.stateflow_26b1= stateflowState_26a9;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void HighestState_268b::outputAppender( const CyberComposition::Simulink::State& subState_26b2, const SFC::LocalVar& localVar_26b4)
{
	_subState_2692->push_back( subState_26b2);
	_localVar_2693->push_back( localVar_26b4);
}

bool Otherwise_26b6::operator()( const Packets_t& states_26b7, const Packets_t& localVars_26ba, Packets_t& states_26b9, Packets_t& localVars_26bc)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_26b6" );
#endif
	_state_26bd= &states_26b9;
	_localVar_26be= &localVars_26bc;
	processInputPackets( states_26b7, localVars_26ba);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_26b6::isInputUnique( const Udm::Object& state_26c3, const Udm::Object& localVar_26cc)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_26c5= _state_26bf.begin(), itLocalVar_26ce= _localVar_26c8.begin(); itState_26c5!= _state_26bf.end(), itLocalVar_26ce!= _localVar_26c8.end(); ++itState_26c5, ++itLocalVar_26ce)
	{
		if( ( *itState_26c5== state_26c3)&& ( *itLocalVar_26ce== localVar_26cc))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_26bf.push_back( state_26c3);
		_localVar_26c8.push_back( localVar_26cc);
	}
	return isUnique;
}

bool Otherwise_26b6::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_26b6::processInputPackets( const Packets_t& states_26b7, const Packets_t& localVars_26ba)
{
	for( Packets_t::const_iterator itState_26c0= states_26b7.begin(), itLocalVar_26c9= localVars_26ba.begin(); itState_26c0!= states_26b7.end(), itLocalVar_26c9!= localVars_26ba.end(); ++itState_26c0, ++itLocalVar_26c9)
	{
		bool isUnique= isInputUnique( *itState_26c0, *itLocalVar_26c9);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_26c0, *itLocalVar_26c9);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_26d5, currMatch.localVar_26d6);
	}
}

bool Otherwise_26b6::patternMatcher( const Udm::Object& state_26c1, const Udm::Object& localVar_26ca)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_26c1.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_26c6= CyberComposition::Simulink::State::Cast( state_26c1);
		if( false== Uml::IsDerivedFrom( localVar_26ca.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_26cf= SFC::LocalVar::Cast( localVar_26ca);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_26d4;
		if( !isValidBound(boundObjs_26d4, state_26c6, true))
			continue;
		currMatch.state_26d5= state_26c6;
		if( !isValidBound(boundObjs_26d4, localVar_26cf, true))
			continue;
		currMatch.localVar_26d6= localVar_26cf;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_26b6::outputAppender( const CyberComposition::Simulink::State& state_26d7, const SFC::LocalVar& localVar_26d9)
{
	_state_26bd->push_back( state_26d7);
	_localVar_26be->push_back( localVar_26d9);
}

void NextHigherState_26db::operator()( const Packets_t& subStates_26dc, const Packets_t& localVars_26df, Packets_t& states_26de, Packets_t& localVars_26e1)
{
#ifdef PRINT_INFO
	printLog( "NextHigherState_26db" );
#endif
	RTTGenerator::Instance()->generateRule(1928, "NextHigherState");
	_state_26e2= &states_26de;
	_localVar_26e3= &localVars_26e1;
	processInputPackets( subStates_26dc, localVars_26df);
}

bool NextHigherState_26db::isInputUnique( const Udm::Object& subState_26e8, const Udm::Object& localVar_26f1)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubState_26ea= _subState_26e4.begin(), itLocalVar_26f3= _localVar_26ed.begin(); itSubState_26ea!= _subState_26e4.end(), itLocalVar_26f3!= _localVar_26ed.end(); ++itSubState_26ea, ++itLocalVar_26f3)
	{
		if( ( *itSubState_26ea== subState_26e8)&& ( *itLocalVar_26f3== localVar_26f1))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subState_26e4.push_back( subState_26e8);
		_localVar_26ed.push_back( localVar_26f1);
	}
	return isUnique;
}

bool NextHigherState_26db::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void NextHigherState_26db::processInputPackets( const Packets_t& subStates_26dc, const Packets_t& localVars_26df)
{
	for( Packets_t::const_iterator itSubState_26e5= subStates_26dc.begin(), itLocalVar_26ee= localVars_26df.begin(); itSubState_26e5!= subStates_26dc.end(), itLocalVar_26ee!= localVars_26df.end(); ++itSubState_26e5, ++itLocalVar_26ee)
	{
		bool isUnique= isInputUnique( *itSubState_26e5, *itLocalVar_26ee);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubState_26e5, *itLocalVar_26ee);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool NextHigherState_26db::patternMatcher( const Udm::Object& subState_26e6, const Udm::Object& localVar_26ef)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subState_26e6.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State subState_26eb= CyberComposition::Simulink::State::Cast( subState_26e6);
		if( false== Uml::IsDerivedFrom( localVar_26ef.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_26f4= SFC::LocalVar::Cast( localVar_26ef);
		Udm::Object subStateParent_26f6= subState_26eb.container();
		if( false== Uml::IsDerivedFrom( subStateParent_26f6.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State stateSubState_26f7= CyberComposition::Simulink::State::Cast( subStateParent_26f6);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_26fb;
		if( !isValidBound(boundObjs_26fb, subState_26eb, true))
			continue;
		currMatch.subState_26fc= subState_26eb;
		if( !isValidBound(boundObjs_26fb, localVar_26f4, true))
			continue;
		currMatch.localVar_26fd= localVar_26f4;
		if( !isValidBound(boundObjs_26fb, stateSubState_26f7, false))
			continue;
		currMatch.state_26fe= stateSubState_26f7;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void NextHigherState_26db::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.state_26fe, currMatch.localVar_26fd);
	}
}

void NextHigherState_26db::outputAppender( const CyberComposition::Simulink::State& state_26ff, const SFC::LocalVar& localVar_2701)
{
	_state_26e2->push_back( state_26ff);
	_localVar_26e3->push_back( localVar_2701);
}

void Register_2709::operator()( const Packets_t& subsystems_270a, const Packets_t& localVars_270c)
{
#ifdef PRINT_INFO
	printLog( "Register_2709" );
#endif
	RTTGenerator::Instance()->generateRule(1933, "Register");
	processInputPackets( subsystems_270a, localVars_270c);
}

bool Register_2709::isInputUnique( const Udm::Object& subsystem_2712, const Udm::Object& localVar_271b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_2714= _subsystem_270e.begin(), itLocalVar_271d= _localVar_2717.begin(); itSubsystem_2714!= _subsystem_270e.end(), itLocalVar_271d!= _localVar_2717.end(); ++itSubsystem_2714, ++itLocalVar_271d)
	{
		if( ( *itSubsystem_2714== subsystem_2712)&& ( *itLocalVar_271d== localVar_271b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_270e.push_back( subsystem_2712);
		_localVar_2717.push_back( localVar_271b);
	}
	return isUnique;
}

bool Register_2709::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Register_2709::processInputPackets( const Packets_t& subsystems_270a, const Packets_t& localVars_270c)
{
	for( Packets_t::const_iterator itSubsystem_270f= subsystems_270a.begin(), itLocalVar_2718= localVars_270c.begin(); itSubsystem_270f!= subsystems_270a.end(), itLocalVar_2718!= localVars_270c.end(); ++itSubsystem_270f, ++itLocalVar_2718)
	{
		bool isUnique= isInputUnique( *itSubsystem_270f, *itLocalVar_2718);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_270f, *itLocalVar_2718);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool Register_2709::patternMatcher( const Udm::Object& subsystem_2710, const Udm::Object& localVar_2719)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_2710.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_2715= CyberComposition::Simulink::Subsystem::Cast( subsystem_2710);
		if( false== Uml::IsDerivedFrom( localVar_2719.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_271e= SFC::LocalVar::Cast( localVar_2719);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2723;
		if( !isValidBound(boundObjs_2723, subsystem_2715, true))
			continue;
		currMatch.subsystem_2724= subsystem_2715;
		if( !isValidBound(boundObjs_2723, localVar_271e, true))
			continue;
		currMatch.localVar_2725= localVar_271e;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Register_2709::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar& LocalVar= currMatch.localVar_2725;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_2724;
		{
SFManager::AddTypedEntityScope( LocalVar );
};
	}
}

void GetScope_2726::operator()( const Packets_t& systems_2727, const Packets_t& localVars_2729, Packets_t& systems_272b, Packets_t& localVars_272c)
{
#ifdef PRINT_INFO
	printLog( "GetScope_2726" );
#endif
	_system_272d= &systems_272b;
	_localVar_272e= &localVars_272c;
	if( ( !systems_2727.empty())&& ( !localVars_2729.empty()))
		callSubSubsystemTest_27bf( systems_2727, localVars_2729);
}

void GetScope_2726::callSubSubsystemTest_27bf( const Packets_t& systems_2758, const Packets_t& localVars_275a)
{
	Packets_t systems_275c;
	Packets_t localVars_275d;
	Packets_t systems_275e;
	Packets_t localVars_275f;
	SubSubsystemTest_2757 subSubsystemTest_2757;
	subSubsystemTest_2757( systems_2758, localVars_275a, systems_275c, localVars_275d, systems_275e, localVars_275f);
	_system_272d->insert( _system_272d->end(), systems_275e.begin(), systems_275e.end());
	_localVar_272e->insert( _localVar_272e->end(), localVars_275f.begin(), localVars_275f.end());
	if( ( !systems_275c.empty())&& ( !localVars_275d.empty()))
		callAddToScope_27c2( systems_275c, localVars_275d);
}

void GetScope_2726::callAddToScope_27c2( const Packets_t& subSubsystems_2730, const Packets_t& localVars_2733)
{
	Packets_t subsystems_2732;
	Packets_t localVars_2735;
	AddToScope_272f addToScope_272f;
	addToScope_272f( subSubsystems_2730, localVars_2733, subsystems_2732, localVars_2735);
	if( ( !subsystems_2732.empty())&& ( !localVars_2735.empty()))
		callSubSubsystemTest_27bf( subsystems_2732, localVars_2735);
}

void AddToScope_272f::operator()( const Packets_t& subSubsystems_2730, const Packets_t& localVars_2733, Packets_t& subsystems_2732, Packets_t& localVars_2735)
{
#ifdef PRINT_INFO
	printLog( "AddToScope_272f" );
#endif
	RTTGenerator::Instance()->generateRule(1942, "AddToScope");
	_subsystem_2736= &subsystems_2732;
	_localVar_2737= &localVars_2735;
	processInputPackets( subSubsystems_2730, localVars_2733);
}

bool AddToScope_272f::isInputUnique( const Udm::Object& subSubsystem_273c, const Udm::Object& localVar_2745)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubSubsystem_273e= _subSubsystem_2738.begin(), itLocalVar_2747= _localVar_2741.begin(); itSubSubsystem_273e!= _subSubsystem_2738.end(), itLocalVar_2747!= _localVar_2741.end(); ++itSubSubsystem_273e, ++itLocalVar_2747)
	{
		if( ( *itSubSubsystem_273e== subSubsystem_273c)&& ( *itLocalVar_2747== localVar_2745))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subSubsystem_2738.push_back( subSubsystem_273c);
		_localVar_2741.push_back( localVar_2745);
	}
	return isUnique;
}

bool AddToScope_272f::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void AddToScope_272f::processInputPackets( const Packets_t& subSubsystems_2730, const Packets_t& localVars_2733)
{
	for( Packets_t::const_iterator itSubSubsystem_2739= subSubsystems_2730.begin(), itLocalVar_2742= localVars_2733.begin(); itSubSubsystem_2739!= subSubsystems_2730.end(), itLocalVar_2742!= localVars_2733.end(); ++itSubSubsystem_2739, ++itLocalVar_2742)
	{
		bool isUnique= isInputUnique( *itSubSubsystem_2739, *itLocalVar_2742);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubSubsystem_2739, *itLocalVar_2742);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AddToScope_272f::patternMatcher( const Udm::Object& subSubsystem_273a, const Udm::Object& localVar_2743)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subSubsystem_273a.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subSubsystem_273f= CyberComposition::Simulink::Subsystem::Cast( subSubsystem_273a);
		if( false== Uml::IsDerivedFrom( localVar_2743.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_2748= SFC::LocalVar::Cast( localVar_2743);
		Udm::Object subSubsystemParent_274a= subSubsystem_273f.container();
		if( false== Uml::IsDerivedFrom( subSubsystemParent_274a.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystemSubSubsystem_274b= CyberComposition::Simulink::Subsystem::Cast( subSubsystemParent_274a);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_274f;
		if( !isValidBound(boundObjs_274f, subSubsystem_273f, true))
			continue;
		currMatch.subSubsystem_2750= subSubsystem_273f;
		if( !isValidBound(boundObjs_274f, localVar_2748, true))
			continue;
		currMatch.localVar_2751= localVar_2748;
		if( !isValidBound(boundObjs_274f, subsystemSubSubsystem_274b, false))
			continue;
		currMatch.subsystem_2752= subsystemSubSubsystem_274b;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void AddToScope_272f::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar& LocalVar= currMatch.localVar_2751;
		CyberComposition::Simulink::Subsystem& SubSubsystem= currMatch.subSubsystem_2750;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_2752;
		{
LocalVar.scope() =
 static_cast< std::string >( Subsystem.name() ) + "/" +
 static_cast< std::string >( LocalVar.scope() );
};
		outputAppender( currMatch.subsystem_2752, currMatch.localVar_2751);
	}
}

void AddToScope_272f::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_2753, const SFC::LocalVar& localVar_2755)
{
	_subsystem_2736->push_back( subsystem_2753);
	_localVar_2737->push_back( localVar_2755);
}

void SubSubsystemTest_2757::operator()( const Packets_t& systems_2758, const Packets_t& localVars_275a, Packets_t& systems_275c, Packets_t& localVars_275d, Packets_t& systems_275e, Packets_t& localVars_275f)
{
#ifdef PRINT_INFO
	printLog( "SubSubsystemTest_2757" );
#endif
	_system_2760= &systems_275c;
	_localVar_2761= &localVars_275d;
	_system_2762= &systems_275e;
	_localVar_2763= &localVars_275f;
	for( Packets_t::const_iterator itsystem_2765= systems_2758.begin(), itlocalVar_276c= localVars_275a.begin(); itsystem_2765!= systems_2758.end(), itlocalVar_276c!= localVars_275a.end(); ++itsystem_2765, ++itlocalVar_276c)
	{
		bool isUnique= isInputUnique( *itsystem_2765, *itlocalVar_276c);
		if( !isUnique)
			continue;
		Packets_t onesystem_2769( 1, *itsystem_2765);
		Packets_t onelocalVar_2770( 1, *itlocalVar_276c);
		executeOne( onesystem_2769, onelocalVar_2770);
	}
}

void SubSubsystemTest_2757::executeOne( const Packets_t& systems_2758, const Packets_t& localVars_275a)
{
	Packets_t subSubsystems_2775;
	Packets_t localVars_2778;
	NotTopSubsystem_2772 notTopSubsystem_2772;
	bool isMatchNotTopSubsystem_2772= notTopSubsystem_2772( systems_2758, localVars_275a, subSubsystems_2775, localVars_2778);
	_system_2760->insert( _system_2760->end(), subSubsystems_2775.begin(), subSubsystems_2775.end());
	_localVar_2761->insert( _localVar_2761->end(), localVars_2778.begin(), localVars_2778.end());
	Packets_t subsystems_279d;
	Packets_t localVars_27a0;
	Otherwise_279a otherwise_279a;
	bool isMatchOtherwise_279a= otherwise_279a( systems_2758, localVars_275a, subsystems_279d, localVars_27a0);
	_system_2762->insert( _system_2762->end(), subsystems_279d.begin(), subsystems_279d.end());
	_localVar_2763->insert( _localVar_2763->end(), localVars_27a0.begin(), localVars_27a0.end());
}

bool SubSubsystemTest_2757::isInputUnique( const Udm::Object& system_2766, const Udm::Object& localVar_276d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itsystem_2768= _system_2764.begin(), itlocalVar_276f= _localVar_276b.begin(); itsystem_2768!= _system_2764.end(), itlocalVar_276f!= _localVar_276b.end(); ++itsystem_2768, ++itlocalVar_276f)
	{
		if( ( *itsystem_2768== system_2766)&& ( *itlocalVar_276f== localVar_276d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_system_2764.push_back( system_2766);
		_localVar_276b.push_back( localVar_276d);
	}
	return isUnique;
}

bool NotTopSubsystem_2772::operator()( const Packets_t& subSubsystems_2773, const Packets_t& localVars_2776, Packets_t& subSubsystems_2775, Packets_t& localVars_2778)
{
#ifdef PRINT_INFO
	printLog( "NotTopSubsystem_2772" );
#endif
	_subSubsystem_2779= &subSubsystems_2775;
	_localVar_277a= &localVars_2778;
	processInputPackets( subSubsystems_2773, localVars_2776);
	if( false== _matches.empty())
		return true;
	return false;
}

bool NotTopSubsystem_2772::isInputUnique( const Udm::Object& subSubsystem_277f, const Udm::Object& localVar_2788)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubSubsystem_2781= _subSubsystem_277b.begin(), itLocalVar_278a= _localVar_2784.begin(); itSubSubsystem_2781!= _subSubsystem_277b.end(), itLocalVar_278a!= _localVar_2784.end(); ++itSubSubsystem_2781, ++itLocalVar_278a)
	{
		if( ( *itSubSubsystem_2781== subSubsystem_277f)&& ( *itLocalVar_278a== localVar_2788))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subSubsystem_277b.push_back( subSubsystem_277f);
		_localVar_2784.push_back( localVar_2788);
	}
	return isUnique;
}

bool NotTopSubsystem_2772::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void NotTopSubsystem_2772::processInputPackets( const Packets_t& subSubsystems_2773, const Packets_t& localVars_2776)
{
	for( Packets_t::const_iterator itSubSubsystem_277c= subSubsystems_2773.begin(), itLocalVar_2785= localVars_2776.begin(); itSubSubsystem_277c!= subSubsystems_2773.end(), itLocalVar_2785!= localVars_2776.end(); ++itSubSubsystem_277c, ++itLocalVar_2785)
	{
		bool isUnique= isInputUnique( *itSubSubsystem_277c, *itLocalVar_2785);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubSubsystem_277c, *itLocalVar_2785);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subSubsystem_2793, currMatch.localVar_2794);
	}
}

bool NotTopSubsystem_2772::patternMatcher( const Udm::Object& subSubsystem_277d, const Udm::Object& localVar_2786)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subSubsystem_277d.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subSubsystem_2782= CyberComposition::Simulink::Subsystem::Cast( subSubsystem_277d);
		if( false== Uml::IsDerivedFrom( localVar_2786.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_278b= SFC::LocalVar::Cast( localVar_2786);
		Udm::Object subSubsystemParent_278d= subSubsystem_2782.container();
		if( false== Uml::IsDerivedFrom( subSubsystemParent_278d.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystemSubSubsystem_278e= CyberComposition::Simulink::Subsystem::Cast( subSubsystemParent_278d);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2792;
		if( !isValidBound(boundObjs_2792, subSubsystem_2782, true))
			continue;
		currMatch.subSubsystem_2793= subSubsystem_2782;
		if( !isValidBound(boundObjs_2792, localVar_278b, true))
			continue;
		currMatch.localVar_2794= localVar_278b;
		if( !isValidBound(boundObjs_2792, subsystemSubSubsystem_278e, false))
			continue;
		currMatch.subsystem_2795= subsystemSubSubsystem_278e;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void NotTopSubsystem_2772::outputAppender( const CyberComposition::Simulink::Subsystem& subSubsystem_2796, const SFC::LocalVar& localVar_2798)
{
	_subSubsystem_2779->push_back( subSubsystem_2796);
	_localVar_277a->push_back( localVar_2798);
}

bool Otherwise_279a::operator()( const Packets_t& subsystems_279b, const Packets_t& localVars_279e, Packets_t& subsystems_279d, Packets_t& localVars_27a0)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_279a" );
#endif
	_subsystem_27a1= &subsystems_279d;
	_localVar_27a2= &localVars_27a0;
	processInputPackets( subsystems_279b, localVars_279e);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_279a::isInputUnique( const Udm::Object& subsystem_27a7, const Udm::Object& localVar_27b0)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_27a9= _subsystem_27a3.begin(), itLocalVar_27b2= _localVar_27ac.begin(); itSubsystem_27a9!= _subsystem_27a3.end(), itLocalVar_27b2!= _localVar_27ac.end(); ++itSubsystem_27a9, ++itLocalVar_27b2)
	{
		if( ( *itSubsystem_27a9== subsystem_27a7)&& ( *itLocalVar_27b2== localVar_27b0))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_27a3.push_back( subsystem_27a7);
		_localVar_27ac.push_back( localVar_27b0);
	}
	return isUnique;
}

bool Otherwise_279a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_279a::processInputPackets( const Packets_t& subsystems_279b, const Packets_t& localVars_279e)
{
	for( Packets_t::const_iterator itSubsystem_27a4= subsystems_279b.begin(), itLocalVar_27ad= localVars_279e.begin(); itSubsystem_27a4!= subsystems_279b.end(), itLocalVar_27ad!= localVars_279e.end(); ++itSubsystem_27a4, ++itLocalVar_27ad)
	{
		bool isUnique= isInputUnique( *itSubsystem_27a4, *itLocalVar_27ad);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_27a4, *itLocalVar_27ad);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_27b9, currMatch.localVar_27ba);
	}
}

bool Otherwise_279a::patternMatcher( const Udm::Object& subsystem_27a5, const Udm::Object& localVar_27ae)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_27a5.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_27aa= CyberComposition::Simulink::Subsystem::Cast( subsystem_27a5);
		if( false== Uml::IsDerivedFrom( localVar_27ae.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_27b3= SFC::LocalVar::Cast( localVar_27ae);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_27b8;
		if( !isValidBound(boundObjs_27b8, subsystem_27aa, true))
			continue;
		currMatch.subsystem_27b9= subsystem_27aa;
		if( !isValidBound(boundObjs_27b8, localVar_27b3, true))
			continue;
		currMatch.localVar_27ba= localVar_27b3;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_279a::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_27bb, const SFC::LocalVar& localVar_27bd)
{
	_subsystem_27a1->push_back( subsystem_27bb);
	_localVar_27a2->push_back( localVar_27bd);
}

void CreateTypes_2807::operator()( const Packets_t& rootFolders_2808, const Packets_t& states_280a, const Packets_t& projects_280c, Packets_t& states_280e, Packets_t& projects_280f)
{
#ifdef PRINT_INFO
	printLog( "CreateTypes_2807" );
#endif
	_state_2810= &states_280e;
	_project_2811= &projects_280f;
	_state_2810->insert( _state_2810->end(), states_280a.begin(), states_280a.end());
	_project_2811->insert( _project_2811->end(), projects_280c.begin(), projects_280c.end());
	if( ( !rootFolders_2808.empty())&& ( !projects_280c.empty()))
		callGetTypeBlock_2db4( rootFolders_2808, projects_280c);
}

void CreateTypes_2807::callGetTypeBlock_2db4( const Packets_t& rootFolders_2d48, const Packets_t& projects_2d4a)
{
	Packets_t typess_2d4c;
	Packets_t projects_2d4d;
	GetTypeBlock_2d47 getTypeBlock_2d47;
	getTypeBlock_2d47( rootFolders_2d48, projects_2d4a, typess_2d4c, projects_2d4d);
	if( ( !typess_2d4c.empty())&& ( !projects_2d4d.empty()))
		callCreateTypesInner_2db7( typess_2d4c, projects_2d4d);
}

void CreateTypes_2807::callCreateTypesInner_2db7( const Packets_t& typess_2813, const Packets_t& projects_2815)
{
	Packets_t typess_2817;
	Packets_t newStructs_2818;
	CreateTypesInner_2812 createTypesInner_2812;
	createTypesInner_2812( typess_2813, projects_2815, typess_2817, newStructs_2818);
	if( ( !typess_2817.empty())&& ( !newStructs_2818.empty()))
		callStructMembers_2dba( typess_2817, newStructs_2818);
}

void CreateTypes_2807::callStructMembers_2dba( const Packets_t& typess_2d18, const Packets_t& newStructs_2d1a)
{
	Packets_t newStructs_2d1c;
	StructMembers_2d17 structMembers_2d17;
	structMembers_2d17( typess_2d18, newStructs_2d1a, newStructs_2d1c);
	if( ( !newStructs_2d1c.empty()))
		callRegisterStruct_2dbd( newStructs_2d1c);
}

void CreateTypes_2807::callRegisterStruct_2dbd( const Packets_t& sfcStructs_2d07)
{
	RegisterStruct_2d06 registerStruct_2d06;
	registerStruct_2d06( sfcStructs_2d07);
}

void CreateTypesInner_2812::operator()( const Packets_t& typess_2813, const Packets_t& projects_2815, Packets_t& typess_2817, Packets_t& newStructs_2818)
{
#ifdef PRINT_INFO
	printLog( "CreateTypesInner_2812" );
#endif
	_types_2819= &typess_2817;
	_newStruct_281a= &newStructs_2818;
	for( Packets_t::const_iterator ittypes_281c= typess_2813.begin(), itproject_2823= projects_2815.begin(); ittypes_281c!= typess_2813.end(), itproject_2823!= projects_2815.end(); ++ittypes_281c, ++itproject_2823)
	{
		bool isUnique= isInputUnique( *ittypes_281c, *itproject_2823);
		if( !isUnique)
			continue;
		Packets_t onetypes_2820( 1, *ittypes_281c);
		Packets_t oneproject_2827( 1, *itproject_2823);
		executeOne( onetypes_2820, oneproject_2827);
	}
}

void CreateTypesInner_2812::executeOne( const Packets_t& typess_2813, const Packets_t& projects_2815)
{
	if( ( !typess_2813.empty())&& ( !projects_2815.empty()))
		callStructOrMatrix_2cfd( typess_2813, projects_2815);
}

bool CreateTypesInner_2812::isInputUnique( const Udm::Object& types_281d, const Udm::Object& project_2824)
{
	bool isUnique= true;
	for( Packets_t::const_iterator ittypes_281f= _types_281b.begin(), itproject_2826= _project_2822.begin(); ittypes_281f!= _types_281b.end(), itproject_2826!= _project_2822.end(); ++ittypes_281f, ++itproject_2826)
	{
		if( ( *ittypes_281f== types_281d)&& ( *itproject_2826== project_2824))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_types_281b.push_back( types_281d);
		_project_2822.push_back( project_2824);
	}
	return isUnique;
}

void CreateTypesInner_2812::callStructOrMatrix_2cfd( const Packets_t& typess_2c73, const Packets_t& projects_2c75)
{
	Packets_t typess_2c77;
	Packets_t projects_2c78;
	Packets_t typess_2c79;
	Packets_t projects_2c7a;
	StructOrMatrix_2c72 structOrMatrix_2c72;
	structOrMatrix_2c72( typess_2c73, projects_2c75, typess_2c77, projects_2c78, typess_2c79, projects_2c7a);
	if( ( !typess_2c77.empty())&& ( !projects_2c78.empty()))
		callCreateStructType_2d00( typess_2c77, projects_2c78);
	if( ( !typess_2c79.empty())&& ( !projects_2c7a.empty()))
		callCreateArrayOrBasicType_2d03( typess_2c79, projects_2c7a);
}

void CreateTypesInner_2812::callCreateStructType_2d00( const Packets_t& ecsl_dp_Structs_2cd8, const Packets_t& projects_2cdb)
{
	Packets_t ecsl_dp_Structs_2cda;
	Packets_t sfc_Structs_2cdd;
	CreateStructType_2cd7 createStructType_2cd7;
	createStructType_2cd7( ecsl_dp_Structs_2cd8, projects_2cdb, ecsl_dp_Structs_2cda, sfc_Structs_2cdd);
	_types_2819->insert( _types_2819->end(), ecsl_dp_Structs_2cda.begin(), ecsl_dp_Structs_2cda.end());
	_newStruct_281a->insert( _newStruct_281a->end(), sfc_Structs_2cdd.begin(), sfc_Structs_2cdd.end());
}

void CreateTypesInner_2812::callCreateArrayOrBasicType_2d03( const Packets_t& typess_282a, const Packets_t& projects_282c)
{
	CreateArrayOrBasicType_2829 createArrayOrBasicType_2829;
	createArrayOrBasicType_2829( typess_282a, projects_282c);
}

void CreateArrayOrBasicType_2829::operator()( const Packets_t& typess_282a, const Packets_t& projects_282c)
{
#ifdef PRINT_INFO
	printLog( "CreateArrayOrBasicType_2829" );
#endif
	if( ( !typess_282a.empty())&& ( !projects_282c.empty()))
		callDimensionTest_2c60( typess_282a, projects_282c);
}

void CreateArrayOrBasicType_2829::callDimensionTest_2c60( const Packets_t& typess_2bcf, const Packets_t& projects_2bd1)
{
	Packets_t typess_2bd3;
	Packets_t projects_2bd4;
	Packets_t typess_2bd5;
	Packets_t projects_2bd6;
	Packets_t typess_2bd7;
	Packets_t projects_2bd8;
	DimensionTest_2bce dimensionTest_2bce;
	dimensionTest_2bce( typess_2bcf, projects_2bd1, typess_2bd3, projects_2bd4, typess_2bd5, projects_2bd6, typess_2bd7, projects_2bd8);
	if( ( !typess_2bd7.empty())&& ( !projects_2bd8.empty()))
		callProcessOther_2c63( typess_2bd7, projects_2bd8);
	if( ( !typess_2bd5.empty())&& ( !projects_2bd6.empty()))
		callProcessColumn_2c66( typess_2bd5, projects_2bd6);
	if( ( !typess_2bd3.empty())&& ( !projects_2bd4.empty()))
		callProcessScalar_2c69( typess_2bd3, projects_2bd4);
}

void CreateArrayOrBasicType_2829::callProcessOther_2c63( const Packets_t& typess_286d, const Packets_t& projects_286f)
{
	Packets_t typess_2871;
	Packets_t array1s_2872;
	Packets_t projects_2873;
	ProcessOther_286c processOther_286c;
	processOther_286c( typess_286d, projects_286f, typess_2871, array1s_2872, projects_2873);
	if( ( !typess_2871.empty())&& ( !array1s_2872.empty()))
		callRegisterType_2c6c( typess_2871, array1s_2872);
}

void CreateArrayOrBasicType_2829::callProcessColumn_2c66( const Packets_t& typess_2bbd, const Packets_t& projects_2bbf)
{
	Packets_t typess_2bc1;
	Packets_t array1s_2bc2;
	Packets_t projects_2bc3;
	ProcessColumn_2bbc processColumn_2bbc;
	processColumn_2bbc( typess_2bbd, projects_2bbf, typess_2bc1, array1s_2bc2, projects_2bc3);
	if( ( !typess_2bc1.empty())&& ( !array1s_2bc2.empty()))
		callRegisterType_2c6c( typess_2bc1, array1s_2bc2);
}

void CreateArrayOrBasicType_2829::callProcessScalar_2c69( const Packets_t& typess_29ad, const Packets_t& projects_29af)
{
	Packets_t typess_29b1;
	Packets_t basictypes_29b2;
	Packets_t projects_29b3;
	ProcessScalar_29ac processScalar_29ac;
	processScalar_29ac( typess_29ad, projects_29af, typess_29b1, basictypes_29b2, projects_29b3);
	if( ( !typess_29b1.empty())&& ( !basictypes_29b2.empty()))
		callRegisterType_2c6c( typess_29b1, basictypes_29b2);
}

void CreateArrayOrBasicType_2829::callRegisterType_2c6c( const Packets_t& matrixs_282f, const Packets_t& dTs_2832)
{
	Packets_t matrixs_2831;
	Packets_t dTs_2834;
	RegisterType_282e registerType_282e;
	registerType_282e( matrixs_282f, dTs_2832, matrixs_2831, dTs_2834);
	if( ( !matrixs_2831.empty())&& ( !dTs_2834.empty()))
		callMakeAssoc_2c6f( matrixs_2831, dTs_2834);
}

void CreateArrayOrBasicType_2829::callMakeAssoc_2c6f( const Packets_t& matrixs_2850, const Packets_t& dTs_2852)
{
	MakeAssoc_284f makeAssoc_284f;
	makeAssoc_284f( matrixs_2850, dTs_2852);
}

void RegisterType_282e::operator()( const Packets_t& matrixs_282f, const Packets_t& dTs_2832, Packets_t& matrixs_2831, Packets_t& dTs_2834)
{
#ifdef PRINT_INFO
	printLog( "RegisterType_282e" );
#endif
	RTTGenerator::Instance()->generateRule(1990, "RegisterType");
	_matrix_2835= &matrixs_2831;
	_dT_2836= &dTs_2834;
	processInputPackets( matrixs_282f, dTs_2832);
	forwardInputs( );
}

bool RegisterType_282e::isInputUnique( const Udm::Object& matrix_283b, const Udm::Object& dT_2844)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_283d= _matrix_2837.begin(), itDT_2846= _dT_2840.begin(); itMatrix_283d!= _matrix_2837.end(), itDT_2846!= _dT_2840.end(); ++itMatrix_283d, ++itDT_2846)
	{
		if( ( *itMatrix_283d== matrix_283b)&& ( *itDT_2846== dT_2844))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_2837.push_back( matrix_283b);
		_dT_2840.push_back( dT_2844);
	}
	return isUnique;
}

bool RegisterType_282e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void RegisterType_282e::processInputPackets( const Packets_t& matrixs_282f, const Packets_t& dTs_2832)
{
	for( Packets_t::const_iterator itMatrix_2838= matrixs_282f.begin(), itDT_2841= dTs_2832.begin(); itMatrix_2838!= matrixs_282f.end(), itDT_2841!= dTs_2832.end(); ++itMatrix_2838, ++itDT_2841)
	{
		bool isUnique= isInputUnique( *itMatrix_2838, *itDT_2841);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_2838, *itDT_2841);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool RegisterType_282e::patternMatcher( const Udm::Object& matrix_2839, const Udm::Object& dT_2842)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_2839.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_283e= CyberComposition::Simulink::SF_Matrix::Cast( matrix_2839);
		if( false== Uml::IsDerivedFrom( dT_2842.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_2847= SFC::DT::Cast( dT_2842);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_284c;
		if( !isValidBound(boundObjs_284c, matrix_283e, true))
			continue;
		currMatch.matrix_284d= matrix_283e;
		if( !isValidBound(boundObjs_284c, dT_2847, true))
			continue;
		currMatch.dT_284e= dT_2847;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void RegisterType_282e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::DT& DT= currMatch.dT_284e;
		CyberComposition::Simulink::SF_Matrix& Matrix= currMatch.matrix_284d;
		{
SFCTypesManager::getSingleton().makeTypeUnique( DT );
};
	}
}

void RegisterType_282e::forwardInputs()
{
	*_matrix_2835= _matrix_2837;
	*_dT_2836= _dT_2840;
}

void MakeAssoc_284f::operator()( const Packets_t& matrixs_2850, const Packets_t& dTs_2852)
{
#ifdef PRINT_INFO
	printLog( "MakeAssoc_284f" );
#endif
	RTTGenerator::Instance()->generateRule(1994, "MakeAssoc");
	processInputPackets( matrixs_2850, dTs_2852);
}

bool MakeAssoc_284f::isInputUnique( const Udm::Object& matrix_2858, const Udm::Object& dT_2861)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_285a= _matrix_2854.begin(), itDT_2863= _dT_285d.begin(); itMatrix_285a!= _matrix_2854.end(), itDT_2863!= _dT_285d.end(); ++itMatrix_285a, ++itDT_2863)
	{
		if( ( *itMatrix_285a== matrix_2858)&& ( *itDT_2863== dT_2861))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_2854.push_back( matrix_2858);
		_dT_285d.push_back( dT_2861);
	}
	return isUnique;
}

bool MakeAssoc_284f::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void MakeAssoc_284f::processInputPackets( const Packets_t& matrixs_2850, const Packets_t& dTs_2852)
{
	for( Packets_t::const_iterator itMatrix_2855= matrixs_2850.begin(), itDT_285e= dTs_2852.begin(); itMatrix_2855!= matrixs_2850.end(), itDT_285e!= dTs_2852.end(); ++itMatrix_2855, ++itDT_285e)
	{
		bool isUnique= isInputUnique( *itMatrix_2855, *itDT_285e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_2855, *itDT_285e);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool MakeAssoc_284f::patternMatcher( const Udm::Object& matrix_2856, const Udm::Object& dT_285f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_2856.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_285b= CyberComposition::Simulink::SF_Matrix::Cast( matrix_2856);
		if( false== Uml::IsDerivedFrom( dT_285f.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_2864= SFC::DT::Cast( dT_285f);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2869;
		if( !isValidBound(boundObjs_2869, matrix_285b, true))
			continue;
		currMatch.matrix_286a= matrix_285b;
		if( !isValidBound(boundObjs_2869, dT_2864, true))
			continue;
		currMatch.dT_286b= dT_2864;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void MakeAssoc_284f::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		currMatch.dT_286b.tb()= currMatch.matrix_286a;
	}
}

void ProcessOther_286c::operator()( const Packets_t& typess_286d, const Packets_t& projects_286f, Packets_t& typess_2871, Packets_t& array1s_2872, Packets_t& projects_2873)
{
#ifdef PRINT_INFO
	printLog( "ProcessOther_286c" );
#endif
	_types_2874= &typess_2871;
	_array1_2875= &array1s_2872;
	_project_2876= &projects_2873;
	if( ( !typess_286d.empty())&& ( !projects_286f.empty()))
		callProcessRowVector_2bb5( typess_286d, projects_286f);
}

void ProcessOther_286c::callProcessRowVector_2bb5( const Packets_t& typess_2878, const Packets_t& projects_287a)
{
	Packets_t typess_287c;
	Packets_t array2s_287d;
	Packets_t projectss_287e;
	ProcessRowVector_2877 processRowVector_2877;
	processRowVector_2877( typess_2878, projects_287a, typess_287c, array2s_287d, projectss_287e);
	if( ( !typess_287c.empty())&& ( !array2s_287d.empty())&& ( !projectss_287e.empty()))
		callProcessArray1_2bb8( typess_287c, array2s_287d, projectss_287e);
}

void ProcessOther_286c::callProcessArray1_2bb8( const Packets_t& typess_2a8e, const Packets_t& basictypes_2a90, const Packets_t& projects_2a92)
{
	Packets_t typess_2a94;
	Packets_t array1s_2a95;
	Packets_t projects_2a96;
	ProcessArray1_2a8d processArray1_2a8d;
	processArray1_2a8d( typess_2a8e, basictypes_2a90, projects_2a92, typess_2a94, array1s_2a95, projects_2a96);
	_project_2876->insert( _project_2876->end(), projects_2a96.begin(), projects_2a96.end());
	_types_2874->insert( _types_2874->end(), typess_2a94.begin(), typess_2a94.end());
	_array1_2875->insert( _array1_2875->end(), array1s_2a95.begin(), array1s_2a95.end());
}

void ProcessRowVector_2877::operator()( const Packets_t& typess_2878, const Packets_t& projects_287a, Packets_t& typess_287c, Packets_t& array2s_287d, Packets_t& projectss_287e)
{
#ifdef PRINT_INFO
	printLog( "ProcessRowVector_2877" );
#endif
	_types_287f= &typess_287c;
	_array2_2880= &array2s_287d;
	_projects_2881= &projectss_287e;
	if( ( !typess_2878.empty())&& ( !projects_287a.empty()))
		callProcessScalar_2a86( typess_2878, projects_287a);
}

void ProcessRowVector_2877::callProcessScalar_2a86( const Packets_t& typess_29ad, const Packets_t& projects_29af)
{
	Packets_t typess_29b1;
	Packets_t basictypes_29b2;
	Packets_t projects_29b3;
	ProcessScalar_29ac processScalar_29ac;
	processScalar_29ac( typess_29ad, projects_29af, typess_29b1, basictypes_29b2, projects_29b3);
	if( ( !typess_29b1.empty())&& ( !basictypes_29b2.empty())&& ( !projects_29b3.empty()))
		callProcessArray2_2a89( typess_29b1, basictypes_29b2, projects_29b3);
}

void ProcessRowVector_2877::callProcessArray2_2a89( const Packets_t& typess_2883, const Packets_t& basictypes_2885, const Packets_t& projects_2887)
{
	Packets_t typess_2889;
	Packets_t array2s_288a;
	Packets_t projectss_288b;
	ProcessArray2_2882 processArray2_2882;
	processArray2_2882( typess_2883, basictypes_2885, projects_2887, typess_2889, array2s_288a, projectss_288b);
	_types_287f->insert( _types_287f->end(), typess_2889.begin(), typess_2889.end());
	_array2_2880->insert( _array2_2880->end(), array2s_288a.begin(), array2s_288a.end());
	_projects_2881->insert( _projects_2881->end(), projectss_288b.begin(), projectss_288b.end());
}

void ProcessArray2_2882::operator()( const Packets_t& typess_2883, const Packets_t& basictypes_2885, const Packets_t& projects_2887, Packets_t& typess_2889, Packets_t& array2s_288a, Packets_t& projectss_288b)
{
#ifdef PRINT_INFO
	printLog( "ProcessArray2_2882" );
#endif
	_types_288c= &typess_2889;
	_array2_288d= &array2s_288a;
	_projects_288e= &projectss_288b;
	if( ( !typess_2883.empty())&& ( !basictypes_2885.empty())&& ( !projects_2887.empty()))
		callGetArray2_29a0( typess_2883, basictypes_2885, projects_2887);
}

void ProcessArray2_2882::callGetArray2_29a0( const Packets_t& typess_2890, const Packets_t& basictypes_2892, const Packets_t& projects_2894)
{
	Packets_t typess_2896;
	Packets_t basictypes_2897;
	Packets_t projectss_2898;
	Packets_t typess_2899;
	Packets_t basictypes_289a;
	Packets_t projectss_289b;
	GetArray2_288f getArray2_288f;
	getArray2_288f( typess_2890, basictypes_2892, projects_2894, typess_2896, basictypes_2897, projectss_2898, typess_2899, basictypes_289a, projectss_289b);
	if( ( !typess_2896.empty())&& ( !basictypes_2897.empty())&& ( !projectss_2898.empty()))
		callUseArray2_29a4( typess_2896, basictypes_2897, projectss_2898);
	if( ( !typess_2899.empty())&& ( !basictypes_289a.empty())&& ( !projectss_289b.empty()))
		callCreateArray2_29a8( typess_2899, basictypes_289a, projectss_289b);
}

void ProcessArray2_2882::callUseArray2_29a4( const Packets_t& matrixs_292c, const Packets_t& basicTypes_2930, const Packets_t& projects_2932)
{
	Packets_t matrixs_292e;
	Packets_t arrays_292f;
	Packets_t projects_2934;
	UseArray2_292b useArray2_292b;
	useArray2_292b( matrixs_292c, basicTypes_2930, projects_2932, matrixs_292e, arrays_292f, projects_2934);
	_types_288c->insert( _types_288c->end(), matrixs_292e.begin(), matrixs_292e.end());
	_array2_288d->insert( _array2_288d->end(), arrays_292f.begin(), arrays_292f.end());
	_projects_288e->insert( _projects_288e->end(), projects_2934.begin(), projects_2934.end());
}

void ProcessArray2_2882::callCreateArray2_29a8( const Packets_t& matrixs_296b, const Packets_t& basicTypes_296f, const Packets_t& projects_2971)
{
	Packets_t matrixs_296d;
	Packets_t arrays_296e;
	Packets_t projects_2973;
	CreateArray2_296a createArray2_296a;
	createArray2_296a( matrixs_296b, basicTypes_296f, projects_2971, matrixs_296d, arrays_296e, projects_2973);
	_types_288c->insert( _types_288c->end(), matrixs_296d.begin(), matrixs_296d.end());
	_array2_288d->insert( _array2_288d->end(), arrays_296e.begin(), arrays_296e.end());
	_projects_288e->insert( _projects_288e->end(), projects_2973.begin(), projects_2973.end());
}

void GetArray2_288f::operator()( const Packets_t& typess_2890, const Packets_t& basictypes_2892, const Packets_t& projects_2894, Packets_t& typess_2896, Packets_t& basictypes_2897, Packets_t& projectss_2898, Packets_t& typess_2899, Packets_t& basictypes_289a, Packets_t& projectss_289b)
{
#ifdef PRINT_INFO
	printLog( "GetArray2_288f" );
#endif
	_types_289c= &typess_2896;
	_basictype_289d= &basictypes_2897;
	_projects_289e= &projectss_2898;
	_types_289f= &typess_2899;
	_basictype_28a0= &basictypes_289a;
	_projects_28a1= &projectss_289b;
	for( Packets_t::const_iterator ittypes_28a3= typess_2890.begin(), itbasictype_28aa= basictypes_2892.begin(), itproject_28b1= projects_2894.begin(); ittypes_28a3!= typess_2890.end(), itbasictype_28aa!= basictypes_2892.end(), itproject_28b1!= projects_2894.end(); ++ittypes_28a3, ++itbasictype_28aa, ++itproject_28b1)
	{
		bool isUnique= isInputUnique( *ittypes_28a3, *itbasictype_28aa, *itproject_28b1);
		if( !isUnique)
			continue;
		Packets_t onetypes_28a7( 1, *ittypes_28a3);
		Packets_t onebasictype_28ae( 1, *itbasictype_28aa);
		Packets_t oneproject_28b5( 1, *itproject_28b1);
		executeOne( onetypes_28a7, onebasictype_28ae, oneproject_28b5);
	}
}

void GetArray2_288f::executeOne( const Packets_t& typess_2890, const Packets_t& basictypes_2892, const Packets_t& projects_2894)
{
	Packets_t matrixs_28ba;
	Packets_t basicTypes_28bd;
	Packets_t projects_28c0;
	Array2Exists_28b7 array2Exists_28b7;
	bool isMatchArray2Exists_28b7= array2Exists_28b7( typess_2890, basictypes_2892, projects_2894, matrixs_28ba, basicTypes_28bd, projects_28c0);
	_types_289c->insert( _types_289c->end(), matrixs_28ba.begin(), matrixs_28ba.end());
	_basictype_289d->insert( _basictype_289d->end(), basicTypes_28bd.begin(), basicTypes_28bd.end());
	_projects_289e->insert( _projects_289e->end(), projects_28c0.begin(), projects_28c0.end());
	if( isMatchArray2Exists_28b7)
		return;
	Packets_t matrixs_28f9;
	Packets_t basicTypes_28fc;
	Packets_t projects_28ff;
	Otherwise_28f6 otherwise_28f6;
	bool isMatchOtherwise_28f6= otherwise_28f6( typess_2890, basictypes_2892, projects_2894, matrixs_28f9, basicTypes_28fc, projects_28ff);
	_types_289f->insert( _types_289f->end(), matrixs_28f9.begin(), matrixs_28f9.end());
	_basictype_28a0->insert( _basictype_28a0->end(), basicTypes_28fc.begin(), basicTypes_28fc.end());
	_projects_28a1->insert( _projects_28a1->end(), projects_28ff.begin(), projects_28ff.end());
	if( isMatchOtherwise_28f6)
		return;
}

bool GetArray2_288f::isInputUnique( const Udm::Object& types_28a4, const Udm::Object& basictype_28ab, const Udm::Object& project_28b2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator ittypes_28a6= _types_28a2.begin(), itbasictype_28ad= _basictype_28a9.begin(), itproject_28b4= _project_28b0.begin(); ittypes_28a6!= _types_28a2.end(), itbasictype_28ad!= _basictype_28a9.end(), itproject_28b4!= _project_28b0.end(); ++ittypes_28a6, ++itbasictype_28ad, ++itproject_28b4)
	{
		if( ( *ittypes_28a6== types_28a4)&& ( *itbasictype_28ad== basictype_28ab)&& ( *itproject_28b4== project_28b2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_types_28a2.push_back( types_28a4);
		_basictype_28a9.push_back( basictype_28ab);
		_project_28b0.push_back( project_28b2);
	}
	return isUnique;
}

bool Array2Exists_28b7::operator()( const Packets_t& matrixs_28b8, const Packets_t& basicTypes_28bb, const Packets_t& projects_28be, Packets_t& matrixs_28ba, Packets_t& basicTypes_28bd, Packets_t& projects_28c0)
{
#ifdef PRINT_INFO
	printLog( "Array2Exists_28b7" );
#endif
	_matrix_28c1= &matrixs_28ba;
	_basicType_28c2= &basicTypes_28bd;
	_project_28c3= &projects_28c0;
	processInputPackets( matrixs_28b8, basicTypes_28bb, projects_28be);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Array2Exists_28b7::isInputUnique( const Udm::Object& matrix_28c8, const Udm::Object& basicType_28d1, const Udm::Object& project_28da)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_28ca= _matrix_28c4.begin(), itBasicType_28d3= _basicType_28cd.begin(), itProject_28dc= _project_28d6.begin(); itMatrix_28ca!= _matrix_28c4.end(), itBasicType_28d3!= _basicType_28cd.end(), itProject_28dc!= _project_28d6.end(); ++itMatrix_28ca, ++itBasicType_28d3, ++itProject_28dc)
	{
		if( ( *itMatrix_28ca== matrix_28c8)&& ( *itBasicType_28d3== basicType_28d1)&& ( *itProject_28dc== project_28da))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_28c4.push_back( matrix_28c8);
		_basicType_28cd.push_back( basicType_28d1);
		_project_28d6.push_back( project_28da);
	}
	return isUnique;
}

bool Array2Exists_28b7::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool Array2Exists_28b7::isGuardTrue( SFC::Array& Array, SFC::BasicType& BasicType, CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard = Matrix.columns() == Array.noelem();;
	return Gz_guard;
}

void Array2Exists_28b7::processInputPackets( const Packets_t& matrixs_28b8, const Packets_t& basicTypes_28bb, const Packets_t& projects_28be)
{
	for( Packets_t::const_iterator itMatrix_28c5= matrixs_28b8.begin(), itBasicType_28ce= basicTypes_28bb.begin(), itProject_28d7= projects_28be.begin(); itMatrix_28c5!= matrixs_28b8.end(), itBasicType_28ce!= basicTypes_28bb.end(), itProject_28d7!= projects_28be.end(); ++itMatrix_28c5, ++itBasicType_28ce, ++itProject_28d7)
	{
		bool isUnique= isInputUnique( *itMatrix_28c5, *itBasicType_28ce, *itProject_28d7);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_28c5, *itBasicType_28ce, *itProject_28d7);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_28e8, currMatch.basicType_28e9, currMatch.project_28ea);
	}
}

bool Array2Exists_28b7::patternMatcher( const Udm::Object& matrix_28c6, const Udm::Object& basicType_28cf, const Udm::Object& project_28d8)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_28c6.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_28cb= CyberComposition::Simulink::SF_Matrix::Cast( matrix_28c6);
		if( false== Uml::IsDerivedFrom( basicType_28cf.type(), SFC::BasicType::meta))
			continue;
		SFC::BasicType basicType_28d4= SFC::BasicType::Cast( basicType_28cf);
		if( false== Uml::IsDerivedFrom( project_28d8.type(), SFC::Project::meta))
			continue;
		SFC::Project project_28dd= SFC::Project::Cast( project_28d8);
		set< SFC::Array> arrays_28df= project_28dd.Array_kind_children();
		for( set< SFC::Array>::const_iterator itArray_28e0= arrays_28df.begin(); itArray_28e0!= arrays_28df.end(); ++itArray_28e0)
		{
			SFC::Array currArray_28e1= *itArray_28e0;
			SFC::DT basicType_28e2= currArray_28e1.dt();
			if( false== Uml::IsDerivedFrom( basicType_28e2.type(), SFC::BasicType::meta))
				continue;
			SFC::BasicType basicType_28e3= SFC::BasicType::Cast( basicType_28e2);
			if( !basicType_28e3)
				continue;
			if( basicType_28d4!= basicType_28e3)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_28e7;
			if( !isValidBound(boundObjs_28e7, matrix_28cb, true))
				continue;
			currMatch.matrix_28e8= matrix_28cb;
			if( !isValidBound(boundObjs_28e7, basicType_28d4, true))
				continue;
			currMatch.basicType_28e9= basicType_28d4;
			if( !isValidBound(boundObjs_28e7, project_28dd, true))
				continue;
			currMatch.project_28ea= project_28dd;
			if( !isValidBound(boundObjs_28e7, currArray_28e1, false))
				continue;
			currMatch.array_28eb= currArray_28e1;
			bool Gz_guard= isGuardTrue( currMatch.array_28eb, currMatch.basicType_28e9, currMatch.matrix_28e8, currMatch.project_28ea);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void Array2Exists_28b7::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_28f0, const SFC::BasicType& basicType_28f2, const SFC::Project& project_28f4)
{
	_matrix_28c1->push_back( matrix_28f0);
	_basicType_28c2->push_back( basicType_28f2);
	_project_28c3->push_back( project_28f4);
}

bool Otherwise_28f6::operator()( const Packets_t& matrixs_28f7, const Packets_t& basicTypes_28fa, const Packets_t& projects_28fd, Packets_t& matrixs_28f9, Packets_t& basicTypes_28fc, Packets_t& projects_28ff)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_28f6" );
#endif
	_matrix_2900= &matrixs_28f9;
	_basicType_2901= &basicTypes_28fc;
	_project_2902= &projects_28ff;
	processInputPackets( matrixs_28f7, basicTypes_28fa, projects_28fd);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_28f6::isInputUnique( const Udm::Object& matrix_2907, const Udm::Object& basicType_2910, const Udm::Object& project_2919)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_2909= _matrix_2903.begin(), itBasicType_2912= _basicType_290c.begin(), itProject_291b= _project_2915.begin(); itMatrix_2909!= _matrix_2903.end(), itBasicType_2912!= _basicType_290c.end(), itProject_291b!= _project_2915.end(); ++itMatrix_2909, ++itBasicType_2912, ++itProject_291b)
	{
		if( ( *itMatrix_2909== matrix_2907)&& ( *itBasicType_2912== basicType_2910)&& ( *itProject_291b== project_2919))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_2903.push_back( matrix_2907);
		_basicType_290c.push_back( basicType_2910);
		_project_2915.push_back( project_2919);
	}
	return isUnique;
}

bool Otherwise_28f6::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_28f6::processInputPackets( const Packets_t& matrixs_28f7, const Packets_t& basicTypes_28fa, const Packets_t& projects_28fd)
{
	for( Packets_t::const_iterator itMatrix_2904= matrixs_28f7.begin(), itBasicType_290d= basicTypes_28fa.begin(), itProject_2916= projects_28fd.begin(); itMatrix_2904!= matrixs_28f7.end(), itBasicType_290d!= basicTypes_28fa.end(), itProject_2916!= projects_28fd.end(); ++itMatrix_2904, ++itBasicType_290d, ++itProject_2916)
	{
		bool isUnique= isInputUnique( *itMatrix_2904, *itBasicType_290d, *itProject_2916);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_2904, *itBasicType_290d, *itProject_2916);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_2922, currMatch.basicType_2923, currMatch.project_2924);
	}
}

bool Otherwise_28f6::patternMatcher( const Udm::Object& matrix_2905, const Udm::Object& basicType_290e, const Udm::Object& project_2917)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_2905.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_290a= CyberComposition::Simulink::SF_Matrix::Cast( matrix_2905);
		if( false== Uml::IsDerivedFrom( basicType_290e.type(), SFC::BasicType::meta))
			continue;
		SFC::BasicType basicType_2913= SFC::BasicType::Cast( basicType_290e);
		if( false== Uml::IsDerivedFrom( project_2917.type(), SFC::Project::meta))
			continue;
		SFC::Project project_291c= SFC::Project::Cast( project_2917);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2921;
		if( !isValidBound(boundObjs_2921, matrix_290a, true))
			continue;
		currMatch.matrix_2922= matrix_290a;
		if( !isValidBound(boundObjs_2921, basicType_2913, true))
			continue;
		currMatch.basicType_2923= basicType_2913;
		if( !isValidBound(boundObjs_2921, project_291c, true))
			continue;
		currMatch.project_2924= project_291c;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_28f6::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_2925, const SFC::BasicType& basicType_2927, const SFC::Project& project_2929)
{
	_matrix_2900->push_back( matrix_2925);
	_basicType_2901->push_back( basicType_2927);
	_project_2902->push_back( project_2929);
}

void UseArray2_292b::operator()( const Packets_t& matrixs_292c, const Packets_t& basicTypes_2930, const Packets_t& projects_2932, Packets_t& matrixs_292e, Packets_t& arrays_292f, Packets_t& projects_2934)
{
#ifdef PRINT_INFO
	printLog( "UseArray2_292b" );
#endif
	RTTGenerator::Instance()->generateRule(2038, "UseArray2");
	_matrix_2935= &matrixs_292e;
	_array_2936= &arrays_292f;
	_project_2937= &projects_2934;
	processInputPackets( matrixs_292c, basicTypes_2930, projects_2932);
}

bool UseArray2_292b::isInputUnique( const Udm::Object& matrix_293c, const Udm::Object& basicType_2945, const Udm::Object& project_294e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_293e= _matrix_2938.begin(), itBasicType_2947= _basicType_2941.begin(), itProject_2950= _project_294a.begin(); itMatrix_293e!= _matrix_2938.end(), itBasicType_2947!= _basicType_2941.end(), itProject_2950!= _project_294a.end(); ++itMatrix_293e, ++itBasicType_2947, ++itProject_2950)
	{
		if( ( *itMatrix_293e== matrix_293c)&& ( *itBasicType_2947== basicType_2945)&& ( *itProject_2950== project_294e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_2938.push_back( matrix_293c);
		_basicType_2941.push_back( basicType_2945);
		_project_294a.push_back( project_294e);
	}
	return isUnique;
}

bool UseArray2_292b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool UseArray2_292b::isGuardTrue( SFC::Array& Array, SFC::BasicType& BasicType, CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard = Matrix.columns() == Array.noelem();;
	return Gz_guard;
}

void UseArray2_292b::processInputPackets( const Packets_t& matrixs_292c, const Packets_t& basicTypes_2930, const Packets_t& projects_2932)
{
	for( Packets_t::const_iterator itMatrix_2939= matrixs_292c.begin(), itBasicType_2942= basicTypes_2930.begin(), itProject_294b= projects_2932.begin(); itMatrix_2939!= matrixs_292c.end(), itBasicType_2942!= basicTypes_2930.end(), itProject_294b!= projects_2932.end(); ++itMatrix_2939, ++itBasicType_2942, ++itProject_294b)
	{
		bool isUnique= isInputUnique( *itMatrix_2939, *itBasicType_2942, *itProject_294b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_2939, *itBasicType_2942, *itProject_294b);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool UseArray2_292b::patternMatcher( const Udm::Object& matrix_293a, const Udm::Object& basicType_2943, const Udm::Object& project_294c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_293a.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_293f= CyberComposition::Simulink::SF_Matrix::Cast( matrix_293a);
		if( false== Uml::IsDerivedFrom( basicType_2943.type(), SFC::BasicType::meta))
			continue;
		SFC::BasicType basicType_2948= SFC::BasicType::Cast( basicType_2943);
		if( false== Uml::IsDerivedFrom( project_294c.type(), SFC::Project::meta))
			continue;
		SFC::Project project_2951= SFC::Project::Cast( project_294c);
		set< SFC::Array> arrays_2953= project_2951.Array_kind_children();
		for( set< SFC::Array>::const_iterator itArray_2954= arrays_2953.begin(); itArray_2954!= arrays_2953.end(); ++itArray_2954)
		{
			SFC::Array currArray_2955= *itArray_2954;
			SFC::DT basicType_2956= currArray_2955.dt();
			if( false== Uml::IsDerivedFrom( basicType_2956.type(), SFC::BasicType::meta))
				continue;
			SFC::BasicType basicType_2957= SFC::BasicType::Cast( basicType_2956);
			if( !basicType_2957)
				continue;
			if( basicType_2948!= basicType_2957)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_295b;
			if( !isValidBound(boundObjs_295b, matrix_293f, true))
				continue;
			currMatch.matrix_295c= matrix_293f;
			if( !isValidBound(boundObjs_295b, basicType_2948, true))
				continue;
			currMatch.basicType_295d= basicType_2948;
			if( !isValidBound(boundObjs_295b, project_2951, true))
				continue;
			currMatch.project_295e= project_2951;
			if( !isValidBound(boundObjs_295b, currArray_2955, false))
				continue;
			currMatch.array_295f= currArray_2955;
			bool Gz_guard= isGuardTrue( currMatch.array_295f, currMatch.basicType_295d, currMatch.matrix_295c, currMatch.project_295e);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void UseArray2_292b::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_295c, currMatch.array_295f, currMatch.project_295e);
	}
}

void UseArray2_292b::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_2964, const SFC::Array& array_2966, const SFC::Project& project_2968)
{
	_matrix_2935->push_back( matrix_2964);
	_array_2936->push_back( array_2966);
	_project_2937->push_back( project_2968);
}

void CreateArray2_296a::operator()( const Packets_t& matrixs_296b, const Packets_t& basicTypes_296f, const Packets_t& projects_2971, Packets_t& matrixs_296d, Packets_t& arrays_296e, Packets_t& projects_2973)
{
#ifdef PRINT_INFO
	printLog( "CreateArray2_296a" );
#endif
	RTTGenerator::Instance()->generateRule(2045, "CreateArray2");
	_matrix_2974= &matrixs_296d;
	_array_2975= &arrays_296e;
	_project_2976= &projects_2973;
	processInputPackets( matrixs_296b, basicTypes_296f, projects_2971);
}

bool CreateArray2_296a::isInputUnique( const Udm::Object& matrix_297b, const Udm::Object& basicType_2984, const Udm::Object& project_298d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_297d= _matrix_2977.begin(), itBasicType_2986= _basicType_2980.begin(), itProject_298f= _project_2989.begin(); itMatrix_297d!= _matrix_2977.end(), itBasicType_2986!= _basicType_2980.end(), itProject_298f!= _project_2989.end(); ++itMatrix_297d, ++itBasicType_2986, ++itProject_298f)
	{
		if( ( *itMatrix_297d== matrix_297b)&& ( *itBasicType_2986== basicType_2984)&& ( *itProject_298f== project_298d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_2977.push_back( matrix_297b);
		_basicType_2980.push_back( basicType_2984);
		_project_2989.push_back( project_298d);
	}
	return isUnique;
}

bool CreateArray2_296a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateArray2_296a::processInputPackets( const Packets_t& matrixs_296b, const Packets_t& basicTypes_296f, const Packets_t& projects_2971)
{
	for( Packets_t::const_iterator itMatrix_2978= matrixs_296b.begin(), itBasicType_2981= basicTypes_296f.begin(), itProject_298a= projects_2971.begin(); itMatrix_2978!= matrixs_296b.end(), itBasicType_2981!= basicTypes_296f.end(), itProject_298a!= projects_2971.end(); ++itMatrix_2978, ++itBasicType_2981, ++itProject_298a)
	{
		bool isUnique= isInputUnique( *itMatrix_2978, *itBasicType_2981, *itProject_298a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_2978, *itBasicType_2981, *itProject_298a);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateArray2_296a::patternMatcher( const Udm::Object& matrix_2979, const Udm::Object& basicType_2982, const Udm::Object& project_298b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_2979.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_297e= CyberComposition::Simulink::SF_Matrix::Cast( matrix_2979);
		if( false== Uml::IsDerivedFrom( basicType_2982.type(), SFC::BasicType::meta))
			continue;
		SFC::BasicType basicType_2987= SFC::BasicType::Cast( basicType_2982);
		if( false== Uml::IsDerivedFrom( project_298b.type(), SFC::Project::meta))
			continue;
		SFC::Project project_2990= SFC::Project::Cast( project_298b);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2995;
		if( !isValidBound(boundObjs_2995, matrix_297e, true))
			continue;
		currMatch.matrix_2996= matrix_297e;
		if( !isValidBound(boundObjs_2995, basicType_2987, true))
			continue;
		currMatch.basicType_2997= basicType_2987;
		if( !isValidBound(boundObjs_2995, project_2990, true))
			continue;
		currMatch.project_2998= project_2990;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateArray2_296a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Array newArray_2999= SFC::Array::Create( currMatch.project_2998);
		SFC::Array& Array= newArray_2999;
		SFC::BasicType& BasicType= currMatch.basicType_2997;
		CyberComposition::Simulink::SF_Matrix& Matrix= currMatch.matrix_2996;
		SFC::Project& Project= currMatch.project_2998;
		{
__int64 statementCount = Project.statementCount();
Array.statementIndex() = statementCount++;
Project.statementCount() = statementCount;

Array.noelem() = Matrix.columns();
};
		newArray_2999.dt()= currMatch.basicType_2997;
		outputAppender( currMatch.matrix_2996, newArray_2999, currMatch.project_2998);
	}
}

void CreateArray2_296a::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_299a, const SFC::Array& array_299c, const SFC::Project& project_299e)
{
	_matrix_2974->push_back( matrix_299a);
	_array_2975->push_back( array_299c);
	_project_2976->push_back( project_299e);
}

void ProcessScalar_29ac::operator()( const Packets_t& typess_29ad, const Packets_t& projects_29af, Packets_t& typess_29b1, Packets_t& basictypes_29b2, Packets_t& projects_29b3)
{
#ifdef PRINT_INFO
	printLog( "ProcessScalar_29ac" );
#endif
	_types_29b4= &typess_29b1;
	_basictype_29b5= &basictypes_29b2;
	_project_29b6= &projects_29b3;
	if( ( !typess_29ad.empty())&& ( !projects_29af.empty()))
		callGetBasicType_2a7d( typess_29ad, projects_29af);
}

void ProcessScalar_29ac::callGetBasicType_2a7d( const Packets_t& typess_2a12, const Packets_t& projects_2a14)
{
	Packets_t typess_2a16;
	Packets_t projectss_2a17;
	Packets_t typess_2a18;
	Packets_t projectss_2a19;
	GetBasicType_2a11 getBasicType_2a11;
	getBasicType_2a11( typess_2a12, projects_2a14, typess_2a16, projectss_2a17, typess_2a18, projectss_2a19);
	if( ( !typess_2a18.empty())&& ( !projectss_2a19.empty()))
		callCreateBasicType_2a80( typess_2a18, projectss_2a19);
	if( ( !typess_2a16.empty())&& ( !projectss_2a17.empty()))
		callUseBasicType_2a83( typess_2a16, projectss_2a17);
}

void ProcessScalar_29ac::callCreateBasicType_2a80( const Packets_t& matrixs_29b8, const Packets_t& projects_29bc)
{
	Packets_t matrixs_29ba;
	Packets_t basicTypes_29bb;
	Packets_t projects_29be;
	CreateBasicType_29b7 createBasicType_29b7;
	createBasicType_29b7( matrixs_29b8, projects_29bc, matrixs_29ba, basicTypes_29bb, projects_29be);
	_types_29b4->insert( _types_29b4->end(), matrixs_29ba.begin(), matrixs_29ba.end());
	_basictype_29b5->insert( _basictype_29b5->end(), basicTypes_29bb.begin(), basicTypes_29bb.end());
	_project_29b6->insert( _project_29b6->end(), projects_29be.begin(), projects_29be.end());
}

void ProcessScalar_29ac::callUseBasicType_2a83( const Packets_t& matrixs_29e2, const Packets_t& projects_29e6)
{
	Packets_t matrixs_29e4;
	Packets_t basicTypes_29e5;
	Packets_t projects_29e8;
	UseBasicType_29e1 useBasicType_29e1;
	useBasicType_29e1( matrixs_29e2, projects_29e6, matrixs_29e4, basicTypes_29e5, projects_29e8);
	_types_29b4->insert( _types_29b4->end(), matrixs_29e4.begin(), matrixs_29e4.end());
	_basictype_29b5->insert( _basictype_29b5->end(), basicTypes_29e5.begin(), basicTypes_29e5.end());
	_project_29b6->insert( _project_29b6->end(), projects_29e8.begin(), projects_29e8.end());
}

void CreateBasicType_29b7::operator()( const Packets_t& matrixs_29b8, const Packets_t& projects_29bc, Packets_t& matrixs_29ba, Packets_t& basicTypes_29bb, Packets_t& projects_29be)
{
#ifdef PRINT_INFO
	printLog( "CreateBasicType_29b7" );
#endif
	RTTGenerator::Instance()->generateRule(2108, "CreateBasicType");
	_matrix_29bf= &matrixs_29ba;
	_basicType_29c0= &basicTypes_29bb;
	_project_29c1= &projects_29be;
	processInputPackets( matrixs_29b8, projects_29bc);
}

bool CreateBasicType_29b7::isInputUnique( const Udm::Object& matrix_29c6, const Udm::Object& project_29cf)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_29c8= _matrix_29c2.begin(), itProject_29d1= _project_29cb.begin(); itMatrix_29c8!= _matrix_29c2.end(), itProject_29d1!= _project_29cb.end(); ++itMatrix_29c8, ++itProject_29d1)
	{
		if( ( *itMatrix_29c8== matrix_29c6)&& ( *itProject_29d1== project_29cf))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_29c2.push_back( matrix_29c6);
		_project_29cb.push_back( project_29cf);
	}
	return isUnique;
}

bool CreateBasicType_29b7::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateBasicType_29b7::processInputPackets( const Packets_t& matrixs_29b8, const Packets_t& projects_29bc)
{
	for( Packets_t::const_iterator itMatrix_29c3= matrixs_29b8.begin(), itProject_29cc= projects_29bc.begin(); itMatrix_29c3!= matrixs_29b8.end(), itProject_29cc!= projects_29bc.end(); ++itMatrix_29c3, ++itProject_29cc)
	{
		bool isUnique= isInputUnique( *itMatrix_29c3, *itProject_29cc);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_29c3, *itProject_29cc);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateBasicType_29b7::patternMatcher( const Udm::Object& matrix_29c4, const Udm::Object& project_29cd)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_29c4.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_29c9= CyberComposition::Simulink::SF_Matrix::Cast( matrix_29c4);
		if( false== Uml::IsDerivedFrom( project_29cd.type(), SFC::Project::meta))
			continue;
		SFC::Project project_29d2= SFC::Project::Cast( project_29cd);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_29d7;
		if( !isValidBound(boundObjs_29d7, matrix_29c9, true))
			continue;
		currMatch.matrix_29d8= matrix_29c9;
		if( !isValidBound(boundObjs_29d7, project_29d2, true))
			continue;
		currMatch.project_29d9= project_29d2;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateBasicType_29b7::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BasicType newBasicType_29da= SFC::BasicType::Create( currMatch.project_29d9);
		SFC::BasicType& BasicType= newBasicType_29da;
		CyberComposition::Simulink::SF_Matrix& Matrix= currMatch.matrix_29d8;
		SFC::Project& Project= currMatch.project_29d9;
		{
__int64 statementCount = Project.statementCount();
BasicType.statementIndex() = statementCount++;
Project.statementCount() = statementCount;

BasicType.name() = Matrix.Type();

};
		outputAppender( currMatch.matrix_29d8, newBasicType_29da, currMatch.project_29d9);
	}
}

void CreateBasicType_29b7::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_29db, const SFC::BasicType& basicType_29dd, const SFC::Project& project_29df)
{
	_matrix_29bf->push_back( matrix_29db);
	_basicType_29c0->push_back( basicType_29dd);
	_project_29c1->push_back( project_29df);
}

void UseBasicType_29e1::operator()( const Packets_t& matrixs_29e2, const Packets_t& projects_29e6, Packets_t& matrixs_29e4, Packets_t& basicTypes_29e5, Packets_t& projects_29e8)
{
#ifdef PRINT_INFO
	printLog( "UseBasicType_29e1" );
#endif
	RTTGenerator::Instance()->generateRule(2114, "UseBasicType");
	_matrix_29e9= &matrixs_29e4;
	_basicType_29ea= &basicTypes_29e5;
	_project_29eb= &projects_29e8;
	processInputPackets( matrixs_29e2, projects_29e6);
}

bool UseBasicType_29e1::isInputUnique( const Udm::Object& matrix_29f0, const Udm::Object& project_29f9)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_29f2= _matrix_29ec.begin(), itProject_29fb= _project_29f5.begin(); itMatrix_29f2!= _matrix_29ec.end(), itProject_29fb!= _project_29f5.end(); ++itMatrix_29f2, ++itProject_29fb)
	{
		if( ( *itMatrix_29f2== matrix_29f0)&& ( *itProject_29fb== project_29f9))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_29ec.push_back( matrix_29f0);
		_project_29f5.push_back( project_29f9);
	}
	return isUnique;
}

bool UseBasicType_29e1::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool UseBasicType_29e1::isGuardTrue( SFC::BasicType& BasicType, CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( Matrix.Type() ) ==
 static_cast< std::string >( BasicType.name() );;
	return Gz_guard;
}

void UseBasicType_29e1::processInputPackets( const Packets_t& matrixs_29e2, const Packets_t& projects_29e6)
{
	for( Packets_t::const_iterator itMatrix_29ed= matrixs_29e2.begin(), itProject_29f6= projects_29e6.begin(); itMatrix_29ed!= matrixs_29e2.end(), itProject_29f6!= projects_29e6.end(); ++itMatrix_29ed, ++itProject_29f6)
	{
		bool isUnique= isInputUnique( *itMatrix_29ed, *itProject_29f6);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_29ed, *itProject_29f6);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool UseBasicType_29e1::patternMatcher( const Udm::Object& matrix_29ee, const Udm::Object& project_29f7)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_29ee.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_29f3= CyberComposition::Simulink::SF_Matrix::Cast( matrix_29ee);
		if( false== Uml::IsDerivedFrom( project_29f7.type(), SFC::Project::meta))
			continue;
		SFC::Project project_29fc= SFC::Project::Cast( project_29f7);
		set< SFC::BasicType> basicTypes_29fe= project_29fc.BasicType_kind_children();
		for( set< SFC::BasicType>::const_iterator itBasicType_29ff= basicTypes_29fe.begin(); itBasicType_29ff!= basicTypes_29fe.end(); ++itBasicType_29ff)
		{
			SFC::BasicType currBasicType_2a00= *itBasicType_29ff;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2a04;
			if( !isValidBound(boundObjs_2a04, matrix_29f3, true))
				continue;
			currMatch.matrix_2a05= matrix_29f3;
			if( !isValidBound(boundObjs_2a04, project_29fc, true))
				continue;
			currMatch.project_2a06= project_29fc;
			if( !isValidBound(boundObjs_2a04, currBasicType_2a00, false))
				continue;
			currMatch.basicType_2a07= currBasicType_2a00;
			bool Gz_guard= isGuardTrue( currMatch.basicType_2a07, currMatch.matrix_2a05, currMatch.project_2a06);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void UseBasicType_29e1::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_2a05, currMatch.basicType_2a07, currMatch.project_2a06);
	}
}

void UseBasicType_29e1::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_2a0b, const SFC::BasicType& basicType_2a0d, const SFC::Project& project_2a0f)
{
	_matrix_29e9->push_back( matrix_2a0b);
	_basicType_29ea->push_back( basicType_2a0d);
	_project_29eb->push_back( project_2a0f);
}

void GetBasicType_2a11::operator()( const Packets_t& typess_2a12, const Packets_t& projects_2a14, Packets_t& typess_2a16, Packets_t& projectss_2a17, Packets_t& typess_2a18, Packets_t& projectss_2a19)
{
#ifdef PRINT_INFO
	printLog( "GetBasicType_2a11" );
#endif
	_types_2a1a= &typess_2a16;
	_projects_2a1b= &projectss_2a17;
	_types_2a1c= &typess_2a18;
	_projects_2a1d= &projectss_2a19;
	for( Packets_t::const_iterator ittypes_2a1f= typess_2a12.begin(), itproject_2a26= projects_2a14.begin(); ittypes_2a1f!= typess_2a12.end(), itproject_2a26!= projects_2a14.end(); ++ittypes_2a1f, ++itproject_2a26)
	{
		bool isUnique= isInputUnique( *ittypes_2a1f, *itproject_2a26);
		if( !isUnique)
			continue;
		Packets_t onetypes_2a23( 1, *ittypes_2a1f);
		Packets_t oneproject_2a2a( 1, *itproject_2a26);
		executeOne( onetypes_2a23, oneproject_2a2a);
	}
}

void GetBasicType_2a11::executeOne( const Packets_t& typess_2a12, const Packets_t& projects_2a14)
{
	Packets_t matrixs_2a2f;
	Packets_t projects_2a32;
	BasicTypeExists_2a2c basicTypeExists_2a2c;
	bool isMatchBasicTypeExists_2a2c= basicTypeExists_2a2c( typess_2a12, projects_2a14, matrixs_2a2f, projects_2a32);
	_types_2a1a->insert( _types_2a1a->end(), matrixs_2a2f.begin(), matrixs_2a2f.end());
	_projects_2a1b->insert( _projects_2a1b->end(), projects_2a32.begin(), projects_2a32.end());
	if( isMatchBasicTypeExists_2a2c)
		return;
	Packets_t matrixs_2a5b;
	Packets_t projects_2a5e;
	Otherwise_2a58 otherwise_2a58;
	bool isMatchOtherwise_2a58= otherwise_2a58( typess_2a12, projects_2a14, matrixs_2a5b, projects_2a5e);
	_types_2a1c->insert( _types_2a1c->end(), matrixs_2a5b.begin(), matrixs_2a5b.end());
	_projects_2a1d->insert( _projects_2a1d->end(), projects_2a5e.begin(), projects_2a5e.end());
}

bool GetBasicType_2a11::isInputUnique( const Udm::Object& types_2a20, const Udm::Object& project_2a27)
{
	bool isUnique= true;
	for( Packets_t::const_iterator ittypes_2a22= _types_2a1e.begin(), itproject_2a29= _project_2a25.begin(); ittypes_2a22!= _types_2a1e.end(), itproject_2a29!= _project_2a25.end(); ++ittypes_2a22, ++itproject_2a29)
	{
		if( ( *ittypes_2a22== types_2a20)&& ( *itproject_2a29== project_2a27))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_types_2a1e.push_back( types_2a20);
		_project_2a25.push_back( project_2a27);
	}
	return isUnique;
}

bool BasicTypeExists_2a2c::operator()( const Packets_t& matrixs_2a2d, const Packets_t& projects_2a30, Packets_t& matrixs_2a2f, Packets_t& projects_2a32)
{
#ifdef PRINT_INFO
	printLog( "BasicTypeExists_2a2c" );
#endif
	_matrix_2a33= &matrixs_2a2f;
	_project_2a34= &projects_2a32;
	processInputPackets( matrixs_2a2d, projects_2a30);
	if( false== _matches.empty())
		return true;
	return false;
}

bool BasicTypeExists_2a2c::isInputUnique( const Udm::Object& matrix_2a39, const Udm::Object& project_2a42)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_2a3b= _matrix_2a35.begin(), itProject_2a44= _project_2a3e.begin(); itMatrix_2a3b!= _matrix_2a35.end(), itProject_2a44!= _project_2a3e.end(); ++itMatrix_2a3b, ++itProject_2a44)
	{
		if( ( *itMatrix_2a3b== matrix_2a39)&& ( *itProject_2a44== project_2a42))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_2a35.push_back( matrix_2a39);
		_project_2a3e.push_back( project_2a42);
	}
	return isUnique;
}

bool BasicTypeExists_2a2c::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool BasicTypeExists_2a2c::isGuardTrue( SFC::BasicType& BasicType, CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( Matrix.Type() ) ==
 static_cast< std::string >( BasicType.name() );;
	return Gz_guard;
}

void BasicTypeExists_2a2c::processInputPackets( const Packets_t& matrixs_2a2d, const Packets_t& projects_2a30)
{
	for( Packets_t::const_iterator itMatrix_2a36= matrixs_2a2d.begin(), itProject_2a3f= projects_2a30.begin(); itMatrix_2a36!= matrixs_2a2d.end(), itProject_2a3f!= projects_2a30.end(); ++itMatrix_2a36, ++itProject_2a3f)
	{
		bool isUnique= isInputUnique( *itMatrix_2a36, *itProject_2a3f);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_2a36, *itProject_2a3f);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_2a4e, currMatch.project_2a4f);
	}
}

bool BasicTypeExists_2a2c::patternMatcher( const Udm::Object& matrix_2a37, const Udm::Object& project_2a40)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_2a37.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_2a3c= CyberComposition::Simulink::SF_Matrix::Cast( matrix_2a37);
		if( false== Uml::IsDerivedFrom( project_2a40.type(), SFC::Project::meta))
			continue;
		SFC::Project project_2a45= SFC::Project::Cast( project_2a40);
		set< SFC::BasicType> basicTypes_2a47= project_2a45.BasicType_kind_children();
		for( set< SFC::BasicType>::const_iterator itBasicType_2a48= basicTypes_2a47.begin(); itBasicType_2a48!= basicTypes_2a47.end(); ++itBasicType_2a48)
		{
			SFC::BasicType currBasicType_2a49= *itBasicType_2a48;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2a4d;
			if( !isValidBound(boundObjs_2a4d, matrix_2a3c, true))
				continue;
			currMatch.matrix_2a4e= matrix_2a3c;
			if( !isValidBound(boundObjs_2a4d, project_2a45, true))
				continue;
			currMatch.project_2a4f= project_2a45;
			if( !isValidBound(boundObjs_2a4d, currBasicType_2a49, false))
				continue;
			currMatch.basicType_2a50= currBasicType_2a49;
			bool Gz_guard= isGuardTrue( currMatch.basicType_2a50, currMatch.matrix_2a4e, currMatch.project_2a4f);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void BasicTypeExists_2a2c::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_2a54, const SFC::Project& project_2a56)
{
	_matrix_2a33->push_back( matrix_2a54);
	_project_2a34->push_back( project_2a56);
}

bool Otherwise_2a58::operator()( const Packets_t& matrixs_2a59, const Packets_t& projects_2a5c, Packets_t& matrixs_2a5b, Packets_t& projects_2a5e)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_2a58" );
#endif
	_matrix_2a5f= &matrixs_2a5b;
	_project_2a60= &projects_2a5e;
	processInputPackets( matrixs_2a59, projects_2a5c);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_2a58::isInputUnique( const Udm::Object& matrix_2a65, const Udm::Object& project_2a6e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_2a67= _matrix_2a61.begin(), itProject_2a70= _project_2a6a.begin(); itMatrix_2a67!= _matrix_2a61.end(), itProject_2a70!= _project_2a6a.end(); ++itMatrix_2a67, ++itProject_2a70)
	{
		if( ( *itMatrix_2a67== matrix_2a65)&& ( *itProject_2a70== project_2a6e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_2a61.push_back( matrix_2a65);
		_project_2a6a.push_back( project_2a6e);
	}
	return isUnique;
}

bool Otherwise_2a58::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_2a58::processInputPackets( const Packets_t& matrixs_2a59, const Packets_t& projects_2a5c)
{
	for( Packets_t::const_iterator itMatrix_2a62= matrixs_2a59.begin(), itProject_2a6b= projects_2a5c.begin(); itMatrix_2a62!= matrixs_2a59.end(), itProject_2a6b!= projects_2a5c.end(); ++itMatrix_2a62, ++itProject_2a6b)
	{
		bool isUnique= isInputUnique( *itMatrix_2a62, *itProject_2a6b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_2a62, *itProject_2a6b);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_2a77, currMatch.project_2a78);
	}
}

bool Otherwise_2a58::patternMatcher( const Udm::Object& matrix_2a63, const Udm::Object& project_2a6c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_2a63.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_2a68= CyberComposition::Simulink::SF_Matrix::Cast( matrix_2a63);
		if( false== Uml::IsDerivedFrom( project_2a6c.type(), SFC::Project::meta))
			continue;
		SFC::Project project_2a71= SFC::Project::Cast( project_2a6c);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2a76;
		if( !isValidBound(boundObjs_2a76, matrix_2a68, true))
			continue;
		currMatch.matrix_2a77= matrix_2a68;
		if( !isValidBound(boundObjs_2a76, project_2a71, true))
			continue;
		currMatch.project_2a78= project_2a71;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_2a58::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_2a79, const SFC::Project& project_2a7b)
{
	_matrix_2a5f->push_back( matrix_2a79);
	_project_2a60->push_back( project_2a7b);
}

void ProcessArray1_2a8d::operator()( const Packets_t& typess_2a8e, const Packets_t& basictypes_2a90, const Packets_t& projects_2a92, Packets_t& typess_2a94, Packets_t& array1s_2a95, Packets_t& projects_2a96)
{
#ifdef PRINT_INFO
	printLog( "ProcessArray1_2a8d" );
#endif
	_types_2a97= &typess_2a94;
	_array1_2a98= &array1s_2a95;
	_project_2a99= &projects_2a96;
	if( ( !typess_2a8e.empty())&& ( !basictypes_2a90.empty())&& ( !projects_2a92.empty()))
		callGetArray1_2ba9( typess_2a8e, basictypes_2a90, projects_2a92);
}

void ProcessArray1_2a8d::callGetArray1_2ba9( const Packets_t& typess_2b0f, const Packets_t& dts_2b11, const Packets_t& projects_2b13)
{
	Packets_t typess_2b15;
	Packets_t dts_2b16;
	Packets_t projectss_2b17;
	Packets_t typess_2b18;
	Packets_t dts_2b19;
	Packets_t projectss_2b1a;
	GetArray1_2b0e getArray1_2b0e;
	getArray1_2b0e( typess_2b0f, dts_2b11, projects_2b13, typess_2b15, dts_2b16, projectss_2b17, typess_2b18, dts_2b19, projectss_2b1a);
	if( ( !typess_2b18.empty())&& ( !dts_2b19.empty())&& ( !projectss_2b1a.empty()))
		callCreateArray1_2bad( typess_2b18, dts_2b19, projectss_2b1a);
	if( ( !typess_2b15.empty())&& ( !dts_2b16.empty())&& ( !projectss_2b17.empty()))
		callUseArray1_2bb1( typess_2b15, dts_2b16, projectss_2b17);
}

void ProcessArray1_2a8d::callCreateArray1_2bad( const Packets_t& matrixs_2a9b, const Packets_t& dTs_2a9f, const Packets_t& projects_2aa1)
{
	Packets_t matrixs_2a9d;
	Packets_t arrays_2a9e;
	Packets_t projects_2aa3;
	CreateArray1_2a9a createArray1_2a9a;
	createArray1_2a9a( matrixs_2a9b, dTs_2a9f, projects_2aa1, matrixs_2a9d, arrays_2a9e, projects_2aa3);
	_types_2a97->insert( _types_2a97->end(), matrixs_2a9d.begin(), matrixs_2a9d.end());
	_array1_2a98->insert( _array1_2a98->end(), arrays_2a9e.begin(), arrays_2a9e.end());
	_project_2a99->insert( _project_2a99->end(), projects_2aa3.begin(), projects_2aa3.end());
}

void ProcessArray1_2a8d::callUseArray1_2bb1( const Packets_t& matrixs_2ad1, const Packets_t& dTs_2ad5, const Packets_t& projects_2ad7)
{
	Packets_t matrixs_2ad3;
	Packets_t arrays_2ad4;
	Packets_t projects_2ad9;
	UseArray1_2ad0 useArray1_2ad0;
	useArray1_2ad0( matrixs_2ad1, dTs_2ad5, projects_2ad7, matrixs_2ad3, arrays_2ad4, projects_2ad9);
	_types_2a97->insert( _types_2a97->end(), matrixs_2ad3.begin(), matrixs_2ad3.end());
	_array1_2a98->insert( _array1_2a98->end(), arrays_2ad4.begin(), arrays_2ad4.end());
	_project_2a99->insert( _project_2a99->end(), projects_2ad9.begin(), projects_2ad9.end());
}

void CreateArray1_2a9a::operator()( const Packets_t& matrixs_2a9b, const Packets_t& dTs_2a9f, const Packets_t& projects_2aa1, Packets_t& matrixs_2a9d, Packets_t& arrays_2a9e, Packets_t& projects_2aa3)
{
#ifdef PRINT_INFO
	printLog( "CreateArray1_2a9a" );
#endif
	RTTGenerator::Instance()->generateRule(2066, "CreateArray1");
	_matrix_2aa4= &matrixs_2a9d;
	_array_2aa5= &arrays_2a9e;
	_project_2aa6= &projects_2aa3;
	processInputPackets( matrixs_2a9b, dTs_2a9f, projects_2aa1);
}

bool CreateArray1_2a9a::isInputUnique( const Udm::Object& matrix_2aab, const Udm::Object& dT_2ab4, const Udm::Object& project_2abd)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_2aad= _matrix_2aa7.begin(), itDT_2ab6= _dT_2ab0.begin(), itProject_2abf= _project_2ab9.begin(); itMatrix_2aad!= _matrix_2aa7.end(), itDT_2ab6!= _dT_2ab0.end(), itProject_2abf!= _project_2ab9.end(); ++itMatrix_2aad, ++itDT_2ab6, ++itProject_2abf)
	{
		if( ( *itMatrix_2aad== matrix_2aab)&& ( *itDT_2ab6== dT_2ab4)&& ( *itProject_2abf== project_2abd))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_2aa7.push_back( matrix_2aab);
		_dT_2ab0.push_back( dT_2ab4);
		_project_2ab9.push_back( project_2abd);
	}
	return isUnique;
}

bool CreateArray1_2a9a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateArray1_2a9a::processInputPackets( const Packets_t& matrixs_2a9b, const Packets_t& dTs_2a9f, const Packets_t& projects_2aa1)
{
	for( Packets_t::const_iterator itMatrix_2aa8= matrixs_2a9b.begin(), itDT_2ab1= dTs_2a9f.begin(), itProject_2aba= projects_2aa1.begin(); itMatrix_2aa8!= matrixs_2a9b.end(), itDT_2ab1!= dTs_2a9f.end(), itProject_2aba!= projects_2aa1.end(); ++itMatrix_2aa8, ++itDT_2ab1, ++itProject_2aba)
	{
		bool isUnique= isInputUnique( *itMatrix_2aa8, *itDT_2ab1, *itProject_2aba);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_2aa8, *itDT_2ab1, *itProject_2aba);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateArray1_2a9a::patternMatcher( const Udm::Object& matrix_2aa9, const Udm::Object& dT_2ab2, const Udm::Object& project_2abb)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_2aa9.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_2aae= CyberComposition::Simulink::SF_Matrix::Cast( matrix_2aa9);
		if( false== Uml::IsDerivedFrom( dT_2ab2.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_2ab7= SFC::DT::Cast( dT_2ab2);
		if( false== Uml::IsDerivedFrom( project_2abb.type(), SFC::Project::meta))
			continue;
		SFC::Project project_2ac0= SFC::Project::Cast( project_2abb);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2ac5;
		if( !isValidBound(boundObjs_2ac5, matrix_2aae, true))
			continue;
		currMatch.matrix_2ac6= matrix_2aae;
		if( !isValidBound(boundObjs_2ac5, dT_2ab7, true))
			continue;
		currMatch.dT_2ac7= dT_2ab7;
		if( !isValidBound(boundObjs_2ac5, project_2ac0, true))
			continue;
		currMatch.project_2ac8= project_2ac0;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateArray1_2a9a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Array newArray_2ac9= SFC::Array::Create( currMatch.project_2ac8);
		SFC::Array& Array= newArray_2ac9;
		SFC::DT& DT= currMatch.dT_2ac7;
		CyberComposition::Simulink::SF_Matrix& Matrix= currMatch.matrix_2ac6;
		SFC::Project& Project= currMatch.project_2ac8;
		{
__int64 statementCount = Project.statementCount();
Array.statementIndex() = statementCount++;
Project.statementCount() = statementCount;

Array.noelem() = Matrix.rows();

};
		newArray_2ac9.dt()= currMatch.dT_2ac7;
		outputAppender( currMatch.matrix_2ac6, newArray_2ac9, currMatch.project_2ac8);
	}
}

void CreateArray1_2a9a::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_2aca, const SFC::Array& array_2acc, const SFC::Project& project_2ace)
{
	_matrix_2aa4->push_back( matrix_2aca);
	_array_2aa5->push_back( array_2acc);
	_project_2aa6->push_back( project_2ace);
}

void UseArray1_2ad0::operator()( const Packets_t& matrixs_2ad1, const Packets_t& dTs_2ad5, const Packets_t& projects_2ad7, Packets_t& matrixs_2ad3, Packets_t& arrays_2ad4, Packets_t& projects_2ad9)
{
#ifdef PRINT_INFO
	printLog( "UseArray1_2ad0" );
#endif
	RTTGenerator::Instance()->generateRule(2074, "UseArray1");
	_matrix_2ada= &matrixs_2ad3;
	_array_2adb= &arrays_2ad4;
	_project_2adc= &projects_2ad9;
	processInputPackets( matrixs_2ad1, dTs_2ad5, projects_2ad7);
}

bool UseArray1_2ad0::isInputUnique( const Udm::Object& matrix_2ae1, const Udm::Object& dT_2aea, const Udm::Object& project_2af3)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_2ae3= _matrix_2add.begin(), itDT_2aec= _dT_2ae6.begin(), itProject_2af5= _project_2aef.begin(); itMatrix_2ae3!= _matrix_2add.end(), itDT_2aec!= _dT_2ae6.end(), itProject_2af5!= _project_2aef.end(); ++itMatrix_2ae3, ++itDT_2aec, ++itProject_2af5)
	{
		if( ( *itMatrix_2ae3== matrix_2ae1)&& ( *itDT_2aec== dT_2aea)&& ( *itProject_2af5== project_2af3))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_2add.push_back( matrix_2ae1);
		_dT_2ae6.push_back( dT_2aea);
		_project_2aef.push_back( project_2af3);
	}
	return isUnique;
}

bool UseArray1_2ad0::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool UseArray1_2ad0::isGuardTrue( SFC::Array& Array, SFC::DT& DT, CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard = Matrix.rows() == Array.noelem();;
	return Gz_guard;
}

void UseArray1_2ad0::processInputPackets( const Packets_t& matrixs_2ad1, const Packets_t& dTs_2ad5, const Packets_t& projects_2ad7)
{
	for( Packets_t::const_iterator itMatrix_2ade= matrixs_2ad1.begin(), itDT_2ae7= dTs_2ad5.begin(), itProject_2af0= projects_2ad7.begin(); itMatrix_2ade!= matrixs_2ad1.end(), itDT_2ae7!= dTs_2ad5.end(), itProject_2af0!= projects_2ad7.end(); ++itMatrix_2ade, ++itDT_2ae7, ++itProject_2af0)
	{
		bool isUnique= isInputUnique( *itMatrix_2ade, *itDT_2ae7, *itProject_2af0);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_2ade, *itDT_2ae7, *itProject_2af0);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool UseArray1_2ad0::patternMatcher( const Udm::Object& matrix_2adf, const Udm::Object& dT_2ae8, const Udm::Object& project_2af1)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_2adf.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_2ae4= CyberComposition::Simulink::SF_Matrix::Cast( matrix_2adf);
		if( false== Uml::IsDerivedFrom( dT_2ae8.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_2aed= SFC::DT::Cast( dT_2ae8);
		if( false== Uml::IsDerivedFrom( project_2af1.type(), SFC::Project::meta))
			continue;
		SFC::Project project_2af6= SFC::Project::Cast( project_2af1);
		set< SFC::Array> arrays_2af8= project_2af6.Array_kind_children();
		for( set< SFC::Array>::const_iterator itArray_2af9= arrays_2af8.begin(); itArray_2af9!= arrays_2af8.end(); ++itArray_2af9)
		{
			SFC::Array currArray_2afa= *itArray_2af9;
			SFC::DT dT_2afb= currArray_2afa.dt();
			if( !dT_2afb)
				continue;
			if( dT_2aed!= dT_2afb)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2aff;
			if( !isValidBound(boundObjs_2aff, matrix_2ae4, true))
				continue;
			currMatch.matrix_2b00= matrix_2ae4;
			if( !isValidBound(boundObjs_2aff, dT_2aed, true))
				continue;
			currMatch.dT_2b01= dT_2aed;
			if( !isValidBound(boundObjs_2aff, project_2af6, true))
				continue;
			currMatch.project_2b02= project_2af6;
			if( !isValidBound(boundObjs_2aff, currArray_2afa, false))
				continue;
			currMatch.array_2b03= currArray_2afa;
			bool Gz_guard= isGuardTrue( currMatch.array_2b03, currMatch.dT_2b01, currMatch.matrix_2b00, currMatch.project_2b02);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void UseArray1_2ad0::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_2b00, currMatch.array_2b03, currMatch.project_2b02);
	}
}

void UseArray1_2ad0::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_2b08, const SFC::Array& array_2b0a, const SFC::Project& project_2b0c)
{
	_matrix_2ada->push_back( matrix_2b08);
	_array_2adb->push_back( array_2b0a);
	_project_2adc->push_back( project_2b0c);
}

void GetArray1_2b0e::operator()( const Packets_t& typess_2b0f, const Packets_t& dts_2b11, const Packets_t& projects_2b13, Packets_t& typess_2b15, Packets_t& dts_2b16, Packets_t& projectss_2b17, Packets_t& typess_2b18, Packets_t& dts_2b19, Packets_t& projectss_2b1a)
{
#ifdef PRINT_INFO
	printLog( "GetArray1_2b0e" );
#endif
	_types_2b1b= &typess_2b15;
	_dt_2b1c= &dts_2b16;
	_projects_2b1d= &projectss_2b17;
	_types_2b1e= &typess_2b18;
	_dt_2b1f= &dts_2b19;
	_projects_2b20= &projectss_2b1a;
	for( Packets_t::const_iterator ittypes_2b22= typess_2b0f.begin(), itdt_2b29= dts_2b11.begin(), itproject_2b30= projects_2b13.begin(); ittypes_2b22!= typess_2b0f.end(), itdt_2b29!= dts_2b11.end(), itproject_2b30!= projects_2b13.end(); ++ittypes_2b22, ++itdt_2b29, ++itproject_2b30)
	{
		bool isUnique= isInputUnique( *ittypes_2b22, *itdt_2b29, *itproject_2b30);
		if( !isUnique)
			continue;
		Packets_t onetypes_2b26( 1, *ittypes_2b22);
		Packets_t onedt_2b2d( 1, *itdt_2b29);
		Packets_t oneproject_2b34( 1, *itproject_2b30);
		executeOne( onetypes_2b26, onedt_2b2d, oneproject_2b34);
	}
}

void GetArray1_2b0e::executeOne( const Packets_t& typess_2b0f, const Packets_t& dts_2b11, const Packets_t& projects_2b13)
{
	Packets_t matrixs_2b39;
	Packets_t dTs_2b3c;
	Packets_t projects_2b3f;
	Array1Exists_2b36 array1Exists_2b36;
	bool isMatchArray1Exists_2b36= array1Exists_2b36( typess_2b0f, dts_2b11, projects_2b13, matrixs_2b39, dTs_2b3c, projects_2b3f);
	_types_2b1b->insert( _types_2b1b->end(), matrixs_2b39.begin(), matrixs_2b39.end());
	_dt_2b1c->insert( _dt_2b1c->end(), dTs_2b3c.begin(), dTs_2b3c.end());
	_projects_2b1d->insert( _projects_2b1d->end(), projects_2b3f.begin(), projects_2b3f.end());
	if( isMatchArray1Exists_2b36)
		return;
	Packets_t matrixs_2b77;
	Packets_t dTs_2b7a;
	Packets_t projects_2b7d;
	Otherwise_2b74 otherwise_2b74;
	bool isMatchOtherwise_2b74= otherwise_2b74( typess_2b0f, dts_2b11, projects_2b13, matrixs_2b77, dTs_2b7a, projects_2b7d);
	_types_2b1e->insert( _types_2b1e->end(), matrixs_2b77.begin(), matrixs_2b77.end());
	_dt_2b1f->insert( _dt_2b1f->end(), dTs_2b7a.begin(), dTs_2b7a.end());
	_projects_2b20->insert( _projects_2b20->end(), projects_2b7d.begin(), projects_2b7d.end());
	if( isMatchOtherwise_2b74)
		return;
}

bool GetArray1_2b0e::isInputUnique( const Udm::Object& types_2b23, const Udm::Object& dt_2b2a, const Udm::Object& project_2b31)
{
	bool isUnique= true;
	for( Packets_t::const_iterator ittypes_2b25= _types_2b21.begin(), itdt_2b2c= _dt_2b28.begin(), itproject_2b33= _project_2b2f.begin(); ittypes_2b25!= _types_2b21.end(), itdt_2b2c!= _dt_2b28.end(), itproject_2b33!= _project_2b2f.end(); ++ittypes_2b25, ++itdt_2b2c, ++itproject_2b33)
	{
		if( ( *ittypes_2b25== types_2b23)&& ( *itdt_2b2c== dt_2b2a)&& ( *itproject_2b33== project_2b31))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_types_2b21.push_back( types_2b23);
		_dt_2b28.push_back( dt_2b2a);
		_project_2b2f.push_back( project_2b31);
	}
	return isUnique;
}

bool Array1Exists_2b36::operator()( const Packets_t& matrixs_2b37, const Packets_t& dTs_2b3a, const Packets_t& projects_2b3d, Packets_t& matrixs_2b39, Packets_t& dTs_2b3c, Packets_t& projects_2b3f)
{
#ifdef PRINT_INFO
	printLog( "Array1Exists_2b36" );
#endif
	_matrix_2b40= &matrixs_2b39;
	_dT_2b41= &dTs_2b3c;
	_project_2b42= &projects_2b3f;
	processInputPackets( matrixs_2b37, dTs_2b3a, projects_2b3d);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Array1Exists_2b36::isInputUnique( const Udm::Object& matrix_2b47, const Udm::Object& dT_2b50, const Udm::Object& project_2b59)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_2b49= _matrix_2b43.begin(), itDT_2b52= _dT_2b4c.begin(), itProject_2b5b= _project_2b55.begin(); itMatrix_2b49!= _matrix_2b43.end(), itDT_2b52!= _dT_2b4c.end(), itProject_2b5b!= _project_2b55.end(); ++itMatrix_2b49, ++itDT_2b52, ++itProject_2b5b)
	{
		if( ( *itMatrix_2b49== matrix_2b47)&& ( *itDT_2b52== dT_2b50)&& ( *itProject_2b5b== project_2b59))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_2b43.push_back( matrix_2b47);
		_dT_2b4c.push_back( dT_2b50);
		_project_2b55.push_back( project_2b59);
	}
	return isUnique;
}

bool Array1Exists_2b36::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool Array1Exists_2b36::isGuardTrue( SFC::Array& Array, SFC::DT& DT, CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard = Matrix.rows() == Array.noelem();;
	return Gz_guard;
}

void Array1Exists_2b36::processInputPackets( const Packets_t& matrixs_2b37, const Packets_t& dTs_2b3a, const Packets_t& projects_2b3d)
{
	for( Packets_t::const_iterator itMatrix_2b44= matrixs_2b37.begin(), itDT_2b4d= dTs_2b3a.begin(), itProject_2b56= projects_2b3d.begin(); itMatrix_2b44!= matrixs_2b37.end(), itDT_2b4d!= dTs_2b3a.end(), itProject_2b56!= projects_2b3d.end(); ++itMatrix_2b44, ++itDT_2b4d, ++itProject_2b56)
	{
		bool isUnique= isInputUnique( *itMatrix_2b44, *itDT_2b4d, *itProject_2b56);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_2b44, *itDT_2b4d, *itProject_2b56);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_2b66, currMatch.dT_2b67, currMatch.project_2b68);
	}
}

bool Array1Exists_2b36::patternMatcher( const Udm::Object& matrix_2b45, const Udm::Object& dT_2b4e, const Udm::Object& project_2b57)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_2b45.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_2b4a= CyberComposition::Simulink::SF_Matrix::Cast( matrix_2b45);
		if( false== Uml::IsDerivedFrom( dT_2b4e.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_2b53= SFC::DT::Cast( dT_2b4e);
		if( false== Uml::IsDerivedFrom( project_2b57.type(), SFC::Project::meta))
			continue;
		SFC::Project project_2b5c= SFC::Project::Cast( project_2b57);
		set< SFC::Array> arrays_2b5e= project_2b5c.Array_kind_children();
		for( set< SFC::Array>::const_iterator itArray_2b5f= arrays_2b5e.begin(); itArray_2b5f!= arrays_2b5e.end(); ++itArray_2b5f)
		{
			SFC::Array currArray_2b60= *itArray_2b5f;
			SFC::DT dT_2b61= currArray_2b60.dt();
			if( !dT_2b61)
				continue;
			if( dT_2b53!= dT_2b61)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2b65;
			if( !isValidBound(boundObjs_2b65, matrix_2b4a, true))
				continue;
			currMatch.matrix_2b66= matrix_2b4a;
			if( !isValidBound(boundObjs_2b65, dT_2b53, true))
				continue;
			currMatch.dT_2b67= dT_2b53;
			if( !isValidBound(boundObjs_2b65, project_2b5c, true))
				continue;
			currMatch.project_2b68= project_2b5c;
			if( !isValidBound(boundObjs_2b65, currArray_2b60, false))
				continue;
			currMatch.array_2b69= currArray_2b60;
			bool Gz_guard= isGuardTrue( currMatch.array_2b69, currMatch.dT_2b67, currMatch.matrix_2b66, currMatch.project_2b68);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void Array1Exists_2b36::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_2b6e, const SFC::DT& dT_2b70, const SFC::Project& project_2b72)
{
	_matrix_2b40->push_back( matrix_2b6e);
	_dT_2b41->push_back( dT_2b70);
	_project_2b42->push_back( project_2b72);
}

bool Otherwise_2b74::operator()( const Packets_t& matrixs_2b75, const Packets_t& dTs_2b78, const Packets_t& projects_2b7b, Packets_t& matrixs_2b77, Packets_t& dTs_2b7a, Packets_t& projects_2b7d)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_2b74" );
#endif
	_matrix_2b7e= &matrixs_2b77;
	_dT_2b7f= &dTs_2b7a;
	_project_2b80= &projects_2b7d;
	processInputPackets( matrixs_2b75, dTs_2b78, projects_2b7b);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_2b74::isInputUnique( const Udm::Object& matrix_2b85, const Udm::Object& dT_2b8e, const Udm::Object& project_2b97)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_2b87= _matrix_2b81.begin(), itDT_2b90= _dT_2b8a.begin(), itProject_2b99= _project_2b93.begin(); itMatrix_2b87!= _matrix_2b81.end(), itDT_2b90!= _dT_2b8a.end(), itProject_2b99!= _project_2b93.end(); ++itMatrix_2b87, ++itDT_2b90, ++itProject_2b99)
	{
		if( ( *itMatrix_2b87== matrix_2b85)&& ( *itDT_2b90== dT_2b8e)&& ( *itProject_2b99== project_2b97))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_2b81.push_back( matrix_2b85);
		_dT_2b8a.push_back( dT_2b8e);
		_project_2b93.push_back( project_2b97);
	}
	return isUnique;
}

bool Otherwise_2b74::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_2b74::processInputPackets( const Packets_t& matrixs_2b75, const Packets_t& dTs_2b78, const Packets_t& projects_2b7b)
{
	for( Packets_t::const_iterator itMatrix_2b82= matrixs_2b75.begin(), itDT_2b8b= dTs_2b78.begin(), itProject_2b94= projects_2b7b.begin(); itMatrix_2b82!= matrixs_2b75.end(), itDT_2b8b!= dTs_2b78.end(), itProject_2b94!= projects_2b7b.end(); ++itMatrix_2b82, ++itDT_2b8b, ++itProject_2b94)
	{
		bool isUnique= isInputUnique( *itMatrix_2b82, *itDT_2b8b, *itProject_2b94);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_2b82, *itDT_2b8b, *itProject_2b94);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_2ba0, currMatch.dT_2ba1, currMatch.project_2ba2);
	}
}

bool Otherwise_2b74::patternMatcher( const Udm::Object& matrix_2b83, const Udm::Object& dT_2b8c, const Udm::Object& project_2b95)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_2b83.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_2b88= CyberComposition::Simulink::SF_Matrix::Cast( matrix_2b83);
		if( false== Uml::IsDerivedFrom( dT_2b8c.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_2b91= SFC::DT::Cast( dT_2b8c);
		if( false== Uml::IsDerivedFrom( project_2b95.type(), SFC::Project::meta))
			continue;
		SFC::Project project_2b9a= SFC::Project::Cast( project_2b95);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2b9f;
		if( !isValidBound(boundObjs_2b9f, matrix_2b88, true))
			continue;
		currMatch.matrix_2ba0= matrix_2b88;
		if( !isValidBound(boundObjs_2b9f, dT_2b91, true))
			continue;
		currMatch.dT_2ba1= dT_2b91;
		if( !isValidBound(boundObjs_2b9f, project_2b9a, true))
			continue;
		currMatch.project_2ba2= project_2b9a;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_2b74::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_2ba3, const SFC::DT& dT_2ba5, const SFC::Project& project_2ba7)
{
	_matrix_2b7e->push_back( matrix_2ba3);
	_dT_2b7f->push_back( dT_2ba5);
	_project_2b80->push_back( project_2ba7);
}

void ProcessColumn_2bbc::operator()( const Packets_t& typess_2bbd, const Packets_t& projects_2bbf, Packets_t& typess_2bc1, Packets_t& array1s_2bc2, Packets_t& projects_2bc3)
{
#ifdef PRINT_INFO
	printLog( "ProcessColumn_2bbc" );
#endif
	_types_2bc4= &typess_2bc1;
	_array1_2bc5= &array1s_2bc2;
	_project_2bc6= &projects_2bc3;
	if( ( !typess_2bbd.empty())&& ( !projects_2bbf.empty()))
		callProcessScalar_2bc7( typess_2bbd, projects_2bbf);
}

void ProcessColumn_2bbc::callProcessScalar_2bc7( const Packets_t& typess_29ad, const Packets_t& projects_29af)
{
	Packets_t typess_29b1;
	Packets_t basictypes_29b2;
	Packets_t projects_29b3;
	ProcessScalar_29ac processScalar_29ac;
	processScalar_29ac( typess_29ad, projects_29af, typess_29b1, basictypes_29b2, projects_29b3);
	if( ( !typess_29b1.empty())&& ( !basictypes_29b2.empty())&& ( !projects_29b3.empty()))
		callProcessArray1_2bca( typess_29b1, basictypes_29b2, projects_29b3);
}

void ProcessColumn_2bbc::callProcessArray1_2bca( const Packets_t& typess_2a8e, const Packets_t& basictypes_2a90, const Packets_t& projects_2a92)
{
	Packets_t typess_2a94;
	Packets_t array1s_2a95;
	Packets_t projects_2a96;
	ProcessArray1_2a8d processArray1_2a8d;
	processArray1_2a8d( typess_2a8e, basictypes_2a90, projects_2a92, typess_2a94, array1s_2a95, projects_2a96);
	_types_2bc4->insert( _types_2bc4->end(), typess_2a94.begin(), typess_2a94.end());
	_array1_2bc5->insert( _array1_2bc5->end(), array1s_2a95.begin(), array1s_2a95.end());
	_project_2bc6->insert( _project_2bc6->end(), projects_2a96.begin(), projects_2a96.end());
}

void DimensionTest_2bce::operator()( const Packets_t& typess_2bcf, const Packets_t& projects_2bd1, Packets_t& typess_2bd3, Packets_t& projects_2bd4, Packets_t& typess_2bd5, Packets_t& projects_2bd6, Packets_t& typess_2bd7, Packets_t& projects_2bd8)
{
#ifdef PRINT_INFO
	printLog( "DimensionTest_2bce" );
#endif
	_types_2bd9= &typess_2bd3;
	_project_2bda= &projects_2bd4;
	_types_2bdb= &typess_2bd5;
	_project_2bdc= &projects_2bd6;
	_types_2bdd= &typess_2bd7;
	_project_2bde= &projects_2bd8;
	for( Packets_t::const_iterator ittypes_2be0= typess_2bcf.begin(), itproject_2be7= projects_2bd1.begin(); ittypes_2be0!= typess_2bcf.end(), itproject_2be7!= projects_2bd1.end(); ++ittypes_2be0, ++itproject_2be7)
	{
		bool isUnique= isInputUnique( *ittypes_2be0, *itproject_2be7);
		if( !isUnique)
			continue;
		Packets_t onetypes_2be4( 1, *ittypes_2be0);
		Packets_t oneproject_2beb( 1, *itproject_2be7);
		executeOne( onetypes_2be4, oneproject_2beb);
	}
}

void DimensionTest_2bce::executeOne( const Packets_t& typess_2bcf, const Packets_t& projects_2bd1)
{
	Packets_t matrixs_2bf0;
	Packets_t projects_2bf3;
	Scalar_2bed scalar_2bed;
	bool isMatchScalar_2bed= scalar_2bed( typess_2bcf, projects_2bd1, matrixs_2bf0, projects_2bf3);
	_types_2bd9->insert( _types_2bd9->end(), matrixs_2bf0.begin(), matrixs_2bf0.end());
	_project_2bda->insert( _project_2bda->end(), projects_2bf3.begin(), projects_2bf3.end());
	if( isMatchScalar_2bed)
		return;
	Packets_t matrixs_2c17;
	Packets_t projects_2c1a;
	ColumnVector_2c14 columnVector_2c14;
	bool isMatchColumnVector_2c14= columnVector_2c14( typess_2bcf, projects_2bd1, matrixs_2c17, projects_2c1a);
	_types_2bdb->insert( _types_2bdb->end(), matrixs_2c17.begin(), matrixs_2c17.end());
	_project_2bdc->insert( _project_2bdc->end(), projects_2c1a.begin(), projects_2c1a.end());
	if( isMatchColumnVector_2c14)
		return;
	Packets_t matrixs_2c3e;
	Packets_t projects_2c41;
	Other_2c3b other_2c3b;
	bool isMatchOther_2c3b= other_2c3b( typess_2bcf, projects_2bd1, matrixs_2c3e, projects_2c41);
	_types_2bdd->insert( _types_2bdd->end(), matrixs_2c3e.begin(), matrixs_2c3e.end());
	_project_2bde->insert( _project_2bde->end(), projects_2c41.begin(), projects_2c41.end());
	if( isMatchOther_2c3b)
		return;
}

bool DimensionTest_2bce::isInputUnique( const Udm::Object& types_2be1, const Udm::Object& project_2be8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator ittypes_2be3= _types_2bdf.begin(), itproject_2bea= _project_2be6.begin(); ittypes_2be3!= _types_2bdf.end(), itproject_2bea!= _project_2be6.end(); ++ittypes_2be3, ++itproject_2bea)
	{
		if( ( *ittypes_2be3== types_2be1)&& ( *itproject_2bea== project_2be8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_types_2bdf.push_back( types_2be1);
		_project_2be6.push_back( project_2be8);
	}
	return isUnique;
}

bool Scalar_2bed::operator()( const Packets_t& matrixs_2bee, const Packets_t& projects_2bf1, Packets_t& matrixs_2bf0, Packets_t& projects_2bf3)
{
#ifdef PRINT_INFO
	printLog( "Scalar_2bed" );
#endif
	_matrix_2bf4= &matrixs_2bf0;
	_project_2bf5= &projects_2bf3;
	processInputPackets( matrixs_2bee, projects_2bf1);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Scalar_2bed::isInputUnique( const Udm::Object& matrix_2bfa, const Udm::Object& project_2c03)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_2bfc= _matrix_2bf6.begin(), itProject_2c05= _project_2bff.begin(); itMatrix_2bfc!= _matrix_2bf6.end(), itProject_2c05!= _project_2bff.end(); ++itMatrix_2bfc, ++itProject_2c05)
	{
		if( ( *itMatrix_2bfc== matrix_2bfa)&& ( *itProject_2c05== project_2c03))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_2bf6.push_back( matrix_2bfa);
		_project_2bff.push_back( project_2c03);
	}
	return isUnique;
}

bool Scalar_2bed::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool Scalar_2bed::isGuardTrue( CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard = Matrix.rows() == 1 && Matrix.columns() == 1;;
	return Gz_guard;
}

void Scalar_2bed::processInputPackets( const Packets_t& matrixs_2bee, const Packets_t& projects_2bf1)
{
	for( Packets_t::const_iterator itMatrix_2bf7= matrixs_2bee.begin(), itProject_2c00= projects_2bf1.begin(); itMatrix_2bf7!= matrixs_2bee.end(), itProject_2c00!= projects_2bf1.end(); ++itMatrix_2bf7, ++itProject_2c00)
	{
		bool isUnique= isInputUnique( *itMatrix_2bf7, *itProject_2c00);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_2bf7, *itProject_2c00);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_2c0c, currMatch.project_2c0d);
	}
}

bool Scalar_2bed::patternMatcher( const Udm::Object& matrix_2bf8, const Udm::Object& project_2c01)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_2bf8.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_2bfd= CyberComposition::Simulink::SF_Matrix::Cast( matrix_2bf8);
		if( false== Uml::IsDerivedFrom( project_2c01.type(), SFC::Project::meta))
			continue;
		SFC::Project project_2c06= SFC::Project::Cast( project_2c01);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2c0b;
		if( !isValidBound(boundObjs_2c0b, matrix_2bfd, true))
			continue;
		currMatch.matrix_2c0c= matrix_2bfd;
		if( !isValidBound(boundObjs_2c0b, project_2c06, true))
			continue;
		currMatch.project_2c0d= project_2c06;
		bool Gz_guard= isGuardTrue( currMatch.matrix_2c0c, currMatch.project_2c0d);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Scalar_2bed::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_2c10, const SFC::Project& project_2c12)
{
	_matrix_2bf4->push_back( matrix_2c10);
	_project_2bf5->push_back( project_2c12);
}

bool ColumnVector_2c14::operator()( const Packets_t& matrixs_2c15, const Packets_t& projects_2c18, Packets_t& matrixs_2c17, Packets_t& projects_2c1a)
{
#ifdef PRINT_INFO
	printLog( "ColumnVector_2c14" );
#endif
	_matrix_2c1b= &matrixs_2c17;
	_project_2c1c= &projects_2c1a;
	processInputPackets( matrixs_2c15, projects_2c18);
	if( false== _matches.empty())
		return true;
	return false;
}

bool ColumnVector_2c14::isInputUnique( const Udm::Object& matrix_2c21, const Udm::Object& project_2c2a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_2c23= _matrix_2c1d.begin(), itProject_2c2c= _project_2c26.begin(); itMatrix_2c23!= _matrix_2c1d.end(), itProject_2c2c!= _project_2c26.end(); ++itMatrix_2c23, ++itProject_2c2c)
	{
		if( ( *itMatrix_2c23== matrix_2c21)&& ( *itProject_2c2c== project_2c2a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_2c1d.push_back( matrix_2c21);
		_project_2c26.push_back( project_2c2a);
	}
	return isUnique;
}

bool ColumnVector_2c14::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool ColumnVector_2c14::isGuardTrue( CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard = Matrix.rows() != 1 && Matrix.columns() == 1;;
	return Gz_guard;
}

void ColumnVector_2c14::processInputPackets( const Packets_t& matrixs_2c15, const Packets_t& projects_2c18)
{
	for( Packets_t::const_iterator itMatrix_2c1e= matrixs_2c15.begin(), itProject_2c27= projects_2c18.begin(); itMatrix_2c1e!= matrixs_2c15.end(), itProject_2c27!= projects_2c18.end(); ++itMatrix_2c1e, ++itProject_2c27)
	{
		bool isUnique= isInputUnique( *itMatrix_2c1e, *itProject_2c27);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_2c1e, *itProject_2c27);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_2c33, currMatch.project_2c34);
	}
}

bool ColumnVector_2c14::patternMatcher( const Udm::Object& matrix_2c1f, const Udm::Object& project_2c28)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_2c1f.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_2c24= CyberComposition::Simulink::SF_Matrix::Cast( matrix_2c1f);
		if( false== Uml::IsDerivedFrom( project_2c28.type(), SFC::Project::meta))
			continue;
		SFC::Project project_2c2d= SFC::Project::Cast( project_2c28);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2c32;
		if( !isValidBound(boundObjs_2c32, matrix_2c24, true))
			continue;
		currMatch.matrix_2c33= matrix_2c24;
		if( !isValidBound(boundObjs_2c32, project_2c2d, true))
			continue;
		currMatch.project_2c34= project_2c2d;
		bool Gz_guard= isGuardTrue( currMatch.matrix_2c33, currMatch.project_2c34);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void ColumnVector_2c14::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_2c37, const SFC::Project& project_2c39)
{
	_matrix_2c1b->push_back( matrix_2c37);
	_project_2c1c->push_back( project_2c39);
}

bool Other_2c3b::operator()( const Packets_t& matrixs_2c3c, const Packets_t& projects_2c3f, Packets_t& matrixs_2c3e, Packets_t& projects_2c41)
{
#ifdef PRINT_INFO
	printLog( "Other_2c3b" );
#endif
	_matrix_2c42= &matrixs_2c3e;
	_project_2c43= &projects_2c41;
	processInputPackets( matrixs_2c3c, projects_2c3f);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Other_2c3b::isInputUnique( const Udm::Object& matrix_2c48, const Udm::Object& project_2c51)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_2c4a= _matrix_2c44.begin(), itProject_2c53= _project_2c4d.begin(); itMatrix_2c4a!= _matrix_2c44.end(), itProject_2c53!= _project_2c4d.end(); ++itMatrix_2c4a, ++itProject_2c53)
	{
		if( ( *itMatrix_2c4a== matrix_2c48)&& ( *itProject_2c53== project_2c51))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_2c44.push_back( matrix_2c48);
		_project_2c4d.push_back( project_2c51);
	}
	return isUnique;
}

bool Other_2c3b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Other_2c3b::processInputPackets( const Packets_t& matrixs_2c3c, const Packets_t& projects_2c3f)
{
	for( Packets_t::const_iterator itMatrix_2c45= matrixs_2c3c.begin(), itProject_2c4e= projects_2c3f.begin(); itMatrix_2c45!= matrixs_2c3c.end(), itProject_2c4e!= projects_2c3f.end(); ++itMatrix_2c45, ++itProject_2c4e)
	{
		bool isUnique= isInputUnique( *itMatrix_2c45, *itProject_2c4e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_2c45, *itProject_2c4e);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_2c5a, currMatch.project_2c5b);
	}
}

bool Other_2c3b::patternMatcher( const Udm::Object& matrix_2c46, const Udm::Object& project_2c4f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_2c46.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_2c4b= CyberComposition::Simulink::SF_Matrix::Cast( matrix_2c46);
		if( false== Uml::IsDerivedFrom( project_2c4f.type(), SFC::Project::meta))
			continue;
		SFC::Project project_2c54= SFC::Project::Cast( project_2c4f);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2c59;
		if( !isValidBound(boundObjs_2c59, matrix_2c4b, true))
			continue;
		currMatch.matrix_2c5a= matrix_2c4b;
		if( !isValidBound(boundObjs_2c59, project_2c54, true))
			continue;
		currMatch.project_2c5b= project_2c54;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Other_2c3b::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_2c5c, const SFC::Project& project_2c5e)
{
	_matrix_2c42->push_back( matrix_2c5c);
	_project_2c43->push_back( project_2c5e);
}

void StructOrMatrix_2c72::operator()( const Packets_t& typess_2c73, const Packets_t& projects_2c75, Packets_t& typess_2c77, Packets_t& projects_2c78, Packets_t& typess_2c79, Packets_t& projects_2c7a)
{
#ifdef PRINT_INFO
	printLog( "StructOrMatrix_2c72" );
#endif
	_types_2c7b= &typess_2c77;
	_project_2c7c= &projects_2c78;
	_types_2c7d= &typess_2c79;
	_project_2c7e= &projects_2c7a;
	for( Packets_t::const_iterator ittypes_2c80= typess_2c73.begin(), itproject_2c87= projects_2c75.begin(); ittypes_2c80!= typess_2c73.end(), itproject_2c87!= projects_2c75.end(); ++ittypes_2c80, ++itproject_2c87)
	{
		bool isUnique= isInputUnique( *ittypes_2c80, *itproject_2c87);
		if( !isUnique)
			continue;
		Packets_t onetypes_2c84( 1, *ittypes_2c80);
		Packets_t oneproject_2c8b( 1, *itproject_2c87);
		executeOne( onetypes_2c84, oneproject_2c8b);
	}
}

void StructOrMatrix_2c72::executeOne( const Packets_t& typess_2c73, const Packets_t& projects_2c75)
{
	Packets_t typeStructs_2c90;
	Packets_t projects_2c93;
	IsStruct_2c8d isStruct_2c8d;
	bool isMatchIsStruct_2c8d= isStruct_2c8d( typess_2c73, projects_2c75, typeStructs_2c90, projects_2c93);
	_types_2c7b->insert( _types_2c7b->end(), typeStructs_2c90.begin(), typeStructs_2c90.end());
	_project_2c7c->insert( _project_2c7c->end(), projects_2c93.begin(), projects_2c93.end());
	Packets_t matrixs_2cb5;
	Packets_t projects_2cb8;
	IsMatrix_2cb2 isMatrix_2cb2;
	bool isMatchIsMatrix_2cb2= isMatrix_2cb2( typess_2c73, projects_2c75, matrixs_2cb5, projects_2cb8);
	_types_2c7d->insert( _types_2c7d->end(), matrixs_2cb5.begin(), matrixs_2cb5.end());
	_project_2c7e->insert( _project_2c7e->end(), projects_2cb8.begin(), projects_2cb8.end());
}

bool StructOrMatrix_2c72::isInputUnique( const Udm::Object& types_2c81, const Udm::Object& project_2c88)
{
	bool isUnique= true;
	for( Packets_t::const_iterator ittypes_2c83= _types_2c7f.begin(), itproject_2c8a= _project_2c86.begin(); ittypes_2c83!= _types_2c7f.end(), itproject_2c8a!= _project_2c86.end(); ++ittypes_2c83, ++itproject_2c8a)
	{
		if( ( *ittypes_2c83== types_2c81)&& ( *itproject_2c8a== project_2c88))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_types_2c7f.push_back( types_2c81);
		_project_2c86.push_back( project_2c88);
	}
	return isUnique;
}

bool IsStruct_2c8d::operator()( const Packets_t& typeStructs_2c8e, const Packets_t& projects_2c91, Packets_t& typeStructs_2c90, Packets_t& projects_2c93)
{
#ifdef PRINT_INFO
	printLog( "IsStruct_2c8d" );
#endif
	_typeStruct_2c94= &typeStructs_2c90;
	_project_2c95= &projects_2c93;
	processInputPackets( typeStructs_2c8e, projects_2c91);
	if( false== _matches.empty())
		return true;
	return false;
}

bool IsStruct_2c8d::isInputUnique( const Udm::Object& typeStruct_2c9a, const Udm::Object& project_2ca3)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itTypeStruct_2c9c= _typeStruct_2c96.begin(), itProject_2ca5= _project_2c9f.begin(); itTypeStruct_2c9c!= _typeStruct_2c96.end(), itProject_2ca5!= _project_2c9f.end(); ++itTypeStruct_2c9c, ++itProject_2ca5)
	{
		if( ( *itTypeStruct_2c9c== typeStruct_2c9a)&& ( *itProject_2ca5== project_2ca3))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_typeStruct_2c96.push_back( typeStruct_2c9a);
		_project_2c9f.push_back( project_2ca3);
	}
	return isUnique;
}

bool IsStruct_2c8d::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void IsStruct_2c8d::processInputPackets( const Packets_t& typeStructs_2c8e, const Packets_t& projects_2c91)
{
	for( Packets_t::const_iterator itTypeStruct_2c97= typeStructs_2c8e.begin(), itProject_2ca0= projects_2c91.begin(); itTypeStruct_2c97!= typeStructs_2c8e.end(), itProject_2ca0!= projects_2c91.end(); ++itTypeStruct_2c97, ++itProject_2ca0)
	{
		bool isUnique= isInputUnique( *itTypeStruct_2c97, *itProject_2ca0);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itTypeStruct_2c97, *itProject_2ca0);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.typeStruct_2cac, currMatch.project_2cad);
	}
}

bool IsStruct_2c8d::patternMatcher( const Udm::Object& typeStruct_2c98, const Udm::Object& project_2ca1)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( typeStruct_2c98.type(), CyberComposition::Simulink::TypeStruct::meta))
			continue;
		CyberComposition::Simulink::TypeStruct typeStruct_2c9d= CyberComposition::Simulink::TypeStruct::Cast( typeStruct_2c98);
		if( false== Uml::IsDerivedFrom( project_2ca1.type(), SFC::Project::meta))
			continue;
		SFC::Project project_2ca6= SFC::Project::Cast( project_2ca1);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2cab;
		if( !isValidBound(boundObjs_2cab, typeStruct_2c9d, true))
			continue;
		currMatch.typeStruct_2cac= typeStruct_2c9d;
		if( !isValidBound(boundObjs_2cab, project_2ca6, true))
			continue;
		currMatch.project_2cad= project_2ca6;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void IsStruct_2c8d::outputAppender( const CyberComposition::Simulink::TypeStruct& typeStruct_2cae, const SFC::Project& project_2cb0)
{
	_typeStruct_2c94->push_back( typeStruct_2cae);
	_project_2c95->push_back( project_2cb0);
}

bool IsMatrix_2cb2::operator()( const Packets_t& matrixs_2cb3, const Packets_t& projects_2cb6, Packets_t& matrixs_2cb5, Packets_t& projects_2cb8)
{
#ifdef PRINT_INFO
	printLog( "IsMatrix_2cb2" );
#endif
	_matrix_2cb9= &matrixs_2cb5;
	_project_2cba= &projects_2cb8;
	processInputPackets( matrixs_2cb3, projects_2cb6);
	if( false== _matches.empty())
		return true;
	return false;
}

bool IsMatrix_2cb2::isInputUnique( const Udm::Object& matrix_2cbf, const Udm::Object& project_2cc8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_2cc1= _matrix_2cbb.begin(), itProject_2cca= _project_2cc4.begin(); itMatrix_2cc1!= _matrix_2cbb.end(), itProject_2cca!= _project_2cc4.end(); ++itMatrix_2cc1, ++itProject_2cca)
	{
		if( ( *itMatrix_2cc1== matrix_2cbf)&& ( *itProject_2cca== project_2cc8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_2cbb.push_back( matrix_2cbf);
		_project_2cc4.push_back( project_2cc8);
	}
	return isUnique;
}

bool IsMatrix_2cb2::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void IsMatrix_2cb2::processInputPackets( const Packets_t& matrixs_2cb3, const Packets_t& projects_2cb6)
{
	for( Packets_t::const_iterator itMatrix_2cbc= matrixs_2cb3.begin(), itProject_2cc5= projects_2cb6.begin(); itMatrix_2cbc!= matrixs_2cb3.end(), itProject_2cc5!= projects_2cb6.end(); ++itMatrix_2cbc, ++itProject_2cc5)
	{
		bool isUnique= isInputUnique( *itMatrix_2cbc, *itProject_2cc5);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_2cbc, *itProject_2cc5);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_2cd1, currMatch.project_2cd2);
	}
}

bool IsMatrix_2cb2::patternMatcher( const Udm::Object& matrix_2cbd, const Udm::Object& project_2cc6)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_2cbd.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_2cc2= CyberComposition::Simulink::SF_Matrix::Cast( matrix_2cbd);
		if( false== Uml::IsDerivedFrom( project_2cc6.type(), SFC::Project::meta))
			continue;
		SFC::Project project_2ccb= SFC::Project::Cast( project_2cc6);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2cd0;
		if( !isValidBound(boundObjs_2cd0, matrix_2cc2, true))
			continue;
		currMatch.matrix_2cd1= matrix_2cc2;
		if( !isValidBound(boundObjs_2cd0, project_2ccb, true))
			continue;
		currMatch.project_2cd2= project_2ccb;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void IsMatrix_2cb2::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_2cd3, const SFC::Project& project_2cd5)
{
	_matrix_2cb9->push_back( matrix_2cd3);
	_project_2cba->push_back( project_2cd5);
}

void CreateStructType_2cd7::operator()( const Packets_t& ecsl_dp_Structs_2cd8, const Packets_t& projects_2cdb, Packets_t& ecsl_dp_Structs_2cda, Packets_t& sfc_Structs_2cdd)
{
#ifdef PRINT_INFO
	printLog( "CreateStructType_2cd7" );
#endif
	RTTGenerator::Instance()->generateRule(2165, "CreateStructType");
	_ecsl_dp_Struct_2cde= &ecsl_dp_Structs_2cda;
	_sfc_Struct_2cdf= &sfc_Structs_2cdd;
	processInputPackets( ecsl_dp_Structs_2cd8, projects_2cdb);
}

bool CreateStructType_2cd7::isInputUnique( const Udm::Object& ecsl_dp_Struct_2ce4, const Udm::Object& project_2ced)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itecsl_dp_Struct_2ce6= _ecsl_dp_Struct_2ce0.begin(), itProject_2cef= _project_2ce9.begin(); itecsl_dp_Struct_2ce6!= _ecsl_dp_Struct_2ce0.end(), itProject_2cef!= _project_2ce9.end(); ++itecsl_dp_Struct_2ce6, ++itProject_2cef)
	{
		if( ( *itecsl_dp_Struct_2ce6== ecsl_dp_Struct_2ce4)&& ( *itProject_2cef== project_2ced))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_ecsl_dp_Struct_2ce0.push_back( ecsl_dp_Struct_2ce4);
		_project_2ce9.push_back( project_2ced);
	}
	return isUnique;
}

bool CreateStructType_2cd7::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateStructType_2cd7::processInputPackets( const Packets_t& ecsl_dp_Structs_2cd8, const Packets_t& projects_2cdb)
{
	for( Packets_t::const_iterator itecsl_dp_Struct_2ce1= ecsl_dp_Structs_2cd8.begin(), itProject_2cea= projects_2cdb.begin(); itecsl_dp_Struct_2ce1!= ecsl_dp_Structs_2cd8.end(), itProject_2cea!= projects_2cdb.end(); ++itecsl_dp_Struct_2ce1, ++itProject_2cea)
	{
		bool isUnique= isInputUnique( *itecsl_dp_Struct_2ce1, *itProject_2cea);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itecsl_dp_Struct_2ce1, *itProject_2cea);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateStructType_2cd7::patternMatcher( const Udm::Object& ecsl_dp_Struct_2ce2, const Udm::Object& project_2ceb)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( ecsl_dp_Struct_2ce2.type(), CyberComposition::Simulink::TypeStruct::meta))
			continue;
		CyberComposition::Simulink::TypeStruct ecsl_dp_Struct_2ce7= CyberComposition::Simulink::TypeStruct::Cast( ecsl_dp_Struct_2ce2);
		if( false== Uml::IsDerivedFrom( project_2ceb.type(), SFC::Project::meta))
			continue;
		SFC::Project project_2cf0= SFC::Project::Cast( project_2ceb);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2cf5;
		if( !isValidBound(boundObjs_2cf5, ecsl_dp_Struct_2ce7, true))
			continue;
		currMatch.ecsl_dp_Struct_2cf6= ecsl_dp_Struct_2ce7;
		if( !isValidBound(boundObjs_2cf5, project_2cf0, true))
			continue;
		currMatch.project_2cf7= project_2cf0;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateStructType_2cd7::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Struct newsfc_Struct_2cf8= SFC::Struct::Create( currMatch.project_2cf7, SFC::Project::meta_stmnt);
		SFC::Project& Project= currMatch.project_2cf7;
		CyberComposition::Simulink::TypeStruct& ecsl_dp_Struct= currMatch.ecsl_dp_Struct_2cf6;
		SFC::Struct& sfc_Struct= newsfc_Struct_2cf8;
		{
sfc_Struct.memberCount() = ecsl_dp_Struct.MemberCount();
sfc_Struct.name() = ecsl_dp_Struct.name();
};
		{
__int64 sc = Project.statementCount();
sfc_Struct.statementIndex() = sc++;
Project.statementCount() = sc;
};
		newsfc_Struct_2cf8.tb()= currMatch.ecsl_dp_Struct_2cf6;
		outputAppender( currMatch.ecsl_dp_Struct_2cf6, newsfc_Struct_2cf8);
	}
}

void CreateStructType_2cd7::outputAppender( const CyberComposition::Simulink::TypeStruct& ecsl_dp_Struct_2cf9, const SFC::Struct& sfc_Struct_2cfb)
{
	_ecsl_dp_Struct_2cde->push_back( ecsl_dp_Struct_2cf9);
	_sfc_Struct_2cdf->push_back( sfc_Struct_2cfb);
}

void RegisterStruct_2d06::operator()( const Packets_t& sfcStructs_2d07)
{
#ifdef PRINT_INFO
	printLog( "RegisterStruct_2d06" );
#endif
	RTTGenerator::Instance()->generateRule(2173, "RegisterStruct");
	processInputPackets( sfcStructs_2d07);
}

bool RegisterStruct_2d06::isInputUnique( const Udm::Object& sfcStruct_2d0d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itsfcStruct_2d0f= _sfcStruct_2d09.begin(); itsfcStruct_2d0f!= _sfcStruct_2d09.end(); ++itsfcStruct_2d0f)
	{
		if( ( *itsfcStruct_2d0f== sfcStruct_2d0d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_sfcStruct_2d09.push_back( sfcStruct_2d0d);
	return isUnique;
}

bool RegisterStruct_2d06::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void RegisterStruct_2d06::processInputPackets( const Packets_t& sfcStructs_2d07)
{
	for( Packets_t::const_iterator itsfcStruct_2d0a= sfcStructs_2d07.begin(); itsfcStruct_2d0a!= sfcStructs_2d07.end(); ++itsfcStruct_2d0a)
	{
		bool isUnique= isInputUnique( *itsfcStruct_2d0a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itsfcStruct_2d0a);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool RegisterStruct_2d06::patternMatcher( const Udm::Object& sfcStruct_2d0b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sfcStruct_2d0b.type(), SFC::Struct::meta))
			continue;
		SFC::Struct sfcStruct_2d10= SFC::Struct::Cast( sfcStruct_2d0b);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2d15;
		if( !isValidBound(boundObjs_2d15, sfcStruct_2d10, true))
			continue;
		currMatch.sfcStruct_2d16= sfcStruct_2d10;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void RegisterStruct_2d06::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Struct& sfcStruct= currMatch.sfcStruct_2d16;
		{
SFCTypesManager::getSingleton().makeTypeUnique( sfcStruct );
};
	}
}

void StructMembers_2d17::operator()( const Packets_t& typess_2d18, const Packets_t& newStructs_2d1a, Packets_t& newStructs_2d1c)
{
#ifdef PRINT_INFO
	printLog( "StructMembers_2d17" );
#endif
	_newStruct_2d1d= &newStructs_2d1c;
	_newStruct_2d1d->insert( _newStruct_2d1d->end(), newStructs_2d1a.begin(), newStructs_2d1a.end());
	if( ( !typess_2d18.empty())&& ( !newStructs_2d1a.empty()))
		callCreateStructMembers_2d44( typess_2d18, newStructs_2d1a);
}

void StructMembers_2d17::callCreateStructMembers_2d44( const Packets_t& ecsl_dp_Structs_2d1f, const Packets_t& sfc_Structs_2d21)
{
	CreateStructMembers_2d1e createStructMembers_2d1e;
	createStructMembers_2d1e( ecsl_dp_Structs_2d1f, sfc_Structs_2d21);
}

void CreateStructMembers_2d1e::operator()( const Packets_t& ecsl_dp_Structs_2d1f, const Packets_t& sfc_Structs_2d21)
{
#ifdef PRINT_INFO
	printLog( "CreateStructMembers_2d1e" );
#endif
	RTTGenerator::Instance()->generateRule(2180, "CreateStructMembers");
	processInputPackets( ecsl_dp_Structs_2d1f, sfc_Structs_2d21);
}

bool CreateStructMembers_2d1e::isInputUnique( const Udm::Object& ecsl_dp_Struct_2d27, const Udm::Object& sfc_Struct_2d30)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itecsl_dp_Struct_2d29= _ecsl_dp_Struct_2d23.begin(), itsfc_Struct_2d32= _sfc_Struct_2d2c.begin(); itecsl_dp_Struct_2d29!= _ecsl_dp_Struct_2d23.end(), itsfc_Struct_2d32!= _sfc_Struct_2d2c.end(); ++itecsl_dp_Struct_2d29, ++itsfc_Struct_2d32)
	{
		if( ( *itecsl_dp_Struct_2d29== ecsl_dp_Struct_2d27)&& ( *itsfc_Struct_2d32== sfc_Struct_2d30))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_ecsl_dp_Struct_2d23.push_back( ecsl_dp_Struct_2d27);
		_sfc_Struct_2d2c.push_back( sfc_Struct_2d30);
	}
	return isUnique;
}

bool CreateStructMembers_2d1e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateStructMembers_2d1e::processInputPackets( const Packets_t& ecsl_dp_Structs_2d1f, const Packets_t& sfc_Structs_2d21)
{
	for( Packets_t::const_iterator itecsl_dp_Struct_2d24= ecsl_dp_Structs_2d1f.begin(), itsfc_Struct_2d2d= sfc_Structs_2d21.begin(); itecsl_dp_Struct_2d24!= ecsl_dp_Structs_2d1f.end(), itsfc_Struct_2d2d!= sfc_Structs_2d21.end(); ++itecsl_dp_Struct_2d24, ++itsfc_Struct_2d2d)
	{
		bool isUnique= isInputUnique( *itecsl_dp_Struct_2d24, *itsfc_Struct_2d2d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itecsl_dp_Struct_2d24, *itsfc_Struct_2d2d);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateStructMembers_2d1e::patternMatcher( const Udm::Object& ecsl_dp_Struct_2d25, const Udm::Object& sfc_Struct_2d2e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( ecsl_dp_Struct_2d25.type(), CyberComposition::Simulink::TypeStruct::meta))
			continue;
		CyberComposition::Simulink::TypeStruct ecsl_dp_Struct_2d2a= CyberComposition::Simulink::TypeStruct::Cast( ecsl_dp_Struct_2d25);
		if( false== Uml::IsDerivedFrom( sfc_Struct_2d2e.type(), SFC::Struct::meta))
			continue;
		SFC::Struct sfc_Struct_2d33= SFC::Struct::Cast( sfc_Struct_2d2e);
		set< CyberComposition::Simulink::TypeBaseRef> ecsl_dp_StructRefs_2d35= ecsl_dp_Struct_2d2a.TypeBaseRef_kind_children();
		for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itecsl_dp_StructRef_2d36= ecsl_dp_StructRefs_2d35.begin(); itecsl_dp_StructRef_2d36!= ecsl_dp_StructRefs_2d35.end(); ++itecsl_dp_StructRef_2d36)
		{
			CyberComposition::Simulink::TypeBaseRef currecsl_dp_StructRef_2d37= *itecsl_dp_StructRef_2d36;
			CyberComposition::Simulink::SF_TypeBase ecsl_dp_TypeBase_2d38= currecsl_dp_StructRef_2d37.ref();
			if( !ecsl_dp_TypeBase_2d38)
				continue;
			SFC::DT sfc_DT_2d39= ecsl_dp_TypeBase_2d38.dt();
			if( !sfc_DT_2d39)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2d3d;
			if( !isValidBound(boundObjs_2d3d, ecsl_dp_Struct_2d2a, true))
				continue;
			currMatch.ecsl_dp_Struct_2d3e= ecsl_dp_Struct_2d2a;
			if( !isValidBound(boundObjs_2d3d, sfc_Struct_2d33, true))
				continue;
			currMatch.sfc_Struct_2d3f= sfc_Struct_2d33;
			if( !isValidBound(boundObjs_2d3d, currecsl_dp_StructRef_2d37, false))
				continue;
			currMatch.ecsl_dp_StructRef_2d40= currecsl_dp_StructRef_2d37;
			if( !isValidBound(boundObjs_2d3d, ecsl_dp_TypeBase_2d38, false))
				continue;
			currMatch.ecsl_dp_TypeBase_2d41= ecsl_dp_TypeBase_2d38;
			if( !isValidBound(boundObjs_2d3d, sfc_DT_2d39, false))
				continue;
			currMatch.sfc_DT_2d42= sfc_DT_2d39;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateStructMembers_2d1e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newStructLocalVar_2d43= SFC::LocalVar::Create( currMatch.sfc_Struct_2d3f, SFC::Struct::meta_memb);
		SFC::LocalVar& StructLocalVar= newStructLocalVar_2d43;
		CyberComposition::Simulink::TypeStruct& ecsl_dp_Struct= currMatch.ecsl_dp_Struct_2d3e;
		CyberComposition::Simulink::TypeBaseRef& ecsl_dp_StructRef= currMatch.ecsl_dp_StructRef_2d40;
		CyberComposition::Simulink::SF_TypeBase& ecsl_dp_TypeBase= currMatch.ecsl_dp_TypeBase_2d41;
		SFC::DT& sfc_DT= currMatch.sfc_DT_2d42;
		SFC::Struct& sfc_Struct= currMatch.sfc_Struct_2d3f;
		{
StructLocalVar.name() = ecsl_dp_StructRef.name();
StructLocalVar.statementIndex() = ecsl_dp_StructRef.MemberIndex();
};
		newStructLocalVar_2d43.dt()= currMatch.sfc_DT_2d42;
		newStructLocalVar_2d43.tbr()= currMatch.ecsl_dp_StructRef_2d40;
	}
}

void GetTypeBlock_2d47::operator()( const Packets_t& rootFolders_2d48, const Packets_t& projects_2d4a, Packets_t& typess_2d4c, Packets_t& projects_2d4d)
{
#ifdef PRINT_INFO
	printLog( "GetTypeBlock_2d47" );
#endif
	_types_2d4e= &typess_2d4c;
	_project_2d4f= &projects_2d4d;
	if( ( !rootFolders_2d48.empty())&& ( !projects_2d4a.empty()))
		callGetTypes_2dae( rootFolders_2d48, projects_2d4a);
	if( ( !rootFolders_2d48.empty())&& ( !projects_2d4a.empty()))
		callGetTypesFromLib_2db1( rootFolders_2d48, projects_2d4a);
}

void GetTypeBlock_2d47::callGetTypes_2dae( const Packets_t& rootFolders_2d82, const Packets_t& projects_2d85)
{
	Packets_t typeBases_2d84;
	Packets_t projects_2d87;
	GetTypes_2d81 getTypes_2d81;
	getTypes_2d81( rootFolders_2d82, projects_2d85, typeBases_2d84, projects_2d87);
	_types_2d4e->insert( _types_2d4e->end(), typeBases_2d84.begin(), typeBases_2d84.end());
	_project_2d4f->insert( _project_2d4f->end(), projects_2d87.begin(), projects_2d87.end());
}

void GetTypeBlock_2d47::callGetTypesFromLib_2db1( const Packets_t& rootFolders_2d51, const Packets_t& projects_2d54)
{
	Packets_t typeBases_2d53;
	Packets_t projects_2d56;
	GetTypesFromLib_2d50 getTypesFromLib_2d50;
	getTypesFromLib_2d50( rootFolders_2d51, projects_2d54, typeBases_2d53, projects_2d56);
	_types_2d4e->insert( _types_2d4e->end(), typeBases_2d53.begin(), typeBases_2d53.end());
	_project_2d4f->insert( _project_2d4f->end(), projects_2d56.begin(), projects_2d56.end());
}

void GetTypesFromLib_2d50::operator()( const Packets_t& rootFolders_2d51, const Packets_t& projects_2d54, Packets_t& typeBases_2d53, Packets_t& projects_2d56)
{
#ifdef PRINT_INFO
	printLog( "GetTypesFromLib_2d50" );
#endif
	RTTGenerator::Instance()->generateRule(2199, "GetTypesFromLib");
	_typeBase_2d57= &typeBases_2d53;
	_project_2d58= &projects_2d56;
	processInputPackets( rootFolders_2d51, projects_2d54);
}

bool GetTypesFromLib_2d50::isInputUnique( const Udm::Object& rootFolder_2d5d, const Udm::Object& project_2d66)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itRootFolder_2d5f= _rootFolder_2d59.begin(), itProject_2d68= _project_2d62.begin(); itRootFolder_2d5f!= _rootFolder_2d59.end(), itProject_2d68!= _project_2d62.end(); ++itRootFolder_2d5f, ++itProject_2d68)
	{
		if( ( *itRootFolder_2d5f== rootFolder_2d5d)&& ( *itProject_2d68== project_2d66))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_rootFolder_2d59.push_back( rootFolder_2d5d);
		_project_2d62.push_back( project_2d66);
	}
	return isUnique;
}

bool GetTypesFromLib_2d50::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetTypesFromLib_2d50::processInputPackets( const Packets_t& rootFolders_2d51, const Packets_t& projects_2d54)
{
	for( Packets_t::const_iterator itRootFolder_2d5a= rootFolders_2d51.begin(), itProject_2d63= projects_2d54.begin(); itRootFolder_2d5a!= rootFolders_2d51.end(), itProject_2d63!= projects_2d54.end(); ++itRootFolder_2d5a, ++itProject_2d63)
	{
		bool isUnique= isInputUnique( *itRootFolder_2d5a, *itProject_2d63);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itRootFolder_2d5a, *itProject_2d63);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetTypesFromLib_2d50::patternMatcher( const Udm::Object& rootFolder_2d5b, const Udm::Object& project_2d64)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( rootFolder_2d5b.type(), CyberComposition::RootFolder::meta))
			continue;
		CyberComposition::RootFolder rootFolder_2d60= CyberComposition::RootFolder::Cast( rootFolder_2d5b);
		if( false== Uml::IsDerivedFrom( project_2d64.type(), SFC::Project::meta))
			continue;
		SFC::Project project_2d69= SFC::Project::Cast( project_2d64);
		set< CyberComposition::RootFolder> rootFolders_2d6b= rootFolder_2d60.RootFolder_kind_children();
		for( set< CyberComposition::RootFolder>::const_iterator itRootFolder_2d6c= rootFolders_2d6b.begin(); itRootFolder_2d6c!= rootFolders_2d6b.end(); ++itRootFolder_2d6c)
		{
			CyberComposition::RootFolder currRootFolder_2d6d= *itRootFolder_2d6c;
			set< CyberComposition::Simulink::Types> typess_2d6e= currRootFolder_2d6d.Simulink_Types_kind_children();
			for( set< CyberComposition::Simulink::Types>::const_iterator itTypes_2d6f= typess_2d6e.begin(); itTypes_2d6f!= typess_2d6e.end(); ++itTypes_2d6f)
			{
				CyberComposition::Simulink::Types currTypes_2d70= *itTypes_2d6f;
				set< CyberComposition::Simulink::SF_TypeBase> typeBases_2d71= currTypes_2d70.SF_TypeBase_kind_children();
				for( set< CyberComposition::Simulink::SF_TypeBase>::const_iterator itTypeBase_2d72= typeBases_2d71.begin(); itTypeBase_2d72!= typeBases_2d71.end(); ++itTypeBase_2d72)
				{
					CyberComposition::Simulink::SF_TypeBase currTypeBase_2d73= *itTypeBase_2d72;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_2d77;
					if( !isValidBound(boundObjs_2d77, rootFolder_2d60, true))
						continue;
					currMatch.rootFolder_2d78= rootFolder_2d60;
					if( !isValidBound(boundObjs_2d77, project_2d69, true))
						continue;
					currMatch.project_2d79= project_2d69;
					if( !isValidBound(boundObjs_2d77, currRootFolder_2d6d, false))
						continue;
					currMatch.rootFolder_2d7a= currRootFolder_2d6d;
					if( !isValidBound(boundObjs_2d77, currTypes_2d70, false))
						continue;
					currMatch.types_2d7b= currTypes_2d70;
					if( !isValidBound(boundObjs_2d77, currTypeBase_2d73, false))
						continue;
					currMatch.typeBase_2d7c= currTypeBase_2d73;
					_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void GetTypesFromLib_2d50::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.typeBase_2d7c, currMatch.project_2d79);
	}
}

void GetTypesFromLib_2d50::outputAppender( const CyberComposition::Simulink::SF_TypeBase& typeBase_2d7d, const SFC::Project& project_2d7f)
{
	_typeBase_2d57->push_back( typeBase_2d7d);
	_project_2d58->push_back( project_2d7f);
}

void GetTypes_2d81::operator()( const Packets_t& rootFolders_2d82, const Packets_t& projects_2d85, Packets_t& typeBases_2d84, Packets_t& projects_2d87)
{
#ifdef PRINT_INFO
	printLog( "GetTypes_2d81" );
#endif
	RTTGenerator::Instance()->generateRule(2208, "GetTypes");
	_typeBase_2d88= &typeBases_2d84;
	_project_2d89= &projects_2d87;
	processInputPackets( rootFolders_2d82, projects_2d85);
}

bool GetTypes_2d81::isInputUnique( const Udm::Object& rootFolder_2d8e, const Udm::Object& project_2d97)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itRootFolder_2d90= _rootFolder_2d8a.begin(), itProject_2d99= _project_2d93.begin(); itRootFolder_2d90!= _rootFolder_2d8a.end(), itProject_2d99!= _project_2d93.end(); ++itRootFolder_2d90, ++itProject_2d99)
	{
		if( ( *itRootFolder_2d90== rootFolder_2d8e)&& ( *itProject_2d99== project_2d97))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_rootFolder_2d8a.push_back( rootFolder_2d8e);
		_project_2d93.push_back( project_2d97);
	}
	return isUnique;
}

bool GetTypes_2d81::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetTypes_2d81::processInputPackets( const Packets_t& rootFolders_2d82, const Packets_t& projects_2d85)
{
	for( Packets_t::const_iterator itRootFolder_2d8b= rootFolders_2d82.begin(), itProject_2d94= projects_2d85.begin(); itRootFolder_2d8b!= rootFolders_2d82.end(), itProject_2d94!= projects_2d85.end(); ++itRootFolder_2d8b, ++itProject_2d94)
	{
		bool isUnique= isInputUnique( *itRootFolder_2d8b, *itProject_2d94);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itRootFolder_2d8b, *itProject_2d94);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetTypes_2d81::patternMatcher( const Udm::Object& rootFolder_2d8c, const Udm::Object& project_2d95)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( rootFolder_2d8c.type(), CyberComposition::RootFolder::meta))
			continue;
		CyberComposition::RootFolder rootFolder_2d91= CyberComposition::RootFolder::Cast( rootFolder_2d8c);
		if( false== Uml::IsDerivedFrom( project_2d95.type(), SFC::Project::meta))
			continue;
		SFC::Project project_2d9a= SFC::Project::Cast( project_2d95);
		set< CyberComposition::Simulink::Types> typess_2d9c= rootFolder_2d91.Simulink_Types_kind_children();
		for( set< CyberComposition::Simulink::Types>::const_iterator itTypes_2d9d= typess_2d9c.begin(); itTypes_2d9d!= typess_2d9c.end(); ++itTypes_2d9d)
		{
			CyberComposition::Simulink::Types currTypes_2d9e= *itTypes_2d9d;
			set< CyberComposition::Simulink::SF_TypeBase> typeBases_2d9f= currTypes_2d9e.SF_TypeBase_kind_children();
			for( set< CyberComposition::Simulink::SF_TypeBase>::const_iterator itTypeBase_2da0= typeBases_2d9f.begin(); itTypeBase_2da0!= typeBases_2d9f.end(); ++itTypeBase_2da0)
			{
				CyberComposition::Simulink::SF_TypeBase currTypeBase_2da1= *itTypeBase_2da0;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_2da5;
				if( !isValidBound(boundObjs_2da5, rootFolder_2d91, true))
					continue;
				currMatch.rootFolder_2da6= rootFolder_2d91;
				if( !isValidBound(boundObjs_2da5, project_2d9a, true))
					continue;
				currMatch.project_2da7= project_2d9a;
				if( !isValidBound(boundObjs_2da5, currTypes_2d9e, false))
					continue;
				currMatch.types_2da8= currTypes_2d9e;
				if( !isValidBound(boundObjs_2da5, currTypeBase_2da1, false))
					continue;
				currMatch.typeBase_2da9= currTypeBase_2da1;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetTypes_2d81::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.typeBase_2da9, currMatch.project_2da7);
	}
}

void GetTypes_2d81::outputAppender( const CyberComposition::Simulink::SF_TypeBase& typeBase_2daa, const SFC::Project& project_2dac)
{
	_typeBase_2d88->push_back( typeBase_2daa);
	_project_2d89->push_back( project_2dac);
}

void GetProject_2dbf::operator()( const Packets_t& rootFolders_2dc0, const Packets_t& states_2dc3, const Packets_t& projects_2dc6, Packets_t& rootFolders_2dc2, Packets_t& states_2dc5, Packets_t& projects_2dc8)
{
#ifdef PRINT_INFO
	printLog( "GetProject_2dbf" );
#endif
	RTTGenerator::Instance()->generateRule(2215, "GetProject");
	_rootFolder_2dc9= &rootFolders_2dc2;
	_state_2dca= &states_2dc5;
	_project_2dcb= &projects_2dc8;
	processInputPackets( rootFolders_2dc0, states_2dc3, projects_2dc6);
	forwardInputs( );
}

bool GetProject_2dbf::isInputUnique( const Udm::Object& rootFolder_2dd0, const Udm::Object& state_2dd9, const Udm::Object& project_2de2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itRootFolder_2dd2= _rootFolder_2dcc.begin(), itState_2ddb= _state_2dd5.begin(), itProject_2de4= _project_2dde.begin(); itRootFolder_2dd2!= _rootFolder_2dcc.end(), itState_2ddb!= _state_2dd5.end(), itProject_2de4!= _project_2dde.end(); ++itRootFolder_2dd2, ++itState_2ddb, ++itProject_2de4)
	{
		if( ( *itRootFolder_2dd2== rootFolder_2dd0)&& ( *itState_2ddb== state_2dd9)&& ( *itProject_2de4== project_2de2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_rootFolder_2dcc.push_back( rootFolder_2dd0);
		_state_2dd5.push_back( state_2dd9);
		_project_2dde.push_back( project_2de2);
	}
	return isUnique;
}

bool GetProject_2dbf::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetProject_2dbf::processInputPackets( const Packets_t& rootFolders_2dc0, const Packets_t& states_2dc3, const Packets_t& projects_2dc6)
{
	for( Packets_t::const_iterator itRootFolder_2dcd= rootFolders_2dc0.begin(), itState_2dd6= states_2dc3.begin(), itProject_2ddf= projects_2dc6.begin(); itRootFolder_2dcd!= rootFolders_2dc0.end(), itState_2dd6!= states_2dc3.end(), itProject_2ddf!= projects_2dc6.end(); ++itRootFolder_2dcd, ++itState_2dd6, ++itProject_2ddf)
	{
		bool isUnique= isInputUnique( *itRootFolder_2dcd, *itState_2dd6, *itProject_2ddf);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itRootFolder_2dcd, *itState_2dd6, *itProject_2ddf);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetProject_2dbf::patternMatcher( const Udm::Object& rootFolder_2dce, const Udm::Object& state_2dd7, const Udm::Object& project_2de0)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( rootFolder_2dce.type(), CyberComposition::RootFolder::meta))
			continue;
		CyberComposition::RootFolder rootFolder_2dd3= CyberComposition::RootFolder::Cast( rootFolder_2dce);
		if( false== Uml::IsDerivedFrom( state_2dd7.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_2ddc= CyberComposition::Simulink::State::Cast( state_2dd7);
		if( false== Uml::IsDerivedFrom( project_2de0.type(), SFC::Project::meta))
			continue;
		SFC::Project project_2de5= SFC::Project::Cast( project_2de0);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2dea;
		if( !isValidBound(boundObjs_2dea, rootFolder_2dd3, true))
			continue;
		currMatch.rootFolder_2deb= rootFolder_2dd3;
		if( !isValidBound(boundObjs_2dea, state_2ddc, true))
			continue;
		currMatch.state_2dec= state_2ddc;
		if( !isValidBound(boundObjs_2dea, project_2de5, true))
			continue;
		currMatch.project_2ded= project_2de5;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void GetProject_2dbf::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Project& Project= currMatch.project_2ded;
		CyberComposition::RootFolder& RootFolder= currMatch.rootFolder_2deb;
		CyberComposition::Simulink::State& State= currMatch.state_2dec;
		{
SFCTypesManager::initSingleton( Project );
};
	}
}

void GetProject_2dbf::forwardInputs()
{
	*_rootFolder_2dc9= _rootFolder_2dcc;
	*_state_2dca= _state_2dd5;
	*_project_2dcb= _project_2dde;
}

void SetFileName_2dee::operator()( const Packets_t& states_2def, const Packets_t& projects_2df3, Packets_t& states_2df1, Packets_t& programs_2df2)
{
#ifdef PRINT_INFO
	printLog( "SetFileName_2dee" );
#endif
	RTTGenerator::Instance()->generateRule(2220, "SetFileName");
	_state_2df5= &states_2df1;
	_program_2df6= &programs_2df2;
	processInputPackets( states_2def, projects_2df3);
}

bool SetFileName_2dee::isInputUnique( const Udm::Object& state_2dfb, const Udm::Object& project_2e04)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_2dfd= _state_2df7.begin(), itProject_2e06= _project_2e00.begin(); itState_2dfd!= _state_2df7.end(), itProject_2e06!= _project_2e00.end(); ++itState_2dfd, ++itProject_2e06)
	{
		if( ( *itState_2dfd== state_2dfb)&& ( *itProject_2e06== project_2e04))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_2df7.push_back( state_2dfb);
		_project_2e00.push_back( project_2e04);
	}
	return isUnique;
}

bool SetFileName_2dee::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void SetFileName_2dee::processInputPackets( const Packets_t& states_2def, const Packets_t& projects_2df3)
{
	for( Packets_t::const_iterator itState_2df8= states_2def.begin(), itProject_2e01= projects_2df3.begin(); itState_2df8!= states_2def.end(), itProject_2e01!= projects_2df3.end(); ++itState_2df8, ++itProject_2e01)
	{
		bool isUnique= isInputUnique( *itState_2df8, *itProject_2e01);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_2df8, *itProject_2e01);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool SetFileName_2dee::patternMatcher( const Udm::Object& state_2df9, const Udm::Object& project_2e02)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_2df9.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_2dfe= CyberComposition::Simulink::State::Cast( state_2df9);
		if( false== Uml::IsDerivedFrom( project_2e02.type(), SFC::Project::meta))
			continue;
		SFC::Project project_2e07= SFC::Project::Cast( project_2e02);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2e0c;
		if( !isValidBound(boundObjs_2e0c, state_2dfe, true))
			continue;
		currMatch.state_2e0d= state_2dfe;
		if( !isValidBound(boundObjs_2e0c, project_2e07, true))
			continue;
		currMatch.project_2e0e= project_2e07;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void SetFileName_2dee::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Program newProgram_2e0f= SFC::Program::Create( currMatch.project_2e0e);
		SFC::Program& Program= newProgram_2e0f;
		SFC::Project& Project= currMatch.project_2e0e;
		CyberComposition::Simulink::State& State= currMatch.state_2e0d;
		{
Project.RefId() = Program.RefId() = State.RefId();
};
		{
__int64 statementCount = Project.statementCount();
Program.statementIndex() = statementCount++;
Project.statementCount() = statementCount;
};
		{
string stateName = State.Name();
Program.filename() = stateName;
};
		outputAppender( currMatch.state_2e0d, newProgram_2e0f);
	}
}

void SetFileName_2dee::outputAppender( const CyberComposition::Simulink::State& state_2e10, const SFC::Program& program_2e12)
{
	_state_2df5->push_back( state_2e10);
	_program_2df6->push_back( program_2e12);
}

void ExecTransConnectorRecurse2_2e22::operator()( const Packets_t& states_2e23, const Packets_t& tcs_2e25, const Packets_t& fcns_2e27, const Packets_t& cgs_2e29)
{
#ifdef PRINT_INFO
	printLog( "ExecTransConnectorRecurse2_2e22" );
#endif
	for( Packets_t::const_iterator itstate_2e2c= states_2e23.begin(), ittc_2e33= tcs_2e25.begin(), itfcn_2e3a= fcns_2e27.begin(), itcg_2e41= cgs_2e29.begin(); itstate_2e2c!= states_2e23.end(), ittc_2e33!= tcs_2e25.end(), itfcn_2e3a!= fcns_2e27.end(), itcg_2e41!= cgs_2e29.end(); ++itstate_2e2c, ++ittc_2e33, ++itfcn_2e3a, ++itcg_2e41)
	{
		bool isUnique= isInputUnique( *itstate_2e2c, *ittc_2e33, *itfcn_2e3a, *itcg_2e41);
		if( !isUnique)
			continue;
		Packets_t onestate_2e30( 1, *itstate_2e2c);
		Packets_t onetc_2e37( 1, *ittc_2e33);
		Packets_t onefcn_2e3e( 1, *itfcn_2e3a);
		Packets_t onecg_2e45( 1, *itcg_2e41);
		executeOne( onestate_2e30, onetc_2e37, onefcn_2e3e, onecg_2e45);
	}
}

void ExecTransConnectorRecurse2_2e22::executeOne( const Packets_t& states_2e23, const Packets_t& tcs_2e25, const Packets_t& fcns_2e27, const Packets_t& cgs_2e29)
{
	if( ( !states_2e23.empty())&& ( !tcs_2e25.empty())&& ( !fcns_2e27.empty())&& ( !cgs_2e29.empty()))
		callProcessedFilter_374d( states_2e23, tcs_2e25, fcns_2e27, cgs_2e29);
}

bool ExecTransConnectorRecurse2_2e22::isInputUnique( const Udm::Object& state_2e2d, const Udm::Object& tc_2e34, const Udm::Object& fcn_2e3b, const Udm::Object& cg_2e42)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_2e2f= _state_2e2b.begin(), ittc_2e36= _tc_2e32.begin(), itfcn_2e3d= _fcn_2e39.begin(), itcg_2e44= _cg_2e40.begin(); itstate_2e2f!= _state_2e2b.end(), ittc_2e36!= _tc_2e32.end(), itfcn_2e3d!= _fcn_2e39.end(), itcg_2e44!= _cg_2e40.end(); ++itstate_2e2f, ++ittc_2e36, ++itfcn_2e3d, ++itcg_2e44)
	{
		if( ( *itstate_2e2f== state_2e2d)&& ( *ittc_2e36== tc_2e34)&& ( *itfcn_2e3d== fcn_2e3b)&& ( *itcg_2e44== cg_2e42))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_2e2b.push_back( state_2e2d);
		_tc_2e32.push_back( tc_2e34);
		_fcn_2e39.push_back( fcn_2e3b);
		_cg_2e40.push_back( cg_2e42);
	}
	return isUnique;
}

void ExecTransConnectorRecurse2_2e22::callProcessedFilter_374d( const Packets_t& states_368a, const Packets_t& tcs_368c, const Packets_t& fcns_368e, const Packets_t& cgs_3690)
{
	Packets_t states_3692;
	Packets_t tcs_3693;
	Packets_t fcns_3694;
	Packets_t cgs_3695;
	ProcessedFilter_3689 processedFilter_3689;
	processedFilter_3689( states_368a, tcs_368c, fcns_368e, cgs_3690, states_3692, tcs_3693, fcns_3694, cgs_3695);
	if( ( !states_3692.empty())&& ( !tcs_3693.empty())&& ( !fcns_3694.empty())&& ( !cgs_3695.empty()))
		callCreateTransitionCG_3752( states_3692, tcs_3693, fcns_3694, cgs_3695);
}

void ExecTransConnectorRecurse2_2e22::callCreateTransitionCG_3752( const Packets_t& sFStates_36fd, const Packets_t& sFTransConnectors_3700, const Packets_t& functions_3703, const Packets_t& tCVarCGs_3707)
{
	Packets_t sFStates_36ff;
	Packets_t sFTransConnectors_3702;
	Packets_t functions_3705;
	Packets_t transitionCGs_3706;
	CreateTransitionCG_36fc createTransitionCG_36fc;
	createTransitionCG_36fc( sFStates_36fd, sFTransConnectors_3700, functions_3703, tCVarCGs_3707, sFStates_36ff, sFTransConnectors_3702, functions_3705, transitionCGs_3706);
	if( ( !sFStates_36ff.empty())&& ( !sFTransConnectors_3702.empty())&& ( !functions_3705.empty())&& ( !transitionCGs_3706.empty()))
		callExecTransitions_3757( sFStates_36ff, sFTransConnectors_3702, functions_3705, transitionCGs_3706);
}

void ExecTransConnectorRecurse2_2e22::callExecTransitions_3757( const Packets_t& states_2fa2, const Packets_t& tcs_2fa4, const Packets_t& fcns_2fa6, const Packets_t& css_2fa8)
{
	Packets_t states_2faa;
	Packets_t tcs_2fab;
	Packets_t fcns_2fac;
	Packets_t css_2fad;
	ExecTransitions_2fa1 execTransitions_2fa1;
	execTransitions_2fa1( states_2fa2, tcs_2fa4, fcns_2fa6, css_2fa8, states_2faa, tcs_2fab, fcns_2fac, css_2fad);
	if( ( !states_2faa.empty())&& ( !tcs_2fab.empty())&& ( !fcns_2fac.empty())&& ( !css_2fad.empty()))
		callNoDefaultTransition_375c( states_2faa, tcs_2fab, fcns_2fac, css_2fad);
}

void ExecTransConnectorRecurse2_2e22::callNoDefaultTransition_375c( const Packets_t& states_2e48, const Packets_t& tcs_2e4a, const Packets_t& fcns_2e4c, const Packets_t& css_2e4e)
{
	NoDefaultTransition_2e47 noDefaultTransition_2e47;
	noDefaultTransition_2e47( states_2e48, tcs_2e4a, fcns_2e4c, css_2e4e);
}

void NoDefaultTransition_2e47::operator()( const Packets_t& states_2e48, const Packets_t& tcs_2e4a, const Packets_t& fcns_2e4c, const Packets_t& css_2e4e)
{
#ifdef PRINT_INFO
	printLog( "NoDefaultTransition_2e47" );
#endif
	if( ( !states_2e48.empty())&& ( !tcs_2e4a.empty())&& ( !fcns_2e4c.empty())&& ( !css_2e4e.empty()))
		callNDTTest_2f97( states_2e48, tcs_2e4a, fcns_2e4c, css_2e4e);
}

void NoDefaultTransition_2e47::callNDTTest_2f97( const Packets_t& states_2e96, const Packets_t& tcs_2e98, const Packets_t& fcns_2e9a, const Packets_t& css_2e9c)
{
	Packets_t states_2e9e;
	Packets_t tcs_2e9f;
	Packets_t fcns_2ea0;
	Packets_t css_2ea1;
	NDTTest_2e95 nDTTest_2e95;
	nDTTest_2e95( states_2e96, tcs_2e98, fcns_2e9a, css_2e9c, states_2e9e, tcs_2e9f, fcns_2ea0, css_2ea1);
	if( ( !states_2e9e.empty())&& ( !tcs_2e9f.empty())&& ( !fcns_2ea0.empty())&& ( !css_2ea1.empty()))
		callExitLoop_2f9c( states_2e9e, tcs_2e9f, fcns_2ea0, css_2ea1);
}

void NoDefaultTransition_2e47::callExitLoop_2f9c( const Packets_t& sFStates_2e51, const Packets_t& sFSrcTransConnectors_2e53, const Packets_t& functions_2e55, const Packets_t& compoundStatements_2e57)
{
	ExitLoop_2e50 exitLoop_2e50;
	exitLoop_2e50( sFStates_2e51, sFSrcTransConnectors_2e53, functions_2e55, compoundStatements_2e57);
}

void ExitLoop_2e50::operator()( const Packets_t& sFStates_2e51, const Packets_t& sFSrcTransConnectors_2e53, const Packets_t& functions_2e55, const Packets_t& compoundStatements_2e57)
{
#ifdef PRINT_INFO
	printLog( "ExitLoop_2e50" );
#endif
	RTTGenerator::Instance()->generateRule(2818, "ExitLoop");
	processInputPackets( sFStates_2e51, sFSrcTransConnectors_2e53, functions_2e55, compoundStatements_2e57);
}

bool ExitLoop_2e50::isInputUnique( const Udm::Object& sFState_2e5d, const Udm::Object& sFSrcTransConnector_2e66, const Udm::Object& function_2e6f, const Udm::Object& compoundStatement_2e78)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_2e5f= _sFState_2e59.begin(), itSFSrcTransConnector_2e68= _sFSrcTransConnector_2e62.begin(), itFunction_2e71= _function_2e6b.begin(), itCompoundStatement_2e7a= _compoundStatement_2e74.begin(); itSFState_2e5f!= _sFState_2e59.end(), itSFSrcTransConnector_2e68!= _sFSrcTransConnector_2e62.end(), itFunction_2e71!= _function_2e6b.end(), itCompoundStatement_2e7a!= _compoundStatement_2e74.end(); ++itSFState_2e5f, ++itSFSrcTransConnector_2e68, ++itFunction_2e71, ++itCompoundStatement_2e7a)
	{
		if( ( *itSFState_2e5f== sFState_2e5d)&& ( *itSFSrcTransConnector_2e68== sFSrcTransConnector_2e66)&& ( *itFunction_2e71== function_2e6f)&& ( *itCompoundStatement_2e7a== compoundStatement_2e78))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_2e59.push_back( sFState_2e5d);
		_sFSrcTransConnector_2e62.push_back( sFSrcTransConnector_2e66);
		_function_2e6b.push_back( function_2e6f);
		_compoundStatement_2e74.push_back( compoundStatement_2e78);
	}
	return isUnique;
}

bool ExitLoop_2e50::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool ExitLoop_2e50::isGuardTrue( SFC::CompoundStatement& CompoundStatement, SFC::Function& Function, CyberComposition::Simulink::SFTransConnector& SFSrcTransConnector, CyberComposition::Simulink::SFState& SFState, SFC::LocalVar& TCVar)
{
	bool Gz_guard= false;
	return static_cast< std::string >( TCVar.name() ) == "_TCVar_";;
	return Gz_guard;
}

void ExitLoop_2e50::processInputPackets( const Packets_t& sFStates_2e51, const Packets_t& sFSrcTransConnectors_2e53, const Packets_t& functions_2e55, const Packets_t& compoundStatements_2e57)
{
	for( Packets_t::const_iterator itSFState_2e5a= sFStates_2e51.begin(), itSFSrcTransConnector_2e63= sFSrcTransConnectors_2e53.begin(), itFunction_2e6c= functions_2e55.begin(), itCompoundStatement_2e75= compoundStatements_2e57.begin(); itSFState_2e5a!= sFStates_2e51.end(), itSFSrcTransConnector_2e63!= sFSrcTransConnectors_2e53.end(), itFunction_2e6c!= functions_2e55.end(), itCompoundStatement_2e75!= compoundStatements_2e57.end(); ++itSFState_2e5a, ++itSFSrcTransConnector_2e63, ++itFunction_2e6c, ++itCompoundStatement_2e75)
	{
		bool isUnique= isInputUnique( *itSFState_2e5a, *itSFSrcTransConnector_2e63, *itFunction_2e6c, *itCompoundStatement_2e75);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_2e5a, *itSFSrcTransConnector_2e63, *itFunction_2e6c, *itCompoundStatement_2e75);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ExitLoop_2e50::patternMatcher( const Udm::Object& sFState_2e5b, const Udm::Object& sFSrcTransConnector_2e64, const Udm::Object& function_2e6d, const Udm::Object& compoundStatement_2e76)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_2e5b.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_2e60= CyberComposition::Simulink::SFState::Cast( sFState_2e5b);
		if( false== Uml::IsDerivedFrom( sFSrcTransConnector_2e64.type(), CyberComposition::Simulink::SFTransConnector::meta))
			continue;
		CyberComposition::Simulink::SFTransConnector sFSrcTransConnector_2e69= CyberComposition::Simulink::SFTransConnector::Cast( sFSrcTransConnector_2e64);
		if( false== Uml::IsDerivedFrom( function_2e6d.type(), SFC::Function::meta))
			continue;
		SFC::Function function_2e72= SFC::Function::Cast( function_2e6d);
		if( false== Uml::IsDerivedFrom( compoundStatement_2e76.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_2e7b= SFC::CompoundStatement::Cast( compoundStatement_2e76);
		set< SFC::LocalVar> tCVars_2e7d= function_2e72.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itTCVar_2e7e= tCVars_2e7d.begin(); itTCVar_2e7e!= tCVars_2e7d.end(); ++itTCVar_2e7e)
		{
			SFC::LocalVar currTCVar_2e7f= *itTCVar_2e7e;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2e83;
			if( !isValidBound(boundObjs_2e83, sFState_2e60, true))
				continue;
			currMatch.sFState_2e84= sFState_2e60;
			if( !isValidBound(boundObjs_2e83, sFSrcTransConnector_2e69, true))
				continue;
			currMatch.sFSrcTransConnector_2e85= sFSrcTransConnector_2e69;
			if( !isValidBound(boundObjs_2e83, function_2e72, true))
				continue;
			currMatch.function_2e86= function_2e72;
			if( !isValidBound(boundObjs_2e83, compoundStatement_2e7b, true))
				continue;
			currMatch.compoundStatement_2e87= compoundStatement_2e7b;
			if( !isValidBound(boundObjs_2e83, currTCVar_2e7f, false))
				continue;
			currMatch.tCVar_2e88= currTCVar_2e7f;
			bool Gz_guard= isGuardTrue( currMatch.compoundStatement_2e87, currMatch.function_2e86, currMatch.sFSrcTransConnector_2e85, currMatch.sFState_2e84, currMatch.tCVar_2e88);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void ExitLoop_2e50::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_2e8e= SFC::ConditionalBlock::Create( currMatch.compoundStatement_2e87, SFC::CompoundStatement::meta_stmnt);
		SFC::UserCode newUserCode_2e8f= SFC::UserCode::Create( newConditionalBlock_2e8e, SFC::ConditionalBlock::meta_stmnt);
		SFC::BinaryExprs newAssign_2e90= SFC::BinaryExprs::Create( newUserCode_2e8f, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newArgDeclRef_2e91= SFC::ArgDeclRef::Create( newAssign_2e90, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newNegOne_2e92= SFC::Int::Create( newAssign_2e90, SFC::BinaryExprs::meta_rightexpr);
		SFC::UserCode newTrueCond_2e93= SFC::UserCode::Create( newConditionalBlock_2e8e, SFC::ConditionalBlock::meta_cond);
		SFC::Int newOne_2e94= SFC::Int::Create( newTrueCond_2e93, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_2e91;
		SFC::BinaryExprs& Assign= newAssign_2e90;
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_2e87;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_2e8e;
		SFC::Function& Function= currMatch.function_2e86;
		SFC::Int& NegOne= newNegOne_2e92;
		SFC::Int& One= newOne_2e94;
		CyberComposition::Simulink::SFTransConnector& SFSrcTransConnector= currMatch.sFSrcTransConnector_2e85;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_2e84;
		SFC::LocalVar& TCVar= currMatch.tCVar_2e88;
		SFC::UserCode& TrueCond= newTrueCond_2e93;
		SFC::UserCode& UserCode= newUserCode_2e8f;
		{
ConditionalBlock.RefId() = UserCode.RefId() = SFSrcTransConnector.RefId();
};
		{
Assign.op() = "=";
};
		{
__int64 statementCount = ConditionalBlock.statementCount();
UserCode.statementIndex() = statementCount++;
ConditionalBlock.statementCount() = statementCount;
};
		{
__int64 statementCount = CompoundStatement.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		{
One.val() = 1;
};
		{
NegOne.val() = -1;
};
		newArgDeclRef_2e91.argdecl()= currMatch.tCVar_2e88;
	}
}

void NDTTest_2e95::operator()( const Packets_t& states_2e96, const Packets_t& tcs_2e98, const Packets_t& fcns_2e9a, const Packets_t& css_2e9c, Packets_t& states_2e9e, Packets_t& tcs_2e9f, Packets_t& fcns_2ea0, Packets_t& css_2ea1)
{
#ifdef PRINT_INFO
	printLog( "NDTTest_2e95" );
#endif
	_state_2ea2= &states_2e9e;
	_tc_2ea3= &tcs_2e9f;
	_fcn_2ea4= &fcns_2ea0;
	_cs_2ea5= &css_2ea1;
	for( Packets_t::const_iterator itstate_2ea7= states_2e96.begin(), ittc_2eae= tcs_2e98.begin(), itfcn_2eb5= fcns_2e9a.begin(), itcs_2ebc= css_2e9c.begin(); itstate_2ea7!= states_2e96.end(), ittc_2eae!= tcs_2e98.end(), itfcn_2eb5!= fcns_2e9a.end(), itcs_2ebc!= css_2e9c.end(); ++itstate_2ea7, ++ittc_2eae, ++itfcn_2eb5, ++itcs_2ebc)
	{
		bool isUnique= isInputUnique( *itstate_2ea7, *ittc_2eae, *itfcn_2eb5, *itcs_2ebc);
		if( !isUnique)
			continue;
		Packets_t onestate_2eab( 1, *itstate_2ea7);
		Packets_t onetc_2eb2( 1, *ittc_2eae);
		Packets_t onefcn_2eb9( 1, *itfcn_2eb5);
		Packets_t onecs_2ec0( 1, *itcs_2ebc);
		executeOne( onestate_2eab, onetc_2eb2, onefcn_2eb9, onecs_2ec0);
	}
}

void NDTTest_2e95::executeOne( const Packets_t& states_2e96, const Packets_t& tcs_2e98, const Packets_t& fcns_2e9a, const Packets_t& css_2e9c)
{
	HasDefaultTransitionDouble_2ec2 hasDefaultTransitionDouble_2ec2;
	bool isMatchHasDefaultTransitionDouble_2ec2= hasDefaultTransitionDouble_2ec2( states_2e96, tcs_2e98, fcns_2e9a, css_2e9c);
	if( isMatchHasDefaultTransitionDouble_2ec2)
		return;
	HasDefaultTransitionInt_2f0a hasDefaultTransitionInt_2f0a;
	bool isMatchHasDefaultTransitionInt_2f0a= hasDefaultTransitionInt_2f0a( states_2e96, tcs_2e98, fcns_2e9a, css_2e9c);
	if( isMatchHasDefaultTransitionInt_2f0a)
		return;
	Packets_t sFStates_2f55;
	Packets_t sFTransConnectors_2f58;
	Packets_t functions_2f5b;
	Packets_t compoundStatements_2f5e;
	NoDefault_2f52 noDefault_2f52;
	bool isMatchNoDefault_2f52= noDefault_2f52( states_2e96, tcs_2e98, fcns_2e9a, css_2e9c, sFStates_2f55, sFTransConnectors_2f58, functions_2f5b, compoundStatements_2f5e);
	_state_2ea2->insert( _state_2ea2->end(), sFStates_2f55.begin(), sFStates_2f55.end());
	_tc_2ea3->insert( _tc_2ea3->end(), sFTransConnectors_2f58.begin(), sFTransConnectors_2f58.end());
	_fcn_2ea4->insert( _fcn_2ea4->end(), functions_2f5b.begin(), functions_2f5b.end());
	_cs_2ea5->insert( _cs_2ea5->end(), compoundStatements_2f5e.begin(), compoundStatements_2f5e.end());
	if( isMatchNoDefault_2f52)
		return;
}

bool NDTTest_2e95::isInputUnique( const Udm::Object& state_2ea8, const Udm::Object& tc_2eaf, const Udm::Object& fcn_2eb6, const Udm::Object& cs_2ebd)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_2eaa= _state_2ea6.begin(), ittc_2eb1= _tc_2ead.begin(), itfcn_2eb8= _fcn_2eb4.begin(), itcs_2ebf= _cs_2ebb.begin(); itstate_2eaa!= _state_2ea6.end(), ittc_2eb1!= _tc_2ead.end(), itfcn_2eb8!= _fcn_2eb4.end(), itcs_2ebf!= _cs_2ebb.end(); ++itstate_2eaa, ++ittc_2eb1, ++itfcn_2eb8, ++itcs_2ebf)
	{
		if( ( *itstate_2eaa== state_2ea8)&& ( *ittc_2eb1== tc_2eaf)&& ( *itfcn_2eb8== fcn_2eb6)&& ( *itcs_2ebf== cs_2ebd))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_2ea6.push_back( state_2ea8);
		_tc_2ead.push_back( tc_2eaf);
		_fcn_2eb4.push_back( fcn_2eb6);
		_cs_2ebb.push_back( cs_2ebd);
	}
	return isUnique;
}

bool HasDefaultTransitionDouble_2ec2::operator()( const Packets_t& sFStates_2ec3, const Packets_t& sFSrcTransConnectors_2ec5, const Packets_t& functions_2ec7, const Packets_t& compoundStatements_2ec9)
{
#ifdef PRINT_INFO
	printLog( "HasDefaultTransitionDouble_2ec2" );
#endif
	processInputPackets( sFStates_2ec3, sFSrcTransConnectors_2ec5, functions_2ec7, compoundStatements_2ec9);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasDefaultTransitionDouble_2ec2::isInputUnique( const Udm::Object& sFState_2ecf, const Udm::Object& sFSrcTransConnector_2ed8, const Udm::Object& function_2ee1, const Udm::Object& compoundStatement_2eea)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_2ed1= _sFState_2ecb.begin(), itSFSrcTransConnector_2eda= _sFSrcTransConnector_2ed4.begin(), itFunction_2ee3= _function_2edd.begin(), itCompoundStatement_2eec= _compoundStatement_2ee6.begin(); itSFState_2ed1!= _sFState_2ecb.end(), itSFSrcTransConnector_2eda!= _sFSrcTransConnector_2ed4.end(), itFunction_2ee3!= _function_2edd.end(), itCompoundStatement_2eec!= _compoundStatement_2ee6.end(); ++itSFState_2ed1, ++itSFSrcTransConnector_2eda, ++itFunction_2ee3, ++itCompoundStatement_2eec)
	{
		if( ( *itSFState_2ed1== sFState_2ecf)&& ( *itSFSrcTransConnector_2eda== sFSrcTransConnector_2ed8)&& ( *itFunction_2ee3== function_2ee1)&& ( *itCompoundStatement_2eec== compoundStatement_2eea))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_2ecb.push_back( sFState_2ecf);
		_sFSrcTransConnector_2ed4.push_back( sFSrcTransConnector_2ed8);
		_function_2edd.push_back( function_2ee1);
		_compoundStatement_2ee6.push_back( compoundStatement_2eea);
	}
	return isUnique;
}

bool HasDefaultTransitionDouble_2ec2::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool HasDefaultTransitionDouble_2ec2::isGuardTrue( SFC::CompoundStatement& CompoundStatement, SFC::ConditionalBlock& ConditionalBlock, SFC::Double& Double, SFC::Function& Function, CyberComposition::Simulink::SFTransConnector& SFSrcTransConnector, CyberComposition::Simulink::SFState& SFState, SFC::UserCode& UserCode)
{
	bool Gz_guard= false;
	return Double.val() == 1;;
	return Gz_guard;
}

void HasDefaultTransitionDouble_2ec2::processInputPackets( const Packets_t& sFStates_2ec3, const Packets_t& sFSrcTransConnectors_2ec5, const Packets_t& functions_2ec7, const Packets_t& compoundStatements_2ec9)
{
	for( Packets_t::const_iterator itSFState_2ecc= sFStates_2ec3.begin(), itSFSrcTransConnector_2ed5= sFSrcTransConnectors_2ec5.begin(), itFunction_2ede= functions_2ec7.begin(), itCompoundStatement_2ee7= compoundStatements_2ec9.begin(); itSFState_2ecc!= sFStates_2ec3.end(), itSFSrcTransConnector_2ed5!= sFSrcTransConnectors_2ec5.end(), itFunction_2ede!= functions_2ec7.end(), itCompoundStatement_2ee7!= compoundStatements_2ec9.end(); ++itSFState_2ecc, ++itSFSrcTransConnector_2ed5, ++itFunction_2ede, ++itCompoundStatement_2ee7)
	{
		bool isUnique= isInputUnique( *itSFState_2ecc, *itSFSrcTransConnector_2ed5, *itFunction_2ede, *itCompoundStatement_2ee7);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_2ecc, *itSFSrcTransConnector_2ed5, *itFunction_2ede, *itCompoundStatement_2ee7);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( );
	}
}

bool HasDefaultTransitionDouble_2ec2::patternMatcher( const Udm::Object& sFState_2ecd, const Udm::Object& sFSrcTransConnector_2ed6, const Udm::Object& function_2edf, const Udm::Object& compoundStatement_2ee8)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_2ecd.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_2ed2= CyberComposition::Simulink::SFState::Cast( sFState_2ecd);
		if( false== Uml::IsDerivedFrom( sFSrcTransConnector_2ed6.type(), CyberComposition::Simulink::SFTransConnector::meta))
			continue;
		CyberComposition::Simulink::SFTransConnector sFSrcTransConnector_2edb= CyberComposition::Simulink::SFTransConnector::Cast( sFSrcTransConnector_2ed6);
		if( false== Uml::IsDerivedFrom( function_2edf.type(), SFC::Function::meta))
			continue;
		SFC::Function function_2ee4= SFC::Function::Cast( function_2edf);
		if( false== Uml::IsDerivedFrom( compoundStatement_2ee8.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_2eed= SFC::CompoundStatement::Cast( compoundStatement_2ee8);
		set< SFC::ConditionalBlock> conditionalBlocks_2eef= compoundStatement_2eed.ConditionalBlock_kind_children();
		for( set< SFC::ConditionalBlock>::const_iterator itConditionalBlock_2ef0= conditionalBlocks_2eef.begin(); itConditionalBlock_2ef0!= conditionalBlocks_2eef.end(); ++itConditionalBlock_2ef0)
		{
			SFC::ConditionalBlock currConditionalBlock_2ef1= *itConditionalBlock_2ef0;
			set< SFC::UserCode> userCodes_2ef2= currConditionalBlock_2ef1.UserCode_kind_children();
			for( set< SFC::UserCode>::const_iterator itUserCode_2ef3= userCodes_2ef2.begin(); itUserCode_2ef3!= userCodes_2ef2.end(); ++itUserCode_2ef3)
			{
				SFC::UserCode currUserCode_2ef4= *itUserCode_2ef3;
				set< SFC::Double> doubles_2ef5= currUserCode_2ef4.Double_kind_children();
				for( set< SFC::Double>::const_iterator itDouble_2ef6= doubles_2ef5.begin(); itDouble_2ef6!= doubles_2ef5.end(); ++itDouble_2ef6)
				{
					SFC::Double currDouble_2ef7= *itDouble_2ef6;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_2efb;
					if( !isValidBound(boundObjs_2efb, sFState_2ed2, true))
						continue;
					currMatch.sFState_2efc= sFState_2ed2;
					if( !isValidBound(boundObjs_2efb, sFSrcTransConnector_2edb, true))
						continue;
					currMatch.sFSrcTransConnector_2efd= sFSrcTransConnector_2edb;
					if( !isValidBound(boundObjs_2efb, function_2ee4, true))
						continue;
					currMatch.function_2efe= function_2ee4;
					if( !isValidBound(boundObjs_2efb, compoundStatement_2eed, true))
						continue;
					currMatch.compoundStatement_2eff= compoundStatement_2eed;
					if( !isValidBound(boundObjs_2efb, currUserCode_2ef4, false))
						continue;
					currMatch.userCode_2f00= currUserCode_2ef4;
					if( !isValidBound(boundObjs_2efb, currDouble_2ef7, false))
						continue;
					currMatch.double_2f01= currDouble_2ef7;
					if( !isValidBound(boundObjs_2efb, currConditionalBlock_2ef1, false))
						continue;
					currMatch.conditionalBlock_2f02= currConditionalBlock_2ef1;
					bool Gz_guard= isGuardTrue( currMatch.compoundStatement_2eff, currMatch.conditionalBlock_2f02, currMatch.double_2f01, currMatch.function_2efe, currMatch.sFSrcTransConnector_2efd, currMatch.sFState_2efc, currMatch.userCode_2f00);
					if( true== Gz_guard)
						_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void HasDefaultTransitionDouble_2ec2::outputAppender()
{
}

bool HasDefaultTransitionInt_2f0a::operator()( const Packets_t& sFStates_2f0b, const Packets_t& sFSrcTransConnectors_2f0d, const Packets_t& functions_2f0f, const Packets_t& compoundStatements_2f11)
{
#ifdef PRINT_INFO
	printLog( "HasDefaultTransitionInt_2f0a" );
#endif
	processInputPackets( sFStates_2f0b, sFSrcTransConnectors_2f0d, functions_2f0f, compoundStatements_2f11);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasDefaultTransitionInt_2f0a::isInputUnique( const Udm::Object& sFState_2f17, const Udm::Object& sFSrcTransConnector_2f20, const Udm::Object& function_2f29, const Udm::Object& compoundStatement_2f32)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_2f19= _sFState_2f13.begin(), itSFSrcTransConnector_2f22= _sFSrcTransConnector_2f1c.begin(), itFunction_2f2b= _function_2f25.begin(), itCompoundStatement_2f34= _compoundStatement_2f2e.begin(); itSFState_2f19!= _sFState_2f13.end(), itSFSrcTransConnector_2f22!= _sFSrcTransConnector_2f1c.end(), itFunction_2f2b!= _function_2f25.end(), itCompoundStatement_2f34!= _compoundStatement_2f2e.end(); ++itSFState_2f19, ++itSFSrcTransConnector_2f22, ++itFunction_2f2b, ++itCompoundStatement_2f34)
	{
		if( ( *itSFState_2f19== sFState_2f17)&& ( *itSFSrcTransConnector_2f22== sFSrcTransConnector_2f20)&& ( *itFunction_2f2b== function_2f29)&& ( *itCompoundStatement_2f34== compoundStatement_2f32))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_2f13.push_back( sFState_2f17);
		_sFSrcTransConnector_2f1c.push_back( sFSrcTransConnector_2f20);
		_function_2f25.push_back( function_2f29);
		_compoundStatement_2f2e.push_back( compoundStatement_2f32);
	}
	return isUnique;
}

bool HasDefaultTransitionInt_2f0a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool HasDefaultTransitionInt_2f0a::isGuardTrue( SFC::CompoundStatement& CompoundStatement, SFC::ConditionalBlock& ConditionalBlock, SFC::Function& Function, SFC::Int& Int, CyberComposition::Simulink::SFTransConnector& SFSrcTransConnector, CyberComposition::Simulink::SFState& SFState, SFC::UserCode& UserCode)
{
	bool Gz_guard= false;
	return Int.val() == 1;;
	return Gz_guard;
}

void HasDefaultTransitionInt_2f0a::processInputPackets( const Packets_t& sFStates_2f0b, const Packets_t& sFSrcTransConnectors_2f0d, const Packets_t& functions_2f0f, const Packets_t& compoundStatements_2f11)
{
	for( Packets_t::const_iterator itSFState_2f14= sFStates_2f0b.begin(), itSFSrcTransConnector_2f1d= sFSrcTransConnectors_2f0d.begin(), itFunction_2f26= functions_2f0f.begin(), itCompoundStatement_2f2f= compoundStatements_2f11.begin(); itSFState_2f14!= sFStates_2f0b.end(), itSFSrcTransConnector_2f1d!= sFSrcTransConnectors_2f0d.end(), itFunction_2f26!= functions_2f0f.end(), itCompoundStatement_2f2f!= compoundStatements_2f11.end(); ++itSFState_2f14, ++itSFSrcTransConnector_2f1d, ++itFunction_2f26, ++itCompoundStatement_2f2f)
	{
		bool isUnique= isInputUnique( *itSFState_2f14, *itSFSrcTransConnector_2f1d, *itFunction_2f26, *itCompoundStatement_2f2f);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_2f14, *itSFSrcTransConnector_2f1d, *itFunction_2f26, *itCompoundStatement_2f2f);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( );
	}
}

bool HasDefaultTransitionInt_2f0a::patternMatcher( const Udm::Object& sFState_2f15, const Udm::Object& sFSrcTransConnector_2f1e, const Udm::Object& function_2f27, const Udm::Object& compoundStatement_2f30)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_2f15.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_2f1a= CyberComposition::Simulink::SFState::Cast( sFState_2f15);
		if( false== Uml::IsDerivedFrom( sFSrcTransConnector_2f1e.type(), CyberComposition::Simulink::SFTransConnector::meta))
			continue;
		CyberComposition::Simulink::SFTransConnector sFSrcTransConnector_2f23= CyberComposition::Simulink::SFTransConnector::Cast( sFSrcTransConnector_2f1e);
		if( false== Uml::IsDerivedFrom( function_2f27.type(), SFC::Function::meta))
			continue;
		SFC::Function function_2f2c= SFC::Function::Cast( function_2f27);
		if( false== Uml::IsDerivedFrom( compoundStatement_2f30.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_2f35= SFC::CompoundStatement::Cast( compoundStatement_2f30);
		set< SFC::ConditionalBlock> conditionalBlocks_2f37= compoundStatement_2f35.ConditionalBlock_kind_children();
		for( set< SFC::ConditionalBlock>::const_iterator itConditionalBlock_2f38= conditionalBlocks_2f37.begin(); itConditionalBlock_2f38!= conditionalBlocks_2f37.end(); ++itConditionalBlock_2f38)
		{
			SFC::ConditionalBlock currConditionalBlock_2f39= *itConditionalBlock_2f38;
			set< SFC::UserCode> userCodes_2f3a= currConditionalBlock_2f39.UserCode_kind_children();
			for( set< SFC::UserCode>::const_iterator itUserCode_2f3b= userCodes_2f3a.begin(); itUserCode_2f3b!= userCodes_2f3a.end(); ++itUserCode_2f3b)
			{
				SFC::UserCode currUserCode_2f3c= *itUserCode_2f3b;
				set< SFC::Int> ints_2f3d= currUserCode_2f3c.Int_kind_children();
				for( set< SFC::Int>::const_iterator itInt_2f3e= ints_2f3d.begin(); itInt_2f3e!= ints_2f3d.end(); ++itInt_2f3e)
				{
					SFC::Int currInt_2f3f= *itInt_2f3e;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_2f43;
					if( !isValidBound(boundObjs_2f43, sFState_2f1a, true))
						continue;
					currMatch.sFState_2f44= sFState_2f1a;
					if( !isValidBound(boundObjs_2f43, sFSrcTransConnector_2f23, true))
						continue;
					currMatch.sFSrcTransConnector_2f45= sFSrcTransConnector_2f23;
					if( !isValidBound(boundObjs_2f43, function_2f2c, true))
						continue;
					currMatch.function_2f46= function_2f2c;
					if( !isValidBound(boundObjs_2f43, compoundStatement_2f35, true))
						continue;
					currMatch.compoundStatement_2f47= compoundStatement_2f35;
					if( !isValidBound(boundObjs_2f43, currUserCode_2f3c, false))
						continue;
					currMatch.userCode_2f48= currUserCode_2f3c;
					if( !isValidBound(boundObjs_2f43, currInt_2f3f, false))
						continue;
					currMatch.int_2f49= currInt_2f3f;
					if( !isValidBound(boundObjs_2f43, currConditionalBlock_2f39, false))
						continue;
					currMatch.conditionalBlock_2f4a= currConditionalBlock_2f39;
					bool Gz_guard= isGuardTrue( currMatch.compoundStatement_2f47, currMatch.conditionalBlock_2f4a, currMatch.function_2f46, currMatch.int_2f49, currMatch.sFSrcTransConnector_2f45, currMatch.sFState_2f44, currMatch.userCode_2f48);
					if( true== Gz_guard)
						_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void HasDefaultTransitionInt_2f0a::outputAppender()
{
}

bool NoDefault_2f52::operator()( const Packets_t& sFStates_2f53, const Packets_t& sFTransConnectors_2f56, const Packets_t& functions_2f59, const Packets_t& compoundStatements_2f5c, Packets_t& sFStates_2f55, Packets_t& sFTransConnectors_2f58, Packets_t& functions_2f5b, Packets_t& compoundStatements_2f5e)
{
#ifdef PRINT_INFO
	printLog( "NoDefault_2f52" );
#endif
	_sFState_2f5f= &sFStates_2f55;
	_sFTransConnector_2f60= &sFTransConnectors_2f58;
	_function_2f61= &functions_2f5b;
	_compoundStatement_2f62= &compoundStatements_2f5e;
	processInputPackets( sFStates_2f53, sFTransConnectors_2f56, functions_2f59, compoundStatements_2f5c);
	if( false== _matches.empty())
		return true;
	return false;
}

bool NoDefault_2f52::isInputUnique( const Udm::Object& sFState_2f67, const Udm::Object& sFTransConnector_2f70, const Udm::Object& function_2f79, const Udm::Object& compoundStatement_2f82)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_2f69= _sFState_2f63.begin(), itSFTransConnector_2f72= _sFTransConnector_2f6c.begin(), itFunction_2f7b= _function_2f75.begin(), itCompoundStatement_2f84= _compoundStatement_2f7e.begin(); itSFState_2f69!= _sFState_2f63.end(), itSFTransConnector_2f72!= _sFTransConnector_2f6c.end(), itFunction_2f7b!= _function_2f75.end(), itCompoundStatement_2f84!= _compoundStatement_2f7e.end(); ++itSFState_2f69, ++itSFTransConnector_2f72, ++itFunction_2f7b, ++itCompoundStatement_2f84)
	{
		if( ( *itSFState_2f69== sFState_2f67)&& ( *itSFTransConnector_2f72== sFTransConnector_2f70)&& ( *itFunction_2f7b== function_2f79)&& ( *itCompoundStatement_2f84== compoundStatement_2f82))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_2f63.push_back( sFState_2f67);
		_sFTransConnector_2f6c.push_back( sFTransConnector_2f70);
		_function_2f75.push_back( function_2f79);
		_compoundStatement_2f7e.push_back( compoundStatement_2f82);
	}
	return isUnique;
}

bool NoDefault_2f52::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void NoDefault_2f52::processInputPackets( const Packets_t& sFStates_2f53, const Packets_t& sFTransConnectors_2f56, const Packets_t& functions_2f59, const Packets_t& compoundStatements_2f5c)
{
	for( Packets_t::const_iterator itSFState_2f64= sFStates_2f53.begin(), itSFTransConnector_2f6d= sFTransConnectors_2f56.begin(), itFunction_2f76= functions_2f59.begin(), itCompoundStatement_2f7f= compoundStatements_2f5c.begin(); itSFState_2f64!= sFStates_2f53.end(), itSFTransConnector_2f6d!= sFTransConnectors_2f56.end(), itFunction_2f76!= functions_2f59.end(), itCompoundStatement_2f7f!= compoundStatements_2f5c.end(); ++itSFState_2f64, ++itSFTransConnector_2f6d, ++itFunction_2f76, ++itCompoundStatement_2f7f)
	{
		bool isUnique= isInputUnique( *itSFState_2f64, *itSFTransConnector_2f6d, *itFunction_2f76, *itCompoundStatement_2f7f);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_2f64, *itSFTransConnector_2f6d, *itFunction_2f76, *itCompoundStatement_2f7f);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_2f8b, currMatch.sFTransConnector_2f8c, currMatch.function_2f8d, currMatch.compoundStatement_2f8e);
	}
}

bool NoDefault_2f52::patternMatcher( const Udm::Object& sFState_2f65, const Udm::Object& sFTransConnector_2f6e, const Udm::Object& function_2f77, const Udm::Object& compoundStatement_2f80)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_2f65.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_2f6a= CyberComposition::Simulink::SFState::Cast( sFState_2f65);
		if( false== Uml::IsDerivedFrom( sFTransConnector_2f6e.type(), CyberComposition::Simulink::SFTransConnector::meta))
			continue;
		CyberComposition::Simulink::SFTransConnector sFTransConnector_2f73= CyberComposition::Simulink::SFTransConnector::Cast( sFTransConnector_2f6e);
		if( false== Uml::IsDerivedFrom( function_2f77.type(), SFC::Function::meta))
			continue;
		SFC::Function function_2f7c= SFC::Function::Cast( function_2f77);
		if( false== Uml::IsDerivedFrom( compoundStatement_2f80.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_2f85= SFC::CompoundStatement::Cast( compoundStatement_2f80);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2f8a;
		if( !isValidBound(boundObjs_2f8a, sFState_2f6a, true))
			continue;
		currMatch.sFState_2f8b= sFState_2f6a;
		if( !isValidBound(boundObjs_2f8a, sFTransConnector_2f73, true))
			continue;
		currMatch.sFTransConnector_2f8c= sFTransConnector_2f73;
		if( !isValidBound(boundObjs_2f8a, function_2f7c, true))
			continue;
		currMatch.function_2f8d= function_2f7c;
		if( !isValidBound(boundObjs_2f8a, compoundStatement_2f85, true))
			continue;
		currMatch.compoundStatement_2f8e= compoundStatement_2f85;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void NoDefault_2f52::outputAppender( const CyberComposition::Simulink::SFState& sFState_2f8f, const CyberComposition::Simulink::SFTransConnector& sFTransConnector_2f91, const SFC::Function& function_2f93, const SFC::CompoundStatement& compoundStatement_2f95)
{
	_sFState_2f5f->push_back( sFState_2f8f);
	_sFTransConnector_2f60->push_back( sFTransConnector_2f91);
	_function_2f61->push_back( function_2f93);
	_compoundStatement_2f62->push_back( compoundStatement_2f95);
}

void ExecTransitions_2fa1::operator()( const Packets_t& states_2fa2, const Packets_t& tcs_2fa4, const Packets_t& fcns_2fa6, const Packets_t& css_2fa8, Packets_t& states_2faa, Packets_t& tcs_2fab, Packets_t& fcns_2fac, Packets_t& css_2fad)
{
#ifdef PRINT_INFO
	printLog( "ExecTransitions_2fa1" );
#endif
	_state_2fae= &states_2faa;
	_tc_2faf= &tcs_2fab;
	_fcn_2fb0= &fcns_2fac;
	_cs_2fb1= &css_2fad;
	_state_2fae->insert( _state_2fae->end(), states_2fa2.begin(), states_2fa2.end());
	_tc_2faf->insert( _tc_2faf->end(), tcs_2fa4.begin(), tcs_2fa4.end());
	_fcn_2fb0->insert( _fcn_2fb0->end(), fcns_2fa6.begin(), fcns_2fa6.end());
	_cs_2fb1->insert( _cs_2fb1->end(), css_2fa8.begin(), css_2fa8.end());
	if( ( !states_2fa2.empty())&& ( !tcs_2fa4.empty())&& ( !fcns_2fa6.empty())&& ( !css_2fa8.empty()))
		callGetAllTransitions_367f( states_2fa2, tcs_2fa4, fcns_2fa6, css_2fa8);
}

void ExecTransitions_2fa1::callGetAllTransitions_367f( const Packets_t& states_3575, const Packets_t& tcs_3577, const Packets_t& fcns_3579, const Packets_t& css_357b)
{
	Packets_t states_357d;
	Packets_t transs_357e;
	Packets_t fcns_357f;
	Packets_t css_3580;
	GetAllTransitions_3574 getAllTransitions_3574;
	getAllTransitions_3574( states_3575, tcs_3577, fcns_3579, css_357b, states_357d, transs_357e, fcns_357f, css_3580);
	if( ( !states_357d.empty())&& ( !transs_357e.empty())&& ( !fcns_357f.empty())&& ( !css_3580.empty()))
		callExecProcessTransitions_3684( states_357d, transs_357e, fcns_357f, css_3580);
}

void ExecTransitions_2fa1::callExecProcessTransitions_3684( const Packets_t& states_2fb3, const Packets_t& transs_2fb5, const Packets_t& fcns_2fb7, const Packets_t& css_2fb9)
{
	ExecProcessTransitions_2fb2 execProcessTransitions_2fb2;
	execProcessTransitions_2fb2( states_2fb3, transs_2fb5, fcns_2fb7, css_2fb9);
}

void ExecProcessTransitions_2fb2::operator()( const Packets_t& states_2fb3, const Packets_t& transs_2fb5, const Packets_t& fcns_2fb7, const Packets_t& css_2fb9)
{
#ifdef PRINT_INFO
	printLog( "ExecProcessTransitions_2fb2" );
#endif
	if( ( !states_2fb3.empty())&& ( !transs_2fb5.empty())&& ( !fcns_2fb7.empty())&& ( !css_2fb9.empty()))
		callOrderTransitions_353b( states_2fb3, transs_2fb5, fcns_2fb7, css_2fb9);
}

void ExecProcessTransitions_2fb2::callOrderTransitions_353b( const Packets_t& sFStates_3387, const Packets_t& sFTransitions_338a, const Packets_t& functions_338d, const Packets_t& compoundStatements_3390)
{
	Packets_t sFStates_3389;
	Packets_t sFTransitions_338c;
	Packets_t functions_338f;
	Packets_t compoundStatements_3392;
	OrderTransitions_3386 orderTransitions_3386;
	orderTransitions_3386( sFStates_3387, sFTransitions_338a, functions_338d, compoundStatements_3390, sFStates_3389, sFTransitions_338c, functions_338f, compoundStatements_3392);
	if( ( !sFStates_3389.empty())&& ( !sFTransitions_338c.empty())&& ( !functions_338f.empty())&& ( !compoundStatements_3392.empty()))
		callTransCond_3540( sFStates_3389, sFTransitions_338c, functions_338f, compoundStatements_3392);
}

void ExecProcessTransitions_2fb2::callTransCond_3540( const Packets_t& sFStates_3079, const Packets_t& sFTransitions_307d, const Packets_t& functions_3080, const Packets_t& transitionCGs_3083)
{
	Packets_t sFStates_307b;
	Packets_t sFDstTransConnectors_307c;
	Packets_t sFTransitions_307f;
	Packets_t functions_3082;
	Packets_t conditionalBlocks_3085;
	TransCond_3078 transCond_3078;
	transCond_3078( sFStates_3079, sFTransitions_307d, functions_3080, transitionCGs_3083, sFStates_307b, sFDstTransConnectors_307c, sFTransitions_307f, functions_3082, conditionalBlocks_3085);
	if( ( !sFStates_307b.empty())&& ( !sFDstTransConnectors_307c.empty())&& ( !sFTransitions_307f.empty())&& ( !functions_3082.empty())&& ( !conditionalBlocks_3085.empty()))
		callHighestTransParent_3545( sFStates_307b, sFDstTransConnectors_307c, sFTransitions_307f, functions_3082, conditionalBlocks_3085);
}

void ExecProcessTransitions_2fb2::callHighestTransParent_3545( const Packets_t& sFStates_2fbc, const Packets_t& sFDstTransConnectors_2fbf, const Packets_t& sFTransitions_2fc2, const Packets_t& functions_2fc5, const Packets_t& conditionalBlocks_2fc8)
{
	Packets_t sFStates_2fbe;
	Packets_t sFDstTransConnectors_2fc1;
	Packets_t sFTransitions_2fc4;
	Packets_t functions_2fc7;
	Packets_t conditionalBlocks_2fca;
	HighestTransParent_2fbb highestTransParent_2fbb;
	highestTransParent_2fbb( sFStates_2fbc, sFDstTransConnectors_2fbf, sFTransitions_2fc2, functions_2fc5, conditionalBlocks_2fc8, sFStates_2fbe, sFDstTransConnectors_2fc1, sFTransitions_2fc4, functions_2fc7, conditionalBlocks_2fca);
	if( ( !sFStates_2fbe.empty())&& ( !sFDstTransConnectors_2fc1.empty())&& ( !sFTransitions_2fc4.empty())&& ( !functions_2fc7.empty())&& ( !conditionalBlocks_2fca.empty()))
		callTest_354b( sFStates_2fbe, sFDstTransConnectors_2fc1, sFTransitions_2fc4, functions_2fc7, conditionalBlocks_2fca);
}

void ExecProcessTransitions_2fb2::callTest_354b( const Packets_t& states_30c4, const Packets_t& dsts_30c6, const Packets_t& transs_30c8, const Packets_t& fcns_30ca, const Packets_t& cbs_30cc)
{
	Packets_t states_30ce;
	Packets_t dsts_30cf;
	Packets_t transs_30d0;
	Packets_t fcns_30d1;
	Packets_t cbs_30d2;
	Packets_t states_30d3;
	Packets_t dsts_30d4;
	Packets_t transs_30d5;
	Packets_t fcns_30d6;
	Packets_t cbs_30d7;
	Packets_t states_30d8;
	Packets_t dsts_30d9;
	Packets_t transs_30da;
	Packets_t fcns_30db;
	Packets_t cbs_30dc;
	Packets_t states_30dd;
	Packets_t dsts_30de;
	Packets_t transs_30df;
	Packets_t fcns_30e0;
	Packets_t cbs_30e1;
	Packets_t states_30e2;
	Packets_t dsts_30e3;
	Packets_t transs_30e4;
	Packets_t fcns_30e5;
	Packets_t cbs_30e6;
	Test_30c3 test_30c3;
	test_30c3( states_30c4, dsts_30c6, transs_30c8, fcns_30ca, cbs_30cc, states_30ce, dsts_30cf, transs_30d0, fcns_30d1, cbs_30d2, states_30d3, dsts_30d4, transs_30d5, fcns_30d6, cbs_30d7, states_30d8, dsts_30d9, transs_30da, fcns_30db, cbs_30dc, states_30dd, dsts_30de, transs_30df, fcns_30e0, cbs_30e1, states_30e2, dsts_30e3, transs_30e4, fcns_30e5, cbs_30e6);
	if( ( !states_30e2.empty())&& ( !dsts_30e3.empty())&& ( !transs_30e4.empty())&& ( !fcns_30e5.empty())&& ( !cbs_30e6.empty()))
		callDeadEndJunction_3551( states_30e2, dsts_30e3, transs_30e4, fcns_30e5, cbs_30e6);
	if( ( !states_30d8.empty())&& ( !dsts_30d9.empty())&& ( !transs_30da.empty())&& ( !fcns_30db.empty())&& ( !cbs_30dc.empty()))
		callNextJunction_3557( states_30d8, dsts_30d9, transs_30da, fcns_30db, cbs_30dc);
	if( ( !states_30dd.empty())&& ( !dsts_30de.empty())&& ( !transs_30df.empty())&& ( !fcns_30e0.empty())&& ( !cbs_30e1.empty()))
		callGetDstJuncFromRef_355d( states_30dd, dsts_30de, transs_30df, fcns_30e0, cbs_30e1);
	if( ( !states_30ce.empty())&& ( !dsts_30cf.empty())&& ( !transs_30d0.empty())&& ( !fcns_30d1.empty())&& ( !cbs_30d2.empty()))
		callExecNextState_3563( states_30ce, dsts_30cf, transs_30d0, fcns_30d1, cbs_30d2);
	if( ( !states_30d3.empty())&& ( !dsts_30d4.empty())&& ( !transs_30d5.empty())&& ( !fcns_30d6.empty())&& ( !cbs_30d7.empty()))
		callGetDstStateFromRef_3569( states_30d3, dsts_30d4, transs_30d5, fcns_30d6, cbs_30d7);
}

void ExecProcessTransitions_2fb2::callDeadEndJunction_3551( const Packets_t& sFStates_33c9, const Packets_t& sFTransConnectors_33cb, const Packets_t& sFTransitions_33cd, const Packets_t& functions_33cf, const Packets_t& transitionCBs_33d1)
{
	DeadEndJunction_33c8 deadEndJunction_33c8;
	deadEndJunction_33c8( sFStates_33c9, sFTransConnectors_33cb, sFTransitions_33cd, functions_33cf, transitionCBs_33d1);
}

void ExecProcessTransitions_2fb2::callNextJunction_3557( const Packets_t& sFStates_3415, const Packets_t& sFJunctions_3418, const Packets_t& sFTransitions_341b, const Packets_t& functions_341d, const Packets_t& transitionCBs_3420)
{
	Packets_t sFStates_3417;
	Packets_t sFJunctions_341a;
	Packets_t functions_341f;
	Packets_t conditionalGroups_3422;
	NextJunction_3414 nextJunction_3414;
	nextJunction_3414( sFStates_3415, sFJunctions_3418, sFTransitions_341b, functions_341d, transitionCBs_3420, sFStates_3417, sFJunctions_341a, functions_341f, conditionalGroups_3422);
	if( ( !sFStates_3417.empty())&& ( !sFJunctions_341a.empty())&& ( !functions_341f.empty())&& ( !conditionalGroups_3422.empty()))
		callExecTransConnectorRecurse_356f( sFStates_3417, sFJunctions_341a, functions_341f, conditionalGroups_3422);
}

void ExecProcessTransitions_2fb2::callGetDstJuncFromRef_355d( const Packets_t& sFStates_3024, const Packets_t& sFConnectorRefs_3027, const Packets_t& sFTransitions_302a, const Packets_t& functions_302d, const Packets_t& conditionalBlocks_3030)
{
	Packets_t sFStates_3026;
	Packets_t sFJunctions_3029;
	Packets_t sFTransitions_302c;
	Packets_t functions_302f;
	Packets_t conditionalBlocks_3032;
	GetDstJuncFromRef_3023 getDstJuncFromRef_3023;
	getDstJuncFromRef_3023( sFStates_3024, sFConnectorRefs_3027, sFTransitions_302a, functions_302d, conditionalBlocks_3030, sFStates_3026, sFJunctions_3029, sFTransitions_302c, functions_302f, conditionalBlocks_3032);
	if( ( !sFStates_3026.empty())&& ( !sFJunctions_3029.empty())&& ( !sFTransitions_302c.empty())&& ( !functions_302f.empty())&& ( !conditionalBlocks_3032.empty()))
		callNextJunction_3557( sFStates_3026, sFJunctions_3029, sFTransitions_302c, functions_302f, conditionalBlocks_3032);
}

void ExecProcessTransitions_2fb2::callExecNextState_3563( const Packets_t& sFStates_34d2, const Packets_t& sFDstStates_34d4, const Packets_t& sFTransitions_34d6, const Packets_t& functions_34d8, const Packets_t& transitionCBs_34da)
{
	ExecNextState_34d1 execNextState_34d1;
	execNextState_34d1( sFStates_34d2, sFDstStates_34d4, sFTransitions_34d6, functions_34d8, transitionCBs_34da);
}

void ExecProcessTransitions_2fb2::callGetDstStateFromRef_3569( const Packets_t& sFStates_347d, const Packets_t& sFConnectorRefs_3481, const Packets_t& sFTransitions_3483, const Packets_t& functions_3486, const Packets_t& conditionalBlocks_3489)
{
	Packets_t sFStates_347f;
	Packets_t sFDstStates_3480;
	Packets_t sFTransitions_3485;
	Packets_t functions_3488;
	Packets_t conditionalBlocks_348b;
	GetDstStateFromRef_347c getDstStateFromRef_347c;
	getDstStateFromRef_347c( sFStates_347d, sFConnectorRefs_3481, sFTransitions_3483, functions_3486, conditionalBlocks_3489, sFStates_347f, sFDstStates_3480, sFTransitions_3485, functions_3488, conditionalBlocks_348b);
	if( ( !sFStates_347f.empty())&& ( !sFDstStates_3480.empty())&& ( !sFTransitions_3485.empty())&& ( !functions_3488.empty())&& ( !conditionalBlocks_348b.empty()))
		callExecNextState_3563( sFStates_347f, sFDstStates_3480, sFTransitions_3485, functions_3488, conditionalBlocks_348b);
}

void ExecProcessTransitions_2fb2::callExecTransConnectorRecurse_356f( const Packets_t& states_2e23, const Packets_t& tcs_2e25, const Packets_t& fcns_2e27, const Packets_t& cgs_2e29)
{
	ExecTransConnectorRecurse2_2e22 execTransConnectorRecurse2_2e22;
	execTransConnectorRecurse2_2e22( states_2e23, tcs_2e25, fcns_2e27, cgs_2e29);
}

void HighestTransParent_2fbb::operator()( const Packets_t& sFStates_2fbc, const Packets_t& sFDstTransConnectors_2fbf, const Packets_t& sFTransitions_2fc2, const Packets_t& functions_2fc5, const Packets_t& conditionalBlocks_2fc8, Packets_t& sFStates_2fbe, Packets_t& sFDstTransConnectors_2fc1, Packets_t& sFTransitions_2fc4, Packets_t& functions_2fc7, Packets_t& conditionalBlocks_2fca)
{
#ifdef PRINT_INFO
	printLog( "HighestTransParent_2fbb" );
#endif
	RTTGenerator::Instance()->generateRule(2896, "HighestTransParent");
	_sFState_2fcb= &sFStates_2fbe;
	_sFDstTransConnector_2fcc= &sFDstTransConnectors_2fc1;
	_sFTransition_2fcd= &sFTransitions_2fc4;
	_function_2fce= &functions_2fc7;
	_conditionalBlock_2fcf= &conditionalBlocks_2fca;
	processInputPackets( sFStates_2fbc, sFDstTransConnectors_2fbf, sFTransitions_2fc2, functions_2fc5, conditionalBlocks_2fc8);
	forwardInputs( );
}

bool HighestTransParent_2fbb::isInputUnique( const Udm::Object& sFState_2fd4, const Udm::Object& sFDstTransConnector_2fdd, const Udm::Object& sFTransition_2fe6, const Udm::Object& function_2fef, const Udm::Object& conditionalBlock_2ff8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_2fd6= _sFState_2fd0.begin(), itSFDstTransConnector_2fdf= _sFDstTransConnector_2fd9.begin(), itSFTransition_2fe8= _sFTransition_2fe2.begin(), itFunction_2ff1= _function_2feb.begin(), itConditionalBlock_2ffa= _conditionalBlock_2ff4.begin(); itSFState_2fd6!= _sFState_2fd0.end(), itSFDstTransConnector_2fdf!= _sFDstTransConnector_2fd9.end(), itSFTransition_2fe8!= _sFTransition_2fe2.end(), itFunction_2ff1!= _function_2feb.end(), itConditionalBlock_2ffa!= _conditionalBlock_2ff4.end(); ++itSFState_2fd6, ++itSFDstTransConnector_2fdf, ++itSFTransition_2fe8, ++itFunction_2ff1, ++itConditionalBlock_2ffa)
	{
		if( ( *itSFState_2fd6== sFState_2fd4)&& ( *itSFDstTransConnector_2fdf== sFDstTransConnector_2fdd)&& ( *itSFTransition_2fe8== sFTransition_2fe6)&& ( *itFunction_2ff1== function_2fef)&& ( *itConditionalBlock_2ffa== conditionalBlock_2ff8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_2fd0.push_back( sFState_2fd4);
		_sFDstTransConnector_2fd9.push_back( sFDstTransConnector_2fdd);
		_sFTransition_2fe2.push_back( sFTransition_2fe6);
		_function_2feb.push_back( function_2fef);
		_conditionalBlock_2ff4.push_back( conditionalBlock_2ff8);
	}
	return isUnique;
}

bool HighestTransParent_2fbb::isGuardTrue( SFC::ConditionalBlock& ConditionalBlock, SFC::Function& Function, SFC::LocalVar& HTPVar, CyberComposition::Simulink::SFTransConnector& SFDstTransConnector, CyberComposition::Simulink::SFState& SFState, CyberComposition::Simulink::SFTransition& SFTransition, CyberComposition::Simulink::SFState& SFTransitionParentState, SFC::StateLabel& StateLabel)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( HTPVar.name() ) == "_HTPVar_";;
	return Gz_guard;
}

void HighestTransParent_2fbb::processInputPackets( const Packets_t& sFStates_2fbc, const Packets_t& sFDstTransConnectors_2fbf, const Packets_t& sFTransitions_2fc2, const Packets_t& functions_2fc5, const Packets_t& conditionalBlocks_2fc8)
{
	for( Packets_t::const_iterator itSFState_2fd1= sFStates_2fbc.begin(), itSFDstTransConnector_2fda= sFDstTransConnectors_2fbf.begin(), itSFTransition_2fe3= sFTransitions_2fc2.begin(), itFunction_2fec= functions_2fc5.begin(), itConditionalBlock_2ff5= conditionalBlocks_2fc8.begin(); itSFState_2fd1!= sFStates_2fbc.end(), itSFDstTransConnector_2fda!= sFDstTransConnectors_2fbf.end(), itSFTransition_2fe3!= sFTransitions_2fc2.end(), itFunction_2fec!= functions_2fc5.end(), itConditionalBlock_2ff5!= conditionalBlocks_2fc8.end(); ++itSFState_2fd1, ++itSFDstTransConnector_2fda, ++itSFTransition_2fe3, ++itFunction_2fec, ++itConditionalBlock_2ff5)
	{
		bool isUnique= isInputUnique( *itSFState_2fd1, *itSFDstTransConnector_2fda, *itSFTransition_2fe3, *itFunction_2fec, *itConditionalBlock_2ff5);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_2fd1, *itSFDstTransConnector_2fda, *itSFTransition_2fe3, *itFunction_2fec, *itConditionalBlock_2ff5);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool HighestTransParent_2fbb::patternMatcher( const Udm::Object& sFState_2fd2, const Udm::Object& sFDstTransConnector_2fdb, const Udm::Object& sFTransition_2fe4, const Udm::Object& function_2fed, const Udm::Object& conditionalBlock_2ff6)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_2fd2.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_2fd7= CyberComposition::Simulink::SFState::Cast( sFState_2fd2);
		if( false== Uml::IsDerivedFrom( sFDstTransConnector_2fdb.type(), CyberComposition::Simulink::SFTransConnector::meta))
			continue;
		CyberComposition::Simulink::SFTransConnector sFDstTransConnector_2fe0= CyberComposition::Simulink::SFTransConnector::Cast( sFDstTransConnector_2fdb);
		if( false== Uml::IsDerivedFrom( sFTransition_2fe4.type(), CyberComposition::Simulink::SFTransition::meta))
			continue;
		CyberComposition::Simulink::SFTransition sFTransition_2fe9= CyberComposition::Simulink::SFTransition::Cast( sFTransition_2fe4);
		if( false== Uml::IsDerivedFrom( function_2fed.type(), SFC::Function::meta))
			continue;
		SFC::Function function_2ff2= SFC::Function::Cast( function_2fed);
		if( false== Uml::IsDerivedFrom( conditionalBlock_2ff6.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlock_2ffb= SFC::ConditionalBlock::Cast( conditionalBlock_2ff6);
		set< SFC::LocalVar> hTPVars_2ffd= function_2ff2.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itHTPVar_2ffe= hTPVars_2ffd.begin(); itHTPVar_2ffe!= hTPVars_2ffd.end(); ++itHTPVar_2ffe)
		{
			SFC::LocalVar currHTPVar_2fff= *itHTPVar_2ffe;
			Udm::Object sFTransitionParent_3000= sFTransition_2fe9.container();
			if( false== Uml::IsDerivedFrom( sFTransitionParent_3000.type(), CyberComposition::Simulink::SFState::meta))
				continue;
			CyberComposition::Simulink::SFState sFTransitionParentStateSFTransition_3001= CyberComposition::Simulink::SFState::Cast( sFTransitionParent_3000);
			set< SFC::StateLabel> stateLabels_3002= sFTransitionParentStateSFTransition_3001.src();
			for( set< SFC::StateLabel>::const_iterator itStateLabels_3003= stateLabels_3002.begin(); itStateLabels_3003!= stateLabels_3002.end(); ++itStateLabels_3003)
			{
				SFC::StateLabel currStateLabel_3004= *itStateLabels_3003;
				Match currMatch;
				currMatch.sFState_3006= sFState_2fd7;
				currMatch.sFDstTransConnector_3007= sFDstTransConnector_2fe0;
				currMatch.sFTransition_3008= sFTransition_2fe9;
				currMatch.function_3009= function_2ff2;
				currMatch.conditionalBlock_300a= conditionalBlock_2ffb;
				currMatch.sFTransitionParentState_300b= sFTransitionParentStateSFTransition_3001;
				currMatch.stateLabel_300c= currStateLabel_3004;
				currMatch.hTPVar_300d= currHTPVar_2fff;
				bool Gz_guard= isGuardTrue( currMatch.conditionalBlock_300a, currMatch.function_3009, currMatch.hTPVar_300d, currMatch.sFDstTransConnector_3007, currMatch.sFState_3006, currMatch.sFTransition_3008, currMatch.sFTransitionParentState_300b, currMatch.stateLabel_300c);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void HighestTransParent_2fbb::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newHighestTransitionCB_3016= SFC::ConditionalBlock::Create( currMatch.conditionalBlock_300a, SFC::ConditionalBlock::meta_stmnt);
		SFC::UserCode newTakeMin_3017= SFC::UserCode::Create( newHighestTransitionCB_3016, SFC::ConditionalBlock::meta_stmnt);
		SFC::BinaryExprs newAssign_3018= SFC::BinaryExprs::Create( newTakeMin_3017, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newSLArgDeclRef2_3019= SFC::ArgDeclRef::Create( newAssign_3018, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newHTPArgDeclRef2_301a= SFC::ArgDeclRef::Create( newAssign_3018, SFC::BinaryExprs::meta_leftexpr);
		SFC::UserCode newTestMin_301b= SFC::UserCode::Create( newHighestTransitionCB_3016, SFC::ConditionalBlock::meta_cond);
		SFC::BinaryExprs newLessThan_301c= SFC::BinaryExprs::Create( newTestMin_301b, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newLBitAnd_301d= SFC::BinaryExprs::Create( newLessThan_301c, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newRBitAnd_301e= SFC::BinaryExprs::Create( newLessThan_301c, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newRInt_301f= SFC::Int::Create( newRBitAnd_301e, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newHTPArgDeclRef1_3020= SFC::ArgDeclRef::Create( newRBitAnd_301e, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newSLArgDeclRef1_3021= SFC::ArgDeclRef::Create( newLBitAnd_301d, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newLInt_3022= SFC::Int::Create( newLBitAnd_301d, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs& Assign= newAssign_3018;
		SFC::ConditionalBlock& ConditionalBlock= currMatch.conditionalBlock_300a;
		SFC::Function& Function= currMatch.function_3009;
		SFC::ArgDeclRef& HTPArgDeclRef1= newHTPArgDeclRef1_3020;
		SFC::ArgDeclRef& HTPArgDeclRef2= newHTPArgDeclRef2_301a;
		SFC::LocalVar& HTPVar= currMatch.hTPVar_300d;
		SFC::ConditionalBlock& HighestTransitionCB= newHighestTransitionCB_3016;
		SFC::BinaryExprs& LBitAnd= newLBitAnd_301d;
		SFC::Int& LInt= newLInt_3022;
		SFC::BinaryExprs& LessThan= newLessThan_301c;
		SFC::BinaryExprs& RBitAnd= newRBitAnd_301e;
		SFC::Int& RInt= newRInt_301f;
		CyberComposition::Simulink::SFTransConnector& SFDstTransConnector= currMatch.sFDstTransConnector_3007;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_3006;
		CyberComposition::Simulink::SFTransition& SFTransition= currMatch.sFTransition_3008;
		CyberComposition::Simulink::SFState& SFTransitionParentState= currMatch.sFTransitionParentState_300b;
		SFC::ArgDeclRef& SLArgDeclRef1= newSLArgDeclRef1_3021;
		SFC::ArgDeclRef& SLArgDeclRef2= newSLArgDeclRef2_3019;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_300c;
		SFC::UserCode& TakeMin= newTakeMin_3017;
		SFC::UserCode& TestMin= newTestMin_301b;
		{
HighestTransitionCB.RefId() = TestMin.RefId() = TakeMin.RefId() = ConditionalBlock.RefId();
};
		{
__int64 statementCount = ConditionalBlock.statementCount();
HighestTransitionCB.statementIndex() = statementCount++;
ConditionalBlock.statementCount() = statementCount;

};
		{
RBitAnd.op() = "&";
};
		{
LInt.val() = 0xFFFF;
};
		{
LessThan.op() = "<";
};
		{
RInt.val() = 0xFFFF;
};
		{
Assign.op() = "=";
};
		{
LBitAnd.op() = "&";
};
		{
__int64 statementCount = HighestTransitionCB.statementCount();
TakeMin.statementIndex() = statementCount++;
HighestTransitionCB.statementCount() = statementCount;
};
		newSLArgDeclRef2_3019.argdecl()= currMatch.stateLabel_300c;
		newHTPArgDeclRef2_301a.argdecl()= currMatch.hTPVar_300d;
		newSLArgDeclRef1_3021.argdecl()= currMatch.stateLabel_300c;
		newHTPArgDeclRef1_3020.argdecl()= currMatch.hTPVar_300d;
	}
}

void HighestTransParent_2fbb::forwardInputs()
{
	*_sFState_2fcb= _sFState_2fd0;
	*_sFDstTransConnector_2fcc= _sFDstTransConnector_2fd9;
	*_sFTransition_2fcd= _sFTransition_2fe2;
	*_function_2fce= _function_2feb;
	*_conditionalBlock_2fcf= _conditionalBlock_2ff4;
}

void GetDstJuncFromRef_3023::operator()( const Packets_t& sFStates_3024, const Packets_t& sFConnectorRefs_3027, const Packets_t& sFTransitions_302a, const Packets_t& functions_302d, const Packets_t& conditionalBlocks_3030, Packets_t& sFStates_3026, Packets_t& sFJunctions_3029, Packets_t& sFTransitions_302c, Packets_t& functions_302f, Packets_t& conditionalBlocks_3032)
{
#ifdef PRINT_INFO
	printLog( "GetDstJuncFromRef_3023" );
#endif
	RTTGenerator::Instance()->generateRule(2947, "GetDstJuncFromRef");
	_sFState_3033= &sFStates_3026;
	_sFJunction_3034= &sFJunctions_3029;
	_sFTransition_3035= &sFTransitions_302c;
	_function_3036= &functions_302f;
	_conditionalBlock_3037= &conditionalBlocks_3032;
	processInputPackets( sFStates_3024, sFConnectorRefs_3027, sFTransitions_302a, functions_302d, conditionalBlocks_3030);
}

bool GetDstJuncFromRef_3023::isInputUnique( const Udm::Object& sFState_303c, const Udm::Object& sFConnectorRef_3045, const Udm::Object& sFTransition_304e, const Udm::Object& function_3057, const Udm::Object& conditionalBlock_3060)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_303e= _sFState_3038.begin(), itSFConnectorRef_3047= _sFConnectorRef_3041.begin(), itSFTransition_3050= _sFTransition_304a.begin(), itFunction_3059= _function_3053.begin(), itConditionalBlock_3062= _conditionalBlock_305c.begin(); itSFState_303e!= _sFState_3038.end(), itSFConnectorRef_3047!= _sFConnectorRef_3041.end(), itSFTransition_3050!= _sFTransition_304a.end(), itFunction_3059!= _function_3053.end(), itConditionalBlock_3062!= _conditionalBlock_305c.end(); ++itSFState_303e, ++itSFConnectorRef_3047, ++itSFTransition_3050, ++itFunction_3059, ++itConditionalBlock_3062)
	{
		if( ( *itSFState_303e== sFState_303c)&& ( *itSFConnectorRef_3047== sFConnectorRef_3045)&& ( *itSFTransition_3050== sFTransition_304e)&& ( *itFunction_3059== function_3057)&& ( *itConditionalBlock_3062== conditionalBlock_3060))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_3038.push_back( sFState_303c);
		_sFConnectorRef_3041.push_back( sFConnectorRef_3045);
		_sFTransition_304a.push_back( sFTransition_304e);
		_function_3053.push_back( function_3057);
		_conditionalBlock_305c.push_back( conditionalBlock_3060);
	}
	return isUnique;
}

void GetDstJuncFromRef_3023::processInputPackets( const Packets_t& sFStates_3024, const Packets_t& sFConnectorRefs_3027, const Packets_t& sFTransitions_302a, const Packets_t& functions_302d, const Packets_t& conditionalBlocks_3030)
{
	for( Packets_t::const_iterator itSFState_3039= sFStates_3024.begin(), itSFConnectorRef_3042= sFConnectorRefs_3027.begin(), itSFTransition_304b= sFTransitions_302a.begin(), itFunction_3054= functions_302d.begin(), itConditionalBlock_305d= conditionalBlocks_3030.begin(); itSFState_3039!= sFStates_3024.end(), itSFConnectorRef_3042!= sFConnectorRefs_3027.end(), itSFTransition_304b!= sFTransitions_302a.end(), itFunction_3054!= functions_302d.end(), itConditionalBlock_305d!= conditionalBlocks_3030.end(); ++itSFState_3039, ++itSFConnectorRef_3042, ++itSFTransition_304b, ++itFunction_3054, ++itConditionalBlock_305d)
	{
		bool isUnique= isInputUnique( *itSFState_3039, *itSFConnectorRef_3042, *itSFTransition_304b, *itFunction_3054, *itConditionalBlock_305d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_3039, *itSFConnectorRef_3042, *itSFTransition_304b, *itFunction_3054, *itConditionalBlock_305d);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetDstJuncFromRef_3023::patternMatcher( const Udm::Object& sFState_303a, const Udm::Object& sFConnectorRef_3043, const Udm::Object& sFTransition_304c, const Udm::Object& function_3055, const Udm::Object& conditionalBlock_305e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_303a.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_303f= CyberComposition::Simulink::SFState::Cast( sFState_303a);
		if( false== Uml::IsDerivedFrom( sFConnectorRef_3043.type(), CyberComposition::Simulink::SFConnectorRef::meta))
			continue;
		CyberComposition::Simulink::SFConnectorRef sFConnectorRef_3048= CyberComposition::Simulink::SFConnectorRef::Cast( sFConnectorRef_3043);
		if( false== Uml::IsDerivedFrom( sFTransition_304c.type(), CyberComposition::Simulink::SFTransition::meta))
			continue;
		CyberComposition::Simulink::SFTransition sFTransition_3051= CyberComposition::Simulink::SFTransition::Cast( sFTransition_304c);
		if( false== Uml::IsDerivedFrom( function_3055.type(), SFC::Function::meta))
			continue;
		SFC::Function function_305a= SFC::Function::Cast( function_3055);
		if( false== Uml::IsDerivedFrom( conditionalBlock_305e.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlock_3063= SFC::ConditionalBlock::Cast( conditionalBlock_305e);
		CyberComposition::Simulink::SFTransConnector sFJunction_3065= sFConnectorRef_3048.ref();
		if( false== Uml::IsDerivedFrom( sFJunction_3065.type(), CyberComposition::Simulink::SFJunction::meta))
			continue;
		CyberComposition::Simulink::SFJunction sFJunction_3066= CyberComposition::Simulink::SFJunction::Cast( sFJunction_3065);
		if( !sFJunction_3066)
			continue;
		Match currMatch;
		currMatch.sFState_3068= sFState_303f;
		currMatch.sFConnectorRef_3069= sFConnectorRef_3048;
		currMatch.sFTransition_306a= sFTransition_3051;
		currMatch.function_306b= function_305a;
		currMatch.conditionalBlock_306c= conditionalBlock_3063;
		currMatch.sFJunction_306d= sFJunction_3066;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void GetDstJuncFromRef_3023::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_3068, currMatch.sFJunction_306d, currMatch.sFTransition_306a, currMatch.function_306b, currMatch.conditionalBlock_306c);
	}
}

void GetDstJuncFromRef_3023::outputAppender( const CyberComposition::Simulink::SFState& sFState_306e, const CyberComposition::Simulink::SFJunction& sFJunction_3070, const CyberComposition::Simulink::SFTransition& sFTransition_3072, const SFC::Function& function_3074, const SFC::ConditionalBlock& conditionalBlock_3076)
{
	_sFState_3033->push_back( sFState_306e);
	_sFJunction_3034->push_back( sFJunction_3070);
	_sFTransition_3035->push_back( sFTransition_3072);
	_function_3036->push_back( function_3074);
	_conditionalBlock_3037->push_back( conditionalBlock_3076);
}

void TransCond_3078::operator()( const Packets_t& sFStates_3079, const Packets_t& sFTransitions_307d, const Packets_t& functions_3080, const Packets_t& transitionCGs_3083, Packets_t& sFStates_307b, Packets_t& sFDstTransConnectors_307c, Packets_t& sFTransitions_307f, Packets_t& functions_3082, Packets_t& conditionalBlocks_3085)
{
#ifdef PRINT_INFO
	printLog( "TransCond_3078" );
#endif
	RTTGenerator::Instance()->generateRule(2955, "TransCond");
	_sFState_3086= &sFStates_307b;
	_sFDstTransConnector_3087= &sFDstTransConnectors_307c;
	_sFTransition_3088= &sFTransitions_307f;
	_function_3089= &functions_3082;
	_conditionalBlock_308a= &conditionalBlocks_3085;
	processInputPackets( sFStates_3079, sFTransitions_307d, functions_3080, transitionCGs_3083);
}

bool TransCond_3078::isInputUnique( const Udm::Object& sFState_308f, const Udm::Object& sFTransition_3098, const Udm::Object& function_30a1, const Udm::Object& transitionCG_30aa)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_3091= _sFState_308b.begin(), itSFTransition_309a= _sFTransition_3094.begin(), itFunction_30a3= _function_309d.begin(), itTransitionCG_30ac= _transitionCG_30a6.begin(); itSFState_3091!= _sFState_308b.end(), itSFTransition_309a!= _sFTransition_3094.end(), itFunction_30a3!= _function_309d.end(), itTransitionCG_30ac!= _transitionCG_30a6.end(); ++itSFState_3091, ++itSFTransition_309a, ++itFunction_30a3, ++itTransitionCG_30ac)
	{
		if( ( *itSFState_3091== sFState_308f)&& ( *itSFTransition_309a== sFTransition_3098)&& ( *itFunction_30a3== function_30a1)&& ( *itTransitionCG_30ac== transitionCG_30aa))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_308b.push_back( sFState_308f);
		_sFTransition_3094.push_back( sFTransition_3098);
		_function_309d.push_back( function_30a1);
		_transitionCG_30a6.push_back( transitionCG_30aa);
	}
	return isUnique;
}

void TransCond_3078::processInputPackets( const Packets_t& sFStates_3079, const Packets_t& sFTransitions_307d, const Packets_t& functions_3080, const Packets_t& transitionCGs_3083)
{
	for( Packets_t::const_iterator itSFState_308c= sFStates_3079.begin(), itSFTransition_3095= sFTransitions_307d.begin(), itFunction_309e= functions_3080.begin(), itTransitionCG_30a7= transitionCGs_3083.begin(); itSFState_308c!= sFStates_3079.end(), itSFTransition_3095!= sFTransitions_307d.end(), itFunction_309e!= functions_3080.end(), itTransitionCG_30a7!= transitionCGs_3083.end(); ++itSFState_308c, ++itSFTransition_3095, ++itFunction_309e, ++itTransitionCG_30a7)
	{
		bool isUnique= isInputUnique( *itSFState_308c, *itSFTransition_3095, *itFunction_309e, *itTransitionCG_30a7);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_308c, *itSFTransition_3095, *itFunction_309e, *itTransitionCG_30a7);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool TransCond_3078::patternMatcher( const Udm::Object& sFState_308d, const Udm::Object& sFTransition_3096, const Udm::Object& function_309f, const Udm::Object& transitionCG_30a8)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_308d.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_3092= CyberComposition::Simulink::SFState::Cast( sFState_308d);
		if( false== Uml::IsDerivedFrom( sFTransition_3096.type(), CyberComposition::Simulink::SFTransition::meta))
			continue;
		CyberComposition::Simulink::SFTransition sFTransition_309b= CyberComposition::Simulink::SFTransition::Cast( sFTransition_3096);
		if( false== Uml::IsDerivedFrom( function_309f.type(), SFC::Function::meta))
			continue;
		SFC::Function function_30a4= SFC::Function::Cast( function_309f);
		if( false== Uml::IsDerivedFrom( transitionCG_30a8.type(), SFC::ConditionalGroup::meta))
			continue;
		SFC::ConditionalGroup transitionCG_30ad= SFC::ConditionalGroup::Cast( transitionCG_30a8);
		CyberComposition::Simulink::SFTransConnector sFSrcTransConnector_30af= sFTransition_309b.srcTransition_end();
		CyberComposition::Simulink::SFTransConnector sFDstTransConnector_30b0= sFTransition_309b.dstTransition_end();
		Match currMatch;
		currMatch.sFState_30b2= sFState_3092;
		currMatch.sFTransition_30b3= sFTransition_309b;
		currMatch.function_30b4= function_30a4;
		currMatch.transitionCG_30b5= transitionCG_30ad;
		currMatch.sFDstTransConnector_30b6= sFDstTransConnector_30b0;
		currMatch.sFSrcTransConnector_30b7= sFSrcTransConnector_30af;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void TransCond_3078::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_30b8= SFC::ConditionalBlock::Create( currMatch.transitionCG_30b5, SFC::ConditionalGroup::meta_stmnt);
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_30b8;
		SFC::Function& Function= currMatch.function_30b4;
		CyberComposition::Simulink::SFTransConnector& SFDstTransConnector= currMatch.sFDstTransConnector_30b6;
		CyberComposition::Simulink::SFTransConnector& SFSrcTransConnector= currMatch.sFSrcTransConnector_30b7;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_30b2;
		CyberComposition::Simulink::SFTransition& SFTransition= currMatch.sFTransition_30b3;
		SFC::ConditionalGroup& TransitionCG= currMatch.transitionCG_30b5;
		{
ConditionalBlock.RefId() = SFTransition.RefId();
};
		{
__int64 statementCount = TransitionCG.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
TransitionCG.statementCount() = statementCount;
};
		{
std::string condition = SFTransition.Trigger();
SFManager::filterComments( condition );
condition = SFManager::trim( condition );

std::string guard = SFTransition.Guard();
SFManager::filterComments( guard );
guard = SFManager::trim( guard );

if ( condition.empty() ) {
  condition = guard;
} else if ( !guard.empty() ) {
  condition = "( " + condition + " ) && ( " + guard + " )";
}
if ( condition.empty() ) condition = "1";

SFManager::mexpr2SFCCondition( ConditionalBlock, condition );

SFManager::mstat2SFC( ConditionalBlock, SFTransition.ConditionAction() );
};
		outputAppender( currMatch.sFState_30b2, currMatch.sFDstTransConnector_30b6, currMatch.sFTransition_30b3, currMatch.function_30b4, newConditionalBlock_30b8);
	}
}

void TransCond_3078::outputAppender( const CyberComposition::Simulink::SFState& sFState_30b9, const CyberComposition::Simulink::SFTransConnector& sFDstTransConnector_30bb, const CyberComposition::Simulink::SFTransition& sFTransition_30bd, const SFC::Function& function_30bf, const SFC::ConditionalBlock& conditionalBlock_30c1)
{
	_sFState_3086->push_back( sFState_30b9);
	_sFDstTransConnector_3087->push_back( sFDstTransConnector_30bb);
	_sFTransition_3088->push_back( sFTransition_30bd);
	_function_3089->push_back( function_30bf);
	_conditionalBlock_308a->push_back( conditionalBlock_30c1);
}

void Test_30c3::operator()( const Packets_t& states_30c4, const Packets_t& dsts_30c6, const Packets_t& transs_30c8, const Packets_t& fcns_30ca, const Packets_t& cbs_30cc, Packets_t& states_30ce, Packets_t& dsts_30cf, Packets_t& transs_30d0, Packets_t& fcns_30d1, Packets_t& cbs_30d2, Packets_t& states_30d3, Packets_t& dsts_30d4, Packets_t& transs_30d5, Packets_t& fcns_30d6, Packets_t& cbs_30d7, Packets_t& states_30d8, Packets_t& dsts_30d9, Packets_t& transs_30da, Packets_t& fcns_30db, Packets_t& cbs_30dc, Packets_t& states_30dd, Packets_t& dsts_30de, Packets_t& transs_30df, Packets_t& fcns_30e0, Packets_t& cbs_30e1, Packets_t& states_30e2, Packets_t& dsts_30e3, Packets_t& transs_30e4, Packets_t& fcns_30e5, Packets_t& cbs_30e6)
{
#ifdef PRINT_INFO
	printLog( "Test_30c3" );
#endif
	_state_30e7= &states_30ce;
	_dst_30e8= &dsts_30cf;
	_trans_30e9= &transs_30d0;
	_fcn_30ea= &fcns_30d1;
	_cb_30eb= &cbs_30d2;
	_state_30ec= &states_30d3;
	_dst_30ed= &dsts_30d4;
	_trans_30ee= &transs_30d5;
	_fcn_30ef= &fcns_30d6;
	_cb_30f0= &cbs_30d7;
	_state_30f1= &states_30d8;
	_dst_30f2= &dsts_30d9;
	_trans_30f3= &transs_30da;
	_fcn_30f4= &fcns_30db;
	_cb_30f5= &cbs_30dc;
	_state_30f6= &states_30dd;
	_dst_30f7= &dsts_30de;
	_trans_30f8= &transs_30df;
	_fcn_30f9= &fcns_30e0;
	_cb_30fa= &cbs_30e1;
	_state_30fb= &states_30e2;
	_dst_30fc= &dsts_30e3;
	_trans_30fd= &transs_30e4;
	_fcn_30fe= &fcns_30e5;
	_cb_30ff= &cbs_30e6;
	for( Packets_t::const_iterator itstate_3101= states_30c4.begin(), itdst_3108= dsts_30c6.begin(), ittrans_310f= transs_30c8.begin(), itfcn_3116= fcns_30ca.begin(), itcb_311d= cbs_30cc.begin(); itstate_3101!= states_30c4.end(), itdst_3108!= dsts_30c6.end(), ittrans_310f!= transs_30c8.end(), itfcn_3116!= fcns_30ca.end(), itcb_311d!= cbs_30cc.end(); ++itstate_3101, ++itdst_3108, ++ittrans_310f, ++itfcn_3116, ++itcb_311d)
	{
		bool isUnique= isInputUnique( *itstate_3101, *itdst_3108, *ittrans_310f, *itfcn_3116, *itcb_311d);
		if( !isUnique)
			continue;
		Packets_t onestate_3105( 1, *itstate_3101);
		Packets_t onedst_310c( 1, *itdst_3108);
		Packets_t onetrans_3113( 1, *ittrans_310f);
		Packets_t onefcn_311a( 1, *itfcn_3116);
		Packets_t onecb_3121( 1, *itcb_311d);
		executeOne( onestate_3105, onedst_310c, onetrans_3113, onefcn_311a, onecb_3121);
	}
}

void Test_30c3::executeOne( const Packets_t& states_30c4, const Packets_t& dsts_30c6, const Packets_t& transs_30c8, const Packets_t& fcns_30ca, const Packets_t& cbs_30cc)
{
	Packets_t sFStates_3126;
	Packets_t sFDstStates_3129;
	Packets_t sFTransitions_312c;
	Packets_t functions_312f;
	Packets_t conditionalBlocks_3132;
	DstIsState_3123 dstIsState_3123;
	bool isMatchDstIsState_3123= dstIsState_3123( states_30c4, dsts_30c6, transs_30c8, fcns_30ca, cbs_30cc, sFStates_3126, sFDstStates_3129, sFTransitions_312c, functions_312f, conditionalBlocks_3132);
	_state_30e7->insert( _state_30e7->end(), sFStates_3126.begin(), sFStates_3126.end());
	_dst_30e8->insert( _dst_30e8->end(), sFDstStates_3129.begin(), sFDstStates_3129.end());
	_trans_30e9->insert( _trans_30e9->end(), sFTransitions_312c.begin(), sFTransitions_312c.end());
	_fcn_30ea->insert( _fcn_30ea->end(), functions_312f.begin(), functions_312f.end());
	_cb_30eb->insert( _cb_30eb->end(), conditionalBlocks_3132.begin(), conditionalBlocks_3132.end());
	if( isMatchDstIsState_3123)
		return;
	Packets_t sFStates_3178;
	Packets_t sFConnectorRefs_317b;
	Packets_t sFTransitions_317e;
	Packets_t functions_3181;
	Packets_t conditionalBlocks_3184;
	DstIsRefState_3175 dstIsRefState_3175;
	bool isMatchDstIsRefState_3175= dstIsRefState_3175( states_30c4, dsts_30c6, transs_30c8, fcns_30ca, cbs_30cc, sFStates_3178, sFConnectorRefs_317b, sFTransitions_317e, functions_3181, conditionalBlocks_3184);
	_state_30ec->insert( _state_30ec->end(), sFStates_3178.begin(), sFStates_3178.end());
	_dst_30ed->insert( _dst_30ed->end(), sFConnectorRefs_317b.begin(), sFConnectorRefs_317b.end());
	_trans_30ee->insert( _trans_30ee->end(), sFTransitions_317e.begin(), sFTransitions_317e.end());
	_fcn_30ef->insert( _fcn_30ef->end(), functions_3181.begin(), functions_3181.end());
	_cb_30f0->insert( _cb_30f0->end(), conditionalBlocks_3184.begin(), conditionalBlocks_3184.end());
	if( isMatchDstIsRefState_3175)
		return;
	Packets_t sFStates_31cd;
	Packets_t sFJunctions_31d0;
	Packets_t sFTransitions_31d3;
	Packets_t functions_31d6;
	Packets_t conditionalBlocks_31d9;
	DstIsJuncWithTrans_31ca dstIsJuncWithTrans_31ca;
	bool isMatchDstIsJuncWithTrans_31ca= dstIsJuncWithTrans_31ca( states_30c4, dsts_30c6, transs_30c8, fcns_30ca, cbs_30cc, sFStates_31cd, sFJunctions_31d0, sFTransitions_31d3, functions_31d6, conditionalBlocks_31d9);
	_state_30f1->insert( _state_30f1->end(), sFStates_31cd.begin(), sFStates_31cd.end());
	_dst_30f2->insert( _dst_30f2->end(), sFJunctions_31d0.begin(), sFJunctions_31d0.end());
	_trans_30f3->insert( _trans_30f3->end(), sFTransitions_31d3.begin(), sFTransitions_31d3.end());
	_fcn_30f4->insert( _fcn_30f4->end(), functions_31d6.begin(), functions_31d6.end());
	_cb_30f5->insert( _cb_30f5->end(), conditionalBlocks_31d9.begin(), conditionalBlocks_31d9.end());
	if( isMatchDstIsJuncWithTrans_31ca)
		return;
	Packets_t sFStates_3225;
	Packets_t sFJunctions_3228;
	Packets_t sFTransitions_322b;
	Packets_t functions_322e;
	Packets_t conditionalBlocks_3231;
	DstIsJuncWithRefTrans_3222 dstIsJuncWithRefTrans_3222;
	bool isMatchDstIsJuncWithRefTrans_3222= dstIsJuncWithRefTrans_3222( states_30c4, dsts_30c6, transs_30c8, fcns_30ca, cbs_30cc, sFStates_3225, sFJunctions_3228, sFTransitions_322b, functions_322e, conditionalBlocks_3231);
	_state_30f1->insert( _state_30f1->end(), sFStates_3225.begin(), sFStates_3225.end());
	_dst_30f2->insert( _dst_30f2->end(), sFJunctions_3228.begin(), sFJunctions_3228.end());
	_trans_30f3->insert( _trans_30f3->end(), sFTransitions_322b.begin(), sFTransitions_322b.end());
	_fcn_30f4->insert( _fcn_30f4->end(), functions_322e.begin(), functions_322e.end());
	_cb_30f5->insert( _cb_30f5->end(), conditionalBlocks_3231.begin(), conditionalBlocks_3231.end());
	if( isMatchDstIsJuncWithRefTrans_3222)
		return;
	Packets_t sFStates_3281;
	Packets_t sFConnectorRefs_3284;
	Packets_t sFTransitions_3287;
	Packets_t functions_328a;
	Packets_t conditionalBlocks_328d;
	DstIsJuncRefWithTrans_327e dstIsJuncRefWithTrans_327e;
	bool isMatchDstIsJuncRefWithTrans_327e= dstIsJuncRefWithTrans_327e( states_30c4, dsts_30c6, transs_30c8, fcns_30ca, cbs_30cc, sFStates_3281, sFConnectorRefs_3284, sFTransitions_3287, functions_328a, conditionalBlocks_328d);
	_state_30f6->insert( _state_30f6->end(), sFStates_3281.begin(), sFStates_3281.end());
	_dst_30f7->insert( _dst_30f7->end(), sFConnectorRefs_3284.begin(), sFConnectorRefs_3284.end());
	_trans_30f8->insert( _trans_30f8->end(), sFTransitions_3287.begin(), sFTransitions_3287.end());
	_fcn_30f9->insert( _fcn_30f9->end(), functions_328a.begin(), functions_328a.end());
	_cb_30fa->insert( _cb_30fa->end(), conditionalBlocks_328d.begin(), conditionalBlocks_328d.end());
	if( isMatchDstIsJuncRefWithTrans_327e)
		return;
	Packets_t sFStates_32dc;
	Packets_t sFConnectorRefs_32df;
	Packets_t sFTransitions_32e2;
	Packets_t functions_32e5;
	Packets_t conditionalBlocks_32e8;
	DstIsJuncRefWithJuncTrans_32d9 dstIsJuncRefWithJuncTrans_32d9;
	bool isMatchDstIsJuncRefWithJuncTrans_32d9= dstIsJuncRefWithJuncTrans_32d9( states_30c4, dsts_30c6, transs_30c8, fcns_30ca, cbs_30cc, sFStates_32dc, sFConnectorRefs_32df, sFTransitions_32e2, functions_32e5, conditionalBlocks_32e8);
	_state_30f6->insert( _state_30f6->end(), sFStates_32dc.begin(), sFStates_32dc.end());
	_dst_30f7->insert( _dst_30f7->end(), sFConnectorRefs_32df.begin(), sFConnectorRefs_32df.end());
	_trans_30f8->insert( _trans_30f8->end(), sFTransitions_32e2.begin(), sFTransitions_32e2.end());
	_fcn_30f9->insert( _fcn_30f9->end(), functions_32e5.begin(), functions_32e5.end());
	_cb_30fa->insert( _cb_30fa->end(), conditionalBlocks_32e8.begin(), conditionalBlocks_32e8.end());
	if( isMatchDstIsJuncRefWithJuncTrans_32d9)
		return;
	Packets_t sFStates_3337;
	Packets_t sFTransConnectors_333a;
	Packets_t sFTransitions_333d;
	Packets_t functions_3340;
	Packets_t conditionalBlocks_3343;
	DeadEnd_3334 deadEnd_3334;
	bool isMatchDeadEnd_3334= deadEnd_3334( states_30c4, dsts_30c6, transs_30c8, fcns_30ca, cbs_30cc, sFStates_3337, sFTransConnectors_333a, sFTransitions_333d, functions_3340, conditionalBlocks_3343);
	_state_30fb->insert( _state_30fb->end(), sFStates_3337.begin(), sFStates_3337.end());
	_dst_30fc->insert( _dst_30fc->end(), sFTransConnectors_333a.begin(), sFTransConnectors_333a.end());
	_trans_30fd->insert( _trans_30fd->end(), sFTransitions_333d.begin(), sFTransitions_333d.end());
	_fcn_30fe->insert( _fcn_30fe->end(), functions_3340.begin(), functions_3340.end());
	_cb_30ff->insert( _cb_30ff->end(), conditionalBlocks_3343.begin(), conditionalBlocks_3343.end());
	if( isMatchDeadEnd_3334)
		return;
}

bool Test_30c3::isInputUnique( const Udm::Object& state_3102, const Udm::Object& dst_3109, const Udm::Object& trans_3110, const Udm::Object& fcn_3117, const Udm::Object& cb_311e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_3104= _state_3100.begin(), itdst_310b= _dst_3107.begin(), ittrans_3112= _trans_310e.begin(), itfcn_3119= _fcn_3115.begin(), itcb_3120= _cb_311c.begin(); itstate_3104!= _state_3100.end(), itdst_310b!= _dst_3107.end(), ittrans_3112!= _trans_310e.end(), itfcn_3119!= _fcn_3115.end(), itcb_3120!= _cb_311c.end(); ++itstate_3104, ++itdst_310b, ++ittrans_3112, ++itfcn_3119, ++itcb_3120)
	{
		if( ( *itstate_3104== state_3102)&& ( *itdst_310b== dst_3109)&& ( *ittrans_3112== trans_3110)&& ( *itfcn_3119== fcn_3117)&& ( *itcb_3120== cb_311e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_3100.push_back( state_3102);
		_dst_3107.push_back( dst_3109);
		_trans_310e.push_back( trans_3110);
		_fcn_3115.push_back( fcn_3117);
		_cb_311c.push_back( cb_311e);
	}
	return isUnique;
}

bool DstIsState_3123::operator()( const Packets_t& sFStates_3124, const Packets_t& sFDstStates_3127, const Packets_t& sFTransitions_312a, const Packets_t& functions_312d, const Packets_t& conditionalBlocks_3130, Packets_t& sFStates_3126, Packets_t& sFDstStates_3129, Packets_t& sFTransitions_312c, Packets_t& functions_312f, Packets_t& conditionalBlocks_3132)
{
#ifdef PRINT_INFO
	printLog( "DstIsState_3123" );
#endif
	_sFState_3133= &sFStates_3126;
	_sFDstState_3134= &sFDstStates_3129;
	_sFTransition_3135= &sFTransitions_312c;
	_function_3136= &functions_312f;
	_conditionalBlock_3137= &conditionalBlocks_3132;
	processInputPackets( sFStates_3124, sFDstStates_3127, sFTransitions_312a, functions_312d, conditionalBlocks_3130);
	if( false== _matches.empty())
		return true;
	return false;
}

bool DstIsState_3123::isInputUnique( const Udm::Object& sFState_313c, const Udm::Object& sFDstState_3145, const Udm::Object& sFTransition_314e, const Udm::Object& function_3157, const Udm::Object& conditionalBlock_3160)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_313e= _sFState_3138.begin(), itSFDstState_3147= _sFDstState_3141.begin(), itSFTransition_3150= _sFTransition_314a.begin(), itFunction_3159= _function_3153.begin(), itConditionalBlock_3162= _conditionalBlock_315c.begin(); itSFState_313e!= _sFState_3138.end(), itSFDstState_3147!= _sFDstState_3141.end(), itSFTransition_3150!= _sFTransition_314a.end(), itFunction_3159!= _function_3153.end(), itConditionalBlock_3162!= _conditionalBlock_315c.end(); ++itSFState_313e, ++itSFDstState_3147, ++itSFTransition_3150, ++itFunction_3159, ++itConditionalBlock_3162)
	{
		if( ( *itSFState_313e== sFState_313c)&& ( *itSFDstState_3147== sFDstState_3145)&& ( *itSFTransition_3150== sFTransition_314e)&& ( *itFunction_3159== function_3157)&& ( *itConditionalBlock_3162== conditionalBlock_3160))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_3138.push_back( sFState_313c);
		_sFDstState_3141.push_back( sFDstState_3145);
		_sFTransition_314a.push_back( sFTransition_314e);
		_function_3153.push_back( function_3157);
		_conditionalBlock_315c.push_back( conditionalBlock_3160);
	}
	return isUnique;
}

void DstIsState_3123::processInputPackets( const Packets_t& sFStates_3124, const Packets_t& sFDstStates_3127, const Packets_t& sFTransitions_312a, const Packets_t& functions_312d, const Packets_t& conditionalBlocks_3130)
{
	for( Packets_t::const_iterator itSFState_3139= sFStates_3124.begin(), itSFDstState_3142= sFDstStates_3127.begin(), itSFTransition_314b= sFTransitions_312a.begin(), itFunction_3154= functions_312d.begin(), itConditionalBlock_315d= conditionalBlocks_3130.begin(); itSFState_3139!= sFStates_3124.end(), itSFDstState_3142!= sFDstStates_3127.end(), itSFTransition_314b!= sFTransitions_312a.end(), itFunction_3154!= functions_312d.end(), itConditionalBlock_315d!= conditionalBlocks_3130.end(); ++itSFState_3139, ++itSFDstState_3142, ++itSFTransition_314b, ++itFunction_3154, ++itConditionalBlock_315d)
	{
		bool isUnique= isInputUnique( *itSFState_3139, *itSFDstState_3142, *itSFTransition_314b, *itFunction_3154, *itConditionalBlock_315d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_3139, *itSFDstState_3142, *itSFTransition_314b, *itFunction_3154, *itConditionalBlock_315d);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_3166, currMatch.sFDstState_3167, currMatch.sFTransition_3168, currMatch.function_3169, currMatch.conditionalBlock_316a);
	}
}

bool DstIsState_3123::patternMatcher( const Udm::Object& sFState_313a, const Udm::Object& sFDstState_3143, const Udm::Object& sFTransition_314c, const Udm::Object& function_3155, const Udm::Object& conditionalBlock_315e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_313a.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_313f= CyberComposition::Simulink::SFState::Cast( sFState_313a);
		if( false== Uml::IsDerivedFrom( sFDstState_3143.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFDstState_3148= CyberComposition::Simulink::SFState::Cast( sFDstState_3143);
		if( false== Uml::IsDerivedFrom( sFTransition_314c.type(), CyberComposition::Simulink::SFTransition::meta))
			continue;
		CyberComposition::Simulink::SFTransition sFTransition_3151= CyberComposition::Simulink::SFTransition::Cast( sFTransition_314c);
		if( false== Uml::IsDerivedFrom( function_3155.type(), SFC::Function::meta))
			continue;
		SFC::Function function_315a= SFC::Function::Cast( function_3155);
		if( false== Uml::IsDerivedFrom( conditionalBlock_315e.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlock_3163= SFC::ConditionalBlock::Cast( conditionalBlock_315e);
		Match currMatch;
		currMatch.sFState_3166= sFState_313f;
		currMatch.sFDstState_3167= sFDstState_3148;
		currMatch.sFTransition_3168= sFTransition_3151;
		currMatch.function_3169= function_315a;
		currMatch.conditionalBlock_316a= conditionalBlock_3163;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void DstIsState_3123::outputAppender( const CyberComposition::Simulink::SFState& sFState_316b, const CyberComposition::Simulink::SFState& sFDstState_316d, const CyberComposition::Simulink::SFTransition& sFTransition_316f, const SFC::Function& function_3171, const SFC::ConditionalBlock& conditionalBlock_3173)
{
	_sFState_3133->push_back( sFState_316b);
	_sFDstState_3134->push_back( sFDstState_316d);
	_sFTransition_3135->push_back( sFTransition_316f);
	_function_3136->push_back( function_3171);
	_conditionalBlock_3137->push_back( conditionalBlock_3173);
}

bool DstIsRefState_3175::operator()( const Packets_t& sFStates_3176, const Packets_t& sFConnectorRefs_3179, const Packets_t& sFTransitions_317c, const Packets_t& functions_317f, const Packets_t& conditionalBlocks_3182, Packets_t& sFStates_3178, Packets_t& sFConnectorRefs_317b, Packets_t& sFTransitions_317e, Packets_t& functions_3181, Packets_t& conditionalBlocks_3184)
{
#ifdef PRINT_INFO
	printLog( "DstIsRefState_3175" );
#endif
	_sFState_3185= &sFStates_3178;
	_sFConnectorRef_3186= &sFConnectorRefs_317b;
	_sFTransition_3187= &sFTransitions_317e;
	_function_3188= &functions_3181;
	_conditionalBlock_3189= &conditionalBlocks_3184;
	processInputPackets( sFStates_3176, sFConnectorRefs_3179, sFTransitions_317c, functions_317f, conditionalBlocks_3182);
	if( false== _matches.empty())
		return true;
	return false;
}

bool DstIsRefState_3175::isInputUnique( const Udm::Object& sFState_318e, const Udm::Object& sFConnectorRef_3197, const Udm::Object& sFTransition_31a0, const Udm::Object& function_31a9, const Udm::Object& conditionalBlock_31b2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_3190= _sFState_318a.begin(), itSFConnectorRef_3199= _sFConnectorRef_3193.begin(), itSFTransition_31a2= _sFTransition_319c.begin(), itFunction_31ab= _function_31a5.begin(), itConditionalBlock_31b4= _conditionalBlock_31ae.begin(); itSFState_3190!= _sFState_318a.end(), itSFConnectorRef_3199!= _sFConnectorRef_3193.end(), itSFTransition_31a2!= _sFTransition_319c.end(), itFunction_31ab!= _function_31a5.end(), itConditionalBlock_31b4!= _conditionalBlock_31ae.end(); ++itSFState_3190, ++itSFConnectorRef_3199, ++itSFTransition_31a2, ++itFunction_31ab, ++itConditionalBlock_31b4)
	{
		if( ( *itSFState_3190== sFState_318e)&& ( *itSFConnectorRef_3199== sFConnectorRef_3197)&& ( *itSFTransition_31a2== sFTransition_31a0)&& ( *itFunction_31ab== function_31a9)&& ( *itConditionalBlock_31b4== conditionalBlock_31b2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_318a.push_back( sFState_318e);
		_sFConnectorRef_3193.push_back( sFConnectorRef_3197);
		_sFTransition_319c.push_back( sFTransition_31a0);
		_function_31a5.push_back( function_31a9);
		_conditionalBlock_31ae.push_back( conditionalBlock_31b2);
	}
	return isUnique;
}

void DstIsRefState_3175::processInputPackets( const Packets_t& sFStates_3176, const Packets_t& sFConnectorRefs_3179, const Packets_t& sFTransitions_317c, const Packets_t& functions_317f, const Packets_t& conditionalBlocks_3182)
{
	for( Packets_t::const_iterator itSFState_318b= sFStates_3176.begin(), itSFConnectorRef_3194= sFConnectorRefs_3179.begin(), itSFTransition_319d= sFTransitions_317c.begin(), itFunction_31a6= functions_317f.begin(), itConditionalBlock_31af= conditionalBlocks_3182.begin(); itSFState_318b!= sFStates_3176.end(), itSFConnectorRef_3194!= sFConnectorRefs_3179.end(), itSFTransition_319d!= sFTransitions_317c.end(), itFunction_31a6!= functions_317f.end(), itConditionalBlock_31af!= conditionalBlocks_3182.end(); ++itSFState_318b, ++itSFConnectorRef_3194, ++itSFTransition_319d, ++itFunction_31a6, ++itConditionalBlock_31af)
	{
		bool isUnique= isInputUnique( *itSFState_318b, *itSFConnectorRef_3194, *itSFTransition_319d, *itFunction_31a6, *itConditionalBlock_31af);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_318b, *itSFConnectorRef_3194, *itSFTransition_319d, *itFunction_31a6, *itConditionalBlock_31af);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_31ba, currMatch.sFConnectorRef_31bb, currMatch.sFTransition_31bc, currMatch.function_31bd, currMatch.conditionalBlock_31be);
	}
}

bool DstIsRefState_3175::patternMatcher( const Udm::Object& sFState_318c, const Udm::Object& sFConnectorRef_3195, const Udm::Object& sFTransition_319e, const Udm::Object& function_31a7, const Udm::Object& conditionalBlock_31b0)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_318c.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_3191= CyberComposition::Simulink::SFState::Cast( sFState_318c);
		if( false== Uml::IsDerivedFrom( sFConnectorRef_3195.type(), CyberComposition::Simulink::SFConnectorRef::meta))
			continue;
		CyberComposition::Simulink::SFConnectorRef sFConnectorRef_319a= CyberComposition::Simulink::SFConnectorRef::Cast( sFConnectorRef_3195);
		if( false== Uml::IsDerivedFrom( sFTransition_319e.type(), CyberComposition::Simulink::SFTransition::meta))
			continue;
		CyberComposition::Simulink::SFTransition sFTransition_31a3= CyberComposition::Simulink::SFTransition::Cast( sFTransition_319e);
		if( false== Uml::IsDerivedFrom( function_31a7.type(), SFC::Function::meta))
			continue;
		SFC::Function function_31ac= SFC::Function::Cast( function_31a7);
		if( false== Uml::IsDerivedFrom( conditionalBlock_31b0.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlock_31b5= SFC::ConditionalBlock::Cast( conditionalBlock_31b0);
		CyberComposition::Simulink::SFTransConnector sFDstState_31b7= sFConnectorRef_319a.ref();
		if( false== Uml::IsDerivedFrom( sFDstState_31b7.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFDstState_31b8= CyberComposition::Simulink::SFState::Cast( sFDstState_31b7);
		if( !sFDstState_31b8)
			continue;
		Match currMatch;
		currMatch.sFState_31ba= sFState_3191;
		currMatch.sFConnectorRef_31bb= sFConnectorRef_319a;
		currMatch.sFTransition_31bc= sFTransition_31a3;
		currMatch.function_31bd= function_31ac;
		currMatch.conditionalBlock_31be= conditionalBlock_31b5;
		currMatch.sFDstState_31bf= sFDstState_31b8;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void DstIsRefState_3175::outputAppender( const CyberComposition::Simulink::SFState& sFState_31c0, const CyberComposition::Simulink::SFConnectorRef& sFConnectorRef_31c2, const CyberComposition::Simulink::SFTransition& sFTransition_31c4, const SFC::Function& function_31c6, const SFC::ConditionalBlock& conditionalBlock_31c8)
{
	_sFState_3185->push_back( sFState_31c0);
	_sFConnectorRef_3186->push_back( sFConnectorRef_31c2);
	_sFTransition_3187->push_back( sFTransition_31c4);
	_function_3188->push_back( function_31c6);
	_conditionalBlock_3189->push_back( conditionalBlock_31c8);
}

bool DstIsJuncWithTrans_31ca::operator()( const Packets_t& sFStates_31cb, const Packets_t& sFJunctions_31ce, const Packets_t& sFTransitions_31d1, const Packets_t& functions_31d4, const Packets_t& conditionalBlocks_31d7, Packets_t& sFStates_31cd, Packets_t& sFJunctions_31d0, Packets_t& sFTransitions_31d3, Packets_t& functions_31d6, Packets_t& conditionalBlocks_31d9)
{
#ifdef PRINT_INFO
	printLog( "DstIsJuncWithTrans_31ca" );
#endif
	_sFState_31da= &sFStates_31cd;
	_sFJunction_31db= &sFJunctions_31d0;
	_sFTransition_31dc= &sFTransitions_31d3;
	_function_31dd= &functions_31d6;
	_conditionalBlock_31de= &conditionalBlocks_31d9;
	processInputPackets( sFStates_31cb, sFJunctions_31ce, sFTransitions_31d1, functions_31d4, conditionalBlocks_31d7);
	if( false== _matches.empty())
		return true;
	return false;
}

bool DstIsJuncWithTrans_31ca::isInputUnique( const Udm::Object& sFState_31e3, const Udm::Object& sFJunction_31ec, const Udm::Object& sFTransition_31f5, const Udm::Object& function_31fe, const Udm::Object& conditionalBlock_3207)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_31e5= _sFState_31df.begin(), itSFJunction_31ee= _sFJunction_31e8.begin(), itSFTransition_31f7= _sFTransition_31f1.begin(), itFunction_3200= _function_31fa.begin(), itConditionalBlock_3209= _conditionalBlock_3203.begin(); itSFState_31e5!= _sFState_31df.end(), itSFJunction_31ee!= _sFJunction_31e8.end(), itSFTransition_31f7!= _sFTransition_31f1.end(), itFunction_3200!= _function_31fa.end(), itConditionalBlock_3209!= _conditionalBlock_3203.end(); ++itSFState_31e5, ++itSFJunction_31ee, ++itSFTransition_31f7, ++itFunction_3200, ++itConditionalBlock_3209)
	{
		if( ( *itSFState_31e5== sFState_31e3)&& ( *itSFJunction_31ee== sFJunction_31ec)&& ( *itSFTransition_31f7== sFTransition_31f5)&& ( *itFunction_3200== function_31fe)&& ( *itConditionalBlock_3209== conditionalBlock_3207))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_31df.push_back( sFState_31e3);
		_sFJunction_31e8.push_back( sFJunction_31ec);
		_sFTransition_31f1.push_back( sFTransition_31f5);
		_function_31fa.push_back( function_31fe);
		_conditionalBlock_3203.push_back( conditionalBlock_3207);
	}
	return isUnique;
}

void DstIsJuncWithTrans_31ca::processInputPackets( const Packets_t& sFStates_31cb, const Packets_t& sFJunctions_31ce, const Packets_t& sFTransitions_31d1, const Packets_t& functions_31d4, const Packets_t& conditionalBlocks_31d7)
{
	for( Packets_t::const_iterator itSFState_31e0= sFStates_31cb.begin(), itSFJunction_31e9= sFJunctions_31ce.begin(), itSFTransition_31f2= sFTransitions_31d1.begin(), itFunction_31fb= functions_31d4.begin(), itConditionalBlock_3204= conditionalBlocks_31d7.begin(); itSFState_31e0!= sFStates_31cb.end(), itSFJunction_31e9!= sFJunctions_31ce.end(), itSFTransition_31f2!= sFTransitions_31d1.end(), itFunction_31fb!= functions_31d4.end(), itConditionalBlock_3204!= conditionalBlocks_31d7.end(); ++itSFState_31e0, ++itSFJunction_31e9, ++itSFTransition_31f2, ++itFunction_31fb, ++itConditionalBlock_3204)
	{
		bool isUnique= isInputUnique( *itSFState_31e0, *itSFJunction_31e9, *itSFTransition_31f2, *itFunction_31fb, *itConditionalBlock_3204);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_31e0, *itSFJunction_31e9, *itSFTransition_31f2, *itFunction_31fb, *itConditionalBlock_3204);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_3211, currMatch.sFJunction_3212, currMatch.sFTransition_3213, currMatch.function_3214, currMatch.conditionalBlock_3215);
	}
}

bool DstIsJuncWithTrans_31ca::patternMatcher( const Udm::Object& sFState_31e1, const Udm::Object& sFJunction_31ea, const Udm::Object& sFTransition_31f3, const Udm::Object& function_31fc, const Udm::Object& conditionalBlock_3205)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_31e1.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_31e6= CyberComposition::Simulink::SFState::Cast( sFState_31e1);
		if( false== Uml::IsDerivedFrom( sFJunction_31ea.type(), CyberComposition::Simulink::SFJunction::meta))
			continue;
		CyberComposition::Simulink::SFJunction sFJunction_31ef= CyberComposition::Simulink::SFJunction::Cast( sFJunction_31ea);
		if( false== Uml::IsDerivedFrom( sFTransition_31f3.type(), CyberComposition::Simulink::SFTransition::meta))
			continue;
		CyberComposition::Simulink::SFTransition sFTransition_31f8= CyberComposition::Simulink::SFTransition::Cast( sFTransition_31f3);
		if( false== Uml::IsDerivedFrom( function_31fc.type(), SFC::Function::meta))
			continue;
		SFC::Function function_3201= SFC::Function::Cast( function_31fc);
		if( false== Uml::IsDerivedFrom( conditionalBlock_3205.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlock_320a= SFC::ConditionalBlock::Cast( conditionalBlock_3205);
		set< CyberComposition::Simulink::SFTransition> sFTransition2s_320c= sFJunction_31ef.dstTransition();
		for( set< CyberComposition::Simulink::SFTransition>::const_iterator itSFTransition2s_320d= sFTransition2s_320c.begin(); itSFTransition2s_320d!= sFTransition2s_320c.end(); ++itSFTransition2s_320d)
		{
			CyberComposition::Simulink::SFTransition currSFTransition2_320e= *itSFTransition2s_320d;
			CyberComposition::Simulink::SFTransConnector sFTransConnector_320f= currSFTransition2_320e.dstTransition_end();
			Match currMatch;
			currMatch.sFState_3211= sFState_31e6;
			currMatch.sFJunction_3212= sFJunction_31ef;
			currMatch.sFTransition_3213= sFTransition_31f8;
			currMatch.function_3214= function_3201;
			currMatch.conditionalBlock_3215= conditionalBlock_320a;
			currMatch.sFTransition2_3216= currSFTransition2_320e;
			currMatch.sFTransConnector_3217= sFTransConnector_320f;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void DstIsJuncWithTrans_31ca::outputAppender( const CyberComposition::Simulink::SFState& sFState_3218, const CyberComposition::Simulink::SFJunction& sFJunction_321a, const CyberComposition::Simulink::SFTransition& sFTransition_321c, const SFC::Function& function_321e, const SFC::ConditionalBlock& conditionalBlock_3220)
{
	_sFState_31da->push_back( sFState_3218);
	_sFJunction_31db->push_back( sFJunction_321a);
	_sFTransition_31dc->push_back( sFTransition_321c);
	_function_31dd->push_back( function_321e);
	_conditionalBlock_31de->push_back( conditionalBlock_3220);
}

bool DstIsJuncWithRefTrans_3222::operator()( const Packets_t& sFStates_3223, const Packets_t& sFJunctions_3226, const Packets_t& sFTransitions_3229, const Packets_t& functions_322c, const Packets_t& conditionalBlocks_322f, Packets_t& sFStates_3225, Packets_t& sFJunctions_3228, Packets_t& sFTransitions_322b, Packets_t& functions_322e, Packets_t& conditionalBlocks_3231)
{
#ifdef PRINT_INFO
	printLog( "DstIsJuncWithRefTrans_3222" );
#endif
	_sFState_3232= &sFStates_3225;
	_sFJunction_3233= &sFJunctions_3228;
	_sFTransition_3234= &sFTransitions_322b;
	_function_3235= &functions_322e;
	_conditionalBlock_3236= &conditionalBlocks_3231;
	processInputPackets( sFStates_3223, sFJunctions_3226, sFTransitions_3229, functions_322c, conditionalBlocks_322f);
	if( false== _matches.empty())
		return true;
	return false;
}

bool DstIsJuncWithRefTrans_3222::isInputUnique( const Udm::Object& sFState_323b, const Udm::Object& sFJunction_3244, const Udm::Object& sFTransition_324d, const Udm::Object& function_3256, const Udm::Object& conditionalBlock_325f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_323d= _sFState_3237.begin(), itSFJunction_3246= _sFJunction_3240.begin(), itSFTransition_324f= _sFTransition_3249.begin(), itFunction_3258= _function_3252.begin(), itConditionalBlock_3261= _conditionalBlock_325b.begin(); itSFState_323d!= _sFState_3237.end(), itSFJunction_3246!= _sFJunction_3240.end(), itSFTransition_324f!= _sFTransition_3249.end(), itFunction_3258!= _function_3252.end(), itConditionalBlock_3261!= _conditionalBlock_325b.end(); ++itSFState_323d, ++itSFJunction_3246, ++itSFTransition_324f, ++itFunction_3258, ++itConditionalBlock_3261)
	{
		if( ( *itSFState_323d== sFState_323b)&& ( *itSFJunction_3246== sFJunction_3244)&& ( *itSFTransition_324f== sFTransition_324d)&& ( *itFunction_3258== function_3256)&& ( *itConditionalBlock_3261== conditionalBlock_325f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_3237.push_back( sFState_323b);
		_sFJunction_3240.push_back( sFJunction_3244);
		_sFTransition_3249.push_back( sFTransition_324d);
		_function_3252.push_back( function_3256);
		_conditionalBlock_325b.push_back( conditionalBlock_325f);
	}
	return isUnique;
}

void DstIsJuncWithRefTrans_3222::processInputPackets( const Packets_t& sFStates_3223, const Packets_t& sFJunctions_3226, const Packets_t& sFTransitions_3229, const Packets_t& functions_322c, const Packets_t& conditionalBlocks_322f)
{
	for( Packets_t::const_iterator itSFState_3238= sFStates_3223.begin(), itSFJunction_3241= sFJunctions_3226.begin(), itSFTransition_324a= sFTransitions_3229.begin(), itFunction_3253= functions_322c.begin(), itConditionalBlock_325c= conditionalBlocks_322f.begin(); itSFState_3238!= sFStates_3223.end(), itSFJunction_3241!= sFJunctions_3226.end(), itSFTransition_324a!= sFTransitions_3229.end(), itFunction_3253!= functions_322c.end(), itConditionalBlock_325c!= conditionalBlocks_322f.end(); ++itSFState_3238, ++itSFJunction_3241, ++itSFTransition_324a, ++itFunction_3253, ++itConditionalBlock_325c)
	{
		bool isUnique= isInputUnique( *itSFState_3238, *itSFJunction_3241, *itSFTransition_324a, *itFunction_3253, *itConditionalBlock_325c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_3238, *itSFJunction_3241, *itSFTransition_324a, *itFunction_3253, *itConditionalBlock_325c);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_326c, currMatch.sFJunction_326d, currMatch.sFTransition_326e, currMatch.function_326f, currMatch.conditionalBlock_3270);
	}
}

bool DstIsJuncWithRefTrans_3222::patternMatcher( const Udm::Object& sFState_3239, const Udm::Object& sFJunction_3242, const Udm::Object& sFTransition_324b, const Udm::Object& function_3254, const Udm::Object& conditionalBlock_325d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_3239.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_323e= CyberComposition::Simulink::SFState::Cast( sFState_3239);
		if( false== Uml::IsDerivedFrom( sFJunction_3242.type(), CyberComposition::Simulink::SFJunction::meta))
			continue;
		CyberComposition::Simulink::SFJunction sFJunction_3247= CyberComposition::Simulink::SFJunction::Cast( sFJunction_3242);
		if( false== Uml::IsDerivedFrom( sFTransition_324b.type(), CyberComposition::Simulink::SFTransition::meta))
			continue;
		CyberComposition::Simulink::SFTransition sFTransition_3250= CyberComposition::Simulink::SFTransition::Cast( sFTransition_324b);
		if( false== Uml::IsDerivedFrom( function_3254.type(), SFC::Function::meta))
			continue;
		SFC::Function function_3259= SFC::Function::Cast( function_3254);
		if( false== Uml::IsDerivedFrom( conditionalBlock_325d.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlock_3262= SFC::ConditionalBlock::Cast( conditionalBlock_325d);
		set< CyberComposition::Simulink::SFConnectorRef> sFConnectorRefs_3264= sFJunction_3247.referedbyConnectorRef();
		for( set< CyberComposition::Simulink::SFConnectorRef>::const_iterator itSFConnectorRefs_3265= sFConnectorRefs_3264.begin(); itSFConnectorRefs_3265!= sFConnectorRefs_3264.end(); ++itSFConnectorRefs_3265)
		{
			CyberComposition::Simulink::SFConnectorRef currSFConnectorRef_3266= *itSFConnectorRefs_3265;
			set< CyberComposition::Simulink::SFTransition> sFTransition2s_3267= currSFConnectorRef_3266.dstTransition();
			for( set< CyberComposition::Simulink::SFTransition>::const_iterator itSFTransition2s_3268= sFTransition2s_3267.begin(); itSFTransition2s_3268!= sFTransition2s_3267.end(); ++itSFTransition2s_3268)
			{
				CyberComposition::Simulink::SFTransition currSFTransition2_3269= *itSFTransition2s_3268;
				CyberComposition::Simulink::SFTransConnector sFTransConnector_326a= currSFTransition2_3269.dstTransition_end();
				Match currMatch;
				currMatch.sFState_326c= sFState_323e;
				currMatch.sFJunction_326d= sFJunction_3247;
				currMatch.sFTransition_326e= sFTransition_3250;
				currMatch.function_326f= function_3259;
				currMatch.conditionalBlock_3270= conditionalBlock_3262;
				currMatch.sFConnectorRef_3271= currSFConnectorRef_3266;
				currMatch.sFTransition2_3272= currSFTransition2_3269;
				currMatch.sFTransConnector_3273= sFTransConnector_326a;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void DstIsJuncWithRefTrans_3222::outputAppender( const CyberComposition::Simulink::SFState& sFState_3274, const CyberComposition::Simulink::SFJunction& sFJunction_3276, const CyberComposition::Simulink::SFTransition& sFTransition_3278, const SFC::Function& function_327a, const SFC::ConditionalBlock& conditionalBlock_327c)
{
	_sFState_3232->push_back( sFState_3274);
	_sFJunction_3233->push_back( sFJunction_3276);
	_sFTransition_3234->push_back( sFTransition_3278);
	_function_3235->push_back( function_327a);
	_conditionalBlock_3236->push_back( conditionalBlock_327c);
}

bool DstIsJuncRefWithTrans_327e::operator()( const Packets_t& sFStates_327f, const Packets_t& sFConnectorRefs_3282, const Packets_t& sFTransitions_3285, const Packets_t& functions_3288, const Packets_t& conditionalBlocks_328b, Packets_t& sFStates_3281, Packets_t& sFConnectorRefs_3284, Packets_t& sFTransitions_3287, Packets_t& functions_328a, Packets_t& conditionalBlocks_328d)
{
#ifdef PRINT_INFO
	printLog( "DstIsJuncRefWithTrans_327e" );
#endif
	_sFState_328e= &sFStates_3281;
	_sFConnectorRef_328f= &sFConnectorRefs_3284;
	_sFTransition_3290= &sFTransitions_3287;
	_function_3291= &functions_328a;
	_conditionalBlock_3292= &conditionalBlocks_328d;
	processInputPackets( sFStates_327f, sFConnectorRefs_3282, sFTransitions_3285, functions_3288, conditionalBlocks_328b);
	if( false== _matches.empty())
		return true;
	return false;
}

bool DstIsJuncRefWithTrans_327e::isInputUnique( const Udm::Object& sFState_3297, const Udm::Object& sFConnectorRef_32a0, const Udm::Object& sFTransition_32a9, const Udm::Object& function_32b2, const Udm::Object& conditionalBlock_32bb)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_3299= _sFState_3293.begin(), itSFConnectorRef_32a2= _sFConnectorRef_329c.begin(), itSFTransition_32ab= _sFTransition_32a5.begin(), itFunction_32b4= _function_32ae.begin(), itConditionalBlock_32bd= _conditionalBlock_32b7.begin(); itSFState_3299!= _sFState_3293.end(), itSFConnectorRef_32a2!= _sFConnectorRef_329c.end(), itSFTransition_32ab!= _sFTransition_32a5.end(), itFunction_32b4!= _function_32ae.end(), itConditionalBlock_32bd!= _conditionalBlock_32b7.end(); ++itSFState_3299, ++itSFConnectorRef_32a2, ++itSFTransition_32ab, ++itFunction_32b4, ++itConditionalBlock_32bd)
	{
		if( ( *itSFState_3299== sFState_3297)&& ( *itSFConnectorRef_32a2== sFConnectorRef_32a0)&& ( *itSFTransition_32ab== sFTransition_32a9)&& ( *itFunction_32b4== function_32b2)&& ( *itConditionalBlock_32bd== conditionalBlock_32bb))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_3293.push_back( sFState_3297);
		_sFConnectorRef_329c.push_back( sFConnectorRef_32a0);
		_sFTransition_32a5.push_back( sFTransition_32a9);
		_function_32ae.push_back( function_32b2);
		_conditionalBlock_32b7.push_back( conditionalBlock_32bb);
	}
	return isUnique;
}

void DstIsJuncRefWithTrans_327e::processInputPackets( const Packets_t& sFStates_327f, const Packets_t& sFConnectorRefs_3282, const Packets_t& sFTransitions_3285, const Packets_t& functions_3288, const Packets_t& conditionalBlocks_328b)
{
	for( Packets_t::const_iterator itSFState_3294= sFStates_327f.begin(), itSFConnectorRef_329d= sFConnectorRefs_3282.begin(), itSFTransition_32a6= sFTransitions_3285.begin(), itFunction_32af= functions_3288.begin(), itConditionalBlock_32b8= conditionalBlocks_328b.begin(); itSFState_3294!= sFStates_327f.end(), itSFConnectorRef_329d!= sFConnectorRefs_3282.end(), itSFTransition_32a6!= sFTransitions_3285.end(), itFunction_32af!= functions_3288.end(), itConditionalBlock_32b8!= conditionalBlocks_328b.end(); ++itSFState_3294, ++itSFConnectorRef_329d, ++itSFTransition_32a6, ++itFunction_32af, ++itConditionalBlock_32b8)
	{
		bool isUnique= isInputUnique( *itSFState_3294, *itSFConnectorRef_329d, *itSFTransition_32a6, *itFunction_32af, *itConditionalBlock_32b8);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_3294, *itSFConnectorRef_329d, *itSFTransition_32a6, *itFunction_32af, *itConditionalBlock_32b8);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_32c7, currMatch.sFConnectorRef_32c8, currMatch.sFTransition_32c9, currMatch.function_32ca, currMatch.conditionalBlock_32cb);
	}
}

bool DstIsJuncRefWithTrans_327e::patternMatcher( const Udm::Object& sFState_3295, const Udm::Object& sFConnectorRef_329e, const Udm::Object& sFTransition_32a7, const Udm::Object& function_32b0, const Udm::Object& conditionalBlock_32b9)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_3295.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_329a= CyberComposition::Simulink::SFState::Cast( sFState_3295);
		if( false== Uml::IsDerivedFrom( sFConnectorRef_329e.type(), CyberComposition::Simulink::SFConnectorRef::meta))
			continue;
		CyberComposition::Simulink::SFConnectorRef sFConnectorRef_32a3= CyberComposition::Simulink::SFConnectorRef::Cast( sFConnectorRef_329e);
		if( false== Uml::IsDerivedFrom( sFTransition_32a7.type(), CyberComposition::Simulink::SFTransition::meta))
			continue;
		CyberComposition::Simulink::SFTransition sFTransition_32ac= CyberComposition::Simulink::SFTransition::Cast( sFTransition_32a7);
		if( false== Uml::IsDerivedFrom( function_32b0.type(), SFC::Function::meta))
			continue;
		SFC::Function function_32b5= SFC::Function::Cast( function_32b0);
		if( false== Uml::IsDerivedFrom( conditionalBlock_32b9.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlock_32be= SFC::ConditionalBlock::Cast( conditionalBlock_32b9);
		CyberComposition::Simulink::SFTransConnector sFJunction_32c0= sFConnectorRef_32a3.ref();
		if( false== Uml::IsDerivedFrom( sFJunction_32c0.type(), CyberComposition::Simulink::SFJunction::meta))
			continue;
		CyberComposition::Simulink::SFJunction sFJunction_32c1= CyberComposition::Simulink::SFJunction::Cast( sFJunction_32c0);
		if( !sFJunction_32c1)
			continue;
		set< CyberComposition::Simulink::SFTransition> sFTransition2s_32c2= sFConnectorRef_32a3.dstTransition();
		for( set< CyberComposition::Simulink::SFTransition>::const_iterator itSFTransition2s_32c3= sFTransition2s_32c2.begin(); itSFTransition2s_32c3!= sFTransition2s_32c2.end(); ++itSFTransition2s_32c3)
		{
			CyberComposition::Simulink::SFTransition currSFTransition2_32c4= *itSFTransition2s_32c3;
			CyberComposition::Simulink::SFTransConnector sFTransConnector_32c5= currSFTransition2_32c4.dstTransition_end();
			Match currMatch;
			currMatch.sFState_32c7= sFState_329a;
			currMatch.sFConnectorRef_32c8= sFConnectorRef_32a3;
			currMatch.sFTransition_32c9= sFTransition_32ac;
			currMatch.function_32ca= function_32b5;
			currMatch.conditionalBlock_32cb= conditionalBlock_32be;
			currMatch.sFJunction_32cc= sFJunction_32c1;
			currMatch.sFTransition2_32cd= currSFTransition2_32c4;
			currMatch.sFTransConnector_32ce= sFTransConnector_32c5;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void DstIsJuncRefWithTrans_327e::outputAppender( const CyberComposition::Simulink::SFState& sFState_32cf, const CyberComposition::Simulink::SFConnectorRef& sFConnectorRef_32d1, const CyberComposition::Simulink::SFTransition& sFTransition_32d3, const SFC::Function& function_32d5, const SFC::ConditionalBlock& conditionalBlock_32d7)
{
	_sFState_328e->push_back( sFState_32cf);
	_sFConnectorRef_328f->push_back( sFConnectorRef_32d1);
	_sFTransition_3290->push_back( sFTransition_32d3);
	_function_3291->push_back( function_32d5);
	_conditionalBlock_3292->push_back( conditionalBlock_32d7);
}

bool DstIsJuncRefWithJuncTrans_32d9::operator()( const Packets_t& sFStates_32da, const Packets_t& sFConnectorRefs_32dd, const Packets_t& sFTransitions_32e0, const Packets_t& functions_32e3, const Packets_t& conditionalBlocks_32e6, Packets_t& sFStates_32dc, Packets_t& sFConnectorRefs_32df, Packets_t& sFTransitions_32e2, Packets_t& functions_32e5, Packets_t& conditionalBlocks_32e8)
{
#ifdef PRINT_INFO
	printLog( "DstIsJuncRefWithJuncTrans_32d9" );
#endif
	_sFState_32e9= &sFStates_32dc;
	_sFConnectorRef_32ea= &sFConnectorRefs_32df;
	_sFTransition_32eb= &sFTransitions_32e2;
	_function_32ec= &functions_32e5;
	_conditionalBlock_32ed= &conditionalBlocks_32e8;
	processInputPackets( sFStates_32da, sFConnectorRefs_32dd, sFTransitions_32e0, functions_32e3, conditionalBlocks_32e6);
	if( false== _matches.empty())
		return true;
	return false;
}

bool DstIsJuncRefWithJuncTrans_32d9::isInputUnique( const Udm::Object& sFState_32f2, const Udm::Object& sFConnectorRef_32fb, const Udm::Object& sFTransition_3304, const Udm::Object& function_330d, const Udm::Object& conditionalBlock_3316)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_32f4= _sFState_32ee.begin(), itSFConnectorRef_32fd= _sFConnectorRef_32f7.begin(), itSFTransition_3306= _sFTransition_3300.begin(), itFunction_330f= _function_3309.begin(), itConditionalBlock_3318= _conditionalBlock_3312.begin(); itSFState_32f4!= _sFState_32ee.end(), itSFConnectorRef_32fd!= _sFConnectorRef_32f7.end(), itSFTransition_3306!= _sFTransition_3300.end(), itFunction_330f!= _function_3309.end(), itConditionalBlock_3318!= _conditionalBlock_3312.end(); ++itSFState_32f4, ++itSFConnectorRef_32fd, ++itSFTransition_3306, ++itFunction_330f, ++itConditionalBlock_3318)
	{
		if( ( *itSFState_32f4== sFState_32f2)&& ( *itSFConnectorRef_32fd== sFConnectorRef_32fb)&& ( *itSFTransition_3306== sFTransition_3304)&& ( *itFunction_330f== function_330d)&& ( *itConditionalBlock_3318== conditionalBlock_3316))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_32ee.push_back( sFState_32f2);
		_sFConnectorRef_32f7.push_back( sFConnectorRef_32fb);
		_sFTransition_3300.push_back( sFTransition_3304);
		_function_3309.push_back( function_330d);
		_conditionalBlock_3312.push_back( conditionalBlock_3316);
	}
	return isUnique;
}

void DstIsJuncRefWithJuncTrans_32d9::processInputPackets( const Packets_t& sFStates_32da, const Packets_t& sFConnectorRefs_32dd, const Packets_t& sFTransitions_32e0, const Packets_t& functions_32e3, const Packets_t& conditionalBlocks_32e6)
{
	for( Packets_t::const_iterator itSFState_32ef= sFStates_32da.begin(), itSFConnectorRef_32f8= sFConnectorRefs_32dd.begin(), itSFTransition_3301= sFTransitions_32e0.begin(), itFunction_330a= functions_32e3.begin(), itConditionalBlock_3313= conditionalBlocks_32e6.begin(); itSFState_32ef!= sFStates_32da.end(), itSFConnectorRef_32f8!= sFConnectorRefs_32dd.end(), itSFTransition_3301!= sFTransitions_32e0.end(), itFunction_330a!= functions_32e3.end(), itConditionalBlock_3313!= conditionalBlocks_32e6.end(); ++itSFState_32ef, ++itSFConnectorRef_32f8, ++itSFTransition_3301, ++itFunction_330a, ++itConditionalBlock_3313)
	{
		bool isUnique= isInputUnique( *itSFState_32ef, *itSFConnectorRef_32f8, *itSFTransition_3301, *itFunction_330a, *itConditionalBlock_3313);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_32ef, *itSFConnectorRef_32f8, *itSFTransition_3301, *itFunction_330a, *itConditionalBlock_3313);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_3322, currMatch.sFConnectorRef_3323, currMatch.sFTransition_3324, currMatch.function_3325, currMatch.conditionalBlock_3326);
	}
}

bool DstIsJuncRefWithJuncTrans_32d9::patternMatcher( const Udm::Object& sFState_32f0, const Udm::Object& sFConnectorRef_32f9, const Udm::Object& sFTransition_3302, const Udm::Object& function_330b, const Udm::Object& conditionalBlock_3314)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_32f0.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_32f5= CyberComposition::Simulink::SFState::Cast( sFState_32f0);
		if( false== Uml::IsDerivedFrom( sFConnectorRef_32f9.type(), CyberComposition::Simulink::SFConnectorRef::meta))
			continue;
		CyberComposition::Simulink::SFConnectorRef sFConnectorRef_32fe= CyberComposition::Simulink::SFConnectorRef::Cast( sFConnectorRef_32f9);
		if( false== Uml::IsDerivedFrom( sFTransition_3302.type(), CyberComposition::Simulink::SFTransition::meta))
			continue;
		CyberComposition::Simulink::SFTransition sFTransition_3307= CyberComposition::Simulink::SFTransition::Cast( sFTransition_3302);
		if( false== Uml::IsDerivedFrom( function_330b.type(), SFC::Function::meta))
			continue;
		SFC::Function function_3310= SFC::Function::Cast( function_330b);
		if( false== Uml::IsDerivedFrom( conditionalBlock_3314.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlock_3319= SFC::ConditionalBlock::Cast( conditionalBlock_3314);
		CyberComposition::Simulink::SFTransConnector sFJunction_331b= sFConnectorRef_32fe.ref();
		if( false== Uml::IsDerivedFrom( sFJunction_331b.type(), CyberComposition::Simulink::SFJunction::meta))
			continue;
		CyberComposition::Simulink::SFJunction sFJunction_331c= CyberComposition::Simulink::SFJunction::Cast( sFJunction_331b);
		if( !sFJunction_331c)
			continue;
		set< CyberComposition::Simulink::SFTransition> sFTransition2s_331d= sFJunction_331c.dstTransition();
		for( set< CyberComposition::Simulink::SFTransition>::const_iterator itSFTransition2s_331e= sFTransition2s_331d.begin(); itSFTransition2s_331e!= sFTransition2s_331d.end(); ++itSFTransition2s_331e)
		{
			CyberComposition::Simulink::SFTransition currSFTransition2_331f= *itSFTransition2s_331e;
			CyberComposition::Simulink::SFTransConnector sFTransConnector_3320= currSFTransition2_331f.dstTransition_end();
			Match currMatch;
			currMatch.sFState_3322= sFState_32f5;
			currMatch.sFConnectorRef_3323= sFConnectorRef_32fe;
			currMatch.sFTransition_3324= sFTransition_3307;
			currMatch.function_3325= function_3310;
			currMatch.conditionalBlock_3326= conditionalBlock_3319;
			currMatch.sFJunction_3327= sFJunction_331c;
			currMatch.sFTransition2_3328= currSFTransition2_331f;
			currMatch.sFTransConnector_3329= sFTransConnector_3320;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void DstIsJuncRefWithJuncTrans_32d9::outputAppender( const CyberComposition::Simulink::SFState& sFState_332a, const CyberComposition::Simulink::SFConnectorRef& sFConnectorRef_332c, const CyberComposition::Simulink::SFTransition& sFTransition_332e, const SFC::Function& function_3330, const SFC::ConditionalBlock& conditionalBlock_3332)
{
	_sFState_32e9->push_back( sFState_332a);
	_sFConnectorRef_32ea->push_back( sFConnectorRef_332c);
	_sFTransition_32eb->push_back( sFTransition_332e);
	_function_32ec->push_back( function_3330);
	_conditionalBlock_32ed->push_back( conditionalBlock_3332);
}

bool DeadEnd_3334::operator()( const Packets_t& sFStates_3335, const Packets_t& sFTransConnectors_3338, const Packets_t& sFTransitions_333b, const Packets_t& functions_333e, const Packets_t& conditionalBlocks_3341, Packets_t& sFStates_3337, Packets_t& sFTransConnectors_333a, Packets_t& sFTransitions_333d, Packets_t& functions_3340, Packets_t& conditionalBlocks_3343)
{
#ifdef PRINT_INFO
	printLog( "DeadEnd_3334" );
#endif
	_sFState_3344= &sFStates_3337;
	_sFTransConnector_3345= &sFTransConnectors_333a;
	_sFTransition_3346= &sFTransitions_333d;
	_function_3347= &functions_3340;
	_conditionalBlock_3348= &conditionalBlocks_3343;
	processInputPackets( sFStates_3335, sFTransConnectors_3338, sFTransitions_333b, functions_333e, conditionalBlocks_3341);
	if( false== _matches.empty())
		return true;
	return false;
}

bool DeadEnd_3334::isInputUnique( const Udm::Object& sFState_334d, const Udm::Object& sFTransConnector_3356, const Udm::Object& sFTransition_335f, const Udm::Object& function_3368, const Udm::Object& conditionalBlock_3371)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_334f= _sFState_3349.begin(), itSFTransConnector_3358= _sFTransConnector_3352.begin(), itSFTransition_3361= _sFTransition_335b.begin(), itFunction_336a= _function_3364.begin(), itConditionalBlock_3373= _conditionalBlock_336d.begin(); itSFState_334f!= _sFState_3349.end(), itSFTransConnector_3358!= _sFTransConnector_3352.end(), itSFTransition_3361!= _sFTransition_335b.end(), itFunction_336a!= _function_3364.end(), itConditionalBlock_3373!= _conditionalBlock_336d.end(); ++itSFState_334f, ++itSFTransConnector_3358, ++itSFTransition_3361, ++itFunction_336a, ++itConditionalBlock_3373)
	{
		if( ( *itSFState_334f== sFState_334d)&& ( *itSFTransConnector_3358== sFTransConnector_3356)&& ( *itSFTransition_3361== sFTransition_335f)&& ( *itFunction_336a== function_3368)&& ( *itConditionalBlock_3373== conditionalBlock_3371))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_3349.push_back( sFState_334d);
		_sFTransConnector_3352.push_back( sFTransConnector_3356);
		_sFTransition_335b.push_back( sFTransition_335f);
		_function_3364.push_back( function_3368);
		_conditionalBlock_336d.push_back( conditionalBlock_3371);
	}
	return isUnique;
}

void DeadEnd_3334::processInputPackets( const Packets_t& sFStates_3335, const Packets_t& sFTransConnectors_3338, const Packets_t& sFTransitions_333b, const Packets_t& functions_333e, const Packets_t& conditionalBlocks_3341)
{
	for( Packets_t::const_iterator itSFState_334a= sFStates_3335.begin(), itSFTransConnector_3353= sFTransConnectors_3338.begin(), itSFTransition_335c= sFTransitions_333b.begin(), itFunction_3365= functions_333e.begin(), itConditionalBlock_336e= conditionalBlocks_3341.begin(); itSFState_334a!= sFStates_3335.end(), itSFTransConnector_3353!= sFTransConnectors_3338.end(), itSFTransition_335c!= sFTransitions_333b.end(), itFunction_3365!= functions_333e.end(), itConditionalBlock_336e!= conditionalBlocks_3341.end(); ++itSFState_334a, ++itSFTransConnector_3353, ++itSFTransition_335c, ++itFunction_3365, ++itConditionalBlock_336e)
	{
		bool isUnique= isInputUnique( *itSFState_334a, *itSFTransConnector_3353, *itSFTransition_335c, *itFunction_3365, *itConditionalBlock_336e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_334a, *itSFTransConnector_3353, *itSFTransition_335c, *itFunction_3365, *itConditionalBlock_336e);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_3377, currMatch.sFTransConnector_3378, currMatch.sFTransition_3379, currMatch.function_337a, currMatch.conditionalBlock_337b);
	}
}

bool DeadEnd_3334::patternMatcher( const Udm::Object& sFState_334b, const Udm::Object& sFTransConnector_3354, const Udm::Object& sFTransition_335d, const Udm::Object& function_3366, const Udm::Object& conditionalBlock_336f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_334b.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_3350= CyberComposition::Simulink::SFState::Cast( sFState_334b);
		if( false== Uml::IsDerivedFrom( sFTransConnector_3354.type(), CyberComposition::Simulink::SFTransConnector::meta))
			continue;
		CyberComposition::Simulink::SFTransConnector sFTransConnector_3359= CyberComposition::Simulink::SFTransConnector::Cast( sFTransConnector_3354);
		if( false== Uml::IsDerivedFrom( sFTransition_335d.type(), CyberComposition::Simulink::SFTransition::meta))
			continue;
		CyberComposition::Simulink::SFTransition sFTransition_3362= CyberComposition::Simulink::SFTransition::Cast( sFTransition_335d);
		if( false== Uml::IsDerivedFrom( function_3366.type(), SFC::Function::meta))
			continue;
		SFC::Function function_336b= SFC::Function::Cast( function_3366);
		if( false== Uml::IsDerivedFrom( conditionalBlock_336f.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlock_3374= SFC::ConditionalBlock::Cast( conditionalBlock_336f);
		Match currMatch;
		currMatch.sFState_3377= sFState_3350;
		currMatch.sFTransConnector_3378= sFTransConnector_3359;
		currMatch.sFTransition_3379= sFTransition_3362;
		currMatch.function_337a= function_336b;
		currMatch.conditionalBlock_337b= conditionalBlock_3374;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void DeadEnd_3334::outputAppender( const CyberComposition::Simulink::SFState& sFState_337c, const CyberComposition::Simulink::SFTransConnector& sFTransConnector_337e, const CyberComposition::Simulink::SFTransition& sFTransition_3380, const SFC::Function& function_3382, const SFC::ConditionalBlock& conditionalBlock_3384)
{
	_sFState_3344->push_back( sFState_337c);
	_sFTransConnector_3345->push_back( sFTransConnector_337e);
	_sFTransition_3346->push_back( sFTransition_3380);
	_function_3347->push_back( function_3382);
	_conditionalBlock_3348->push_back( conditionalBlock_3384);
}

void OrderTransitions_3386::operator()( const Packets_t& sFStates_3387, const Packets_t& sFTransitions_338a, const Packets_t& functions_338d, const Packets_t& compoundStatements_3390, Packets_t& sFStates_3389, Packets_t& sFTransitions_338c, Packets_t& functions_338f, Packets_t& compoundStatements_3392)
{
#ifdef PRINT_INFO
	printLog( "OrderTransitions_3386" );
#endif
	RTTGenerator::Instance()->generateRule(3066, "OrderTransitions");
	_sFState_3393= &sFStates_3389;
	_sFTransition_3394= &sFTransitions_338c;
	_function_3395= &functions_338f;
	_compoundStatement_3396= &compoundStatements_3392;
	processInputPackets( sFStates_3387, sFTransitions_338a, functions_338d, compoundStatements_3390);
	sortOutputs( );
}

bool OrderTransitions_3386::isInputUnique( const Udm::Object& sFState_339b, const Udm::Object& sFTransition_33a4, const Udm::Object& function_33ad, const Udm::Object& compoundStatement_33b6)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_339d= _sFState_3397.begin(), itSFTransition_33a6= _sFTransition_33a0.begin(), itFunction_33af= _function_33a9.begin(), itCompoundStatement_33b8= _compoundStatement_33b2.begin(); itSFState_339d!= _sFState_3397.end(), itSFTransition_33a6!= _sFTransition_33a0.end(), itFunction_33af!= _function_33a9.end(), itCompoundStatement_33b8!= _compoundStatement_33b2.end(); ++itSFState_339d, ++itSFTransition_33a6, ++itFunction_33af, ++itCompoundStatement_33b8)
	{
		if( ( *itSFState_339d== sFState_339b)&& ( *itSFTransition_33a6== sFTransition_33a4)&& ( *itFunction_33af== function_33ad)&& ( *itCompoundStatement_33b8== compoundStatement_33b6))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_3397.push_back( sFState_339b);
		_sFTransition_33a0.push_back( sFTransition_33a4);
		_function_33a9.push_back( function_33ad);
		_compoundStatement_33b2.push_back( compoundStatement_33b6);
	}
	return isUnique;
}

void OrderTransitions_3386::processInputPackets( const Packets_t& sFStates_3387, const Packets_t& sFTransitions_338a, const Packets_t& functions_338d, const Packets_t& compoundStatements_3390)
{
	for( Packets_t::const_iterator itSFState_3398= sFStates_3387.begin(), itSFTransition_33a1= sFTransitions_338a.begin(), itFunction_33aa= functions_338d.begin(), itCompoundStatement_33b3= compoundStatements_3390.begin(); itSFState_3398!= sFStates_3387.end(), itSFTransition_33a1!= sFTransitions_338a.end(), itFunction_33aa!= functions_338d.end(), itCompoundStatement_33b3!= compoundStatements_3390.end(); ++itSFState_3398, ++itSFTransition_33a1, ++itFunction_33aa, ++itCompoundStatement_33b3)
	{
		bool isUnique= isInputUnique( *itSFState_3398, *itSFTransition_33a1, *itFunction_33aa, *itCompoundStatement_33b3);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_3398, *itSFTransition_33a1, *itFunction_33aa, *itCompoundStatement_33b3);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool OrderTransitions_3386::patternMatcher( const Udm::Object& sFState_3399, const Udm::Object& sFTransition_33a2, const Udm::Object& function_33ab, const Udm::Object& compoundStatement_33b4)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_3399.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_339e= CyberComposition::Simulink::SFState::Cast( sFState_3399);
		if( false== Uml::IsDerivedFrom( sFTransition_33a2.type(), CyberComposition::Simulink::SFTransition::meta))
			continue;
		CyberComposition::Simulink::SFTransition sFTransition_33a7= CyberComposition::Simulink::SFTransition::Cast( sFTransition_33a2);
		if( false== Uml::IsDerivedFrom( function_33ab.type(), SFC::Function::meta))
			continue;
		SFC::Function function_33b0= SFC::Function::Cast( function_33ab);
		if( false== Uml::IsDerivedFrom( compoundStatement_33b4.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_33b9= SFC::CompoundStatement::Cast( compoundStatement_33b4);
		Match currMatch;
		currMatch.sFState_33bc= sFState_339e;
		currMatch.sFTransition_33bd= sFTransition_33a7;
		currMatch.function_33be= function_33b0;
		currMatch.compoundStatement_33bf= compoundStatement_33b9;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void OrderTransitions_3386::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_33bc, currMatch.sFTransition_33bd, currMatch.function_33be, currMatch.compoundStatement_33bf);
	}
}

void OrderTransitions_3386::outputAppender( const CyberComposition::Simulink::SFState& sFState_33c0, const CyberComposition::Simulink::SFTransition& sFTransition_33c2, const SFC::Function& function_33c4, const SFC::CompoundStatement& compoundStatement_33c6)
{
	_sFState_3393->push_back( sFState_33c0);
	_sFTransition_3394->push_back( sFTransition_33c2);
	_function_3395->push_back( function_33c4);
	_compoundStatement_3396->push_back( compoundStatement_33c6);
}

void OrderTransitions_3386::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::SFTransition, std::pointer_to_binary_function< const CyberComposition::Simulink::SFTransition&, const CyberComposition::Simulink::SFTransition&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::SFTransition&, const CyberComposition::Simulink::SFTransition&, bool> ptr_TransitionOrder( TransitionOrder< CyberComposition::Simulink::SFTransition>);
	SortedSet_t sortedSet( ptr_TransitionOrder);
	std::vector< int> permutationVector( _sFTransition_3394->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _sFTransition_3394->begin(); it!= _sFTransition_3394->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::SFTransition::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _sFTransition_3394->begin());
	// order rest of the containers
	permutate( permutationVector, *_sFState_3393);
	permutate( permutationVector, *_function_3395);
	permutate( permutationVector, *_compoundStatement_3396);
}

void DeadEndJunction_33c8::operator()( const Packets_t& sFStates_33c9, const Packets_t& sFTransConnectors_33cb, const Packets_t& sFTransitions_33cd, const Packets_t& functions_33cf, const Packets_t& transitionCBs_33d1)
{
#ifdef PRINT_INFO
	printLog( "DeadEndJunction_33c8" );
#endif
	RTTGenerator::Instance()->generateRule(3071, "DeadEndJunction");
	processInputPackets( sFStates_33c9, sFTransConnectors_33cb, sFTransitions_33cd, functions_33cf, transitionCBs_33d1);
}

bool DeadEndJunction_33c8::isInputUnique( const Udm::Object& sFState_33d7, const Udm::Object& sFTransConnector_33e0, const Udm::Object& sFTransition_33e9, const Udm::Object& function_33f2, const Udm::Object& transitionCB_33fb)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_33d9= _sFState_33d3.begin(), itSFTransConnector_33e2= _sFTransConnector_33dc.begin(), itSFTransition_33eb= _sFTransition_33e5.begin(), itFunction_33f4= _function_33ee.begin(), itTransitionCB_33fd= _transitionCB_33f7.begin(); itSFState_33d9!= _sFState_33d3.end(), itSFTransConnector_33e2!= _sFTransConnector_33dc.end(), itSFTransition_33eb!= _sFTransition_33e5.end(), itFunction_33f4!= _function_33ee.end(), itTransitionCB_33fd!= _transitionCB_33f7.end(); ++itSFState_33d9, ++itSFTransConnector_33e2, ++itSFTransition_33eb, ++itFunction_33f4, ++itTransitionCB_33fd)
	{
		if( ( *itSFState_33d9== sFState_33d7)&& ( *itSFTransConnector_33e2== sFTransConnector_33e0)&& ( *itSFTransition_33eb== sFTransition_33e9)&& ( *itFunction_33f4== function_33f2)&& ( *itTransitionCB_33fd== transitionCB_33fb))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_33d3.push_back( sFState_33d7);
		_sFTransConnector_33dc.push_back( sFTransConnector_33e0);
		_sFTransition_33e5.push_back( sFTransition_33e9);
		_function_33ee.push_back( function_33f2);
		_transitionCB_33f7.push_back( transitionCB_33fb);
	}
	return isUnique;
}

bool DeadEndJunction_33c8::isGuardTrue( SFC::Function& Function, CyberComposition::Simulink::SFState& SFState, CyberComposition::Simulink::SFTransConnector& SFTransConnector, CyberComposition::Simulink::SFTransition& SFTransition, SFC::LocalVar& TCVar, SFC::ConditionalBlock& TransitionCB)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( TCVar.name() ) == "_TCVar_";;
	return Gz_guard;
}

void DeadEndJunction_33c8::processInputPackets( const Packets_t& sFStates_33c9, const Packets_t& sFTransConnectors_33cb, const Packets_t& sFTransitions_33cd, const Packets_t& functions_33cf, const Packets_t& transitionCBs_33d1)
{
	for( Packets_t::const_iterator itSFState_33d4= sFStates_33c9.begin(), itSFTransConnector_33dd= sFTransConnectors_33cb.begin(), itSFTransition_33e6= sFTransitions_33cd.begin(), itFunction_33ef= functions_33cf.begin(), itTransitionCB_33f8= transitionCBs_33d1.begin(); itSFState_33d4!= sFStates_33c9.end(), itSFTransConnector_33dd!= sFTransConnectors_33cb.end(), itSFTransition_33e6!= sFTransitions_33cd.end(), itFunction_33ef!= functions_33cf.end(), itTransitionCB_33f8!= transitionCBs_33d1.end(); ++itSFState_33d4, ++itSFTransConnector_33dd, ++itSFTransition_33e6, ++itFunction_33ef, ++itTransitionCB_33f8)
	{
		bool isUnique= isInputUnique( *itSFState_33d4, *itSFTransConnector_33dd, *itSFTransition_33e6, *itFunction_33ef, *itTransitionCB_33f8);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_33d4, *itSFTransConnector_33dd, *itSFTransition_33e6, *itFunction_33ef, *itTransitionCB_33f8);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool DeadEndJunction_33c8::patternMatcher( const Udm::Object& sFState_33d5, const Udm::Object& sFTransConnector_33de, const Udm::Object& sFTransition_33e7, const Udm::Object& function_33f0, const Udm::Object& transitionCB_33f9)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_33d5.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_33da= CyberComposition::Simulink::SFState::Cast( sFState_33d5);
		if( false== Uml::IsDerivedFrom( sFTransConnector_33de.type(), CyberComposition::Simulink::SFTransConnector::meta))
			continue;
		CyberComposition::Simulink::SFTransConnector sFTransConnector_33e3= CyberComposition::Simulink::SFTransConnector::Cast( sFTransConnector_33de);
		if( false== Uml::IsDerivedFrom( sFTransition_33e7.type(), CyberComposition::Simulink::SFTransition::meta))
			continue;
		CyberComposition::Simulink::SFTransition sFTransition_33ec= CyberComposition::Simulink::SFTransition::Cast( sFTransition_33e7);
		if( false== Uml::IsDerivedFrom( function_33f0.type(), SFC::Function::meta))
			continue;
		SFC::Function function_33f5= SFC::Function::Cast( function_33f0);
		if( false== Uml::IsDerivedFrom( transitionCB_33f9.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock transitionCB_33fe= SFC::ConditionalBlock::Cast( transitionCB_33f9);
		set< SFC::LocalVar> tCVars_3400= function_33f5.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itTCVar_3401= tCVars_3400.begin(); itTCVar_3401!= tCVars_3400.end(); ++itTCVar_3401)
		{
			SFC::LocalVar currTCVar_3402= *itTCVar_3401;
			Match currMatch;
			currMatch.sFState_3404= sFState_33da;
			currMatch.sFTransConnector_3405= sFTransConnector_33e3;
			currMatch.sFTransition_3406= sFTransition_33ec;
			currMatch.function_3407= function_33f5;
			currMatch.transitionCB_3408= transitionCB_33fe;
			currMatch.tCVar_3409= currTCVar_3402;
			bool Gz_guard= isGuardTrue( currMatch.function_3407, currMatch.sFState_3404, currMatch.sFTransConnector_3405, currMatch.sFTransition_3406, currMatch.tCVar_3409, currMatch.transitionCB_3408);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void DeadEndJunction_33c8::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newNextJunction_3410= SFC::UserCode::Create( currMatch.transitionCB_3408, SFC::ConditionalBlock::meta_stmnt);
		SFC::BinaryExprs newAssign_3411= SFC::BinaryExprs::Create( newNextJunction_3410, SFC::UserCode::meta_codeexpr);
		SFC::Int newNegOne_3412= SFC::Int::Create( newAssign_3411, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_3413= SFC::ArgDeclRef::Create( newAssign_3411, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_3413;
		SFC::BinaryExprs& Assign= newAssign_3411;
		SFC::Function& Function= currMatch.function_3407;
		SFC::Int& NegOne= newNegOne_3412;
		SFC::UserCode& NextJunction= newNextJunction_3410;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_3404;
		CyberComposition::Simulink::SFTransConnector& SFTransConnector= currMatch.sFTransConnector_3405;
		CyberComposition::Simulink::SFTransition& SFTransition= currMatch.sFTransition_3406;
		SFC::LocalVar& TCVar= currMatch.tCVar_3409;
		SFC::ConditionalBlock& TransitionCB= currMatch.transitionCB_3408;
		{
NextJunction.RefId() = SFTransConnector.RefId();
};
		{
__int64 statementCount = TransitionCB.statementCount();
NextJunction.statementIndex() = statementCount++;
TransitionCB.statementCount() = statementCount;
};
		{
Assign.op() = "=";
NegOne.val() = -1;
};
		newArgDeclRef_3413.argdecl()= currMatch.tCVar_3409;
	}
}

void NextJunction_3414::operator()( const Packets_t& sFStates_3415, const Packets_t& sFJunctions_3418, const Packets_t& sFTransitions_341b, const Packets_t& functions_341d, const Packets_t& transitionCBs_3420, Packets_t& sFStates_3417, Packets_t& sFJunctions_341a, Packets_t& functions_341f, Packets_t& conditionalGroups_3422)
{
#ifdef PRINT_INFO
	printLog( "NextJunction_3414" );
#endif
	RTTGenerator::Instance()->generateRule(3091, "NextJunction");
	_sFState_3423= &sFStates_3417;
	_sFJunction_3424= &sFJunctions_341a;
	_function_3425= &functions_341f;
	_conditionalGroup_3426= &conditionalGroups_3422;
	processInputPackets( sFStates_3415, sFJunctions_3418, sFTransitions_341b, functions_341d, transitionCBs_3420);
}

bool NextJunction_3414::isInputUnique( const Udm::Object& sFState_342b, const Udm::Object& sFJunction_3434, const Udm::Object& sFTransition_343d, const Udm::Object& function_3446, const Udm::Object& transitionCB_344f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_342d= _sFState_3427.begin(), itSFJunction_3436= _sFJunction_3430.begin(), itSFTransition_343f= _sFTransition_3439.begin(), itFunction_3448= _function_3442.begin(), itTransitionCB_3451= _transitionCB_344b.begin(); itSFState_342d!= _sFState_3427.end(), itSFJunction_3436!= _sFJunction_3430.end(), itSFTransition_343f!= _sFTransition_3439.end(), itFunction_3448!= _function_3442.end(), itTransitionCB_3451!= _transitionCB_344b.end(); ++itSFState_342d, ++itSFJunction_3436, ++itSFTransition_343f, ++itFunction_3448, ++itTransitionCB_3451)
	{
		if( ( *itSFState_342d== sFState_342b)&& ( *itSFJunction_3436== sFJunction_3434)&& ( *itSFTransition_343f== sFTransition_343d)&& ( *itFunction_3448== function_3446)&& ( *itTransitionCB_3451== transitionCB_344f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_3427.push_back( sFState_342b);
		_sFJunction_3430.push_back( sFJunction_3434);
		_sFTransition_3439.push_back( sFTransition_343d);
		_function_3442.push_back( function_3446);
		_transitionCB_344b.push_back( transitionCB_344f);
	}
	return isUnique;
}

bool NextJunction_3414::isGuardTrue( SFC::ConditionalBlock& ConditionalBlock, SFC::ConditionalGroup& ConditionalGroup, SFC::Function& Function, CyberComposition::Simulink::SFJunction& SFJunction, CyberComposition::Simulink::SFState& SFState, CyberComposition::Simulink::SFTransition& SFTransition, SFC::LocalVar& TCVar, SFC::ConditionalBlock& TransitionCB, SFC::ConditionalGroup& TransitionCG)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( TCVar.name() ) == "_TCVar_";;
	return Gz_guard;
}

void NextJunction_3414::processInputPackets( const Packets_t& sFStates_3415, const Packets_t& sFJunctions_3418, const Packets_t& sFTransitions_341b, const Packets_t& functions_341d, const Packets_t& transitionCBs_3420)
{
	for( Packets_t::const_iterator itSFState_3428= sFStates_3415.begin(), itSFJunction_3431= sFJunctions_3418.begin(), itSFTransition_343a= sFTransitions_341b.begin(), itFunction_3443= functions_341d.begin(), itTransitionCB_344c= transitionCBs_3420.begin(); itSFState_3428!= sFStates_3415.end(), itSFJunction_3431!= sFJunctions_3418.end(), itSFTransition_343a!= sFTransitions_341b.end(), itFunction_3443!= functions_341d.end(), itTransitionCB_344c!= transitionCBs_3420.end(); ++itSFState_3428, ++itSFJunction_3431, ++itSFTransition_343a, ++itFunction_3443, ++itTransitionCB_344c)
	{
		bool isUnique= isInputUnique( *itSFState_3428, *itSFJunction_3431, *itSFTransition_343a, *itFunction_3443, *itTransitionCB_344c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_3428, *itSFJunction_3431, *itSFTransition_343a, *itFunction_3443, *itTransitionCB_344c);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool NextJunction_3414::patternMatcher( const Udm::Object& sFState_3429, const Udm::Object& sFJunction_3432, const Udm::Object& sFTransition_343b, const Udm::Object& function_3444, const Udm::Object& transitionCB_344d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_3429.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_342e= CyberComposition::Simulink::SFState::Cast( sFState_3429);
		if( false== Uml::IsDerivedFrom( sFJunction_3432.type(), CyberComposition::Simulink::SFJunction::meta))
			continue;
		CyberComposition::Simulink::SFJunction sFJunction_3437= CyberComposition::Simulink::SFJunction::Cast( sFJunction_3432);
		if( false== Uml::IsDerivedFrom( sFTransition_343b.type(), CyberComposition::Simulink::SFTransition::meta))
			continue;
		CyberComposition::Simulink::SFTransition sFTransition_3440= CyberComposition::Simulink::SFTransition::Cast( sFTransition_343b);
		if( false== Uml::IsDerivedFrom( function_3444.type(), SFC::Function::meta))
			continue;
		SFC::Function function_3449= SFC::Function::Cast( function_3444);
		if( false== Uml::IsDerivedFrom( transitionCB_344d.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock transitionCB_3452= SFC::ConditionalBlock::Cast( transitionCB_344d);
		Udm::Object transitionCBParent_3454= transitionCB_3452.container();
		if( false== Uml::IsDerivedFrom( transitionCBParent_3454.type(), SFC::ConditionalGroup::meta))
			continue;
		SFC::ConditionalGroup transitionCGTransitionCB_3455= SFC::ConditionalGroup::Cast( transitionCBParent_3454);
		Udm::Object transitionCGParent_3456= transitionCGTransitionCB_3455.container();
		if( false== Uml::IsDerivedFrom( transitionCGParent_3456.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlockTransitionCG_3457= SFC::ConditionalBlock::Cast( transitionCGParent_3456);
		Udm::Object conditionalBlockParent_3458= conditionalBlockTransitionCG_3457.container();
		if( false== Uml::IsDerivedFrom( conditionalBlockParent_3458.type(), SFC::ConditionalGroup::meta))
			continue;
		SFC::ConditionalGroup conditionalGroupConditionalBlock_3459= SFC::ConditionalGroup::Cast( conditionalBlockParent_3458);
		set< SFC::LocalVar> tCVars_345a= function_3449.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itTCVar_345b= tCVars_345a.begin(); itTCVar_345b!= tCVars_345a.end(); ++itTCVar_345b)
		{
			SFC::LocalVar currTCVar_345c= *itTCVar_345b;
			Match currMatch;
			currMatch.sFState_345e= sFState_342e;
			currMatch.sFJunction_345f= sFJunction_3437;
			currMatch.sFTransition_3460= sFTransition_3440;
			currMatch.function_3461= function_3449;
			currMatch.transitionCB_3462= transitionCB_3452;
			currMatch.tCVar_3463= currTCVar_345c;
			currMatch.conditionalGroup_3464= conditionalGroupConditionalBlock_3459;
			currMatch.transitionCG_3465= transitionCGTransitionCB_3455;
			currMatch.conditionalBlock_3466= conditionalBlockTransitionCG_3457;
			bool Gz_guard= isGuardTrue( currMatch.conditionalBlock_3466, currMatch.conditionalGroup_3464, currMatch.function_3461, currMatch.sFJunction_345f, currMatch.sFState_345e, currMatch.sFTransition_3460, currMatch.tCVar_3463, currMatch.transitionCB_3462, currMatch.transitionCG_3465);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void NextJunction_3414::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newNextJunction_3470= SFC::UserCode::Create( currMatch.transitionCB_3462, SFC::ConditionalBlock::meta_stmnt);
		SFC::BinaryExprs newAssign_3471= SFC::BinaryExprs::Create( newNextJunction_3470, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newArgDeclRef_3472= SFC::ArgDeclRef::Create( newAssign_3471, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newInt_3473= SFC::Int::Create( newAssign_3471, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_3472;
		SFC::BinaryExprs& Assign= newAssign_3471;
		SFC::ConditionalBlock& ConditionalBlock= currMatch.conditionalBlock_3466;
		SFC::ConditionalGroup& ConditionalGroup= currMatch.conditionalGroup_3464;
		SFC::Function& Function= currMatch.function_3461;
		SFC::Int& Int= newInt_3473;
		SFC::UserCode& NextJunction= newNextJunction_3470;
		CyberComposition::Simulink::SFJunction& SFJunction= currMatch.sFJunction_345f;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_345e;
		CyberComposition::Simulink::SFTransition& SFTransition= currMatch.sFTransition_3460;
		SFC::LocalVar& TCVar= currMatch.tCVar_3463;
		SFC::ConditionalBlock& TransitionCB= currMatch.transitionCB_3462;
		SFC::ConditionalGroup& TransitionCG= currMatch.transitionCG_3465;
		{
NextJunction.RefId() = SFJunction.RefId();
};
		{
Assign.op() = "=";

};
		{
__int64 statementCount = TransitionCB.statementCount();
NextJunction.statementIndex() = statementCount++;
TransitionCB.statementCount() = statementCount;
};
		{
Int.val() = SFManager::SFStateTransConnectorMap::get_singleton().getTransConnectorMap( SFState ).getTransConnectorNumber( SFJunction );
};
		newArgDeclRef_3472.argdecl()= currMatch.tCVar_3463;
		outputAppender( currMatch.sFState_345e, currMatch.sFJunction_345f, currMatch.function_3461, currMatch.conditionalGroup_3464);
	}
}

void NextJunction_3414::outputAppender( const CyberComposition::Simulink::SFState& sFState_3474, const CyberComposition::Simulink::SFJunction& sFJunction_3476, const SFC::Function& function_3478, const SFC::ConditionalGroup& conditionalGroup_347a)
{
	_sFState_3423->push_back( sFState_3474);
	_sFJunction_3424->push_back( sFJunction_3476);
	_function_3425->push_back( function_3478);
	_conditionalGroup_3426->push_back( conditionalGroup_347a);
}

void GetDstStateFromRef_347c::operator()( const Packets_t& sFStates_347d, const Packets_t& sFConnectorRefs_3481, const Packets_t& sFTransitions_3483, const Packets_t& functions_3486, const Packets_t& conditionalBlocks_3489, Packets_t& sFStates_347f, Packets_t& sFDstStates_3480, Packets_t& sFTransitions_3485, Packets_t& functions_3488, Packets_t& conditionalBlocks_348b)
{
#ifdef PRINT_INFO
	printLog( "GetDstStateFromRef_347c" );
#endif
	RTTGenerator::Instance()->generateRule(3118, "GetDstStateFromRef");
	_sFState_348c= &sFStates_347f;
	_sFDstState_348d= &sFDstStates_3480;
	_sFTransition_348e= &sFTransitions_3485;
	_function_348f= &functions_3488;
	_conditionalBlock_3490= &conditionalBlocks_348b;
	processInputPackets( sFStates_347d, sFConnectorRefs_3481, sFTransitions_3483, functions_3486, conditionalBlocks_3489);
}

bool GetDstStateFromRef_347c::isInputUnique( const Udm::Object& sFState_3495, const Udm::Object& sFConnectorRef_349e, const Udm::Object& sFTransition_34a7, const Udm::Object& function_34b0, const Udm::Object& conditionalBlock_34b9)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_3497= _sFState_3491.begin(), itSFConnectorRef_34a0= _sFConnectorRef_349a.begin(), itSFTransition_34a9= _sFTransition_34a3.begin(), itFunction_34b2= _function_34ac.begin(), itConditionalBlock_34bb= _conditionalBlock_34b5.begin(); itSFState_3497!= _sFState_3491.end(), itSFConnectorRef_34a0!= _sFConnectorRef_349a.end(), itSFTransition_34a9!= _sFTransition_34a3.end(), itFunction_34b2!= _function_34ac.end(), itConditionalBlock_34bb!= _conditionalBlock_34b5.end(); ++itSFState_3497, ++itSFConnectorRef_34a0, ++itSFTransition_34a9, ++itFunction_34b2, ++itConditionalBlock_34bb)
	{
		if( ( *itSFState_3497== sFState_3495)&& ( *itSFConnectorRef_34a0== sFConnectorRef_349e)&& ( *itSFTransition_34a9== sFTransition_34a7)&& ( *itFunction_34b2== function_34b0)&& ( *itConditionalBlock_34bb== conditionalBlock_34b9))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_3491.push_back( sFState_3495);
		_sFConnectorRef_349a.push_back( sFConnectorRef_349e);
		_sFTransition_34a3.push_back( sFTransition_34a7);
		_function_34ac.push_back( function_34b0);
		_conditionalBlock_34b5.push_back( conditionalBlock_34b9);
	}
	return isUnique;
}

void GetDstStateFromRef_347c::processInputPackets( const Packets_t& sFStates_347d, const Packets_t& sFConnectorRefs_3481, const Packets_t& sFTransitions_3483, const Packets_t& functions_3486, const Packets_t& conditionalBlocks_3489)
{
	for( Packets_t::const_iterator itSFState_3492= sFStates_347d.begin(), itSFConnectorRef_349b= sFConnectorRefs_3481.begin(), itSFTransition_34a4= sFTransitions_3483.begin(), itFunction_34ad= functions_3486.begin(), itConditionalBlock_34b6= conditionalBlocks_3489.begin(); itSFState_3492!= sFStates_347d.end(), itSFConnectorRef_349b!= sFConnectorRefs_3481.end(), itSFTransition_34a4!= sFTransitions_3483.end(), itFunction_34ad!= functions_3486.end(), itConditionalBlock_34b6!= conditionalBlocks_3489.end(); ++itSFState_3492, ++itSFConnectorRef_349b, ++itSFTransition_34a4, ++itFunction_34ad, ++itConditionalBlock_34b6)
	{
		bool isUnique= isInputUnique( *itSFState_3492, *itSFConnectorRef_349b, *itSFTransition_34a4, *itFunction_34ad, *itConditionalBlock_34b6);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_3492, *itSFConnectorRef_349b, *itSFTransition_34a4, *itFunction_34ad, *itConditionalBlock_34b6);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetDstStateFromRef_347c::patternMatcher( const Udm::Object& sFState_3493, const Udm::Object& sFConnectorRef_349c, const Udm::Object& sFTransition_34a5, const Udm::Object& function_34ae, const Udm::Object& conditionalBlock_34b7)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_3493.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_3498= CyberComposition::Simulink::SFState::Cast( sFState_3493);
		if( false== Uml::IsDerivedFrom( sFConnectorRef_349c.type(), CyberComposition::Simulink::SFConnectorRef::meta))
			continue;
		CyberComposition::Simulink::SFConnectorRef sFConnectorRef_34a1= CyberComposition::Simulink::SFConnectorRef::Cast( sFConnectorRef_349c);
		if( false== Uml::IsDerivedFrom( sFTransition_34a5.type(), CyberComposition::Simulink::SFTransition::meta))
			continue;
		CyberComposition::Simulink::SFTransition sFTransition_34aa= CyberComposition::Simulink::SFTransition::Cast( sFTransition_34a5);
		if( false== Uml::IsDerivedFrom( function_34ae.type(), SFC::Function::meta))
			continue;
		SFC::Function function_34b3= SFC::Function::Cast( function_34ae);
		if( false== Uml::IsDerivedFrom( conditionalBlock_34b7.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlock_34bc= SFC::ConditionalBlock::Cast( conditionalBlock_34b7);
		CyberComposition::Simulink::SFTransConnector sFDstState_34be= sFConnectorRef_34a1.ref();
		if( false== Uml::IsDerivedFrom( sFDstState_34be.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFDstState_34bf= CyberComposition::Simulink::SFState::Cast( sFDstState_34be);
		if( !sFDstState_34bf)
			continue;
		Match currMatch;
		currMatch.sFState_34c1= sFState_3498;
		currMatch.sFConnectorRef_34c2= sFConnectorRef_34a1;
		currMatch.sFTransition_34c3= sFTransition_34aa;
		currMatch.function_34c4= function_34b3;
		currMatch.conditionalBlock_34c5= conditionalBlock_34bc;
		currMatch.sFDstState_34c6= sFDstState_34bf;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void GetDstStateFromRef_347c::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_34c1, currMatch.sFDstState_34c6, currMatch.sFTransition_34c3, currMatch.function_34c4, currMatch.conditionalBlock_34c5);
	}
}

void GetDstStateFromRef_347c::outputAppender( const CyberComposition::Simulink::SFState& sFState_34c7, const CyberComposition::Simulink::SFState& sFDstState_34c9, const CyberComposition::Simulink::SFTransition& sFTransition_34cb, const SFC::Function& function_34cd, const SFC::ConditionalBlock& conditionalBlock_34cf)
{
	_sFState_348c->push_back( sFState_34c7);
	_sFDstState_348d->push_back( sFDstState_34c9);
	_sFTransition_348e->push_back( sFTransition_34cb);
	_function_348f->push_back( function_34cd);
	_conditionalBlock_3490->push_back( conditionalBlock_34cf);
}

void ExecNextState_34d1::operator()( const Packets_t& sFStates_34d2, const Packets_t& sFDstStates_34d4, const Packets_t& sFTransitions_34d6, const Packets_t& functions_34d8, const Packets_t& transitionCBs_34da)
{
#ifdef PRINT_INFO
	printLog( "ExecNextState_34d1" );
#endif
	RTTGenerator::Instance()->generateRule(3126, "ExecNextState");
	processInputPackets( sFStates_34d2, sFDstStates_34d4, sFTransitions_34d6, functions_34d8, transitionCBs_34da);
}

bool ExecNextState_34d1::isInputUnique( const Udm::Object& sFState_34e0, const Udm::Object& sFDstState_34e9, const Udm::Object& sFTransition_34f2, const Udm::Object& function_34fb, const Udm::Object& transitionCB_3504)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_34e2= _sFState_34dc.begin(), itSFDstState_34eb= _sFDstState_34e5.begin(), itSFTransition_34f4= _sFTransition_34ee.begin(), itFunction_34fd= _function_34f7.begin(), itTransitionCB_3506= _transitionCB_3500.begin(); itSFState_34e2!= _sFState_34dc.end(), itSFDstState_34eb!= _sFDstState_34e5.end(), itSFTransition_34f4!= _sFTransition_34ee.end(), itFunction_34fd!= _function_34f7.end(), itTransitionCB_3506!= _transitionCB_3500.end(); ++itSFState_34e2, ++itSFDstState_34eb, ++itSFTransition_34f4, ++itFunction_34fd, ++itTransitionCB_3506)
	{
		if( ( *itSFState_34e2== sFState_34e0)&& ( *itSFDstState_34eb== sFDstState_34e9)&& ( *itSFTransition_34f4== sFTransition_34f2)&& ( *itFunction_34fd== function_34fb)&& ( *itTransitionCB_3506== transitionCB_3504))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_34dc.push_back( sFState_34e0);
		_sFDstState_34e5.push_back( sFDstState_34e9);
		_sFTransition_34ee.push_back( sFTransition_34f2);
		_function_34f7.push_back( function_34fb);
		_transitionCB_3500.push_back( transitionCB_3504);
	}
	return isUnique;
}

bool ExecNextState_34d1::isGuardTrue( SFC::Function& Enter, SFC::Arg& EnterArg0, SFC::Arg& EnterArg1, SFC::Function& Exit, SFC::Arg& ExitArg, SFC::Function& Function, SFC::LocalVar& HTPVar, CyberComposition::Simulink::SFState& SFDstState, CyberComposition::Simulink::SFState& SFState, CyberComposition::Simulink::SFTransition& SFTransition, SFC::ConditionalBlock& TransitionCB)
{
	bool Gz_guard= false;
	return static_cast< std::string >( HTPVar.name() ) == "_HTPVar_" && EnterArg0.argIndex() == 0 && EnterArg1.argIndex() == 1;;
	return Gz_guard;
}

void ExecNextState_34d1::processInputPackets( const Packets_t& sFStates_34d2, const Packets_t& sFDstStates_34d4, const Packets_t& sFTransitions_34d6, const Packets_t& functions_34d8, const Packets_t& transitionCBs_34da)
{
	for( Packets_t::const_iterator itSFState_34dd= sFStates_34d2.begin(), itSFDstState_34e6= sFDstStates_34d4.begin(), itSFTransition_34ef= sFTransitions_34d6.begin(), itFunction_34f8= functions_34d8.begin(), itTransitionCB_3501= transitionCBs_34da.begin(); itSFState_34dd!= sFStates_34d2.end(), itSFDstState_34e6!= sFDstStates_34d4.end(), itSFTransition_34ef!= sFTransitions_34d6.end(), itFunction_34f8!= functions_34d8.end(), itTransitionCB_3501!= transitionCBs_34da.end(); ++itSFState_34dd, ++itSFDstState_34e6, ++itSFTransition_34ef, ++itFunction_34f8, ++itTransitionCB_3501)
	{
		bool isUnique= isInputUnique( *itSFState_34dd, *itSFDstState_34e6, *itSFTransition_34ef, *itFunction_34f8, *itTransitionCB_3501);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_34dd, *itSFDstState_34e6, *itSFTransition_34ef, *itFunction_34f8, *itTransitionCB_3501);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ExecNextState_34d1::patternMatcher( const Udm::Object& sFState_34de, const Udm::Object& sFDstState_34e7, const Udm::Object& sFTransition_34f0, const Udm::Object& function_34f9, const Udm::Object& transitionCB_3502)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_34de.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_34e3= CyberComposition::Simulink::SFState::Cast( sFState_34de);
		if( false== Uml::IsDerivedFrom( sFDstState_34e7.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFDstState_34ec= CyberComposition::Simulink::SFState::Cast( sFDstState_34e7);
		if( false== Uml::IsDerivedFrom( sFTransition_34f0.type(), CyberComposition::Simulink::SFTransition::meta))
			continue;
		CyberComposition::Simulink::SFTransition sFTransition_34f5= CyberComposition::Simulink::SFTransition::Cast( sFTransition_34f0);
		if( false== Uml::IsDerivedFrom( function_34f9.type(), SFC::Function::meta))
			continue;
		SFC::Function function_34fe= SFC::Function::Cast( function_34f9);
		if( false== Uml::IsDerivedFrom( transitionCB_3502.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock transitionCB_3507= SFC::ConditionalBlock::Cast( transitionCB_3502);
		set< SFC::LocalVar> hTPVars_3509= function_34fe.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itHTPVar_350a= hTPVars_3509.begin(); itHTPVar_350a!= hTPVars_3509.end(); ++itHTPVar_350a)
		{
			SFC::LocalVar currHTPVar_350b= *itHTPVar_350a;
			set< SFC::Function> exits_350c= sFState_34e3.exit();
			for( set< SFC::Function>::const_iterator itExits_350d= exits_350c.begin(); itExits_350d!= exits_350c.end(); ++itExits_350d)
			{
				SFC::Function currExit_350e= *itExits_350d;
				set< SFC::Arg> exitArgs_350f= currExit_350e.Arg_kind_children();
				for( set< SFC::Arg>::const_iterator itExitArg_3510= exitArgs_350f.begin(); itExitArg_3510!= exitArgs_350f.end(); ++itExitArg_3510)
				{
					SFC::Arg currExitArg_3511= *itExitArg_3510;
					set< SFC::Function> enters_3512= sFDstState_34ec.enter();
					for( set< SFC::Function>::const_iterator itEnters_3513= enters_3512.begin(); itEnters_3513!= enters_3512.end(); ++itEnters_3513)
					{
						SFC::Function currEnter_3514= *itEnters_3513;
						set< SFC::Arg> enterArg0s_3515= currEnter_3514.Arg_kind_children();
						for( set< SFC::Arg>::const_iterator itEnterArg0_3516= enterArg0s_3515.begin(); itEnterArg0_3516!= enterArg0s_3515.end(); ++itEnterArg0_3516)
						{
							SFC::Arg currEnterArg0_3517= *itEnterArg0_3516;
							set< SFC::Arg> enterArg1s_3518= currEnter_3514.Arg_kind_children();
							for( set< SFC::Arg>::const_iterator itEnterArg1_3519= enterArg1s_3518.begin(); itEnterArg1_3519!= enterArg1s_3518.end(); ++itEnterArg1_3519)
							{
								SFC::Arg currEnterArg1_351a= *itEnterArg1_3519;
								Match currMatch;
								currMatch.sFState_351c= sFState_34e3;
								currMatch.sFDstState_351d= sFDstState_34ec;
								currMatch.sFTransition_351e= sFTransition_34f5;
								currMatch.function_351f= function_34fe;
								currMatch.transitionCB_3520= transitionCB_3507;
								currMatch.exitArg_3521= currExitArg_3511;
								currMatch.exit_3522= currExit_350e;
								currMatch.enterArg0_3523= currEnterArg0_3517;
								currMatch.enter_3524= currEnter_3514;
								currMatch.enterArg1_3525= currEnterArg1_351a;
								currMatch.hTPVar_3526= currHTPVar_350b;
								bool Gz_guard= isGuardTrue( currMatch.enter_3524, currMatch.enterArg0_3523, currMatch.enterArg1_3525, currMatch.exit_3522, currMatch.exitArg_3521, currMatch.function_351f, currMatch.hTPVar_3526, currMatch.sFDstState_351d, currMatch.sFState_351c, currMatch.sFTransition_351e, currMatch.transitionCB_3520);
								if( true== Gz_guard)
									_matches.push_back( currMatch);
							}
						}
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void ExecNextState_34d1::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::FunctionCall newExitFunctionCall_3532= SFC::FunctionCall::Create( currMatch.transitionCB_3520, SFC::ConditionalBlock::meta_stmnt);
		SFC::ArgVal newExitArgVal_3533= SFC::ArgVal::Create( newExitFunctionCall_3532);
		SFC::ArgDeclRef newExitArgDeclRef_3534= SFC::ArgDeclRef::Create( newExitArgVal_3533, SFC::ArgVal::meta_argexpr);
		SFC::Return newReturn_3535= SFC::Return::Create( currMatch.transitionCB_3520, SFC::ConditionalBlock::meta_stmnt);
		SFC::FunctionCall newEnterFunctionCall_3536= SFC::FunctionCall::Create( currMatch.transitionCB_3520, SFC::ConditionalBlock::meta_stmnt);
		SFC::ArgVal newEnterArgVal0_3537= SFC::ArgVal::Create( newEnterFunctionCall_3536);
		SFC::Int newZero_3538= SFC::Int::Create( newEnterArgVal0_3537, SFC::ArgVal::meta_argexpr);
		SFC::ArgVal newEnterArgVal1_3539= SFC::ArgVal::Create( newEnterFunctionCall_3536);
		SFC::ArgDeclRef newEnterArgDeclRef_353a= SFC::ArgDeclRef::Create( newEnterArgVal1_3539, SFC::ArgVal::meta_argexpr);
		SFC::Function& Enter= currMatch.enter_3524;
		SFC::Arg& EnterArg0= currMatch.enterArg0_3523;
		SFC::Arg& EnterArg1= currMatch.enterArg1_3525;
		SFC::ArgDeclRef& EnterArgDeclRef= newEnterArgDeclRef_353a;
		SFC::ArgVal& EnterArgVal0= newEnterArgVal0_3537;
		SFC::ArgVal& EnterArgVal1= newEnterArgVal1_3539;
		SFC::FunctionCall& EnterFunctionCall= newEnterFunctionCall_3536;
		SFC::Function& Exit= currMatch.exit_3522;
		SFC::Arg& ExitArg= currMatch.exitArg_3521;
		SFC::ArgDeclRef& ExitArgDeclRef= newExitArgDeclRef_3534;
		SFC::ArgVal& ExitArgVal= newExitArgVal_3533;
		SFC::FunctionCall& ExitFunctionCall= newExitFunctionCall_3532;
		SFC::Function& Function= currMatch.function_351f;
		SFC::LocalVar& HTPVar= currMatch.hTPVar_3526;
		SFC::Return& Return= newReturn_3535;
		CyberComposition::Simulink::SFState& SFDstState= currMatch.sFDstState_351d;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_351c;
		CyberComposition::Simulink::SFTransition& SFTransition= currMatch.sFTransition_351e;
		SFC::ConditionalBlock& TransitionCB= currMatch.transitionCB_3520;
		SFC::Int& Zero= newZero_3538;
		{
EnterFunctionCall.RefId() = ExitFunctionCall.RefId() = Return.RefId() = TransitionCB.RefId();
};
		{
EnterArgVal0.argIndex() = 0;
};
		{
Zero.val() = 0;
};
		{
__int64 statementCount = TransitionCB.statementCount();
ExitFunctionCall.statementIndex() = statementCount++;
TransitionCB.statementCount() = statementCount;

SFManager::mstat2SFC( TransitionCB, SFTransition.Action() );

statementCount = TransitionCB.statementCount();
EnterFunctionCall.statementIndex() = statementCount++;
Return.statementIndex() = statementCount++;
TransitionCB.statementCount() = statementCount;
};
		{
EnterArgVal1.argIndex() = 1;
};
		newEnterArgVal0_3537.arg()+= currMatch.enterArg0_3523;
		newExitFunctionCall_3532.callee()= currMatch.exit_3522;
		newExitArgDeclRef_3534.argdecl()= currMatch.hTPVar_3526;
		newEnterFunctionCall_3536.callee()= currMatch.enter_3524;
		newEnterArgVal1_3539.arg()+= currMatch.enterArg1_3525;
		newEnterArgDeclRef_353a.argdecl()= currMatch.hTPVar_3526;
		newExitArgVal_3533.arg()+= currMatch.exitArg_3521;
	}
}

void GetAllTransitions_3574::operator()( const Packets_t& states_3575, const Packets_t& tcs_3577, const Packets_t& fcns_3579, const Packets_t& css_357b, Packets_t& states_357d, Packets_t& transs_357e, Packets_t& fcns_357f, Packets_t& css_3580)
{
#ifdef PRINT_INFO
	printLog( "GetAllTransitions_3574" );
#endif
	_state_3581= &states_357d;
	_trans_3582= &transs_357e;
	_fcn_3583= &fcns_357f;
	_cs_3584= &css_3580;
	if( ( !states_3575.empty())&& ( !tcs_3577.empty())&& ( !fcns_3579.empty())&& ( !css_357b.empty()))
		callGetTransitionsFromJunctionRefs_3670( states_3575, tcs_3577, fcns_3579, css_357b);
	if( ( !states_3575.empty())&& ( !tcs_3577.empty())&& ( !fcns_3579.empty())&& ( !css_357b.empty()))
		callGetDirectTransitions_3675( states_3575, tcs_3577, fcns_3579, css_357b);
	if( ( !states_3575.empty())&& ( !tcs_3577.empty())&& ( !fcns_3579.empty())&& ( !css_357b.empty()))
		callGetTransitionsFromStateRefs_367a( states_3575, tcs_3577, fcns_3579, css_357b);
}

void GetAllTransitions_3574::callGetTransitionsFromJunctionRefs_3670( const Packets_t& sFStates_3586, const Packets_t& sFJunctions_358a, const Packets_t& functions_358c, const Packets_t& compoundStatements_358f)
{
	Packets_t sFStates_3588;
	Packets_t sFTransitions_3589;
	Packets_t functions_358e;
	Packets_t compoundStatements_3591;
	GetTransitionsFromJunctionRefs_3585 getTransitionsFromJunctionRefs_3585;
	getTransitionsFromJunctionRefs_3585( sFStates_3586, sFJunctions_358a, functions_358c, compoundStatements_358f, sFStates_3588, sFTransitions_3589, functions_358e, compoundStatements_3591);
	_state_3581->insert( _state_3581->end(), sFStates_3588.begin(), sFStates_3588.end());
	_trans_3582->insert( _trans_3582->end(), sFTransitions_3589.begin(), sFTransitions_3589.end());
	_fcn_3583->insert( _fcn_3583->end(), functions_358e.begin(), functions_358e.end());
	_cs_3584->insert( _cs_3584->end(), compoundStatements_3591.begin(), compoundStatements_3591.end());
}

void GetAllTransitions_3574::callGetDirectTransitions_3675( const Packets_t& sFStates_35d2, const Packets_t& sFSrcTransConnectors_35d5, const Packets_t& functions_35d8, const Packets_t& compoundStatements_35db)
{
	Packets_t sFStates_35d4;
	Packets_t sFTransitions_35d7;
	Packets_t functions_35da;
	Packets_t compoundStatements_35dd;
	GetDirectTransitions_35d1 getDirectTransitions_35d1;
	getDirectTransitions_35d1( sFStates_35d2, sFSrcTransConnectors_35d5, functions_35d8, compoundStatements_35db, sFStates_35d4, sFTransitions_35d7, functions_35da, compoundStatements_35dd);
	_state_3581->insert( _state_3581->end(), sFStates_35d4.begin(), sFStates_35d4.end());
	_trans_3582->insert( _trans_3582->end(), sFTransitions_35d7.begin(), sFTransitions_35d7.end());
	_fcn_3583->insert( _fcn_3583->end(), functions_35da.begin(), functions_35da.end());
	_cs_3584->insert( _cs_3584->end(), compoundStatements_35dd.begin(), compoundStatements_35dd.end());
}

void GetAllTransitions_3574::callGetTransitionsFromStateRefs_367a( const Packets_t& sFStates_361a, const Packets_t& sFTCStates_361e, const Packets_t& functions_3620, const Packets_t& compoundStatements_3623)
{
	Packets_t sFStates_361c;
	Packets_t sFTransitions_361d;
	Packets_t functions_3622;
	Packets_t compoundStatements_3625;
	GetTransitionsFromStateRefs_3619 getTransitionsFromStateRefs_3619;
	getTransitionsFromStateRefs_3619( sFStates_361a, sFTCStates_361e, functions_3620, compoundStatements_3623, sFStates_361c, sFTransitions_361d, functions_3622, compoundStatements_3625);
	_state_3581->insert( _state_3581->end(), sFStates_361c.begin(), sFStates_361c.end());
	_trans_3582->insert( _trans_3582->end(), sFTransitions_361d.begin(), sFTransitions_361d.end());
	_fcn_3583->insert( _fcn_3583->end(), functions_3622.begin(), functions_3622.end());
	_cs_3584->insert( _cs_3584->end(), compoundStatements_3625.begin(), compoundStatements_3625.end());
}

void GetTransitionsFromJunctionRefs_3585::operator()( const Packets_t& sFStates_3586, const Packets_t& sFJunctions_358a, const Packets_t& functions_358c, const Packets_t& compoundStatements_358f, Packets_t& sFStates_3588, Packets_t& sFTransitions_3589, Packets_t& functions_358e, Packets_t& compoundStatements_3591)
{
#ifdef PRINT_INFO
	printLog( "GetTransitionsFromJunctionRefs_3585" );
#endif
	RTTGenerator::Instance()->generateRule(3183, "GetTransitionsFromJunctionRefs");
	_sFState_3592= &sFStates_3588;
	_sFTransition_3593= &sFTransitions_3589;
	_function_3594= &functions_358e;
	_compoundStatement_3595= &compoundStatements_3591;
	processInputPackets( sFStates_3586, sFJunctions_358a, functions_358c, compoundStatements_358f);
}

bool GetTransitionsFromJunctionRefs_3585::isInputUnique( const Udm::Object& sFState_359a, const Udm::Object& sFJunction_35a3, const Udm::Object& function_35ac, const Udm::Object& compoundStatement_35b5)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_359c= _sFState_3596.begin(), itSFJunction_35a5= _sFJunction_359f.begin(), itFunction_35ae= _function_35a8.begin(), itCompoundStatement_35b7= _compoundStatement_35b1.begin(); itSFState_359c!= _sFState_3596.end(), itSFJunction_35a5!= _sFJunction_359f.end(), itFunction_35ae!= _function_35a8.end(), itCompoundStatement_35b7!= _compoundStatement_35b1.end(); ++itSFState_359c, ++itSFJunction_35a5, ++itFunction_35ae, ++itCompoundStatement_35b7)
	{
		if( ( *itSFState_359c== sFState_359a)&& ( *itSFJunction_35a5== sFJunction_35a3)&& ( *itFunction_35ae== function_35ac)&& ( *itCompoundStatement_35b7== compoundStatement_35b5))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_3596.push_back( sFState_359a);
		_sFJunction_359f.push_back( sFJunction_35a3);
		_function_35a8.push_back( function_35ac);
		_compoundStatement_35b1.push_back( compoundStatement_35b5);
	}
	return isUnique;
}

void GetTransitionsFromJunctionRefs_3585::processInputPackets( const Packets_t& sFStates_3586, const Packets_t& sFJunctions_358a, const Packets_t& functions_358c, const Packets_t& compoundStatements_358f)
{
	for( Packets_t::const_iterator itSFState_3597= sFStates_3586.begin(), itSFJunction_35a0= sFJunctions_358a.begin(), itFunction_35a9= functions_358c.begin(), itCompoundStatement_35b2= compoundStatements_358f.begin(); itSFState_3597!= sFStates_3586.end(), itSFJunction_35a0!= sFJunctions_358a.end(), itFunction_35a9!= functions_358c.end(), itCompoundStatement_35b2!= compoundStatements_358f.end(); ++itSFState_3597, ++itSFJunction_35a0, ++itFunction_35a9, ++itCompoundStatement_35b2)
	{
		bool isUnique= isInputUnique( *itSFState_3597, *itSFJunction_35a0, *itFunction_35a9, *itCompoundStatement_35b2);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_3597, *itSFJunction_35a0, *itFunction_35a9, *itCompoundStatement_35b2);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetTransitionsFromJunctionRefs_3585::patternMatcher( const Udm::Object& sFState_3598, const Udm::Object& sFJunction_35a1, const Udm::Object& function_35aa, const Udm::Object& compoundStatement_35b3)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_3598.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_359d= CyberComposition::Simulink::SFState::Cast( sFState_3598);
		if( false== Uml::IsDerivedFrom( sFJunction_35a1.type(), CyberComposition::Simulink::SFJunction::meta))
			continue;
		CyberComposition::Simulink::SFJunction sFJunction_35a6= CyberComposition::Simulink::SFJunction::Cast( sFJunction_35a1);
		if( false== Uml::IsDerivedFrom( function_35aa.type(), SFC::Function::meta))
			continue;
		SFC::Function function_35af= SFC::Function::Cast( function_35aa);
		if( false== Uml::IsDerivedFrom( compoundStatement_35b3.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_35b8= SFC::CompoundStatement::Cast( compoundStatement_35b3);
		set< CyberComposition::Simulink::SFConnectorRef> sFConnectorRefs_35ba= sFJunction_35a6.referedbyConnectorRef();
		for( set< CyberComposition::Simulink::SFConnectorRef>::const_iterator itSFConnectorRefs_35bb= sFConnectorRefs_35ba.begin(); itSFConnectorRefs_35bb!= sFConnectorRefs_35ba.end(); ++itSFConnectorRefs_35bb)
		{
			CyberComposition::Simulink::SFConnectorRef currSFConnectorRef_35bc= *itSFConnectorRefs_35bb;
			set< CyberComposition::Simulink::SFTransition> sFTransitions_35bd= currSFConnectorRef_35bc.dstTransition();
			for( set< CyberComposition::Simulink::SFTransition>::const_iterator itSFTransitions_35be= sFTransitions_35bd.begin(); itSFTransitions_35be!= sFTransitions_35bd.end(); ++itSFTransitions_35be)
			{
				CyberComposition::Simulink::SFTransition currSFTransition_35bf= *itSFTransitions_35be;
				CyberComposition::Simulink::SFTransConnector sFDstTransConnector_35c0= currSFTransition_35bf.dstTransition_end();
				Match currMatch;
				currMatch.sFState_35c2= sFState_359d;
				currMatch.sFJunction_35c3= sFJunction_35a6;
				currMatch.function_35c4= function_35af;
				currMatch.compoundStatement_35c5= compoundStatement_35b8;
				currMatch.sFTransition_35c6= currSFTransition_35bf;
				currMatch.sFConnectorRef_35c7= currSFConnectorRef_35bc;
				currMatch.sFDstTransConnector_35c8= sFDstTransConnector_35c0;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetTransitionsFromJunctionRefs_3585::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_35c2, currMatch.sFTransition_35c6, currMatch.function_35c4, currMatch.compoundStatement_35c5);
	}
}

void GetTransitionsFromJunctionRefs_3585::outputAppender( const CyberComposition::Simulink::SFState& sFState_35c9, const CyberComposition::Simulink::SFTransition& sFTransition_35cb, const SFC::Function& function_35cd, const SFC::CompoundStatement& compoundStatement_35cf)
{
	_sFState_3592->push_back( sFState_35c9);
	_sFTransition_3593->push_back( sFTransition_35cb);
	_function_3594->push_back( function_35cd);
	_compoundStatement_3595->push_back( compoundStatement_35cf);
}

void GetDirectTransitions_35d1::operator()( const Packets_t& sFStates_35d2, const Packets_t& sFSrcTransConnectors_35d5, const Packets_t& functions_35d8, const Packets_t& compoundStatements_35db, Packets_t& sFStates_35d4, Packets_t& sFTransitions_35d7, Packets_t& functions_35da, Packets_t& compoundStatements_35dd)
{
#ifdef PRINT_INFO
	printLog( "GetDirectTransitions_35d1" );
#endif
	RTTGenerator::Instance()->generateRule(3194, "GetDirectTransitions");
	_sFState_35de= &sFStates_35d4;
	_sFTransition_35df= &sFTransitions_35d7;
	_function_35e0= &functions_35da;
	_compoundStatement_35e1= &compoundStatements_35dd;
	processInputPackets( sFStates_35d2, sFSrcTransConnectors_35d5, functions_35d8, compoundStatements_35db);
}

bool GetDirectTransitions_35d1::isInputUnique( const Udm::Object& sFState_35e6, const Udm::Object& sFSrcTransConnector_35ef, const Udm::Object& function_35f8, const Udm::Object& compoundStatement_3601)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_35e8= _sFState_35e2.begin(), itSFSrcTransConnector_35f1= _sFSrcTransConnector_35eb.begin(), itFunction_35fa= _function_35f4.begin(), itCompoundStatement_3603= _compoundStatement_35fd.begin(); itSFState_35e8!= _sFState_35e2.end(), itSFSrcTransConnector_35f1!= _sFSrcTransConnector_35eb.end(), itFunction_35fa!= _function_35f4.end(), itCompoundStatement_3603!= _compoundStatement_35fd.end(); ++itSFState_35e8, ++itSFSrcTransConnector_35f1, ++itFunction_35fa, ++itCompoundStatement_3603)
	{
		if( ( *itSFState_35e8== sFState_35e6)&& ( *itSFSrcTransConnector_35f1== sFSrcTransConnector_35ef)&& ( *itFunction_35fa== function_35f8)&& ( *itCompoundStatement_3603== compoundStatement_3601))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_35e2.push_back( sFState_35e6);
		_sFSrcTransConnector_35eb.push_back( sFSrcTransConnector_35ef);
		_function_35f4.push_back( function_35f8);
		_compoundStatement_35fd.push_back( compoundStatement_3601);
	}
	return isUnique;
}

void GetDirectTransitions_35d1::processInputPackets( const Packets_t& sFStates_35d2, const Packets_t& sFSrcTransConnectors_35d5, const Packets_t& functions_35d8, const Packets_t& compoundStatements_35db)
{
	for( Packets_t::const_iterator itSFState_35e3= sFStates_35d2.begin(), itSFSrcTransConnector_35ec= sFSrcTransConnectors_35d5.begin(), itFunction_35f5= functions_35d8.begin(), itCompoundStatement_35fe= compoundStatements_35db.begin(); itSFState_35e3!= sFStates_35d2.end(), itSFSrcTransConnector_35ec!= sFSrcTransConnectors_35d5.end(), itFunction_35f5!= functions_35d8.end(), itCompoundStatement_35fe!= compoundStatements_35db.end(); ++itSFState_35e3, ++itSFSrcTransConnector_35ec, ++itFunction_35f5, ++itCompoundStatement_35fe)
	{
		bool isUnique= isInputUnique( *itSFState_35e3, *itSFSrcTransConnector_35ec, *itFunction_35f5, *itCompoundStatement_35fe);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_35e3, *itSFSrcTransConnector_35ec, *itFunction_35f5, *itCompoundStatement_35fe);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetDirectTransitions_35d1::patternMatcher( const Udm::Object& sFState_35e4, const Udm::Object& sFSrcTransConnector_35ed, const Udm::Object& function_35f6, const Udm::Object& compoundStatement_35ff)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_35e4.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_35e9= CyberComposition::Simulink::SFState::Cast( sFState_35e4);
		if( false== Uml::IsDerivedFrom( sFSrcTransConnector_35ed.type(), CyberComposition::Simulink::SFTransConnector::meta))
			continue;
		CyberComposition::Simulink::SFTransConnector sFSrcTransConnector_35f2= CyberComposition::Simulink::SFTransConnector::Cast( sFSrcTransConnector_35ed);
		if( false== Uml::IsDerivedFrom( function_35f6.type(), SFC::Function::meta))
			continue;
		SFC::Function function_35fb= SFC::Function::Cast( function_35f6);
		if( false== Uml::IsDerivedFrom( compoundStatement_35ff.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_3604= SFC::CompoundStatement::Cast( compoundStatement_35ff);
		set< CyberComposition::Simulink::SFTransition> sFTransitions_3606= sFSrcTransConnector_35f2.dstTransition();
		for( set< CyberComposition::Simulink::SFTransition>::const_iterator itSFTransitions_3607= sFTransitions_3606.begin(); itSFTransitions_3607!= sFTransitions_3606.end(); ++itSFTransitions_3607)
		{
			CyberComposition::Simulink::SFTransition currSFTransition_3608= *itSFTransitions_3607;
			CyberComposition::Simulink::SFTransConnector sFDstTransConnector_3609= currSFTransition_3608.dstTransition_end();
			Match currMatch;
			currMatch.sFState_360b= sFState_35e9;
			currMatch.sFSrcTransConnector_360c= sFSrcTransConnector_35f2;
			currMatch.function_360d= function_35fb;
			currMatch.compoundStatement_360e= compoundStatement_3604;
			currMatch.sFTransition_360f= currSFTransition_3608;
			currMatch.sFDstTransConnector_3610= sFDstTransConnector_3609;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetDirectTransitions_35d1::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_360b, currMatch.sFTransition_360f, currMatch.function_360d, currMatch.compoundStatement_360e);
	}
}

void GetDirectTransitions_35d1::outputAppender( const CyberComposition::Simulink::SFState& sFState_3611, const CyberComposition::Simulink::SFTransition& sFTransition_3613, const SFC::Function& function_3615, const SFC::CompoundStatement& compoundStatement_3617)
{
	_sFState_35de->push_back( sFState_3611);
	_sFTransition_35df->push_back( sFTransition_3613);
	_function_35e0->push_back( function_3615);
	_compoundStatement_35e1->push_back( compoundStatement_3617);
}

void GetTransitionsFromStateRefs_3619::operator()( const Packets_t& sFStates_361a, const Packets_t& sFTCStates_361e, const Packets_t& functions_3620, const Packets_t& compoundStatements_3623, Packets_t& sFStates_361c, Packets_t& sFTransitions_361d, Packets_t& functions_3622, Packets_t& compoundStatements_3625)
{
#ifdef PRINT_INFO
	printLog( "GetTransitionsFromStateRefs_3619" );
#endif
	RTTGenerator::Instance()->generateRule(3203, "GetTransitionsFromStateRefs");
	_sFState_3626= &sFStates_361c;
	_sFTransition_3627= &sFTransitions_361d;
	_function_3628= &functions_3622;
	_compoundStatement_3629= &compoundStatements_3625;
	processInputPackets( sFStates_361a, sFTCStates_361e, functions_3620, compoundStatements_3623);
}

bool GetTransitionsFromStateRefs_3619::isInputUnique( const Udm::Object& sFState_362e, const Udm::Object& sFTCState_3637, const Udm::Object& function_3640, const Udm::Object& compoundStatement_3649)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_3630= _sFState_362a.begin(), itSFTCState_3639= _sFTCState_3633.begin(), itFunction_3642= _function_363c.begin(), itCompoundStatement_364b= _compoundStatement_3645.begin(); itSFState_3630!= _sFState_362a.end(), itSFTCState_3639!= _sFTCState_3633.end(), itFunction_3642!= _function_363c.end(), itCompoundStatement_364b!= _compoundStatement_3645.end(); ++itSFState_3630, ++itSFTCState_3639, ++itFunction_3642, ++itCompoundStatement_364b)
	{
		if( ( *itSFState_3630== sFState_362e)&& ( *itSFTCState_3639== sFTCState_3637)&& ( *itFunction_3642== function_3640)&& ( *itCompoundStatement_364b== compoundStatement_3649))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_362a.push_back( sFState_362e);
		_sFTCState_3633.push_back( sFTCState_3637);
		_function_363c.push_back( function_3640);
		_compoundStatement_3645.push_back( compoundStatement_3649);
	}
	return isUnique;
}

bool GetTransitionsFromStateRefs_3619::isGuardTrue( SFC::CompoundStatement& CompoundStatement, SFC::Function& Function, CyberComposition::Simulink::SFConnectorRef& SFConnectorRef, CyberComposition::Simulink::SFTransConnector& SFDstTransConnector, CyberComposition::Simulink::SFState& SFRefParentState, CyberComposition::Simulink::SFState& SFState, CyberComposition::Simulink::SFState& SFTCState, CyberComposition::Simulink::SFTransition& SFTransition)
{
	bool Gz_guard= false;
	return SFState != SFRefParentState;;
	return Gz_guard;
}

void GetTransitionsFromStateRefs_3619::processInputPackets( const Packets_t& sFStates_361a, const Packets_t& sFTCStates_361e, const Packets_t& functions_3620, const Packets_t& compoundStatements_3623)
{
	for( Packets_t::const_iterator itSFState_362b= sFStates_361a.begin(), itSFTCState_3634= sFTCStates_361e.begin(), itFunction_363d= functions_3620.begin(), itCompoundStatement_3646= compoundStatements_3623.begin(); itSFState_362b!= sFStates_361a.end(), itSFTCState_3634!= sFTCStates_361e.end(), itFunction_363d!= functions_3620.end(), itCompoundStatement_3646!= compoundStatements_3623.end(); ++itSFState_362b, ++itSFTCState_3634, ++itFunction_363d, ++itCompoundStatement_3646)
	{
		bool isUnique= isInputUnique( *itSFState_362b, *itSFTCState_3634, *itFunction_363d, *itCompoundStatement_3646);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_362b, *itSFTCState_3634, *itFunction_363d, *itCompoundStatement_3646);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetTransitionsFromStateRefs_3619::patternMatcher( const Udm::Object& sFState_362c, const Udm::Object& sFTCState_3635, const Udm::Object& function_363e, const Udm::Object& compoundStatement_3647)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_362c.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_3631= CyberComposition::Simulink::SFState::Cast( sFState_362c);
		if( false== Uml::IsDerivedFrom( sFTCState_3635.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFTCState_363a= CyberComposition::Simulink::SFState::Cast( sFTCState_3635);
		if( false== Uml::IsDerivedFrom( function_363e.type(), SFC::Function::meta))
			continue;
		SFC::Function function_3643= SFC::Function::Cast( function_363e);
		if( false== Uml::IsDerivedFrom( compoundStatement_3647.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_364c= SFC::CompoundStatement::Cast( compoundStatement_3647);
		set< CyberComposition::Simulink::SFConnectorRef> sFConnectorRefs_364e= sFState_3631.referedbyConnectorRef();
		for( set< CyberComposition::Simulink::SFConnectorRef>::const_iterator itSFConnectorRefs_364f= sFConnectorRefs_364e.begin(); itSFConnectorRefs_364f!= sFConnectorRefs_364e.end(); ++itSFConnectorRefs_364f)
		{
			CyberComposition::Simulink::SFConnectorRef currSFConnectorRef_3650= *itSFConnectorRefs_364f;
			Udm::Object sFConnectorRefParent_3651= currSFConnectorRef_3650.container();
			if( false== Uml::IsDerivedFrom( sFConnectorRefParent_3651.type(), CyberComposition::Simulink::SFState::meta))
				continue;
			CyberComposition::Simulink::SFState sFRefParentStateSFConnectorRef_3652= CyberComposition::Simulink::SFState::Cast( sFConnectorRefParent_3651);
			set< CyberComposition::Simulink::SFTransition> sFTransitions_3653= currSFConnectorRef_3650.dstTransition();
			for( set< CyberComposition::Simulink::SFTransition>::const_iterator itSFTransitions_3654= sFTransitions_3653.begin(); itSFTransitions_3654!= sFTransitions_3653.end(); ++itSFTransitions_3654)
			{
				CyberComposition::Simulink::SFTransition currSFTransition_3655= *itSFTransitions_3654;
				CyberComposition::Simulink::SFTransConnector sFDstTransConnector_3656= currSFTransition_3655.dstTransition_end();
				Match currMatch;
				currMatch.sFState_3658= sFState_3631;
				currMatch.sFTCState_3659= sFTCState_363a;
				currMatch.function_365a= function_3643;
				currMatch.compoundStatement_365b= compoundStatement_364c;
				currMatch.sFRefParentState_365c= sFRefParentStateSFConnectorRef_3652;
				currMatch.sFTransition_365d= currSFTransition_3655;
				currMatch.sFConnectorRef_365e= currSFConnectorRef_3650;
				currMatch.sFDstTransConnector_365f= sFDstTransConnector_3656;
				bool Gz_guard= isGuardTrue( currMatch.compoundStatement_365b, currMatch.function_365a, currMatch.sFConnectorRef_365e, currMatch.sFDstTransConnector_365f, currMatch.sFRefParentState_365c, currMatch.sFState_3658, currMatch.sFTCState_3659, currMatch.sFTransition_365d);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetTransitionsFromStateRefs_3619::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_3658, currMatch.sFTransition_365d, currMatch.function_365a, currMatch.compoundStatement_365b);
	}
}

void GetTransitionsFromStateRefs_3619::outputAppender( const CyberComposition::Simulink::SFState& sFState_3668, const CyberComposition::Simulink::SFTransition& sFTransition_366a, const SFC::Function& function_366c, const SFC::CompoundStatement& compoundStatement_366e)
{
	_sFState_3626->push_back( sFState_3668);
	_sFTransition_3627->push_back( sFTransition_366a);
	_function_3628->push_back( function_366c);
	_compoundStatement_3629->push_back( compoundStatement_366e);
}

void ProcessedFilter_3689::operator()( const Packets_t& states_368a, const Packets_t& tcs_368c, const Packets_t& fcns_368e, const Packets_t& cgs_3690, Packets_t& states_3692, Packets_t& tcs_3693, Packets_t& fcns_3694, Packets_t& cgs_3695)
{
#ifdef PRINT_INFO
	printLog( "ProcessedFilter_3689" );
#endif
	_state_3696= &states_3692;
	_tc_3697= &tcs_3693;
	_fcn_3698= &fcns_3694;
	_cg_3699= &cgs_3695;
	for( Packets_t::const_iterator itstate_369b= states_368a.begin(), ittc_36a2= tcs_368c.begin(), itfcn_36a9= fcns_368e.begin(), itcg_36b0= cgs_3690.begin(); itstate_369b!= states_368a.end(), ittc_36a2!= tcs_368c.end(), itfcn_36a9!= fcns_368e.end(), itcg_36b0!= cgs_3690.end(); ++itstate_369b, ++ittc_36a2, ++itfcn_36a9, ++itcg_36b0)
	{
		bool isUnique= isInputUnique( *itstate_369b, *ittc_36a2, *itfcn_36a9, *itcg_36b0);
		if( !isUnique)
			continue;
		Packets_t onestate_369f( 1, *itstate_369b);
		Packets_t onetc_36a6( 1, *ittc_36a2);
		Packets_t onefcn_36ad( 1, *itfcn_36a9);
		Packets_t onecg_36b4( 1, *itcg_36b0);
		executeOne( onestate_369f, onetc_36a6, onefcn_36ad, onecg_36b4);
	}
}

void ProcessedFilter_3689::executeOne( const Packets_t& states_368a, const Packets_t& tcs_368c, const Packets_t& fcns_368e, const Packets_t& cgs_3690)
{
	Packets_t sFStates_36b9;
	Packets_t sFTransConnectors_36bc;
	Packets_t functions_36bf;
	Packets_t conditionalGroups_36c2;
	TCNotProcessed_36b6 tCNotProcessed_36b6;
	bool isMatchTCNotProcessed_36b6= tCNotProcessed_36b6( states_368a, tcs_368c, fcns_368e, cgs_3690, sFStates_36b9, sFTransConnectors_36bc, functions_36bf, conditionalGroups_36c2);
	_state_3696->insert( _state_3696->end(), sFStates_36b9.begin(), sFStates_36b9.end());
	_tc_3697->insert( _tc_3697->end(), sFTransConnectors_36bc.begin(), sFTransConnectors_36bc.end());
	_fcn_3698->insert( _fcn_3698->end(), functions_36bf.begin(), functions_36bf.end());
	_cg_3699->insert( _cg_3699->end(), conditionalGroups_36c2.begin(), conditionalGroups_36c2.end());
	if( isMatchTCNotProcessed_36b6)
		return;
}

bool ProcessedFilter_3689::isInputUnique( const Udm::Object& state_369c, const Udm::Object& tc_36a3, const Udm::Object& fcn_36aa, const Udm::Object& cg_36b1)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_369e= _state_369a.begin(), ittc_36a5= _tc_36a1.begin(), itfcn_36ac= _fcn_36a8.begin(), itcg_36b3= _cg_36af.begin(); itstate_369e!= _state_369a.end(), ittc_36a5!= _tc_36a1.end(), itfcn_36ac!= _fcn_36a8.end(), itcg_36b3!= _cg_36af.end(); ++itstate_369e, ++ittc_36a5, ++itfcn_36ac, ++itcg_36b3)
	{
		if( ( *itstate_369e== state_369c)&& ( *ittc_36a5== tc_36a3)&& ( *itfcn_36ac== fcn_36aa)&& ( *itcg_36b3== cg_36b1))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_369a.push_back( state_369c);
		_tc_36a1.push_back( tc_36a3);
		_fcn_36a8.push_back( fcn_36aa);
		_cg_36af.push_back( cg_36b1);
	}
	return isUnique;
}

bool TCNotProcessed_36b6::operator()( const Packets_t& sFStates_36b7, const Packets_t& sFTransConnectors_36ba, const Packets_t& functions_36bd, const Packets_t& conditionalGroups_36c0, Packets_t& sFStates_36b9, Packets_t& sFTransConnectors_36bc, Packets_t& functions_36bf, Packets_t& conditionalGroups_36c2)
{
#ifdef PRINT_INFO
	printLog( "TCNotProcessed_36b6" );
#endif
	_sFState_36c3= &sFStates_36b9;
	_sFTransConnector_36c4= &sFTransConnectors_36bc;
	_function_36c5= &functions_36bf;
	_conditionalGroup_36c6= &conditionalGroups_36c2;
	processInputPackets( sFStates_36b7, sFTransConnectors_36ba, functions_36bd, conditionalGroups_36c0);
	if( false== _matches.empty())
		return true;
	return false;
}

bool TCNotProcessed_36b6::isInputUnique( const Udm::Object& sFState_36cb, const Udm::Object& sFTransConnector_36d4, const Udm::Object& function_36dd, const Udm::Object& conditionalGroup_36e6)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_36cd= _sFState_36c7.begin(), itSFTransConnector_36d6= _sFTransConnector_36d0.begin(), itFunction_36df= _function_36d9.begin(), itConditionalGroup_36e8= _conditionalGroup_36e2.begin(); itSFState_36cd!= _sFState_36c7.end(), itSFTransConnector_36d6!= _sFTransConnector_36d0.end(), itFunction_36df!= _function_36d9.end(), itConditionalGroup_36e8!= _conditionalGroup_36e2.end(); ++itSFState_36cd, ++itSFTransConnector_36d6, ++itFunction_36df, ++itConditionalGroup_36e8)
	{
		if( ( *itSFState_36cd== sFState_36cb)&& ( *itSFTransConnector_36d6== sFTransConnector_36d4)&& ( *itFunction_36df== function_36dd)&& ( *itConditionalGroup_36e8== conditionalGroup_36e6))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_36c7.push_back( sFState_36cb);
		_sFTransConnector_36d0.push_back( sFTransConnector_36d4);
		_function_36d9.push_back( function_36dd);
		_conditionalGroup_36e2.push_back( conditionalGroup_36e6);
	}
	return isUnique;
}

bool TCNotProcessed_36b6::isGuardTrue( SFC::ConditionalGroup& ConditionalGroup, SFC::Function& Function, CyberComposition::Simulink::SFState& SFState, CyberComposition::Simulink::SFTransConnector& SFTransConnector)
{
	bool Gz_guard= false;
	return !SFManager::SFStateTransConnectorMap::get_singleton().getTransConnectorMap( SFState ).getIsTransConnectorProcessed( SFTransConnector );;
	return Gz_guard;
}

void TCNotProcessed_36b6::processInputPackets( const Packets_t& sFStates_36b7, const Packets_t& sFTransConnectors_36ba, const Packets_t& functions_36bd, const Packets_t& conditionalGroups_36c0)
{
	for( Packets_t::const_iterator itSFState_36c8= sFStates_36b7.begin(), itSFTransConnector_36d1= sFTransConnectors_36ba.begin(), itFunction_36da= functions_36bd.begin(), itConditionalGroup_36e3= conditionalGroups_36c0.begin(); itSFState_36c8!= sFStates_36b7.end(), itSFTransConnector_36d1!= sFTransConnectors_36ba.end(), itFunction_36da!= functions_36bd.end(), itConditionalGroup_36e3!= conditionalGroups_36c0.end(); ++itSFState_36c8, ++itSFTransConnector_36d1, ++itFunction_36da, ++itConditionalGroup_36e3)
	{
		bool isUnique= isInputUnique( *itSFState_36c8, *itSFTransConnector_36d1, *itFunction_36da, *itConditionalGroup_36e3);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_36c8, *itSFTransConnector_36d1, *itFunction_36da, *itConditionalGroup_36e3);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_36ec, currMatch.sFTransConnector_36ed, currMatch.function_36ee, currMatch.conditionalGroup_36ef);
	}
}

bool TCNotProcessed_36b6::patternMatcher( const Udm::Object& sFState_36c9, const Udm::Object& sFTransConnector_36d2, const Udm::Object& function_36db, const Udm::Object& conditionalGroup_36e4)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_36c9.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_36ce= CyberComposition::Simulink::SFState::Cast( sFState_36c9);
		if( false== Uml::IsDerivedFrom( sFTransConnector_36d2.type(), CyberComposition::Simulink::SFTransConnector::meta))
			continue;
		CyberComposition::Simulink::SFTransConnector sFTransConnector_36d7= CyberComposition::Simulink::SFTransConnector::Cast( sFTransConnector_36d2);
		if( false== Uml::IsDerivedFrom( function_36db.type(), SFC::Function::meta))
			continue;
		SFC::Function function_36e0= SFC::Function::Cast( function_36db);
		if( false== Uml::IsDerivedFrom( conditionalGroup_36e4.type(), SFC::ConditionalGroup::meta))
			continue;
		SFC::ConditionalGroup conditionalGroup_36e9= SFC::ConditionalGroup::Cast( conditionalGroup_36e4);
		Match currMatch;
		currMatch.sFState_36ec= sFState_36ce;
		currMatch.sFTransConnector_36ed= sFTransConnector_36d7;
		currMatch.function_36ee= function_36e0;
		currMatch.conditionalGroup_36ef= conditionalGroup_36e9;
		bool Gz_guard= isGuardTrue( currMatch.conditionalGroup_36ef, currMatch.function_36ee, currMatch.sFState_36ec, currMatch.sFTransConnector_36ed);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void TCNotProcessed_36b6::outputAppender( const CyberComposition::Simulink::SFState& sFState_36f4, const CyberComposition::Simulink::SFTransConnector& sFTransConnector_36f6, const SFC::Function& function_36f8, const SFC::ConditionalGroup& conditionalGroup_36fa)
{
	_sFState_36c3->push_back( sFState_36f4);
	_sFTransConnector_36c4->push_back( sFTransConnector_36f6);
	_function_36c5->push_back( function_36f8);
	_conditionalGroup_36c6->push_back( conditionalGroup_36fa);
}

void CreateTransitionCG_36fc::operator()( const Packets_t& sFStates_36fd, const Packets_t& sFTransConnectors_3700, const Packets_t& functions_3703, const Packets_t& tCVarCGs_3707, Packets_t& sFStates_36ff, Packets_t& sFTransConnectors_3702, Packets_t& functions_3705, Packets_t& transitionCGs_3706)
{
#ifdef PRINT_INFO
	printLog( "CreateTransitionCG_36fc" );
#endif
	RTTGenerator::Instance()->generateRule(3230, "CreateTransitionCG");
	_sFState_3709= &sFStates_36ff;
	_sFTransConnector_370a= &sFTransConnectors_3702;
	_function_370b= &functions_3705;
	_transitionCG_370c= &transitionCGs_3706;
	processInputPackets( sFStates_36fd, sFTransConnectors_3700, functions_3703, tCVarCGs_3707);
}

bool CreateTransitionCG_36fc::isInputUnique( const Udm::Object& sFState_3711, const Udm::Object& sFTransConnector_371a, const Udm::Object& function_3723, const Udm::Object& tCVarCG_372c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_3713= _sFState_370d.begin(), itSFTransConnector_371c= _sFTransConnector_3716.begin(), itFunction_3725= _function_371f.begin(), itTCVarCG_372e= _tCVarCG_3728.begin(); itSFState_3713!= _sFState_370d.end(), itSFTransConnector_371c!= _sFTransConnector_3716.end(), itFunction_3725!= _function_371f.end(), itTCVarCG_372e!= _tCVarCG_3728.end(); ++itSFState_3713, ++itSFTransConnector_371c, ++itFunction_3725, ++itTCVarCG_372e)
	{
		if( ( *itSFState_3713== sFState_3711)&& ( *itSFTransConnector_371c== sFTransConnector_371a)&& ( *itFunction_3725== function_3723)&& ( *itTCVarCG_372e== tCVarCG_372c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_370d.push_back( sFState_3711);
		_sFTransConnector_3716.push_back( sFTransConnector_371a);
		_function_371f.push_back( function_3723);
		_tCVarCG_3728.push_back( tCVarCG_372c);
	}
	return isUnique;
}

bool CreateTransitionCG_36fc::isGuardTrue( SFC::Function& Function, CyberComposition::Simulink::SFState& SFState, CyberComposition::Simulink::SFTransConnector& SFTransConnector, SFC::LocalVar& TCVar, SFC::ConditionalGroup& TCVarCG)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( TCVar.name() ) == "_TCVar_";
	return Gz_guard;
}

void CreateTransitionCG_36fc::processInputPackets( const Packets_t& sFStates_36fd, const Packets_t& sFTransConnectors_3700, const Packets_t& functions_3703, const Packets_t& tCVarCGs_3707)
{
	for( Packets_t::const_iterator itSFState_370e= sFStates_36fd.begin(), itSFTransConnector_3717= sFTransConnectors_3700.begin(), itFunction_3720= functions_3703.begin(), itTCVarCG_3729= tCVarCGs_3707.begin(); itSFState_370e!= sFStates_36fd.end(), itSFTransConnector_3717!= sFTransConnectors_3700.end(), itFunction_3720!= functions_3703.end(), itTCVarCG_3729!= tCVarCGs_3707.end(); ++itSFState_370e, ++itSFTransConnector_3717, ++itFunction_3720, ++itTCVarCG_3729)
	{
		bool isUnique= isInputUnique( *itSFState_370e, *itSFTransConnector_3717, *itFunction_3720, *itTCVarCG_3729);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_370e, *itSFTransConnector_3717, *itFunction_3720, *itTCVarCG_3729);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateTransitionCG_36fc::patternMatcher( const Udm::Object& sFState_370f, const Udm::Object& sFTransConnector_3718, const Udm::Object& function_3721, const Udm::Object& tCVarCG_372a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_370f.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_3714= CyberComposition::Simulink::SFState::Cast( sFState_370f);
		if( false== Uml::IsDerivedFrom( sFTransConnector_3718.type(), CyberComposition::Simulink::SFTransConnector::meta))
			continue;
		CyberComposition::Simulink::SFTransConnector sFTransConnector_371d= CyberComposition::Simulink::SFTransConnector::Cast( sFTransConnector_3718);
		if( false== Uml::IsDerivedFrom( function_3721.type(), SFC::Function::meta))
			continue;
		SFC::Function function_3726= SFC::Function::Cast( function_3721);
		if( false== Uml::IsDerivedFrom( tCVarCG_372a.type(), SFC::ConditionalGroup::meta))
			continue;
		SFC::ConditionalGroup tCVarCG_372f= SFC::ConditionalGroup::Cast( tCVarCG_372a);
		set< SFC::LocalVar> tCVars_3731= function_3726.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itTCVar_3732= tCVars_3731.begin(); itTCVar_3732!= tCVars_3731.end(); ++itTCVar_3732)
		{
			SFC::LocalVar currTCVar_3733= *itTCVar_3732;
			Match currMatch;
			currMatch.sFState_3735= sFState_3714;
			currMatch.sFTransConnector_3736= sFTransConnector_371d;
			currMatch.function_3737= function_3726;
			currMatch.tCVarCG_3738= tCVarCG_372f;
			currMatch.tCVar_3739= currTCVar_3733;
			bool Gz_guard= isGuardTrue( currMatch.function_3737, currMatch.sFState_3735, currMatch.sFTransConnector_3736, currMatch.tCVar_3739, currMatch.tCVarCG_3738);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateTransitionCG_36fc::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newTCVarCB_373f= SFC::ConditionalBlock::Create( currMatch.tCVarCG_3738, SFC::ConditionalGroup::meta_stmnt);
		SFC::UserCode newTCVarTest_3740= SFC::UserCode::Create( newTCVarCB_373f, SFC::ConditionalBlock::meta_cond);
		SFC::BinaryExprs newEquals_3741= SFC::BinaryExprs::Create( newTCVarTest_3740, SFC::UserCode::meta_codeexpr);
		SFC::Int newInt_3742= SFC::Int::Create( newEquals_3741, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_3743= SFC::ArgDeclRef::Create( newEquals_3741, SFC::BinaryExprs::meta_leftexpr);
		SFC::ConditionalGroup newTransitionCG_3744= SFC::ConditionalGroup::Create( newTCVarCB_373f, SFC::ConditionalBlock::meta_stmnt);
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_3743;
		SFC::BinaryExprs& Equals= newEquals_3741;
		SFC::Function& Function= currMatch.function_3737;
		SFC::Int& Int= newInt_3742;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_3735;
		CyberComposition::Simulink::SFTransConnector& SFTransConnector= currMatch.sFTransConnector_3736;
		SFC::LocalVar& TCVar= currMatch.tCVar_3739;
		SFC::ConditionalBlock& TCVarCB= newTCVarCB_373f;
		SFC::ConditionalGroup& TCVarCG= currMatch.tCVarCG_3738;
		SFC::UserCode& TCVarTest= newTCVarTest_3740;
		SFC::ConditionalGroup& TransitionCG= newTransitionCG_3744;
		{
TCVarCB.RefId() = TCVarTest.RefId() = TransitionCG.RefId() = SFTransConnector.RefId();
};
		{
__int64 statementCount = TCVarCG.statementCount();
TCVarCB.statementIndex() = statementCount++;
TCVarCG.statementCount() = statementCount;
};
		{
Equals.op() = "==";
};
		{
__int64 statementCount = TCVarCB.statementCount();
TransitionCG.statementIndex() = statementCount++;
TCVarCB.statementCount() = statementCount;
};
		{
Int.val() = SFManager::SFStateTransConnectorMap::get_singleton().getTransConnectorMap( SFState ).getTransConnectorNumber( SFTransConnector );
};
		{
SFManager::SFStateTransConnectorMap::get_singleton().getTransConnectorMap( SFState ).setIsTransConnectorProcessed( SFTransConnector, true );
};
		newArgDeclRef_3743.argdecl()= currMatch.tCVar_3739;
		outputAppender( currMatch.sFState_3735, currMatch.sFTransConnector_3736, currMatch.function_3737, newTransitionCG_3744);
	}
}

void CreateTransitionCG_36fc::outputAppender( const CyberComposition::Simulink::SFState& sFState_3745, const CyberComposition::Simulink::SFTransConnector& sFTransConnector_3747, const SFC::Function& function_3749, const SFC::ConditionalGroup& transitionCG_374b)
{
	_sFState_3709->push_back( sFState_3745);
	_sFTransConnector_370a->push_back( sFTransConnector_3747);
	_function_370b->push_back( function_3749);
	_transitionCG_370c->push_back( transitionCG_374b);
}

void T2L_3761::operator()( const Packets_t& rootFolders_3762, const Packets_t& rootStates_3764, const Packets_t& projects_3766)
{
#ifdef PRINT_INFO
	printLog( "T2L_3761" );
#endif
	if( ( !rootFolders_3762.empty())&& ( !rootStates_3764.empty())&& ( !projects_3766.empty()))
		callGetProject_5c15( rootFolders_3762, rootStates_3764, projects_3766);
}

void T2L_3761::callGetProject_5c15( const Packets_t& rootFolders_3d21, const Packets_t& sFStates_3d24, const Packets_t& projects_3d27)
{
	Packets_t rootFolders_3d23;
	Packets_t sFStates_3d26;
	Packets_t projects_3d29;
	GetProject_3d20 getProject_3d20;
	getProject_3d20( rootFolders_3d21, sFStates_3d24, projects_3d27, rootFolders_3d23, sFStates_3d26, projects_3d29);
	if( ( !rootFolders_3d23.empty())&& ( !sFStates_3d26.empty())&& ( !projects_3d29.empty()))
		callCreateTypes_5c19( rootFolders_3d23, sFStates_3d26, projects_3d29);
}

void T2L_3761::callCreateTypes_5c19( const Packets_t& rootFolders_3769, const Packets_t& states_376b, const Packets_t& projects_376d)
{
	Packets_t states_376f;
	Packets_t projects_3770;
	CreateTypes_3768 createTypes_3768;
	createTypes_3768( rootFolders_3769, states_376b, projects_376d, states_376f, projects_3770);
	if( ( !states_376f.empty())&& ( !projects_3770.empty()))
		callSetFileName_5c1d( states_376f, projects_3770);
}

void T2L_3761::callSetFileName_5c1d( const Packets_t& sFStates_3d50, const Packets_t& projects_3d54)
{
	Packets_t sFStates_3d52;
	Packets_t programs_3d53;
	SetFileName_3d4f setFileName_3d4f;
	setFileName_3d4f( sFStates_3d50, projects_3d54, sFStates_3d52, programs_3d53);
	if( ( !sFStates_3d52.empty())&& ( !programs_3d53.empty()))
		callProcessProgram_5c20( sFStates_3d52, programs_3d53);
}

void T2L_3761::callProcessProgram_5c20( const Packets_t& states_3d76, const Packets_t& programs_3d78)
{
	ProcessProgram_3d75 processProgram_3d75;
	processProgram_3d75( states_3d76, programs_3d78);
}

void CreateTypes_3768::operator()( const Packets_t& rootFolders_3769, const Packets_t& states_376b, const Packets_t& projects_376d, Packets_t& states_376f, Packets_t& projects_3770)
{
#ifdef PRINT_INFO
	printLog( "CreateTypes_3768" );
#endif
	_state_3771= &states_376f;
	_project_3772= &projects_3770;
	_state_3771->insert( _state_3771->end(), states_376b.begin(), states_376b.end());
	_project_3772->insert( _project_3772->end(), projects_376d.begin(), projects_376d.end());
	if( ( !rootFolders_3769.empty())&& ( !projects_376d.empty()))
		callGetTypeBlock_3d15( rootFolders_3769, projects_376d);
}

void CreateTypes_3768::callGetTypeBlock_3d15( const Packets_t& rootFolders_3ca9, const Packets_t& projects_3cab)
{
	Packets_t typess_3cad;
	Packets_t projects_3cae;
	GetTypeBlock_3ca8 getTypeBlock_3ca8;
	getTypeBlock_3ca8( rootFolders_3ca9, projects_3cab, typess_3cad, projects_3cae);
	if( ( !typess_3cad.empty())&& ( !projects_3cae.empty()))
		callCreateTypesInner_3d18( typess_3cad, projects_3cae);
}

void CreateTypes_3768::callCreateTypesInner_3d18( const Packets_t& typess_3774, const Packets_t& projects_3776)
{
	Packets_t typess_3778;
	Packets_t newStructs_3779;
	CreateTypesInner_3773 createTypesInner_3773;
	createTypesInner_3773( typess_3774, projects_3776, typess_3778, newStructs_3779);
	if( ( !typess_3778.empty())&& ( !newStructs_3779.empty()))
		callStructMembers_3d1b( typess_3778, newStructs_3779);
}

void CreateTypes_3768::callStructMembers_3d1b( const Packets_t& typess_3c79, const Packets_t& newStructs_3c7b)
{
	Packets_t newStructs_3c7d;
	StructMembers_3c78 structMembers_3c78;
	structMembers_3c78( typess_3c79, newStructs_3c7b, newStructs_3c7d);
	if( ( !newStructs_3c7d.empty()))
		callRegisterStruct_3d1e( newStructs_3c7d);
}

void CreateTypes_3768::callRegisterStruct_3d1e( const Packets_t& sfcStructs_3c68)
{
	RegisterStruct_3c67 registerStruct_3c67;
	registerStruct_3c67( sfcStructs_3c68);
}

void CreateTypesInner_3773::operator()( const Packets_t& typess_3774, const Packets_t& projects_3776, Packets_t& typess_3778, Packets_t& newStructs_3779)
{
#ifdef PRINT_INFO
	printLog( "CreateTypesInner_3773" );
#endif
	_types_377a= &typess_3778;
	_newStruct_377b= &newStructs_3779;
	for( Packets_t::const_iterator ittypes_377d= typess_3774.begin(), itproject_3784= projects_3776.begin(); ittypes_377d!= typess_3774.end(), itproject_3784!= projects_3776.end(); ++ittypes_377d, ++itproject_3784)
	{
		bool isUnique= isInputUnique( *ittypes_377d, *itproject_3784);
		if( !isUnique)
			continue;
		Packets_t onetypes_3781( 1, *ittypes_377d);
		Packets_t oneproject_3788( 1, *itproject_3784);
		executeOne( onetypes_3781, oneproject_3788);
	}
}

void CreateTypesInner_3773::executeOne( const Packets_t& typess_3774, const Packets_t& projects_3776)
{
	if( ( !typess_3774.empty())&& ( !projects_3776.empty()))
		callStructOrMatrix_3c5e( typess_3774, projects_3776);
}

bool CreateTypesInner_3773::isInputUnique( const Udm::Object& types_377e, const Udm::Object& project_3785)
{
	bool isUnique= true;
	for( Packets_t::const_iterator ittypes_3780= _types_377c.begin(), itproject_3787= _project_3783.begin(); ittypes_3780!= _types_377c.end(), itproject_3787!= _project_3783.end(); ++ittypes_3780, ++itproject_3787)
	{
		if( ( *ittypes_3780== types_377e)&& ( *itproject_3787== project_3785))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_types_377c.push_back( types_377e);
		_project_3783.push_back( project_3785);
	}
	return isUnique;
}

void CreateTypesInner_3773::callStructOrMatrix_3c5e( const Packets_t& typess_378b, const Packets_t& projects_378d)
{
	Packets_t typess_378f;
	Packets_t projects_3790;
	Packets_t typess_3791;
	Packets_t projects_3792;
	StructOrMatrix_378a structOrMatrix_378a;
	structOrMatrix_378a( typess_378b, projects_378d, typess_378f, projects_3790, typess_3791, projects_3792);
	if( ( !typess_378f.empty())&& ( !projects_3790.empty()))
		callCreateStructType_3c61( typess_378f, projects_3790);
	if( ( !typess_3791.empty())&& ( !projects_3792.empty()))
		callCreateArrayOrBasicType_3c64( typess_3791, projects_3792);
}

void CreateTypesInner_3773::callCreateStructType_3c61( const Packets_t& ecsl_dp_Structs_3c39, const Packets_t& projects_3c3d)
{
	Packets_t ecsl_dp_Structs_3c3b;
	Packets_t sfc_Structs_3c3c;
	CreateStructType_3c38 createStructType_3c38;
	createStructType_3c38( ecsl_dp_Structs_3c39, projects_3c3d, ecsl_dp_Structs_3c3b, sfc_Structs_3c3c);
	_types_377a->insert( _types_377a->end(), ecsl_dp_Structs_3c3b.begin(), ecsl_dp_Structs_3c3b.end());
	_newStruct_377b->insert( _newStruct_377b->end(), sfc_Structs_3c3c.begin(), sfc_Structs_3c3c.end());
}

void CreateTypesInner_3773::callCreateArrayOrBasicType_3c64( const Packets_t& typess_37f0, const Packets_t& projects_37f2)
{
	CreateArrayOrBasicType_37ef createArrayOrBasicType_37ef;
	createArrayOrBasicType_37ef( typess_37f0, projects_37f2);
}

void StructOrMatrix_378a::operator()( const Packets_t& typess_378b, const Packets_t& projects_378d, Packets_t& typess_378f, Packets_t& projects_3790, Packets_t& typess_3791, Packets_t& projects_3792)
{
#ifdef PRINT_INFO
	printLog( "StructOrMatrix_378a" );
#endif
	_types_3793= &typess_378f;
	_project_3794= &projects_3790;
	_types_3795= &typess_3791;
	_project_3796= &projects_3792;
	for( Packets_t::const_iterator ittypes_3798= typess_378b.begin(), itproject_379f= projects_378d.begin(); ittypes_3798!= typess_378b.end(), itproject_379f!= projects_378d.end(); ++ittypes_3798, ++itproject_379f)
	{
		bool isUnique= isInputUnique( *ittypes_3798, *itproject_379f);
		if( !isUnique)
			continue;
		Packets_t onetypes_379c( 1, *ittypes_3798);
		Packets_t oneproject_37a3( 1, *itproject_379f);
		executeOne( onetypes_379c, oneproject_37a3);
	}
}

void StructOrMatrix_378a::executeOne( const Packets_t& typess_378b, const Packets_t& projects_378d)
{
	Packets_t typeStructs_37a8;
	Packets_t projects_37ab;
	IsStruct_37a5 isStruct_37a5;
	bool isMatchIsStruct_37a5= isStruct_37a5( typess_378b, projects_378d, typeStructs_37a8, projects_37ab);
	_types_3793->insert( _types_3793->end(), typeStructs_37a8.begin(), typeStructs_37a8.end());
	_project_3794->insert( _project_3794->end(), projects_37ab.begin(), projects_37ab.end());
	Packets_t matrixs_37cd;
	Packets_t projects_37d0;
	IsMatrix_37ca isMatrix_37ca;
	bool isMatchIsMatrix_37ca= isMatrix_37ca( typess_378b, projects_378d, matrixs_37cd, projects_37d0);
	_types_3795->insert( _types_3795->end(), matrixs_37cd.begin(), matrixs_37cd.end());
	_project_3796->insert( _project_3796->end(), projects_37d0.begin(), projects_37d0.end());
}

bool StructOrMatrix_378a::isInputUnique( const Udm::Object& types_3799, const Udm::Object& project_37a0)
{
	bool isUnique= true;
	for( Packets_t::const_iterator ittypes_379b= _types_3797.begin(), itproject_37a2= _project_379e.begin(); ittypes_379b!= _types_3797.end(), itproject_37a2!= _project_379e.end(); ++ittypes_379b, ++itproject_37a2)
	{
		if( ( *ittypes_379b== types_3799)&& ( *itproject_37a2== project_37a0))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_types_3797.push_back( types_3799);
		_project_379e.push_back( project_37a0);
	}
	return isUnique;
}

bool IsStruct_37a5::operator()( const Packets_t& typeStructs_37a6, const Packets_t& projects_37a9, Packets_t& typeStructs_37a8, Packets_t& projects_37ab)
{
#ifdef PRINT_INFO
	printLog( "IsStruct_37a5" );
#endif
	_typeStruct_37ac= &typeStructs_37a8;
	_project_37ad= &projects_37ab;
	processInputPackets( typeStructs_37a6, projects_37a9);
	if( false== _matches.empty())
		return true;
	return false;
}

bool IsStruct_37a5::isInputUnique( const Udm::Object& typeStruct_37b2, const Udm::Object& project_37bb)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itTypeStruct_37b4= _typeStruct_37ae.begin(), itProject_37bd= _project_37b7.begin(); itTypeStruct_37b4!= _typeStruct_37ae.end(), itProject_37bd!= _project_37b7.end(); ++itTypeStruct_37b4, ++itProject_37bd)
	{
		if( ( *itTypeStruct_37b4== typeStruct_37b2)&& ( *itProject_37bd== project_37bb))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_typeStruct_37ae.push_back( typeStruct_37b2);
		_project_37b7.push_back( project_37bb);
	}
	return isUnique;
}

bool IsStruct_37a5::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void IsStruct_37a5::processInputPackets( const Packets_t& typeStructs_37a6, const Packets_t& projects_37a9)
{
	for( Packets_t::const_iterator itTypeStruct_37af= typeStructs_37a6.begin(), itProject_37b8= projects_37a9.begin(); itTypeStruct_37af!= typeStructs_37a6.end(), itProject_37b8!= projects_37a9.end(); ++itTypeStruct_37af, ++itProject_37b8)
	{
		bool isUnique= isInputUnique( *itTypeStruct_37af, *itProject_37b8);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itTypeStruct_37af, *itProject_37b8);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.typeStruct_37c4, currMatch.project_37c5);
	}
}

bool IsStruct_37a5::patternMatcher( const Udm::Object& typeStruct_37b0, const Udm::Object& project_37b9)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( typeStruct_37b0.type(), CyberComposition::Simulink::TypeStruct::meta))
			continue;
		CyberComposition::Simulink::TypeStruct typeStruct_37b5= CyberComposition::Simulink::TypeStruct::Cast( typeStruct_37b0);
		if( false== Uml::IsDerivedFrom( project_37b9.type(), SFC::Project::meta))
			continue;
		SFC::Project project_37be= SFC::Project::Cast( project_37b9);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_37c3;
		if( !isValidBound(boundObjs_37c3, typeStruct_37b5, true))
			continue;
		currMatch.typeStruct_37c4= typeStruct_37b5;
		if( !isValidBound(boundObjs_37c3, project_37be, true))
			continue;
		currMatch.project_37c5= project_37be;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void IsStruct_37a5::outputAppender( const CyberComposition::Simulink::TypeStruct& typeStruct_37c6, const SFC::Project& project_37c8)
{
	_typeStruct_37ac->push_back( typeStruct_37c6);
	_project_37ad->push_back( project_37c8);
}

bool IsMatrix_37ca::operator()( const Packets_t& matrixs_37cb, const Packets_t& projects_37ce, Packets_t& matrixs_37cd, Packets_t& projects_37d0)
{
#ifdef PRINT_INFO
	printLog( "IsMatrix_37ca" );
#endif
	_matrix_37d1= &matrixs_37cd;
	_project_37d2= &projects_37d0;
	processInputPackets( matrixs_37cb, projects_37ce);
	if( false== _matches.empty())
		return true;
	return false;
}

bool IsMatrix_37ca::isInputUnique( const Udm::Object& matrix_37d7, const Udm::Object& project_37e0)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_37d9= _matrix_37d3.begin(), itProject_37e2= _project_37dc.begin(); itMatrix_37d9!= _matrix_37d3.end(), itProject_37e2!= _project_37dc.end(); ++itMatrix_37d9, ++itProject_37e2)
	{
		if( ( *itMatrix_37d9== matrix_37d7)&& ( *itProject_37e2== project_37e0))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_37d3.push_back( matrix_37d7);
		_project_37dc.push_back( project_37e0);
	}
	return isUnique;
}

bool IsMatrix_37ca::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void IsMatrix_37ca::processInputPackets( const Packets_t& matrixs_37cb, const Packets_t& projects_37ce)
{
	for( Packets_t::const_iterator itMatrix_37d4= matrixs_37cb.begin(), itProject_37dd= projects_37ce.begin(); itMatrix_37d4!= matrixs_37cb.end(), itProject_37dd!= projects_37ce.end(); ++itMatrix_37d4, ++itProject_37dd)
	{
		bool isUnique= isInputUnique( *itMatrix_37d4, *itProject_37dd);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_37d4, *itProject_37dd);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_37e9, currMatch.project_37ea);
	}
}

bool IsMatrix_37ca::patternMatcher( const Udm::Object& matrix_37d5, const Udm::Object& project_37de)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_37d5.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_37da= CyberComposition::Simulink::SF_Matrix::Cast( matrix_37d5);
		if( false== Uml::IsDerivedFrom( project_37de.type(), SFC::Project::meta))
			continue;
		SFC::Project project_37e3= SFC::Project::Cast( project_37de);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_37e8;
		if( !isValidBound(boundObjs_37e8, matrix_37da, true))
			continue;
		currMatch.matrix_37e9= matrix_37da;
		if( !isValidBound(boundObjs_37e8, project_37e3, true))
			continue;
		currMatch.project_37ea= project_37e3;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void IsMatrix_37ca::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_37eb, const SFC::Project& project_37ed)
{
	_matrix_37d1->push_back( matrix_37eb);
	_project_37d2->push_back( project_37ed);
}

void CreateArrayOrBasicType_37ef::operator()( const Packets_t& typess_37f0, const Packets_t& projects_37f2)
{
#ifdef PRINT_INFO
	printLog( "CreateArrayOrBasicType_37ef" );
#endif
	if( ( !typess_37f0.empty())&& ( !projects_37f2.empty()))
		callDimensionTest_3c26( typess_37f0, projects_37f2);
}

void CreateArrayOrBasicType_37ef::callDimensionTest_3c26( const Packets_t& typess_3b95, const Packets_t& projects_3b97)
{
	Packets_t typess_3b99;
	Packets_t projects_3b9a;
	Packets_t typess_3b9b;
	Packets_t projects_3b9c;
	Packets_t typess_3b9d;
	Packets_t projects_3b9e;
	DimensionTest_3b94 dimensionTest_3b94;
	dimensionTest_3b94( typess_3b95, projects_3b97, typess_3b99, projects_3b9a, typess_3b9b, projects_3b9c, typess_3b9d, projects_3b9e);
	if( ( !typess_3b9d.empty())&& ( !projects_3b9e.empty()))
		callProcessOther_3c29( typess_3b9d, projects_3b9e);
	if( ( !typess_3b9b.empty())&& ( !projects_3b9c.empty()))
		callProcessColumn_3c2c( typess_3b9b, projects_3b9c);
	if( ( !typess_3b99.empty())&& ( !projects_3b9a.empty()))
		callProcessScalar_3c2f( typess_3b99, projects_3b9a);
}

void CreateArrayOrBasicType_37ef::callProcessOther_3c29( const Packets_t& typess_3833, const Packets_t& projects_3835)
{
	Packets_t typess_3837;
	Packets_t array1s_3838;
	Packets_t projects_3839;
	ProcessOther_3832 processOther_3832;
	processOther_3832( typess_3833, projects_3835, typess_3837, array1s_3838, projects_3839);
	if( ( !typess_3837.empty())&& ( !array1s_3838.empty()))
		callRegisterType_3c32( typess_3837, array1s_3838);
}

void CreateArrayOrBasicType_37ef::callProcessColumn_3c2c( const Packets_t& typess_3b83, const Packets_t& projects_3b85)
{
	Packets_t typess_3b87;
	Packets_t array1s_3b88;
	Packets_t projects_3b89;
	ProcessColumn_3b82 processColumn_3b82;
	processColumn_3b82( typess_3b83, projects_3b85, typess_3b87, array1s_3b88, projects_3b89);
	if( ( !typess_3b87.empty())&& ( !array1s_3b88.empty()))
		callRegisterType_3c32( typess_3b87, array1s_3b88);
}

void CreateArrayOrBasicType_37ef::callProcessScalar_3c2f( const Packets_t& typess_3973, const Packets_t& projects_3975)
{
	Packets_t typess_3977;
	Packets_t basictypes_3978;
	Packets_t projects_3979;
	ProcessScalar_3972 processScalar_3972;
	processScalar_3972( typess_3973, projects_3975, typess_3977, basictypes_3978, projects_3979);
	if( ( !typess_3977.empty())&& ( !basictypes_3978.empty()))
		callRegisterType_3c32( typess_3977, basictypes_3978);
}

void CreateArrayOrBasicType_37ef::callRegisterType_3c32( const Packets_t& matrixs_37f5, const Packets_t& dTs_37f8)
{
	Packets_t matrixs_37f7;
	Packets_t dTs_37fa;
	RegisterType_37f4 registerType_37f4;
	registerType_37f4( matrixs_37f5, dTs_37f8, matrixs_37f7, dTs_37fa);
	if( ( !matrixs_37f7.empty())&& ( !dTs_37fa.empty()))
		callMakeAssoc_3c35( matrixs_37f7, dTs_37fa);
}

void CreateArrayOrBasicType_37ef::callMakeAssoc_3c35( const Packets_t& matrixs_3816, const Packets_t& dTs_3818)
{
	MakeAssoc_3815 makeAssoc_3815;
	makeAssoc_3815( matrixs_3816, dTs_3818);
}

void RegisterType_37f4::operator()( const Packets_t& matrixs_37f5, const Packets_t& dTs_37f8, Packets_t& matrixs_37f7, Packets_t& dTs_37fa)
{
#ifdef PRINT_INFO
	printLog( "RegisterType_37f4" );
#endif
	RTTGenerator::Instance()->generateRule(3287, "RegisterType");
	_matrix_37fb= &matrixs_37f7;
	_dT_37fc= &dTs_37fa;
	processInputPackets( matrixs_37f5, dTs_37f8);
	forwardInputs( );
}

bool RegisterType_37f4::isInputUnique( const Udm::Object& matrix_3801, const Udm::Object& dT_380a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_3803= _matrix_37fd.begin(), itDT_380c= _dT_3806.begin(); itMatrix_3803!= _matrix_37fd.end(), itDT_380c!= _dT_3806.end(); ++itMatrix_3803, ++itDT_380c)
	{
		if( ( *itMatrix_3803== matrix_3801)&& ( *itDT_380c== dT_380a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_37fd.push_back( matrix_3801);
		_dT_3806.push_back( dT_380a);
	}
	return isUnique;
}

bool RegisterType_37f4::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void RegisterType_37f4::processInputPackets( const Packets_t& matrixs_37f5, const Packets_t& dTs_37f8)
{
	for( Packets_t::const_iterator itMatrix_37fe= matrixs_37f5.begin(), itDT_3807= dTs_37f8.begin(); itMatrix_37fe!= matrixs_37f5.end(), itDT_3807!= dTs_37f8.end(); ++itMatrix_37fe, ++itDT_3807)
	{
		bool isUnique= isInputUnique( *itMatrix_37fe, *itDT_3807);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_37fe, *itDT_3807);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool RegisterType_37f4::patternMatcher( const Udm::Object& matrix_37ff, const Udm::Object& dT_3808)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_37ff.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_3804= CyberComposition::Simulink::SF_Matrix::Cast( matrix_37ff);
		if( false== Uml::IsDerivedFrom( dT_3808.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_380d= SFC::DT::Cast( dT_3808);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3812;
		if( !isValidBound(boundObjs_3812, matrix_3804, true))
			continue;
		currMatch.matrix_3813= matrix_3804;
		if( !isValidBound(boundObjs_3812, dT_380d, true))
			continue;
		currMatch.dT_3814= dT_380d;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void RegisterType_37f4::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::DT& DT= currMatch.dT_3814;
		CyberComposition::Simulink::SF_Matrix& Matrix= currMatch.matrix_3813;
		{
SFCTypesManager::getSingleton().makeTypeUnique( DT );
};
	}
}

void RegisterType_37f4::forwardInputs()
{
	*_matrix_37fb= _matrix_37fd;
	*_dT_37fc= _dT_3806;
}

void MakeAssoc_3815::operator()( const Packets_t& matrixs_3816, const Packets_t& dTs_3818)
{
#ifdef PRINT_INFO
	printLog( "MakeAssoc_3815" );
#endif
	RTTGenerator::Instance()->generateRule(3291, "MakeAssoc");
	processInputPackets( matrixs_3816, dTs_3818);
}

bool MakeAssoc_3815::isInputUnique( const Udm::Object& matrix_381e, const Udm::Object& dT_3827)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_3820= _matrix_381a.begin(), itDT_3829= _dT_3823.begin(); itMatrix_3820!= _matrix_381a.end(), itDT_3829!= _dT_3823.end(); ++itMatrix_3820, ++itDT_3829)
	{
		if( ( *itMatrix_3820== matrix_381e)&& ( *itDT_3829== dT_3827))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_381a.push_back( matrix_381e);
		_dT_3823.push_back( dT_3827);
	}
	return isUnique;
}

bool MakeAssoc_3815::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void MakeAssoc_3815::processInputPackets( const Packets_t& matrixs_3816, const Packets_t& dTs_3818)
{
	for( Packets_t::const_iterator itMatrix_381b= matrixs_3816.begin(), itDT_3824= dTs_3818.begin(); itMatrix_381b!= matrixs_3816.end(), itDT_3824!= dTs_3818.end(); ++itMatrix_381b, ++itDT_3824)
	{
		bool isUnique= isInputUnique( *itMatrix_381b, *itDT_3824);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_381b, *itDT_3824);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool MakeAssoc_3815::patternMatcher( const Udm::Object& matrix_381c, const Udm::Object& dT_3825)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_381c.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_3821= CyberComposition::Simulink::SF_Matrix::Cast( matrix_381c);
		if( false== Uml::IsDerivedFrom( dT_3825.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_382a= SFC::DT::Cast( dT_3825);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_382f;
		if( !isValidBound(boundObjs_382f, matrix_3821, true))
			continue;
		currMatch.matrix_3830= matrix_3821;
		if( !isValidBound(boundObjs_382f, dT_382a, true))
			continue;
		currMatch.dT_3831= dT_382a;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void MakeAssoc_3815::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		currMatch.dT_3831.tb()= currMatch.matrix_3830;
	}
}

void ProcessOther_3832::operator()( const Packets_t& typess_3833, const Packets_t& projects_3835, Packets_t& typess_3837, Packets_t& array1s_3838, Packets_t& projects_3839)
{
#ifdef PRINT_INFO
	printLog( "ProcessOther_3832" );
#endif
	_types_383a= &typess_3837;
	_array1_383b= &array1s_3838;
	_project_383c= &projects_3839;
	if( ( !typess_3833.empty())&& ( !projects_3835.empty()))
		callProcessRowVector_3b7b( typess_3833, projects_3835);
}

void ProcessOther_3832::callProcessRowVector_3b7b( const Packets_t& typess_383e, const Packets_t& projects_3840)
{
	Packets_t typess_3842;
	Packets_t array2s_3843;
	Packets_t projectss_3844;
	ProcessRowVector_383d processRowVector_383d;
	processRowVector_383d( typess_383e, projects_3840, typess_3842, array2s_3843, projectss_3844);
	if( ( !typess_3842.empty())&& ( !array2s_3843.empty())&& ( !projectss_3844.empty()))
		callProcessArray1_3b7e( typess_3842, array2s_3843, projectss_3844);
}

void ProcessOther_3832::callProcessArray1_3b7e( const Packets_t& typess_3a54, const Packets_t& basictypes_3a56, const Packets_t& projects_3a58)
{
	Packets_t typess_3a5a;
	Packets_t array1s_3a5b;
	Packets_t projects_3a5c;
	ProcessArray1_3a53 processArray1_3a53;
	processArray1_3a53( typess_3a54, basictypes_3a56, projects_3a58, typess_3a5a, array1s_3a5b, projects_3a5c);
	_project_383c->insert( _project_383c->end(), projects_3a5c.begin(), projects_3a5c.end());
	_types_383a->insert( _types_383a->end(), typess_3a5a.begin(), typess_3a5a.end());
	_array1_383b->insert( _array1_383b->end(), array1s_3a5b.begin(), array1s_3a5b.end());
}

void ProcessRowVector_383d::operator()( const Packets_t& typess_383e, const Packets_t& projects_3840, Packets_t& typess_3842, Packets_t& array2s_3843, Packets_t& projectss_3844)
{
#ifdef PRINT_INFO
	printLog( "ProcessRowVector_383d" );
#endif
	_types_3845= &typess_3842;
	_array2_3846= &array2s_3843;
	_projects_3847= &projectss_3844;
	if( ( !typess_383e.empty())&& ( !projects_3840.empty()))
		callProcessScalar_3a4c( typess_383e, projects_3840);
}

void ProcessRowVector_383d::callProcessScalar_3a4c( const Packets_t& typess_3973, const Packets_t& projects_3975)
{
	Packets_t typess_3977;
	Packets_t basictypes_3978;
	Packets_t projects_3979;
	ProcessScalar_3972 processScalar_3972;
	processScalar_3972( typess_3973, projects_3975, typess_3977, basictypes_3978, projects_3979);
	if( ( !typess_3977.empty())&& ( !basictypes_3978.empty())&& ( !projects_3979.empty()))
		callProcessArray2_3a4f( typess_3977, basictypes_3978, projects_3979);
}

void ProcessRowVector_383d::callProcessArray2_3a4f( const Packets_t& typess_3849, const Packets_t& basictypes_384b, const Packets_t& projects_384d)
{
	Packets_t typess_384f;
	Packets_t array2s_3850;
	Packets_t projectss_3851;
	ProcessArray2_3848 processArray2_3848;
	processArray2_3848( typess_3849, basictypes_384b, projects_384d, typess_384f, array2s_3850, projectss_3851);
	_types_3845->insert( _types_3845->end(), typess_384f.begin(), typess_384f.end());
	_array2_3846->insert( _array2_3846->end(), array2s_3850.begin(), array2s_3850.end());
	_projects_3847->insert( _projects_3847->end(), projectss_3851.begin(), projectss_3851.end());
}

void ProcessArray2_3848::operator()( const Packets_t& typess_3849, const Packets_t& basictypes_384b, const Packets_t& projects_384d, Packets_t& typess_384f, Packets_t& array2s_3850, Packets_t& projectss_3851)
{
#ifdef PRINT_INFO
	printLog( "ProcessArray2_3848" );
#endif
	_types_3852= &typess_384f;
	_array2_3853= &array2s_3850;
	_projects_3854= &projectss_3851;
	if( ( !typess_3849.empty())&& ( !basictypes_384b.empty())&& ( !projects_384d.empty()))
		callGetArray2_3966( typess_3849, basictypes_384b, projects_384d);
}

void ProcessArray2_3848::callGetArray2_3966( const Packets_t& typess_3856, const Packets_t& basictypes_3858, const Packets_t& projects_385a)
{
	Packets_t typess_385c;
	Packets_t basictypes_385d;
	Packets_t projectss_385e;
	Packets_t typess_385f;
	Packets_t basictypes_3860;
	Packets_t projectss_3861;
	GetArray2_3855 getArray2_3855;
	getArray2_3855( typess_3856, basictypes_3858, projects_385a, typess_385c, basictypes_385d, projectss_385e, typess_385f, basictypes_3860, projectss_3861);
	if( ( !typess_385c.empty())&& ( !basictypes_385d.empty())&& ( !projectss_385e.empty()))
		callUseArray2_396a( typess_385c, basictypes_385d, projectss_385e);
	if( ( !typess_385f.empty())&& ( !basictypes_3860.empty())&& ( !projectss_3861.empty()))
		callCreateArray2_396e( typess_385f, basictypes_3860, projectss_3861);
}

void ProcessArray2_3848::callUseArray2_396a( const Packets_t& matrixs_38f2, const Packets_t& basicTypes_38f6, const Packets_t& projects_38f8)
{
	Packets_t matrixs_38f4;
	Packets_t arrays_38f5;
	Packets_t projects_38fa;
	UseArray2_38f1 useArray2_38f1;
	useArray2_38f1( matrixs_38f2, basicTypes_38f6, projects_38f8, matrixs_38f4, arrays_38f5, projects_38fa);
	_types_3852->insert( _types_3852->end(), matrixs_38f4.begin(), matrixs_38f4.end());
	_array2_3853->insert( _array2_3853->end(), arrays_38f5.begin(), arrays_38f5.end());
	_projects_3854->insert( _projects_3854->end(), projects_38fa.begin(), projects_38fa.end());
}

void ProcessArray2_3848::callCreateArray2_396e( const Packets_t& matrixs_3931, const Packets_t& basicTypes_3935, const Packets_t& projects_3937)
{
	Packets_t matrixs_3933;
	Packets_t arrays_3934;
	Packets_t projects_3939;
	CreateArray2_3930 createArray2_3930;
	createArray2_3930( matrixs_3931, basicTypes_3935, projects_3937, matrixs_3933, arrays_3934, projects_3939);
	_types_3852->insert( _types_3852->end(), matrixs_3933.begin(), matrixs_3933.end());
	_array2_3853->insert( _array2_3853->end(), arrays_3934.begin(), arrays_3934.end());
	_projects_3854->insert( _projects_3854->end(), projects_3939.begin(), projects_3939.end());
}

void GetArray2_3855::operator()( const Packets_t& typess_3856, const Packets_t& basictypes_3858, const Packets_t& projects_385a, Packets_t& typess_385c, Packets_t& basictypes_385d, Packets_t& projectss_385e, Packets_t& typess_385f, Packets_t& basictypes_3860, Packets_t& projectss_3861)
{
#ifdef PRINT_INFO
	printLog( "GetArray2_3855" );
#endif
	_types_3862= &typess_385c;
	_basictype_3863= &basictypes_385d;
	_projects_3864= &projectss_385e;
	_types_3865= &typess_385f;
	_basictype_3866= &basictypes_3860;
	_projects_3867= &projectss_3861;
	for( Packets_t::const_iterator ittypes_3869= typess_3856.begin(), itbasictype_3870= basictypes_3858.begin(), itproject_3877= projects_385a.begin(); ittypes_3869!= typess_3856.end(), itbasictype_3870!= basictypes_3858.end(), itproject_3877!= projects_385a.end(); ++ittypes_3869, ++itbasictype_3870, ++itproject_3877)
	{
		bool isUnique= isInputUnique( *ittypes_3869, *itbasictype_3870, *itproject_3877);
		if( !isUnique)
			continue;
		Packets_t onetypes_386d( 1, *ittypes_3869);
		Packets_t onebasictype_3874( 1, *itbasictype_3870);
		Packets_t oneproject_387b( 1, *itproject_3877);
		executeOne( onetypes_386d, onebasictype_3874, oneproject_387b);
	}
}

void GetArray2_3855::executeOne( const Packets_t& typess_3856, const Packets_t& basictypes_3858, const Packets_t& projects_385a)
{
	Packets_t matrixs_3880;
	Packets_t basicTypes_3883;
	Packets_t projects_3886;
	Array2Exists_387d array2Exists_387d;
	bool isMatchArray2Exists_387d= array2Exists_387d( typess_3856, basictypes_3858, projects_385a, matrixs_3880, basicTypes_3883, projects_3886);
	_types_3862->insert( _types_3862->end(), matrixs_3880.begin(), matrixs_3880.end());
	_basictype_3863->insert( _basictype_3863->end(), basicTypes_3883.begin(), basicTypes_3883.end());
	_projects_3864->insert( _projects_3864->end(), projects_3886.begin(), projects_3886.end());
	if( isMatchArray2Exists_387d)
		return;
	Packets_t matrixs_38bf;
	Packets_t basicTypes_38c2;
	Packets_t projects_38c5;
	Otherwise_38bc otherwise_38bc;
	bool isMatchOtherwise_38bc= otherwise_38bc( typess_3856, basictypes_3858, projects_385a, matrixs_38bf, basicTypes_38c2, projects_38c5);
	_types_3865->insert( _types_3865->end(), matrixs_38bf.begin(), matrixs_38bf.end());
	_basictype_3866->insert( _basictype_3866->end(), basicTypes_38c2.begin(), basicTypes_38c2.end());
	_projects_3867->insert( _projects_3867->end(), projects_38c5.begin(), projects_38c5.end());
	if( isMatchOtherwise_38bc)
		return;
}

bool GetArray2_3855::isInputUnique( const Udm::Object& types_386a, const Udm::Object& basictype_3871, const Udm::Object& project_3878)
{
	bool isUnique= true;
	for( Packets_t::const_iterator ittypes_386c= _types_3868.begin(), itbasictype_3873= _basictype_386f.begin(), itproject_387a= _project_3876.begin(); ittypes_386c!= _types_3868.end(), itbasictype_3873!= _basictype_386f.end(), itproject_387a!= _project_3876.end(); ++ittypes_386c, ++itbasictype_3873, ++itproject_387a)
	{
		if( ( *ittypes_386c== types_386a)&& ( *itbasictype_3873== basictype_3871)&& ( *itproject_387a== project_3878))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_types_3868.push_back( types_386a);
		_basictype_386f.push_back( basictype_3871);
		_project_3876.push_back( project_3878);
	}
	return isUnique;
}

bool Array2Exists_387d::operator()( const Packets_t& matrixs_387e, const Packets_t& basicTypes_3881, const Packets_t& projects_3884, Packets_t& matrixs_3880, Packets_t& basicTypes_3883, Packets_t& projects_3886)
{
#ifdef PRINT_INFO
	printLog( "Array2Exists_387d" );
#endif
	_matrix_3887= &matrixs_3880;
	_basicType_3888= &basicTypes_3883;
	_project_3889= &projects_3886;
	processInputPackets( matrixs_387e, basicTypes_3881, projects_3884);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Array2Exists_387d::isInputUnique( const Udm::Object& matrix_388e, const Udm::Object& basicType_3897, const Udm::Object& project_38a0)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_3890= _matrix_388a.begin(), itBasicType_3899= _basicType_3893.begin(), itProject_38a2= _project_389c.begin(); itMatrix_3890!= _matrix_388a.end(), itBasicType_3899!= _basicType_3893.end(), itProject_38a2!= _project_389c.end(); ++itMatrix_3890, ++itBasicType_3899, ++itProject_38a2)
	{
		if( ( *itMatrix_3890== matrix_388e)&& ( *itBasicType_3899== basicType_3897)&& ( *itProject_38a2== project_38a0))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_388a.push_back( matrix_388e);
		_basicType_3893.push_back( basicType_3897);
		_project_389c.push_back( project_38a0);
	}
	return isUnique;
}

bool Array2Exists_387d::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool Array2Exists_387d::isGuardTrue( SFC::Array& Array, SFC::BasicType& BasicType, CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard = Matrix.columns() == Array.noelem();;
	return Gz_guard;
}

void Array2Exists_387d::processInputPackets( const Packets_t& matrixs_387e, const Packets_t& basicTypes_3881, const Packets_t& projects_3884)
{
	for( Packets_t::const_iterator itMatrix_388b= matrixs_387e.begin(), itBasicType_3894= basicTypes_3881.begin(), itProject_389d= projects_3884.begin(); itMatrix_388b!= matrixs_387e.end(), itBasicType_3894!= basicTypes_3881.end(), itProject_389d!= projects_3884.end(); ++itMatrix_388b, ++itBasicType_3894, ++itProject_389d)
	{
		bool isUnique= isInputUnique( *itMatrix_388b, *itBasicType_3894, *itProject_389d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_388b, *itBasicType_3894, *itProject_389d);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_38ae, currMatch.basicType_38af, currMatch.project_38b0);
	}
}

bool Array2Exists_387d::patternMatcher( const Udm::Object& matrix_388c, const Udm::Object& basicType_3895, const Udm::Object& project_389e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_388c.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_3891= CyberComposition::Simulink::SF_Matrix::Cast( matrix_388c);
		if( false== Uml::IsDerivedFrom( basicType_3895.type(), SFC::BasicType::meta))
			continue;
		SFC::BasicType basicType_389a= SFC::BasicType::Cast( basicType_3895);
		if( false== Uml::IsDerivedFrom( project_389e.type(), SFC::Project::meta))
			continue;
		SFC::Project project_38a3= SFC::Project::Cast( project_389e);
		set< SFC::Array> arrays_38a5= project_38a3.Array_kind_children();
		for( set< SFC::Array>::const_iterator itArray_38a6= arrays_38a5.begin(); itArray_38a6!= arrays_38a5.end(); ++itArray_38a6)
		{
			SFC::Array currArray_38a7= *itArray_38a6;
			SFC::DT basicType_38a8= currArray_38a7.dt();
			if( false== Uml::IsDerivedFrom( basicType_38a8.type(), SFC::BasicType::meta))
				continue;
			SFC::BasicType basicType_38a9= SFC::BasicType::Cast( basicType_38a8);
			if( !basicType_38a9)
				continue;
			if( basicType_389a!= basicType_38a9)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_38ad;
			if( !isValidBound(boundObjs_38ad, matrix_3891, true))
				continue;
			currMatch.matrix_38ae= matrix_3891;
			if( !isValidBound(boundObjs_38ad, basicType_389a, true))
				continue;
			currMatch.basicType_38af= basicType_389a;
			if( !isValidBound(boundObjs_38ad, project_38a3, true))
				continue;
			currMatch.project_38b0= project_38a3;
			if( !isValidBound(boundObjs_38ad, currArray_38a7, false))
				continue;
			currMatch.array_38b1= currArray_38a7;
			bool Gz_guard= isGuardTrue( currMatch.array_38b1, currMatch.basicType_38af, currMatch.matrix_38ae, currMatch.project_38b0);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void Array2Exists_387d::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_38b6, const SFC::BasicType& basicType_38b8, const SFC::Project& project_38ba)
{
	_matrix_3887->push_back( matrix_38b6);
	_basicType_3888->push_back( basicType_38b8);
	_project_3889->push_back( project_38ba);
}

bool Otherwise_38bc::operator()( const Packets_t& matrixs_38bd, const Packets_t& basicTypes_38c0, const Packets_t& projects_38c3, Packets_t& matrixs_38bf, Packets_t& basicTypes_38c2, Packets_t& projects_38c5)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_38bc" );
#endif
	_matrix_38c6= &matrixs_38bf;
	_basicType_38c7= &basicTypes_38c2;
	_project_38c8= &projects_38c5;
	processInputPackets( matrixs_38bd, basicTypes_38c0, projects_38c3);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_38bc::isInputUnique( const Udm::Object& matrix_38cd, const Udm::Object& basicType_38d6, const Udm::Object& project_38df)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_38cf= _matrix_38c9.begin(), itBasicType_38d8= _basicType_38d2.begin(), itProject_38e1= _project_38db.begin(); itMatrix_38cf!= _matrix_38c9.end(), itBasicType_38d8!= _basicType_38d2.end(), itProject_38e1!= _project_38db.end(); ++itMatrix_38cf, ++itBasicType_38d8, ++itProject_38e1)
	{
		if( ( *itMatrix_38cf== matrix_38cd)&& ( *itBasicType_38d8== basicType_38d6)&& ( *itProject_38e1== project_38df))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_38c9.push_back( matrix_38cd);
		_basicType_38d2.push_back( basicType_38d6);
		_project_38db.push_back( project_38df);
	}
	return isUnique;
}

bool Otherwise_38bc::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_38bc::processInputPackets( const Packets_t& matrixs_38bd, const Packets_t& basicTypes_38c0, const Packets_t& projects_38c3)
{
	for( Packets_t::const_iterator itMatrix_38ca= matrixs_38bd.begin(), itBasicType_38d3= basicTypes_38c0.begin(), itProject_38dc= projects_38c3.begin(); itMatrix_38ca!= matrixs_38bd.end(), itBasicType_38d3!= basicTypes_38c0.end(), itProject_38dc!= projects_38c3.end(); ++itMatrix_38ca, ++itBasicType_38d3, ++itProject_38dc)
	{
		bool isUnique= isInputUnique( *itMatrix_38ca, *itBasicType_38d3, *itProject_38dc);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_38ca, *itBasicType_38d3, *itProject_38dc);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_38e8, currMatch.basicType_38e9, currMatch.project_38ea);
	}
}

bool Otherwise_38bc::patternMatcher( const Udm::Object& matrix_38cb, const Udm::Object& basicType_38d4, const Udm::Object& project_38dd)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_38cb.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_38d0= CyberComposition::Simulink::SF_Matrix::Cast( matrix_38cb);
		if( false== Uml::IsDerivedFrom( basicType_38d4.type(), SFC::BasicType::meta))
			continue;
		SFC::BasicType basicType_38d9= SFC::BasicType::Cast( basicType_38d4);
		if( false== Uml::IsDerivedFrom( project_38dd.type(), SFC::Project::meta))
			continue;
		SFC::Project project_38e2= SFC::Project::Cast( project_38dd);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_38e7;
		if( !isValidBound(boundObjs_38e7, matrix_38d0, true))
			continue;
		currMatch.matrix_38e8= matrix_38d0;
		if( !isValidBound(boundObjs_38e7, basicType_38d9, true))
			continue;
		currMatch.basicType_38e9= basicType_38d9;
		if( !isValidBound(boundObjs_38e7, project_38e2, true))
			continue;
		currMatch.project_38ea= project_38e2;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_38bc::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_38eb, const SFC::BasicType& basicType_38ed, const SFC::Project& project_38ef)
{
	_matrix_38c6->push_back( matrix_38eb);
	_basicType_38c7->push_back( basicType_38ed);
	_project_38c8->push_back( project_38ef);
}

void UseArray2_38f1::operator()( const Packets_t& matrixs_38f2, const Packets_t& basicTypes_38f6, const Packets_t& projects_38f8, Packets_t& matrixs_38f4, Packets_t& arrays_38f5, Packets_t& projects_38fa)
{
#ifdef PRINT_INFO
	printLog( "UseArray2_38f1" );
#endif
	RTTGenerator::Instance()->generateRule(3335, "UseArray2");
	_matrix_38fb= &matrixs_38f4;
	_array_38fc= &arrays_38f5;
	_project_38fd= &projects_38fa;
	processInputPackets( matrixs_38f2, basicTypes_38f6, projects_38f8);
}

bool UseArray2_38f1::isInputUnique( const Udm::Object& matrix_3902, const Udm::Object& basicType_390b, const Udm::Object& project_3914)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_3904= _matrix_38fe.begin(), itBasicType_390d= _basicType_3907.begin(), itProject_3916= _project_3910.begin(); itMatrix_3904!= _matrix_38fe.end(), itBasicType_390d!= _basicType_3907.end(), itProject_3916!= _project_3910.end(); ++itMatrix_3904, ++itBasicType_390d, ++itProject_3916)
	{
		if( ( *itMatrix_3904== matrix_3902)&& ( *itBasicType_390d== basicType_390b)&& ( *itProject_3916== project_3914))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_38fe.push_back( matrix_3902);
		_basicType_3907.push_back( basicType_390b);
		_project_3910.push_back( project_3914);
	}
	return isUnique;
}

bool UseArray2_38f1::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool UseArray2_38f1::isGuardTrue( SFC::Array& Array, SFC::BasicType& BasicType, CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard = Matrix.columns() == Array.noelem();;
	return Gz_guard;
}

void UseArray2_38f1::processInputPackets( const Packets_t& matrixs_38f2, const Packets_t& basicTypes_38f6, const Packets_t& projects_38f8)
{
	for( Packets_t::const_iterator itMatrix_38ff= matrixs_38f2.begin(), itBasicType_3908= basicTypes_38f6.begin(), itProject_3911= projects_38f8.begin(); itMatrix_38ff!= matrixs_38f2.end(), itBasicType_3908!= basicTypes_38f6.end(), itProject_3911!= projects_38f8.end(); ++itMatrix_38ff, ++itBasicType_3908, ++itProject_3911)
	{
		bool isUnique= isInputUnique( *itMatrix_38ff, *itBasicType_3908, *itProject_3911);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_38ff, *itBasicType_3908, *itProject_3911);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool UseArray2_38f1::patternMatcher( const Udm::Object& matrix_3900, const Udm::Object& basicType_3909, const Udm::Object& project_3912)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_3900.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_3905= CyberComposition::Simulink::SF_Matrix::Cast( matrix_3900);
		if( false== Uml::IsDerivedFrom( basicType_3909.type(), SFC::BasicType::meta))
			continue;
		SFC::BasicType basicType_390e= SFC::BasicType::Cast( basicType_3909);
		if( false== Uml::IsDerivedFrom( project_3912.type(), SFC::Project::meta))
			continue;
		SFC::Project project_3917= SFC::Project::Cast( project_3912);
		set< SFC::Array> arrays_3919= project_3917.Array_kind_children();
		for( set< SFC::Array>::const_iterator itArray_391a= arrays_3919.begin(); itArray_391a!= arrays_3919.end(); ++itArray_391a)
		{
			SFC::Array currArray_391b= *itArray_391a;
			SFC::DT basicType_391c= currArray_391b.dt();
			if( false== Uml::IsDerivedFrom( basicType_391c.type(), SFC::BasicType::meta))
				continue;
			SFC::BasicType basicType_391d= SFC::BasicType::Cast( basicType_391c);
			if( !basicType_391d)
				continue;
			if( basicType_390e!= basicType_391d)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_3921;
			if( !isValidBound(boundObjs_3921, matrix_3905, true))
				continue;
			currMatch.matrix_3922= matrix_3905;
			if( !isValidBound(boundObjs_3921, basicType_390e, true))
				continue;
			currMatch.basicType_3923= basicType_390e;
			if( !isValidBound(boundObjs_3921, project_3917, true))
				continue;
			currMatch.project_3924= project_3917;
			if( !isValidBound(boundObjs_3921, currArray_391b, false))
				continue;
			currMatch.array_3925= currArray_391b;
			bool Gz_guard= isGuardTrue( currMatch.array_3925, currMatch.basicType_3923, currMatch.matrix_3922, currMatch.project_3924);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void UseArray2_38f1::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_3922, currMatch.array_3925, currMatch.project_3924);
	}
}

void UseArray2_38f1::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_392a, const SFC::Array& array_392c, const SFC::Project& project_392e)
{
	_matrix_38fb->push_back( matrix_392a);
	_array_38fc->push_back( array_392c);
	_project_38fd->push_back( project_392e);
}

void CreateArray2_3930::operator()( const Packets_t& matrixs_3931, const Packets_t& basicTypes_3935, const Packets_t& projects_3937, Packets_t& matrixs_3933, Packets_t& arrays_3934, Packets_t& projects_3939)
{
#ifdef PRINT_INFO
	printLog( "CreateArray2_3930" );
#endif
	RTTGenerator::Instance()->generateRule(3342, "CreateArray2");
	_matrix_393a= &matrixs_3933;
	_array_393b= &arrays_3934;
	_project_393c= &projects_3939;
	processInputPackets( matrixs_3931, basicTypes_3935, projects_3937);
}

bool CreateArray2_3930::isInputUnique( const Udm::Object& matrix_3941, const Udm::Object& basicType_394a, const Udm::Object& project_3953)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_3943= _matrix_393d.begin(), itBasicType_394c= _basicType_3946.begin(), itProject_3955= _project_394f.begin(); itMatrix_3943!= _matrix_393d.end(), itBasicType_394c!= _basicType_3946.end(), itProject_3955!= _project_394f.end(); ++itMatrix_3943, ++itBasicType_394c, ++itProject_3955)
	{
		if( ( *itMatrix_3943== matrix_3941)&& ( *itBasicType_394c== basicType_394a)&& ( *itProject_3955== project_3953))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_393d.push_back( matrix_3941);
		_basicType_3946.push_back( basicType_394a);
		_project_394f.push_back( project_3953);
	}
	return isUnique;
}

bool CreateArray2_3930::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateArray2_3930::processInputPackets( const Packets_t& matrixs_3931, const Packets_t& basicTypes_3935, const Packets_t& projects_3937)
{
	for( Packets_t::const_iterator itMatrix_393e= matrixs_3931.begin(), itBasicType_3947= basicTypes_3935.begin(), itProject_3950= projects_3937.begin(); itMatrix_393e!= matrixs_3931.end(), itBasicType_3947!= basicTypes_3935.end(), itProject_3950!= projects_3937.end(); ++itMatrix_393e, ++itBasicType_3947, ++itProject_3950)
	{
		bool isUnique= isInputUnique( *itMatrix_393e, *itBasicType_3947, *itProject_3950);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_393e, *itBasicType_3947, *itProject_3950);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateArray2_3930::patternMatcher( const Udm::Object& matrix_393f, const Udm::Object& basicType_3948, const Udm::Object& project_3951)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_393f.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_3944= CyberComposition::Simulink::SF_Matrix::Cast( matrix_393f);
		if( false== Uml::IsDerivedFrom( basicType_3948.type(), SFC::BasicType::meta))
			continue;
		SFC::BasicType basicType_394d= SFC::BasicType::Cast( basicType_3948);
		if( false== Uml::IsDerivedFrom( project_3951.type(), SFC::Project::meta))
			continue;
		SFC::Project project_3956= SFC::Project::Cast( project_3951);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_395b;
		if( !isValidBound(boundObjs_395b, matrix_3944, true))
			continue;
		currMatch.matrix_395c= matrix_3944;
		if( !isValidBound(boundObjs_395b, basicType_394d, true))
			continue;
		currMatch.basicType_395d= basicType_394d;
		if( !isValidBound(boundObjs_395b, project_3956, true))
			continue;
		currMatch.project_395e= project_3956;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateArray2_3930::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Array newArray_395f= SFC::Array::Create( currMatch.project_395e);
		SFC::Array& Array= newArray_395f;
		SFC::BasicType& BasicType= currMatch.basicType_395d;
		CyberComposition::Simulink::SF_Matrix& Matrix= currMatch.matrix_395c;
		SFC::Project& Project= currMatch.project_395e;
		{
__int64 statementCount = Project.statementCount();
Array.statementIndex() = statementCount++;
Project.statementCount() = statementCount;

Array.noelem() = Matrix.columns();
};
		newArray_395f.dt()= currMatch.basicType_395d;
		outputAppender( currMatch.matrix_395c, newArray_395f, currMatch.project_395e);
	}
}

void CreateArray2_3930::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_3960, const SFC::Array& array_3962, const SFC::Project& project_3964)
{
	_matrix_393a->push_back( matrix_3960);
	_array_393b->push_back( array_3962);
	_project_393c->push_back( project_3964);
}

void ProcessScalar_3972::operator()( const Packets_t& typess_3973, const Packets_t& projects_3975, Packets_t& typess_3977, Packets_t& basictypes_3978, Packets_t& projects_3979)
{
#ifdef PRINT_INFO
	printLog( "ProcessScalar_3972" );
#endif
	_types_397a= &typess_3977;
	_basictype_397b= &basictypes_3978;
	_project_397c= &projects_3979;
	if( ( !typess_3973.empty())&& ( !projects_3975.empty()))
		callGetBasicType_3a43( typess_3973, projects_3975);
}

void ProcessScalar_3972::callGetBasicType_3a43( const Packets_t& typess_39d8, const Packets_t& projects_39da)
{
	Packets_t typess_39dc;
	Packets_t projectss_39dd;
	Packets_t typess_39de;
	Packets_t projectss_39df;
	GetBasicType_39d7 getBasicType_39d7;
	getBasicType_39d7( typess_39d8, projects_39da, typess_39dc, projectss_39dd, typess_39de, projectss_39df);
	if( ( !typess_39de.empty())&& ( !projectss_39df.empty()))
		callCreateBasicType_3a46( typess_39de, projectss_39df);
	if( ( !typess_39dc.empty())&& ( !projectss_39dd.empty()))
		callUseBasicType_3a49( typess_39dc, projectss_39dd);
}

void ProcessScalar_3972::callCreateBasicType_3a46( const Packets_t& matrixs_397e, const Packets_t& projects_3982)
{
	Packets_t matrixs_3980;
	Packets_t basicTypes_3981;
	Packets_t projects_3984;
	CreateBasicType_397d createBasicType_397d;
	createBasicType_397d( matrixs_397e, projects_3982, matrixs_3980, basicTypes_3981, projects_3984);
	_types_397a->insert( _types_397a->end(), matrixs_3980.begin(), matrixs_3980.end());
	_basictype_397b->insert( _basictype_397b->end(), basicTypes_3981.begin(), basicTypes_3981.end());
	_project_397c->insert( _project_397c->end(), projects_3984.begin(), projects_3984.end());
}

void ProcessScalar_3972::callUseBasicType_3a49( const Packets_t& matrixs_39a8, const Packets_t& projects_39ac)
{
	Packets_t matrixs_39aa;
	Packets_t basicTypes_39ab;
	Packets_t projects_39ae;
	UseBasicType_39a7 useBasicType_39a7;
	useBasicType_39a7( matrixs_39a8, projects_39ac, matrixs_39aa, basicTypes_39ab, projects_39ae);
	_types_397a->insert( _types_397a->end(), matrixs_39aa.begin(), matrixs_39aa.end());
	_basictype_397b->insert( _basictype_397b->end(), basicTypes_39ab.begin(), basicTypes_39ab.end());
	_project_397c->insert( _project_397c->end(), projects_39ae.begin(), projects_39ae.end());
}

void CreateBasicType_397d::operator()( const Packets_t& matrixs_397e, const Packets_t& projects_3982, Packets_t& matrixs_3980, Packets_t& basicTypes_3981, Packets_t& projects_3984)
{
#ifdef PRINT_INFO
	printLog( "CreateBasicType_397d" );
#endif
	RTTGenerator::Instance()->generateRule(3405, "CreateBasicType");
	_matrix_3985= &matrixs_3980;
	_basicType_3986= &basicTypes_3981;
	_project_3987= &projects_3984;
	processInputPackets( matrixs_397e, projects_3982);
}

bool CreateBasicType_397d::isInputUnique( const Udm::Object& matrix_398c, const Udm::Object& project_3995)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_398e= _matrix_3988.begin(), itProject_3997= _project_3991.begin(); itMatrix_398e!= _matrix_3988.end(), itProject_3997!= _project_3991.end(); ++itMatrix_398e, ++itProject_3997)
	{
		if( ( *itMatrix_398e== matrix_398c)&& ( *itProject_3997== project_3995))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_3988.push_back( matrix_398c);
		_project_3991.push_back( project_3995);
	}
	return isUnique;
}

bool CreateBasicType_397d::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateBasicType_397d::processInputPackets( const Packets_t& matrixs_397e, const Packets_t& projects_3982)
{
	for( Packets_t::const_iterator itMatrix_3989= matrixs_397e.begin(), itProject_3992= projects_3982.begin(); itMatrix_3989!= matrixs_397e.end(), itProject_3992!= projects_3982.end(); ++itMatrix_3989, ++itProject_3992)
	{
		bool isUnique= isInputUnique( *itMatrix_3989, *itProject_3992);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_3989, *itProject_3992);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateBasicType_397d::patternMatcher( const Udm::Object& matrix_398a, const Udm::Object& project_3993)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_398a.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_398f= CyberComposition::Simulink::SF_Matrix::Cast( matrix_398a);
		if( false== Uml::IsDerivedFrom( project_3993.type(), SFC::Project::meta))
			continue;
		SFC::Project project_3998= SFC::Project::Cast( project_3993);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_399d;
		if( !isValidBound(boundObjs_399d, matrix_398f, true))
			continue;
		currMatch.matrix_399e= matrix_398f;
		if( !isValidBound(boundObjs_399d, project_3998, true))
			continue;
		currMatch.project_399f= project_3998;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateBasicType_397d::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BasicType newBasicType_39a0= SFC::BasicType::Create( currMatch.project_399f);
		SFC::BasicType& BasicType= newBasicType_39a0;
		CyberComposition::Simulink::SF_Matrix& Matrix= currMatch.matrix_399e;
		SFC::Project& Project= currMatch.project_399f;
		{
__int64 statementCount = Project.statementCount();
BasicType.statementIndex() = statementCount++;
Project.statementCount() = statementCount;

BasicType.name() = Matrix.Type();

};
		outputAppender( currMatch.matrix_399e, newBasicType_39a0, currMatch.project_399f);
	}
}

void CreateBasicType_397d::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_39a1, const SFC::BasicType& basicType_39a3, const SFC::Project& project_39a5)
{
	_matrix_3985->push_back( matrix_39a1);
	_basicType_3986->push_back( basicType_39a3);
	_project_3987->push_back( project_39a5);
}

void UseBasicType_39a7::operator()( const Packets_t& matrixs_39a8, const Packets_t& projects_39ac, Packets_t& matrixs_39aa, Packets_t& basicTypes_39ab, Packets_t& projects_39ae)
{
#ifdef PRINT_INFO
	printLog( "UseBasicType_39a7" );
#endif
	RTTGenerator::Instance()->generateRule(3411, "UseBasicType");
	_matrix_39af= &matrixs_39aa;
	_basicType_39b0= &basicTypes_39ab;
	_project_39b1= &projects_39ae;
	processInputPackets( matrixs_39a8, projects_39ac);
}

bool UseBasicType_39a7::isInputUnique( const Udm::Object& matrix_39b6, const Udm::Object& project_39bf)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_39b8= _matrix_39b2.begin(), itProject_39c1= _project_39bb.begin(); itMatrix_39b8!= _matrix_39b2.end(), itProject_39c1!= _project_39bb.end(); ++itMatrix_39b8, ++itProject_39c1)
	{
		if( ( *itMatrix_39b8== matrix_39b6)&& ( *itProject_39c1== project_39bf))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_39b2.push_back( matrix_39b6);
		_project_39bb.push_back( project_39bf);
	}
	return isUnique;
}

bool UseBasicType_39a7::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool UseBasicType_39a7::isGuardTrue( SFC::BasicType& BasicType, CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( Matrix.Type() ) ==
 static_cast< std::string >( BasicType.name() );;
	return Gz_guard;
}

void UseBasicType_39a7::processInputPackets( const Packets_t& matrixs_39a8, const Packets_t& projects_39ac)
{
	for( Packets_t::const_iterator itMatrix_39b3= matrixs_39a8.begin(), itProject_39bc= projects_39ac.begin(); itMatrix_39b3!= matrixs_39a8.end(), itProject_39bc!= projects_39ac.end(); ++itMatrix_39b3, ++itProject_39bc)
	{
		bool isUnique= isInputUnique( *itMatrix_39b3, *itProject_39bc);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_39b3, *itProject_39bc);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool UseBasicType_39a7::patternMatcher( const Udm::Object& matrix_39b4, const Udm::Object& project_39bd)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_39b4.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_39b9= CyberComposition::Simulink::SF_Matrix::Cast( matrix_39b4);
		if( false== Uml::IsDerivedFrom( project_39bd.type(), SFC::Project::meta))
			continue;
		SFC::Project project_39c2= SFC::Project::Cast( project_39bd);
		set< SFC::BasicType> basicTypes_39c4= project_39c2.BasicType_kind_children();
		for( set< SFC::BasicType>::const_iterator itBasicType_39c5= basicTypes_39c4.begin(); itBasicType_39c5!= basicTypes_39c4.end(); ++itBasicType_39c5)
		{
			SFC::BasicType currBasicType_39c6= *itBasicType_39c5;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_39ca;
			if( !isValidBound(boundObjs_39ca, matrix_39b9, true))
				continue;
			currMatch.matrix_39cb= matrix_39b9;
			if( !isValidBound(boundObjs_39ca, project_39c2, true))
				continue;
			currMatch.project_39cc= project_39c2;
			if( !isValidBound(boundObjs_39ca, currBasicType_39c6, false))
				continue;
			currMatch.basicType_39cd= currBasicType_39c6;
			bool Gz_guard= isGuardTrue( currMatch.basicType_39cd, currMatch.matrix_39cb, currMatch.project_39cc);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void UseBasicType_39a7::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_39cb, currMatch.basicType_39cd, currMatch.project_39cc);
	}
}

void UseBasicType_39a7::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_39d1, const SFC::BasicType& basicType_39d3, const SFC::Project& project_39d5)
{
	_matrix_39af->push_back( matrix_39d1);
	_basicType_39b0->push_back( basicType_39d3);
	_project_39b1->push_back( project_39d5);
}

void GetBasicType_39d7::operator()( const Packets_t& typess_39d8, const Packets_t& projects_39da, Packets_t& typess_39dc, Packets_t& projectss_39dd, Packets_t& typess_39de, Packets_t& projectss_39df)
{
#ifdef PRINT_INFO
	printLog( "GetBasicType_39d7" );
#endif
	_types_39e0= &typess_39dc;
	_projects_39e1= &projectss_39dd;
	_types_39e2= &typess_39de;
	_projects_39e3= &projectss_39df;
	for( Packets_t::const_iterator ittypes_39e5= typess_39d8.begin(), itproject_39ec= projects_39da.begin(); ittypes_39e5!= typess_39d8.end(), itproject_39ec!= projects_39da.end(); ++ittypes_39e5, ++itproject_39ec)
	{
		bool isUnique= isInputUnique( *ittypes_39e5, *itproject_39ec);
		if( !isUnique)
			continue;
		Packets_t onetypes_39e9( 1, *ittypes_39e5);
		Packets_t oneproject_39f0( 1, *itproject_39ec);
		executeOne( onetypes_39e9, oneproject_39f0);
	}
}

void GetBasicType_39d7::executeOne( const Packets_t& typess_39d8, const Packets_t& projects_39da)
{
	Packets_t matrixs_39f5;
	Packets_t projects_39f8;
	BasicTypeExists_39f2 basicTypeExists_39f2;
	bool isMatchBasicTypeExists_39f2= basicTypeExists_39f2( typess_39d8, projects_39da, matrixs_39f5, projects_39f8);
	_types_39e0->insert( _types_39e0->end(), matrixs_39f5.begin(), matrixs_39f5.end());
	_projects_39e1->insert( _projects_39e1->end(), projects_39f8.begin(), projects_39f8.end());
	if( isMatchBasicTypeExists_39f2)
		return;
	Packets_t matrixs_3a21;
	Packets_t projects_3a24;
	Otherwise_3a1e otherwise_3a1e;
	bool isMatchOtherwise_3a1e= otherwise_3a1e( typess_39d8, projects_39da, matrixs_3a21, projects_3a24);
	_types_39e2->insert( _types_39e2->end(), matrixs_3a21.begin(), matrixs_3a21.end());
	_projects_39e3->insert( _projects_39e3->end(), projects_3a24.begin(), projects_3a24.end());
}

bool GetBasicType_39d7::isInputUnique( const Udm::Object& types_39e6, const Udm::Object& project_39ed)
{
	bool isUnique= true;
	for( Packets_t::const_iterator ittypes_39e8= _types_39e4.begin(), itproject_39ef= _project_39eb.begin(); ittypes_39e8!= _types_39e4.end(), itproject_39ef!= _project_39eb.end(); ++ittypes_39e8, ++itproject_39ef)
	{
		if( ( *ittypes_39e8== types_39e6)&& ( *itproject_39ef== project_39ed))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_types_39e4.push_back( types_39e6);
		_project_39eb.push_back( project_39ed);
	}
	return isUnique;
}

bool BasicTypeExists_39f2::operator()( const Packets_t& matrixs_39f3, const Packets_t& projects_39f6, Packets_t& matrixs_39f5, Packets_t& projects_39f8)
{
#ifdef PRINT_INFO
	printLog( "BasicTypeExists_39f2" );
#endif
	_matrix_39f9= &matrixs_39f5;
	_project_39fa= &projects_39f8;
	processInputPackets( matrixs_39f3, projects_39f6);
	if( false== _matches.empty())
		return true;
	return false;
}

bool BasicTypeExists_39f2::isInputUnique( const Udm::Object& matrix_39ff, const Udm::Object& project_3a08)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_3a01= _matrix_39fb.begin(), itProject_3a0a= _project_3a04.begin(); itMatrix_3a01!= _matrix_39fb.end(), itProject_3a0a!= _project_3a04.end(); ++itMatrix_3a01, ++itProject_3a0a)
	{
		if( ( *itMatrix_3a01== matrix_39ff)&& ( *itProject_3a0a== project_3a08))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_39fb.push_back( matrix_39ff);
		_project_3a04.push_back( project_3a08);
	}
	return isUnique;
}

bool BasicTypeExists_39f2::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool BasicTypeExists_39f2::isGuardTrue( SFC::BasicType& BasicType, CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( Matrix.Type() ) ==
 static_cast< std::string >( BasicType.name() );;
	return Gz_guard;
}

void BasicTypeExists_39f2::processInputPackets( const Packets_t& matrixs_39f3, const Packets_t& projects_39f6)
{
	for( Packets_t::const_iterator itMatrix_39fc= matrixs_39f3.begin(), itProject_3a05= projects_39f6.begin(); itMatrix_39fc!= matrixs_39f3.end(), itProject_3a05!= projects_39f6.end(); ++itMatrix_39fc, ++itProject_3a05)
	{
		bool isUnique= isInputUnique( *itMatrix_39fc, *itProject_3a05);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_39fc, *itProject_3a05);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_3a14, currMatch.project_3a15);
	}
}

bool BasicTypeExists_39f2::patternMatcher( const Udm::Object& matrix_39fd, const Udm::Object& project_3a06)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_39fd.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_3a02= CyberComposition::Simulink::SF_Matrix::Cast( matrix_39fd);
		if( false== Uml::IsDerivedFrom( project_3a06.type(), SFC::Project::meta))
			continue;
		SFC::Project project_3a0b= SFC::Project::Cast( project_3a06);
		set< SFC::BasicType> basicTypes_3a0d= project_3a0b.BasicType_kind_children();
		for( set< SFC::BasicType>::const_iterator itBasicType_3a0e= basicTypes_3a0d.begin(); itBasicType_3a0e!= basicTypes_3a0d.end(); ++itBasicType_3a0e)
		{
			SFC::BasicType currBasicType_3a0f= *itBasicType_3a0e;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_3a13;
			if( !isValidBound(boundObjs_3a13, matrix_3a02, true))
				continue;
			currMatch.matrix_3a14= matrix_3a02;
			if( !isValidBound(boundObjs_3a13, project_3a0b, true))
				continue;
			currMatch.project_3a15= project_3a0b;
			if( !isValidBound(boundObjs_3a13, currBasicType_3a0f, false))
				continue;
			currMatch.basicType_3a16= currBasicType_3a0f;
			bool Gz_guard= isGuardTrue( currMatch.basicType_3a16, currMatch.matrix_3a14, currMatch.project_3a15);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void BasicTypeExists_39f2::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_3a1a, const SFC::Project& project_3a1c)
{
	_matrix_39f9->push_back( matrix_3a1a);
	_project_39fa->push_back( project_3a1c);
}

bool Otherwise_3a1e::operator()( const Packets_t& matrixs_3a1f, const Packets_t& projects_3a22, Packets_t& matrixs_3a21, Packets_t& projects_3a24)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_3a1e" );
#endif
	_matrix_3a25= &matrixs_3a21;
	_project_3a26= &projects_3a24;
	processInputPackets( matrixs_3a1f, projects_3a22);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_3a1e::isInputUnique( const Udm::Object& matrix_3a2b, const Udm::Object& project_3a34)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_3a2d= _matrix_3a27.begin(), itProject_3a36= _project_3a30.begin(); itMatrix_3a2d!= _matrix_3a27.end(), itProject_3a36!= _project_3a30.end(); ++itMatrix_3a2d, ++itProject_3a36)
	{
		if( ( *itMatrix_3a2d== matrix_3a2b)&& ( *itProject_3a36== project_3a34))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_3a27.push_back( matrix_3a2b);
		_project_3a30.push_back( project_3a34);
	}
	return isUnique;
}

bool Otherwise_3a1e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_3a1e::processInputPackets( const Packets_t& matrixs_3a1f, const Packets_t& projects_3a22)
{
	for( Packets_t::const_iterator itMatrix_3a28= matrixs_3a1f.begin(), itProject_3a31= projects_3a22.begin(); itMatrix_3a28!= matrixs_3a1f.end(), itProject_3a31!= projects_3a22.end(); ++itMatrix_3a28, ++itProject_3a31)
	{
		bool isUnique= isInputUnique( *itMatrix_3a28, *itProject_3a31);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_3a28, *itProject_3a31);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_3a3d, currMatch.project_3a3e);
	}
}

bool Otherwise_3a1e::patternMatcher( const Udm::Object& matrix_3a29, const Udm::Object& project_3a32)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_3a29.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_3a2e= CyberComposition::Simulink::SF_Matrix::Cast( matrix_3a29);
		if( false== Uml::IsDerivedFrom( project_3a32.type(), SFC::Project::meta))
			continue;
		SFC::Project project_3a37= SFC::Project::Cast( project_3a32);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3a3c;
		if( !isValidBound(boundObjs_3a3c, matrix_3a2e, true))
			continue;
		currMatch.matrix_3a3d= matrix_3a2e;
		if( !isValidBound(boundObjs_3a3c, project_3a37, true))
			continue;
		currMatch.project_3a3e= project_3a37;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_3a1e::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_3a3f, const SFC::Project& project_3a41)
{
	_matrix_3a25->push_back( matrix_3a3f);
	_project_3a26->push_back( project_3a41);
}

void ProcessArray1_3a53::operator()( const Packets_t& typess_3a54, const Packets_t& basictypes_3a56, const Packets_t& projects_3a58, Packets_t& typess_3a5a, Packets_t& array1s_3a5b, Packets_t& projects_3a5c)
{
#ifdef PRINT_INFO
	printLog( "ProcessArray1_3a53" );
#endif
	_types_3a5d= &typess_3a5a;
	_array1_3a5e= &array1s_3a5b;
	_project_3a5f= &projects_3a5c;
	if( ( !typess_3a54.empty())&& ( !basictypes_3a56.empty())&& ( !projects_3a58.empty()))
		callGetArray1_3b6f( typess_3a54, basictypes_3a56, projects_3a58);
}

void ProcessArray1_3a53::callGetArray1_3b6f( const Packets_t& typess_3ad5, const Packets_t& dts_3ad7, const Packets_t& projects_3ad9)
{
	Packets_t typess_3adb;
	Packets_t dts_3adc;
	Packets_t projectss_3add;
	Packets_t typess_3ade;
	Packets_t dts_3adf;
	Packets_t projectss_3ae0;
	GetArray1_3ad4 getArray1_3ad4;
	getArray1_3ad4( typess_3ad5, dts_3ad7, projects_3ad9, typess_3adb, dts_3adc, projectss_3add, typess_3ade, dts_3adf, projectss_3ae0);
	if( ( !typess_3ade.empty())&& ( !dts_3adf.empty())&& ( !projectss_3ae0.empty()))
		callCreateArray1_3b73( typess_3ade, dts_3adf, projectss_3ae0);
	if( ( !typess_3adb.empty())&& ( !dts_3adc.empty())&& ( !projectss_3add.empty()))
		callUseArray1_3b77( typess_3adb, dts_3adc, projectss_3add);
}

void ProcessArray1_3a53::callCreateArray1_3b73( const Packets_t& matrixs_3a61, const Packets_t& dTs_3a65, const Packets_t& projects_3a67)
{
	Packets_t matrixs_3a63;
	Packets_t arrays_3a64;
	Packets_t projects_3a69;
	CreateArray1_3a60 createArray1_3a60;
	createArray1_3a60( matrixs_3a61, dTs_3a65, projects_3a67, matrixs_3a63, arrays_3a64, projects_3a69);
	_types_3a5d->insert( _types_3a5d->end(), matrixs_3a63.begin(), matrixs_3a63.end());
	_array1_3a5e->insert( _array1_3a5e->end(), arrays_3a64.begin(), arrays_3a64.end());
	_project_3a5f->insert( _project_3a5f->end(), projects_3a69.begin(), projects_3a69.end());
}

void ProcessArray1_3a53::callUseArray1_3b77( const Packets_t& matrixs_3a97, const Packets_t& dTs_3a9b, const Packets_t& projects_3a9d)
{
	Packets_t matrixs_3a99;
	Packets_t arrays_3a9a;
	Packets_t projects_3a9f;
	UseArray1_3a96 useArray1_3a96;
	useArray1_3a96( matrixs_3a97, dTs_3a9b, projects_3a9d, matrixs_3a99, arrays_3a9a, projects_3a9f);
	_types_3a5d->insert( _types_3a5d->end(), matrixs_3a99.begin(), matrixs_3a99.end());
	_array1_3a5e->insert( _array1_3a5e->end(), arrays_3a9a.begin(), arrays_3a9a.end());
	_project_3a5f->insert( _project_3a5f->end(), projects_3a9f.begin(), projects_3a9f.end());
}

void CreateArray1_3a60::operator()( const Packets_t& matrixs_3a61, const Packets_t& dTs_3a65, const Packets_t& projects_3a67, Packets_t& matrixs_3a63, Packets_t& arrays_3a64, Packets_t& projects_3a69)
{
#ifdef PRINT_INFO
	printLog( "CreateArray1_3a60" );
#endif
	RTTGenerator::Instance()->generateRule(3363, "CreateArray1");
	_matrix_3a6a= &matrixs_3a63;
	_array_3a6b= &arrays_3a64;
	_project_3a6c= &projects_3a69;
	processInputPackets( matrixs_3a61, dTs_3a65, projects_3a67);
}

bool CreateArray1_3a60::isInputUnique( const Udm::Object& matrix_3a71, const Udm::Object& dT_3a7a, const Udm::Object& project_3a83)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_3a73= _matrix_3a6d.begin(), itDT_3a7c= _dT_3a76.begin(), itProject_3a85= _project_3a7f.begin(); itMatrix_3a73!= _matrix_3a6d.end(), itDT_3a7c!= _dT_3a76.end(), itProject_3a85!= _project_3a7f.end(); ++itMatrix_3a73, ++itDT_3a7c, ++itProject_3a85)
	{
		if( ( *itMatrix_3a73== matrix_3a71)&& ( *itDT_3a7c== dT_3a7a)&& ( *itProject_3a85== project_3a83))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_3a6d.push_back( matrix_3a71);
		_dT_3a76.push_back( dT_3a7a);
		_project_3a7f.push_back( project_3a83);
	}
	return isUnique;
}

bool CreateArray1_3a60::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateArray1_3a60::processInputPackets( const Packets_t& matrixs_3a61, const Packets_t& dTs_3a65, const Packets_t& projects_3a67)
{
	for( Packets_t::const_iterator itMatrix_3a6e= matrixs_3a61.begin(), itDT_3a77= dTs_3a65.begin(), itProject_3a80= projects_3a67.begin(); itMatrix_3a6e!= matrixs_3a61.end(), itDT_3a77!= dTs_3a65.end(), itProject_3a80!= projects_3a67.end(); ++itMatrix_3a6e, ++itDT_3a77, ++itProject_3a80)
	{
		bool isUnique= isInputUnique( *itMatrix_3a6e, *itDT_3a77, *itProject_3a80);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_3a6e, *itDT_3a77, *itProject_3a80);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateArray1_3a60::patternMatcher( const Udm::Object& matrix_3a6f, const Udm::Object& dT_3a78, const Udm::Object& project_3a81)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_3a6f.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_3a74= CyberComposition::Simulink::SF_Matrix::Cast( matrix_3a6f);
		if( false== Uml::IsDerivedFrom( dT_3a78.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_3a7d= SFC::DT::Cast( dT_3a78);
		if( false== Uml::IsDerivedFrom( project_3a81.type(), SFC::Project::meta))
			continue;
		SFC::Project project_3a86= SFC::Project::Cast( project_3a81);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3a8b;
		if( !isValidBound(boundObjs_3a8b, matrix_3a74, true))
			continue;
		currMatch.matrix_3a8c= matrix_3a74;
		if( !isValidBound(boundObjs_3a8b, dT_3a7d, true))
			continue;
		currMatch.dT_3a8d= dT_3a7d;
		if( !isValidBound(boundObjs_3a8b, project_3a86, true))
			continue;
		currMatch.project_3a8e= project_3a86;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateArray1_3a60::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Array newArray_3a8f= SFC::Array::Create( currMatch.project_3a8e);
		SFC::Array& Array= newArray_3a8f;
		SFC::DT& DT= currMatch.dT_3a8d;
		CyberComposition::Simulink::SF_Matrix& Matrix= currMatch.matrix_3a8c;
		SFC::Project& Project= currMatch.project_3a8e;
		{
__int64 statementCount = Project.statementCount();
Array.statementIndex() = statementCount++;
Project.statementCount() = statementCount;

Array.noelem() = Matrix.rows();

};
		newArray_3a8f.dt()= currMatch.dT_3a8d;
		outputAppender( currMatch.matrix_3a8c, newArray_3a8f, currMatch.project_3a8e);
	}
}

void CreateArray1_3a60::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_3a90, const SFC::Array& array_3a92, const SFC::Project& project_3a94)
{
	_matrix_3a6a->push_back( matrix_3a90);
	_array_3a6b->push_back( array_3a92);
	_project_3a6c->push_back( project_3a94);
}

void UseArray1_3a96::operator()( const Packets_t& matrixs_3a97, const Packets_t& dTs_3a9b, const Packets_t& projects_3a9d, Packets_t& matrixs_3a99, Packets_t& arrays_3a9a, Packets_t& projects_3a9f)
{
#ifdef PRINT_INFO
	printLog( "UseArray1_3a96" );
#endif
	RTTGenerator::Instance()->generateRule(3371, "UseArray1");
	_matrix_3aa0= &matrixs_3a99;
	_array_3aa1= &arrays_3a9a;
	_project_3aa2= &projects_3a9f;
	processInputPackets( matrixs_3a97, dTs_3a9b, projects_3a9d);
}

bool UseArray1_3a96::isInputUnique( const Udm::Object& matrix_3aa7, const Udm::Object& dT_3ab0, const Udm::Object& project_3ab9)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_3aa9= _matrix_3aa3.begin(), itDT_3ab2= _dT_3aac.begin(), itProject_3abb= _project_3ab5.begin(); itMatrix_3aa9!= _matrix_3aa3.end(), itDT_3ab2!= _dT_3aac.end(), itProject_3abb!= _project_3ab5.end(); ++itMatrix_3aa9, ++itDT_3ab2, ++itProject_3abb)
	{
		if( ( *itMatrix_3aa9== matrix_3aa7)&& ( *itDT_3ab2== dT_3ab0)&& ( *itProject_3abb== project_3ab9))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_3aa3.push_back( matrix_3aa7);
		_dT_3aac.push_back( dT_3ab0);
		_project_3ab5.push_back( project_3ab9);
	}
	return isUnique;
}

bool UseArray1_3a96::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool UseArray1_3a96::isGuardTrue( SFC::Array& Array, SFC::DT& DT, CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard = Matrix.rows() == Array.noelem();;
	return Gz_guard;
}

void UseArray1_3a96::processInputPackets( const Packets_t& matrixs_3a97, const Packets_t& dTs_3a9b, const Packets_t& projects_3a9d)
{
	for( Packets_t::const_iterator itMatrix_3aa4= matrixs_3a97.begin(), itDT_3aad= dTs_3a9b.begin(), itProject_3ab6= projects_3a9d.begin(); itMatrix_3aa4!= matrixs_3a97.end(), itDT_3aad!= dTs_3a9b.end(), itProject_3ab6!= projects_3a9d.end(); ++itMatrix_3aa4, ++itDT_3aad, ++itProject_3ab6)
	{
		bool isUnique= isInputUnique( *itMatrix_3aa4, *itDT_3aad, *itProject_3ab6);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_3aa4, *itDT_3aad, *itProject_3ab6);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool UseArray1_3a96::patternMatcher( const Udm::Object& matrix_3aa5, const Udm::Object& dT_3aae, const Udm::Object& project_3ab7)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_3aa5.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_3aaa= CyberComposition::Simulink::SF_Matrix::Cast( matrix_3aa5);
		if( false== Uml::IsDerivedFrom( dT_3aae.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_3ab3= SFC::DT::Cast( dT_3aae);
		if( false== Uml::IsDerivedFrom( project_3ab7.type(), SFC::Project::meta))
			continue;
		SFC::Project project_3abc= SFC::Project::Cast( project_3ab7);
		set< SFC::Array> arrays_3abe= project_3abc.Array_kind_children();
		for( set< SFC::Array>::const_iterator itArray_3abf= arrays_3abe.begin(); itArray_3abf!= arrays_3abe.end(); ++itArray_3abf)
		{
			SFC::Array currArray_3ac0= *itArray_3abf;
			SFC::DT dT_3ac1= currArray_3ac0.dt();
			if( !dT_3ac1)
				continue;
			if( dT_3ab3!= dT_3ac1)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_3ac5;
			if( !isValidBound(boundObjs_3ac5, matrix_3aaa, true))
				continue;
			currMatch.matrix_3ac6= matrix_3aaa;
			if( !isValidBound(boundObjs_3ac5, dT_3ab3, true))
				continue;
			currMatch.dT_3ac7= dT_3ab3;
			if( !isValidBound(boundObjs_3ac5, project_3abc, true))
				continue;
			currMatch.project_3ac8= project_3abc;
			if( !isValidBound(boundObjs_3ac5, currArray_3ac0, false))
				continue;
			currMatch.array_3ac9= currArray_3ac0;
			bool Gz_guard= isGuardTrue( currMatch.array_3ac9, currMatch.dT_3ac7, currMatch.matrix_3ac6, currMatch.project_3ac8);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void UseArray1_3a96::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_3ac6, currMatch.array_3ac9, currMatch.project_3ac8);
	}
}

void UseArray1_3a96::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_3ace, const SFC::Array& array_3ad0, const SFC::Project& project_3ad2)
{
	_matrix_3aa0->push_back( matrix_3ace);
	_array_3aa1->push_back( array_3ad0);
	_project_3aa2->push_back( project_3ad2);
}

void GetArray1_3ad4::operator()( const Packets_t& typess_3ad5, const Packets_t& dts_3ad7, const Packets_t& projects_3ad9, Packets_t& typess_3adb, Packets_t& dts_3adc, Packets_t& projectss_3add, Packets_t& typess_3ade, Packets_t& dts_3adf, Packets_t& projectss_3ae0)
{
#ifdef PRINT_INFO
	printLog( "GetArray1_3ad4" );
#endif
	_types_3ae1= &typess_3adb;
	_dt_3ae2= &dts_3adc;
	_projects_3ae3= &projectss_3add;
	_types_3ae4= &typess_3ade;
	_dt_3ae5= &dts_3adf;
	_projects_3ae6= &projectss_3ae0;
	for( Packets_t::const_iterator ittypes_3ae8= typess_3ad5.begin(), itdt_3aef= dts_3ad7.begin(), itproject_3af6= projects_3ad9.begin(); ittypes_3ae8!= typess_3ad5.end(), itdt_3aef!= dts_3ad7.end(), itproject_3af6!= projects_3ad9.end(); ++ittypes_3ae8, ++itdt_3aef, ++itproject_3af6)
	{
		bool isUnique= isInputUnique( *ittypes_3ae8, *itdt_3aef, *itproject_3af6);
		if( !isUnique)
			continue;
		Packets_t onetypes_3aec( 1, *ittypes_3ae8);
		Packets_t onedt_3af3( 1, *itdt_3aef);
		Packets_t oneproject_3afa( 1, *itproject_3af6);
		executeOne( onetypes_3aec, onedt_3af3, oneproject_3afa);
	}
}

void GetArray1_3ad4::executeOne( const Packets_t& typess_3ad5, const Packets_t& dts_3ad7, const Packets_t& projects_3ad9)
{
	Packets_t matrixs_3aff;
	Packets_t dTs_3b02;
	Packets_t projects_3b05;
	Array1Exists_3afc array1Exists_3afc;
	bool isMatchArray1Exists_3afc= array1Exists_3afc( typess_3ad5, dts_3ad7, projects_3ad9, matrixs_3aff, dTs_3b02, projects_3b05);
	_types_3ae1->insert( _types_3ae1->end(), matrixs_3aff.begin(), matrixs_3aff.end());
	_dt_3ae2->insert( _dt_3ae2->end(), dTs_3b02.begin(), dTs_3b02.end());
	_projects_3ae3->insert( _projects_3ae3->end(), projects_3b05.begin(), projects_3b05.end());
	if( isMatchArray1Exists_3afc)
		return;
	Packets_t matrixs_3b3d;
	Packets_t dTs_3b40;
	Packets_t projects_3b43;
	Otherwise_3b3a otherwise_3b3a;
	bool isMatchOtherwise_3b3a= otherwise_3b3a( typess_3ad5, dts_3ad7, projects_3ad9, matrixs_3b3d, dTs_3b40, projects_3b43);
	_types_3ae4->insert( _types_3ae4->end(), matrixs_3b3d.begin(), matrixs_3b3d.end());
	_dt_3ae5->insert( _dt_3ae5->end(), dTs_3b40.begin(), dTs_3b40.end());
	_projects_3ae6->insert( _projects_3ae6->end(), projects_3b43.begin(), projects_3b43.end());
	if( isMatchOtherwise_3b3a)
		return;
}

bool GetArray1_3ad4::isInputUnique( const Udm::Object& types_3ae9, const Udm::Object& dt_3af0, const Udm::Object& project_3af7)
{
	bool isUnique= true;
	for( Packets_t::const_iterator ittypes_3aeb= _types_3ae7.begin(), itdt_3af2= _dt_3aee.begin(), itproject_3af9= _project_3af5.begin(); ittypes_3aeb!= _types_3ae7.end(), itdt_3af2!= _dt_3aee.end(), itproject_3af9!= _project_3af5.end(); ++ittypes_3aeb, ++itdt_3af2, ++itproject_3af9)
	{
		if( ( *ittypes_3aeb== types_3ae9)&& ( *itdt_3af2== dt_3af0)&& ( *itproject_3af9== project_3af7))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_types_3ae7.push_back( types_3ae9);
		_dt_3aee.push_back( dt_3af0);
		_project_3af5.push_back( project_3af7);
	}
	return isUnique;
}

bool Array1Exists_3afc::operator()( const Packets_t& matrixs_3afd, const Packets_t& dTs_3b00, const Packets_t& projects_3b03, Packets_t& matrixs_3aff, Packets_t& dTs_3b02, Packets_t& projects_3b05)
{
#ifdef PRINT_INFO
	printLog( "Array1Exists_3afc" );
#endif
	_matrix_3b06= &matrixs_3aff;
	_dT_3b07= &dTs_3b02;
	_project_3b08= &projects_3b05;
	processInputPackets( matrixs_3afd, dTs_3b00, projects_3b03);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Array1Exists_3afc::isInputUnique( const Udm::Object& matrix_3b0d, const Udm::Object& dT_3b16, const Udm::Object& project_3b1f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_3b0f= _matrix_3b09.begin(), itDT_3b18= _dT_3b12.begin(), itProject_3b21= _project_3b1b.begin(); itMatrix_3b0f!= _matrix_3b09.end(), itDT_3b18!= _dT_3b12.end(), itProject_3b21!= _project_3b1b.end(); ++itMatrix_3b0f, ++itDT_3b18, ++itProject_3b21)
	{
		if( ( *itMatrix_3b0f== matrix_3b0d)&& ( *itDT_3b18== dT_3b16)&& ( *itProject_3b21== project_3b1f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_3b09.push_back( matrix_3b0d);
		_dT_3b12.push_back( dT_3b16);
		_project_3b1b.push_back( project_3b1f);
	}
	return isUnique;
}

bool Array1Exists_3afc::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool Array1Exists_3afc::isGuardTrue( SFC::Array& Array, SFC::DT& DT, CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard = Matrix.rows() == Array.noelem();;
	return Gz_guard;
}

void Array1Exists_3afc::processInputPackets( const Packets_t& matrixs_3afd, const Packets_t& dTs_3b00, const Packets_t& projects_3b03)
{
	for( Packets_t::const_iterator itMatrix_3b0a= matrixs_3afd.begin(), itDT_3b13= dTs_3b00.begin(), itProject_3b1c= projects_3b03.begin(); itMatrix_3b0a!= matrixs_3afd.end(), itDT_3b13!= dTs_3b00.end(), itProject_3b1c!= projects_3b03.end(); ++itMatrix_3b0a, ++itDT_3b13, ++itProject_3b1c)
	{
		bool isUnique= isInputUnique( *itMatrix_3b0a, *itDT_3b13, *itProject_3b1c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_3b0a, *itDT_3b13, *itProject_3b1c);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_3b2c, currMatch.dT_3b2d, currMatch.project_3b2e);
	}
}

bool Array1Exists_3afc::patternMatcher( const Udm::Object& matrix_3b0b, const Udm::Object& dT_3b14, const Udm::Object& project_3b1d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_3b0b.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_3b10= CyberComposition::Simulink::SF_Matrix::Cast( matrix_3b0b);
		if( false== Uml::IsDerivedFrom( dT_3b14.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_3b19= SFC::DT::Cast( dT_3b14);
		if( false== Uml::IsDerivedFrom( project_3b1d.type(), SFC::Project::meta))
			continue;
		SFC::Project project_3b22= SFC::Project::Cast( project_3b1d);
		set< SFC::Array> arrays_3b24= project_3b22.Array_kind_children();
		for( set< SFC::Array>::const_iterator itArray_3b25= arrays_3b24.begin(); itArray_3b25!= arrays_3b24.end(); ++itArray_3b25)
		{
			SFC::Array currArray_3b26= *itArray_3b25;
			SFC::DT dT_3b27= currArray_3b26.dt();
			if( !dT_3b27)
				continue;
			if( dT_3b19!= dT_3b27)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_3b2b;
			if( !isValidBound(boundObjs_3b2b, matrix_3b10, true))
				continue;
			currMatch.matrix_3b2c= matrix_3b10;
			if( !isValidBound(boundObjs_3b2b, dT_3b19, true))
				continue;
			currMatch.dT_3b2d= dT_3b19;
			if( !isValidBound(boundObjs_3b2b, project_3b22, true))
				continue;
			currMatch.project_3b2e= project_3b22;
			if( !isValidBound(boundObjs_3b2b, currArray_3b26, false))
				continue;
			currMatch.array_3b2f= currArray_3b26;
			bool Gz_guard= isGuardTrue( currMatch.array_3b2f, currMatch.dT_3b2d, currMatch.matrix_3b2c, currMatch.project_3b2e);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void Array1Exists_3afc::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_3b34, const SFC::DT& dT_3b36, const SFC::Project& project_3b38)
{
	_matrix_3b06->push_back( matrix_3b34);
	_dT_3b07->push_back( dT_3b36);
	_project_3b08->push_back( project_3b38);
}

bool Otherwise_3b3a::operator()( const Packets_t& matrixs_3b3b, const Packets_t& dTs_3b3e, const Packets_t& projects_3b41, Packets_t& matrixs_3b3d, Packets_t& dTs_3b40, Packets_t& projects_3b43)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_3b3a" );
#endif
	_matrix_3b44= &matrixs_3b3d;
	_dT_3b45= &dTs_3b40;
	_project_3b46= &projects_3b43;
	processInputPackets( matrixs_3b3b, dTs_3b3e, projects_3b41);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_3b3a::isInputUnique( const Udm::Object& matrix_3b4b, const Udm::Object& dT_3b54, const Udm::Object& project_3b5d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_3b4d= _matrix_3b47.begin(), itDT_3b56= _dT_3b50.begin(), itProject_3b5f= _project_3b59.begin(); itMatrix_3b4d!= _matrix_3b47.end(), itDT_3b56!= _dT_3b50.end(), itProject_3b5f!= _project_3b59.end(); ++itMatrix_3b4d, ++itDT_3b56, ++itProject_3b5f)
	{
		if( ( *itMatrix_3b4d== matrix_3b4b)&& ( *itDT_3b56== dT_3b54)&& ( *itProject_3b5f== project_3b5d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_3b47.push_back( matrix_3b4b);
		_dT_3b50.push_back( dT_3b54);
		_project_3b59.push_back( project_3b5d);
	}
	return isUnique;
}

bool Otherwise_3b3a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_3b3a::processInputPackets( const Packets_t& matrixs_3b3b, const Packets_t& dTs_3b3e, const Packets_t& projects_3b41)
{
	for( Packets_t::const_iterator itMatrix_3b48= matrixs_3b3b.begin(), itDT_3b51= dTs_3b3e.begin(), itProject_3b5a= projects_3b41.begin(); itMatrix_3b48!= matrixs_3b3b.end(), itDT_3b51!= dTs_3b3e.end(), itProject_3b5a!= projects_3b41.end(); ++itMatrix_3b48, ++itDT_3b51, ++itProject_3b5a)
	{
		bool isUnique= isInputUnique( *itMatrix_3b48, *itDT_3b51, *itProject_3b5a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_3b48, *itDT_3b51, *itProject_3b5a);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_3b66, currMatch.dT_3b67, currMatch.project_3b68);
	}
}

bool Otherwise_3b3a::patternMatcher( const Udm::Object& matrix_3b49, const Udm::Object& dT_3b52, const Udm::Object& project_3b5b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_3b49.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_3b4e= CyberComposition::Simulink::SF_Matrix::Cast( matrix_3b49);
		if( false== Uml::IsDerivedFrom( dT_3b52.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_3b57= SFC::DT::Cast( dT_3b52);
		if( false== Uml::IsDerivedFrom( project_3b5b.type(), SFC::Project::meta))
			continue;
		SFC::Project project_3b60= SFC::Project::Cast( project_3b5b);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3b65;
		if( !isValidBound(boundObjs_3b65, matrix_3b4e, true))
			continue;
		currMatch.matrix_3b66= matrix_3b4e;
		if( !isValidBound(boundObjs_3b65, dT_3b57, true))
			continue;
		currMatch.dT_3b67= dT_3b57;
		if( !isValidBound(boundObjs_3b65, project_3b60, true))
			continue;
		currMatch.project_3b68= project_3b60;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_3b3a::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_3b69, const SFC::DT& dT_3b6b, const SFC::Project& project_3b6d)
{
	_matrix_3b44->push_back( matrix_3b69);
	_dT_3b45->push_back( dT_3b6b);
	_project_3b46->push_back( project_3b6d);
}

void ProcessColumn_3b82::operator()( const Packets_t& typess_3b83, const Packets_t& projects_3b85, Packets_t& typess_3b87, Packets_t& array1s_3b88, Packets_t& projects_3b89)
{
#ifdef PRINT_INFO
	printLog( "ProcessColumn_3b82" );
#endif
	_types_3b8a= &typess_3b87;
	_array1_3b8b= &array1s_3b88;
	_project_3b8c= &projects_3b89;
	if( ( !typess_3b83.empty())&& ( !projects_3b85.empty()))
		callProcessScalar_3b8d( typess_3b83, projects_3b85);
}

void ProcessColumn_3b82::callProcessScalar_3b8d( const Packets_t& typess_3973, const Packets_t& projects_3975)
{
	Packets_t typess_3977;
	Packets_t basictypes_3978;
	Packets_t projects_3979;
	ProcessScalar_3972 processScalar_3972;
	processScalar_3972( typess_3973, projects_3975, typess_3977, basictypes_3978, projects_3979);
	if( ( !typess_3977.empty())&& ( !basictypes_3978.empty())&& ( !projects_3979.empty()))
		callProcessArray1_3b90( typess_3977, basictypes_3978, projects_3979);
}

void ProcessColumn_3b82::callProcessArray1_3b90( const Packets_t& typess_3a54, const Packets_t& basictypes_3a56, const Packets_t& projects_3a58)
{
	Packets_t typess_3a5a;
	Packets_t array1s_3a5b;
	Packets_t projects_3a5c;
	ProcessArray1_3a53 processArray1_3a53;
	processArray1_3a53( typess_3a54, basictypes_3a56, projects_3a58, typess_3a5a, array1s_3a5b, projects_3a5c);
	_types_3b8a->insert( _types_3b8a->end(), typess_3a5a.begin(), typess_3a5a.end());
	_array1_3b8b->insert( _array1_3b8b->end(), array1s_3a5b.begin(), array1s_3a5b.end());
	_project_3b8c->insert( _project_3b8c->end(), projects_3a5c.begin(), projects_3a5c.end());
}

void DimensionTest_3b94::operator()( const Packets_t& typess_3b95, const Packets_t& projects_3b97, Packets_t& typess_3b99, Packets_t& projects_3b9a, Packets_t& typess_3b9b, Packets_t& projects_3b9c, Packets_t& typess_3b9d, Packets_t& projects_3b9e)
{
#ifdef PRINT_INFO
	printLog( "DimensionTest_3b94" );
#endif
	_types_3b9f= &typess_3b99;
	_project_3ba0= &projects_3b9a;
	_types_3ba1= &typess_3b9b;
	_project_3ba2= &projects_3b9c;
	_types_3ba3= &typess_3b9d;
	_project_3ba4= &projects_3b9e;
	for( Packets_t::const_iterator ittypes_3ba6= typess_3b95.begin(), itproject_3bad= projects_3b97.begin(); ittypes_3ba6!= typess_3b95.end(), itproject_3bad!= projects_3b97.end(); ++ittypes_3ba6, ++itproject_3bad)
	{
		bool isUnique= isInputUnique( *ittypes_3ba6, *itproject_3bad);
		if( !isUnique)
			continue;
		Packets_t onetypes_3baa( 1, *ittypes_3ba6);
		Packets_t oneproject_3bb1( 1, *itproject_3bad);
		executeOne( onetypes_3baa, oneproject_3bb1);
	}
}

void DimensionTest_3b94::executeOne( const Packets_t& typess_3b95, const Packets_t& projects_3b97)
{
	Packets_t matrixs_3bb6;
	Packets_t projects_3bb9;
	Scalar_3bb3 scalar_3bb3;
	bool isMatchScalar_3bb3= scalar_3bb3( typess_3b95, projects_3b97, matrixs_3bb6, projects_3bb9);
	_types_3b9f->insert( _types_3b9f->end(), matrixs_3bb6.begin(), matrixs_3bb6.end());
	_project_3ba0->insert( _project_3ba0->end(), projects_3bb9.begin(), projects_3bb9.end());
	if( isMatchScalar_3bb3)
		return;
	Packets_t matrixs_3bdd;
	Packets_t projects_3be0;
	ColumnVector_3bda columnVector_3bda;
	bool isMatchColumnVector_3bda= columnVector_3bda( typess_3b95, projects_3b97, matrixs_3bdd, projects_3be0);
	_types_3ba1->insert( _types_3ba1->end(), matrixs_3bdd.begin(), matrixs_3bdd.end());
	_project_3ba2->insert( _project_3ba2->end(), projects_3be0.begin(), projects_3be0.end());
	if( isMatchColumnVector_3bda)
		return;
	Packets_t matrixs_3c04;
	Packets_t projects_3c07;
	Other_3c01 other_3c01;
	bool isMatchOther_3c01= other_3c01( typess_3b95, projects_3b97, matrixs_3c04, projects_3c07);
	_types_3ba3->insert( _types_3ba3->end(), matrixs_3c04.begin(), matrixs_3c04.end());
	_project_3ba4->insert( _project_3ba4->end(), projects_3c07.begin(), projects_3c07.end());
	if( isMatchOther_3c01)
		return;
}

bool DimensionTest_3b94::isInputUnique( const Udm::Object& types_3ba7, const Udm::Object& project_3bae)
{
	bool isUnique= true;
	for( Packets_t::const_iterator ittypes_3ba9= _types_3ba5.begin(), itproject_3bb0= _project_3bac.begin(); ittypes_3ba9!= _types_3ba5.end(), itproject_3bb0!= _project_3bac.end(); ++ittypes_3ba9, ++itproject_3bb0)
	{
		if( ( *ittypes_3ba9== types_3ba7)&& ( *itproject_3bb0== project_3bae))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_types_3ba5.push_back( types_3ba7);
		_project_3bac.push_back( project_3bae);
	}
	return isUnique;
}

bool Scalar_3bb3::operator()( const Packets_t& matrixs_3bb4, const Packets_t& projects_3bb7, Packets_t& matrixs_3bb6, Packets_t& projects_3bb9)
{
#ifdef PRINT_INFO
	printLog( "Scalar_3bb3" );
#endif
	_matrix_3bba= &matrixs_3bb6;
	_project_3bbb= &projects_3bb9;
	processInputPackets( matrixs_3bb4, projects_3bb7);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Scalar_3bb3::isInputUnique( const Udm::Object& matrix_3bc0, const Udm::Object& project_3bc9)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_3bc2= _matrix_3bbc.begin(), itProject_3bcb= _project_3bc5.begin(); itMatrix_3bc2!= _matrix_3bbc.end(), itProject_3bcb!= _project_3bc5.end(); ++itMatrix_3bc2, ++itProject_3bcb)
	{
		if( ( *itMatrix_3bc2== matrix_3bc0)&& ( *itProject_3bcb== project_3bc9))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_3bbc.push_back( matrix_3bc0);
		_project_3bc5.push_back( project_3bc9);
	}
	return isUnique;
}

bool Scalar_3bb3::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool Scalar_3bb3::isGuardTrue( CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard = Matrix.rows() == 1 && Matrix.columns() == 1;;
	return Gz_guard;
}

void Scalar_3bb3::processInputPackets( const Packets_t& matrixs_3bb4, const Packets_t& projects_3bb7)
{
	for( Packets_t::const_iterator itMatrix_3bbd= matrixs_3bb4.begin(), itProject_3bc6= projects_3bb7.begin(); itMatrix_3bbd!= matrixs_3bb4.end(), itProject_3bc6!= projects_3bb7.end(); ++itMatrix_3bbd, ++itProject_3bc6)
	{
		bool isUnique= isInputUnique( *itMatrix_3bbd, *itProject_3bc6);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_3bbd, *itProject_3bc6);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_3bd2, currMatch.project_3bd3);
	}
}

bool Scalar_3bb3::patternMatcher( const Udm::Object& matrix_3bbe, const Udm::Object& project_3bc7)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_3bbe.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_3bc3= CyberComposition::Simulink::SF_Matrix::Cast( matrix_3bbe);
		if( false== Uml::IsDerivedFrom( project_3bc7.type(), SFC::Project::meta))
			continue;
		SFC::Project project_3bcc= SFC::Project::Cast( project_3bc7);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3bd1;
		if( !isValidBound(boundObjs_3bd1, matrix_3bc3, true))
			continue;
		currMatch.matrix_3bd2= matrix_3bc3;
		if( !isValidBound(boundObjs_3bd1, project_3bcc, true))
			continue;
		currMatch.project_3bd3= project_3bcc;
		bool Gz_guard= isGuardTrue( currMatch.matrix_3bd2, currMatch.project_3bd3);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Scalar_3bb3::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_3bd6, const SFC::Project& project_3bd8)
{
	_matrix_3bba->push_back( matrix_3bd6);
	_project_3bbb->push_back( project_3bd8);
}

bool ColumnVector_3bda::operator()( const Packets_t& matrixs_3bdb, const Packets_t& projects_3bde, Packets_t& matrixs_3bdd, Packets_t& projects_3be0)
{
#ifdef PRINT_INFO
	printLog( "ColumnVector_3bda" );
#endif
	_matrix_3be1= &matrixs_3bdd;
	_project_3be2= &projects_3be0;
	processInputPackets( matrixs_3bdb, projects_3bde);
	if( false== _matches.empty())
		return true;
	return false;
}

bool ColumnVector_3bda::isInputUnique( const Udm::Object& matrix_3be7, const Udm::Object& project_3bf0)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_3be9= _matrix_3be3.begin(), itProject_3bf2= _project_3bec.begin(); itMatrix_3be9!= _matrix_3be3.end(), itProject_3bf2!= _project_3bec.end(); ++itMatrix_3be9, ++itProject_3bf2)
	{
		if( ( *itMatrix_3be9== matrix_3be7)&& ( *itProject_3bf2== project_3bf0))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_3be3.push_back( matrix_3be7);
		_project_3bec.push_back( project_3bf0);
	}
	return isUnique;
}

bool ColumnVector_3bda::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool ColumnVector_3bda::isGuardTrue( CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard = Matrix.rows() != 1 && Matrix.columns() == 1;;
	return Gz_guard;
}

void ColumnVector_3bda::processInputPackets( const Packets_t& matrixs_3bdb, const Packets_t& projects_3bde)
{
	for( Packets_t::const_iterator itMatrix_3be4= matrixs_3bdb.begin(), itProject_3bed= projects_3bde.begin(); itMatrix_3be4!= matrixs_3bdb.end(), itProject_3bed!= projects_3bde.end(); ++itMatrix_3be4, ++itProject_3bed)
	{
		bool isUnique= isInputUnique( *itMatrix_3be4, *itProject_3bed);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_3be4, *itProject_3bed);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_3bf9, currMatch.project_3bfa);
	}
}

bool ColumnVector_3bda::patternMatcher( const Udm::Object& matrix_3be5, const Udm::Object& project_3bee)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_3be5.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_3bea= CyberComposition::Simulink::SF_Matrix::Cast( matrix_3be5);
		if( false== Uml::IsDerivedFrom( project_3bee.type(), SFC::Project::meta))
			continue;
		SFC::Project project_3bf3= SFC::Project::Cast( project_3bee);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3bf8;
		if( !isValidBound(boundObjs_3bf8, matrix_3bea, true))
			continue;
		currMatch.matrix_3bf9= matrix_3bea;
		if( !isValidBound(boundObjs_3bf8, project_3bf3, true))
			continue;
		currMatch.project_3bfa= project_3bf3;
		bool Gz_guard= isGuardTrue( currMatch.matrix_3bf9, currMatch.project_3bfa);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void ColumnVector_3bda::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_3bfd, const SFC::Project& project_3bff)
{
	_matrix_3be1->push_back( matrix_3bfd);
	_project_3be2->push_back( project_3bff);
}

bool Other_3c01::operator()( const Packets_t& matrixs_3c02, const Packets_t& projects_3c05, Packets_t& matrixs_3c04, Packets_t& projects_3c07)
{
#ifdef PRINT_INFO
	printLog( "Other_3c01" );
#endif
	_matrix_3c08= &matrixs_3c04;
	_project_3c09= &projects_3c07;
	processInputPackets( matrixs_3c02, projects_3c05);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Other_3c01::isInputUnique( const Udm::Object& matrix_3c0e, const Udm::Object& project_3c17)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_3c10= _matrix_3c0a.begin(), itProject_3c19= _project_3c13.begin(); itMatrix_3c10!= _matrix_3c0a.end(), itProject_3c19!= _project_3c13.end(); ++itMatrix_3c10, ++itProject_3c19)
	{
		if( ( *itMatrix_3c10== matrix_3c0e)&& ( *itProject_3c19== project_3c17))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_3c0a.push_back( matrix_3c0e);
		_project_3c13.push_back( project_3c17);
	}
	return isUnique;
}

bool Other_3c01::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Other_3c01::processInputPackets( const Packets_t& matrixs_3c02, const Packets_t& projects_3c05)
{
	for( Packets_t::const_iterator itMatrix_3c0b= matrixs_3c02.begin(), itProject_3c14= projects_3c05.begin(); itMatrix_3c0b!= matrixs_3c02.end(), itProject_3c14!= projects_3c05.end(); ++itMatrix_3c0b, ++itProject_3c14)
	{
		bool isUnique= isInputUnique( *itMatrix_3c0b, *itProject_3c14);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_3c0b, *itProject_3c14);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_3c20, currMatch.project_3c21);
	}
}

bool Other_3c01::patternMatcher( const Udm::Object& matrix_3c0c, const Udm::Object& project_3c15)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_3c0c.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_3c11= CyberComposition::Simulink::SF_Matrix::Cast( matrix_3c0c);
		if( false== Uml::IsDerivedFrom( project_3c15.type(), SFC::Project::meta))
			continue;
		SFC::Project project_3c1a= SFC::Project::Cast( project_3c15);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3c1f;
		if( !isValidBound(boundObjs_3c1f, matrix_3c11, true))
			continue;
		currMatch.matrix_3c20= matrix_3c11;
		if( !isValidBound(boundObjs_3c1f, project_3c1a, true))
			continue;
		currMatch.project_3c21= project_3c1a;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Other_3c01::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_3c22, const SFC::Project& project_3c24)
{
	_matrix_3c08->push_back( matrix_3c22);
	_project_3c09->push_back( project_3c24);
}

void CreateStructType_3c38::operator()( const Packets_t& ecsl_dp_Structs_3c39, const Packets_t& projects_3c3d, Packets_t& ecsl_dp_Structs_3c3b, Packets_t& sfc_Structs_3c3c)
{
#ifdef PRINT_INFO
	printLog( "CreateStructType_3c38" );
#endif
	RTTGenerator::Instance()->generateRule(3449, "CreateStructType");
	_ecsl_dp_Struct_3c3f= &ecsl_dp_Structs_3c3b;
	_sfc_Struct_3c40= &sfc_Structs_3c3c;
	processInputPackets( ecsl_dp_Structs_3c39, projects_3c3d);
}

bool CreateStructType_3c38::isInputUnique( const Udm::Object& ecsl_dp_Struct_3c45, const Udm::Object& project_3c4e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itecsl_dp_Struct_3c47= _ecsl_dp_Struct_3c41.begin(), itProject_3c50= _project_3c4a.begin(); itecsl_dp_Struct_3c47!= _ecsl_dp_Struct_3c41.end(), itProject_3c50!= _project_3c4a.end(); ++itecsl_dp_Struct_3c47, ++itProject_3c50)
	{
		if( ( *itecsl_dp_Struct_3c47== ecsl_dp_Struct_3c45)&& ( *itProject_3c50== project_3c4e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_ecsl_dp_Struct_3c41.push_back( ecsl_dp_Struct_3c45);
		_project_3c4a.push_back( project_3c4e);
	}
	return isUnique;
}

bool CreateStructType_3c38::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateStructType_3c38::processInputPackets( const Packets_t& ecsl_dp_Structs_3c39, const Packets_t& projects_3c3d)
{
	for( Packets_t::const_iterator itecsl_dp_Struct_3c42= ecsl_dp_Structs_3c39.begin(), itProject_3c4b= projects_3c3d.begin(); itecsl_dp_Struct_3c42!= ecsl_dp_Structs_3c39.end(), itProject_3c4b!= projects_3c3d.end(); ++itecsl_dp_Struct_3c42, ++itProject_3c4b)
	{
		bool isUnique= isInputUnique( *itecsl_dp_Struct_3c42, *itProject_3c4b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itecsl_dp_Struct_3c42, *itProject_3c4b);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateStructType_3c38::patternMatcher( const Udm::Object& ecsl_dp_Struct_3c43, const Udm::Object& project_3c4c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( ecsl_dp_Struct_3c43.type(), CyberComposition::Simulink::TypeStruct::meta))
			continue;
		CyberComposition::Simulink::TypeStruct ecsl_dp_Struct_3c48= CyberComposition::Simulink::TypeStruct::Cast( ecsl_dp_Struct_3c43);
		if( false== Uml::IsDerivedFrom( project_3c4c.type(), SFC::Project::meta))
			continue;
		SFC::Project project_3c51= SFC::Project::Cast( project_3c4c);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3c56;
		if( !isValidBound(boundObjs_3c56, ecsl_dp_Struct_3c48, true))
			continue;
		currMatch.ecsl_dp_Struct_3c57= ecsl_dp_Struct_3c48;
		if( !isValidBound(boundObjs_3c56, project_3c51, true))
			continue;
		currMatch.project_3c58= project_3c51;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateStructType_3c38::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Struct newsfc_Struct_3c59= SFC::Struct::Create( currMatch.project_3c58, SFC::Project::meta_stmnt);
		SFC::Project& Project= currMatch.project_3c58;
		CyberComposition::Simulink::TypeStruct& ecsl_dp_Struct= currMatch.ecsl_dp_Struct_3c57;
		SFC::Struct& sfc_Struct= newsfc_Struct_3c59;
		{
sfc_Struct.memberCount() = ecsl_dp_Struct.MemberCount();
sfc_Struct.name() = ecsl_dp_Struct.name();
};
		{
__int64 sc = Project.statementCount();
sfc_Struct.statementIndex() = sc++;
Project.statementCount() = sc;
};
		newsfc_Struct_3c59.tb()= currMatch.ecsl_dp_Struct_3c57;
		outputAppender( currMatch.ecsl_dp_Struct_3c57, newsfc_Struct_3c59);
	}
}

void CreateStructType_3c38::outputAppender( const CyberComposition::Simulink::TypeStruct& ecsl_dp_Struct_3c5a, const SFC::Struct& sfc_Struct_3c5c)
{
	_ecsl_dp_Struct_3c3f->push_back( ecsl_dp_Struct_3c5a);
	_sfc_Struct_3c40->push_back( sfc_Struct_3c5c);
}

void RegisterStruct_3c67::operator()( const Packets_t& sfcStructs_3c68)
{
#ifdef PRINT_INFO
	printLog( "RegisterStruct_3c67" );
#endif
	RTTGenerator::Instance()->generateRule(3457, "RegisterStruct");
	processInputPackets( sfcStructs_3c68);
}

bool RegisterStruct_3c67::isInputUnique( const Udm::Object& sfcStruct_3c6e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itsfcStruct_3c70= _sfcStruct_3c6a.begin(); itsfcStruct_3c70!= _sfcStruct_3c6a.end(); ++itsfcStruct_3c70)
	{
		if( ( *itsfcStruct_3c70== sfcStruct_3c6e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_sfcStruct_3c6a.push_back( sfcStruct_3c6e);
	return isUnique;
}

bool RegisterStruct_3c67::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void RegisterStruct_3c67::processInputPackets( const Packets_t& sfcStructs_3c68)
{
	for( Packets_t::const_iterator itsfcStruct_3c6b= sfcStructs_3c68.begin(); itsfcStruct_3c6b!= sfcStructs_3c68.end(); ++itsfcStruct_3c6b)
	{
		bool isUnique= isInputUnique( *itsfcStruct_3c6b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itsfcStruct_3c6b);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool RegisterStruct_3c67::patternMatcher( const Udm::Object& sfcStruct_3c6c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sfcStruct_3c6c.type(), SFC::Struct::meta))
			continue;
		SFC::Struct sfcStruct_3c71= SFC::Struct::Cast( sfcStruct_3c6c);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3c76;
		if( !isValidBound(boundObjs_3c76, sfcStruct_3c71, true))
			continue;
		currMatch.sfcStruct_3c77= sfcStruct_3c71;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void RegisterStruct_3c67::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Struct& sfcStruct= currMatch.sfcStruct_3c77;
		{
SFCTypesManager::getSingleton().makeTypeUnique( sfcStruct );
};
	}
}

void StructMembers_3c78::operator()( const Packets_t& typess_3c79, const Packets_t& newStructs_3c7b, Packets_t& newStructs_3c7d)
{
#ifdef PRINT_INFO
	printLog( "StructMembers_3c78" );
#endif
	_newStruct_3c7e= &newStructs_3c7d;
	_newStruct_3c7e->insert( _newStruct_3c7e->end(), newStructs_3c7b.begin(), newStructs_3c7b.end());
	if( ( !typess_3c79.empty())&& ( !newStructs_3c7b.empty()))
		callCreateStructMembers_3ca5( typess_3c79, newStructs_3c7b);
}

void StructMembers_3c78::callCreateStructMembers_3ca5( const Packets_t& ecsl_dp_Structs_3c80, const Packets_t& sfc_Structs_3c82)
{
	CreateStructMembers_3c7f createStructMembers_3c7f;
	createStructMembers_3c7f( ecsl_dp_Structs_3c80, sfc_Structs_3c82);
}

void CreateStructMembers_3c7f::operator()( const Packets_t& ecsl_dp_Structs_3c80, const Packets_t& sfc_Structs_3c82)
{
#ifdef PRINT_INFO
	printLog( "CreateStructMembers_3c7f" );
#endif
	RTTGenerator::Instance()->generateRule(3464, "CreateStructMembers");
	processInputPackets( ecsl_dp_Structs_3c80, sfc_Structs_3c82);
}

bool CreateStructMembers_3c7f::isInputUnique( const Udm::Object& ecsl_dp_Struct_3c88, const Udm::Object& sfc_Struct_3c91)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itecsl_dp_Struct_3c8a= _ecsl_dp_Struct_3c84.begin(), itsfc_Struct_3c93= _sfc_Struct_3c8d.begin(); itecsl_dp_Struct_3c8a!= _ecsl_dp_Struct_3c84.end(), itsfc_Struct_3c93!= _sfc_Struct_3c8d.end(); ++itecsl_dp_Struct_3c8a, ++itsfc_Struct_3c93)
	{
		if( ( *itecsl_dp_Struct_3c8a== ecsl_dp_Struct_3c88)&& ( *itsfc_Struct_3c93== sfc_Struct_3c91))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_ecsl_dp_Struct_3c84.push_back( ecsl_dp_Struct_3c88);
		_sfc_Struct_3c8d.push_back( sfc_Struct_3c91);
	}
	return isUnique;
}

bool CreateStructMembers_3c7f::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateStructMembers_3c7f::processInputPackets( const Packets_t& ecsl_dp_Structs_3c80, const Packets_t& sfc_Structs_3c82)
{
	for( Packets_t::const_iterator itecsl_dp_Struct_3c85= ecsl_dp_Structs_3c80.begin(), itsfc_Struct_3c8e= sfc_Structs_3c82.begin(); itecsl_dp_Struct_3c85!= ecsl_dp_Structs_3c80.end(), itsfc_Struct_3c8e!= sfc_Structs_3c82.end(); ++itecsl_dp_Struct_3c85, ++itsfc_Struct_3c8e)
	{
		bool isUnique= isInputUnique( *itecsl_dp_Struct_3c85, *itsfc_Struct_3c8e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itecsl_dp_Struct_3c85, *itsfc_Struct_3c8e);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateStructMembers_3c7f::patternMatcher( const Udm::Object& ecsl_dp_Struct_3c86, const Udm::Object& sfc_Struct_3c8f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( ecsl_dp_Struct_3c86.type(), CyberComposition::Simulink::TypeStruct::meta))
			continue;
		CyberComposition::Simulink::TypeStruct ecsl_dp_Struct_3c8b= CyberComposition::Simulink::TypeStruct::Cast( ecsl_dp_Struct_3c86);
		if( false== Uml::IsDerivedFrom( sfc_Struct_3c8f.type(), SFC::Struct::meta))
			continue;
		SFC::Struct sfc_Struct_3c94= SFC::Struct::Cast( sfc_Struct_3c8f);
		set< CyberComposition::Simulink::TypeBaseRef> ecsl_dp_StructRefs_3c96= ecsl_dp_Struct_3c8b.TypeBaseRef_kind_children();
		for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itecsl_dp_StructRef_3c97= ecsl_dp_StructRefs_3c96.begin(); itecsl_dp_StructRef_3c97!= ecsl_dp_StructRefs_3c96.end(); ++itecsl_dp_StructRef_3c97)
		{
			CyberComposition::Simulink::TypeBaseRef currecsl_dp_StructRef_3c98= *itecsl_dp_StructRef_3c97;
			CyberComposition::Simulink::SF_TypeBase ecsl_dp_TypeBase_3c99= currecsl_dp_StructRef_3c98.ref();
			if( !ecsl_dp_TypeBase_3c99)
				continue;
			SFC::DT sfc_DT_3c9a= ecsl_dp_TypeBase_3c99.dt();
			if( !sfc_DT_3c9a)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_3c9e;
			if( !isValidBound(boundObjs_3c9e, ecsl_dp_Struct_3c8b, true))
				continue;
			currMatch.ecsl_dp_Struct_3c9f= ecsl_dp_Struct_3c8b;
			if( !isValidBound(boundObjs_3c9e, sfc_Struct_3c94, true))
				continue;
			currMatch.sfc_Struct_3ca0= sfc_Struct_3c94;
			if( !isValidBound(boundObjs_3c9e, currecsl_dp_StructRef_3c98, false))
				continue;
			currMatch.ecsl_dp_StructRef_3ca1= currecsl_dp_StructRef_3c98;
			if( !isValidBound(boundObjs_3c9e, ecsl_dp_TypeBase_3c99, false))
				continue;
			currMatch.ecsl_dp_TypeBase_3ca2= ecsl_dp_TypeBase_3c99;
			if( !isValidBound(boundObjs_3c9e, sfc_DT_3c9a, false))
				continue;
			currMatch.sfc_DT_3ca3= sfc_DT_3c9a;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateStructMembers_3c7f::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newStructLocalVar_3ca4= SFC::LocalVar::Create( currMatch.sfc_Struct_3ca0, SFC::Struct::meta_memb);
		SFC::LocalVar& StructLocalVar= newStructLocalVar_3ca4;
		CyberComposition::Simulink::TypeStruct& ecsl_dp_Struct= currMatch.ecsl_dp_Struct_3c9f;
		CyberComposition::Simulink::TypeBaseRef& ecsl_dp_StructRef= currMatch.ecsl_dp_StructRef_3ca1;
		CyberComposition::Simulink::SF_TypeBase& ecsl_dp_TypeBase= currMatch.ecsl_dp_TypeBase_3ca2;
		SFC::DT& sfc_DT= currMatch.sfc_DT_3ca3;
		SFC::Struct& sfc_Struct= currMatch.sfc_Struct_3ca0;
		{
StructLocalVar.name() = ecsl_dp_StructRef.name();
StructLocalVar.statementIndex() = ecsl_dp_StructRef.MemberIndex();
};
		newStructLocalVar_3ca4.dt()= currMatch.sfc_DT_3ca3;
		newStructLocalVar_3ca4.tbr()= currMatch.ecsl_dp_StructRef_3ca1;
	}
}

void GetTypeBlock_3ca8::operator()( const Packets_t& rootFolders_3ca9, const Packets_t& projects_3cab, Packets_t& typess_3cad, Packets_t& projects_3cae)
{
#ifdef PRINT_INFO
	printLog( "GetTypeBlock_3ca8" );
#endif
	_types_3caf= &typess_3cad;
	_project_3cb0= &projects_3cae;
	if( ( !rootFolders_3ca9.empty())&& ( !projects_3cab.empty()))
		callGetTypesFromLib_3d0f( rootFolders_3ca9, projects_3cab);
	if( ( !rootFolders_3ca9.empty())&& ( !projects_3cab.empty()))
		callGetTypes_3d12( rootFolders_3ca9, projects_3cab);
}

void GetTypeBlock_3ca8::callGetTypesFromLib_3d0f( const Packets_t& rootFolders_3cdf, const Packets_t& projects_3ce2)
{
	Packets_t typeBases_3ce1;
	Packets_t projects_3ce4;
	GetTypesFromLib_3cde getTypesFromLib_3cde;
	getTypesFromLib_3cde( rootFolders_3cdf, projects_3ce2, typeBases_3ce1, projects_3ce4);
	_types_3caf->insert( _types_3caf->end(), typeBases_3ce1.begin(), typeBases_3ce1.end());
	_project_3cb0->insert( _project_3cb0->end(), projects_3ce4.begin(), projects_3ce4.end());
}

void GetTypeBlock_3ca8::callGetTypes_3d12( const Packets_t& rootFolders_3cb2, const Packets_t& projects_3cb5)
{
	Packets_t typeBases_3cb4;
	Packets_t projects_3cb7;
	GetTypes_3cb1 getTypes_3cb1;
	getTypes_3cb1( rootFolders_3cb2, projects_3cb5, typeBases_3cb4, projects_3cb7);
	_types_3caf->insert( _types_3caf->end(), typeBases_3cb4.begin(), typeBases_3cb4.end());
	_project_3cb0->insert( _project_3cb0->end(), projects_3cb7.begin(), projects_3cb7.end());
}

void GetTypes_3cb1::operator()( const Packets_t& rootFolders_3cb2, const Packets_t& projects_3cb5, Packets_t& typeBases_3cb4, Packets_t& projects_3cb7)
{
#ifdef PRINT_INFO
	printLog( "GetTypes_3cb1" );
#endif
	RTTGenerator::Instance()->generateRule(3483, "GetTypes");
	_typeBase_3cb8= &typeBases_3cb4;
	_project_3cb9= &projects_3cb7;
	processInputPackets( rootFolders_3cb2, projects_3cb5);
}

bool GetTypes_3cb1::isInputUnique( const Udm::Object& rootFolder_3cbe, const Udm::Object& project_3cc7)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itRootFolder_3cc0= _rootFolder_3cba.begin(), itProject_3cc9= _project_3cc3.begin(); itRootFolder_3cc0!= _rootFolder_3cba.end(), itProject_3cc9!= _project_3cc3.end(); ++itRootFolder_3cc0, ++itProject_3cc9)
	{
		if( ( *itRootFolder_3cc0== rootFolder_3cbe)&& ( *itProject_3cc9== project_3cc7))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_rootFolder_3cba.push_back( rootFolder_3cbe);
		_project_3cc3.push_back( project_3cc7);
	}
	return isUnique;
}

bool GetTypes_3cb1::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetTypes_3cb1::processInputPackets( const Packets_t& rootFolders_3cb2, const Packets_t& projects_3cb5)
{
	for( Packets_t::const_iterator itRootFolder_3cbb= rootFolders_3cb2.begin(), itProject_3cc4= projects_3cb5.begin(); itRootFolder_3cbb!= rootFolders_3cb2.end(), itProject_3cc4!= projects_3cb5.end(); ++itRootFolder_3cbb, ++itProject_3cc4)
	{
		bool isUnique= isInputUnique( *itRootFolder_3cbb, *itProject_3cc4);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itRootFolder_3cbb, *itProject_3cc4);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetTypes_3cb1::patternMatcher( const Udm::Object& rootFolder_3cbc, const Udm::Object& project_3cc5)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( rootFolder_3cbc.type(), CyberComposition::RootFolder::meta))
			continue;
		CyberComposition::RootFolder rootFolder_3cc1= CyberComposition::RootFolder::Cast( rootFolder_3cbc);
		if( false== Uml::IsDerivedFrom( project_3cc5.type(), SFC::Project::meta))
			continue;
		SFC::Project project_3cca= SFC::Project::Cast( project_3cc5);
		set< CyberComposition::Simulink::Types> typess_3ccc= rootFolder_3cc1.Simulink_Types_kind_children();
		for( set< CyberComposition::Simulink::Types>::const_iterator itTypes_3ccd= typess_3ccc.begin(); itTypes_3ccd!= typess_3ccc.end(); ++itTypes_3ccd)
		{
			CyberComposition::Simulink::Types currTypes_3cce= *itTypes_3ccd;
			set< CyberComposition::Simulink::SF_TypeBase> typeBases_3ccf= currTypes_3cce.SF_TypeBase_kind_children();
			for( set< CyberComposition::Simulink::SF_TypeBase>::const_iterator itTypeBase_3cd0= typeBases_3ccf.begin(); itTypeBase_3cd0!= typeBases_3ccf.end(); ++itTypeBase_3cd0)
			{
				CyberComposition::Simulink::SF_TypeBase currTypeBase_3cd1= *itTypeBase_3cd0;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_3cd5;
				if( !isValidBound(boundObjs_3cd5, rootFolder_3cc1, true))
					continue;
				currMatch.rootFolder_3cd6= rootFolder_3cc1;
				if( !isValidBound(boundObjs_3cd5, project_3cca, true))
					continue;
				currMatch.project_3cd7= project_3cca;
				if( !isValidBound(boundObjs_3cd5, currTypes_3cce, false))
					continue;
				currMatch.types_3cd8= currTypes_3cce;
				if( !isValidBound(boundObjs_3cd5, currTypeBase_3cd1, false))
					continue;
				currMatch.typeBase_3cd9= currTypeBase_3cd1;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetTypes_3cb1::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.typeBase_3cd9, currMatch.project_3cd7);
	}
}

void GetTypes_3cb1::outputAppender( const CyberComposition::Simulink::SF_TypeBase& typeBase_3cda, const SFC::Project& project_3cdc)
{
	_typeBase_3cb8->push_back( typeBase_3cda);
	_project_3cb9->push_back( project_3cdc);
}

void GetTypesFromLib_3cde::operator()( const Packets_t& rootFolders_3cdf, const Packets_t& projects_3ce2, Packets_t& typeBases_3ce1, Packets_t& projects_3ce4)
{
#ifdef PRINT_INFO
	printLog( "GetTypesFromLib_3cde" );
#endif
	RTTGenerator::Instance()->generateRule(3490, "GetTypesFromLib");
	_typeBase_3ce5= &typeBases_3ce1;
	_project_3ce6= &projects_3ce4;
	processInputPackets( rootFolders_3cdf, projects_3ce2);
}

bool GetTypesFromLib_3cde::isInputUnique( const Udm::Object& rootFolder_3ceb, const Udm::Object& project_3cf4)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itRootFolder_3ced= _rootFolder_3ce7.begin(), itProject_3cf6= _project_3cf0.begin(); itRootFolder_3ced!= _rootFolder_3ce7.end(), itProject_3cf6!= _project_3cf0.end(); ++itRootFolder_3ced, ++itProject_3cf6)
	{
		if( ( *itRootFolder_3ced== rootFolder_3ceb)&& ( *itProject_3cf6== project_3cf4))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_rootFolder_3ce7.push_back( rootFolder_3ceb);
		_project_3cf0.push_back( project_3cf4);
	}
	return isUnique;
}

bool GetTypesFromLib_3cde::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetTypesFromLib_3cde::processInputPackets( const Packets_t& rootFolders_3cdf, const Packets_t& projects_3ce2)
{
	for( Packets_t::const_iterator itRootFolder_3ce8= rootFolders_3cdf.begin(), itProject_3cf1= projects_3ce2.begin(); itRootFolder_3ce8!= rootFolders_3cdf.end(), itProject_3cf1!= projects_3ce2.end(); ++itRootFolder_3ce8, ++itProject_3cf1)
	{
		bool isUnique= isInputUnique( *itRootFolder_3ce8, *itProject_3cf1);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itRootFolder_3ce8, *itProject_3cf1);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetTypesFromLib_3cde::patternMatcher( const Udm::Object& rootFolder_3ce9, const Udm::Object& project_3cf2)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( rootFolder_3ce9.type(), CyberComposition::RootFolder::meta))
			continue;
		CyberComposition::RootFolder rootFolder_3cee= CyberComposition::RootFolder::Cast( rootFolder_3ce9);
		if( false== Uml::IsDerivedFrom( project_3cf2.type(), SFC::Project::meta))
			continue;
		SFC::Project project_3cf7= SFC::Project::Cast( project_3cf2);
		set< CyberComposition::RootFolder> rootFolders_3cf9= rootFolder_3cee.RootFolder_kind_children();
		for( set< CyberComposition::RootFolder>::const_iterator itRootFolder_3cfa= rootFolders_3cf9.begin(); itRootFolder_3cfa!= rootFolders_3cf9.end(); ++itRootFolder_3cfa)
		{
			CyberComposition::RootFolder currRootFolder_3cfb= *itRootFolder_3cfa;
			set< CyberComposition::Simulink::Types> typess_3cfc= currRootFolder_3cfb.Simulink_Types_kind_children();
			for( set< CyberComposition::Simulink::Types>::const_iterator itTypes_3cfd= typess_3cfc.begin(); itTypes_3cfd!= typess_3cfc.end(); ++itTypes_3cfd)
			{
				CyberComposition::Simulink::Types currTypes_3cfe= *itTypes_3cfd;
				set< CyberComposition::Simulink::SF_TypeBase> typeBases_3cff= currTypes_3cfe.SF_TypeBase_kind_children();
				for( set< CyberComposition::Simulink::SF_TypeBase>::const_iterator itTypeBase_3d00= typeBases_3cff.begin(); itTypeBase_3d00!= typeBases_3cff.end(); ++itTypeBase_3d00)
				{
					CyberComposition::Simulink::SF_TypeBase currTypeBase_3d01= *itTypeBase_3d00;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_3d05;
					if( !isValidBound(boundObjs_3d05, rootFolder_3cee, true))
						continue;
					currMatch.rootFolder_3d06= rootFolder_3cee;
					if( !isValidBound(boundObjs_3d05, project_3cf7, true))
						continue;
					currMatch.project_3d07= project_3cf7;
					if( !isValidBound(boundObjs_3d05, currRootFolder_3cfb, false))
						continue;
					currMatch.rootFolder_3d08= currRootFolder_3cfb;
					if( !isValidBound(boundObjs_3d05, currTypes_3cfe, false))
						continue;
					currMatch.types_3d09= currTypes_3cfe;
					if( !isValidBound(boundObjs_3d05, currTypeBase_3d01, false))
						continue;
					currMatch.typeBase_3d0a= currTypeBase_3d01;
					_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void GetTypesFromLib_3cde::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.typeBase_3d0a, currMatch.project_3d07);
	}
}

void GetTypesFromLib_3cde::outputAppender( const CyberComposition::Simulink::SF_TypeBase& typeBase_3d0b, const SFC::Project& project_3d0d)
{
	_typeBase_3ce5->push_back( typeBase_3d0b);
	_project_3ce6->push_back( project_3d0d);
}

void GetProject_3d20::operator()( const Packets_t& rootFolders_3d21, const Packets_t& sFStates_3d24, const Packets_t& projects_3d27, Packets_t& rootFolders_3d23, Packets_t& sFStates_3d26, Packets_t& projects_3d29)
{
#ifdef PRINT_INFO
	printLog( "GetProject_3d20" );
#endif
	RTTGenerator::Instance()->generateRule(3499, "GetProject");
	_rootFolder_3d2a= &rootFolders_3d23;
	_sFState_3d2b= &sFStates_3d26;
	_project_3d2c= &projects_3d29;
	processInputPackets( rootFolders_3d21, sFStates_3d24, projects_3d27);
	forwardInputs( );
}

bool GetProject_3d20::isInputUnique( const Udm::Object& rootFolder_3d31, const Udm::Object& sFState_3d3a, const Udm::Object& project_3d43)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itRootFolder_3d33= _rootFolder_3d2d.begin(), itSFState_3d3c= _sFState_3d36.begin(), itProject_3d45= _project_3d3f.begin(); itRootFolder_3d33!= _rootFolder_3d2d.end(), itSFState_3d3c!= _sFState_3d36.end(), itProject_3d45!= _project_3d3f.end(); ++itRootFolder_3d33, ++itSFState_3d3c, ++itProject_3d45)
	{
		if( ( *itRootFolder_3d33== rootFolder_3d31)&& ( *itSFState_3d3c== sFState_3d3a)&& ( *itProject_3d45== project_3d43))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_rootFolder_3d2d.push_back( rootFolder_3d31);
		_sFState_3d36.push_back( sFState_3d3a);
		_project_3d3f.push_back( project_3d43);
	}
	return isUnique;
}

bool GetProject_3d20::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetProject_3d20::processInputPackets( const Packets_t& rootFolders_3d21, const Packets_t& sFStates_3d24, const Packets_t& projects_3d27)
{
	for( Packets_t::const_iterator itRootFolder_3d2e= rootFolders_3d21.begin(), itSFState_3d37= sFStates_3d24.begin(), itProject_3d40= projects_3d27.begin(); itRootFolder_3d2e!= rootFolders_3d21.end(), itSFState_3d37!= sFStates_3d24.end(), itProject_3d40!= projects_3d27.end(); ++itRootFolder_3d2e, ++itSFState_3d37, ++itProject_3d40)
	{
		bool isUnique= isInputUnique( *itRootFolder_3d2e, *itSFState_3d37, *itProject_3d40);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itRootFolder_3d2e, *itSFState_3d37, *itProject_3d40);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetProject_3d20::patternMatcher( const Udm::Object& rootFolder_3d2f, const Udm::Object& sFState_3d38, const Udm::Object& project_3d41)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( rootFolder_3d2f.type(), CyberComposition::RootFolder::meta))
			continue;
		CyberComposition::RootFolder rootFolder_3d34= CyberComposition::RootFolder::Cast( rootFolder_3d2f);
		if( false== Uml::IsDerivedFrom( sFState_3d38.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_3d3d= CyberComposition::Simulink::SFState::Cast( sFState_3d38);
		if( false== Uml::IsDerivedFrom( project_3d41.type(), SFC::Project::meta))
			continue;
		SFC::Project project_3d46= SFC::Project::Cast( project_3d41);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3d4b;
		if( !isValidBound(boundObjs_3d4b, rootFolder_3d34, true))
			continue;
		currMatch.rootFolder_3d4c= rootFolder_3d34;
		if( !isValidBound(boundObjs_3d4b, sFState_3d3d, true))
			continue;
		currMatch.sFState_3d4d= sFState_3d3d;
		if( !isValidBound(boundObjs_3d4b, project_3d46, true))
			continue;
		currMatch.project_3d4e= project_3d46;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void GetProject_3d20::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Project& Project= currMatch.project_3d4e;
		CyberComposition::RootFolder& RootFolder= currMatch.rootFolder_3d4c;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_3d4d;
		{
SFCTypesManager::initSingleton( Project );
};
	}
}

void GetProject_3d20::forwardInputs()
{
	*_rootFolder_3d2a= _rootFolder_3d2d;
	*_sFState_3d2b= _sFState_3d36;
	*_project_3d2c= _project_3d3f;
}

void SetFileName_3d4f::operator()( const Packets_t& sFStates_3d50, const Packets_t& projects_3d54, Packets_t& sFStates_3d52, Packets_t& programs_3d53)
{
#ifdef PRINT_INFO
	printLog( "SetFileName_3d4f" );
#endif
	RTTGenerator::Instance()->generateRule(3504, "SetFileName");
	_sFState_3d56= &sFStates_3d52;
	_program_3d57= &programs_3d53;
	processInputPackets( sFStates_3d50, projects_3d54);
}

bool SetFileName_3d4f::isInputUnique( const Udm::Object& sFState_3d5c, const Udm::Object& project_3d65)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_3d5e= _sFState_3d58.begin(), itProject_3d67= _project_3d61.begin(); itSFState_3d5e!= _sFState_3d58.end(), itProject_3d67!= _project_3d61.end(); ++itSFState_3d5e, ++itProject_3d67)
	{
		if( ( *itSFState_3d5e== sFState_3d5c)&& ( *itProject_3d67== project_3d65))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_3d58.push_back( sFState_3d5c);
		_project_3d61.push_back( project_3d65);
	}
	return isUnique;
}

bool SetFileName_3d4f::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void SetFileName_3d4f::processInputPackets( const Packets_t& sFStates_3d50, const Packets_t& projects_3d54)
{
	for( Packets_t::const_iterator itSFState_3d59= sFStates_3d50.begin(), itProject_3d62= projects_3d54.begin(); itSFState_3d59!= sFStates_3d50.end(), itProject_3d62!= projects_3d54.end(); ++itSFState_3d59, ++itProject_3d62)
	{
		bool isUnique= isInputUnique( *itSFState_3d59, *itProject_3d62);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_3d59, *itProject_3d62);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool SetFileName_3d4f::patternMatcher( const Udm::Object& sFState_3d5a, const Udm::Object& project_3d63)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_3d5a.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_3d5f= CyberComposition::Simulink::SFState::Cast( sFState_3d5a);
		if( false== Uml::IsDerivedFrom( project_3d63.type(), SFC::Project::meta))
			continue;
		SFC::Project project_3d68= SFC::Project::Cast( project_3d63);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3d6d;
		if( !isValidBound(boundObjs_3d6d, sFState_3d5f, true))
			continue;
		currMatch.sFState_3d6e= sFState_3d5f;
		if( !isValidBound(boundObjs_3d6d, project_3d68, true))
			continue;
		currMatch.project_3d6f= project_3d68;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void SetFileName_3d4f::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Program newProgram_3d70= SFC::Program::Create( currMatch.project_3d6f);
		SFC::Program& Program= newProgram_3d70;
		SFC::Project& Project= currMatch.project_3d6f;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_3d6e;
		{
__int64 statementCount = Project.statementCount();
Program.statementIndex() = statementCount++;
Project.statementCount() = statementCount;
};
		{
Project.RefId() = Program.RefId() = SFState.RefId();
};
		{
string stateName = SFState.name();
Program.filename() = stateName;
};
		outputAppender( currMatch.sFState_3d6e, newProgram_3d70);
	}
}

void SetFileName_3d4f::outputAppender( const CyberComposition::Simulink::SFState& sFState_3d71, const SFC::Program& program_3d73)
{
	_sFState_3d56->push_back( sFState_3d71);
	_program_3d57->push_back( program_3d73);
}

void ProcessProgram_3d75::operator()( const Packets_t& states_3d76, const Packets_t& programs_3d78)
{
#ifdef PRINT_INFO
	printLog( "ProcessProgram_3d75" );
#endif
	for( Packets_t::const_iterator itstate_3d7b= states_3d76.begin(), itprogram_3d82= programs_3d78.begin(); itstate_3d7b!= states_3d76.end(), itprogram_3d82!= programs_3d78.end(); ++itstate_3d7b, ++itprogram_3d82)
	{
		bool isUnique= isInputUnique( *itstate_3d7b, *itprogram_3d82);
		if( !isUnique)
			continue;
		Packets_t onestate_3d7f( 1, *itstate_3d7b);
		Packets_t oneprogram_3d86( 1, *itprogram_3d82);
		executeOne( onestate_3d7f, oneprogram_3d86);
	}
}

void ProcessProgram_3d75::executeOne( const Packets_t& states_3d76, const Packets_t& programs_3d78)
{
	if( ( !states_3d76.empty())&& ( !programs_3d78.empty()))
		callClearTables_5bf4( states_3d76, programs_3d78);
}

bool ProcessProgram_3d75::isInputUnique( const Udm::Object& state_3d7c, const Udm::Object& program_3d83)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_3d7e= _state_3d7a.begin(), itprogram_3d85= _program_3d81.begin(); itstate_3d7e!= _state_3d7a.end(), itprogram_3d85!= _program_3d81.end(); ++itstate_3d7e, ++itprogram_3d85)
	{
		if( ( *itstate_3d7e== state_3d7c)&& ( *itprogram_3d85== program_3d83))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_3d7a.push_back( state_3d7c);
		_program_3d81.push_back( program_3d83);
	}
	return isUnique;
}

void ProcessProgram_3d75::callClearTables_5bf4( const Packets_t& sFStates_4255, const Packets_t& programs_4258)
{
	Packets_t sFStates_4257;
	Packets_t programs_425a;
	ClearTables_4254 clearTables_4254;
	clearTables_4254( sFStates_4255, programs_4258, sFStates_4257, programs_425a);
	if( ( !sFStates_4257.empty())&& ( !programs_425a.empty()))
		callCreateStateLabels_5bf7( sFStates_4257, programs_425a);
}

void ProcessProgram_3d75::callCreateStateLabels_5bf7( const Packets_t& states_4276, const Packets_t& programs_4278)
{
	Packets_t states_427a;
	Packets_t programs_427b;
	CreateStateLabels_4275 createStateLabels_4275;
	createStateLabels_4275( states_4276, programs_4278, states_427a, programs_427b);
	if( ( !states_427a.empty())&& ( !programs_427b.empty()))
		callCreateDEVars_5bfa( states_427a, programs_427b);
}

void ProcessProgram_3d75::callCreateDEVars_5bfa( const Packets_t& states_4491, const Packets_t& programs_4493)
{
	Packets_t states_4495;
	Packets_t programs_4496;
	CreateDEVars_4490 createDEVars_4490;
	createDEVars_4490( states_4491, programs_4493, states_4495, programs_4496);
	if( ( !states_4495.empty())&& ( !programs_4496.empty()))
		callCreateFuncStateFunctions_5bfd( states_4495, programs_4496);
}

void ProcessProgram_3d75::callCreateFuncStateFunctions_5bfd( const Packets_t& states_4834, const Packets_t& programs_4836)
{
	Packets_t states_4838;
	Packets_t programs_4839;
	CreateFuncStateFunctions_4833 createFuncStateFunctions_4833;
	createFuncStateFunctions_4833( states_4834, programs_4836, states_4838, programs_4839);
	if( ( !states_4838.empty())&& ( !programs_4839.empty()))
		callCreateFSFunctionBodies_5c00( states_4838, programs_4839);
}

void ProcessProgram_3d75::callCreateFSFunctionBodies_5c00( const Packets_t& states_3dbf, const Packets_t& programs_3dc1)
{
	Packets_t states_3dc3;
	Packets_t programs_3dc4;
	CreateFSFunctionBodies_3dbe createFSFunctionBodies_3dbe;
	createFSFunctionBodies_3dbe( states_3dbf, programs_3dc1, states_3dc3, programs_3dc4);
	if( ( !states_3dc3.empty())&& ( !programs_3dc4.empty()))
		callCreateFunctions_5c03( states_3dc3, programs_3dc4);
}

void ProcessProgram_3d75::callCreateFunctions_5c03( const Packets_t& states_571d, const Packets_t& programs_571f)
{
	Packets_t states_5721;
	Packets_t programs_5722;
	CreateFunctions_571c createFunctions_571c;
	createFunctions_571c( states_571d, programs_571f, states_5721, programs_5722);
	if( ( !states_5721.empty())&& ( !programs_5722.empty()))
		callPopulateFunctions_5c06( states_5721, programs_5722);
}

void ProcessProgram_3d75::callPopulateFunctions_5c06( const Packets_t& states_4992, const Packets_t& programs_4994)
{
	Packets_t states_4996;
	Packets_t programs_4997;
	PopulateFunctions_4991 populateFunctions_4991;
	populateFunctions_4991( states_4992, programs_4994, states_4996, programs_4997);
	if( ( !states_4996.empty())&& ( !programs_4997.empty()))
		callCreateRootFunction_5c09( states_4996, programs_4997);
}

void ProcessProgram_3d75::callCreateRootFunction_5c09( const Packets_t& states_575f, const Packets_t& programs_5761)
{
	Packets_t states_5763;
	Packets_t programs_5764;
	CreateRootFunction_575e createRootFunction_575e;
	createRootFunction_575e( states_575f, programs_5761, states_5763, programs_5764);
	if( ( !states_5763.empty())&& ( !programs_5764.empty()))
		callCreateInitFunction_5c0c( states_5763, programs_5764);
}

void ProcessProgram_3d75::callCreateInitFunction_5c0c( const Packets_t& states_599e, const Packets_t& programs_59a0)
{
	Packets_t states_59a2;
	Packets_t programs_59a3;
	CreateInitFunction_599d createInitFunction_599d;
	createInitFunction_599d( states_599e, programs_59a0, states_59a2, programs_59a3);
	if( ( !states_59a2.empty())&& ( !programs_59a3.empty()))
		callCreateStatusFunction_5c0f( states_59a2, programs_59a3);
}

void ProcessProgram_3d75::callCreateStatusFunction_5c0f( const Packets_t& states_3d89, const Packets_t& programs_3d8b)
{
	Packets_t states_3d8d;
	Packets_t programs_3d8e;
	CreateStatusFunction_3d88 createStatusFunction_3d88;
	createStatusFunction_3d88( states_3d89, programs_3d8b, states_3d8d, programs_3d8e);
	if( ( !states_3d8d.empty())&& ( !programs_3d8e.empty()))
		callMarkLegacy_5c12( states_3d8d, programs_3d8e);
}

void ProcessProgram_3d75::callMarkLegacy_5c12( const Packets_t& sFStates_5bd8, const Packets_t& programs_5bda)
{
	MarkLegacy_5bd7 markLegacy_5bd7;
	markLegacy_5bd7( sFStates_5bd8, programs_5bda);
}

void CreateStatusFunction_3d88::operator()( const Packets_t& states_3d89, const Packets_t& programs_3d8b, Packets_t& states_3d8d, Packets_t& programs_3d8e)
{
#ifdef PRINT_INFO
	printLog( "CreateStatusFunction_3d88" );
#endif
	_state_3d8f= &states_3d8d;
	_program_3d90= &programs_3d8e;
	if( ( !states_3d89.empty())&& ( !programs_3d8b.empty()))
		callCreateStatusFunction_3dbb( states_3d89, programs_3d8b);
	_state_3d8f->insert( _state_3d8f->end(), states_3d89.begin(), states_3d89.end());
	_program_3d90->insert( _program_3d90->end(), programs_3d8b.begin(), programs_3d8b.end());
}

void CreateStatusFunction_3d88::callCreateStatusFunction_3dbb( const Packets_t& sFStates_3d92, const Packets_t& programs_3d94)
{
	CreateStatusFunction_3d91 createStatusFunction_3d91;
	createStatusFunction_3d91( sFStates_3d92, programs_3d94);
}

void CreateStatusFunction_3d91::operator()( const Packets_t& sFStates_3d92, const Packets_t& programs_3d94)
{
#ifdef PRINT_INFO
	printLog( "CreateStatusFunction_3d91" );
#endif
	RTTGenerator::Instance()->generateRule(3520, "CreateStatusFunction");
	processInputPackets( sFStates_3d92, programs_3d94);
}

bool CreateStatusFunction_3d91::isInputUnique( const Udm::Object& sFState_3d9a, const Udm::Object& program_3da3)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_3d9c= _sFState_3d96.begin(), itProgram_3da5= _program_3d9f.begin(); itSFState_3d9c!= _sFState_3d96.end(), itProgram_3da5!= _program_3d9f.end(); ++itSFState_3d9c, ++itProgram_3da5)
	{
		if( ( *itSFState_3d9c== sFState_3d9a)&& ( *itProgram_3da5== program_3da3))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_3d96.push_back( sFState_3d9a);
		_program_3d9f.push_back( program_3da3);
	}
	return isUnique;
}

bool CreateStatusFunction_3d91::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateStatusFunction_3d91::processInputPackets( const Packets_t& sFStates_3d92, const Packets_t& programs_3d94)
{
	for( Packets_t::const_iterator itSFState_3d97= sFStates_3d92.begin(), itProgram_3da0= programs_3d94.begin(); itSFState_3d97!= sFStates_3d92.end(), itProgram_3da0!= programs_3d94.end(); ++itSFState_3d97, ++itProgram_3da0)
	{
		bool isUnique= isInputUnique( *itSFState_3d97, *itProgram_3da0);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_3d97, *itProgram_3da0);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateStatusFunction_3d91::patternMatcher( const Udm::Object& sFState_3d98, const Udm::Object& program_3da1)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_3d98.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_3d9d= CyberComposition::Simulink::SFState::Cast( sFState_3d98);
		if( false== Uml::IsDerivedFrom( program_3da1.type(), SFC::Program::meta))
			continue;
		SFC::Program program_3da6= SFC::Program::Cast( program_3da1);
		set< SFC::Function> statuss_3da8= sFState_3d9d.status();
		for( set< SFC::Function>::const_iterator itStatuss_3da9= statuss_3da8.begin(); itStatuss_3da9!= statuss_3da8.end(); ++itStatuss_3da9)
		{
			SFC::Function currStatus_3daa= *itStatuss_3da9;
			set< SFC::Arg> args_3dab= currStatus_3daa.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itArg_3dac= args_3dab.begin(); itArg_3dac!= args_3dab.end(); ++itArg_3dac)
			{
				SFC::Arg currArg_3dad= *itArg_3dac;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_3db1;
				if( !isValidBound(boundObjs_3db1, sFState_3d9d, true))
					continue;
				currMatch.sFState_3db2= sFState_3d9d;
				if( !isValidBound(boundObjs_3db1, program_3da6, true))
					continue;
				currMatch.program_3db3= program_3da6;
				if( !isValidBound(boundObjs_3db1, currArg_3dad, false))
					continue;
				currMatch.arg_3db4= currArg_3dad;
				if( !isValidBound(boundObjs_3db1, currStatus_3daa, false))
					continue;
				currMatch.status_3db5= currStatus_3daa;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void CreateStatusFunction_3d91::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function newgetStatus_3db6= SFC::Function::Create( currMatch.program_3db3, SFC::Program::meta_stmnt);
		SFC::Return newReturn_3db7= SFC::Return::Create( newgetStatus_3db6, SFC::Function::meta_stmnt);
		SFC::FunctionCall newFunctionCall_3db8= SFC::FunctionCall::Create( newReturn_3db7, SFC::Return::meta_retexpr);
		SFC::ArgVal newArgVal_3db9= SFC::ArgVal::Create( newFunctionCall_3db8);
		SFC::Str newStr_3dba= SFC::Str::Create( newArgVal_3db9, SFC::ArgVal::meta_argexpr);
		SFC::Arg& Arg= currMatch.arg_3db4;
		SFC::ArgVal& ArgVal= newArgVal_3db9;
		SFC::FunctionCall& FunctionCall= newFunctionCall_3db8;
		SFC::Program& Program= currMatch.program_3db3;
		SFC::Return& Return= newReturn_3db7;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_3db2;
		SFC::Function& Status= currMatch.status_3db5;
		SFC::Str& Str= newStr_3dba;
		SFC::Function& getStatus= newgetStatus_3db6;
		{
getStatus.RefId() = Return.RefId() = Status.RefId();
};
		{
getStatus.name() = "getStatus";
getStatus.dt() = SFCTypesManager::getSingleton().getBasicType( "string" );
};
		{
__int64 statementCount = getStatus.statementCount();
Return.statementIndex() = statementCount++;
getStatus.statementCount() = statementCount;
};
		{
ArgVal.argIndex() = 0;
};
		{
Str.val() = "";
};
		{
__int64 statementCount = Program.statementCount();
getStatus.statementIndex() = statementCount++;
Program.statementCount() = statementCount;
};
		newFunctionCall_3db8.callee()= currMatch.status_3db5;
		newArgVal_3db9.arg()+= currMatch.arg_3db4;
	}
}

void CreateFSFunctionBodies_3dbe::operator()( const Packets_t& states_3dbf, const Packets_t& programs_3dc1, Packets_t& states_3dc3, Packets_t& programs_3dc4)
{
#ifdef PRINT_INFO
	printLog( "CreateFSFunctionBodies_3dbe" );
#endif
	_state_3dc5= &states_3dc3;
	_program_3dc6= &programs_3dc4;
	if( ( !states_3dbf.empty())&& ( !programs_3dc1.empty()))
		callPopulateGRFSFunction_424b( states_3dbf, programs_3dc1);
	_state_3dc5->insert( _state_3dc5->end(), states_3dbf.begin(), states_3dbf.end());
	_program_3dc6->insert( _program_3dc6->end(), programs_3dc1.begin(), programs_3dc1.end());
}

void CreateFSFunctionBodies_3dbe::callPopulateGRFSFunction_424b( const Packets_t& states_3dc8, const Packets_t& programs_3dca)
{
	Packets_t states_3dcc;
	Packets_t programs_3dcd;
	PopulateGRFSFunction_3dc7 populateGRFSFunction_3dc7;
	populateGRFSFunction_3dc7( states_3dc8, programs_3dca, states_3dcc, programs_3dcd);
	if( ( !states_3dcc.empty())&& ( !programs_3dcd.empty()))
		callPopulateEMFSFunction_424e( states_3dcc, programs_3dcd);
}

void CreateFSFunctionBodies_3dbe::callPopulateEMFSFunction_424e( const Packets_t& states_41c6, const Packets_t& programs_41c8)
{
	Packets_t states_41ca;
	Packets_t programs_41cb;
	PopulateEMFSFunction_41c5 populateEMFSFunction_41c5;
	populateEMFSFunction_41c5( states_41c6, programs_41c8, states_41ca, programs_41cb);
	if( ( !states_41ca.empty())&& ( !programs_41cb.empty()))
		callGetSubStates_4251( states_41ca, programs_41cb);
}

void CreateFSFunctionBodies_3dbe::callGetSubStates_4251( const Packets_t& sFStates_4223, const Packets_t& parStmnts_4226)
{
	Packets_t sFSubStates_4225;
	Packets_t parStmnts_4228;
	GetSubStates_4222 getSubStates_4222;
	getSubStates_4222( sFStates_4223, parStmnts_4226, sFSubStates_4225, parStmnts_4228);
	if( ( !sFSubStates_4225.empty())&& ( !parStmnts_4228.empty()))
		callPopulateGRFSFunction_424b( sFSubStates_4225, parStmnts_4228);
}

void PopulateGRFSFunction_3dc7::operator()( const Packets_t& states_3dc8, const Packets_t& programs_3dca, Packets_t& states_3dcc, Packets_t& programs_3dcd)
{
#ifdef PRINT_INFO
	printLog( "PopulateGRFSFunction_3dc7" );
#endif
	_state_3dce= &states_3dcc;
	_program_3dcf= &programs_3dcd;
	if( ( !states_3dc8.empty())&& ( !programs_3dca.empty()))
		callGetGRFuncStateFunction_41b8( states_3dc8, programs_3dca);
	_state_3dce->insert( _state_3dce->end(), states_3dc8.begin(), states_3dc8.end());
	_program_3dcf->insert( _program_3dcf->end(), programs_3dca.begin(), programs_3dca.end());
}

void PopulateGRFSFunction_3dc7::callGetGRFuncStateFunction_41b8( const Packets_t& sFStates_3dd1, const Packets_t& programs_3dd4)
{
	Packets_t sFStates_3dd3;
	Packets_t execs_3dd6;
	GetGRFuncStateFunction_3dd0 getGRFuncStateFunction_3dd0;
	getGRFuncStateFunction_3dd0( sFStates_3dd1, programs_3dd4, sFStates_3dd3, execs_3dd6);
	if( ( !sFStates_3dd3.empty())&& ( !execs_3dd6.empty()))
		callTransStartMap_41bb( sFStates_3dd3, execs_3dd6);
}

void PopulateGRFSFunction_3dc7::callTransStartMap_41bb( const Packets_t& states_3f9f, const Packets_t& css_3fa1)
{
	Packets_t states_3fa3;
	Packets_t css_3fa4;
	TransStartMap_3f9e transStartMap_3f9e;
	transStartMap_3f9e( states_3f9f, css_3fa1, states_3fa3, css_3fa4);
	if( ( !states_3fa3.empty())&& ( !css_3fa4.empty()))
		callDirectInFunction_41be( states_3fa3, css_3fa4);
}

void PopulateGRFSFunction_3dc7::callDirectInFunction_41be( const Packets_t& sFStates_3e02, const Packets_t& functions_3e05)
{
	Packets_t sFStates_3e04;
	Packets_t functions_3e07;
	DirectInFunction_3e01 directInFunction_3e01;
	directInFunction_3e01( sFStates_3e02, functions_3e05, sFStates_3e04, functions_3e07);
	if( ( !sFStates_3e04.empty())&& ( !functions_3e07.empty())&& ( !functions_3e07.empty()))
		callTransStartTransitions_41c1( sFStates_3e04, functions_3e07, functions_3e07);
}

void PopulateGRFSFunction_3dc7::callTransStartTransitions_41c1( const Packets_t& states_3e20, const Packets_t& fcns_3e22, const Packets_t& css_3e24)
{
	TransStartTransitions_3e1f transStartTransitions_3e1f;
	transStartTransitions_3e1f( states_3e20, fcns_3e22, css_3e24);
}

void GetGRFuncStateFunction_3dd0::operator()( const Packets_t& sFStates_3dd1, const Packets_t& programs_3dd4, Packets_t& sFStates_3dd3, Packets_t& execs_3dd6)
{
#ifdef PRINT_INFO
	printLog( "GetGRFuncStateFunction_3dd0" );
#endif
	RTTGenerator::Instance()->generateRule(3555, "GetGRFuncStateFunction");
	_sFState_3dd7= &sFStates_3dd3;
	_exec_3dd8= &execs_3dd6;
	processInputPackets( sFStates_3dd1, programs_3dd4);
}

bool GetGRFuncStateFunction_3dd0::isInputUnique( const Udm::Object& sFState_3ddd, const Udm::Object& program_3de6)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_3ddf= _sFState_3dd9.begin(), itProgram_3de8= _program_3de2.begin(); itSFState_3ddf!= _sFState_3dd9.end(), itProgram_3de8!= _program_3de2.end(); ++itSFState_3ddf, ++itProgram_3de8)
	{
		if( ( *itSFState_3ddf== sFState_3ddd)&& ( *itProgram_3de8== program_3de6))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_3dd9.push_back( sFState_3ddd);
		_program_3de2.push_back( program_3de6);
	}
	return isUnique;
}

bool GetGRFuncStateFunction_3dd0::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool GetGRFuncStateFunction_3dd0::isGuardTrue( SFC::Function& Exec, SFC::Program& Program, CyberComposition::Simulink::SFState& SFState, SFC::StateLabel& StateLabel)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( SFState.Decomposition() ) == "FUNC_STATE" &&
 static_cast< std::string >( SFState.Order() ) == "-1";;
	return Gz_guard;
}

void GetGRFuncStateFunction_3dd0::processInputPackets( const Packets_t& sFStates_3dd1, const Packets_t& programs_3dd4)
{
	for( Packets_t::const_iterator itSFState_3dda= sFStates_3dd1.begin(), itProgram_3de3= programs_3dd4.begin(); itSFState_3dda!= sFStates_3dd1.end(), itProgram_3de3!= programs_3dd4.end(); ++itSFState_3dda, ++itProgram_3de3)
	{
		bool isUnique= isInputUnique( *itSFState_3dda, *itProgram_3de3);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_3dda, *itProgram_3de3);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetGRFuncStateFunction_3dd0::patternMatcher( const Udm::Object& sFState_3ddb, const Udm::Object& program_3de4)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_3ddb.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_3de0= CyberComposition::Simulink::SFState::Cast( sFState_3ddb);
		if( false== Uml::IsDerivedFrom( program_3de4.type(), SFC::Program::meta))
			continue;
		SFC::Program program_3de9= SFC::Program::Cast( program_3de4);
		set< SFC::Function> execs_3deb= sFState_3de0.exec();
		for( set< SFC::Function>::const_iterator itExecs_3dec= execs_3deb.begin(); itExecs_3dec!= execs_3deb.end(); ++itExecs_3dec)
		{
			SFC::Function currExec_3ded= *itExecs_3dec;
			set< SFC::StateLabel> stateLabels_3dee= sFState_3de0.src();
			for( set< SFC::StateLabel>::const_iterator itStateLabels_3def= stateLabels_3dee.begin(); itStateLabels_3def!= stateLabels_3dee.end(); ++itStateLabels_3def)
			{
				SFC::StateLabel currStateLabel_3df0= *itStateLabels_3def;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_3df4;
				if( !isValidBound(boundObjs_3df4, sFState_3de0, true))
					continue;
				currMatch.sFState_3df5= sFState_3de0;
				if( !isValidBound(boundObjs_3df4, program_3de9, true))
					continue;
				currMatch.program_3df6= program_3de9;
				if( !isValidBound(boundObjs_3df4, currStateLabel_3df0, false))
					continue;
				currMatch.stateLabel_3df7= currStateLabel_3df0;
				if( !isValidBound(boundObjs_3df4, currExec_3ded, false))
					continue;
				currMatch.exec_3df8= currExec_3ded;
				bool Gz_guard= isGuardTrue( currMatch.exec_3df8, currMatch.program_3df6, currMatch.sFState_3df5, currMatch.stateLabel_3df7);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetGRFuncStateFunction_3dd0::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_3df5, currMatch.exec_3df8);
	}
}

void GetGRFuncStateFunction_3dd0::outputAppender( const CyberComposition::Simulink::SFState& sFState_3dfd, const SFC::Function& exec_3dff)
{
	_sFState_3dd7->push_back( sFState_3dfd);
	_exec_3dd8->push_back( exec_3dff);
}

void DirectInFunction_3e01::operator()( const Packets_t& sFStates_3e02, const Packets_t& functions_3e05, Packets_t& sFStates_3e04, Packets_t& functions_3e07)
{
#ifdef PRINT_INFO
	printLog( "DirectInFunction_3e01" );
#endif
	RTTGenerator::Instance()->generateRule(3562, "DirectInFunction");
	_sFState_3e08= &sFStates_3e04;
	_function_3e09= &functions_3e07;
	processInputPackets( sFStates_3e02, functions_3e05);
	forwardInputs( );
}

bool DirectInFunction_3e01::isInputUnique( const Udm::Object& sFState_3e0e, const Udm::Object& function_3e17)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_3e10= _sFState_3e0a.begin(), itFunction_3e19= _function_3e13.begin(); itSFState_3e10!= _sFState_3e0a.end(), itFunction_3e19!= _function_3e13.end(); ++itSFState_3e10, ++itFunction_3e19)
	{
		if( ( *itSFState_3e10== sFState_3e0e)&& ( *itFunction_3e19== function_3e17))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_3e0a.push_back( sFState_3e0e);
		_function_3e13.push_back( function_3e17);
	}
	return isUnique;
}

void DirectInFunction_3e01::processInputPackets( const Packets_t& sFStates_3e02, const Packets_t& functions_3e05)
{
	for( Packets_t::const_iterator itSFState_3e0b= sFStates_3e02.begin(), itFunction_3e14= functions_3e05.begin(); itSFState_3e0b!= sFStates_3e02.end(), itFunction_3e14!= functions_3e05.end(); ++itSFState_3e0b, ++itFunction_3e14)
	{
		bool isUnique= isInputUnique( *itSFState_3e0b, *itFunction_3e14);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_3e0b, *itFunction_3e14);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool DirectInFunction_3e01::patternMatcher( const Udm::Object& sFState_3e0c, const Udm::Object& function_3e15)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_3e0c.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_3e11= CyberComposition::Simulink::SFState::Cast( sFState_3e0c);
		if( false== Uml::IsDerivedFrom( function_3e15.type(), SFC::Function::meta))
			continue;
		SFC::Function function_3e1a= SFC::Function::Cast( function_3e15);
		Match currMatch;
		currMatch.sFState_3e1d= sFState_3e11;
		currMatch.function_3e1e= function_3e1a;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void DirectInFunction_3e01::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
	}
}

void DirectInFunction_3e01::forwardInputs()
{
	*_sFState_3e08= _sFState_3e0a;
	*_function_3e09= _function_3e13;
}

void TransStartTransitions_3e1f::operator()( const Packets_t& states_3e20, const Packets_t& fcns_3e22, const Packets_t& css_3e24)
{
#ifdef PRINT_INFO
	printLog( "TransStartTransitions_3e1f" );
#endif
	if( ( !states_3e20.empty())&& ( !fcns_3e22.empty())&& ( !css_3e24.empty()))
		callInitTCVarLoop_3f91( states_3e20, fcns_3e22, css_3e24);
}

void TransStartTransitions_3e1f::callInitTCVarLoop_3f91( const Packets_t& sFStates_3f4e, const Packets_t& functions_3f51, const Packets_t& compoundStatements_3f54)
{
	Packets_t sFStates_3f50;
	Packets_t functions_3f53;
	Packets_t conditionalGroups_3f56;
	InitTCVarLoop_3f4d initTCVarLoop_3f4d;
	initTCVarLoop_3f4d( sFStates_3f4e, functions_3f51, compoundStatements_3f54, sFStates_3f50, functions_3f53, conditionalGroups_3f56);
	if( ( !sFStates_3f50.empty())&& ( !functions_3f53.empty())&& ( !conditionalGroups_3f56.empty()))
		callGetStartTC_3f95( sFStates_3f50, functions_3f53, conditionalGroups_3f56);
}

void TransStartTransitions_3e1f::callGetStartTC_3f95( const Packets_t& sFStates_3e27, const Packets_t& functions_3e2b, const Packets_t& conditionalGroups_3e2e)
{
	Packets_t sFStates_3e29;
	Packets_t sFTransStarts_3e2a;
	Packets_t functions_3e2d;
	Packets_t conditionalGroups_3e30;
	GetStartTC_3e26 getStartTC_3e26;
	getStartTC_3e26( sFStates_3e27, functions_3e2b, conditionalGroups_3e2e, sFStates_3e29, sFTransStarts_3e2a, functions_3e2d, conditionalGroups_3e30);
	if( ( !sFStates_3e29.empty())&& ( !sFTransStarts_3e2a.empty())&& ( !functions_3e2d.empty())&& ( !conditionalGroups_3e30.empty()))
		callEnterTransConnectorRecurse_3f99( sFStates_3e29, sFTransStarts_3e2a, functions_3e2d, conditionalGroups_3e30);
}

void TransStartTransitions_3e1f::callEnterTransConnectorRecurse_3f99( const Packets_t& states_3e61, const Packets_t& tcs_3e63, const Packets_t& fcns_3e65, const Packets_t& cgs_3e67)
{
	EnterTransConnectorRecurse2_3e60 enterTransConnectorRecurse2_3e60;
	enterTransConnectorRecurse2_3e60( states_3e61, tcs_3e63, fcns_3e65, cgs_3e67);
}

void GetStartTC_3e26::operator()( const Packets_t& sFStates_3e27, const Packets_t& functions_3e2b, const Packets_t& conditionalGroups_3e2e, Packets_t& sFStates_3e29, Packets_t& sFTransStarts_3e2a, Packets_t& functions_3e2d, Packets_t& conditionalGroups_3e30)
{
#ifdef PRINT_INFO
	printLog( "GetStartTC_3e26" );
#endif
	RTTGenerator::Instance()->generateRule(4715, "GetStartTC");
	_sFState_3e31= &sFStates_3e29;
	_sFTransStart_3e32= &sFTransStarts_3e2a;
	_function_3e33= &functions_3e2d;
	_conditionalGroup_3e34= &conditionalGroups_3e30;
	processInputPackets( sFStates_3e27, functions_3e2b, conditionalGroups_3e2e);
}

bool GetStartTC_3e26::isInputUnique( const Udm::Object& sFState_3e39, const Udm::Object& function_3e42, const Udm::Object& conditionalGroup_3e4b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_3e3b= _sFState_3e35.begin(), itFunction_3e44= _function_3e3e.begin(), itConditionalGroup_3e4d= _conditionalGroup_3e47.begin(); itSFState_3e3b!= _sFState_3e35.end(), itFunction_3e44!= _function_3e3e.end(), itConditionalGroup_3e4d!= _conditionalGroup_3e47.end(); ++itSFState_3e3b, ++itFunction_3e44, ++itConditionalGroup_3e4d)
	{
		if( ( *itSFState_3e3b== sFState_3e39)&& ( *itFunction_3e44== function_3e42)&& ( *itConditionalGroup_3e4d== conditionalGroup_3e4b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_3e35.push_back( sFState_3e39);
		_function_3e3e.push_back( function_3e42);
		_conditionalGroup_3e47.push_back( conditionalGroup_3e4b);
	}
	return isUnique;
}

void GetStartTC_3e26::processInputPackets( const Packets_t& sFStates_3e27, const Packets_t& functions_3e2b, const Packets_t& conditionalGroups_3e2e)
{
	for( Packets_t::const_iterator itSFState_3e36= sFStates_3e27.begin(), itFunction_3e3f= functions_3e2b.begin(), itConditionalGroup_3e48= conditionalGroups_3e2e.begin(); itSFState_3e36!= sFStates_3e27.end(), itFunction_3e3f!= functions_3e2b.end(), itConditionalGroup_3e48!= conditionalGroups_3e2e.end(); ++itSFState_3e36, ++itFunction_3e3f, ++itConditionalGroup_3e48)
	{
		bool isUnique= isInputUnique( *itSFState_3e36, *itFunction_3e3f, *itConditionalGroup_3e48);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_3e36, *itFunction_3e3f, *itConditionalGroup_3e48);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetStartTC_3e26::patternMatcher( const Udm::Object& sFState_3e37, const Udm::Object& function_3e40, const Udm::Object& conditionalGroup_3e49)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_3e37.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_3e3c= CyberComposition::Simulink::SFState::Cast( sFState_3e37);
		if( false== Uml::IsDerivedFrom( function_3e40.type(), SFC::Function::meta))
			continue;
		SFC::Function function_3e45= SFC::Function::Cast( function_3e40);
		if( false== Uml::IsDerivedFrom( conditionalGroup_3e49.type(), SFC::ConditionalGroup::meta))
			continue;
		SFC::ConditionalGroup conditionalGroup_3e4e= SFC::ConditionalGroup::Cast( conditionalGroup_3e49);
		set< CyberComposition::Simulink::SFTransStart> sFTransStarts_3e50= sFState_3e3c.SFTransStart_kind_children();
		for( set< CyberComposition::Simulink::SFTransStart>::const_iterator itSFTransStart_3e51= sFTransStarts_3e50.begin(); itSFTransStart_3e51!= sFTransStarts_3e50.end(); ++itSFTransStart_3e51)
		{
			CyberComposition::Simulink::SFTransStart currSFTransStart_3e52= *itSFTransStart_3e51;
			Match currMatch;
			currMatch.sFState_3e54= sFState_3e3c;
			currMatch.function_3e55= function_3e45;
			currMatch.conditionalGroup_3e56= conditionalGroup_3e4e;
			currMatch.sFTransStart_3e57= currSFTransStart_3e52;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetStartTC_3e26::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_3e54, currMatch.sFTransStart_3e57, currMatch.function_3e55, currMatch.conditionalGroup_3e56);
	}
}

void GetStartTC_3e26::outputAppender( const CyberComposition::Simulink::SFState& sFState_3e58, const CyberComposition::Simulink::SFTransStart& sFTransStart_3e5a, const SFC::Function& function_3e5c, const SFC::ConditionalGroup& conditionalGroup_3e5e)
{
	_sFState_3e31->push_back( sFState_3e58);
	_sFTransStart_3e32->push_back( sFTransStart_3e5a);
	_function_3e33->push_back( function_3e5c);
	_conditionalGroup_3e34->push_back( conditionalGroup_3e5e);
}

void EnterTransConnectorRecurse2_3e60::operator()( const Packets_t& states_3e61, const Packets_t& tcs_3e63, const Packets_t& fcns_3e65, const Packets_t& cgs_3e67)
{
#ifdef PRINT_INFO
	printLog( "EnterTransConnectorRecurse2_3e60" );
#endif
	for( Packets_t::const_iterator itstate_3e6a= states_3e61.begin(), ittc_3e71= tcs_3e63.begin(), itfcn_3e78= fcns_3e65.begin(), itcg_3e7f= cgs_3e67.begin(); itstate_3e6a!= states_3e61.end(), ittc_3e71!= tcs_3e63.end(), itfcn_3e78!= fcns_3e65.end(), itcg_3e7f!= cgs_3e67.end(); ++itstate_3e6a, ++ittc_3e71, ++itfcn_3e78, ++itcg_3e7f)
	{
		bool isUnique= isInputUnique( *itstate_3e6a, *ittc_3e71, *itfcn_3e78, *itcg_3e7f);
		if( !isUnique)
			continue;
		Packets_t onestate_3e6e( 1, *itstate_3e6a);
		Packets_t onetc_3e75( 1, *ittc_3e71);
		Packets_t onefcn_3e7c( 1, *itfcn_3e78);
		Packets_t onecg_3e83( 1, *itcg_3e7f);
		executeOne( onestate_3e6e, onetc_3e75, onefcn_3e7c, onecg_3e83);
	}
}

void EnterTransConnectorRecurse2_3e60::executeOne( const Packets_t& states_3e61, const Packets_t& tcs_3e63, const Packets_t& fcns_3e65, const Packets_t& cgs_3e67)
{
	if( ( !states_3e61.empty())&& ( !tcs_3e63.empty())&& ( !fcns_3e65.empty())&& ( !cgs_3e67.empty()))
		callProcessedFilter_3f39( states_3e61, tcs_3e63, fcns_3e65, cgs_3e67);
}

bool EnterTransConnectorRecurse2_3e60::isInputUnique( const Udm::Object& state_3e6b, const Udm::Object& tc_3e72, const Udm::Object& fcn_3e79, const Udm::Object& cg_3e80)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_3e6d= _state_3e69.begin(), ittc_3e74= _tc_3e70.begin(), itfcn_3e7b= _fcn_3e77.begin(), itcg_3e82= _cg_3e7e.begin(); itstate_3e6d!= _state_3e69.end(), ittc_3e74!= _tc_3e70.end(), itfcn_3e7b!= _fcn_3e77.end(), itcg_3e82!= _cg_3e7e.end(); ++itstate_3e6d, ++ittc_3e74, ++itfcn_3e7b, ++itcg_3e82)
	{
		if( ( *itstate_3e6d== state_3e6b)&& ( *ittc_3e74== tc_3e72)&& ( *itfcn_3e7b== fcn_3e79)&& ( *itcg_3e82== cg_3e80))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_3e69.push_back( state_3e6b);
		_tc_3e70.push_back( tc_3e72);
		_fcn_3e77.push_back( fcn_3e79);
		_cg_3e7e.push_back( cg_3e80);
	}
	return isUnique;
}

void EnterTransConnectorRecurse2_3e60::callProcessedFilter_3f39( const Packets_t& states_368a, const Packets_t& tcs_368c, const Packets_t& fcns_368e, const Packets_t& cgs_3690)
{
	Packets_t states_3692;
	Packets_t tcs_3693;
	Packets_t fcns_3694;
	Packets_t cgs_3695;
	ProcessedFilter_3689 processedFilter_3689;
	processedFilter_3689( states_368a, tcs_368c, fcns_368e, cgs_3690, states_3692, tcs_3693, fcns_3694, cgs_3695);
	if( ( !states_3692.empty())&& ( !tcs_3693.empty())&& ( !fcns_3694.empty())&& ( !cgs_3695.empty()))
		callCreateTransitionCG_3f3e( states_3692, tcs_3693, fcns_3694, cgs_3695);
}

void EnterTransConnectorRecurse2_3e60::callCreateTransitionCG_3f3e( const Packets_t& sFStates_36fd, const Packets_t& sFTransConnectors_3700, const Packets_t& functions_3703, const Packets_t& tCVarCGs_3707)
{
	Packets_t sFStates_36ff;
	Packets_t sFTransConnectors_3702;
	Packets_t functions_3705;
	Packets_t transitionCGs_3706;
	CreateTransitionCG_36fc createTransitionCG_36fc;
	createTransitionCG_36fc( sFStates_36fd, sFTransConnectors_3700, functions_3703, tCVarCGs_3707, sFStates_36ff, sFTransConnectors_3702, functions_3705, transitionCGs_3706);
	if( ( !sFStates_36ff.empty())&& ( !sFTransConnectors_3702.empty())&& ( !functions_3705.empty())&& ( !transitionCGs_3706.empty()))
		callEnterTransitions_3f43( sFStates_36ff, sFTransConnectors_3702, functions_3705, transitionCGs_3706);
}

void EnterTransConnectorRecurse2_3e60::callEnterTransitions_3f43( const Packets_t& states_3e86, const Packets_t& tcs_3e88, const Packets_t& fcns_3e8a, const Packets_t& css_3e8c)
{
	Packets_t states_3e8e;
	Packets_t tcs_3e8f;
	Packets_t fcns_3e90;
	Packets_t css_3e91;
	EnterTransitions_3e85 enterTransitions_3e85;
	enterTransitions_3e85( states_3e86, tcs_3e88, fcns_3e8a, css_3e8c, states_3e8e, tcs_3e8f, fcns_3e90, css_3e91);
	if( ( !states_3e8e.empty())&& ( !tcs_3e8f.empty())&& ( !fcns_3e90.empty())&& ( !css_3e91.empty()))
		callNoDefaultTransition_3f48( states_3e8e, tcs_3e8f, fcns_3e90, css_3e91);
}

void EnterTransConnectorRecurse2_3e60::callNoDefaultTransition_3f48( const Packets_t& states_2e48, const Packets_t& tcs_2e4a, const Packets_t& fcns_2e4c, const Packets_t& css_2e4e)
{
	NoDefaultTransition_2e47 noDefaultTransition_2e47;
	noDefaultTransition_2e47( states_2e48, tcs_2e4a, fcns_2e4c, css_2e4e);
}

void EnterTransitions_3e85::operator()( const Packets_t& states_3e86, const Packets_t& tcs_3e88, const Packets_t& fcns_3e8a, const Packets_t& css_3e8c, Packets_t& states_3e8e, Packets_t& tcs_3e8f, Packets_t& fcns_3e90, Packets_t& css_3e91)
{
#ifdef PRINT_INFO
	printLog( "EnterTransitions_3e85" );
#endif
	_state_3e92= &states_3e8e;
	_tc_3e93= &tcs_3e8f;
	_fcn_3e94= &fcns_3e90;
	_cs_3e95= &css_3e91;
	if( ( !states_3e86.empty())&& ( !tcs_3e88.empty())&& ( !fcns_3e8a.empty())&& ( !css_3e8c.empty()))
		callGetAllTransitions_3f2f( states_3e86, tcs_3e88, fcns_3e8a, css_3e8c);
	_state_3e92->insert( _state_3e92->end(), states_3e86.begin(), states_3e86.end());
	_tc_3e93->insert( _tc_3e93->end(), tcs_3e88.begin(), tcs_3e88.end());
	_fcn_3e94->insert( _fcn_3e94->end(), fcns_3e8a.begin(), fcns_3e8a.end());
	_cs_3e95->insert( _cs_3e95->end(), css_3e8c.begin(), css_3e8c.end());
}

void EnterTransitions_3e85::callGetAllTransitions_3f2f( const Packets_t& states_3575, const Packets_t& tcs_3577, const Packets_t& fcns_3579, const Packets_t& css_357b)
{
	Packets_t states_357d;
	Packets_t transs_357e;
	Packets_t fcns_357f;
	Packets_t css_3580;
	GetAllTransitions_3574 getAllTransitions_3574;
	getAllTransitions_3574( states_3575, tcs_3577, fcns_3579, css_357b, states_357d, transs_357e, fcns_357f, css_3580);
	if( ( !states_357d.empty())&& ( !transs_357e.empty())&& ( !fcns_357f.empty())&& ( !css_3580.empty()))
		callEnterProcessTransitions_3f34( states_357d, transs_357e, fcns_357f, css_3580);
}

void EnterTransitions_3e85::callEnterProcessTransitions_3f34( const Packets_t& states_3e97, const Packets_t& transs_3e99, const Packets_t& fcns_3e9b, const Packets_t& css_3e9d)
{
	EnterProcessTransitions_3e96 enterProcessTransitions_3e96;
	enterProcessTransitions_3e96( states_3e97, transs_3e99, fcns_3e9b, css_3e9d);
}

void EnterProcessTransitions_3e96::operator()( const Packets_t& states_3e97, const Packets_t& transs_3e99, const Packets_t& fcns_3e9b, const Packets_t& css_3e9d)
{
#ifdef PRINT_INFO
	printLog( "EnterProcessTransitions_3e96" );
#endif
	if( ( !states_3e97.empty())&& ( !transs_3e99.empty())&& ( !fcns_3e9b.empty())&& ( !css_3e9d.empty()))
		callOrderTransitions_3efc( states_3e97, transs_3e99, fcns_3e9b, css_3e9d);
}

void EnterProcessTransitions_3e96::callOrderTransitions_3efc( const Packets_t& sFStates_3387, const Packets_t& sFTransitions_338a, const Packets_t& functions_338d, const Packets_t& compoundStatements_3390)
{
	Packets_t sFStates_3389;
	Packets_t sFTransitions_338c;
	Packets_t functions_338f;
	Packets_t compoundStatements_3392;
	OrderTransitions_3386 orderTransitions_3386;
	orderTransitions_3386( sFStates_3387, sFTransitions_338a, functions_338d, compoundStatements_3390, sFStates_3389, sFTransitions_338c, functions_338f, compoundStatements_3392);
	if( ( !sFStates_3389.empty())&& ( !sFTransitions_338c.empty())&& ( !functions_338f.empty())&& ( !compoundStatements_3392.empty()))
		callTransCond_3f01( sFStates_3389, sFTransitions_338c, functions_338f, compoundStatements_3392);
}

void EnterProcessTransitions_3e96::callTransCond_3f01( const Packets_t& sFStates_3079, const Packets_t& sFTransitions_307d, const Packets_t& functions_3080, const Packets_t& transitionCGs_3083)
{
	Packets_t sFStates_307b;
	Packets_t sFDstTransConnectors_307c;
	Packets_t sFTransitions_307f;
	Packets_t functions_3082;
	Packets_t conditionalBlocks_3085;
	TransCond_3078 transCond_3078;
	transCond_3078( sFStates_3079, sFTransitions_307d, functions_3080, transitionCGs_3083, sFStates_307b, sFDstTransConnectors_307c, sFTransitions_307f, functions_3082, conditionalBlocks_3085);
	if( ( !sFStates_307b.empty())&& ( !sFDstTransConnectors_307c.empty())&& ( !sFTransitions_307f.empty())&& ( !functions_3082.empty())&& ( !conditionalBlocks_3085.empty()))
		callTest_3f06( sFStates_307b, sFDstTransConnectors_307c, sFTransitions_307f, functions_3082, conditionalBlocks_3085);
}

void EnterProcessTransitions_3e96::callTest_3f06( const Packets_t& states_30c4, const Packets_t& dsts_30c6, const Packets_t& transs_30c8, const Packets_t& fcns_30ca, const Packets_t& cbs_30cc)
{
	Packets_t states_30ce;
	Packets_t dsts_30cf;
	Packets_t transs_30d0;
	Packets_t fcns_30d1;
	Packets_t cbs_30d2;
	Packets_t states_30d3;
	Packets_t dsts_30d4;
	Packets_t transs_30d5;
	Packets_t fcns_30d6;
	Packets_t cbs_30d7;
	Packets_t states_30d8;
	Packets_t dsts_30d9;
	Packets_t transs_30da;
	Packets_t fcns_30db;
	Packets_t cbs_30dc;
	Packets_t states_30dd;
	Packets_t dsts_30de;
	Packets_t transs_30df;
	Packets_t fcns_30e0;
	Packets_t cbs_30e1;
	Packets_t states_30e2;
	Packets_t dsts_30e3;
	Packets_t transs_30e4;
	Packets_t fcns_30e5;
	Packets_t cbs_30e6;
	Test_30c3 test_30c3;
	test_30c3( states_30c4, dsts_30c6, transs_30c8, fcns_30ca, cbs_30cc, states_30ce, dsts_30cf, transs_30d0, fcns_30d1, cbs_30d2, states_30d3, dsts_30d4, transs_30d5, fcns_30d6, cbs_30d7, states_30d8, dsts_30d9, transs_30da, fcns_30db, cbs_30dc, states_30dd, dsts_30de, transs_30df, fcns_30e0, cbs_30e1, states_30e2, dsts_30e3, transs_30e4, fcns_30e5, cbs_30e6);
	if( ( !states_30ce.empty())&& ( !dsts_30cf.empty())&& ( !transs_30d0.empty())&& ( !fcns_30d1.empty())&& ( !cbs_30d2.empty()))
		callEnterNextState_3f0c( states_30ce, dsts_30cf, transs_30d0, fcns_30d1, cbs_30d2);
	if( ( !states_30d8.empty())&& ( !dsts_30d9.empty())&& ( !transs_30da.empty())&& ( !fcns_30db.empty())&& ( !cbs_30dc.empty()))
		callNextJunction_3f12( states_30d8, dsts_30d9, transs_30da, fcns_30db, cbs_30dc);
	if( ( !states_30e2.empty())&& ( !dsts_30e3.empty())&& ( !transs_30e4.empty())&& ( !fcns_30e5.empty())&& ( !cbs_30e6.empty()))
		callDeadEndJunction_3f18( states_30e2, dsts_30e3, transs_30e4, fcns_30e5, cbs_30e6);
	if( ( !states_30dd.empty())&& ( !dsts_30de.empty())&& ( !transs_30df.empty())&& ( !fcns_30e0.empty())&& ( !cbs_30e1.empty()))
		callGetDstJuncFromRef_3f1e( states_30dd, dsts_30de, transs_30df, fcns_30e0, cbs_30e1);
	if( ( !states_30d3.empty())&& ( !dsts_30d4.empty())&& ( !transs_30d5.empty())&& ( !fcns_30d6.empty())&& ( !cbs_30d7.empty()))
		callGetDstStateFromRef_3f24( states_30d3, dsts_30d4, transs_30d5, fcns_30d6, cbs_30d7);
}

void EnterProcessTransitions_3e96::callEnterNextState_3f0c( const Packets_t& sFStates_3ea0, const Packets_t& sFDstStates_3ea2, const Packets_t& sFTransitions_3ea4, const Packets_t& functions_3ea6, const Packets_t& transitionCBs_3ea8)
{
	EnterNextState_3e9f enterNextState_3e9f;
	enterNextState_3e9f( sFStates_3ea0, sFDstStates_3ea2, sFTransitions_3ea4, functions_3ea6, transitionCBs_3ea8);
}

void EnterProcessTransitions_3e96::callNextJunction_3f12( const Packets_t& sFStates_3415, const Packets_t& sFJunctions_3418, const Packets_t& sFTransitions_341b, const Packets_t& functions_341d, const Packets_t& transitionCBs_3420)
{
	Packets_t sFStates_3417;
	Packets_t sFJunctions_341a;
	Packets_t functions_341f;
	Packets_t conditionalGroups_3422;
	NextJunction_3414 nextJunction_3414;
	nextJunction_3414( sFStates_3415, sFJunctions_3418, sFTransitions_341b, functions_341d, transitionCBs_3420, sFStates_3417, sFJunctions_341a, functions_341f, conditionalGroups_3422);
	if( ( !sFStates_3417.empty())&& ( !sFJunctions_341a.empty())&& ( !functions_341f.empty())&& ( !conditionalGroups_3422.empty()))
		callEnterTransConnectorRecurse_3f2a( sFStates_3417, sFJunctions_341a, functions_341f, conditionalGroups_3422);
}

void EnterProcessTransitions_3e96::callDeadEndJunction_3f18( const Packets_t& sFStates_33c9, const Packets_t& sFTransConnectors_33cb, const Packets_t& sFTransitions_33cd, const Packets_t& functions_33cf, const Packets_t& transitionCBs_33d1)
{
	DeadEndJunction_33c8 deadEndJunction_33c8;
	deadEndJunction_33c8( sFStates_33c9, sFTransConnectors_33cb, sFTransitions_33cd, functions_33cf, transitionCBs_33d1);
}

void EnterProcessTransitions_3e96::callGetDstJuncFromRef_3f1e( const Packets_t& sFStates_3024, const Packets_t& sFConnectorRefs_3027, const Packets_t& sFTransitions_302a, const Packets_t& functions_302d, const Packets_t& conditionalBlocks_3030)
{
	Packets_t sFStates_3026;
	Packets_t sFJunctions_3029;
	Packets_t sFTransitions_302c;
	Packets_t functions_302f;
	Packets_t conditionalBlocks_3032;
	GetDstJuncFromRef_3023 getDstJuncFromRef_3023;
	getDstJuncFromRef_3023( sFStates_3024, sFConnectorRefs_3027, sFTransitions_302a, functions_302d, conditionalBlocks_3030, sFStates_3026, sFJunctions_3029, sFTransitions_302c, functions_302f, conditionalBlocks_3032);
	if( ( !sFStates_3026.empty())&& ( !sFJunctions_3029.empty())&& ( !sFTransitions_302c.empty())&& ( !functions_302f.empty())&& ( !conditionalBlocks_3032.empty()))
		callNextJunction_3f12( sFStates_3026, sFJunctions_3029, sFTransitions_302c, functions_302f, conditionalBlocks_3032);
}

void EnterProcessTransitions_3e96::callGetDstStateFromRef_3f24( const Packets_t& sFStates_347d, const Packets_t& sFConnectorRefs_3481, const Packets_t& sFTransitions_3483, const Packets_t& functions_3486, const Packets_t& conditionalBlocks_3489)
{
	Packets_t sFStates_347f;
	Packets_t sFDstStates_3480;
	Packets_t sFTransitions_3485;
	Packets_t functions_3488;
	Packets_t conditionalBlocks_348b;
	GetDstStateFromRef_347c getDstStateFromRef_347c;
	getDstStateFromRef_347c( sFStates_347d, sFConnectorRefs_3481, sFTransitions_3483, functions_3486, conditionalBlocks_3489, sFStates_347f, sFDstStates_3480, sFTransitions_3485, functions_3488, conditionalBlocks_348b);
	if( ( !sFStates_347f.empty())&& ( !sFDstStates_3480.empty())&& ( !sFTransitions_3485.empty())&& ( !functions_3488.empty())&& ( !conditionalBlocks_348b.empty()))
		callEnterNextState_3f0c( sFStates_347f, sFDstStates_3480, sFTransitions_3485, functions_3488, conditionalBlocks_348b);
}

void EnterProcessTransitions_3e96::callEnterTransConnectorRecurse_3f2a( const Packets_t& states_3e61, const Packets_t& tcs_3e63, const Packets_t& fcns_3e65, const Packets_t& cgs_3e67)
{
	EnterTransConnectorRecurse2_3e60 enterTransConnectorRecurse2_3e60;
	enterTransConnectorRecurse2_3e60( states_3e61, tcs_3e63, fcns_3e65, cgs_3e67);
}

void EnterNextState_3e9f::operator()( const Packets_t& sFStates_3ea0, const Packets_t& sFDstStates_3ea2, const Packets_t& sFTransitions_3ea4, const Packets_t& functions_3ea6, const Packets_t& transitionCBs_3ea8)
{
#ifdef PRINT_INFO
	printLog( "EnterNextState_3e9f" );
#endif
	RTTGenerator::Instance()->generateRule(5484, "EnterNextState");
	processInputPackets( sFStates_3ea0, sFDstStates_3ea2, sFTransitions_3ea4, functions_3ea6, transitionCBs_3ea8);
}

bool EnterNextState_3e9f::isInputUnique( const Udm::Object& sFState_3eae, const Udm::Object& sFDstState_3eb7, const Udm::Object& sFTransition_3ec0, const Udm::Object& function_3ec9, const Udm::Object& transitionCB_3ed2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_3eb0= _sFState_3eaa.begin(), itSFDstState_3eb9= _sFDstState_3eb3.begin(), itSFTransition_3ec2= _sFTransition_3ebc.begin(), itFunction_3ecb= _function_3ec5.begin(), itTransitionCB_3ed4= _transitionCB_3ece.begin(); itSFState_3eb0!= _sFState_3eaa.end(), itSFDstState_3eb9!= _sFDstState_3eb3.end(), itSFTransition_3ec2!= _sFTransition_3ebc.end(), itFunction_3ecb!= _function_3ec5.end(), itTransitionCB_3ed4!= _transitionCB_3ece.end(); ++itSFState_3eb0, ++itSFDstState_3eb9, ++itSFTransition_3ec2, ++itFunction_3ecb, ++itTransitionCB_3ed4)
	{
		if( ( *itSFState_3eb0== sFState_3eae)&& ( *itSFDstState_3eb9== sFDstState_3eb7)&& ( *itSFTransition_3ec2== sFTransition_3ec0)&& ( *itFunction_3ecb== function_3ec9)&& ( *itTransitionCB_3ed4== transitionCB_3ed2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_3eaa.push_back( sFState_3eae);
		_sFDstState_3eb3.push_back( sFDstState_3eb7);
		_sFTransition_3ebc.push_back( sFTransition_3ec0);
		_function_3ec5.push_back( function_3ec9);
		_transitionCB_3ece.push_back( transitionCB_3ed2);
	}
	return isUnique;
}

bool EnterNextState_3e9f::isGuardTrue( SFC::Function& Enter, SFC::Arg& EnterArg0, SFC::Arg& EnterArg1, SFC::Function& Function, CyberComposition::Simulink::SFState& SFDstState, CyberComposition::Simulink::SFState& SFState, CyberComposition::Simulink::SFTransition& SFTransition, SFC::StateLabel& StateLabel, SFC::ConditionalBlock& TransitionCB)
{
	bool Gz_guard= false;
	return EnterArg0.argIndex() == 0 && EnterArg1.argIndex() == 1;;
	return Gz_guard;
}

void EnterNextState_3e9f::processInputPackets( const Packets_t& sFStates_3ea0, const Packets_t& sFDstStates_3ea2, const Packets_t& sFTransitions_3ea4, const Packets_t& functions_3ea6, const Packets_t& transitionCBs_3ea8)
{
	for( Packets_t::const_iterator itSFState_3eab= sFStates_3ea0.begin(), itSFDstState_3eb4= sFDstStates_3ea2.begin(), itSFTransition_3ebd= sFTransitions_3ea4.begin(), itFunction_3ec6= functions_3ea6.begin(), itTransitionCB_3ecf= transitionCBs_3ea8.begin(); itSFState_3eab!= sFStates_3ea0.end(), itSFDstState_3eb4!= sFDstStates_3ea2.end(), itSFTransition_3ebd!= sFTransitions_3ea4.end(), itFunction_3ec6!= functions_3ea6.end(), itTransitionCB_3ecf!= transitionCBs_3ea8.end(); ++itSFState_3eab, ++itSFDstState_3eb4, ++itSFTransition_3ebd, ++itFunction_3ec6, ++itTransitionCB_3ecf)
	{
		bool isUnique= isInputUnique( *itSFState_3eab, *itSFDstState_3eb4, *itSFTransition_3ebd, *itFunction_3ec6, *itTransitionCB_3ecf);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_3eab, *itSFDstState_3eb4, *itSFTransition_3ebd, *itFunction_3ec6, *itTransitionCB_3ecf);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool EnterNextState_3e9f::patternMatcher( const Udm::Object& sFState_3eac, const Udm::Object& sFDstState_3eb5, const Udm::Object& sFTransition_3ebe, const Udm::Object& function_3ec7, const Udm::Object& transitionCB_3ed0)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_3eac.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_3eb1= CyberComposition::Simulink::SFState::Cast( sFState_3eac);
		if( false== Uml::IsDerivedFrom( sFDstState_3eb5.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFDstState_3eba= CyberComposition::Simulink::SFState::Cast( sFDstState_3eb5);
		if( false== Uml::IsDerivedFrom( sFTransition_3ebe.type(), CyberComposition::Simulink::SFTransition::meta))
			continue;
		CyberComposition::Simulink::SFTransition sFTransition_3ec3= CyberComposition::Simulink::SFTransition::Cast( sFTransition_3ebe);
		if( false== Uml::IsDerivedFrom( function_3ec7.type(), SFC::Function::meta))
			continue;
		SFC::Function function_3ecc= SFC::Function::Cast( function_3ec7);
		if( false== Uml::IsDerivedFrom( transitionCB_3ed0.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock transitionCB_3ed5= SFC::ConditionalBlock::Cast( transitionCB_3ed0);
		set< SFC::StateLabel> stateLabels_3ed7= sFState_3eb1.src();
		for( set< SFC::StateLabel>::const_iterator itStateLabels_3ed8= stateLabels_3ed7.begin(); itStateLabels_3ed8!= stateLabels_3ed7.end(); ++itStateLabels_3ed8)
		{
			SFC::StateLabel currStateLabel_3ed9= *itStateLabels_3ed8;
			set< SFC::Function> enters_3eda= sFDstState_3eba.enter();
			for( set< SFC::Function>::const_iterator itEnters_3edb= enters_3eda.begin(); itEnters_3edb!= enters_3eda.end(); ++itEnters_3edb)
			{
				SFC::Function currEnter_3edc= *itEnters_3edb;
				set< SFC::Arg> enterArg0s_3edd= currEnter_3edc.Arg_kind_children();
				for( set< SFC::Arg>::const_iterator itEnterArg0_3ede= enterArg0s_3edd.begin(); itEnterArg0_3ede!= enterArg0s_3edd.end(); ++itEnterArg0_3ede)
				{
					SFC::Arg currEnterArg0_3edf= *itEnterArg0_3ede;
					set< SFC::Arg> enterArg1s_3ee0= currEnter_3edc.Arg_kind_children();
					for( set< SFC::Arg>::const_iterator itEnterArg1_3ee1= enterArg1s_3ee0.begin(); itEnterArg1_3ee1!= enterArg1s_3ee0.end(); ++itEnterArg1_3ee1)
					{
						SFC::Arg currEnterArg1_3ee2= *itEnterArg1_3ee1;
						Match currMatch;
						currMatch.sFState_3ee4= sFState_3eb1;
						currMatch.sFDstState_3ee5= sFDstState_3eba;
						currMatch.sFTransition_3ee6= sFTransition_3ec3;
						currMatch.function_3ee7= function_3ecc;
						currMatch.transitionCB_3ee8= transitionCB_3ed5;
						currMatch.stateLabel_3ee9= currStateLabel_3ed9;
						currMatch.enterArg0_3eea= currEnterArg0_3edf;
						currMatch.enter_3eeb= currEnter_3edc;
						currMatch.enterArg1_3eec= currEnterArg1_3ee2;
						bool Gz_guard= isGuardTrue( currMatch.enter_3eeb, currMatch.enterArg0_3eea, currMatch.enterArg1_3eec, currMatch.function_3ee7, currMatch.sFDstState_3ee5, currMatch.sFState_3ee4, currMatch.sFTransition_3ee6, currMatch.stateLabel_3ee9, currMatch.transitionCB_3ee8);
						if( true== Gz_guard)
							_matches.push_back( currMatch);
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void EnterNextState_3e9f::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Return newReturn_3ef6= SFC::Return::Create( currMatch.transitionCB_3ee8, SFC::ConditionalBlock::meta_stmnt);
		SFC::FunctionCall newEnterFunctionCall_3ef7= SFC::FunctionCall::Create( currMatch.transitionCB_3ee8, SFC::ConditionalBlock::meta_stmnt);
		SFC::ArgVal newEnterArgVal0_3ef8= SFC::ArgVal::Create( newEnterFunctionCall_3ef7);
		SFC::ArgVal newEnterArgVal1_3ef9= SFC::ArgVal::Create( newEnterFunctionCall_3ef7);
		SFC::ArgDeclRef newEnterArgDeclRef_3efa= SFC::ArgDeclRef::Create( newEnterArgVal1_3ef9, SFC::ArgVal::meta_argexpr);
		SFC::Int newTwo_3efb= SFC::Int::Create( newEnterArgVal0_3ef8, SFC::ArgVal::meta_argexpr);
		SFC::Function& Enter= currMatch.enter_3eeb;
		SFC::Arg& EnterArg0= currMatch.enterArg0_3eea;
		SFC::Arg& EnterArg1= currMatch.enterArg1_3eec;
		SFC::ArgDeclRef& EnterArgDeclRef= newEnterArgDeclRef_3efa;
		SFC::ArgVal& EnterArgVal0= newEnterArgVal0_3ef8;
		SFC::ArgVal& EnterArgVal1= newEnterArgVal1_3ef9;
		SFC::FunctionCall& EnterFunctionCall= newEnterFunctionCall_3ef7;
		SFC::Function& Function= currMatch.function_3ee7;
		SFC::Return& Return= newReturn_3ef6;
		CyberComposition::Simulink::SFState& SFDstState= currMatch.sFDstState_3ee5;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_3ee4;
		CyberComposition::Simulink::SFTransition& SFTransition= currMatch.sFTransition_3ee6;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_3ee9;
		SFC::ConditionalBlock& TransitionCB= currMatch.transitionCB_3ee8;
		SFC::Int& Two= newTwo_3efb;
		{
EnterFunctionCall.RefId() = Return.RefId() = TransitionCB.RefId();
};
		{
EnterArgVal1.argIndex() = 1;
};
		{
SFManager::mstat2SFC( TransitionCB, SFTransition.Action() );

__int64 statementCount = TransitionCB.statementCount();
EnterFunctionCall.statementIndex() = statementCount++;
Return.statementIndex() = statementCount++;
TransitionCB.statementCount() = statementCount;
};
		{
EnterArgVal0.argIndex() = 0;
};
		{
Two.val() = 2;
};
		newEnterArgDeclRef_3efa.argdecl()= currMatch.stateLabel_3ee9;
		newEnterArgVal1_3ef9.arg()+= currMatch.enterArg1_3eec;
		newEnterArgVal0_3ef8.arg()+= currMatch.enterArg0_3eea;
		newEnterFunctionCall_3ef7.callee()= currMatch.enter_3eeb;
	}
}

void InitTCVarLoop_3f4d::operator()( const Packets_t& sFStates_3f4e, const Packets_t& functions_3f51, const Packets_t& compoundStatements_3f54, Packets_t& sFStates_3f50, Packets_t& functions_3f53, Packets_t& conditionalGroups_3f56)
{
#ifdef PRINT_INFO
	printLog( "InitTCVarLoop_3f4d" );
#endif
	RTTGenerator::Instance()->generateRule(4843, "InitTCVarLoop");
	_sFState_3f57= &sFStates_3f50;
	_function_3f58= &functions_3f53;
	_conditionalGroup_3f59= &conditionalGroups_3f56;
	processInputPackets( sFStates_3f4e, functions_3f51, compoundStatements_3f54);
}

bool InitTCVarLoop_3f4d::isInputUnique( const Udm::Object& sFState_3f5e, const Udm::Object& function_3f67, const Udm::Object& compoundStatement_3f70)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_3f60= _sFState_3f5a.begin(), itFunction_3f69= _function_3f63.begin(), itCompoundStatement_3f72= _compoundStatement_3f6c.begin(); itSFState_3f60!= _sFState_3f5a.end(), itFunction_3f69!= _function_3f63.end(), itCompoundStatement_3f72!= _compoundStatement_3f6c.end(); ++itSFState_3f60, ++itFunction_3f69, ++itCompoundStatement_3f72)
	{
		if( ( *itSFState_3f60== sFState_3f5e)&& ( *itFunction_3f69== function_3f67)&& ( *itCompoundStatement_3f72== compoundStatement_3f70))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_3f5a.push_back( sFState_3f5e);
		_function_3f63.push_back( function_3f67);
		_compoundStatement_3f6c.push_back( compoundStatement_3f70);
	}
	return isUnique;
}

bool InitTCVarLoop_3f4d::isGuardTrue( SFC::CompoundStatement& CompoundStatement, SFC::Function& Function, CyberComposition::Simulink::SFState& SFState, SFC::LocalVar& TCVar)
{
	bool Gz_guard= false;
	return static_cast< std::string >( TCVar.name() ) == "_TCVar_";;
	return Gz_guard;
}

void InitTCVarLoop_3f4d::processInputPackets( const Packets_t& sFStates_3f4e, const Packets_t& functions_3f51, const Packets_t& compoundStatements_3f54)
{
	for( Packets_t::const_iterator itSFState_3f5b= sFStates_3f4e.begin(), itFunction_3f64= functions_3f51.begin(), itCompoundStatement_3f6d= compoundStatements_3f54.begin(); itSFState_3f5b!= sFStates_3f4e.end(), itFunction_3f64!= functions_3f51.end(), itCompoundStatement_3f6d!= compoundStatements_3f54.end(); ++itSFState_3f5b, ++itFunction_3f64, ++itCompoundStatement_3f6d)
	{
		bool isUnique= isInputUnique( *itSFState_3f5b, *itFunction_3f64, *itCompoundStatement_3f6d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_3f5b, *itFunction_3f64, *itCompoundStatement_3f6d);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InitTCVarLoop_3f4d::patternMatcher( const Udm::Object& sFState_3f5c, const Udm::Object& function_3f65, const Udm::Object& compoundStatement_3f6e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_3f5c.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_3f61= CyberComposition::Simulink::SFState::Cast( sFState_3f5c);
		if( false== Uml::IsDerivedFrom( function_3f65.type(), SFC::Function::meta))
			continue;
		SFC::Function function_3f6a= SFC::Function::Cast( function_3f65);
		if( false== Uml::IsDerivedFrom( compoundStatement_3f6e.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_3f73= SFC::CompoundStatement::Cast( compoundStatement_3f6e);
		set< SFC::LocalVar> tCVars_3f75= function_3f6a.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itTCVar_3f76= tCVars_3f75.begin(); itTCVar_3f76!= tCVars_3f75.end(); ++itTCVar_3f76)
		{
			SFC::LocalVar currTCVar_3f77= *itTCVar_3f76;
			Match currMatch;
			currMatch.sFState_3f79= sFState_3f61;
			currMatch.function_3f7a= function_3f6a;
			currMatch.compoundStatement_3f7b= compoundStatement_3f73;
			currMatch.tCVar_3f7c= currTCVar_3f77;
			bool Gz_guard= isGuardTrue( currMatch.compoundStatement_3f7b, currMatch.function_3f7a, currMatch.sFState_3f79, currMatch.tCVar_3f7c);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void InitTCVarLoop_3f4d::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newInitTCVar_3f81= SFC::UserCode::Create( currMatch.compoundStatement_3f7b, SFC::CompoundStatement::meta_stmnt);
		SFC::BinaryExprs newAssignTCVar_3f82= SFC::BinaryExprs::Create( newInitTCVar_3f81, SFC::UserCode::meta_codeexpr);
		SFC::IterativeBlock newIterativeBlock_3f83= SFC::IterativeBlock::Create( currMatch.compoundStatement_3f7b, SFC::CompoundStatement::meta_stmnt);
		SFC::UserCode newUserCode_3f84= SFC::UserCode::Create( newIterativeBlock_3f83, SFC::IterativeBlock::meta_cond);
		SFC::BinaryExprs newNotEqualTo_3f85= SFC::BinaryExprs::Create( newUserCode_3f84, SFC::UserCode::meta_codeexpr);
		SFC::Int newNegOne_3f86= SFC::Int::Create( newNotEqualTo_3f85, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newZero_3f87= SFC::Int::Create( newAssignTCVar_3f82, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newAssignTCArgDeclRef_3f88= SFC::ArgDeclRef::Create( newAssignTCVar_3f82, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newEqualsTCArgDeclRef_3f89= SFC::ArgDeclRef::Create( newNotEqualTo_3f85, SFC::BinaryExprs::meta_leftexpr);
		SFC::ConditionalGroup newConditionalGroup_3f8a= SFC::ConditionalGroup::Create( newIterativeBlock_3f83, SFC::IterativeBlock::meta_stmnt);
		SFC::ArgDeclRef& AssignTCArgDeclRef= newAssignTCArgDeclRef_3f88;
		SFC::BinaryExprs& AssignTCVar= newAssignTCVar_3f82;
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_3f7b;
		SFC::ConditionalGroup& ConditionalGroup= newConditionalGroup_3f8a;
		SFC::ArgDeclRef& EqualsTCArgDeclRef= newEqualsTCArgDeclRef_3f89;
		SFC::Function& Function= currMatch.function_3f7a;
		SFC::UserCode& InitTCVar= newInitTCVar_3f81;
		SFC::IterativeBlock& IterativeBlock= newIterativeBlock_3f83;
		SFC::Int& NegOne= newNegOne_3f86;
		SFC::BinaryExprs& NotEqualTo= newNotEqualTo_3f85;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_3f79;
		SFC::LocalVar& TCVar= currMatch.tCVar_3f7c;
		SFC::UserCode& UserCode= newUserCode_3f84;
		SFC::Int& Zero= newZero_3f87;
		{
InitTCVar.RefId() = IterativeBlock.RefId() = ConditionalGroup.RefId() = UserCode.RefId() = CompoundStatement.RefId();
};
		{
NegOne.val() = -1;
};
		{
Zero.val() = 0;
};
		{
__int64 statementCount = IterativeBlock.statementCount();
ConditionalGroup.statementIndex() = statementCount++;
IterativeBlock.statementCount() = statementCount;
};
		{
AssignTCVar.op() = "=";
};
		{
__int64 statementCount = CompoundStatement.statementCount();
InitTCVar.statementIndex() = statementCount++;
IterativeBlock.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		{
NotEqualTo.op() = "!=";
};
		newAssignTCArgDeclRef_3f88.argdecl()= currMatch.tCVar_3f7c;
		newEqualsTCArgDeclRef_3f89.argdecl()= currMatch.tCVar_3f7c;
		outputAppender( currMatch.sFState_3f79, currMatch.function_3f7a, newConditionalGroup_3f8a);
	}
}

void InitTCVarLoop_3f4d::outputAppender( const CyberComposition::Simulink::SFState& sFState_3f8b, const SFC::Function& function_3f8d, const SFC::ConditionalGroup& conditionalGroup_3f8f)
{
	_sFState_3f57->push_back( sFState_3f8b);
	_function_3f58->push_back( function_3f8d);
	_conditionalGroup_3f59->push_back( conditionalGroup_3f8f);
}

void TransStartMap_3f9e::operator()( const Packets_t& states_3f9f, const Packets_t& css_3fa1, Packets_t& states_3fa3, Packets_t& css_3fa4)
{
#ifdef PRINT_INFO
	printLog( "TransStartMap_3f9e" );
#endif
	_state_3fa5= &states_3fa3;
	_cs_3fa6= &css_3fa4;
	if( ( !states_3f9f.empty()))
		callInitTransConnectorMap_41b3( states_3f9f);
	_state_3fa5->insert( _state_3fa5->end(), states_3f9f.begin(), states_3f9f.end());
	_cs_3fa6->insert( _cs_3fa6->end(), css_3fa1.begin(), css_3fa1.end());
}

void TransStartMap_3f9e::callInitTransConnectorMap_41b3( const Packets_t& sFStates_3fa8)
{
	Packets_t sFStates_3faa;
	Packets_t sFTransStarts_3fab;
	InitTransConnectorMap_3fa7 initTransConnectorMap_3fa7;
	initTransConnectorMap_3fa7( sFStates_3fa8, sFStates_3faa, sFTransStarts_3fab);
	if( ( !sFStates_3faa.empty())&& ( !sFTransStarts_3fab.empty()))
		callTransConnectorMapRecurse_41b5( sFStates_3faa, sFTransStarts_3fab);
}

void TransStartMap_3f9e::callTransConnectorMapRecurse_41b5( const Packets_t& states_3fc2, const Packets_t& tcs_3fc4)
{
	TransConnectorMapRecurse2_3fc1 transConnectorMapRecurse2_3fc1;
	transConnectorMapRecurse2_3fc1( states_3fc2, tcs_3fc4);
}

void InitTransConnectorMap_3fa7::operator()( const Packets_t& sFStates_3fa8, Packets_t& sFStates_3faa, Packets_t& sFTransStarts_3fab)
{
#ifdef PRINT_INFO
	printLog( "InitTransConnectorMap_3fa7" );
#endif
	RTTGenerator::Instance()->generateRule(4726, "InitTransConnectorMap");
	_sFState_3fac= &sFStates_3faa;
	_sFTransStart_3fad= &sFTransStarts_3fab;
	processInputPackets( sFStates_3fa8);
}

bool InitTransConnectorMap_3fa7::isInputUnique( const Udm::Object& sFState_3fb2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_3fb4= _sFState_3fae.begin(); itSFState_3fb4!= _sFState_3fae.end(); ++itSFState_3fb4)
	{
		if( ( *itSFState_3fb4== sFState_3fb2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_sFState_3fae.push_back( sFState_3fb2);
	return isUnique;
}

void InitTransConnectorMap_3fa7::processInputPackets( const Packets_t& sFStates_3fa8)
{
	for( Packets_t::const_iterator itSFState_3faf= sFStates_3fa8.begin(); itSFState_3faf!= sFStates_3fa8.end(); ++itSFState_3faf)
	{
		bool isUnique= isInputUnique( *itSFState_3faf);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_3faf);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InitTransConnectorMap_3fa7::patternMatcher( const Udm::Object& sFState_3fb0)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_3fb0.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_3fb5= CyberComposition::Simulink::SFState::Cast( sFState_3fb0);
		set< CyberComposition::Simulink::SFTransStart> sFTransStarts_3fb7= sFState_3fb5.SFTransStart_kind_children();
		for( set< CyberComposition::Simulink::SFTransStart>::const_iterator itSFTransStart_3fb8= sFTransStarts_3fb7.begin(); itSFTransStart_3fb8!= sFTransStarts_3fb7.end(); ++itSFTransStart_3fb8)
		{
			CyberComposition::Simulink::SFTransStart currSFTransStart_3fb9= *itSFTransStart_3fb8;
			Match currMatch;
			currMatch.sFState_3fbb= sFState_3fb5;
			currMatch.sFTransStart_3fbc= currSFTransStart_3fb9;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void InitTransConnectorMap_3fa7::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_3fbb;
		CyberComposition::Simulink::SFTransStart& SFTransStart= currMatch.sFTransStart_3fbc;
		{
SFManager::SFStateTransConnectorMap::get_singleton().clearState( SFState );
};
		outputAppender( currMatch.sFState_3fbb, currMatch.sFTransStart_3fbc);
	}
}

void InitTransConnectorMap_3fa7::outputAppender( const CyberComposition::Simulink::SFState& sFState_3fbd, const CyberComposition::Simulink::SFTransStart& sFTransStart_3fbf)
{
	_sFState_3fac->push_back( sFState_3fbd);
	_sFTransStart_3fad->push_back( sFTransStart_3fbf);
}

void TransConnectorMapRecurse2_3fc1::operator()( const Packets_t& states_3fc2, const Packets_t& tcs_3fc4)
{
#ifdef PRINT_INFO
	printLog( "TransConnectorMapRecurse2_3fc1" );
#endif
	for( Packets_t::const_iterator itstate_3fc7= states_3fc2.begin(), ittc_3fce= tcs_3fc4.begin(); itstate_3fc7!= states_3fc2.end(), ittc_3fce!= tcs_3fc4.end(); ++itstate_3fc7, ++ittc_3fce)
	{
		bool isUnique= isInputUnique( *itstate_3fc7, *ittc_3fce);
		if( !isUnique)
			continue;
		Packets_t onestate_3fcb( 1, *itstate_3fc7);
		Packets_t onetc_3fd2( 1, *ittc_3fce);
		executeOne( onestate_3fcb, onetc_3fd2);
	}
}

void TransConnectorMapRecurse2_3fc1::executeOne( const Packets_t& states_3fc2, const Packets_t& tcs_3fc4)
{
	if( ( !states_3fc2.empty())&& ( !tcs_3fc4.empty()))
		callProcessedFilter_41a7( states_3fc2, tcs_3fc4);
}

bool TransConnectorMapRecurse2_3fc1::isInputUnique( const Udm::Object& state_3fc8, const Udm::Object& tc_3fcf)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_3fca= _state_3fc6.begin(), ittc_3fd1= _tc_3fcd.begin(); itstate_3fca!= _state_3fc6.end(), ittc_3fd1!= _tc_3fcd.end(); ++itstate_3fca, ++ittc_3fd1)
	{
		if( ( *itstate_3fca== state_3fc8)&& ( *ittc_3fd1== tc_3fcf))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_3fc6.push_back( state_3fc8);
		_tc_3fcd.push_back( tc_3fcf);
	}
	return isUnique;
}

void TransConnectorMapRecurse2_3fc1::callProcessedFilter_41a7( const Packets_t& states_414f, const Packets_t& tcs_4151)
{
	Packets_t states_4153;
	Packets_t tcs_4154;
	ProcessedFilter_414e processedFilter_414e;
	processedFilter_414e( states_414f, tcs_4151, states_4153, tcs_4154);
	if( ( !states_4153.empty())&& ( !tcs_4154.empty()))
		callAddTransConnector_41aa( states_4153, tcs_4154);
}

void TransConnectorMapRecurse2_3fc1::callAddTransConnector_41aa( const Packets_t& sFStates_418a, const Packets_t& sFTransConnectors_418d)
{
	Packets_t sFStates_418c;
	Packets_t sFTransConnectors_418f;
	AddTransConnector_4189 addTransConnector_4189;
	addTransConnector_4189( sFStates_418a, sFTransConnectors_418d, sFStates_418c, sFTransConnectors_418f);
	if( ( !sFStates_418c.empty())&& ( !sFTransConnectors_418f.empty()))
		callGetAllTransitions_41ad( sFStates_418c, sFTransConnectors_418f);
}

void TransConnectorMapRecurse2_3fc1::callGetAllTransitions_41ad( const Packets_t& states_3fd5, const Packets_t& tcs_3fd7)
{
	Packets_t states_3fd9;
	Packets_t transs_3fda;
	GetAllTransitions_3fd4 getAllTransitions_3fd4;
	getAllTransitions_3fd4( states_3fd5, tcs_3fd7, states_3fd9, transs_3fda);
	if( ( !states_3fd9.empty())&& ( !transs_3fda.empty()))
		callProcessTransitionsMap_41b0( states_3fd9, transs_3fda);
}

void TransConnectorMapRecurse2_3fc1::callProcessTransitionsMap_41b0( const Packets_t& states_4070, const Packets_t& transs_4072)
{
	ProcessTransitionsMap_406f processTransitionsMap_406f;
	processTransitionsMap_406f( states_4070, transs_4072);
}

void GetAllTransitions_3fd4::operator()( const Packets_t& states_3fd5, const Packets_t& tcs_3fd7, Packets_t& states_3fd9, Packets_t& transs_3fda)
{
#ifdef PRINT_INFO
	printLog( "GetAllTransitions_3fd4" );
#endif
	_state_3fdb= &states_3fd9;
	_trans_3fdc= &transs_3fda;
	if( ( !states_3fd5.empty())&& ( !tcs_3fd7.empty()))
		callGetTransitionsFromJunctionRefs_4066( states_3fd5, tcs_3fd7);
	if( ( !states_3fd5.empty())&& ( !tcs_3fd7.empty()))
		callGetDirectTransitions_4069( states_3fd5, tcs_3fd7);
	if( ( !states_3fd5.empty())&& ( !tcs_3fd7.empty()))
		callGetTransitionsFromStateRefs_406c( states_3fd5, tcs_3fd7);
}

void GetAllTransitions_3fd4::callGetTransitionsFromJunctionRefs_4066( const Packets_t& sFStates_403b, const Packets_t& sFJunctions_403f)
{
	Packets_t sFStates_403d;
	Packets_t sFTransitions_403e;
	GetTransitionsFromJunctionRefs_403a getTransitionsFromJunctionRefs_403a;
	getTransitionsFromJunctionRefs_403a( sFStates_403b, sFJunctions_403f, sFStates_403d, sFTransitions_403e);
	_state_3fdb->insert( _state_3fdb->end(), sFStates_403d.begin(), sFStates_403d.end());
	_trans_3fdc->insert( _trans_3fdc->end(), sFTransitions_403e.begin(), sFTransitions_403e.end());
}

void GetAllTransitions_3fd4::callGetDirectTransitions_4069( const Packets_t& sFStates_4013, const Packets_t& sFSrcTransConnectors_4016)
{
	Packets_t sFStates_4015;
	Packets_t sFTransitions_4018;
	GetDirectTransitions_4012 getDirectTransitions_4012;
	getDirectTransitions_4012( sFStates_4013, sFSrcTransConnectors_4016, sFStates_4015, sFTransitions_4018);
	_state_3fdb->insert( _state_3fdb->end(), sFStates_4015.begin(), sFStates_4015.end());
	_trans_3fdc->insert( _trans_3fdc->end(), sFTransitions_4018.begin(), sFTransitions_4018.end());
}

void GetAllTransitions_3fd4::callGetTransitionsFromStateRefs_406c( const Packets_t& sFStates_3fde, const Packets_t& sFTCStates_3fe2)
{
	Packets_t sFStates_3fe0;
	Packets_t sFTransitions_3fe1;
	GetTransitionsFromStateRefs_3fdd getTransitionsFromStateRefs_3fdd;
	getTransitionsFromStateRefs_3fdd( sFStates_3fde, sFTCStates_3fe2, sFStates_3fe0, sFTransitions_3fe1);
	_state_3fdb->insert( _state_3fdb->end(), sFStates_3fe0.begin(), sFStates_3fe0.end());
	_trans_3fdc->insert( _trans_3fdc->end(), sFTransitions_3fe1.begin(), sFTransitions_3fe1.end());
}

void GetTransitionsFromStateRefs_3fdd::operator()( const Packets_t& sFStates_3fde, const Packets_t& sFTCStates_3fe2, Packets_t& sFStates_3fe0, Packets_t& sFTransitions_3fe1)
{
#ifdef PRINT_INFO
	printLog( "GetTransitionsFromStateRefs_3fdd" );
#endif
	RTTGenerator::Instance()->generateRule(5527, "GetTransitionsFromStateRefs");
	_sFState_3fe4= &sFStates_3fe0;
	_sFTransition_3fe5= &sFTransitions_3fe1;
	processInputPackets( sFStates_3fde, sFTCStates_3fe2);
}

bool GetTransitionsFromStateRefs_3fdd::isInputUnique( const Udm::Object& sFState_3fea, const Udm::Object& sFTCState_3ff3)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_3fec= _sFState_3fe6.begin(), itSFTCState_3ff5= _sFTCState_3fef.begin(); itSFState_3fec!= _sFState_3fe6.end(), itSFTCState_3ff5!= _sFTCState_3fef.end(); ++itSFState_3fec, ++itSFTCState_3ff5)
	{
		if( ( *itSFState_3fec== sFState_3fea)&& ( *itSFTCState_3ff5== sFTCState_3ff3))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_3fe6.push_back( sFState_3fea);
		_sFTCState_3fef.push_back( sFTCState_3ff3);
	}
	return isUnique;
}

bool GetTransitionsFromStateRefs_3fdd::isGuardTrue( CyberComposition::Simulink::SFConnectorRef& SFConnectorRef, CyberComposition::Simulink::SFTransConnector& SFDstTransConnector, CyberComposition::Simulink::SFState& SFRefParentState, CyberComposition::Simulink::SFState& SFState, CyberComposition::Simulink::SFState& SFTCState, CyberComposition::Simulink::SFTransition& SFTransition)
{
	bool Gz_guard= false;
	return SFState != SFRefParentState;;
	return Gz_guard;
}

void GetTransitionsFromStateRefs_3fdd::processInputPackets( const Packets_t& sFStates_3fde, const Packets_t& sFTCStates_3fe2)
{
	for( Packets_t::const_iterator itSFState_3fe7= sFStates_3fde.begin(), itSFTCState_3ff0= sFTCStates_3fe2.begin(); itSFState_3fe7!= sFStates_3fde.end(), itSFTCState_3ff0!= sFTCStates_3fe2.end(); ++itSFState_3fe7, ++itSFTCState_3ff0)
	{
		bool isUnique= isInputUnique( *itSFState_3fe7, *itSFTCState_3ff0);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_3fe7, *itSFTCState_3ff0);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetTransitionsFromStateRefs_3fdd::patternMatcher( const Udm::Object& sFState_3fe8, const Udm::Object& sFTCState_3ff1)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_3fe8.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_3fed= CyberComposition::Simulink::SFState::Cast( sFState_3fe8);
		if( false== Uml::IsDerivedFrom( sFTCState_3ff1.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFTCState_3ff6= CyberComposition::Simulink::SFState::Cast( sFTCState_3ff1);
		set< CyberComposition::Simulink::SFConnectorRef> sFConnectorRefs_3ff8= sFState_3fed.referedbyConnectorRef();
		for( set< CyberComposition::Simulink::SFConnectorRef>::const_iterator itSFConnectorRefs_3ff9= sFConnectorRefs_3ff8.begin(); itSFConnectorRefs_3ff9!= sFConnectorRefs_3ff8.end(); ++itSFConnectorRefs_3ff9)
		{
			CyberComposition::Simulink::SFConnectorRef currSFConnectorRef_3ffa= *itSFConnectorRefs_3ff9;
			Udm::Object sFConnectorRefParent_3ffb= currSFConnectorRef_3ffa.container();
			if( false== Uml::IsDerivedFrom( sFConnectorRefParent_3ffb.type(), CyberComposition::Simulink::SFState::meta))
				continue;
			CyberComposition::Simulink::SFState sFRefParentStateSFConnectorRef_3ffc= CyberComposition::Simulink::SFState::Cast( sFConnectorRefParent_3ffb);
			set< CyberComposition::Simulink::SFTransition> sFTransitions_3ffd= currSFConnectorRef_3ffa.dstTransition();
			for( set< CyberComposition::Simulink::SFTransition>::const_iterator itSFTransitions_3ffe= sFTransitions_3ffd.begin(); itSFTransitions_3ffe!= sFTransitions_3ffd.end(); ++itSFTransitions_3ffe)
			{
				CyberComposition::Simulink::SFTransition currSFTransition_3fff= *itSFTransitions_3ffe;
				CyberComposition::Simulink::SFTransConnector sFDstTransConnector_4000= currSFTransition_3fff.dstTransition_end();
				Match currMatch;
				currMatch.sFState_4002= sFState_3fed;
				currMatch.sFTCState_4003= sFTCState_3ff6;
				currMatch.sFRefParentState_4004= sFRefParentStateSFConnectorRef_3ffc;
				currMatch.sFTransition_4005= currSFTransition_3fff;
				currMatch.sFConnectorRef_4006= currSFConnectorRef_3ffa;
				currMatch.sFDstTransConnector_4007= sFDstTransConnector_4000;
				bool Gz_guard= isGuardTrue( currMatch.sFConnectorRef_4006, currMatch.sFDstTransConnector_4007, currMatch.sFRefParentState_4004, currMatch.sFState_4002, currMatch.sFTCState_4003, currMatch.sFTransition_4005);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetTransitionsFromStateRefs_3fdd::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4002, currMatch.sFTransition_4005);
	}
}

void GetTransitionsFromStateRefs_3fdd::outputAppender( const CyberComposition::Simulink::SFState& sFState_400e, const CyberComposition::Simulink::SFTransition& sFTransition_4010)
{
	_sFState_3fe4->push_back( sFState_400e);
	_sFTransition_3fe5->push_back( sFTransition_4010);
}

void GetDirectTransitions_4012::operator()( const Packets_t& sFStates_4013, const Packets_t& sFSrcTransConnectors_4016, Packets_t& sFStates_4015, Packets_t& sFTransitions_4018)
{
#ifdef PRINT_INFO
	printLog( "GetDirectTransitions_4012" );
#endif
	RTTGenerator::Instance()->generateRule(5538, "GetDirectTransitions");
	_sFState_4019= &sFStates_4015;
	_sFTransition_401a= &sFTransitions_4018;
	processInputPackets( sFStates_4013, sFSrcTransConnectors_4016);
}

bool GetDirectTransitions_4012::isInputUnique( const Udm::Object& sFState_401f, const Udm::Object& sFSrcTransConnector_4028)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4021= _sFState_401b.begin(), itSFSrcTransConnector_402a= _sFSrcTransConnector_4024.begin(); itSFState_4021!= _sFState_401b.end(), itSFSrcTransConnector_402a!= _sFSrcTransConnector_4024.end(); ++itSFState_4021, ++itSFSrcTransConnector_402a)
	{
		if( ( *itSFState_4021== sFState_401f)&& ( *itSFSrcTransConnector_402a== sFSrcTransConnector_4028))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_401b.push_back( sFState_401f);
		_sFSrcTransConnector_4024.push_back( sFSrcTransConnector_4028);
	}
	return isUnique;
}

void GetDirectTransitions_4012::processInputPackets( const Packets_t& sFStates_4013, const Packets_t& sFSrcTransConnectors_4016)
{
	for( Packets_t::const_iterator itSFState_401c= sFStates_4013.begin(), itSFSrcTransConnector_4025= sFSrcTransConnectors_4016.begin(); itSFState_401c!= sFStates_4013.end(), itSFSrcTransConnector_4025!= sFSrcTransConnectors_4016.end(); ++itSFState_401c, ++itSFSrcTransConnector_4025)
	{
		bool isUnique= isInputUnique( *itSFState_401c, *itSFSrcTransConnector_4025);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_401c, *itSFSrcTransConnector_4025);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetDirectTransitions_4012::patternMatcher( const Udm::Object& sFState_401d, const Udm::Object& sFSrcTransConnector_4026)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_401d.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4022= CyberComposition::Simulink::SFState::Cast( sFState_401d);
		if( false== Uml::IsDerivedFrom( sFSrcTransConnector_4026.type(), CyberComposition::Simulink::SFTransConnector::meta))
			continue;
		CyberComposition::Simulink::SFTransConnector sFSrcTransConnector_402b= CyberComposition::Simulink::SFTransConnector::Cast( sFSrcTransConnector_4026);
		set< CyberComposition::Simulink::SFTransition> sFTransitions_402d= sFSrcTransConnector_402b.dstTransition();
		for( set< CyberComposition::Simulink::SFTransition>::const_iterator itSFTransitions_402e= sFTransitions_402d.begin(); itSFTransitions_402e!= sFTransitions_402d.end(); ++itSFTransitions_402e)
		{
			CyberComposition::Simulink::SFTransition currSFTransition_402f= *itSFTransitions_402e;
			CyberComposition::Simulink::SFTransConnector sFDstTransConnector_4030= currSFTransition_402f.dstTransition_end();
			Match currMatch;
			currMatch.sFState_4032= sFState_4022;
			currMatch.sFSrcTransConnector_4033= sFSrcTransConnector_402b;
			currMatch.sFTransition_4034= currSFTransition_402f;
			currMatch.sFDstTransConnector_4035= sFDstTransConnector_4030;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetDirectTransitions_4012::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4032, currMatch.sFTransition_4034);
	}
}

void GetDirectTransitions_4012::outputAppender( const CyberComposition::Simulink::SFState& sFState_4036, const CyberComposition::Simulink::SFTransition& sFTransition_4038)
{
	_sFState_4019->push_back( sFState_4036);
	_sFTransition_401a->push_back( sFTransition_4038);
}

void GetTransitionsFromJunctionRefs_403a::operator()( const Packets_t& sFStates_403b, const Packets_t& sFJunctions_403f, Packets_t& sFStates_403d, Packets_t& sFTransitions_403e)
{
#ifdef PRINT_INFO
	printLog( "GetTransitionsFromJunctionRefs_403a" );
#endif
	RTTGenerator::Instance()->generateRule(5545, "GetTransitionsFromJunctionRefs");
	_sFState_4041= &sFStates_403d;
	_sFTransition_4042= &sFTransitions_403e;
	processInputPackets( sFStates_403b, sFJunctions_403f);
}

bool GetTransitionsFromJunctionRefs_403a::isInputUnique( const Udm::Object& sFState_4047, const Udm::Object& sFJunction_4050)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4049= _sFState_4043.begin(), itSFJunction_4052= _sFJunction_404c.begin(); itSFState_4049!= _sFState_4043.end(), itSFJunction_4052!= _sFJunction_404c.end(); ++itSFState_4049, ++itSFJunction_4052)
	{
		if( ( *itSFState_4049== sFState_4047)&& ( *itSFJunction_4052== sFJunction_4050))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4043.push_back( sFState_4047);
		_sFJunction_404c.push_back( sFJunction_4050);
	}
	return isUnique;
}

void GetTransitionsFromJunctionRefs_403a::processInputPackets( const Packets_t& sFStates_403b, const Packets_t& sFJunctions_403f)
{
	for( Packets_t::const_iterator itSFState_4044= sFStates_403b.begin(), itSFJunction_404d= sFJunctions_403f.begin(); itSFState_4044!= sFStates_403b.end(), itSFJunction_404d!= sFJunctions_403f.end(); ++itSFState_4044, ++itSFJunction_404d)
	{
		bool isUnique= isInputUnique( *itSFState_4044, *itSFJunction_404d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4044, *itSFJunction_404d);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetTransitionsFromJunctionRefs_403a::patternMatcher( const Udm::Object& sFState_4045, const Udm::Object& sFJunction_404e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4045.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_404a= CyberComposition::Simulink::SFState::Cast( sFState_4045);
		if( false== Uml::IsDerivedFrom( sFJunction_404e.type(), CyberComposition::Simulink::SFJunction::meta))
			continue;
		CyberComposition::Simulink::SFJunction sFJunction_4053= CyberComposition::Simulink::SFJunction::Cast( sFJunction_404e);
		set< CyberComposition::Simulink::SFConnectorRef> sFConnectorRefs_4055= sFJunction_4053.referedbyConnectorRef();
		for( set< CyberComposition::Simulink::SFConnectorRef>::const_iterator itSFConnectorRefs_4056= sFConnectorRefs_4055.begin(); itSFConnectorRefs_4056!= sFConnectorRefs_4055.end(); ++itSFConnectorRefs_4056)
		{
			CyberComposition::Simulink::SFConnectorRef currSFConnectorRef_4057= *itSFConnectorRefs_4056;
			set< CyberComposition::Simulink::SFTransition> sFTransitions_4058= currSFConnectorRef_4057.dstTransition();
			for( set< CyberComposition::Simulink::SFTransition>::const_iterator itSFTransitions_4059= sFTransitions_4058.begin(); itSFTransitions_4059!= sFTransitions_4058.end(); ++itSFTransitions_4059)
			{
				CyberComposition::Simulink::SFTransition currSFTransition_405a= *itSFTransitions_4059;
				CyberComposition::Simulink::SFTransConnector sFDstTransConnector_405b= currSFTransition_405a.dstTransition_end();
				Match currMatch;
				currMatch.sFState_405d= sFState_404a;
				currMatch.sFJunction_405e= sFJunction_4053;
				currMatch.sFTransition_405f= currSFTransition_405a;
				currMatch.sFConnectorRef_4060= currSFConnectorRef_4057;
				currMatch.sFDstTransConnector_4061= sFDstTransConnector_405b;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetTransitionsFromJunctionRefs_403a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_405d, currMatch.sFTransition_405f);
	}
}

void GetTransitionsFromJunctionRefs_403a::outputAppender( const CyberComposition::Simulink::SFState& sFState_4062, const CyberComposition::Simulink::SFTransition& sFTransition_4064)
{
	_sFState_4041->push_back( sFState_4062);
	_sFTransition_4042->push_back( sFTransition_4064);
}

void ProcessTransitionsMap_406f::operator()( const Packets_t& states_4070, const Packets_t& transs_4072)
{
#ifdef PRINT_INFO
	printLog( "ProcessTransitionsMap_406f" );
#endif
	if( ( !states_4070.empty())&& ( !transs_4072.empty()))
		callOrderTransitions_413f( states_4070, transs_4072);
}

void ProcessTransitionsMap_406f::callOrderTransitions_413f( const Packets_t& sFStates_40f8, const Packets_t& sFTransitions_40fb)
{
	Packets_t sFStates_40fa;
	Packets_t sFTransitions_40fd;
	OrderTransitions_40f7 orderTransitions_40f7;
	orderTransitions_40f7( sFStates_40f8, sFTransitions_40fb, sFStates_40fa, sFTransitions_40fd);
	if( ( !sFStates_40fa.empty())&& ( !sFTransitions_40fd.empty()))
		callgetDstTransConnectors_4142( sFStates_40fa, sFTransitions_40fd);
}

void ProcessTransitionsMap_406f::callgetDstTransConnectors_4142( const Packets_t& sFStates_411a, const Packets_t& sFTransitions_411e)
{
	Packets_t sFStates_411c;
	Packets_t sFDstTransConnectors_411d;
	GetDstTransConnectors_4119 getDstTransConnectors_4119;
	getDstTransConnectors_4119( sFStates_411a, sFTransitions_411e, sFStates_411c, sFDstTransConnectors_411d);
	if( ( !sFStates_411c.empty())&& ( !sFDstTransConnectors_411d.empty()))
		callTransConnTest_4145( sFStates_411c, sFDstTransConnectors_411d);
}

void ProcessTransitionsMap_406f::callTransConnTest_4145( const Packets_t& states_4099, const Packets_t& tcs_409b)
{
	Packets_t states_409d;
	Packets_t tcs_409e;
	Packets_t states_409f;
	Packets_t tcs_40a0;
	TransConnTest_4098 transConnTest_4098;
	transConnTest_4098( states_4099, tcs_409b, states_409d, tcs_409e, states_409f, tcs_40a0);
	if( ( !states_409f.empty())&& ( !tcs_40a0.empty()))
		callTransConnectorMapRecurse_4148( states_409f, tcs_40a0);
	if( ( !states_409d.empty())&& ( !tcs_409e.empty()))
		callDerefConnRef_414b( states_409d, tcs_409e);
}

void ProcessTransitionsMap_406f::callTransConnectorMapRecurse_4148( const Packets_t& states_3fc2, const Packets_t& tcs_3fc4)
{
	TransConnectorMapRecurse2_3fc1 transConnectorMapRecurse2_3fc1;
	transConnectorMapRecurse2_3fc1( states_3fc2, tcs_3fc4);
}

void ProcessTransitionsMap_406f::callDerefConnRef_414b( const Packets_t& sFStates_4075, const Packets_t& sFConnectorRefs_4078)
{
	Packets_t sFStates_4077;
	Packets_t sFTransConnectors_407a;
	DerefConnRef_4074 derefConnRef_4074;
	derefConnRef_4074( sFStates_4075, sFConnectorRefs_4078, sFStates_4077, sFTransConnectors_407a);
	if( ( !sFStates_4077.empty())&& ( !sFTransConnectors_407a.empty()))
		callTransConnTest_4145( sFStates_4077, sFTransConnectors_407a);
}

void DerefConnRef_4074::operator()( const Packets_t& sFStates_4075, const Packets_t& sFConnectorRefs_4078, Packets_t& sFStates_4077, Packets_t& sFTransConnectors_407a)
{
#ifdef PRINT_INFO
	printLog( "DerefConnRef_4074" );
#endif
	RTTGenerator::Instance()->generateRule(5557, "DerefConnRef");
	_sFState_407b= &sFStates_4077;
	_sFTransConnector_407c= &sFTransConnectors_407a;
	processInputPackets( sFStates_4075, sFConnectorRefs_4078);
}

bool DerefConnRef_4074::isInputUnique( const Udm::Object& sFState_4081, const Udm::Object& sFConnectorRef_408a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4083= _sFState_407d.begin(), itSFConnectorRef_408c= _sFConnectorRef_4086.begin(); itSFState_4083!= _sFState_407d.end(), itSFConnectorRef_408c!= _sFConnectorRef_4086.end(); ++itSFState_4083, ++itSFConnectorRef_408c)
	{
		if( ( *itSFState_4083== sFState_4081)&& ( *itSFConnectorRef_408c== sFConnectorRef_408a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_407d.push_back( sFState_4081);
		_sFConnectorRef_4086.push_back( sFConnectorRef_408a);
	}
	return isUnique;
}

void DerefConnRef_4074::processInputPackets( const Packets_t& sFStates_4075, const Packets_t& sFConnectorRefs_4078)
{
	for( Packets_t::const_iterator itSFState_407e= sFStates_4075.begin(), itSFConnectorRef_4087= sFConnectorRefs_4078.begin(); itSFState_407e!= sFStates_4075.end(), itSFConnectorRef_4087!= sFConnectorRefs_4078.end(); ++itSFState_407e, ++itSFConnectorRef_4087)
	{
		bool isUnique= isInputUnique( *itSFState_407e, *itSFConnectorRef_4087);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_407e, *itSFConnectorRef_4087);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool DerefConnRef_4074::patternMatcher( const Udm::Object& sFState_407f, const Udm::Object& sFConnectorRef_4088)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_407f.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4084= CyberComposition::Simulink::SFState::Cast( sFState_407f);
		if( false== Uml::IsDerivedFrom( sFConnectorRef_4088.type(), CyberComposition::Simulink::SFConnectorRef::meta))
			continue;
		CyberComposition::Simulink::SFConnectorRef sFConnectorRef_408d= CyberComposition::Simulink::SFConnectorRef::Cast( sFConnectorRef_4088);
		CyberComposition::Simulink::SFTransConnector sFTransConnector_408f= sFConnectorRef_408d.ref();
		if( !sFTransConnector_408f)
			continue;
		Match currMatch;
		currMatch.sFState_4091= sFState_4084;
		currMatch.sFConnectorRef_4092= sFConnectorRef_408d;
		currMatch.sFTransConnector_4093= sFTransConnector_408f;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void DerefConnRef_4074::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4091, currMatch.sFTransConnector_4093);
	}
}

void DerefConnRef_4074::outputAppender( const CyberComposition::Simulink::SFState& sFState_4094, const CyberComposition::Simulink::SFTransConnector& sFTransConnector_4096)
{
	_sFState_407b->push_back( sFState_4094);
	_sFTransConnector_407c->push_back( sFTransConnector_4096);
}

void TransConnTest_4098::operator()( const Packets_t& states_4099, const Packets_t& tcs_409b, Packets_t& states_409d, Packets_t& tcs_409e, Packets_t& states_409f, Packets_t& tcs_40a0)
{
#ifdef PRINT_INFO
	printLog( "TransConnTest_4098" );
#endif
	_state_40a1= &states_409d;
	_tc_40a2= &tcs_409e;
	_state_40a3= &states_409f;
	_tc_40a4= &tcs_40a0;
	for( Packets_t::const_iterator itstate_40a6= states_4099.begin(), ittc_40ad= tcs_409b.begin(); itstate_40a6!= states_4099.end(), ittc_40ad!= tcs_409b.end(); ++itstate_40a6, ++ittc_40ad)
	{
		bool isUnique= isInputUnique( *itstate_40a6, *ittc_40ad);
		if( !isUnique)
			continue;
		Packets_t onestate_40aa( 1, *itstate_40a6);
		Packets_t onetc_40b1( 1, *ittc_40ad);
		executeOne( onestate_40aa, onetc_40b1);
	}
}

void TransConnTest_4098::executeOne( const Packets_t& states_4099, const Packets_t& tcs_409b)
{
	Packets_t sFStates_40b6;
	Packets_t sFConnectorRefs_40b9;
	IsConnectorRef_40b3 isConnectorRef_40b3;
	bool isMatchIsConnectorRef_40b3= isConnectorRef_40b3( states_4099, tcs_409b, sFStates_40b6, sFConnectorRefs_40b9);
	_state_40a1->insert( _state_40a1->end(), sFStates_40b6.begin(), sFStates_40b6.end());
	_tc_40a2->insert( _tc_40a2->end(), sFConnectorRefs_40b9.begin(), sFConnectorRefs_40b9.end());
	if( isMatchIsConnectorRef_40b3)
		return;
	Packets_t sFStates_40d8;
	Packets_t sFJunctions_40db;
	Otherwise_40d5 otherwise_40d5;
	bool isMatchOtherwise_40d5= otherwise_40d5( states_4099, tcs_409b, sFStates_40d8, sFJunctions_40db);
	_state_40a3->insert( _state_40a3->end(), sFStates_40d8.begin(), sFStates_40d8.end());
	_tc_40a4->insert( _tc_40a4->end(), sFJunctions_40db.begin(), sFJunctions_40db.end());
	if( isMatchOtherwise_40d5)
		return;
}

bool TransConnTest_4098::isInputUnique( const Udm::Object& state_40a7, const Udm::Object& tc_40ae)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_40a9= _state_40a5.begin(), ittc_40b0= _tc_40ac.begin(); itstate_40a9!= _state_40a5.end(), ittc_40b0!= _tc_40ac.end(); ++itstate_40a9, ++ittc_40b0)
	{
		if( ( *itstate_40a9== state_40a7)&& ( *ittc_40b0== tc_40ae))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_40a5.push_back( state_40a7);
		_tc_40ac.push_back( tc_40ae);
	}
	return isUnique;
}

bool IsConnectorRef_40b3::operator()( const Packets_t& sFStates_40b4, const Packets_t& sFConnectorRefs_40b7, Packets_t& sFStates_40b6, Packets_t& sFConnectorRefs_40b9)
{
#ifdef PRINT_INFO
	printLog( "IsConnectorRef_40b3" );
#endif
	_sFState_40ba= &sFStates_40b6;
	_sFConnectorRef_40bb= &sFConnectorRefs_40b9;
	processInputPackets( sFStates_40b4, sFConnectorRefs_40b7);
	if( false== _matches.empty())
		return true;
	return false;
}

bool IsConnectorRef_40b3::isInputUnique( const Udm::Object& sFState_40c0, const Udm::Object& sFConnectorRef_40c9)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_40c2= _sFState_40bc.begin(), itSFConnectorRef_40cb= _sFConnectorRef_40c5.begin(); itSFState_40c2!= _sFState_40bc.end(), itSFConnectorRef_40cb!= _sFConnectorRef_40c5.end(); ++itSFState_40c2, ++itSFConnectorRef_40cb)
	{
		if( ( *itSFState_40c2== sFState_40c0)&& ( *itSFConnectorRef_40cb== sFConnectorRef_40c9))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_40bc.push_back( sFState_40c0);
		_sFConnectorRef_40c5.push_back( sFConnectorRef_40c9);
	}
	return isUnique;
}

void IsConnectorRef_40b3::processInputPackets( const Packets_t& sFStates_40b4, const Packets_t& sFConnectorRefs_40b7)
{
	for( Packets_t::const_iterator itSFState_40bd= sFStates_40b4.begin(), itSFConnectorRef_40c6= sFConnectorRefs_40b7.begin(); itSFState_40bd!= sFStates_40b4.end(), itSFConnectorRef_40c6!= sFConnectorRefs_40b7.end(); ++itSFState_40bd, ++itSFConnectorRef_40c6)
	{
		bool isUnique= isInputUnique( *itSFState_40bd, *itSFConnectorRef_40c6);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_40bd, *itSFConnectorRef_40c6);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_40cf, currMatch.sFConnectorRef_40d0);
	}
}

bool IsConnectorRef_40b3::patternMatcher( const Udm::Object& sFState_40be, const Udm::Object& sFConnectorRef_40c7)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_40be.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_40c3= CyberComposition::Simulink::SFState::Cast( sFState_40be);
		if( false== Uml::IsDerivedFrom( sFConnectorRef_40c7.type(), CyberComposition::Simulink::SFConnectorRef::meta))
			continue;
		CyberComposition::Simulink::SFConnectorRef sFConnectorRef_40cc= CyberComposition::Simulink::SFConnectorRef::Cast( sFConnectorRef_40c7);
		Match currMatch;
		currMatch.sFState_40cf= sFState_40c3;
		currMatch.sFConnectorRef_40d0= sFConnectorRef_40cc;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void IsConnectorRef_40b3::outputAppender( const CyberComposition::Simulink::SFState& sFState_40d1, const CyberComposition::Simulink::SFConnectorRef& sFConnectorRef_40d3)
{
	_sFState_40ba->push_back( sFState_40d1);
	_sFConnectorRef_40bb->push_back( sFConnectorRef_40d3);
}

bool Otherwise_40d5::operator()( const Packets_t& sFStates_40d6, const Packets_t& sFJunctions_40d9, Packets_t& sFStates_40d8, Packets_t& sFJunctions_40db)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_40d5" );
#endif
	_sFState_40dc= &sFStates_40d8;
	_sFJunction_40dd= &sFJunctions_40db;
	processInputPackets( sFStates_40d6, sFJunctions_40d9);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_40d5::isInputUnique( const Udm::Object& sFState_40e2, const Udm::Object& sFJunction_40eb)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_40e4= _sFState_40de.begin(), itSFJunction_40ed= _sFJunction_40e7.begin(); itSFState_40e4!= _sFState_40de.end(), itSFJunction_40ed!= _sFJunction_40e7.end(); ++itSFState_40e4, ++itSFJunction_40ed)
	{
		if( ( *itSFState_40e4== sFState_40e2)&& ( *itSFJunction_40ed== sFJunction_40eb))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_40de.push_back( sFState_40e2);
		_sFJunction_40e7.push_back( sFJunction_40eb);
	}
	return isUnique;
}

void Otherwise_40d5::processInputPackets( const Packets_t& sFStates_40d6, const Packets_t& sFJunctions_40d9)
{
	for( Packets_t::const_iterator itSFState_40df= sFStates_40d6.begin(), itSFJunction_40e8= sFJunctions_40d9.begin(); itSFState_40df!= sFStates_40d6.end(), itSFJunction_40e8!= sFJunctions_40d9.end(); ++itSFState_40df, ++itSFJunction_40e8)
	{
		bool isUnique= isInputUnique( *itSFState_40df, *itSFJunction_40e8);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_40df, *itSFJunction_40e8);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_40f1, currMatch.sFJunction_40f2);
	}
}

bool Otherwise_40d5::patternMatcher( const Udm::Object& sFState_40e0, const Udm::Object& sFJunction_40e9)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_40e0.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_40e5= CyberComposition::Simulink::SFState::Cast( sFState_40e0);
		if( false== Uml::IsDerivedFrom( sFJunction_40e9.type(), CyberComposition::Simulink::SFJunction::meta))
			continue;
		CyberComposition::Simulink::SFJunction sFJunction_40ee= CyberComposition::Simulink::SFJunction::Cast( sFJunction_40e9);
		Match currMatch;
		currMatch.sFState_40f1= sFState_40e5;
		currMatch.sFJunction_40f2= sFJunction_40ee;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_40d5::outputAppender( const CyberComposition::Simulink::SFState& sFState_40f3, const CyberComposition::Simulink::SFJunction& sFJunction_40f5)
{
	_sFState_40dc->push_back( sFState_40f3);
	_sFJunction_40dd->push_back( sFJunction_40f5);
}

void OrderTransitions_40f7::operator()( const Packets_t& sFStates_40f8, const Packets_t& sFTransitions_40fb, Packets_t& sFStates_40fa, Packets_t& sFTransitions_40fd)
{
#ifdef PRINT_INFO
	printLog( "OrderTransitions_40f7" );
#endif
	RTTGenerator::Instance()->generateRule(5575, "OrderTransitions");
	_sFState_40fe= &sFStates_40fa;
	_sFTransition_40ff= &sFTransitions_40fd;
	processInputPackets( sFStates_40f8, sFTransitions_40fb);
	sortOutputs( );
}

bool OrderTransitions_40f7::isInputUnique( const Udm::Object& sFState_4104, const Udm::Object& sFTransition_410d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4106= _sFState_4100.begin(), itSFTransition_410f= _sFTransition_4109.begin(); itSFState_4106!= _sFState_4100.end(), itSFTransition_410f!= _sFTransition_4109.end(); ++itSFState_4106, ++itSFTransition_410f)
	{
		if( ( *itSFState_4106== sFState_4104)&& ( *itSFTransition_410f== sFTransition_410d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4100.push_back( sFState_4104);
		_sFTransition_4109.push_back( sFTransition_410d);
	}
	return isUnique;
}

void OrderTransitions_40f7::processInputPackets( const Packets_t& sFStates_40f8, const Packets_t& sFTransitions_40fb)
{
	for( Packets_t::const_iterator itSFState_4101= sFStates_40f8.begin(), itSFTransition_410a= sFTransitions_40fb.begin(); itSFState_4101!= sFStates_40f8.end(), itSFTransition_410a!= sFTransitions_40fb.end(); ++itSFState_4101, ++itSFTransition_410a)
	{
		bool isUnique= isInputUnique( *itSFState_4101, *itSFTransition_410a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4101, *itSFTransition_410a);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool OrderTransitions_40f7::patternMatcher( const Udm::Object& sFState_4102, const Udm::Object& sFTransition_410b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4102.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4107= CyberComposition::Simulink::SFState::Cast( sFState_4102);
		if( false== Uml::IsDerivedFrom( sFTransition_410b.type(), CyberComposition::Simulink::SFTransition::meta))
			continue;
		CyberComposition::Simulink::SFTransition sFTransition_4110= CyberComposition::Simulink::SFTransition::Cast( sFTransition_410b);
		Match currMatch;
		currMatch.sFState_4113= sFState_4107;
		currMatch.sFTransition_4114= sFTransition_4110;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void OrderTransitions_40f7::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4113, currMatch.sFTransition_4114);
	}
}

void OrderTransitions_40f7::outputAppender( const CyberComposition::Simulink::SFState& sFState_4115, const CyberComposition::Simulink::SFTransition& sFTransition_4117)
{
	_sFState_40fe->push_back( sFState_4115);
	_sFTransition_40ff->push_back( sFTransition_4117);
}

void OrderTransitions_40f7::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::SFTransition, std::pointer_to_binary_function< const CyberComposition::Simulink::SFTransition&, const CyberComposition::Simulink::SFTransition&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::SFTransition&, const CyberComposition::Simulink::SFTransition&, bool> ptr_TransitionOrder( TransitionOrder< CyberComposition::Simulink::SFTransition>);
	SortedSet_t sortedSet( ptr_TransitionOrder);
	std::vector< int> permutationVector( _sFTransition_40ff->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _sFTransition_40ff->begin(); it!= _sFTransition_40ff->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::SFTransition::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _sFTransition_40ff->begin());
	// order rest of the containers
	permutate( permutationVector, *_sFState_40fe);
}

void GetDstTransConnectors_4119::operator()( const Packets_t& sFStates_411a, const Packets_t& sFTransitions_411e, Packets_t& sFStates_411c, Packets_t& sFDstTransConnectors_411d)
{
#ifdef PRINT_INFO
	printLog( "GetDstTransConnectors_4119" );
#endif
	RTTGenerator::Instance()->generateRule(5578, "getDstTransConnectors");
	_sFState_4120= &sFStates_411c;
	_sFDstTransConnector_4121= &sFDstTransConnectors_411d;
	processInputPackets( sFStates_411a, sFTransitions_411e);
}

bool GetDstTransConnectors_4119::isInputUnique( const Udm::Object& sFState_4126, const Udm::Object& sFTransition_412f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4128= _sFState_4122.begin(), itSFTransition_4131= _sFTransition_412b.begin(); itSFState_4128!= _sFState_4122.end(), itSFTransition_4131!= _sFTransition_412b.end(); ++itSFState_4128, ++itSFTransition_4131)
	{
		if( ( *itSFState_4128== sFState_4126)&& ( *itSFTransition_4131== sFTransition_412f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4122.push_back( sFState_4126);
		_sFTransition_412b.push_back( sFTransition_412f);
	}
	return isUnique;
}

void GetDstTransConnectors_4119::processInputPackets( const Packets_t& sFStates_411a, const Packets_t& sFTransitions_411e)
{
	for( Packets_t::const_iterator itSFState_4123= sFStates_411a.begin(), itSFTransition_412c= sFTransitions_411e.begin(); itSFState_4123!= sFStates_411a.end(), itSFTransition_412c!= sFTransitions_411e.end(); ++itSFState_4123, ++itSFTransition_412c)
	{
		bool isUnique= isInputUnique( *itSFState_4123, *itSFTransition_412c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4123, *itSFTransition_412c);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetDstTransConnectors_4119::patternMatcher( const Udm::Object& sFState_4124, const Udm::Object& sFTransition_412d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4124.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4129= CyberComposition::Simulink::SFState::Cast( sFState_4124);
		if( false== Uml::IsDerivedFrom( sFTransition_412d.type(), CyberComposition::Simulink::SFTransition::meta))
			continue;
		CyberComposition::Simulink::SFTransition sFTransition_4132= CyberComposition::Simulink::SFTransition::Cast( sFTransition_412d);
		CyberComposition::Simulink::SFTransConnector sFTransConnector_4134= sFTransition_4132.srcTransition_end();
		CyberComposition::Simulink::SFTransConnector sFDstTransConnector_4135= sFTransition_4132.dstTransition_end();
		Match currMatch;
		currMatch.sFState_4137= sFState_4129;
		currMatch.sFTransition_4138= sFTransition_4132;
		currMatch.sFTransConnector_4139= sFTransConnector_4134;
		currMatch.sFDstTransConnector_413a= sFDstTransConnector_4135;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void GetDstTransConnectors_4119::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4137, currMatch.sFDstTransConnector_413a);
	}
}

void GetDstTransConnectors_4119::outputAppender( const CyberComposition::Simulink::SFState& sFState_413b, const CyberComposition::Simulink::SFTransConnector& sFDstTransConnector_413d)
{
	_sFState_4120->push_back( sFState_413b);
	_sFDstTransConnector_4121->push_back( sFDstTransConnector_413d);
}

void ProcessedFilter_414e::operator()( const Packets_t& states_414f, const Packets_t& tcs_4151, Packets_t& states_4153, Packets_t& tcs_4154)
{
#ifdef PRINT_INFO
	printLog( "ProcessedFilter_414e" );
#endif
	_state_4155= &states_4153;
	_tc_4156= &tcs_4154;
	for( Packets_t::const_iterator itstate_4158= states_414f.begin(), ittc_415f= tcs_4151.begin(); itstate_4158!= states_414f.end(), ittc_415f!= tcs_4151.end(); ++itstate_4158, ++ittc_415f)
	{
		bool isUnique= isInputUnique( *itstate_4158, *ittc_415f);
		if( !isUnique)
			continue;
		Packets_t onestate_415c( 1, *itstate_4158);
		Packets_t onetc_4163( 1, *ittc_415f);
		executeOne( onestate_415c, onetc_4163);
	}
}

void ProcessedFilter_414e::executeOne( const Packets_t& states_414f, const Packets_t& tcs_4151)
{
	Packets_t sFStates_4168;
	Packets_t sFTransConnectors_416b;
	TCNotProcessed_4165 tCNotProcessed_4165;
	bool isMatchTCNotProcessed_4165= tCNotProcessed_4165( states_414f, tcs_4151, sFStates_4168, sFTransConnectors_416b);
	_state_4155->insert( _state_4155->end(), sFStates_4168.begin(), sFStates_4168.end());
	_tc_4156->insert( _tc_4156->end(), sFTransConnectors_416b.begin(), sFTransConnectors_416b.end());
	if( isMatchTCNotProcessed_4165)
		return;
}

bool ProcessedFilter_414e::isInputUnique( const Udm::Object& state_4159, const Udm::Object& tc_4160)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_415b= _state_4157.begin(), ittc_4162= _tc_415e.begin(); itstate_415b!= _state_4157.end(), ittc_4162!= _tc_415e.end(); ++itstate_415b, ++ittc_4162)
	{
		if( ( *itstate_415b== state_4159)&& ( *ittc_4162== tc_4160))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_4157.push_back( state_4159);
		_tc_415e.push_back( tc_4160);
	}
	return isUnique;
}

bool TCNotProcessed_4165::operator()( const Packets_t& sFStates_4166, const Packets_t& sFTransConnectors_4169, Packets_t& sFStates_4168, Packets_t& sFTransConnectors_416b)
{
#ifdef PRINT_INFO
	printLog( "TCNotProcessed_4165" );
#endif
	_sFState_416c= &sFStates_4168;
	_sFTransConnector_416d= &sFTransConnectors_416b;
	processInputPackets( sFStates_4166, sFTransConnectors_4169);
	if( false== _matches.empty())
		return true;
	return false;
}

bool TCNotProcessed_4165::isInputUnique( const Udm::Object& sFState_4172, const Udm::Object& sFTransConnector_417b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4174= _sFState_416e.begin(), itSFTransConnector_417d= _sFTransConnector_4177.begin(); itSFState_4174!= _sFState_416e.end(), itSFTransConnector_417d!= _sFTransConnector_4177.end(); ++itSFState_4174, ++itSFTransConnector_417d)
	{
		if( ( *itSFState_4174== sFState_4172)&& ( *itSFTransConnector_417d== sFTransConnector_417b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_416e.push_back( sFState_4172);
		_sFTransConnector_4177.push_back( sFTransConnector_417b);
	}
	return isUnique;
}

bool TCNotProcessed_4165::isGuardTrue( CyberComposition::Simulink::SFState& SFState, CyberComposition::Simulink::SFTransConnector& SFTransConnector)
{
	bool Gz_guard= false;
	return !SFManager::SFStateTransConnectorMap::get_singleton().getTransConnectorMap( SFState ).hasTransConnector( SFTransConnector );;
	return Gz_guard;
}

void TCNotProcessed_4165::processInputPackets( const Packets_t& sFStates_4166, const Packets_t& sFTransConnectors_4169)
{
	for( Packets_t::const_iterator itSFState_416f= sFStates_4166.begin(), itSFTransConnector_4178= sFTransConnectors_4169.begin(); itSFState_416f!= sFStates_4166.end(), itSFTransConnector_4178!= sFTransConnectors_4169.end(); ++itSFState_416f, ++itSFTransConnector_4178)
	{
		bool isUnique= isInputUnique( *itSFState_416f, *itSFTransConnector_4178);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_416f, *itSFTransConnector_4178);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4181, currMatch.sFTransConnector_4182);
	}
}

bool TCNotProcessed_4165::patternMatcher( const Udm::Object& sFState_4170, const Udm::Object& sFTransConnector_4179)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4170.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4175= CyberComposition::Simulink::SFState::Cast( sFState_4170);
		if( false== Uml::IsDerivedFrom( sFTransConnector_4179.type(), CyberComposition::Simulink::SFTransConnector::meta))
			continue;
		CyberComposition::Simulink::SFTransConnector sFTransConnector_417e= CyberComposition::Simulink::SFTransConnector::Cast( sFTransConnector_4179);
		Match currMatch;
		currMatch.sFState_4181= sFState_4175;
		currMatch.sFTransConnector_4182= sFTransConnector_417e;
		bool Gz_guard= isGuardTrue( currMatch.sFState_4181, currMatch.sFTransConnector_4182);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void TCNotProcessed_4165::outputAppender( const CyberComposition::Simulink::SFState& sFState_4185, const CyberComposition::Simulink::SFTransConnector& sFTransConnector_4187)
{
	_sFState_416c->push_back( sFState_4185);
	_sFTransConnector_416d->push_back( sFTransConnector_4187);
}

void AddTransConnector_4189::operator()( const Packets_t& sFStates_418a, const Packets_t& sFTransConnectors_418d, Packets_t& sFStates_418c, Packets_t& sFTransConnectors_418f)
{
#ifdef PRINT_INFO
	printLog( "AddTransConnector_4189" );
#endif
	RTTGenerator::Instance()->generateRule(5593, "AddTransConnector");
	_sFState_4190= &sFStates_418c;
	_sFTransConnector_4191= &sFTransConnectors_418f;
	processInputPackets( sFStates_418a, sFTransConnectors_418d);
	forwardInputs( );
}

bool AddTransConnector_4189::isInputUnique( const Udm::Object& sFState_4196, const Udm::Object& sFTransConnector_419f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4198= _sFState_4192.begin(), itSFTransConnector_41a1= _sFTransConnector_419b.begin(); itSFState_4198!= _sFState_4192.end(), itSFTransConnector_41a1!= _sFTransConnector_419b.end(); ++itSFState_4198, ++itSFTransConnector_41a1)
	{
		if( ( *itSFState_4198== sFState_4196)&& ( *itSFTransConnector_41a1== sFTransConnector_419f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4192.push_back( sFState_4196);
		_sFTransConnector_419b.push_back( sFTransConnector_419f);
	}
	return isUnique;
}

void AddTransConnector_4189::processInputPackets( const Packets_t& sFStates_418a, const Packets_t& sFTransConnectors_418d)
{
	for( Packets_t::const_iterator itSFState_4193= sFStates_418a.begin(), itSFTransConnector_419c= sFTransConnectors_418d.begin(); itSFState_4193!= sFStates_418a.end(), itSFTransConnector_419c!= sFTransConnectors_418d.end(); ++itSFState_4193, ++itSFTransConnector_419c)
	{
		bool isUnique= isInputUnique( *itSFState_4193, *itSFTransConnector_419c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4193, *itSFTransConnector_419c);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AddTransConnector_4189::patternMatcher( const Udm::Object& sFState_4194, const Udm::Object& sFTransConnector_419d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4194.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4199= CyberComposition::Simulink::SFState::Cast( sFState_4194);
		if( false== Uml::IsDerivedFrom( sFTransConnector_419d.type(), CyberComposition::Simulink::SFTransConnector::meta))
			continue;
		CyberComposition::Simulink::SFTransConnector sFTransConnector_41a2= CyberComposition::Simulink::SFTransConnector::Cast( sFTransConnector_419d);
		Match currMatch;
		currMatch.sFState_41a5= sFState_4199;
		currMatch.sFTransConnector_41a6= sFTransConnector_41a2;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void AddTransConnector_4189::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_41a5;
		CyberComposition::Simulink::SFTransConnector& SFTransConnector= currMatch.sFTransConnector_41a6;
		{
SFManager::SFStateTransConnectorMap::get_singleton().getTransConnectorMap( SFState ).addTransConnector( SFTransConnector );
};
	}
}

void AddTransConnector_4189::forwardInputs()
{
	*_sFState_4190= _sFState_4192;
	*_sFTransConnector_4191= _sFTransConnector_419b;
}

void PopulateEMFSFunction_41c5::operator()( const Packets_t& states_41c6, const Packets_t& programs_41c8, Packets_t& states_41ca, Packets_t& programs_41cb)
{
#ifdef PRINT_INFO
	printLog( "PopulateEMFSFunction_41c5" );
#endif
	_state_41cc= &states_41ca;
	_program_41cd= &programs_41cb;
	if( ( !states_41c6.empty())&& ( !programs_41c8.empty()))
		callGetEMFuncStateFunction_421c( states_41c6, programs_41c8);
	_state_41cc->insert( _state_41cc->end(), states_41c6.begin(), states_41c6.end());
	_program_41cd->insert( _program_41cd->end(), programs_41c8.begin(), programs_41c8.end());
}

void PopulateEMFSFunction_41c5::callGetEMFuncStateFunction_421c( const Packets_t& sFStates_41ec, const Packets_t& programs_41ef)
{
	Packets_t sFStates_41ee;
	Packets_t execs_41f1;
	GetEMFuncStateFunction_41eb getEMFuncStateFunction_41eb;
	getEMFuncStateFunction_41eb( sFStates_41ec, programs_41ef, sFStates_41ee, execs_41f1);
	if( ( !sFStates_41ee.empty())&& ( !execs_41f1.empty()))
		callFunctionBody_421f( sFStates_41ee, execs_41f1);
}

void PopulateEMFSFunction_41c5::callFunctionBody_421f( const Packets_t& sFStates_41cf, const Packets_t& execs_41d1)
{
	FunctionBody_41ce functionBody_41ce;
	functionBody_41ce( sFStates_41cf, execs_41d1);
}

void FunctionBody_41ce::operator()( const Packets_t& sFStates_41cf, const Packets_t& execs_41d1)
{
#ifdef PRINT_INFO
	printLog( "FunctionBody_41ce" );
#endif
	RTTGenerator::Instance()->generateRule(3570, "FunctionBody");
	processInputPackets( sFStates_41cf, execs_41d1);
}

bool FunctionBody_41ce::isInputUnique( const Udm::Object& sFState_41d7, const Udm::Object& exec_41e0)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_41d9= _sFState_41d3.begin(), itExec_41e2= _exec_41dc.begin(); itSFState_41d9!= _sFState_41d3.end(), itExec_41e2!= _exec_41dc.end(); ++itSFState_41d9, ++itExec_41e2)
	{
		if( ( *itSFState_41d9== sFState_41d7)&& ( *itExec_41e2== exec_41e0))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_41d3.push_back( sFState_41d7);
		_exec_41dc.push_back( exec_41e0);
	}
	return isUnique;
}

bool FunctionBody_41ce::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void FunctionBody_41ce::processInputPackets( const Packets_t& sFStates_41cf, const Packets_t& execs_41d1)
{
	for( Packets_t::const_iterator itSFState_41d4= sFStates_41cf.begin(), itExec_41dd= execs_41d1.begin(); itSFState_41d4!= sFStates_41cf.end(), itExec_41dd!= execs_41d1.end(); ++itSFState_41d4, ++itExec_41dd)
	{
		bool isUnique= isInputUnique( *itSFState_41d4, *itExec_41dd);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_41d4, *itExec_41dd);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool FunctionBody_41ce::patternMatcher( const Udm::Object& sFState_41d5, const Udm::Object& exec_41de)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_41d5.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_41da= CyberComposition::Simulink::SFState::Cast( sFState_41d5);
		if( false== Uml::IsDerivedFrom( exec_41de.type(), SFC::Function::meta))
			continue;
		SFC::Function exec_41e3= SFC::Function::Cast( exec_41de);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_41e8;
		if( !isValidBound(boundObjs_41e8, sFState_41da, true))
			continue;
		currMatch.sFState_41e9= sFState_41da;
		if( !isValidBound(boundObjs_41e8, exec_41e3, true))
			continue;
		currMatch.exec_41ea= exec_41e3;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void FunctionBody_41ce::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function& Exec= currMatch.exec_41ea;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_41e9;
		{
SFManager::mstat2SFC( Exec, SFState.DuringAction() );
};
	}
}

void GetEMFuncStateFunction_41eb::operator()( const Packets_t& sFStates_41ec, const Packets_t& programs_41ef, Packets_t& sFStates_41ee, Packets_t& execs_41f1)
{
#ifdef PRINT_INFO
	printLog( "GetEMFuncStateFunction_41eb" );
#endif
	RTTGenerator::Instance()->generateRule(3574, "GetEMFuncStateFunction");
	_sFState_41f2= &sFStates_41ee;
	_exec_41f3= &execs_41f1;
	processInputPackets( sFStates_41ec, programs_41ef);
}

bool GetEMFuncStateFunction_41eb::isInputUnique( const Udm::Object& sFState_41f8, const Udm::Object& program_4201)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_41fa= _sFState_41f4.begin(), itProgram_4203= _program_41fd.begin(); itSFState_41fa!= _sFState_41f4.end(), itProgram_4203!= _program_41fd.end(); ++itSFState_41fa, ++itProgram_4203)
	{
		if( ( *itSFState_41fa== sFState_41f8)&& ( *itProgram_4203== program_4201))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_41f4.push_back( sFState_41f8);
		_program_41fd.push_back( program_4201);
	}
	return isUnique;
}

bool GetEMFuncStateFunction_41eb::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool GetEMFuncStateFunction_41eb::isGuardTrue( SFC::Function& Exec, SFC::Program& Program, CyberComposition::Simulink::SFState& SFState, SFC::StateLabel& StateLabel)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( SFState.Decomposition() ) == "FUNC_STATE" &&
 static_cast< std::string >( SFState.Order() ) == "-2";;
	return Gz_guard;
}

void GetEMFuncStateFunction_41eb::processInputPackets( const Packets_t& sFStates_41ec, const Packets_t& programs_41ef)
{
	for( Packets_t::const_iterator itSFState_41f5= sFStates_41ec.begin(), itProgram_41fe= programs_41ef.begin(); itSFState_41f5!= sFStates_41ec.end(), itProgram_41fe!= programs_41ef.end(); ++itSFState_41f5, ++itProgram_41fe)
	{
		bool isUnique= isInputUnique( *itSFState_41f5, *itProgram_41fe);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_41f5, *itProgram_41fe);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetEMFuncStateFunction_41eb::patternMatcher( const Udm::Object& sFState_41f6, const Udm::Object& program_41ff)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_41f6.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_41fb= CyberComposition::Simulink::SFState::Cast( sFState_41f6);
		if( false== Uml::IsDerivedFrom( program_41ff.type(), SFC::Program::meta))
			continue;
		SFC::Program program_4204= SFC::Program::Cast( program_41ff);
		set< SFC::Function> execs_4206= sFState_41fb.exec();
		for( set< SFC::Function>::const_iterator itExecs_4207= execs_4206.begin(); itExecs_4207!= execs_4206.end(); ++itExecs_4207)
		{
			SFC::Function currExec_4208= *itExecs_4207;
			set< SFC::StateLabel> stateLabels_4209= sFState_41fb.src();
			for( set< SFC::StateLabel>::const_iterator itStateLabels_420a= stateLabels_4209.begin(); itStateLabels_420a!= stateLabels_4209.end(); ++itStateLabels_420a)
			{
				SFC::StateLabel currStateLabel_420b= *itStateLabels_420a;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_420f;
				if( !isValidBound(boundObjs_420f, sFState_41fb, true))
					continue;
				currMatch.sFState_4210= sFState_41fb;
				if( !isValidBound(boundObjs_420f, program_4204, true))
					continue;
				currMatch.program_4211= program_4204;
				if( !isValidBound(boundObjs_420f, currStateLabel_420b, false))
					continue;
				currMatch.stateLabel_4212= currStateLabel_420b;
				if( !isValidBound(boundObjs_420f, currExec_4208, false))
					continue;
				currMatch.exec_4213= currExec_4208;
				bool Gz_guard= isGuardTrue( currMatch.exec_4213, currMatch.program_4211, currMatch.sFState_4210, currMatch.stateLabel_4212);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetEMFuncStateFunction_41eb::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4210, currMatch.exec_4213);
	}
}

void GetEMFuncStateFunction_41eb::outputAppender( const CyberComposition::Simulink::SFState& sFState_4218, const SFC::Function& exec_421a)
{
	_sFState_41f2->push_back( sFState_4218);
	_exec_41f3->push_back( exec_421a);
}

void GetSubStates_4222::operator()( const Packets_t& sFStates_4223, const Packets_t& parStmnts_4226, Packets_t& sFSubStates_4225, Packets_t& parStmnts_4228)
{
#ifdef PRINT_INFO
	printLog( "GetSubStates_4222" );
#endif
	RTTGenerator::Instance()->generateRule(3868, "GetSubStates");
	_sFSubState_4229= &sFSubStates_4225;
	_parStmnt_422a= &parStmnts_4228;
	processInputPackets( sFStates_4223, parStmnts_4226);
}

bool GetSubStates_4222::isInputUnique( const Udm::Object& sFState_422f, const Udm::Object& parStmnt_4238)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4231= _sFState_422b.begin(), itParStmnt_423a= _parStmnt_4234.begin(); itSFState_4231!= _sFState_422b.end(), itParStmnt_423a!= _parStmnt_4234.end(); ++itSFState_4231, ++itParStmnt_423a)
	{
		if( ( *itSFState_4231== sFState_422f)&& ( *itParStmnt_423a== parStmnt_4238))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_422b.push_back( sFState_422f);
		_parStmnt_4234.push_back( parStmnt_4238);
	}
	return isUnique;
}

bool GetSubStates_4222::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetSubStates_4222::processInputPackets( const Packets_t& sFStates_4223, const Packets_t& parStmnts_4226)
{
	for( Packets_t::const_iterator itSFState_422c= sFStates_4223.begin(), itParStmnt_4235= parStmnts_4226.begin(); itSFState_422c!= sFStates_4223.end(), itParStmnt_4235!= parStmnts_4226.end(); ++itSFState_422c, ++itParStmnt_4235)
	{
		bool isUnique= isInputUnique( *itSFState_422c, *itParStmnt_4235);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_422c, *itParStmnt_4235);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetSubStates_4222::patternMatcher( const Udm::Object& sFState_422d, const Udm::Object& parStmnt_4236)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_422d.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4232= CyberComposition::Simulink::SFState::Cast( sFState_422d);
		if( false== Uml::IsDerivedFrom( parStmnt_4236.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement parStmnt_423b= SFC::CompoundStatement::Cast( parStmnt_4236);
		set< CyberComposition::Simulink::SFState> sFSubStates_423d= sFState_4232.SFState_kind_children();
		for( set< CyberComposition::Simulink::SFState>::const_iterator itSFSubState_423e= sFSubStates_423d.begin(); itSFSubState_423e!= sFSubStates_423d.end(); ++itSFSubState_423e)
		{
			CyberComposition::Simulink::SFState currSFSubState_423f= *itSFSubState_423e;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_4243;
			if( !isValidBound(boundObjs_4243, sFState_4232, true))
				continue;
			currMatch.sFState_4244= sFState_4232;
			if( !isValidBound(boundObjs_4243, parStmnt_423b, true))
				continue;
			currMatch.parStmnt_4245= parStmnt_423b;
			if( !isValidBound(boundObjs_4243, currSFSubState_423f, false))
				continue;
			currMatch.sFSubState_4246= currSFSubState_423f;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetSubStates_4222::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFSubState_4246, currMatch.parStmnt_4245);
	}
}

void GetSubStates_4222::outputAppender( const CyberComposition::Simulink::SFState& sFSubState_4247, const SFC::CompoundStatement& parStmnt_4249)
{
	_sFSubState_4229->push_back( sFSubState_4247);
	_parStmnt_422a->push_back( parStmnt_4249);
}

void ClearTables_4254::operator()( const Packets_t& sFStates_4255, const Packets_t& programs_4258, Packets_t& sFStates_4257, Packets_t& programs_425a)
{
#ifdef PRINT_INFO
	printLog( "ClearTables_4254" );
#endif
	RTTGenerator::Instance()->generateRule(3581, "ClearTables");
	_sFState_425b= &sFStates_4257;
	_program_425c= &programs_425a;
	processInputPackets( sFStates_4255, programs_4258);
	forwardInputs( );
}

bool ClearTables_4254::isInputUnique( const Udm::Object& sFState_4261, const Udm::Object& program_426a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4263= _sFState_425d.begin(), itProgram_426c= _program_4266.begin(); itSFState_4263!= _sFState_425d.end(), itProgram_426c!= _program_4266.end(); ++itSFState_4263, ++itProgram_426c)
	{
		if( ( *itSFState_4263== sFState_4261)&& ( *itProgram_426c== program_426a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_425d.push_back( sFState_4261);
		_program_4266.push_back( program_426a);
	}
	return isUnique;
}

bool ClearTables_4254::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void ClearTables_4254::processInputPackets( const Packets_t& sFStates_4255, const Packets_t& programs_4258)
{
	for( Packets_t::const_iterator itSFState_425e= sFStates_4255.begin(), itProgram_4267= programs_4258.begin(); itSFState_425e!= sFStates_4255.end(), itProgram_4267!= programs_4258.end(); ++itSFState_425e, ++itProgram_4267)
	{
		bool isUnique= isInputUnique( *itSFState_425e, *itProgram_4267);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_425e, *itProgram_4267);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ClearTables_4254::patternMatcher( const Udm::Object& sFState_425f, const Udm::Object& program_4268)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_425f.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4264= CyberComposition::Simulink::SFState::Cast( sFState_425f);
		if( false== Uml::IsDerivedFrom( program_4268.type(), SFC::Program::meta))
			continue;
		SFC::Program program_426d= SFC::Program::Cast( program_4268);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4272;
		if( !isValidBound(boundObjs_4272, sFState_4264, true))
			continue;
		currMatch.sFState_4273= sFState_4264;
		if( !isValidBound(boundObjs_4272, program_426d, true))
			continue;
		currMatch.program_4274= program_426d;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void ClearTables_4254::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Program& Program= currMatch.program_4274;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_4273;
		{
SFManager::getVarResolve().clear();
SFManager::getFunctionHash().clear();
getSFCSymbolTable().clear();
};
	}
}

void ClearTables_4254::forwardInputs()
{
	*_sFState_425b= _sFState_425d;
	*_program_425c= _program_4266;
}

void CreateStateLabels_4275::operator()( const Packets_t& states_4276, const Packets_t& programs_4278, Packets_t& states_427a, Packets_t& programs_427b)
{
#ifdef PRINT_INFO
	printLog( "CreateStateLabels_4275" );
#endif
	_state_427c= &states_427a;
	_program_427d= &programs_427b;
	if( ( !states_4276.empty())&& ( !programs_4278.empty()))
		callCreateCompoundStates_4484( states_4276, programs_4278);
	_state_427c->insert( _state_427c->end(), states_4276.begin(), states_4276.end());
	_program_427d->insert( _program_427d->end(), programs_4278.begin(), programs_4278.end());
}

void CreateStateLabels_4275::callCreateCompoundStates_4484( const Packets_t& states_438e, const Packets_t& programs_4390)
{
	Packets_t states_4392;
	Packets_t programs_4393;
	CreateCompoundStates_438d createCompoundStates_438d;
	createCompoundStates_438d( states_438e, programs_4390, states_4392, programs_4393);
	if( ( !states_4392.empty())&& ( !programs_4393.empty()))
		callCreateStateVar_4487( states_4392, programs_4393);
}

void CreateStateLabels_4275::callCreateStateVar_4487( const Packets_t& sFStates_4463, const Packets_t& programs_4466)
{
	Packets_t sFStates_4465;
	Packets_t programs_4468;
	CreateStateVar_4462 createStateVar_4462;
	createStateVar_4462( sFStates_4463, programs_4466, sFStates_4465, programs_4468);
	if( ( !sFStates_4465.empty())&& ( !programs_4468.empty()))
		callCreateLeafStates_448a( sFStates_4465, programs_4468);
}

void CreateStateLabels_4275::callCreateLeafStates_448a( const Packets_t& states_43e3, const Packets_t& programs_43e5)
{
	Packets_t states_43e7;
	Packets_t programs_43e8;
	CreateLeafStates_43e2 createLeafStates_43e2;
	createLeafStates_43e2( states_43e3, programs_43e5, states_43e7, programs_43e8);
	if( ( !states_43e7.empty())&& ( !programs_43e8.empty()))
		callCreateFuncStates_psuedo_448d( states_43e7, programs_43e8);
}

void CreateStateLabels_4275::callCreateFuncStates_psuedo_448d( const Packets_t& states_427f, const Packets_t& programs_4281)
{
	Packets_t states_4283;
	Packets_t programs_4284;
	CreateFuncStates_psuedo_427e createFuncStates_psuedo_427e;
	createFuncStates_psuedo_427e( states_427f, programs_4281, states_4283, programs_4284);
}

void CreateFuncStates_psuedo_427e::operator()( const Packets_t& states_427f, const Packets_t& programs_4281, Packets_t& states_4283, Packets_t& programs_4284)
{
#ifdef PRINT_INFO
	printLog( "CreateFuncStates_psuedo_427e" );
#endif
	_state_4285= &states_4283;
	_program_4286= &programs_4284;
	if( ( !states_427f.empty())&& ( !programs_4281.empty()))
		callIsFuncState_4384( states_427f, programs_4281);
	_state_4285->insert( _state_4285->end(), states_427f.begin(), states_427f.end());
	_program_4286->insert( _program_4286->end(), programs_4281.begin(), programs_4281.end());
}

void CreateFuncStates_psuedo_427e::callIsFuncState_4384( const Packets_t& states_4288, const Packets_t& programs_428a)
{
	Packets_t states_428c;
	Packets_t programs_428d;
	Packets_t states_428e;
	Packets_t programs_428f;
	IsFuncState_4287 isFuncState_4287;
	isFuncState_4287( states_4288, programs_428a, states_428c, programs_428d, states_428e, programs_428f);
	if( ( !states_428c.empty())&& ( !programs_428d.empty()))
		callGetSubStates_4387( states_428c, programs_428d);
	if( ( !states_428e.empty())&& ( !programs_428f.empty()))
		callCreateStateLabel_438a( states_428e, programs_428f);
}

void CreateFuncStates_psuedo_427e::callGetSubStates_4387( const Packets_t& sFStates_4223, const Packets_t& parStmnts_4226)
{
	Packets_t sFSubStates_4225;
	Packets_t parStmnts_4228;
	GetSubStates_4222 getSubStates_4222;
	getSubStates_4222( sFStates_4223, parStmnts_4226, sFSubStates_4225, parStmnts_4228);
	if( ( !sFSubStates_4225.empty())&& ( !parStmnts_4228.empty()))
		callIsFuncState_4384( sFSubStates_4225, parStmnts_4228);
}

void CreateFuncStates_psuedo_427e::callCreateStateLabel_438a( const Packets_t& states_42f6, const Packets_t& programs_42f8)
{
	Packets_t states_42fa;
	Packets_t programs_42fb;
	CreateStateLabel_42f5 createStateLabel_42f5;
	createStateLabel_42f5( states_42f6, programs_42f8, states_42fa, programs_42fb);
	if( ( !states_42fa.empty())&& ( !programs_42fb.empty()))
		callGetSubStates_4387( states_42fa, programs_42fb);
}

void IsFuncState_4287::operator()( const Packets_t& states_4288, const Packets_t& programs_428a, Packets_t& states_428c, Packets_t& programs_428d, Packets_t& states_428e, Packets_t& programs_428f)
{
#ifdef PRINT_INFO
	printLog( "IsFuncState_4287" );
#endif
	_state_4290= &states_428c;
	_program_4291= &programs_428d;
	_state_4292= &states_428e;
	_program_4293= &programs_428f;
	for( Packets_t::const_iterator itstate_4295= states_4288.begin(), itprogram_429c= programs_428a.begin(); itstate_4295!= states_4288.end(), itprogram_429c!= programs_428a.end(); ++itstate_4295, ++itprogram_429c)
	{
		bool isUnique= isInputUnique( *itstate_4295, *itprogram_429c);
		if( !isUnique)
			continue;
		Packets_t onestate_4299( 1, *itstate_4295);
		Packets_t oneprogram_42a0( 1, *itprogram_429c);
		executeOne( onestate_4299, oneprogram_42a0);
	}
}

void IsFuncState_4287::executeOne( const Packets_t& states_4288, const Packets_t& programs_428a)
{
	Packets_t sFStates_42a5;
	Packets_t programs_42a8;
	HasSubstates_42a2 hasSubstates_42a2;
	bool isMatchHasSubstates_42a2= hasSubstates_42a2( states_4288, programs_428a, sFStates_42a5, programs_42a8);
	_state_4290->insert( _state_4290->end(), sFStates_42a5.begin(), sFStates_42a5.end());
	_program_4291->insert( _program_4291->end(), programs_42a8.begin(), programs_42a8.end());
	if( isMatchHasSubstates_42a2)
		return;
	Packets_t sFStates_42d1;
	Packets_t programs_42d4;
	Otherwise_42ce otherwise_42ce;
	bool isMatchOtherwise_42ce= otherwise_42ce( states_4288, programs_428a, sFStates_42d1, programs_42d4);
	_state_4292->insert( _state_4292->end(), sFStates_42d1.begin(), sFStates_42d1.end());
	_program_4293->insert( _program_4293->end(), programs_42d4.begin(), programs_42d4.end());
}

bool IsFuncState_4287::isInputUnique( const Udm::Object& state_4296, const Udm::Object& program_429d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_4298= _state_4294.begin(), itprogram_429f= _program_429b.begin(); itstate_4298!= _state_4294.end(), itprogram_429f!= _program_429b.end(); ++itstate_4298, ++itprogram_429f)
	{
		if( ( *itstate_4298== state_4296)&& ( *itprogram_429f== program_429d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_4294.push_back( state_4296);
		_program_429b.push_back( program_429d);
	}
	return isUnique;
}

bool HasSubstates_42a2::operator()( const Packets_t& sFStates_42a3, const Packets_t& programs_42a6, Packets_t& sFStates_42a5, Packets_t& programs_42a8)
{
#ifdef PRINT_INFO
	printLog( "HasSubstates_42a2" );
#endif
	_sFState_42a9= &sFStates_42a5;
	_program_42aa= &programs_42a8;
	processInputPackets( sFStates_42a3, programs_42a6);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasSubstates_42a2::isInputUnique( const Udm::Object& sFState_42af, const Udm::Object& program_42b8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_42b1= _sFState_42ab.begin(), itProgram_42ba= _program_42b4.begin(); itSFState_42b1!= _sFState_42ab.end(), itProgram_42ba!= _program_42b4.end(); ++itSFState_42b1, ++itProgram_42ba)
	{
		if( ( *itSFState_42b1== sFState_42af)&& ( *itProgram_42ba== program_42b8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_42ab.push_back( sFState_42af);
		_program_42b4.push_back( program_42b8);
	}
	return isUnique;
}

bool HasSubstates_42a2::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool HasSubstates_42a2::isGuardTrue( SFC::Program& Program, CyberComposition::Simulink::SFState& SFState, CyberComposition::Simulink::SFState& SFSubState)
{
	bool Gz_guard= false;
	Gz_guard  = static_cast< std::string >( SFState.Decomposition() ) != "FUNC_STATE";;
	return Gz_guard;
}

void HasSubstates_42a2::processInputPackets( const Packets_t& sFStates_42a3, const Packets_t& programs_42a6)
{
	for( Packets_t::const_iterator itSFState_42ac= sFStates_42a3.begin(), itProgram_42b5= programs_42a6.begin(); itSFState_42ac!= sFStates_42a3.end(), itProgram_42b5!= programs_42a6.end(); ++itSFState_42ac, ++itProgram_42b5)
	{
		bool isUnique= isInputUnique( *itSFState_42ac, *itProgram_42b5);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_42ac, *itProgram_42b5);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_42c4, currMatch.program_42c5);
	}
}

bool HasSubstates_42a2::patternMatcher( const Udm::Object& sFState_42ad, const Udm::Object& program_42b6)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_42ad.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_42b2= CyberComposition::Simulink::SFState::Cast( sFState_42ad);
		if( false== Uml::IsDerivedFrom( program_42b6.type(), SFC::Program::meta))
			continue;
		SFC::Program program_42bb= SFC::Program::Cast( program_42b6);
		set< CyberComposition::Simulink::SFState> sFSubStates_42bd= sFState_42b2.SFState_kind_children();
		for( set< CyberComposition::Simulink::SFState>::const_iterator itSFSubState_42be= sFSubStates_42bd.begin(); itSFSubState_42be!= sFSubStates_42bd.end(); ++itSFSubState_42be)
		{
			CyberComposition::Simulink::SFState currSFSubState_42bf= *itSFSubState_42be;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_42c3;
			if( !isValidBound(boundObjs_42c3, sFState_42b2, true))
				continue;
			currMatch.sFState_42c4= sFState_42b2;
			if( !isValidBound(boundObjs_42c3, program_42bb, true))
				continue;
			currMatch.program_42c5= program_42bb;
			if( !isValidBound(boundObjs_42c3, currSFSubState_42bf, false))
				continue;
			currMatch.sFSubState_42c6= currSFSubState_42bf;
			bool Gz_guard= isGuardTrue( currMatch.program_42c5, currMatch.sFState_42c4, currMatch.sFSubState_42c6);
			if( true== Gz_guard)
			{
				_matches.push_back( currMatch);
				return true;
			}
		}
	}
	return !_matches.empty();
}

void HasSubstates_42a2::outputAppender( const CyberComposition::Simulink::SFState& sFState_42ca, const SFC::Program& program_42cc)
{
	_sFState_42a9->push_back( sFState_42ca);
	_program_42aa->push_back( program_42cc);
}

bool Otherwise_42ce::operator()( const Packets_t& sFStates_42cf, const Packets_t& programs_42d2, Packets_t& sFStates_42d1, Packets_t& programs_42d4)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_42ce" );
#endif
	_sFState_42d5= &sFStates_42d1;
	_program_42d6= &programs_42d4;
	processInputPackets( sFStates_42cf, programs_42d2);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_42ce::isInputUnique( const Udm::Object& sFState_42db, const Udm::Object& program_42e4)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_42dd= _sFState_42d7.begin(), itProgram_42e6= _program_42e0.begin(); itSFState_42dd!= _sFState_42d7.end(), itProgram_42e6!= _program_42e0.end(); ++itSFState_42dd, ++itProgram_42e6)
	{
		if( ( *itSFState_42dd== sFState_42db)&& ( *itProgram_42e6== program_42e4))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_42d7.push_back( sFState_42db);
		_program_42e0.push_back( program_42e4);
	}
	return isUnique;
}

bool Otherwise_42ce::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool Otherwise_42ce::isGuardTrue( SFC::Program& Program, CyberComposition::Simulink::SFState& SFState)
{
	bool Gz_guard= false;
	string s = SFState.Decomposition();
Gz_guard = ( s.compare("FUNC_STATE") == 0 );;
	return Gz_guard;
}

void Otherwise_42ce::processInputPackets( const Packets_t& sFStates_42cf, const Packets_t& programs_42d2)
{
	for( Packets_t::const_iterator itSFState_42d8= sFStates_42cf.begin(), itProgram_42e1= programs_42d2.begin(); itSFState_42d8!= sFStates_42cf.end(), itProgram_42e1!= programs_42d2.end(); ++itSFState_42d8, ++itProgram_42e1)
	{
		bool isUnique= isInputUnique( *itSFState_42d8, *itProgram_42e1);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_42d8, *itProgram_42e1);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_42ed, currMatch.program_42ee);
	}
}

bool Otherwise_42ce::patternMatcher( const Udm::Object& sFState_42d9, const Udm::Object& program_42e2)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_42d9.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_42de= CyberComposition::Simulink::SFState::Cast( sFState_42d9);
		if( false== Uml::IsDerivedFrom( program_42e2.type(), SFC::Program::meta))
			continue;
		SFC::Program program_42e7= SFC::Program::Cast( program_42e2);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_42ec;
		if( !isValidBound(boundObjs_42ec, sFState_42de, true))
			continue;
		currMatch.sFState_42ed= sFState_42de;
		if( !isValidBound(boundObjs_42ec, program_42e7, true))
			continue;
		currMatch.program_42ee= program_42e7;
		bool Gz_guard= isGuardTrue( currMatch.program_42ee, currMatch.sFState_42ed);
		if( true== Gz_guard)
		{
			_matches.push_back( currMatch);
			return true;
		}
	}
	return !_matches.empty();
}

void Otherwise_42ce::outputAppender( const CyberComposition::Simulink::SFState& sFState_42f1, const SFC::Program& program_42f3)
{
	_sFState_42d5->push_back( sFState_42f1);
	_program_42d6->push_back( program_42f3);
}

void CreateStateLabel_42f5::operator()( const Packets_t& states_42f6, const Packets_t& programs_42f8, Packets_t& states_42fa, Packets_t& programs_42fb)
{
#ifdef PRINT_INFO
	printLog( "CreateStateLabel_42f5" );
#endif
	_state_42fc= &states_42fa;
	_program_42fd= &programs_42fb;
	if( ( !states_42f6.empty())&& ( !programs_42f8.empty()))
		callCreate_437b( states_42f6, programs_42f8);
	_state_42fc->insert( _state_42fc->end(), states_42f6.begin(), states_42f6.end());
	_program_42fd->insert( _program_42fd->end(), programs_42f8.begin(), programs_42f8.end());
}

void CreateStateLabel_42f5::callCreate_437b( const Packets_t& sFStates_4327, const Packets_t& programs_432a)
{
	Packets_t sFStates_4329;
	Packets_t stateLabels_432c;
	Create_4326 create_4326;
	create_4326( sFStates_4327, programs_432a, sFStates_4329, stateLabels_432c);
	if( ( !sFStates_4329.empty())&& ( !stateLabels_432c.empty()))
		callInitMask_437e( sFStates_4329, stateLabels_432c);
}

void CreateStateLabel_42f5::callInitMask_437e( const Packets_t& sFStates_434d, const Packets_t& stateLabels_4350)
{
	Packets_t sFStates_434f;
	Packets_t stateLabels_4352;
	InitMask_434c initMask_434c;
	initMask_434c( sFStates_434d, stateLabels_4350, sFStates_434f, stateLabels_4352);
	if( ( !sFStates_434f.empty())&& ( !stateLabels_4352.empty()))
		callSetPath_4381( sFStates_434f, stateLabels_4352);
}

void CreateStateLabel_42f5::callSetPath_4381( const Packets_t& sFStates_42ff, const Packets_t& stateLabels_4302)
{
	Packets_t sFSuperStates_4301;
	Packets_t stateLabels_4304;
	SetPath_42fe setPath_42fe;
	setPath_42fe( sFStates_42ff, stateLabels_4302, sFSuperStates_4301, stateLabels_4304);
	if( ( !sFSuperStates_4301.empty())&& ( !stateLabels_4304.empty()))
		callSetPath_4381( sFSuperStates_4301, stateLabels_4304);
}

void SetPath_42fe::operator()( const Packets_t& sFStates_42ff, const Packets_t& stateLabels_4302, Packets_t& sFSuperStates_4301, Packets_t& stateLabels_4304)
{
#ifdef PRINT_INFO
	printLog( "SetPath_42fe" );
#endif
	RTTGenerator::Instance()->generateRule(3630, "SetPath");
	_sFSuperState_4305= &sFSuperStates_4301;
	_stateLabel_4306= &stateLabels_4304;
	processInputPackets( sFStates_42ff, stateLabels_4302);
}

bool SetPath_42fe::isInputUnique( const Udm::Object& sFState_430b, const Udm::Object& stateLabel_4314)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_430d= _sFState_4307.begin(), itStateLabel_4316= _stateLabel_4310.begin(); itSFState_430d!= _sFState_4307.end(), itStateLabel_4316!= _stateLabel_4310.end(); ++itSFState_430d, ++itStateLabel_4316)
	{
		if( ( *itSFState_430d== sFState_430b)&& ( *itStateLabel_4316== stateLabel_4314))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4307.push_back( sFState_430b);
		_stateLabel_4310.push_back( stateLabel_4314);
	}
	return isUnique;
}

bool SetPath_42fe::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void SetPath_42fe::processInputPackets( const Packets_t& sFStates_42ff, const Packets_t& stateLabels_4302)
{
	for( Packets_t::const_iterator itSFState_4308= sFStates_42ff.begin(), itStateLabel_4311= stateLabels_4302.begin(); itSFState_4308!= sFStates_42ff.end(), itStateLabel_4311!= stateLabels_4302.end(); ++itSFState_4308, ++itStateLabel_4311)
	{
		bool isUnique= isInputUnique( *itSFState_4308, *itStateLabel_4311);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4308, *itStateLabel_4311);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool SetPath_42fe::patternMatcher( const Udm::Object& sFState_4309, const Udm::Object& stateLabel_4312)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4309.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_430e= CyberComposition::Simulink::SFState::Cast( sFState_4309);
		if( false== Uml::IsDerivedFrom( stateLabel_4312.type(), SFC::StateLabel::meta))
			continue;
		SFC::StateLabel stateLabel_4317= SFC::StateLabel::Cast( stateLabel_4312);
		Udm::Object sFStateParent_4319= sFState_430e.container();
		if( false== Uml::IsDerivedFrom( sFStateParent_4319.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFSuperStateSFState_431a= CyberComposition::Simulink::SFState::Cast( sFStateParent_4319);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_431e;
		if( !isValidBound(boundObjs_431e, sFState_430e, true))
			continue;
		currMatch.sFState_431f= sFState_430e;
		if( !isValidBound(boundObjs_431e, stateLabel_4317, true))
			continue;
		currMatch.stateLabel_4320= stateLabel_4317;
		if( !isValidBound(boundObjs_431e, sFSuperStateSFState_431a, false))
			continue;
		currMatch.sFSuperState_4321= sFSuperStateSFState_431a;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void SetPath_42fe::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_431f;
		CyberComposition::Simulink::SFState& SFSuperState= currMatch.sFSuperState_4321;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_4320;
		{
StateLabel.comment() =
 static_cast< std::string >( SFSuperState.name() ) + "/" +
 static_cast< std::string >( StateLabel.comment() );
};
		outputAppender( currMatch.sFSuperState_4321, currMatch.stateLabel_4320);
	}
}

void SetPath_42fe::outputAppender( const CyberComposition::Simulink::SFState& sFSuperState_4322, const SFC::StateLabel& stateLabel_4324)
{
	_sFSuperState_4305->push_back( sFSuperState_4322);
	_stateLabel_4306->push_back( stateLabel_4324);
}

void Create_4326::operator()( const Packets_t& sFStates_4327, const Packets_t& programs_432a, Packets_t& sFStates_4329, Packets_t& stateLabels_432c)
{
#ifdef PRINT_INFO
	printLog( "Create_4326" );
#endif
	RTTGenerator::Instance()->generateRule(3636, "Create");
	_sFState_432d= &sFStates_4329;
	_stateLabel_432e= &stateLabels_432c;
	processInputPackets( sFStates_4327, programs_432a);
}

bool Create_4326::isInputUnique( const Udm::Object& sFState_4333, const Udm::Object& program_433c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4335= _sFState_432f.begin(), itProgram_433e= _program_4338.begin(); itSFState_4335!= _sFState_432f.end(), itProgram_433e!= _program_4338.end(); ++itSFState_4335, ++itProgram_433e)
	{
		if( ( *itSFState_4335== sFState_4333)&& ( *itProgram_433e== program_433c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_432f.push_back( sFState_4333);
		_program_4338.push_back( program_433c);
	}
	return isUnique;
}

bool Create_4326::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Create_4326::processInputPackets( const Packets_t& sFStates_4327, const Packets_t& programs_432a)
{
	for( Packets_t::const_iterator itSFState_4330= sFStates_4327.begin(), itProgram_4339= programs_432a.begin(); itSFState_4330!= sFStates_4327.end(), itProgram_4339!= programs_432a.end(); ++itSFState_4330, ++itProgram_4339)
	{
		bool isUnique= isInputUnique( *itSFState_4330, *itProgram_4339);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4330, *itProgram_4339);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool Create_4326::patternMatcher( const Udm::Object& sFState_4331, const Udm::Object& program_433a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4331.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4336= CyberComposition::Simulink::SFState::Cast( sFState_4331);
		if( false== Uml::IsDerivedFrom( program_433a.type(), SFC::Program::meta))
			continue;
		SFC::Program program_433f= SFC::Program::Cast( program_433a);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4344;
		if( !isValidBound(boundObjs_4344, sFState_4336, true))
			continue;
		currMatch.sFState_4345= sFState_4336;
		if( !isValidBound(boundObjs_4344, program_433f, true))
			continue;
		currMatch.program_4346= program_433f;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Create_4326::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::StateLabel newStateLabel_4347= SFC::StateLabel::Create( currMatch.program_4346);
		SFC::Program& Program= currMatch.program_4346;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_4345;
		SFC::StateLabel& StateLabel= newStateLabel_4347;
		{
StateLabel.RefId() = SFState.RefId();
};
		{
std::string name = SFState.name();

StateLabel.comment() = name;

__int64 stateCount = Program.stateCount();
std::string nameUC = SFUtils::convertToCPlusPlusName(   std::string(  _strupr( (char *)name.c_str() )  )   ) + boost::lexical_cast< std::string >( stateCount );

StateLabel.name() = nameUC;
StateLabel.value() = stateCount++;
Program.stateCount() = stateCount;

StateLabel.dt() = SFCTypesManager::getSingleton().getBasicType( "int" );
};
		{
__int64 statementCount = Program.statementCount();
StateLabel.statementIndex() = statementCount++;
Program.statementCount() = statementCount;
};
		newStateLabel_4347.SFdst()+= currMatch.sFState_4345;
		outputAppender( currMatch.sFState_4345, newStateLabel_4347);
	}
}

void Create_4326::outputAppender( const CyberComposition::Simulink::SFState& sFState_4348, const SFC::StateLabel& stateLabel_434a)
{
	_sFState_432d->push_back( sFState_4348);
	_stateLabel_432e->push_back( stateLabel_434a);
}

void InitMask_434c::operator()( const Packets_t& sFStates_434d, const Packets_t& stateLabels_4350, Packets_t& sFStates_434f, Packets_t& stateLabels_4352)
{
#ifdef PRINT_INFO
	printLog( "InitMask_434c" );
#endif
	RTTGenerator::Instance()->generateRule(3645, "InitMask");
	_sFState_4353= &sFStates_434f;
	_stateLabel_4354= &stateLabels_4352;
	processInputPackets( sFStates_434d, stateLabels_4350);
	forwardInputs( );
}

bool InitMask_434c::isInputUnique( const Udm::Object& sFState_4359, const Udm::Object& stateLabel_4362)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_435b= _sFState_4355.begin(), itStateLabel_4364= _stateLabel_435e.begin(); itSFState_435b!= _sFState_4355.end(), itStateLabel_4364!= _stateLabel_435e.end(); ++itSFState_435b, ++itStateLabel_4364)
	{
		if( ( *itSFState_435b== sFState_4359)&& ( *itStateLabel_4364== stateLabel_4362))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4355.push_back( sFState_4359);
		_stateLabel_435e.push_back( stateLabel_4362);
	}
	return isUnique;
}

bool InitMask_434c::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool InitMask_434c::isGuardTrue( CyberComposition::Simulink::SFState& SFState, CyberComposition::Simulink::SFState& SFSuperState, SFC::StateLabel& StateLabel, SFC::StateLabel& SuperStateLabel)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( SFState.Decomposition() ) == "AND_STATE";;
	return Gz_guard;
}

void InitMask_434c::processInputPackets( const Packets_t& sFStates_434d, const Packets_t& stateLabels_4350)
{
	for( Packets_t::const_iterator itSFState_4356= sFStates_434d.begin(), itStateLabel_435f= stateLabels_4350.begin(); itSFState_4356!= sFStates_434d.end(), itStateLabel_435f!= stateLabels_4350.end(); ++itSFState_4356, ++itStateLabel_435f)
	{
		bool isUnique= isInputUnique( *itSFState_4356, *itStateLabel_435f);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4356, *itStateLabel_435f);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InitMask_434c::patternMatcher( const Udm::Object& sFState_4357, const Udm::Object& stateLabel_4360)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4357.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_435c= CyberComposition::Simulink::SFState::Cast( sFState_4357);
		if( false== Uml::IsDerivedFrom( stateLabel_4360.type(), SFC::StateLabel::meta))
			continue;
		SFC::StateLabel stateLabel_4365= SFC::StateLabel::Cast( stateLabel_4360);
		set< CyberComposition::Simulink::SFState> sFStates_4367= stateLabel_4365.SFdst();
		for( set< CyberComposition::Simulink::SFState>::const_iterator itSFStates_4368= sFStates_4367.begin(); itSFStates_4368!= sFStates_4367.end(); ++itSFStates_4368)
		{
			CyberComposition::Simulink::SFState currSFState_4369= *itSFStates_4368;
			if( sFState_435c!= currSFState_4369)
				continue;
			Udm::Object sFStateParent_436a= sFState_435c.container();
			if( false== Uml::IsDerivedFrom( sFStateParent_436a.type(), CyberComposition::Simulink::SFState::meta))
				continue;
			CyberComposition::Simulink::SFState sFSuperStateSFState_436b= CyberComposition::Simulink::SFState::Cast( sFStateParent_436a);
			set< SFC::StateLabel> superStateLabels_436c= sFSuperStateSFState_436b.src();
			for( set< SFC::StateLabel>::const_iterator itSuperStateLabels_436d= superStateLabels_436c.begin(); itSuperStateLabels_436d!= superStateLabels_436c.end(); ++itSuperStateLabels_436d)
			{
				SFC::StateLabel currSuperStateLabel_436e= *itSuperStateLabels_436d;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_4372;
				if( !isValidBound(boundObjs_4372, sFState_435c, true))
					continue;
				currMatch.sFState_4373= sFState_435c;
				if( !isValidBound(boundObjs_4372, stateLabel_4365, true))
					continue;
				currMatch.stateLabel_4374= stateLabel_4365;
				if( !isValidBound(boundObjs_4372, sFSuperStateSFState_436b, false))
					continue;
				currMatch.sFSuperState_4375= sFSuperStateSFState_436b;
				if( !isValidBound(boundObjs_4372, currSuperStateLabel_436e, false))
					continue;
				currMatch.superStateLabel_4376= currSuperStateLabel_436e;
				bool Gz_guard= isGuardTrue( currMatch.sFState_4373, currMatch.sFSuperState_4375, currMatch.stateLabel_4374, currMatch.superStateLabel_4376);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void InitMask_434c::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_4373;
		CyberComposition::Simulink::SFState& SFSuperState= currMatch.sFSuperState_4375;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_4374;
		SFC::StateLabel& SuperStateLabel= currMatch.superStateLabel_4376;
		{
__int64 ss = SuperStateLabel.andSS();
__int64 sl = StateLabel.value();

sl = (1LL << (ss + 16)) | (sl & 0xffff);

StateLabel.value() = sl;
SuperStateLabel.andSS() = ++ss;
};
	}
}

void InitMask_434c::forwardInputs()
{
	*_sFState_4353= _sFState_4355;
	*_stateLabel_4354= _stateLabel_435e;
}

void CreateCompoundStates_438d::operator()( const Packets_t& states_438e, const Packets_t& programs_4390, Packets_t& states_4392, Packets_t& programs_4393)
{
#ifdef PRINT_INFO
	printLog( "CreateCompoundStates_438d" );
#endif
	_state_4394= &states_4392;
	_program_4395= &programs_4393;
	_state_4394->insert( _state_4394->end(), states_438e.begin(), states_438e.end());
	_program_4395->insert( _program_4395->end(), programs_4390.begin(), programs_4390.end());
	if( ( !states_438e.empty())&& ( !programs_4390.empty()))
		callIsANDORGROUPCompound_43d9( states_438e, programs_4390);
}

void CreateCompoundStates_438d::callIsANDORGROUPCompound_43d9( const Packets_t& states_4397, const Packets_t& programs_4399)
{
	Packets_t states_439b;
	Packets_t programs_439c;
	IsANDORGROUPCompound_4396 isANDORGROUPCompound_4396;
	isANDORGROUPCompound_4396( states_4397, programs_4399, states_439b, programs_439c);
	if( ( !states_439b.empty())&& ( !programs_439c.empty()))
		callCreateStateLabel_43dc( states_439b, programs_439c);
}

void CreateCompoundStates_438d::callCreateStateLabel_43dc( const Packets_t& states_42f6, const Packets_t& programs_42f8)
{
	Packets_t states_42fa;
	Packets_t programs_42fb;
	CreateStateLabel_42f5 createStateLabel_42f5;
	createStateLabel_42f5( states_42f6, programs_42f8, states_42fa, programs_42fb);
	if( ( !states_42fa.empty())&& ( !programs_42fb.empty()))
		callGetSubStates_43df( states_42fa, programs_42fb);
}

void CreateCompoundStates_438d::callGetSubStates_43df( const Packets_t& sFStates_4223, const Packets_t& parStmnts_4226)
{
	Packets_t sFSubStates_4225;
	Packets_t parStmnts_4228;
	GetSubStates_4222 getSubStates_4222;
	getSubStates_4222( sFStates_4223, parStmnts_4226, sFSubStates_4225, parStmnts_4228);
	if( ( !sFSubStates_4225.empty())&& ( !parStmnts_4228.empty()))
		callIsANDORGROUPCompound_43d9( sFSubStates_4225, parStmnts_4228);
}

void IsANDORGROUPCompound_4396::operator()( const Packets_t& states_4397, const Packets_t& programs_4399, Packets_t& states_439b, Packets_t& programs_439c)
{
#ifdef PRINT_INFO
	printLog( "IsANDORGROUPCompound_4396" );
#endif
	_state_439d= &states_439b;
	_program_439e= &programs_439c;
	for( Packets_t::const_iterator itstate_43a0= states_4397.begin(), itprogram_43a7= programs_4399.begin(); itstate_43a0!= states_4397.end(), itprogram_43a7!= programs_4399.end(); ++itstate_43a0, ++itprogram_43a7)
	{
		bool isUnique= isInputUnique( *itstate_43a0, *itprogram_43a7);
		if( !isUnique)
			continue;
		Packets_t onestate_43a4( 1, *itstate_43a0);
		Packets_t oneprogram_43ab( 1, *itprogram_43a7);
		executeOne( onestate_43a4, oneprogram_43ab);
	}
}

void IsANDORGROUPCompound_4396::executeOne( const Packets_t& states_4397, const Packets_t& programs_4399)
{
	Packets_t sFStates_43b0;
	Packets_t programs_43b3;
	HasSubstates_43ad hasSubstates_43ad;
	bool isMatchHasSubstates_43ad= hasSubstates_43ad( states_4397, programs_4399, sFStates_43b0, programs_43b3);
	_state_439d->insert( _state_439d->end(), sFStates_43b0.begin(), sFStates_43b0.end());
	_program_439e->insert( _program_439e->end(), programs_43b3.begin(), programs_43b3.end());
	if( isMatchHasSubstates_43ad)
		return;
}

bool IsANDORGROUPCompound_4396::isInputUnique( const Udm::Object& state_43a1, const Udm::Object& program_43a8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_43a3= _state_439f.begin(), itprogram_43aa= _program_43a6.begin(); itstate_43a3!= _state_439f.end(), itprogram_43aa!= _program_43a6.end(); ++itstate_43a3, ++itprogram_43aa)
	{
		if( ( *itstate_43a3== state_43a1)&& ( *itprogram_43aa== program_43a8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_439f.push_back( state_43a1);
		_program_43a6.push_back( program_43a8);
	}
	return isUnique;
}

bool HasSubstates_43ad::operator()( const Packets_t& sFStates_43ae, const Packets_t& programs_43b1, Packets_t& sFStates_43b0, Packets_t& programs_43b3)
{
#ifdef PRINT_INFO
	printLog( "HasSubstates_43ad" );
#endif
	_sFState_43b4= &sFStates_43b0;
	_program_43b5= &programs_43b3;
	processInputPackets( sFStates_43ae, programs_43b1);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasSubstates_43ad::isInputUnique( const Udm::Object& sFState_43ba, const Udm::Object& program_43c3)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_43bc= _sFState_43b6.begin(), itProgram_43c5= _program_43bf.begin(); itSFState_43bc!= _sFState_43b6.end(), itProgram_43c5!= _program_43bf.end(); ++itSFState_43bc, ++itProgram_43c5)
	{
		if( ( *itSFState_43bc== sFState_43ba)&& ( *itProgram_43c5== program_43c3))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_43b6.push_back( sFState_43ba);
		_program_43bf.push_back( program_43c3);
	}
	return isUnique;
}

bool HasSubstates_43ad::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool HasSubstates_43ad::isGuardTrue( SFC::Program& Program, CyberComposition::Simulink::SFState& SFState, CyberComposition::Simulink::SFState& SFSubState)
{
	bool Gz_guard= false;
	string s = SFState.Decomposition();
Gz_guard = !( s.compare("FUNC_STATE") == 0 );;
	return Gz_guard;
}

void HasSubstates_43ad::processInputPackets( const Packets_t& sFStates_43ae, const Packets_t& programs_43b1)
{
	for( Packets_t::const_iterator itSFState_43b7= sFStates_43ae.begin(), itProgram_43c0= programs_43b1.begin(); itSFState_43b7!= sFStates_43ae.end(), itProgram_43c0!= programs_43b1.end(); ++itSFState_43b7, ++itProgram_43c0)
	{
		bool isUnique= isInputUnique( *itSFState_43b7, *itProgram_43c0);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_43b7, *itProgram_43c0);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_43cf, currMatch.program_43d0);
	}
}

bool HasSubstates_43ad::patternMatcher( const Udm::Object& sFState_43b8, const Udm::Object& program_43c1)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_43b8.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_43bd= CyberComposition::Simulink::SFState::Cast( sFState_43b8);
		if( false== Uml::IsDerivedFrom( program_43c1.type(), SFC::Program::meta))
			continue;
		SFC::Program program_43c6= SFC::Program::Cast( program_43c1);
		set< CyberComposition::Simulink::SFState> sFSubStates_43c8= sFState_43bd.SFState_kind_children();
		for( set< CyberComposition::Simulink::SFState>::const_iterator itSFSubState_43c9= sFSubStates_43c8.begin(); itSFSubState_43c9!= sFSubStates_43c8.end(); ++itSFSubState_43c9)
		{
			CyberComposition::Simulink::SFState currSFSubState_43ca= *itSFSubState_43c9;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_43ce;
			if( !isValidBound(boundObjs_43ce, sFState_43bd, true))
				continue;
			currMatch.sFState_43cf= sFState_43bd;
			if( !isValidBound(boundObjs_43ce, program_43c6, true))
				continue;
			currMatch.program_43d0= program_43c6;
			if( !isValidBound(boundObjs_43ce, currSFSubState_43ca, false))
				continue;
			currMatch.sFSubState_43d1= currSFSubState_43ca;
			bool Gz_guard= isGuardTrue( currMatch.program_43d0, currMatch.sFState_43cf, currMatch.sFSubState_43d1);
			if( true== Gz_guard)
			{
				_matches.push_back( currMatch);
				return true;
			}
		}
	}
	return !_matches.empty();
}

void HasSubstates_43ad::outputAppender( const CyberComposition::Simulink::SFState& sFState_43d5, const SFC::Program& program_43d7)
{
	_sFState_43b4->push_back( sFState_43d5);
	_program_43b5->push_back( program_43d7);
}

void CreateLeafStates_43e2::operator()( const Packets_t& states_43e3, const Packets_t& programs_43e5, Packets_t& states_43e7, Packets_t& programs_43e8)
{
#ifdef PRINT_INFO
	printLog( "CreateLeafStates_43e2" );
#endif
	_state_43e9= &states_43e7;
	_program_43ea= &programs_43e8;
	_state_43e9->insert( _state_43e9->end(), states_43e3.begin(), states_43e3.end());
	_program_43ea->insert( _program_43ea->end(), programs_43e5.begin(), programs_43e5.end());
	if( ( !states_43e3.empty())&& ( !programs_43e5.empty()))
		callIsLeaf_4459( states_43e3, programs_43e5);
}

void CreateLeafStates_43e2::callIsLeaf_4459( const Packets_t& states_43ec, const Packets_t& programs_43ee)
{
	Packets_t states_43f0;
	Packets_t programs_43f1;
	Packets_t states_43f2;
	Packets_t programs_43f3;
	IsLeaf_43eb isLeaf_43eb;
	isLeaf_43eb( states_43ec, programs_43ee, states_43f0, programs_43f1, states_43f2, programs_43f3);
	if( ( !states_43f2.empty())&& ( !programs_43f3.empty()))
		callCreateStateLabel_445c( states_43f2, programs_43f3);
	if( ( !states_43f0.empty())&& ( !programs_43f1.empty()))
		callGetSubStates_445f( states_43f0, programs_43f1);
}

void CreateLeafStates_43e2::callCreateStateLabel_445c( const Packets_t& states_42f6, const Packets_t& programs_42f8)
{
	Packets_t states_42fa;
	Packets_t programs_42fb;
	CreateStateLabel_42f5 createStateLabel_42f5;
	createStateLabel_42f5( states_42f6, programs_42f8, states_42fa, programs_42fb);
}

void CreateLeafStates_43e2::callGetSubStates_445f( const Packets_t& sFStates_4223, const Packets_t& parStmnts_4226)
{
	Packets_t sFSubStates_4225;
	Packets_t parStmnts_4228;
	GetSubStates_4222 getSubStates_4222;
	getSubStates_4222( sFStates_4223, parStmnts_4226, sFSubStates_4225, parStmnts_4228);
	if( ( !sFSubStates_4225.empty())&& ( !parStmnts_4228.empty()))
		callIsLeaf_4459( sFSubStates_4225, parStmnts_4228);
}

void IsLeaf_43eb::operator()( const Packets_t& states_43ec, const Packets_t& programs_43ee, Packets_t& states_43f0, Packets_t& programs_43f1, Packets_t& states_43f2, Packets_t& programs_43f3)
{
#ifdef PRINT_INFO
	printLog( "IsLeaf_43eb" );
#endif
	_state_43f4= &states_43f0;
	_program_43f5= &programs_43f1;
	_state_43f6= &states_43f2;
	_program_43f7= &programs_43f3;
	for( Packets_t::const_iterator itstate_43f9= states_43ec.begin(), itprogram_4400= programs_43ee.begin(); itstate_43f9!= states_43ec.end(), itprogram_4400!= programs_43ee.end(); ++itstate_43f9, ++itprogram_4400)
	{
		bool isUnique= isInputUnique( *itstate_43f9, *itprogram_4400);
		if( !isUnique)
			continue;
		Packets_t onestate_43fd( 1, *itstate_43f9);
		Packets_t oneprogram_4404( 1, *itprogram_4400);
		executeOne( onestate_43fd, oneprogram_4404);
	}
}

void IsLeaf_43eb::executeOne( const Packets_t& states_43ec, const Packets_t& programs_43ee)
{
	Packets_t sFStates_4409;
	Packets_t programs_440c;
	HasSubstates_4406 hasSubstates_4406;
	bool isMatchHasSubstates_4406= hasSubstates_4406( states_43ec, programs_43ee, sFStates_4409, programs_440c);
	_state_43f4->insert( _state_43f4->end(), sFStates_4409.begin(), sFStates_4409.end());
	_program_43f5->insert( _program_43f5->end(), programs_440c.begin(), programs_440c.end());
	if( isMatchHasSubstates_4406)
		return;
	Packets_t sFStates_4435;
	Packets_t programs_4438;
	Otherwise_4432 otherwise_4432;
	bool isMatchOtherwise_4432= otherwise_4432( states_43ec, programs_43ee, sFStates_4435, programs_4438);
	_state_43f6->insert( _state_43f6->end(), sFStates_4435.begin(), sFStates_4435.end());
	_program_43f7->insert( _program_43f7->end(), programs_4438.begin(), programs_4438.end());
}

bool IsLeaf_43eb::isInputUnique( const Udm::Object& state_43fa, const Udm::Object& program_4401)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_43fc= _state_43f8.begin(), itprogram_4403= _program_43ff.begin(); itstate_43fc!= _state_43f8.end(), itprogram_4403!= _program_43ff.end(); ++itstate_43fc, ++itprogram_4403)
	{
		if( ( *itstate_43fc== state_43fa)&& ( *itprogram_4403== program_4401))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_43f8.push_back( state_43fa);
		_program_43ff.push_back( program_4401);
	}
	return isUnique;
}

bool HasSubstates_4406::operator()( const Packets_t& sFStates_4407, const Packets_t& programs_440a, Packets_t& sFStates_4409, Packets_t& programs_440c)
{
#ifdef PRINT_INFO
	printLog( "HasSubstates_4406" );
#endif
	_sFState_440d= &sFStates_4409;
	_program_440e= &programs_440c;
	processInputPackets( sFStates_4407, programs_440a);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasSubstates_4406::isInputUnique( const Udm::Object& sFState_4413, const Udm::Object& program_441c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4415= _sFState_440f.begin(), itProgram_441e= _program_4418.begin(); itSFState_4415!= _sFState_440f.end(), itProgram_441e!= _program_4418.end(); ++itSFState_4415, ++itProgram_441e)
	{
		if( ( *itSFState_4415== sFState_4413)&& ( *itProgram_441e== program_441c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_440f.push_back( sFState_4413);
		_program_4418.push_back( program_441c);
	}
	return isUnique;
}

bool HasSubstates_4406::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool HasSubstates_4406::isGuardTrue( SFC::Program& Program, CyberComposition::Simulink::SFState& SFState, CyberComposition::Simulink::SFState& SFSubState)
{
	bool Gz_guard= false;
	string s;
SFState.GetStrValue("Decomposition", s);
Gz_guard = !( s.compare("FUNC_STATE") == 0 );;
	return Gz_guard;
}

void HasSubstates_4406::processInputPackets( const Packets_t& sFStates_4407, const Packets_t& programs_440a)
{
	for( Packets_t::const_iterator itSFState_4410= sFStates_4407.begin(), itProgram_4419= programs_440a.begin(); itSFState_4410!= sFStates_4407.end(), itProgram_4419!= programs_440a.end(); ++itSFState_4410, ++itProgram_4419)
	{
		bool isUnique= isInputUnique( *itSFState_4410, *itProgram_4419);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4410, *itProgram_4419);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4428, currMatch.program_4429);
	}
}

bool HasSubstates_4406::patternMatcher( const Udm::Object& sFState_4411, const Udm::Object& program_441a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4411.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4416= CyberComposition::Simulink::SFState::Cast( sFState_4411);
		if( false== Uml::IsDerivedFrom( program_441a.type(), SFC::Program::meta))
			continue;
		SFC::Program program_441f= SFC::Program::Cast( program_441a);
		set< CyberComposition::Simulink::SFState> sFSubStates_4421= sFState_4416.SFState_kind_children();
		for( set< CyberComposition::Simulink::SFState>::const_iterator itSFSubState_4422= sFSubStates_4421.begin(); itSFSubState_4422!= sFSubStates_4421.end(); ++itSFSubState_4422)
		{
			CyberComposition::Simulink::SFState currSFSubState_4423= *itSFSubState_4422;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_4427;
			if( !isValidBound(boundObjs_4427, sFState_4416, true))
				continue;
			currMatch.sFState_4428= sFState_4416;
			if( !isValidBound(boundObjs_4427, program_441f, true))
				continue;
			currMatch.program_4429= program_441f;
			if( !isValidBound(boundObjs_4427, currSFSubState_4423, false))
				continue;
			currMatch.sFSubState_442a= currSFSubState_4423;
			bool Gz_guard= isGuardTrue( currMatch.program_4429, currMatch.sFState_4428, currMatch.sFSubState_442a);
			if( true== Gz_guard)
			{
				_matches.push_back( currMatch);
				return true;
			}
		}
	}
	return !_matches.empty();
}

void HasSubstates_4406::outputAppender( const CyberComposition::Simulink::SFState& sFState_442e, const SFC::Program& program_4430)
{
	_sFState_440d->push_back( sFState_442e);
	_program_440e->push_back( program_4430);
}

bool Otherwise_4432::operator()( const Packets_t& sFStates_4433, const Packets_t& programs_4436, Packets_t& sFStates_4435, Packets_t& programs_4438)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_4432" );
#endif
	_sFState_4439= &sFStates_4435;
	_program_443a= &programs_4438;
	processInputPackets( sFStates_4433, programs_4436);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_4432::isInputUnique( const Udm::Object& sFState_443f, const Udm::Object& program_4448)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4441= _sFState_443b.begin(), itProgram_444a= _program_4444.begin(); itSFState_4441!= _sFState_443b.end(), itProgram_444a!= _program_4444.end(); ++itSFState_4441, ++itProgram_444a)
	{
		if( ( *itSFState_4441== sFState_443f)&& ( *itProgram_444a== program_4448))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_443b.push_back( sFState_443f);
		_program_4444.push_back( program_4448);
	}
	return isUnique;
}

bool Otherwise_4432::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool Otherwise_4432::isGuardTrue( SFC::Program& Program, CyberComposition::Simulink::SFState& SFState)
{
	bool Gz_guard= false;
	string s = SFState.Decomposition();
Gz_guard = !( s.compare("FUNC_STATE") == 0 );;
	return Gz_guard;
}

void Otherwise_4432::processInputPackets( const Packets_t& sFStates_4433, const Packets_t& programs_4436)
{
	for( Packets_t::const_iterator itSFState_443c= sFStates_4433.begin(), itProgram_4445= programs_4436.begin(); itSFState_443c!= sFStates_4433.end(), itProgram_4445!= programs_4436.end(); ++itSFState_443c, ++itProgram_4445)
	{
		bool isUnique= isInputUnique( *itSFState_443c, *itProgram_4445);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_443c, *itProgram_4445);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4451, currMatch.program_4452);
	}
}

bool Otherwise_4432::patternMatcher( const Udm::Object& sFState_443d, const Udm::Object& program_4446)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_443d.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4442= CyberComposition::Simulink::SFState::Cast( sFState_443d);
		if( false== Uml::IsDerivedFrom( program_4446.type(), SFC::Program::meta))
			continue;
		SFC::Program program_444b= SFC::Program::Cast( program_4446);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4450;
		if( !isValidBound(boundObjs_4450, sFState_4442, true))
			continue;
		currMatch.sFState_4451= sFState_4442;
		if( !isValidBound(boundObjs_4450, program_444b, true))
			continue;
		currMatch.program_4452= program_444b;
		bool Gz_guard= isGuardTrue( currMatch.program_4452, currMatch.sFState_4451);
		if( true== Gz_guard)
		{
			_matches.push_back( currMatch);
			return true;
		}
	}
	return !_matches.empty();
}

void Otherwise_4432::outputAppender( const CyberComposition::Simulink::SFState& sFState_4455, const SFC::Program& program_4457)
{
	_sFState_4439->push_back( sFState_4455);
	_program_443a->push_back( program_4457);
}

void CreateStateVar_4462::operator()( const Packets_t& sFStates_4463, const Packets_t& programs_4466, Packets_t& sFStates_4465, Packets_t& programs_4468)
{
#ifdef PRINT_INFO
	printLog( "CreateStateVar_4462" );
#endif
	RTTGenerator::Instance()->generateRule(3674, "CreateStateVar");
	_sFState_4469= &sFStates_4465;
	_program_446a= &programs_4468;
	processInputPackets( sFStates_4463, programs_4466);
	forwardInputs( );
}

bool CreateStateVar_4462::isInputUnique( const Udm::Object& sFState_446f, const Udm::Object& program_4478)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4471= _sFState_446b.begin(), itProgram_447a= _program_4474.begin(); itSFState_4471!= _sFState_446b.end(), itProgram_447a!= _program_4474.end(); ++itSFState_4471, ++itProgram_447a)
	{
		if( ( *itSFState_4471== sFState_446f)&& ( *itProgram_447a== program_4478))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_446b.push_back( sFState_446f);
		_program_4474.push_back( program_4478);
	}
	return isUnique;
}

bool CreateStateVar_4462::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateStateVar_4462::processInputPackets( const Packets_t& sFStates_4463, const Packets_t& programs_4466)
{
	for( Packets_t::const_iterator itSFState_446c= sFStates_4463.begin(), itProgram_4475= programs_4466.begin(); itSFState_446c!= sFStates_4463.end(), itProgram_4475!= programs_4466.end(); ++itSFState_446c, ++itProgram_4475)
	{
		bool isUnique= isInputUnique( *itSFState_446c, *itProgram_4475);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_446c, *itProgram_4475);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateStateVar_4462::patternMatcher( const Udm::Object& sFState_446d, const Udm::Object& program_4476)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_446d.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4472= CyberComposition::Simulink::SFState::Cast( sFState_446d);
		if( false== Uml::IsDerivedFrom( program_4476.type(), SFC::Program::meta))
			continue;
		SFC::Program program_447b= SFC::Program::Cast( program_4476);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4480;
		if( !isValidBound(boundObjs_4480, sFState_4472, true))
			continue;
		currMatch.sFState_4481= sFState_4472;
		if( !isValidBound(boundObjs_4480, program_447b, true))
			continue;
		currMatch.program_4482= program_447b;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateStateVar_4462::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::StateVar newStateVar_4483= SFC::StateVar::Create( currMatch.program_4482, SFC::Program::meta_stmnt);
		SFC::Program& Program= currMatch.program_4482;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_4481;
		SFC::StateVar& StateVar= newStateVar_4483;
		{
StateVar.RefId() = Program.RefId();
};
		{
__int64 stateCount = Program.stateCount();
StateVar.size() = stateCount;
StateVar.name() = "activeSubStates";
StateVar.dt() = SFCTypesManager::getSingleton().getBasicType( "int" );
};
		{
__int64 statementCount = Program.statementCount();
StateVar.statementIndex() = statementCount++;
Program.statementCount() = statementCount;
};
	}
}

void CreateStateVar_4462::forwardInputs()
{
	*_sFState_4469= _sFState_446b;
	*_program_446a= _program_4474;
}

void CreateDEVars_4490::operator()( const Packets_t& states_4491, const Packets_t& programs_4493, Packets_t& states_4495, Packets_t& programs_4496)
{
#ifdef PRINT_INFO
	printLog( "CreateDEVars_4490" );
#endif
	_state_4497= &states_4495;
	_program_4498= &programs_4496;
	if( ( !states_4491.empty())&& ( !programs_4493.empty()))
		callCheckStateDecomp_4824( states_4491, programs_4493);
	_state_4497->insert( _state_4497->end(), states_4491.begin(), states_4491.end());
	_program_4498->insert( _program_4498->end(), programs_4493.begin(), programs_4493.end());
}

void CreateDEVars_4490::callCheckStateDecomp_4824( const Packets_t& states_47be, const Packets_t& programs_47c0)
{
	Packets_t states_47c2;
	Packets_t programs_47c3;
	Packets_t states_47c4;
	Packets_t programs_47c5;
	CheckStateDecomp_47bd checkStateDecomp_47bd;
	checkStateDecomp_47bd( states_47be, programs_47c0, states_47c2, programs_47c3, states_47c4, programs_47c5);
	if( ( !states_47c2.empty())&& ( !programs_47c3.empty()))
		callGetSubStates_4827( states_47c2, programs_47c3);
	if( ( !states_47c4.empty())&& ( !programs_47c5.empty()))
		callCreateDataVar_482a( states_47c4, programs_47c5);
}

void CreateDEVars_4490::callGetSubStates_4827( const Packets_t& sFStates_4223, const Packets_t& parStmnts_4226)
{
	Packets_t sFSubStates_4225;
	Packets_t parStmnts_4228;
	GetSubStates_4222 getSubStates_4222;
	getSubStates_4222( sFStates_4223, parStmnts_4226, sFSubStates_4225, parStmnts_4228);
	if( ( !sFSubStates_4225.empty())&& ( !parStmnts_4228.empty()))
		callCheckStateDecomp_4824( sFSubStates_4225, parStmnts_4228);
}

void CreateDEVars_4490::callCreateDataVar_482a( const Packets_t& states_449a, const Packets_t& programs_449c)
{
	Packets_t states_449e;
	Packets_t programs_449f;
	CreateDataVar_4499 createDataVar_4499;
	createDataVar_4499( states_449a, programs_449c, states_449e, programs_449f);
	if( ( !states_449e.empty())&& ( !programs_449f.empty()))
		callCreateStoreVar_482d( states_449e, programs_449f);
}

void CreateDEVars_4490::callCreateStoreVar_482d( const Packets_t& states_44db, const Packets_t& programs_44dd)
{
	Packets_t states_44df;
	Packets_t programs_44e0;
	CreateStoreVar_44da createStoreVar_44da;
	createStoreVar_44da( states_44db, programs_44dd, states_44df, programs_44e0);
	if( ( !states_44df.empty())&& ( !programs_44e0.empty()))
		callCreateEventVar_4830( states_44df, programs_44e0);
}

void CreateDEVars_4490::callCreateEventVar_4830( const Packets_t& states_4784, const Packets_t& programs_4786)
{
	Packets_t states_4788;
	Packets_t programs_4789;
	CreateEventVar_4783 createEventVar_4783;
	createEventVar_4783( states_4784, programs_4786, states_4788, programs_4789);
	if( ( !states_4788.empty())&& ( !programs_4789.empty()))
		callGetSubStates_4827( states_4788, programs_4789);
}

void CreateDataVar_4499::operator()( const Packets_t& states_449a, const Packets_t& programs_449c, Packets_t& states_449e, Packets_t& programs_449f)
{
#ifdef PRINT_INFO
	printLog( "CreateDataVar_4499" );
#endif
	_state_44a0= &states_449e;
	_program_44a1= &programs_449f;
	_state_44a0->insert( _state_44a0->end(), states_449a.begin(), states_449a.end());
	_program_44a1->insert( _program_44a1->end(), programs_449c.begin(), programs_449c.end());
	if( ( !states_449a.empty())&& ( !programs_449c.empty()))
		callCreateDataVar_44d7( states_449a, programs_449c);
}

void CreateDataVar_4499::callCreateDataVar_44d7( const Packets_t& sFStates_44a3, const Packets_t& programs_44a5)
{
	CreateDataVar_44a2 createDataVar_44a2;
	createDataVar_44a2( sFStates_44a3, programs_44a5);
}

void CreateDataVar_44a2::operator()( const Packets_t& sFStates_44a3, const Packets_t& programs_44a5)
{
#ifdef PRINT_INFO
	printLog( "CreateDataVar_44a2" );
#endif
	RTTGenerator::Instance()->generateRule(3692, "CreateDataVar");
	processInputPackets( sFStates_44a3, programs_44a5);
}

bool CreateDataVar_44a2::isInputUnique( const Udm::Object& sFState_44ab, const Udm::Object& program_44b4)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_44ad= _sFState_44a7.begin(), itProgram_44b6= _program_44b0.begin(); itSFState_44ad!= _sFState_44a7.end(), itProgram_44b6!= _program_44b0.end(); ++itSFState_44ad, ++itProgram_44b6)
	{
		if( ( *itSFState_44ad== sFState_44ab)&& ( *itProgram_44b6== program_44b4))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_44a7.push_back( sFState_44ab);
		_program_44b0.push_back( program_44b4);
	}
	return isUnique;
}

bool CreateDataVar_44a2::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool CreateDataVar_44a2::isGuardTrue( SFC::DT& DT, SFC::Program& Program, CyberComposition::Simulink::SFData& SFData, CyberComposition::Simulink::SFState& SFState, SFC::StateLabel& StateLabel, CyberComposition::Simulink::SF_TypeBase& TypeBase, CyberComposition::Simulink::TypeBaseRef& TypeBaseRef)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( SFData.Scope() ) != "STORE_DATA";;
	return Gz_guard;
}

void CreateDataVar_44a2::processInputPackets( const Packets_t& sFStates_44a3, const Packets_t& programs_44a5)
{
	for( Packets_t::const_iterator itSFState_44a8= sFStates_44a3.begin(), itProgram_44b1= programs_44a5.begin(); itSFState_44a8!= sFStates_44a3.end(), itProgram_44b1!= programs_44a5.end(); ++itSFState_44a8, ++itProgram_44b1)
	{
		bool isUnique= isInputUnique( *itSFState_44a8, *itProgram_44b1);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_44a8, *itProgram_44b1);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateDataVar_44a2::patternMatcher( const Udm::Object& sFState_44a9, const Udm::Object& program_44b2)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_44a9.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_44ae= CyberComposition::Simulink::SFState::Cast( sFState_44a9);
		if( false== Uml::IsDerivedFrom( program_44b2.type(), SFC::Program::meta))
			continue;
		SFC::Program program_44b7= SFC::Program::Cast( program_44b2);
		set< CyberComposition::Simulink::SFData> sFDatas_44b9= sFState_44ae.SFData_kind_children();
		for( set< CyberComposition::Simulink::SFData>::const_iterator itSFData_44ba= sFDatas_44b9.begin(); itSFData_44ba!= sFDatas_44b9.end(); ++itSFData_44ba)
		{
			CyberComposition::Simulink::SFData currSFData_44bb= *itSFData_44ba;
			set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_44bc= currSFData_44bb.TypeBaseRef_kind_children();
			for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_44bd= typeBaseRefs_44bc.begin(); itTypeBaseRef_44bd!= typeBaseRefs_44bc.end(); ++itTypeBaseRef_44bd)
			{
				CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_44be= *itTypeBaseRef_44bd;
				CyberComposition::Simulink::SF_TypeBase typeBase_44bf= currTypeBaseRef_44be.ref();
				if( !typeBase_44bf)
					continue;
				set< SFC::StateLabel> stateLabels_44c0= sFState_44ae.src();
				for( set< SFC::StateLabel>::const_iterator itStateLabels_44c1= stateLabels_44c0.begin(); itStateLabels_44c1!= stateLabels_44c0.end(); ++itStateLabels_44c1)
				{
					SFC::StateLabel currStateLabel_44c2= *itStateLabels_44c1;
					SFC::DT dT_44c3= typeBase_44bf.dt();
					if( !dT_44c3)
						continue;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_44c7;
					if( !isValidBound(boundObjs_44c7, sFState_44ae, true))
						continue;
					currMatch.sFState_44c8= sFState_44ae;
					if( !isValidBound(boundObjs_44c7, program_44b7, true))
						continue;
					currMatch.program_44c9= program_44b7;
					if( !isValidBound(boundObjs_44c7, currStateLabel_44c2, false))
						continue;
					currMatch.stateLabel_44ca= currStateLabel_44c2;
					if( !isValidBound(boundObjs_44c7, currSFData_44bb, false))
						continue;
					currMatch.sFData_44cb= currSFData_44bb;
					if( !isValidBound(boundObjs_44c7, currTypeBaseRef_44be, false))
						continue;
					currMatch.typeBaseRef_44cc= currTypeBaseRef_44be;
					if( !isValidBound(boundObjs_44c7, typeBase_44bf, false))
						continue;
					currMatch.typeBase_44cd= typeBase_44bf;
					if( !isValidBound(boundObjs_44c7, dT_44c3, false))
						continue;
					currMatch.dT_44ce= dT_44c3;
					bool Gz_guard= isGuardTrue( currMatch.dT_44ce, currMatch.program_44c9, currMatch.sFData_44cb, currMatch.sFState_44c8, currMatch.stateLabel_44ca, currMatch.typeBase_44cd, currMatch.typeBaseRef_44cc);
					if( true== Gz_guard)
						_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void CreateDataVar_44a2::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newLocalVar_44d6= SFC::LocalVar::Create( currMatch.program_44c9);
		SFC::DT& DT= currMatch.dT_44ce;
		SFC::LocalVar& LocalVar= newLocalVar_44d6;
		SFC::Program& Program= currMatch.program_44c9;
		CyberComposition::Simulink::SFData& SFData= currMatch.sFData_44cb;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_44c8;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_44ca;
		CyberComposition::Simulink::SF_TypeBase& TypeBase= currMatch.typeBase_44cd;
		CyberComposition::Simulink::TypeBaseRef& TypeBaseRef= currMatch.typeBaseRef_44cc;
		{
__int64 statementCount = Program.statementCount();
LocalVar.statementIndex() = statementCount++;
Program.statementCount() = statementCount;
};
		{
LocalVar.RefId() = SFData.RefId();
};
		{
std::string dataName = SFData.Name();
if(dataName.empty())
	dataName = SFData.name();
LocalVar.name() = dataName;
LocalVar.scope() = StateLabel.comment(); /* comment contains the extend state name */
LocalVar.initial() = SFData.InitialValue();
LocalVar.indexBase() = SFData.ArrayFirstIndex();

SFManager::AddTypedEntityScope( LocalVar );
};
		newLocalVar_44d6.dt()= currMatch.dT_44ce;
		newLocalVar_44d6.SFdata()+= currMatch.sFData_44cb;
	}
}

void CreateStoreVar_44da::operator()( const Packets_t& states_44db, const Packets_t& programs_44dd, Packets_t& states_44df, Packets_t& programs_44e0)
{
#ifdef PRINT_INFO
	printLog( "CreateStoreVar_44da" );
#endif
	_state_44e1= &states_44df;
	_program_44e2= &programs_44e0;
	_state_44e1->insert( _state_44e1->end(), states_44db.begin(), states_44db.end());
	_program_44e2->insert( _program_44e2->end(), programs_44dd.begin(), programs_44dd.end());
	if( ( !states_44db.empty())&& ( !programs_44dd.empty()))
		callCreateDataVar_4771( states_44db, programs_44dd);
}

void CreateStoreVar_44da::callCreateDataVar_4771( const Packets_t& sFStates_4731, const Packets_t& programs_4735)
{
	Packets_t sFStates_4733;
	Packets_t localVars_4734;
	CreateDataVar_4730 createDataVar_4730;
	createDataVar_4730( sFStates_4731, programs_4735, sFStates_4733, localVars_4734);
	if( ( !sFStates_4733.empty())&& ( !localVars_4734.empty()))
		callGetHighestState_4774( sFStates_4733, localVars_4734);
}

void CreateStoreVar_44da::callGetHighestState_4774( const Packets_t& states_44e4, const Packets_t& localVars_44e6)
{
	Packets_t states_44e8;
	Packets_t localVars_44e9;
	GetHighestState_44e3 getHighestState_44e3;
	getHighestState_44e3( states_44e4, localVars_44e6, states_44e8, localVars_44e9);
	if( ( !states_44e8.empty())&& ( !localVars_44e9.empty()))
		callGetContainingSubsystem_4777( states_44e8, localVars_44e9);
}

void CreateStoreVar_44da::callGetContainingSubsystem_4777( const Packets_t& sFStates_4709, const Packets_t& localVars_470c)
{
	Packets_t subsystems_470b;
	Packets_t localVars_470e;
	GetContainingSubsystem_4708 getContainingSubsystem_4708;
	getContainingSubsystem_4708( sFStates_4709, localVars_470c, subsystems_470b, localVars_470e);
	if( ( !subsystems_470b.empty())&& ( !localVars_470e.empty()))
		callGetStoreSubsystem_477a( subsystems_470b, localVars_470e);
}

void CreateStoreVar_44da::callGetStoreSubsystem_477a( const Packets_t& systems_4642, const Packets_t& localVars_4644)
{
	Packets_t systems_4646;
	Packets_t localVars_4647;
	GetStoreSubsystem_4641 getStoreSubsystem_4641;
	getStoreSubsystem_4641( systems_4642, localVars_4644, systems_4646, localVars_4647);
	if( ( !systems_4646.empty())&& ( !localVars_4647.empty()))
		callGetScope_477d( systems_4646, localVars_4647);
}

void CreateStoreVar_44da::callGetScope_477d( const Packets_t& systems_45a3, const Packets_t& localVars_45a5)
{
	Packets_t systems_45a7;
	Packets_t localVars_45a8;
	GetScope_45a2 getScope_45a2;
	getScope_45a2( systems_45a3, localVars_45a5, systems_45a7, localVars_45a8);
	if( ( !systems_45a7.empty())&& ( !localVars_45a8.empty()))
		callRegister_4780( systems_45a7, localVars_45a8);
}

void CreateStoreVar_44da::callRegister_4780( const Packets_t& subsystems_4586, const Packets_t& localVars_4588)
{
	Register_4585 register_4585;
	register_4585( subsystems_4586, localVars_4588);
}

void GetHighestState_44e3::operator()( const Packets_t& states_44e4, const Packets_t& localVars_44e6, Packets_t& states_44e8, Packets_t& localVars_44e9)
{
#ifdef PRINT_INFO
	printLog( "GetHighestState_44e3" );
#endif
	_state_44ea= &states_44e8;
	_localVar_44eb= &localVars_44e9;
	if( ( !states_44e4.empty())&& ( !localVars_44e6.empty()))
		callHighestStateTest_457f( states_44e4, localVars_44e6);
}

void GetHighestState_44e3::callHighestStateTest_457f( const Packets_t& states_44ed, const Packets_t& localVars_44ef)
{
	Packets_t states_44f1;
	Packets_t localVars_44f2;
	Packets_t states_44f3;
	Packets_t localVars_44f4;
	HighestStateTest_44ec highestStateTest_44ec;
	highestStateTest_44ec( states_44ed, localVars_44ef, states_44f1, localVars_44f2, states_44f3, localVars_44f4);
	if( ( !states_44f3.empty())&& ( !localVars_44f4.empty()))
		callNextHigherState_4582( states_44f3, localVars_44f4);
	_state_44ea->insert( _state_44ea->end(), states_44f1.begin(), states_44f1.end());
	_localVar_44eb->insert( _localVar_44eb->end(), localVars_44f2.begin(), localVars_44f2.end());
}

void GetHighestState_44e3::callNextHigherState_4582( const Packets_t& sFSubStates_4558, const Packets_t& localVars_455b)
{
	Packets_t sFStates_455a;
	Packets_t localVars_455d;
	NextHigherState_4557 nextHigherState_4557;
	nextHigherState_4557( sFSubStates_4558, localVars_455b, sFStates_455a, localVars_455d);
	if( ( !sFStates_455a.empty())&& ( !localVars_455d.empty()))
		callHighestStateTest_457f( sFStates_455a, localVars_455d);
}

void HighestStateTest_44ec::operator()( const Packets_t& states_44ed, const Packets_t& localVars_44ef, Packets_t& states_44f1, Packets_t& localVars_44f2, Packets_t& states_44f3, Packets_t& localVars_44f4)
{
#ifdef PRINT_INFO
	printLog( "HighestStateTest_44ec" );
#endif
	_state_44f5= &states_44f1;
	_localVar_44f6= &localVars_44f2;
	_state_44f7= &states_44f3;
	_localVar_44f8= &localVars_44f4;
	for( Packets_t::const_iterator itstate_44fa= states_44ed.begin(), itlocalVar_4501= localVars_44ef.begin(); itstate_44fa!= states_44ed.end(), itlocalVar_4501!= localVars_44ef.end(); ++itstate_44fa, ++itlocalVar_4501)
	{
		bool isUnique= isInputUnique( *itstate_44fa, *itlocalVar_4501);
		if( !isUnique)
			continue;
		Packets_t onestate_44fe( 1, *itstate_44fa);
		Packets_t onelocalVar_4505( 1, *itlocalVar_4501);
		executeOne( onestate_44fe, onelocalVar_4505);
	}
}

void HighestStateTest_44ec::executeOne( const Packets_t& states_44ed, const Packets_t& localVars_44ef)
{
	Packets_t sFSubStates_450a;
	Packets_t localVars_450d;
	HighestState_4507 highestState_4507;
	bool isMatchHighestState_4507= highestState_4507( states_44ed, localVars_44ef, sFSubStates_450a, localVars_450d);
	_state_44f5->insert( _state_44f5->end(), sFSubStates_450a.begin(), sFSubStates_450a.end());
	_localVar_44f6->insert( _localVar_44f6->end(), localVars_450d.begin(), localVars_450d.end());
	if( isMatchHighestState_4507)
		return;
	Packets_t sFStates_4535;
	Packets_t localVars_4538;
	Otherwise_4532 otherwise_4532;
	bool isMatchOtherwise_4532= otherwise_4532( states_44ed, localVars_44ef, sFStates_4535, localVars_4538);
	_state_44f7->insert( _state_44f7->end(), sFStates_4535.begin(), sFStates_4535.end());
	_localVar_44f8->insert( _localVar_44f8->end(), localVars_4538.begin(), localVars_4538.end());
	if( isMatchOtherwise_4532)
		return;
}

bool HighestStateTest_44ec::isInputUnique( const Udm::Object& state_44fb, const Udm::Object& localVar_4502)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_44fd= _state_44f9.begin(), itlocalVar_4504= _localVar_4500.begin(); itstate_44fd!= _state_44f9.end(), itlocalVar_4504!= _localVar_4500.end(); ++itstate_44fd, ++itlocalVar_4504)
	{
		if( ( *itstate_44fd== state_44fb)&& ( *itlocalVar_4504== localVar_4502))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_44f9.push_back( state_44fb);
		_localVar_4500.push_back( localVar_4502);
	}
	return isUnique;
}

bool HighestState_4507::operator()( const Packets_t& sFSubStates_4508, const Packets_t& localVars_450b, Packets_t& sFSubStates_450a, Packets_t& localVars_450d)
{
#ifdef PRINT_INFO
	printLog( "HighestState_4507" );
#endif
	_sFSubState_450e= &sFSubStates_450a;
	_localVar_450f= &localVars_450d;
	processInputPackets( sFSubStates_4508, localVars_450b);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HighestState_4507::isInputUnique( const Udm::Object& sFSubState_4514, const Udm::Object& localVar_451d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFSubState_4516= _sFSubState_4510.begin(), itLocalVar_451f= _localVar_4519.begin(); itSFSubState_4516!= _sFSubState_4510.end(), itLocalVar_451f!= _localVar_4519.end(); ++itSFSubState_4516, ++itLocalVar_451f)
	{
		if( ( *itSFSubState_4516== sFSubState_4514)&& ( *itLocalVar_451f== localVar_451d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFSubState_4510.push_back( sFSubState_4514);
		_localVar_4519.push_back( localVar_451d);
	}
	return isUnique;
}

bool HighestState_4507::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void HighestState_4507::processInputPackets( const Packets_t& sFSubStates_4508, const Packets_t& localVars_450b)
{
	for( Packets_t::const_iterator itSFSubState_4511= sFSubStates_4508.begin(), itLocalVar_451a= localVars_450b.begin(); itSFSubState_4511!= sFSubStates_4508.end(), itLocalVar_451a!= localVars_450b.end(); ++itSFSubState_4511, ++itLocalVar_451a)
	{
		bool isUnique= isInputUnique( *itSFSubState_4511, *itLocalVar_451a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFSubState_4511, *itLocalVar_451a);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFSubState_452a, currMatch.localVar_452b);
	}
}

bool HighestState_4507::patternMatcher( const Udm::Object& sFSubState_4512, const Udm::Object& localVar_451b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFSubState_4512.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFSubState_4517= CyberComposition::Simulink::SFState::Cast( sFSubState_4512);
		if( false== Uml::IsDerivedFrom( localVar_451b.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_4520= SFC::LocalVar::Cast( localVar_451b);
		Udm::Object sFSubStateParent_4522= sFSubState_4517.container();
		if( false== Uml::IsDerivedFrom( sFSubStateParent_4522.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFStateSFSubState_4523= CyberComposition::Simulink::SFState::Cast( sFSubStateParent_4522);
		Udm::Object sFStateParent_4524= sFStateSFSubState_4523.container();
		if( false== Uml::IsDerivedFrom( sFStateParent_4524.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystemSFState_4525= CyberComposition::Simulink::Subsystem::Cast( sFStateParent_4524);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4529;
		if( !isValidBound(boundObjs_4529, sFSubState_4517, true))
			continue;
		currMatch.sFSubState_452a= sFSubState_4517;
		if( !isValidBound(boundObjs_4529, localVar_4520, true))
			continue;
		currMatch.localVar_452b= localVar_4520;
		if( !isValidBound(boundObjs_4529, sFStateSFSubState_4523, false))
			continue;
		currMatch.sFState_452c= sFStateSFSubState_4523;
		if( !isValidBound(boundObjs_4529, subsystemSFState_4525, false))
			continue;
		currMatch.subsystem_452d= subsystemSFState_4525;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void HighestState_4507::outputAppender( const CyberComposition::Simulink::SFState& sFSubState_452e, const SFC::LocalVar& localVar_4530)
{
	_sFSubState_450e->push_back( sFSubState_452e);
	_localVar_450f->push_back( localVar_4530);
}

bool Otherwise_4532::operator()( const Packets_t& sFStates_4533, const Packets_t& localVars_4536, Packets_t& sFStates_4535, Packets_t& localVars_4538)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_4532" );
#endif
	_sFState_4539= &sFStates_4535;
	_localVar_453a= &localVars_4538;
	processInputPackets( sFStates_4533, localVars_4536);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_4532::isInputUnique( const Udm::Object& sFState_453f, const Udm::Object& localVar_4548)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4541= _sFState_453b.begin(), itLocalVar_454a= _localVar_4544.begin(); itSFState_4541!= _sFState_453b.end(), itLocalVar_454a!= _localVar_4544.end(); ++itSFState_4541, ++itLocalVar_454a)
	{
		if( ( *itSFState_4541== sFState_453f)&& ( *itLocalVar_454a== localVar_4548))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_453b.push_back( sFState_453f);
		_localVar_4544.push_back( localVar_4548);
	}
	return isUnique;
}

bool Otherwise_4532::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_4532::processInputPackets( const Packets_t& sFStates_4533, const Packets_t& localVars_4536)
{
	for( Packets_t::const_iterator itSFState_453c= sFStates_4533.begin(), itLocalVar_4545= localVars_4536.begin(); itSFState_453c!= sFStates_4533.end(), itLocalVar_4545!= localVars_4536.end(); ++itSFState_453c, ++itLocalVar_4545)
	{
		bool isUnique= isInputUnique( *itSFState_453c, *itLocalVar_4545);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_453c, *itLocalVar_4545);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4551, currMatch.localVar_4552);
	}
}

bool Otherwise_4532::patternMatcher( const Udm::Object& sFState_453d, const Udm::Object& localVar_4546)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_453d.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4542= CyberComposition::Simulink::SFState::Cast( sFState_453d);
		if( false== Uml::IsDerivedFrom( localVar_4546.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_454b= SFC::LocalVar::Cast( localVar_4546);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4550;
		if( !isValidBound(boundObjs_4550, sFState_4542, true))
			continue;
		currMatch.sFState_4551= sFState_4542;
		if( !isValidBound(boundObjs_4550, localVar_454b, true))
			continue;
		currMatch.localVar_4552= localVar_454b;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_4532::outputAppender( const CyberComposition::Simulink::SFState& sFState_4553, const SFC::LocalVar& localVar_4555)
{
	_sFState_4539->push_back( sFState_4553);
	_localVar_453a->push_back( localVar_4555);
}

void NextHigherState_4557::operator()( const Packets_t& sFSubStates_4558, const Packets_t& localVars_455b, Packets_t& sFStates_455a, Packets_t& localVars_455d)
{
#ifdef PRINT_INFO
	printLog( "NextHigherState_4557" );
#endif
	RTTGenerator::Instance()->generateRule(3739, "NextHigherState");
	_sFState_455e= &sFStates_455a;
	_localVar_455f= &localVars_455d;
	processInputPackets( sFSubStates_4558, localVars_455b);
}

bool NextHigherState_4557::isInputUnique( const Udm::Object& sFSubState_4564, const Udm::Object& localVar_456d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFSubState_4566= _sFSubState_4560.begin(), itLocalVar_456f= _localVar_4569.begin(); itSFSubState_4566!= _sFSubState_4560.end(), itLocalVar_456f!= _localVar_4569.end(); ++itSFSubState_4566, ++itLocalVar_456f)
	{
		if( ( *itSFSubState_4566== sFSubState_4564)&& ( *itLocalVar_456f== localVar_456d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFSubState_4560.push_back( sFSubState_4564);
		_localVar_4569.push_back( localVar_456d);
	}
	return isUnique;
}

bool NextHigherState_4557::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void NextHigherState_4557::processInputPackets( const Packets_t& sFSubStates_4558, const Packets_t& localVars_455b)
{
	for( Packets_t::const_iterator itSFSubState_4561= sFSubStates_4558.begin(), itLocalVar_456a= localVars_455b.begin(); itSFSubState_4561!= sFSubStates_4558.end(), itLocalVar_456a!= localVars_455b.end(); ++itSFSubState_4561, ++itLocalVar_456a)
	{
		bool isUnique= isInputUnique( *itSFSubState_4561, *itLocalVar_456a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFSubState_4561, *itLocalVar_456a);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool NextHigherState_4557::patternMatcher( const Udm::Object& sFSubState_4562, const Udm::Object& localVar_456b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFSubState_4562.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFSubState_4567= CyberComposition::Simulink::SFState::Cast( sFSubState_4562);
		if( false== Uml::IsDerivedFrom( localVar_456b.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_4570= SFC::LocalVar::Cast( localVar_456b);
		Udm::Object sFSubStateParent_4572= sFSubState_4567.container();
		if( false== Uml::IsDerivedFrom( sFSubStateParent_4572.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFStateSFSubState_4573= CyberComposition::Simulink::SFState::Cast( sFSubStateParent_4572);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4577;
		if( !isValidBound(boundObjs_4577, sFSubState_4567, true))
			continue;
		currMatch.sFSubState_4578= sFSubState_4567;
		if( !isValidBound(boundObjs_4577, localVar_4570, true))
			continue;
		currMatch.localVar_4579= localVar_4570;
		if( !isValidBound(boundObjs_4577, sFStateSFSubState_4573, false))
			continue;
		currMatch.sFState_457a= sFStateSFSubState_4573;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void NextHigherState_4557::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_457a, currMatch.localVar_4579);
	}
}

void NextHigherState_4557::outputAppender( const CyberComposition::Simulink::SFState& sFState_457b, const SFC::LocalVar& localVar_457d)
{
	_sFState_455e->push_back( sFState_457b);
	_localVar_455f->push_back( localVar_457d);
}

void Register_4585::operator()( const Packets_t& subsystems_4586, const Packets_t& localVars_4588)
{
#ifdef PRINT_INFO
	printLog( "Register_4585" );
#endif
	RTTGenerator::Instance()->generateRule(3744, "Register");
	processInputPackets( subsystems_4586, localVars_4588);
}

bool Register_4585::isInputUnique( const Udm::Object& subsystem_458e, const Udm::Object& localVar_4597)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_4590= _subsystem_458a.begin(), itLocalVar_4599= _localVar_4593.begin(); itSubsystem_4590!= _subsystem_458a.end(), itLocalVar_4599!= _localVar_4593.end(); ++itSubsystem_4590, ++itLocalVar_4599)
	{
		if( ( *itSubsystem_4590== subsystem_458e)&& ( *itLocalVar_4599== localVar_4597))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_458a.push_back( subsystem_458e);
		_localVar_4593.push_back( localVar_4597);
	}
	return isUnique;
}

bool Register_4585::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Register_4585::processInputPackets( const Packets_t& subsystems_4586, const Packets_t& localVars_4588)
{
	for( Packets_t::const_iterator itSubsystem_458b= subsystems_4586.begin(), itLocalVar_4594= localVars_4588.begin(); itSubsystem_458b!= subsystems_4586.end(), itLocalVar_4594!= localVars_4588.end(); ++itSubsystem_458b, ++itLocalVar_4594)
	{
		bool isUnique= isInputUnique( *itSubsystem_458b, *itLocalVar_4594);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_458b, *itLocalVar_4594);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool Register_4585::patternMatcher( const Udm::Object& subsystem_458c, const Udm::Object& localVar_4595)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_458c.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_4591= CyberComposition::Simulink::Subsystem::Cast( subsystem_458c);
		if( false== Uml::IsDerivedFrom( localVar_4595.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_459a= SFC::LocalVar::Cast( localVar_4595);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_459f;
		if( !isValidBound(boundObjs_459f, subsystem_4591, true))
			continue;
		currMatch.subsystem_45a0= subsystem_4591;
		if( !isValidBound(boundObjs_459f, localVar_459a, true))
			continue;
		currMatch.localVar_45a1= localVar_459a;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Register_4585::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar& LocalVar= currMatch.localVar_45a1;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_45a0;
		{
SFManager::AddTypedEntityScope( LocalVar );
};
	}
}

void GetScope_45a2::operator()( const Packets_t& systems_45a3, const Packets_t& localVars_45a5, Packets_t& systems_45a7, Packets_t& localVars_45a8)
{
#ifdef PRINT_INFO
	printLog( "GetScope_45a2" );
#endif
	_system_45a9= &systems_45a7;
	_localVar_45aa= &localVars_45a8;
	if( ( !systems_45a3.empty())&& ( !localVars_45a5.empty()))
		callSubSubsystemTest_463b( systems_45a3, localVars_45a5);
}

void GetScope_45a2::callSubSubsystemTest_463b( const Packets_t& systems_45d4, const Packets_t& localVars_45d6)
{
	Packets_t systems_45d8;
	Packets_t localVars_45d9;
	Packets_t systems_45da;
	Packets_t localVars_45db;
	SubSubsystemTest_45d3 subSubsystemTest_45d3;
	subSubsystemTest_45d3( systems_45d4, localVars_45d6, systems_45d8, localVars_45d9, systems_45da, localVars_45db);
	_system_45a9->insert( _system_45a9->end(), systems_45da.begin(), systems_45da.end());
	_localVar_45aa->insert( _localVar_45aa->end(), localVars_45db.begin(), localVars_45db.end());
	if( ( !systems_45d8.empty())&& ( !localVars_45d9.empty()))
		callAddToScope_463e( systems_45d8, localVars_45d9);
}

void GetScope_45a2::callAddToScope_463e( const Packets_t& subSubsystems_45ac, const Packets_t& localVars_45af)
{
	Packets_t subsystems_45ae;
	Packets_t localVars_45b1;
	AddToScope_45ab addToScope_45ab;
	addToScope_45ab( subSubsystems_45ac, localVars_45af, subsystems_45ae, localVars_45b1);
	if( ( !subsystems_45ae.empty())&& ( !localVars_45b1.empty()))
		callSubSubsystemTest_463b( subsystems_45ae, localVars_45b1);
}

void AddToScope_45ab::operator()( const Packets_t& subSubsystems_45ac, const Packets_t& localVars_45af, Packets_t& subsystems_45ae, Packets_t& localVars_45b1)
{
#ifdef PRINT_INFO
	printLog( "AddToScope_45ab" );
#endif
	RTTGenerator::Instance()->generateRule(3753, "AddToScope");
	_subsystem_45b2= &subsystems_45ae;
	_localVar_45b3= &localVars_45b1;
	processInputPackets( subSubsystems_45ac, localVars_45af);
}

bool AddToScope_45ab::isInputUnique( const Udm::Object& subSubsystem_45b8, const Udm::Object& localVar_45c1)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubSubsystem_45ba= _subSubsystem_45b4.begin(), itLocalVar_45c3= _localVar_45bd.begin(); itSubSubsystem_45ba!= _subSubsystem_45b4.end(), itLocalVar_45c3!= _localVar_45bd.end(); ++itSubSubsystem_45ba, ++itLocalVar_45c3)
	{
		if( ( *itSubSubsystem_45ba== subSubsystem_45b8)&& ( *itLocalVar_45c3== localVar_45c1))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subSubsystem_45b4.push_back( subSubsystem_45b8);
		_localVar_45bd.push_back( localVar_45c1);
	}
	return isUnique;
}

bool AddToScope_45ab::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void AddToScope_45ab::processInputPackets( const Packets_t& subSubsystems_45ac, const Packets_t& localVars_45af)
{
	for( Packets_t::const_iterator itSubSubsystem_45b5= subSubsystems_45ac.begin(), itLocalVar_45be= localVars_45af.begin(); itSubSubsystem_45b5!= subSubsystems_45ac.end(), itLocalVar_45be!= localVars_45af.end(); ++itSubSubsystem_45b5, ++itLocalVar_45be)
	{
		bool isUnique= isInputUnique( *itSubSubsystem_45b5, *itLocalVar_45be);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubSubsystem_45b5, *itLocalVar_45be);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AddToScope_45ab::patternMatcher( const Udm::Object& subSubsystem_45b6, const Udm::Object& localVar_45bf)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subSubsystem_45b6.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subSubsystem_45bb= CyberComposition::Simulink::Subsystem::Cast( subSubsystem_45b6);
		if( false== Uml::IsDerivedFrom( localVar_45bf.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_45c4= SFC::LocalVar::Cast( localVar_45bf);
		Udm::Object subSubsystemParent_45c6= subSubsystem_45bb.container();
		if( false== Uml::IsDerivedFrom( subSubsystemParent_45c6.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystemSubSubsystem_45c7= CyberComposition::Simulink::Subsystem::Cast( subSubsystemParent_45c6);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_45cb;
		if( !isValidBound(boundObjs_45cb, subSubsystem_45bb, true))
			continue;
		currMatch.subSubsystem_45cc= subSubsystem_45bb;
		if( !isValidBound(boundObjs_45cb, localVar_45c4, true))
			continue;
		currMatch.localVar_45cd= localVar_45c4;
		if( !isValidBound(boundObjs_45cb, subsystemSubSubsystem_45c7, false))
			continue;
		currMatch.subsystem_45ce= subsystemSubSubsystem_45c7;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void AddToScope_45ab::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar& LocalVar= currMatch.localVar_45cd;
		CyberComposition::Simulink::Subsystem& SubSubsystem= currMatch.subSubsystem_45cc;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_45ce;
		{
LocalVar.scope() =
 static_cast< std::string >( Subsystem.name() ) + "/" +
 static_cast< std::string >( LocalVar.scope() );
};
		outputAppender( currMatch.subsystem_45ce, currMatch.localVar_45cd);
	}
}

void AddToScope_45ab::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_45cf, const SFC::LocalVar& localVar_45d1)
{
	_subsystem_45b2->push_back( subsystem_45cf);
	_localVar_45b3->push_back( localVar_45d1);
}

void SubSubsystemTest_45d3::operator()( const Packets_t& systems_45d4, const Packets_t& localVars_45d6, Packets_t& systems_45d8, Packets_t& localVars_45d9, Packets_t& systems_45da, Packets_t& localVars_45db)
{
#ifdef PRINT_INFO
	printLog( "SubSubsystemTest_45d3" );
#endif
	_system_45dc= &systems_45d8;
	_localVar_45dd= &localVars_45d9;
	_system_45de= &systems_45da;
	_localVar_45df= &localVars_45db;
	for( Packets_t::const_iterator itsystem_45e1= systems_45d4.begin(), itlocalVar_45e8= localVars_45d6.begin(); itsystem_45e1!= systems_45d4.end(), itlocalVar_45e8!= localVars_45d6.end(); ++itsystem_45e1, ++itlocalVar_45e8)
	{
		bool isUnique= isInputUnique( *itsystem_45e1, *itlocalVar_45e8);
		if( !isUnique)
			continue;
		Packets_t onesystem_45e5( 1, *itsystem_45e1);
		Packets_t onelocalVar_45ec( 1, *itlocalVar_45e8);
		executeOne( onesystem_45e5, onelocalVar_45ec);
	}
}

void SubSubsystemTest_45d3::executeOne( const Packets_t& systems_45d4, const Packets_t& localVars_45d6)
{
	Packets_t subSubsystems_45f1;
	Packets_t localVars_45f4;
	NotTopSubsystem_45ee notTopSubsystem_45ee;
	bool isMatchNotTopSubsystem_45ee= notTopSubsystem_45ee( systems_45d4, localVars_45d6, subSubsystems_45f1, localVars_45f4);
	_system_45dc->insert( _system_45dc->end(), subSubsystems_45f1.begin(), subSubsystems_45f1.end());
	_localVar_45dd->insert( _localVar_45dd->end(), localVars_45f4.begin(), localVars_45f4.end());
	Packets_t subsystems_4619;
	Packets_t localVars_461c;
	Otherwise_4616 otherwise_4616;
	bool isMatchOtherwise_4616= otherwise_4616( systems_45d4, localVars_45d6, subsystems_4619, localVars_461c);
	_system_45de->insert( _system_45de->end(), subsystems_4619.begin(), subsystems_4619.end());
	_localVar_45df->insert( _localVar_45df->end(), localVars_461c.begin(), localVars_461c.end());
}

bool SubSubsystemTest_45d3::isInputUnique( const Udm::Object& system_45e2, const Udm::Object& localVar_45e9)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itsystem_45e4= _system_45e0.begin(), itlocalVar_45eb= _localVar_45e7.begin(); itsystem_45e4!= _system_45e0.end(), itlocalVar_45eb!= _localVar_45e7.end(); ++itsystem_45e4, ++itlocalVar_45eb)
	{
		if( ( *itsystem_45e4== system_45e2)&& ( *itlocalVar_45eb== localVar_45e9))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_system_45e0.push_back( system_45e2);
		_localVar_45e7.push_back( localVar_45e9);
	}
	return isUnique;
}

bool NotTopSubsystem_45ee::operator()( const Packets_t& subSubsystems_45ef, const Packets_t& localVars_45f2, Packets_t& subSubsystems_45f1, Packets_t& localVars_45f4)
{
#ifdef PRINT_INFO
	printLog( "NotTopSubsystem_45ee" );
#endif
	_subSubsystem_45f5= &subSubsystems_45f1;
	_localVar_45f6= &localVars_45f4;
	processInputPackets( subSubsystems_45ef, localVars_45f2);
	if( false== _matches.empty())
		return true;
	return false;
}

bool NotTopSubsystem_45ee::isInputUnique( const Udm::Object& subSubsystem_45fb, const Udm::Object& localVar_4604)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubSubsystem_45fd= _subSubsystem_45f7.begin(), itLocalVar_4606= _localVar_4600.begin(); itSubSubsystem_45fd!= _subSubsystem_45f7.end(), itLocalVar_4606!= _localVar_4600.end(); ++itSubSubsystem_45fd, ++itLocalVar_4606)
	{
		if( ( *itSubSubsystem_45fd== subSubsystem_45fb)&& ( *itLocalVar_4606== localVar_4604))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subSubsystem_45f7.push_back( subSubsystem_45fb);
		_localVar_4600.push_back( localVar_4604);
	}
	return isUnique;
}

bool NotTopSubsystem_45ee::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void NotTopSubsystem_45ee::processInputPackets( const Packets_t& subSubsystems_45ef, const Packets_t& localVars_45f2)
{
	for( Packets_t::const_iterator itSubSubsystem_45f8= subSubsystems_45ef.begin(), itLocalVar_4601= localVars_45f2.begin(); itSubSubsystem_45f8!= subSubsystems_45ef.end(), itLocalVar_4601!= localVars_45f2.end(); ++itSubSubsystem_45f8, ++itLocalVar_4601)
	{
		bool isUnique= isInputUnique( *itSubSubsystem_45f8, *itLocalVar_4601);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubSubsystem_45f8, *itLocalVar_4601);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subSubsystem_460f, currMatch.localVar_4610);
	}
}

bool NotTopSubsystem_45ee::patternMatcher( const Udm::Object& subSubsystem_45f9, const Udm::Object& localVar_4602)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subSubsystem_45f9.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subSubsystem_45fe= CyberComposition::Simulink::Subsystem::Cast( subSubsystem_45f9);
		if( false== Uml::IsDerivedFrom( localVar_4602.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_4607= SFC::LocalVar::Cast( localVar_4602);
		Udm::Object subSubsystemParent_4609= subSubsystem_45fe.container();
		if( false== Uml::IsDerivedFrom( subSubsystemParent_4609.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystemSubSubsystem_460a= CyberComposition::Simulink::Subsystem::Cast( subSubsystemParent_4609);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_460e;
		if( !isValidBound(boundObjs_460e, subSubsystem_45fe, true))
			continue;
		currMatch.subSubsystem_460f= subSubsystem_45fe;
		if( !isValidBound(boundObjs_460e, localVar_4607, true))
			continue;
		currMatch.localVar_4610= localVar_4607;
		if( !isValidBound(boundObjs_460e, subsystemSubSubsystem_460a, false))
			continue;
		currMatch.subsystem_4611= subsystemSubSubsystem_460a;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void NotTopSubsystem_45ee::outputAppender( const CyberComposition::Simulink::Subsystem& subSubsystem_4612, const SFC::LocalVar& localVar_4614)
{
	_subSubsystem_45f5->push_back( subSubsystem_4612);
	_localVar_45f6->push_back( localVar_4614);
}

bool Otherwise_4616::operator()( const Packets_t& subsystems_4617, const Packets_t& localVars_461a, Packets_t& subsystems_4619, Packets_t& localVars_461c)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_4616" );
#endif
	_subsystem_461d= &subsystems_4619;
	_localVar_461e= &localVars_461c;
	processInputPackets( subsystems_4617, localVars_461a);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_4616::isInputUnique( const Udm::Object& subsystem_4623, const Udm::Object& localVar_462c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_4625= _subsystem_461f.begin(), itLocalVar_462e= _localVar_4628.begin(); itSubsystem_4625!= _subsystem_461f.end(), itLocalVar_462e!= _localVar_4628.end(); ++itSubsystem_4625, ++itLocalVar_462e)
	{
		if( ( *itSubsystem_4625== subsystem_4623)&& ( *itLocalVar_462e== localVar_462c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_461f.push_back( subsystem_4623);
		_localVar_4628.push_back( localVar_462c);
	}
	return isUnique;
}

bool Otherwise_4616::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_4616::processInputPackets( const Packets_t& subsystems_4617, const Packets_t& localVars_461a)
{
	for( Packets_t::const_iterator itSubsystem_4620= subsystems_4617.begin(), itLocalVar_4629= localVars_461a.begin(); itSubsystem_4620!= subsystems_4617.end(), itLocalVar_4629!= localVars_461a.end(); ++itSubsystem_4620, ++itLocalVar_4629)
	{
		bool isUnique= isInputUnique( *itSubsystem_4620, *itLocalVar_4629);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_4620, *itLocalVar_4629);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_4635, currMatch.localVar_4636);
	}
}

bool Otherwise_4616::patternMatcher( const Udm::Object& subsystem_4621, const Udm::Object& localVar_462a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_4621.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_4626= CyberComposition::Simulink::Subsystem::Cast( subsystem_4621);
		if( false== Uml::IsDerivedFrom( localVar_462a.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_462f= SFC::LocalVar::Cast( localVar_462a);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4634;
		if( !isValidBound(boundObjs_4634, subsystem_4626, true))
			continue;
		currMatch.subsystem_4635= subsystem_4626;
		if( !isValidBound(boundObjs_4634, localVar_462f, true))
			continue;
		currMatch.localVar_4636= localVar_462f;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_4616::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_4637, const SFC::LocalVar& localVar_4639)
{
	_subsystem_461d->push_back( subsystem_4637);
	_localVar_461e->push_back( localVar_4639);
}

void GetStoreSubsystem_4641::operator()( const Packets_t& systems_4642, const Packets_t& localVars_4644, Packets_t& systems_4646, Packets_t& localVars_4647)
{
#ifdef PRINT_INFO
	printLog( "GetStoreSubsystem_4641" );
#endif
	_system_4648= &systems_4646;
	_localVar_4649= &localVars_4647;
	if( ( !systems_4642.empty())&& ( !localVars_4644.empty()))
		callStoreTest_46ff( systems_4642, localVars_4644);
}

void GetStoreSubsystem_4641::callStoreTest_46ff( const Packets_t& systems_464b, const Packets_t& localVars_464d)
{
	Packets_t systems_464f;
	Packets_t localVars_4650;
	Packets_t systems_4651;
	Packets_t localVars_4652;
	StoreTest_464a storeTest_464a;
	storeTest_464a( systems_464b, localVars_464d, systems_464f, localVars_4650, systems_4651, localVars_4652);
	if( ( !systems_464f.empty())&& ( !localVars_4650.empty()))
		callInitScope_4702( systems_464f, localVars_4650);
	if( ( !systems_4651.empty())&& ( !localVars_4652.empty()))
		callNextHigherSubsystem_4705( systems_4651, localVars_4652);
}

void GetStoreSubsystem_4641::callInitScope_4702( const Packets_t& subsystems_46df, const Packets_t& localVars_46e2)
{
	Packets_t subsystems_46e1;
	Packets_t localVars_46e4;
	InitScope_46de initScope_46de;
	initScope_46de( subsystems_46df, localVars_46e2, subsystems_46e1, localVars_46e4);
	_system_4648->insert( _system_4648->end(), subsystems_46e1.begin(), subsystems_46e1.end());
	_localVar_4649->insert( _localVar_4649->end(), localVars_46e4.begin(), localVars_46e4.end());
}

void GetStoreSubsystem_4641::callNextHigherSubsystem_4705( const Packets_t& subSubsystems_46b7, const Packets_t& localVars_46ba)
{
	Packets_t subsystems_46b9;
	Packets_t localVars_46bc;
	NextHigherSubsystem_46b6 nextHigherSubsystem_46b6;
	nextHigherSubsystem_46b6( subSubsystems_46b7, localVars_46ba, subsystems_46b9, localVars_46bc);
	if( ( !subsystems_46b9.empty())&& ( !localVars_46bc.empty()))
		callStoreTest_46ff( subsystems_46b9, localVars_46bc);
}

void StoreTest_464a::operator()( const Packets_t& systems_464b, const Packets_t& localVars_464d, Packets_t& systems_464f, Packets_t& localVars_4650, Packets_t& systems_4651, Packets_t& localVars_4652)
{
#ifdef PRINT_INFO
	printLog( "StoreTest_464a" );
#endif
	_system_4653= &systems_464f;
	_localVar_4654= &localVars_4650;
	_system_4655= &systems_4651;
	_localVar_4656= &localVars_4652;
	for( Packets_t::const_iterator itsystem_4658= systems_464b.begin(), itlocalVar_465f= localVars_464d.begin(); itsystem_4658!= systems_464b.end(), itlocalVar_465f!= localVars_464d.end(); ++itsystem_4658, ++itlocalVar_465f)
	{
		bool isUnique= isInputUnique( *itsystem_4658, *itlocalVar_465f);
		if( !isUnique)
			continue;
		Packets_t onesystem_465c( 1, *itsystem_4658);
		Packets_t onelocalVar_4663( 1, *itlocalVar_465f);
		executeOne( onesystem_465c, onelocalVar_4663);
	}
}

void StoreTest_464a::executeOne( const Packets_t& systems_464b, const Packets_t& localVars_464d)
{
	Packets_t subsystems_4668;
	Packets_t localVars_466b;
	HasStore_4665 hasStore_4665;
	bool isMatchHasStore_4665= hasStore_4665( systems_464b, localVars_464d, subsystems_4668, localVars_466b);
	_system_4653->insert( _system_4653->end(), subsystems_4668.begin(), subsystems_4668.end());
	_localVar_4654->insert( _localVar_4654->end(), localVars_466b.begin(), localVars_466b.end());
	if( isMatchHasStore_4665)
		return;
	Packets_t subsystems_4694;
	Packets_t localVars_4697;
	Otherwise_4691 otherwise_4691;
	bool isMatchOtherwise_4691= otherwise_4691( systems_464b, localVars_464d, subsystems_4694, localVars_4697);
	_system_4655->insert( _system_4655->end(), subsystems_4694.begin(), subsystems_4694.end());
	_localVar_4656->insert( _localVar_4656->end(), localVars_4697.begin(), localVars_4697.end());
	if( isMatchOtherwise_4691)
		return;
}

bool StoreTest_464a::isInputUnique( const Udm::Object& system_4659, const Udm::Object& localVar_4660)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itsystem_465b= _system_4657.begin(), itlocalVar_4662= _localVar_465e.begin(); itsystem_465b!= _system_4657.end(), itlocalVar_4662!= _localVar_465e.end(); ++itsystem_465b, ++itlocalVar_4662)
	{
		if( ( *itsystem_465b== system_4659)&& ( *itlocalVar_4662== localVar_4660))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_system_4657.push_back( system_4659);
		_localVar_465e.push_back( localVar_4660);
	}
	return isUnique;
}

bool HasStore_4665::operator()( const Packets_t& subsystems_4666, const Packets_t& localVars_4669, Packets_t& subsystems_4668, Packets_t& localVars_466b)
{
#ifdef PRINT_INFO
	printLog( "HasStore_4665" );
#endif
	_subsystem_466c= &subsystems_4668;
	_localVar_466d= &localVars_466b;
	processInputPackets( subsystems_4666, localVars_4669);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasStore_4665::isInputUnique( const Udm::Object& subsystem_4672, const Udm::Object& localVar_467b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_4674= _subsystem_466e.begin(), itLocalVar_467d= _localVar_4677.begin(); itSubsystem_4674!= _subsystem_466e.end(), itLocalVar_467d!= _localVar_4677.end(); ++itSubsystem_4674, ++itLocalVar_467d)
	{
		if( ( *itSubsystem_4674== subsystem_4672)&& ( *itLocalVar_467d== localVar_467b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_466e.push_back( subsystem_4672);
		_localVar_4677.push_back( localVar_467b);
	}
	return isUnique;
}

bool HasStore_4665::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool HasStore_4665::isGuardTrue( SFC::LocalVar& LocalVar, CyberComposition::Simulink::SF_Parameter& Parameter, CyberComposition::Simulink::Subsystem& Subsystem)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( Parameter.Value() ) ==
 static_cast< std::string >( LocalVar.name() );;
	return Gz_guard;
}

void HasStore_4665::processInputPackets( const Packets_t& subsystems_4666, const Packets_t& localVars_4669)
{
	for( Packets_t::const_iterator itSubsystem_466f= subsystems_4666.begin(), itLocalVar_4678= localVars_4669.begin(); itSubsystem_466f!= subsystems_4666.end(), itLocalVar_4678!= localVars_4669.end(); ++itSubsystem_466f, ++itLocalVar_4678)
	{
		bool isUnique= isInputUnique( *itSubsystem_466f, *itLocalVar_4678);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_466f, *itLocalVar_4678);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_4687, currMatch.localVar_4688);
	}
}

bool HasStore_4665::patternMatcher( const Udm::Object& subsystem_4670, const Udm::Object& localVar_4679)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_4670.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_4675= CyberComposition::Simulink::Subsystem::Cast( subsystem_4670);
		if( false== Uml::IsDerivedFrom( localVar_4679.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_467e= SFC::LocalVar::Cast( localVar_4679);
		set< CyberComposition::Simulink::SF_Parameter> parameters_4680= subsystem_4675.SF_Parameter_kind_children();
		for( set< CyberComposition::Simulink::SF_Parameter>::const_iterator itParameter_4681= parameters_4680.begin(); itParameter_4681!= parameters_4680.end(); ++itParameter_4681)
		{
			CyberComposition::Simulink::SF_Parameter currParameter_4682= *itParameter_4681;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_4686;
			if( !isValidBound(boundObjs_4686, subsystem_4675, true))
				continue;
			currMatch.subsystem_4687= subsystem_4675;
			if( !isValidBound(boundObjs_4686, localVar_467e, true))
				continue;
			currMatch.localVar_4688= localVar_467e;
			if( !isValidBound(boundObjs_4686, currParameter_4682, false))
				continue;
			currMatch.parameter_4689= currParameter_4682;
			bool Gz_guard= isGuardTrue( currMatch.localVar_4688, currMatch.parameter_4689, currMatch.subsystem_4687);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void HasStore_4665::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_468d, const SFC::LocalVar& localVar_468f)
{
	_subsystem_466c->push_back( subsystem_468d);
	_localVar_466d->push_back( localVar_468f);
}

bool Otherwise_4691::operator()( const Packets_t& subsystems_4692, const Packets_t& localVars_4695, Packets_t& subsystems_4694, Packets_t& localVars_4697)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_4691" );
#endif
	_subsystem_4698= &subsystems_4694;
	_localVar_4699= &localVars_4697;
	processInputPackets( subsystems_4692, localVars_4695);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_4691::isInputUnique( const Udm::Object& subsystem_469e, const Udm::Object& localVar_46a7)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_46a0= _subsystem_469a.begin(), itLocalVar_46a9= _localVar_46a3.begin(); itSubsystem_46a0!= _subsystem_469a.end(), itLocalVar_46a9!= _localVar_46a3.end(); ++itSubsystem_46a0, ++itLocalVar_46a9)
	{
		if( ( *itSubsystem_46a0== subsystem_469e)&& ( *itLocalVar_46a9== localVar_46a7))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_469a.push_back( subsystem_469e);
		_localVar_46a3.push_back( localVar_46a7);
	}
	return isUnique;
}

bool Otherwise_4691::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_4691::processInputPackets( const Packets_t& subsystems_4692, const Packets_t& localVars_4695)
{
	for( Packets_t::const_iterator itSubsystem_469b= subsystems_4692.begin(), itLocalVar_46a4= localVars_4695.begin(); itSubsystem_469b!= subsystems_4692.end(), itLocalVar_46a4!= localVars_4695.end(); ++itSubsystem_469b, ++itLocalVar_46a4)
	{
		bool isUnique= isInputUnique( *itSubsystem_469b, *itLocalVar_46a4);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_469b, *itLocalVar_46a4);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_46b0, currMatch.localVar_46b1);
	}
}

bool Otherwise_4691::patternMatcher( const Udm::Object& subsystem_469c, const Udm::Object& localVar_46a5)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_469c.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_46a1= CyberComposition::Simulink::Subsystem::Cast( subsystem_469c);
		if( false== Uml::IsDerivedFrom( localVar_46a5.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_46aa= SFC::LocalVar::Cast( localVar_46a5);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_46af;
		if( !isValidBound(boundObjs_46af, subsystem_46a1, true))
			continue;
		currMatch.subsystem_46b0= subsystem_46a1;
		if( !isValidBound(boundObjs_46af, localVar_46aa, true))
			continue;
		currMatch.localVar_46b1= localVar_46aa;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_4691::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_46b2, const SFC::LocalVar& localVar_46b4)
{
	_subsystem_4698->push_back( subsystem_46b2);
	_localVar_4699->push_back( localVar_46b4);
}

void NextHigherSubsystem_46b6::operator()( const Packets_t& subSubsystems_46b7, const Packets_t& localVars_46ba, Packets_t& subsystems_46b9, Packets_t& localVars_46bc)
{
#ifdef PRINT_INFO
	printLog( "NextHigherSubsystem_46b6" );
#endif
	RTTGenerator::Instance()->generateRule(3794, "NextHigherSubsystem");
	_subsystem_46bd= &subsystems_46b9;
	_localVar_46be= &localVars_46bc;
	processInputPackets( subSubsystems_46b7, localVars_46ba);
}

bool NextHigherSubsystem_46b6::isInputUnique( const Udm::Object& subSubsystem_46c3, const Udm::Object& localVar_46cc)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubSubsystem_46c5= _subSubsystem_46bf.begin(), itLocalVar_46ce= _localVar_46c8.begin(); itSubSubsystem_46c5!= _subSubsystem_46bf.end(), itLocalVar_46ce!= _localVar_46c8.end(); ++itSubSubsystem_46c5, ++itLocalVar_46ce)
	{
		if( ( *itSubSubsystem_46c5== subSubsystem_46c3)&& ( *itLocalVar_46ce== localVar_46cc))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subSubsystem_46bf.push_back( subSubsystem_46c3);
		_localVar_46c8.push_back( localVar_46cc);
	}
	return isUnique;
}

bool NextHigherSubsystem_46b6::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void NextHigherSubsystem_46b6::processInputPackets( const Packets_t& subSubsystems_46b7, const Packets_t& localVars_46ba)
{
	for( Packets_t::const_iterator itSubSubsystem_46c0= subSubsystems_46b7.begin(), itLocalVar_46c9= localVars_46ba.begin(); itSubSubsystem_46c0!= subSubsystems_46b7.end(), itLocalVar_46c9!= localVars_46ba.end(); ++itSubSubsystem_46c0, ++itLocalVar_46c9)
	{
		bool isUnique= isInputUnique( *itSubSubsystem_46c0, *itLocalVar_46c9);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubSubsystem_46c0, *itLocalVar_46c9);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool NextHigherSubsystem_46b6::patternMatcher( const Udm::Object& subSubsystem_46c1, const Udm::Object& localVar_46ca)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subSubsystem_46c1.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subSubsystem_46c6= CyberComposition::Simulink::Subsystem::Cast( subSubsystem_46c1);
		if( false== Uml::IsDerivedFrom( localVar_46ca.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_46cf= SFC::LocalVar::Cast( localVar_46ca);
		Udm::Object subSubsystemParent_46d1= subSubsystem_46c6.container();
		if( false== Uml::IsDerivedFrom( subSubsystemParent_46d1.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystemSubSubsystem_46d2= CyberComposition::Simulink::Subsystem::Cast( subSubsystemParent_46d1);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_46d6;
		if( !isValidBound(boundObjs_46d6, subSubsystem_46c6, true))
			continue;
		currMatch.subSubsystem_46d7= subSubsystem_46c6;
		if( !isValidBound(boundObjs_46d6, localVar_46cf, true))
			continue;
		currMatch.localVar_46d8= localVar_46cf;
		if( !isValidBound(boundObjs_46d6, subsystemSubSubsystem_46d2, false))
			continue;
		currMatch.subsystem_46d9= subsystemSubSubsystem_46d2;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void NextHigherSubsystem_46b6::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_46d9, currMatch.localVar_46d8);
	}
}

void NextHigherSubsystem_46b6::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_46da, const SFC::LocalVar& localVar_46dc)
{
	_subsystem_46bd->push_back( subsystem_46da);
	_localVar_46be->push_back( localVar_46dc);
}

void InitScope_46de::operator()( const Packets_t& subsystems_46df, const Packets_t& localVars_46e2, Packets_t& subsystems_46e1, Packets_t& localVars_46e4)
{
#ifdef PRINT_INFO
	printLog( "InitScope_46de" );
#endif
	RTTGenerator::Instance()->generateRule(3799, "InitScope");
	_subsystem_46e5= &subsystems_46e1;
	_localVar_46e6= &localVars_46e4;
	processInputPackets( subsystems_46df, localVars_46e2);
	forwardInputs( );
}

bool InitScope_46de::isInputUnique( const Udm::Object& subsystem_46eb, const Udm::Object& localVar_46f4)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_46ed= _subsystem_46e7.begin(), itLocalVar_46f6= _localVar_46f0.begin(); itSubsystem_46ed!= _subsystem_46e7.end(), itLocalVar_46f6!= _localVar_46f0.end(); ++itSubsystem_46ed, ++itLocalVar_46f6)
	{
		if( ( *itSubsystem_46ed== subsystem_46eb)&& ( *itLocalVar_46f6== localVar_46f4))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_46e7.push_back( subsystem_46eb);
		_localVar_46f0.push_back( localVar_46f4);
	}
	return isUnique;
}

bool InitScope_46de::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void InitScope_46de::processInputPackets( const Packets_t& subsystems_46df, const Packets_t& localVars_46e2)
{
	for( Packets_t::const_iterator itSubsystem_46e8= subsystems_46df.begin(), itLocalVar_46f1= localVars_46e2.begin(); itSubsystem_46e8!= subsystems_46df.end(), itLocalVar_46f1!= localVars_46e2.end(); ++itSubsystem_46e8, ++itLocalVar_46f1)
	{
		bool isUnique= isInputUnique( *itSubsystem_46e8, *itLocalVar_46f1);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_46e8, *itLocalVar_46f1);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InitScope_46de::patternMatcher( const Udm::Object& subsystem_46e9, const Udm::Object& localVar_46f2)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_46e9.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_46ee= CyberComposition::Simulink::Subsystem::Cast( subsystem_46e9);
		if( false== Uml::IsDerivedFrom( localVar_46f2.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_46f7= SFC::LocalVar::Cast( localVar_46f2);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_46fc;
		if( !isValidBound(boundObjs_46fc, subsystem_46ee, true))
			continue;
		currMatch.subsystem_46fd= subsystem_46ee;
		if( !isValidBound(boundObjs_46fc, localVar_46f7, true))
			continue;
		currMatch.localVar_46fe= localVar_46f7;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void InitScope_46de::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar& LocalVar= currMatch.localVar_46fe;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_46fd;
		{
LocalVar.scope() = Subsystem.name();
};
	}
}

void InitScope_46de::forwardInputs()
{
	*_subsystem_46e5= _subsystem_46e7;
	*_localVar_46e6= _localVar_46f0;
}

void GetContainingSubsystem_4708::operator()( const Packets_t& sFStates_4709, const Packets_t& localVars_470c, Packets_t& subsystems_470b, Packets_t& localVars_470e)
{
#ifdef PRINT_INFO
	printLog( "GetContainingSubsystem_4708" );
#endif
	RTTGenerator::Instance()->generateRule(3803, "GetContainingSubsystem");
	_subsystem_470f= &subsystems_470b;
	_localVar_4710= &localVars_470e;
	processInputPackets( sFStates_4709, localVars_470c);
}

bool GetContainingSubsystem_4708::isInputUnique( const Udm::Object& sFState_4715, const Udm::Object& localVar_471e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4717= _sFState_4711.begin(), itLocalVar_4720= _localVar_471a.begin(); itSFState_4717!= _sFState_4711.end(), itLocalVar_4720!= _localVar_471a.end(); ++itSFState_4717, ++itLocalVar_4720)
	{
		if( ( *itSFState_4717== sFState_4715)&& ( *itLocalVar_4720== localVar_471e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4711.push_back( sFState_4715);
		_localVar_471a.push_back( localVar_471e);
	}
	return isUnique;
}

bool GetContainingSubsystem_4708::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetContainingSubsystem_4708::processInputPackets( const Packets_t& sFStates_4709, const Packets_t& localVars_470c)
{
	for( Packets_t::const_iterator itSFState_4712= sFStates_4709.begin(), itLocalVar_471b= localVars_470c.begin(); itSFState_4712!= sFStates_4709.end(), itLocalVar_471b!= localVars_470c.end(); ++itSFState_4712, ++itLocalVar_471b)
	{
		bool isUnique= isInputUnique( *itSFState_4712, *itLocalVar_471b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4712, *itLocalVar_471b);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetContainingSubsystem_4708::patternMatcher( const Udm::Object& sFState_4713, const Udm::Object& localVar_471c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4713.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4718= CyberComposition::Simulink::SFState::Cast( sFState_4713);
		if( false== Uml::IsDerivedFrom( localVar_471c.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_4721= SFC::LocalVar::Cast( localVar_471c);
		Udm::Object sFStateParent_4723= sFState_4718.container();
		if( false== Uml::IsDerivedFrom( sFStateParent_4723.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystemSFState_4724= CyberComposition::Simulink::Subsystem::Cast( sFStateParent_4723);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4728;
		if( !isValidBound(boundObjs_4728, sFState_4718, true))
			continue;
		currMatch.sFState_4729= sFState_4718;
		if( !isValidBound(boundObjs_4728, localVar_4721, true))
			continue;
		currMatch.localVar_472a= localVar_4721;
		if( !isValidBound(boundObjs_4728, subsystemSFState_4724, false))
			continue;
		currMatch.subsystem_472b= subsystemSFState_4724;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void GetContainingSubsystem_4708::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_472b, currMatch.localVar_472a);
	}
}

void GetContainingSubsystem_4708::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_472c, const SFC::LocalVar& localVar_472e)
{
	_subsystem_470f->push_back( subsystem_472c);
	_localVar_4710->push_back( localVar_472e);
}

void CreateDataVar_4730::operator()( const Packets_t& sFStates_4731, const Packets_t& programs_4735, Packets_t& sFStates_4733, Packets_t& localVars_4734)
{
#ifdef PRINT_INFO
	printLog( "CreateDataVar_4730" );
#endif
	RTTGenerator::Instance()->generateRule(3808, "CreateDataVar");
	_sFState_4737= &sFStates_4733;
	_localVar_4738= &localVars_4734;
	processInputPackets( sFStates_4731, programs_4735);
}

bool CreateDataVar_4730::isInputUnique( const Udm::Object& sFState_473d, const Udm::Object& program_4746)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_473f= _sFState_4739.begin(), itProgram_4748= _program_4742.begin(); itSFState_473f!= _sFState_4739.end(), itProgram_4748!= _program_4742.end(); ++itSFState_473f, ++itProgram_4748)
	{
		if( ( *itSFState_473f== sFState_473d)&& ( *itProgram_4748== program_4746))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4739.push_back( sFState_473d);
		_program_4742.push_back( program_4746);
	}
	return isUnique;
}

bool CreateDataVar_4730::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool CreateDataVar_4730::isGuardTrue( SFC::DT& DT, SFC::Program& Program, SFC::Project& Project, CyberComposition::Simulink::SFData& SFData, CyberComposition::Simulink::SFState& SFState, SFC::StateLabel& StateLabel, CyberComposition::Simulink::SF_TypeBase& TypeBase, CyberComposition::Simulink::TypeBaseRef& TypeBaseRef)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( SFData.Scope() ) == "STORE_DATA";;
	return Gz_guard;
}

void CreateDataVar_4730::processInputPackets( const Packets_t& sFStates_4731, const Packets_t& programs_4735)
{
	for( Packets_t::const_iterator itSFState_473a= sFStates_4731.begin(), itProgram_4743= programs_4735.begin(); itSFState_473a!= sFStates_4731.end(), itProgram_4743!= programs_4735.end(); ++itSFState_473a, ++itProgram_4743)
	{
		bool isUnique= isInputUnique( *itSFState_473a, *itProgram_4743);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_473a, *itProgram_4743);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateDataVar_4730::patternMatcher( const Udm::Object& sFState_473b, const Udm::Object& program_4744)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_473b.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4740= CyberComposition::Simulink::SFState::Cast( sFState_473b);
		if( false== Uml::IsDerivedFrom( program_4744.type(), SFC::Program::meta))
			continue;
		SFC::Program program_4749= SFC::Program::Cast( program_4744);
		set< CyberComposition::Simulink::SFData> sFDatas_474b= sFState_4740.SFData_kind_children();
		for( set< CyberComposition::Simulink::SFData>::const_iterator itSFData_474c= sFDatas_474b.begin(); itSFData_474c!= sFDatas_474b.end(); ++itSFData_474c)
		{
			CyberComposition::Simulink::SFData currSFData_474d= *itSFData_474c;
			Udm::Object programParent_474e= program_4749.container();
			if( false== Uml::IsDerivedFrom( programParent_474e.type(), SFC::Project::meta))
				continue;
			SFC::Project projectProgram_474f= SFC::Project::Cast( programParent_474e);
			set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_4750= currSFData_474d.TypeBaseRef_kind_children();
			for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_4751= typeBaseRefs_4750.begin(); itTypeBaseRef_4751!= typeBaseRefs_4750.end(); ++itTypeBaseRef_4751)
			{
				CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_4752= *itTypeBaseRef_4751;
				set< SFC::StateLabel> stateLabels_4753= sFState_4740.src();
				for( set< SFC::StateLabel>::const_iterator itStateLabels_4754= stateLabels_4753.begin(); itStateLabels_4754!= stateLabels_4753.end(); ++itStateLabels_4754)
				{
					SFC::StateLabel currStateLabel_4755= *itStateLabels_4754;
					CyberComposition::Simulink::SF_TypeBase typeBase_4756= currTypeBaseRef_4752.ref();
					if( !typeBase_4756)
						continue;
					SFC::DT dT_4757= typeBase_4756.dt();
					if( !dT_4757)
						continue;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_475b;
					if( !isValidBound(boundObjs_475b, sFState_4740, true))
						continue;
					currMatch.sFState_475c= sFState_4740;
					if( !isValidBound(boundObjs_475b, program_4749, true))
						continue;
					currMatch.program_475d= program_4749;
					if( !isValidBound(boundObjs_475b, currStateLabel_4755, false))
						continue;
					currMatch.stateLabel_475e= currStateLabel_4755;
					if( !isValidBound(boundObjs_475b, currSFData_474d, false))
						continue;
					currMatch.sFData_475f= currSFData_474d;
					if( !isValidBound(boundObjs_475b, currTypeBaseRef_4752, false))
						continue;
					currMatch.typeBaseRef_4760= currTypeBaseRef_4752;
					if( !isValidBound(boundObjs_475b, typeBase_4756, false))
						continue;
					currMatch.typeBase_4761= typeBase_4756;
					if( !isValidBound(boundObjs_475b, dT_4757, false))
						continue;
					currMatch.dT_4762= dT_4757;
					if( !isValidBound(boundObjs_475b, projectProgram_474f, false))
						continue;
					currMatch.project_4763= projectProgram_474f;
					bool Gz_guard= isGuardTrue( currMatch.dT_4762, currMatch.program_475d, currMatch.project_4763, currMatch.sFData_475f, currMatch.sFState_475c, currMatch.stateLabel_475e, currMatch.typeBase_4761, currMatch.typeBaseRef_4760);
					if( true== Gz_guard)
						_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void CreateDataVar_4730::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newLocalVar_476c= SFC::LocalVar::Create( currMatch.project_4763);
		SFC::DT& DT= currMatch.dT_4762;
		SFC::LocalVar& LocalVar= newLocalVar_476c;
		SFC::Program& Program= currMatch.program_475d;
		SFC::Project& Project= currMatch.project_4763;
		CyberComposition::Simulink::SFData& SFData= currMatch.sFData_475f;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_475c;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_475e;
		CyberComposition::Simulink::SF_TypeBase& TypeBase= currMatch.typeBase_4761;
		CyberComposition::Simulink::TypeBaseRef& TypeBaseRef= currMatch.typeBaseRef_4760;
		{
__int64 statementCount = Project.statementCount();
LocalVar.statementIndex() = statementCount++;
Project.statementCount() = statementCount;
};
		{
std::string dataName = SFData.Name();
if(dataName.empty())
	dataName = SFData.name();
LocalVar.name() = dataName;
LocalVar.initial() = SFData.InitialValue();
LocalVar.indexBase() = SFData.ArrayFirstIndex();
};
		{
LocalVar.RefId() = SFData.RefId();
};
		newLocalVar_476c.SFdata()+= currMatch.sFData_475f;
		newLocalVar_476c.dt()= currMatch.dT_4762;
		outputAppender( currMatch.sFState_475c, newLocalVar_476c);
	}
}

void CreateDataVar_4730::outputAppender( const CyberComposition::Simulink::SFState& sFState_476d, const SFC::LocalVar& localVar_476f)
{
	_sFState_4737->push_back( sFState_476d);
	_localVar_4738->push_back( localVar_476f);
}

void CreateEventVar_4783::operator()( const Packets_t& states_4784, const Packets_t& programs_4786, Packets_t& states_4788, Packets_t& programs_4789)
{
#ifdef PRINT_INFO
	printLog( "CreateEventVar_4783" );
#endif
	_state_478a= &states_4788;
	_program_478b= &programs_4789;
	if( ( !states_4784.empty())&& ( !programs_4786.empty()))
		callCreateEventVar_47ba( states_4784, programs_4786);
	_state_478a->insert( _state_478a->end(), states_4784.begin(), states_4784.end());
	_program_478b->insert( _program_478b->end(), programs_4786.begin(), programs_4786.end());
}

void CreateEventVar_4783::callCreateEventVar_47ba( const Packets_t& sFStates_478d, const Packets_t& programs_478f)
{
	CreateEventVar_478c createEventVar_478c;
	createEventVar_478c( sFStates_478d, programs_478f);
}

void CreateEventVar_478c::operator()( const Packets_t& sFStates_478d, const Packets_t& programs_478f)
{
#ifdef PRINT_INFO
	printLog( "CreateEventVar_478c" );
#endif
	RTTGenerator::Instance()->generateRule(3835, "CreateEventVar");
	processInputPackets( sFStates_478d, programs_478f);
}

bool CreateEventVar_478c::isInputUnique( const Udm::Object& sFState_4795, const Udm::Object& program_479e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4797= _sFState_4791.begin(), itProgram_47a0= _program_479a.begin(); itSFState_4797!= _sFState_4791.end(), itProgram_47a0!= _program_479a.end(); ++itSFState_4797, ++itProgram_47a0)
	{
		if( ( *itSFState_4797== sFState_4795)&& ( *itProgram_47a0== program_479e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4791.push_back( sFState_4795);
		_program_479a.push_back( program_479e);
	}
	return isUnique;
}

bool CreateEventVar_478c::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateEventVar_478c::processInputPackets( const Packets_t& sFStates_478d, const Packets_t& programs_478f)
{
	for( Packets_t::const_iterator itSFState_4792= sFStates_478d.begin(), itProgram_479b= programs_478f.begin(); itSFState_4792!= sFStates_478d.end(), itProgram_479b!= programs_478f.end(); ++itSFState_4792, ++itProgram_479b)
	{
		bool isUnique= isInputUnique( *itSFState_4792, *itProgram_479b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4792, *itProgram_479b);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateEventVar_478c::patternMatcher( const Udm::Object& sFState_4793, const Udm::Object& program_479c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4793.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4798= CyberComposition::Simulink::SFState::Cast( sFState_4793);
		if( false== Uml::IsDerivedFrom( program_479c.type(), SFC::Program::meta))
			continue;
		SFC::Program program_47a1= SFC::Program::Cast( program_479c);
		set< CyberComposition::Simulink::SFEvent> sFEvents_47a3= sFState_4798.SFEvent_kind_children();
		for( set< CyberComposition::Simulink::SFEvent>::const_iterator itSFEvent_47a4= sFEvents_47a3.begin(); itSFEvent_47a4!= sFEvents_47a3.end(); ++itSFEvent_47a4)
		{
			CyberComposition::Simulink::SFEvent currSFEvent_47a5= *itSFEvent_47a4;
			set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_47a6= currSFEvent_47a5.TypeBaseRef_kind_children();
			for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_47a7= typeBaseRefs_47a6.begin(); itTypeBaseRef_47a7!= typeBaseRefs_47a6.end(); ++itTypeBaseRef_47a7)
			{
				CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_47a8= *itTypeBaseRef_47a7;
				CyberComposition::Simulink::SF_TypeBase typeBase_47a9= currTypeBaseRef_47a8.ref();
				if( !typeBase_47a9)
					continue;
				SFC::DT dT_47aa= typeBase_47a9.dt();
				if( !dT_47aa)
					continue;
				set< SFC::StateLabel> stateLabels_47ab= sFState_4798.src();
				for( set< SFC::StateLabel>::const_iterator itStateLabels_47ac= stateLabels_47ab.begin(); itStateLabels_47ac!= stateLabels_47ab.end(); ++itStateLabels_47ac)
				{
					SFC::StateLabel currStateLabel_47ad= *itStateLabels_47ac;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_47b1;
					if( !isValidBound(boundObjs_47b1, sFState_4798, true))
						continue;
					currMatch.sFState_47b2= sFState_4798;
					if( !isValidBound(boundObjs_47b1, program_47a1, true))
						continue;
					currMatch.program_47b3= program_47a1;
					if( !isValidBound(boundObjs_47b1, currStateLabel_47ad, false))
						continue;
					currMatch.stateLabel_47b4= currStateLabel_47ad;
					if( !isValidBound(boundObjs_47b1, currSFEvent_47a5, false))
						continue;
					currMatch.sFEvent_47b5= currSFEvent_47a5;
					if( !isValidBound(boundObjs_47b1, currTypeBaseRef_47a8, false))
						continue;
					currMatch.typeBaseRef_47b6= currTypeBaseRef_47a8;
					if( !isValidBound(boundObjs_47b1, typeBase_47a9, false))
						continue;
					currMatch.typeBase_47b7= typeBase_47a9;
					if( !isValidBound(boundObjs_47b1, dT_47aa, false))
						continue;
					currMatch.dT_47b8= dT_47aa;
					_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void CreateEventVar_478c::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newLocalVar_47b9= SFC::LocalVar::Create( currMatch.program_47b3);
		SFC::DT& DT= currMatch.dT_47b8;
		SFC::LocalVar& LocalVar= newLocalVar_47b9;
		SFC::Program& Program= currMatch.program_47b3;
		CyberComposition::Simulink::SFEvent& SFEvent= currMatch.sFEvent_47b5;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_47b2;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_47b4;
		CyberComposition::Simulink::SF_TypeBase& TypeBase= currMatch.typeBase_47b7;
		CyberComposition::Simulink::TypeBaseRef& TypeBaseRef= currMatch.typeBaseRef_47b6;
		{
LocalVar.RefId() = SFEvent.RefId();
};
		{
__int64 sc;
Program.GetIntValue("statementCount", sc);
LocalVar.SetIntValue("statementIndex", sc++);
Program.SetIntValue("statementCount", sc);
};
		{
LocalVar.name() = SFEvent.name();
LocalVar.initial() = "0";
LocalVar.scope() = StateLabel.comment();

SFManager::AddTypedEntityScope( LocalVar );
};
		newLocalVar_47b9.dt()= currMatch.dT_47b8;
		newLocalVar_47b9.SFevent()+= currMatch.sFEvent_47b5;
	}
}

void CheckStateDecomp_47bd::operator()( const Packets_t& states_47be, const Packets_t& programs_47c0, Packets_t& states_47c2, Packets_t& programs_47c3, Packets_t& states_47c4, Packets_t& programs_47c5)
{
#ifdef PRINT_INFO
	printLog( "CheckStateDecomp_47bd" );
#endif
	_state_47c6= &states_47c2;
	_program_47c7= &programs_47c3;
	_state_47c8= &states_47c4;
	_program_47c9= &programs_47c5;
	for( Packets_t::const_iterator itstate_47cb= states_47be.begin(), itprogram_47d2= programs_47c0.begin(); itstate_47cb!= states_47be.end(), itprogram_47d2!= programs_47c0.end(); ++itstate_47cb, ++itprogram_47d2)
	{
		bool isUnique= isInputUnique( *itstate_47cb, *itprogram_47d2);
		if( !isUnique)
			continue;
		Packets_t onestate_47cf( 1, *itstate_47cb);
		Packets_t oneprogram_47d6( 1, *itprogram_47d2);
		executeOne( onestate_47cf, oneprogram_47d6);
	}
}

void CheckStateDecomp_47bd::executeOne( const Packets_t& states_47be, const Packets_t& programs_47c0)
{
	Packets_t sFStates_47db;
	Packets_t programs_47de;
	IsFuncState_47d8 isFuncState_47d8;
	bool isMatchIsFuncState_47d8= isFuncState_47d8( states_47be, programs_47c0, sFStates_47db, programs_47de);
	_state_47c6->insert( _state_47c6->end(), sFStates_47db.begin(), sFStates_47db.end());
	_program_47c7->insert( _program_47c7->end(), programs_47de.begin(), programs_47de.end());
	if( isMatchIsFuncState_47d8)
		return;
	Packets_t sFStates_4802;
	Packets_t programs_4805;
	Otherwise_47ff otherwise_47ff;
	bool isMatchOtherwise_47ff= otherwise_47ff( states_47be, programs_47c0, sFStates_4802, programs_4805);
	_state_47c8->insert( _state_47c8->end(), sFStates_4802.begin(), sFStates_4802.end());
	_program_47c9->insert( _program_47c9->end(), programs_4805.begin(), programs_4805.end());
}

bool CheckStateDecomp_47bd::isInputUnique( const Udm::Object& state_47cc, const Udm::Object& program_47d3)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_47ce= _state_47ca.begin(), itprogram_47d5= _program_47d1.begin(); itstate_47ce!= _state_47ca.end(), itprogram_47d5!= _program_47d1.end(); ++itstate_47ce, ++itprogram_47d5)
	{
		if( ( *itstate_47ce== state_47cc)&& ( *itprogram_47d5== program_47d3))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_47ca.push_back( state_47cc);
		_program_47d1.push_back( program_47d3);
	}
	return isUnique;
}

bool IsFuncState_47d8::operator()( const Packets_t& sFStates_47d9, const Packets_t& programs_47dc, Packets_t& sFStates_47db, Packets_t& programs_47de)
{
#ifdef PRINT_INFO
	printLog( "IsFuncState_47d8" );
#endif
	_sFState_47df= &sFStates_47db;
	_program_47e0= &programs_47de;
	processInputPackets( sFStates_47d9, programs_47dc);
	if( false== _matches.empty())
		return true;
	return false;
}

bool IsFuncState_47d8::isInputUnique( const Udm::Object& sFState_47e5, const Udm::Object& program_47ee)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_47e7= _sFState_47e1.begin(), itProgram_47f0= _program_47ea.begin(); itSFState_47e7!= _sFState_47e1.end(), itProgram_47f0!= _program_47ea.end(); ++itSFState_47e7, ++itProgram_47f0)
	{
		if( ( *itSFState_47e7== sFState_47e5)&& ( *itProgram_47f0== program_47ee))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_47e1.push_back( sFState_47e5);
		_program_47ea.push_back( program_47ee);
	}
	return isUnique;
}

bool IsFuncState_47d8::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool IsFuncState_47d8::isGuardTrue( SFC::CompoundStatement& Program, CyberComposition::Simulink::SFState& SFState)
{
	bool Gz_guard= false;
	return static_cast< std::string >( SFState.Decomposition() ) == "FUNC_STATE";;
	return Gz_guard;
}

void IsFuncState_47d8::processInputPackets( const Packets_t& sFStates_47d9, const Packets_t& programs_47dc)
{
	for( Packets_t::const_iterator itSFState_47e2= sFStates_47d9.begin(), itProgram_47eb= programs_47dc.begin(); itSFState_47e2!= sFStates_47d9.end(), itProgram_47eb!= programs_47dc.end(); ++itSFState_47e2, ++itProgram_47eb)
	{
		bool isUnique= isInputUnique( *itSFState_47e2, *itProgram_47eb);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_47e2, *itProgram_47eb);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_47f7, currMatch.program_47f8);
	}
}

bool IsFuncState_47d8::patternMatcher( const Udm::Object& sFState_47e3, const Udm::Object& program_47ec)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_47e3.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_47e8= CyberComposition::Simulink::SFState::Cast( sFState_47e3);
		if( false== Uml::IsDerivedFrom( program_47ec.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement program_47f1= SFC::CompoundStatement::Cast( program_47ec);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_47f6;
		if( !isValidBound(boundObjs_47f6, sFState_47e8, true))
			continue;
		currMatch.sFState_47f7= sFState_47e8;
		if( !isValidBound(boundObjs_47f6, program_47f1, true))
			continue;
		currMatch.program_47f8= program_47f1;
		bool Gz_guard= isGuardTrue( currMatch.program_47f8, currMatch.sFState_47f7);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void IsFuncState_47d8::outputAppender( const CyberComposition::Simulink::SFState& sFState_47fb, const SFC::CompoundStatement& program_47fd)
{
	_sFState_47df->push_back( sFState_47fb);
	_program_47e0->push_back( program_47fd);
}

bool Otherwise_47ff::operator()( const Packets_t& sFStates_4800, const Packets_t& programs_4803, Packets_t& sFStates_4802, Packets_t& programs_4805)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_47ff" );
#endif
	_sFState_4806= &sFStates_4802;
	_program_4807= &programs_4805;
	processInputPackets( sFStates_4800, programs_4803);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_47ff::isInputUnique( const Udm::Object& sFState_480c, const Udm::Object& program_4815)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_480e= _sFState_4808.begin(), itProgram_4817= _program_4811.begin(); itSFState_480e!= _sFState_4808.end(), itProgram_4817!= _program_4811.end(); ++itSFState_480e, ++itProgram_4817)
	{
		if( ( *itSFState_480e== sFState_480c)&& ( *itProgram_4817== program_4815))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4808.push_back( sFState_480c);
		_program_4811.push_back( program_4815);
	}
	return isUnique;
}

bool Otherwise_47ff::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_47ff::processInputPackets( const Packets_t& sFStates_4800, const Packets_t& programs_4803)
{
	for( Packets_t::const_iterator itSFState_4809= sFStates_4800.begin(), itProgram_4812= programs_4803.begin(); itSFState_4809!= sFStates_4800.end(), itProgram_4812!= programs_4803.end(); ++itSFState_4809, ++itProgram_4812)
	{
		bool isUnique= isInputUnique( *itSFState_4809, *itProgram_4812);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4809, *itProgram_4812);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_481e, currMatch.program_481f);
	}
}

bool Otherwise_47ff::patternMatcher( const Udm::Object& sFState_480a, const Udm::Object& program_4813)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_480a.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_480f= CyberComposition::Simulink::SFState::Cast( sFState_480a);
		if( false== Uml::IsDerivedFrom( program_4813.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement program_4818= SFC::CompoundStatement::Cast( program_4813);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_481d;
		if( !isValidBound(boundObjs_481d, sFState_480f, true))
			continue;
		currMatch.sFState_481e= sFState_480f;
		if( !isValidBound(boundObjs_481d, program_4818, true))
			continue;
		currMatch.program_481f= program_4818;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_47ff::outputAppender( const CyberComposition::Simulink::SFState& sFState_4820, const SFC::CompoundStatement& program_4822)
{
	_sFState_4806->push_back( sFState_4820);
	_program_4807->push_back( program_4822);
}

void CreateFuncStateFunctions_4833::operator()( const Packets_t& states_4834, const Packets_t& programs_4836, Packets_t& states_4838, Packets_t& programs_4839)
{
#ifdef PRINT_INFO
	printLog( "CreateFuncStateFunctions_4833" );
#endif
	_state_483a= &states_4838;
	_program_483b= &programs_4839;
	if( ( !states_4834.empty())&& ( !programs_4836.empty()))
		callPopulateGRFSFunction_4988( states_4834, programs_4836);
	_state_483a->insert( _state_483a->end(), states_4834.begin(), states_4834.end());
	_program_483b->insert( _program_483b->end(), programs_4836.begin(), programs_4836.end());
}

void CreateFuncStateFunctions_4833::callPopulateGRFSFunction_4988( const Packets_t& states_494b, const Packets_t& programs_494d)
{
	Packets_t states_494f;
	Packets_t programs_4950;
	PopulateGRFSFunction_494a populateGRFSFunction_494a;
	populateGRFSFunction_494a( states_494b, programs_494d, states_494f, programs_4950);
	if( ( !states_494f.empty())&& ( !programs_4950.empty()))
		callPopulateEMFSFunction_498b( states_494f, programs_4950);
}

void CreateFuncStateFunctions_4833::callPopulateEMFSFunction_498b( const Packets_t& states_483d, const Packets_t& programs_483f)
{
	Packets_t states_4841;
	Packets_t programs_4842;
	PopulateEMFSFunction_483c populateEMFSFunction_483c;
	populateEMFSFunction_483c( states_483d, programs_483f, states_4841, programs_4842);
	if( ( !states_4841.empty())&& ( !programs_4842.empty()))
		callGetSubStates_498e( states_4841, programs_4842);
}

void CreateFuncStateFunctions_4833::callGetSubStates_498e( const Packets_t& sFStates_4223, const Packets_t& parStmnts_4226)
{
	Packets_t sFSubStates_4225;
	Packets_t parStmnts_4228;
	GetSubStates_4222 getSubStates_4222;
	getSubStates_4222( sFStates_4223, parStmnts_4226, sFSubStates_4225, parStmnts_4228);
	if( ( !sFSubStates_4225.empty())&& ( !parStmnts_4228.empty()))
		callPopulateGRFSFunction_4988( sFSubStates_4225, parStmnts_4228);
}

void PopulateEMFSFunction_483c::operator()( const Packets_t& states_483d, const Packets_t& programs_483f, Packets_t& states_4841, Packets_t& programs_4842)
{
#ifdef PRINT_INFO
	printLog( "PopulateEMFSFunction_483c" );
#endif
	_state_4843= &states_4841;
	_program_4844= &programs_4842;
	_state_4843->insert( _state_4843->end(), states_483d.begin(), states_483d.end());
	_program_4844->insert( _program_4844->end(), programs_483f.begin(), programs_483f.end());
	if( ( !states_483d.empty())&& ( !programs_483f.empty()))
		callCreateEMFuncStateFunction_4944( states_483d, programs_483f);
}

void PopulateEMFSFunction_483c::callCreateEMFuncStateFunction_4944( const Packets_t& sFStates_4846, const Packets_t& programs_4849)
{
	Packets_t sFStates_4848;
	Packets_t execs_484b;
	CreateEMFuncStateFunction_4845 createEMFuncStateFunction_4845;
	createEMFuncStateFunction_4845( sFStates_4846, programs_4849, sFStates_4848, execs_484b);
	if( ( !sFStates_4848.empty())&& ( !execs_484b.empty()))
		callFuncArgsAndVars_4947( sFStates_4848, execs_484b);
}

void PopulateEMFSFunction_483c::callFuncArgsAndVars_4947( const Packets_t& states_4873, const Packets_t& fcns_4875)
{
	Packets_t states_4877;
	Packets_t fcns_4878;
	FuncArgsAndVars_4872 funcArgsAndVars_4872;
	funcArgsAndVars_4872( states_4873, fcns_4875, states_4877, fcns_4878);
}

void CreateEMFuncStateFunction_4845::operator()( const Packets_t& sFStates_4846, const Packets_t& programs_4849, Packets_t& sFStates_4848, Packets_t& execs_484b)
{
#ifdef PRINT_INFO
	printLog( "CreateEMFuncStateFunction_4845" );
#endif
	RTTGenerator::Instance()->generateRule(3883, "CreateEMFuncStateFunction");
	_sFState_484c= &sFStates_4848;
	_exec_484d= &execs_484b;
	processInputPackets( sFStates_4846, programs_4849);
}

bool CreateEMFuncStateFunction_4845::isInputUnique( const Udm::Object& sFState_4852, const Udm::Object& program_485b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4854= _sFState_484e.begin(), itProgram_485d= _program_4857.begin(); itSFState_4854!= _sFState_484e.end(), itProgram_485d!= _program_4857.end(); ++itSFState_4854, ++itProgram_485d)
	{
		if( ( *itSFState_4854== sFState_4852)&& ( *itProgram_485d== program_485b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_484e.push_back( sFState_4852);
		_program_4857.push_back( program_485b);
	}
	return isUnique;
}

bool CreateEMFuncStateFunction_4845::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool CreateEMFuncStateFunction_4845::isGuardTrue( SFC::Program& Program, CyberComposition::Simulink::SFState& SFState, SFC::StateLabel& StateLabel)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( SFState.Decomposition() ) == "FUNC_STATE" &&
 static_cast< std::string >( SFState.Order() ) == "-2";;
	return Gz_guard;
}

void CreateEMFuncStateFunction_4845::processInputPackets( const Packets_t& sFStates_4846, const Packets_t& programs_4849)
{
	for( Packets_t::const_iterator itSFState_484f= sFStates_4846.begin(), itProgram_4858= programs_4849.begin(); itSFState_484f!= sFStates_4846.end(), itProgram_4858!= programs_4849.end(); ++itSFState_484f, ++itProgram_4858)
	{
		bool isUnique= isInputUnique( *itSFState_484f, *itProgram_4858);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_484f, *itProgram_4858);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateEMFuncStateFunction_4845::patternMatcher( const Udm::Object& sFState_4850, const Udm::Object& program_4859)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4850.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4855= CyberComposition::Simulink::SFState::Cast( sFState_4850);
		if( false== Uml::IsDerivedFrom( program_4859.type(), SFC::Program::meta))
			continue;
		SFC::Program program_485e= SFC::Program::Cast( program_4859);
		set< SFC::StateLabel> stateLabels_4860= sFState_4855.src();
		for( set< SFC::StateLabel>::const_iterator itStateLabels_4861= stateLabels_4860.begin(); itStateLabels_4861!= stateLabels_4860.end(); ++itStateLabels_4861)
		{
			SFC::StateLabel currStateLabel_4862= *itStateLabels_4861;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_4866;
			if( !isValidBound(boundObjs_4866, sFState_4855, true))
				continue;
			currMatch.sFState_4867= sFState_4855;
			if( !isValidBound(boundObjs_4866, program_485e, true))
				continue;
			currMatch.program_4868= program_485e;
			if( !isValidBound(boundObjs_4866, currStateLabel_4862, false))
				continue;
			currMatch.stateLabel_4869= currStateLabel_4862;
			bool Gz_guard= isGuardTrue( currMatch.program_4868, currMatch.sFState_4867, currMatch.stateLabel_4869);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateEMFuncStateFunction_4845::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function newExec_486d= SFC::Function::Create( currMatch.program_4868, SFC::Program::meta_stmnt);
		SFC::Function& Exec= newExec_486d;
		SFC::Program& Program= currMatch.program_4868;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_4867;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_4869;
		{
Exec.RefId() = SFState.RefId();
};
		{
__int64 statementCount = Program.statementCount();
Exec.statementIndex() = statementCount++;
Program.statementCount() = statementCount;
};
		{
Exec.name() = SFState.name();
Exec.scope() = StateLabel.comment();

SFManager::FunctionArgMapManager::get_singleton().parseFunctionSpec( Exec, SFState.EnterAction() );

SFManager::AddTypedEntityScope( Exec );
};
		newExec_486d.SFexecSt()+= currMatch.sFState_4867;
		outputAppender( currMatch.sFState_4867, newExec_486d);
	}
}

void CreateEMFuncStateFunction_4845::outputAppender( const CyberComposition::Simulink::SFState& sFState_486e, const SFC::Function& exec_4870)
{
	_sFState_484c->push_back( sFState_486e);
	_exec_484d->push_back( exec_4870);
}

void FuncArgsAndVars_4872::operator()( const Packets_t& states_4873, const Packets_t& fcns_4875, Packets_t& states_4877, Packets_t& fcns_4878)
{
#ifdef PRINT_INFO
	printLog( "FuncArgsAndVars_4872" );
#endif
	_state_4879= &states_4877;
	_fcn_487a= &fcns_4878;
	if( ( !states_4873.empty())&& ( !fcns_4875.empty()))
		callFuncInputArgs_493b( states_4873, fcns_4875);
}

void FuncArgsAndVars_4872::callFuncInputArgs_493b( const Packets_t& states_48bd, const Packets_t& fcns_48bf)
{
	Packets_t states_48c1;
	Packets_t fcns_48c2;
	FuncInputArgs_48bc funcInputArgs_48bc;
	funcInputArgs_48bc( states_48bd, fcns_48bf, states_48c1, fcns_48c2);
	if( ( !states_48c1.empty())&& ( !fcns_48c2.empty()))
		callFuncOutputArgs_493e( states_48c1, fcns_48c2);
}

void FuncArgsAndVars_4872::callFuncOutputArgs_493e( const Packets_t& states_487c, const Packets_t& fcns_487e)
{
	Packets_t states_4880;
	Packets_t fcns_4881;
	FuncOutputArgs_487b funcOutputArgs_487b;
	funcOutputArgs_487b( states_487c, fcns_487e, states_4880, fcns_4881);
	if( ( !states_4880.empty())&& ( !fcns_4881.empty()))
		callFuncLocalVars_4941( states_4880, fcns_4881);
}

void FuncArgsAndVars_4872::callFuncLocalVars_4941( const Packets_t& states_48fb, const Packets_t& fcns_48fd)
{
	Packets_t states_48ff;
	Packets_t fcns_4900;
	FuncLocalVars_48fa funcLocalVars_48fa;
	funcLocalVars_48fa( states_48fb, fcns_48fd, states_48ff, fcns_4900);
	_state_4879->insert( _state_4879->end(), states_48ff.begin(), states_48ff.end());
	_fcn_487a->insert( _fcn_487a->end(), fcns_4900.begin(), fcns_4900.end());
}

void FuncOutputArgs_487b::operator()( const Packets_t& states_487c, const Packets_t& fcns_487e, Packets_t& states_4880, Packets_t& fcns_4881)
{
#ifdef PRINT_INFO
	printLog( "FuncOutputArgs_487b" );
#endif
	_state_4882= &states_4880;
	_fcn_4883= &fcns_4881;
	_state_4882->insert( _state_4882->end(), states_487c.begin(), states_487c.end());
	_fcn_4883->insert( _fcn_4883->end(), fcns_487e.begin(), fcns_487e.end());
	if( ( !states_487c.empty())&& ( !fcns_487e.empty()))
		callOutputArgs_48b9( states_487c, fcns_487e);
}

void FuncOutputArgs_487b::callOutputArgs_48b9( const Packets_t& sFStates_4885, const Packets_t& execs_4887)
{
	OutputArgs_4884 outputArgs_4884;
	outputArgs_4884( sFStates_4885, execs_4887);
}

void OutputArgs_4884::operator()( const Packets_t& sFStates_4885, const Packets_t& execs_4887)
{
#ifdef PRINT_INFO
	printLog( "OutputArgs_4884" );
#endif
	RTTGenerator::Instance()->generateRule(3926, "OutputArgs");
	processInputPackets( sFStates_4885, execs_4887);
}

bool OutputArgs_4884::isInputUnique( const Udm::Object& sFState_488d, const Udm::Object& exec_4896)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_488f= _sFState_4889.begin(), itExec_4898= _exec_4892.begin(); itSFState_488f!= _sFState_4889.end(), itExec_4898!= _exec_4892.end(); ++itSFState_488f, ++itExec_4898)
	{
		if( ( *itSFState_488f== sFState_488d)&& ( *itExec_4898== exec_4896))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4889.push_back( sFState_488d);
		_exec_4892.push_back( exec_4896);
	}
	return isUnique;
}

bool OutputArgs_4884::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool OutputArgs_4884::isGuardTrue( SFC::DT& DT, SFC::Function& Exec, CyberComposition::Simulink::SFData& SFData, CyberComposition::Simulink::SFState& SFState, SFC::StateLabel& StateLabel, CyberComposition::Simulink::SF_TypeBase& TypeBase, CyberComposition::Simulink::TypeBaseRef& TypeBaseRef)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( SFData.Scope() ) == "OUTPUT_DATA";;
	return Gz_guard;
}

void OutputArgs_4884::processInputPackets( const Packets_t& sFStates_4885, const Packets_t& execs_4887)
{
	for( Packets_t::const_iterator itSFState_488a= sFStates_4885.begin(), itExec_4893= execs_4887.begin(); itSFState_488a!= sFStates_4885.end(), itExec_4893!= execs_4887.end(); ++itSFState_488a, ++itExec_4893)
	{
		bool isUnique= isInputUnique( *itSFState_488a, *itExec_4893);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_488a, *itExec_4893);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool OutputArgs_4884::patternMatcher( const Udm::Object& sFState_488b, const Udm::Object& exec_4894)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_488b.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4890= CyberComposition::Simulink::SFState::Cast( sFState_488b);
		if( false== Uml::IsDerivedFrom( exec_4894.type(), SFC::Function::meta))
			continue;
		SFC::Function exec_4899= SFC::Function::Cast( exec_4894);
		set< CyberComposition::Simulink::SFData> sFDatas_489b= sFState_4890.SFData_kind_children();
		for( set< CyberComposition::Simulink::SFData>::const_iterator itSFData_489c= sFDatas_489b.begin(); itSFData_489c!= sFDatas_489b.end(); ++itSFData_489c)
		{
			CyberComposition::Simulink::SFData currSFData_489d= *itSFData_489c;
			set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_489e= currSFData_489d.TypeBaseRef_kind_children();
			for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_489f= typeBaseRefs_489e.begin(); itTypeBaseRef_489f!= typeBaseRefs_489e.end(); ++itTypeBaseRef_489f)
			{
				CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_48a0= *itTypeBaseRef_489f;
				set< SFC::StateLabel> stateLabels_48a1= sFState_4890.src();
				for( set< SFC::StateLabel>::const_iterator itStateLabels_48a2= stateLabels_48a1.begin(); itStateLabels_48a2!= stateLabels_48a1.end(); ++itStateLabels_48a2)
				{
					SFC::StateLabel currStateLabel_48a3= *itStateLabels_48a2;
					CyberComposition::Simulink::SF_TypeBase typeBase_48a4= currTypeBaseRef_48a0.ref();
					if( !typeBase_48a4)
						continue;
					SFC::DT dT_48a5= typeBase_48a4.dt();
					if( !dT_48a5)
						continue;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_48a9;
					if( !isValidBound(boundObjs_48a9, sFState_4890, true))
						continue;
					currMatch.sFState_48aa= sFState_4890;
					if( !isValidBound(boundObjs_48a9, exec_4899, true))
						continue;
					currMatch.exec_48ab= exec_4899;
					if( !isValidBound(boundObjs_48a9, currStateLabel_48a3, false))
						continue;
					currMatch.stateLabel_48ac= currStateLabel_48a3;
					if( !isValidBound(boundObjs_48a9, currSFData_489d, false))
						continue;
					currMatch.sFData_48ad= currSFData_489d;
					if( !isValidBound(boundObjs_48a9, currTypeBaseRef_48a0, false))
						continue;
					currMatch.typeBaseRef_48ae= currTypeBaseRef_48a0;
					if( !isValidBound(boundObjs_48a9, typeBase_48a4, false))
						continue;
					currMatch.typeBase_48af= typeBase_48a4;
					if( !isValidBound(boundObjs_48a9, dT_48a5, false))
						continue;
					currMatch.dT_48b0= dT_48a5;
					bool Gz_guard= isGuardTrue( currMatch.dT_48b0, currMatch.exec_48ab, currMatch.sFData_48ad, currMatch.sFState_48aa, currMatch.stateLabel_48ac, currMatch.typeBase_48af, currMatch.typeBaseRef_48ae);
					if( true== Gz_guard)
						_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void OutputArgs_4884::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg newArg_48b8= SFC::Arg::Create( currMatch.exec_48ab);
		SFC::Arg& Arg= newArg_48b8;
		SFC::DT& DT= currMatch.dT_48b0;
		SFC::Function& Exec= currMatch.exec_48ab;
		CyberComposition::Simulink::SFData& SFData= currMatch.sFData_48ad;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_48aa;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_48ac;
		CyberComposition::Simulink::SF_TypeBase& TypeBase= currMatch.typeBase_48af;
		CyberComposition::Simulink::TypeBaseRef& TypeBaseRef= currMatch.typeBaseRef_48ae;
		{
Arg.RefId() = SFData.RefId();
};
		{
std::string name = SFData.name();
Arg.name() = name;
Arg.scope() = StateLabel.comment(); /* comment contains the extend state name */
Arg.argIndex() = SFManager::FunctionArgMapManager::get_singleton().getArgNo( Exec, name );
Arg.indexBase() = SFData.ArrayFirstIndex();
Arg.ptr() = true;

Exec.argCount() = Exec.argCount() + 1;

SFManager::AddTypedEntityScope( Arg );
};
		newArg_48b8.dt()= currMatch.dT_48b0;
	}
}

void FuncInputArgs_48bc::operator()( const Packets_t& states_48bd, const Packets_t& fcns_48bf, Packets_t& states_48c1, Packets_t& fcns_48c2)
{
#ifdef PRINT_INFO
	printLog( "FuncInputArgs_48bc" );
#endif
	_state_48c3= &states_48c1;
	_fcn_48c4= &fcns_48c2;
	_state_48c3->insert( _state_48c3->end(), states_48bd.begin(), states_48bd.end());
	_fcn_48c4->insert( _fcn_48c4->end(), fcns_48bf.begin(), fcns_48bf.end());
	if( ( !states_48bd.empty())&& ( !fcns_48bf.empty()))
		callInputArgs_48f7( states_48bd, fcns_48bf);
}

void FuncInputArgs_48bc::callInputArgs_48f7( const Packets_t& sFStates_48c6, const Packets_t& execs_48c8)
{
	InputArgs_48c5 inputArgs_48c5;
	inputArgs_48c5( sFStates_48c6, execs_48c8);
}

void InputArgs_48c5::operator()( const Packets_t& sFStates_48c6, const Packets_t& execs_48c8)
{
#ifdef PRINT_INFO
	printLog( "InputArgs_48c5" );
#endif
	RTTGenerator::Instance()->generateRule(3949, "InputArgs");
	processInputPackets( sFStates_48c6, execs_48c8);
}

bool InputArgs_48c5::isInputUnique( const Udm::Object& sFState_48ce, const Udm::Object& exec_48d7)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_48d0= _sFState_48ca.begin(), itExec_48d9= _exec_48d3.begin(); itSFState_48d0!= _sFState_48ca.end(), itExec_48d9!= _exec_48d3.end(); ++itSFState_48d0, ++itExec_48d9)
	{
		if( ( *itSFState_48d0== sFState_48ce)&& ( *itExec_48d9== exec_48d7))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_48ca.push_back( sFState_48ce);
		_exec_48d3.push_back( exec_48d7);
	}
	return isUnique;
}

bool InputArgs_48c5::isGuardTrue( SFC::DT& DT, SFC::Function& Exec, CyberComposition::Simulink::SFData& SFData, CyberComposition::Simulink::SFState& SFState, SFC::StateLabel& StateLabel, CyberComposition::Simulink::SF_TypeBase& TypeBase, CyberComposition::Simulink::TypeBaseRef& TypeBaseRef)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( SFData.Scope() ) == "INPUT_DATA";;
	return Gz_guard;
}

void InputArgs_48c5::processInputPackets( const Packets_t& sFStates_48c6, const Packets_t& execs_48c8)
{
	for( Packets_t::const_iterator itSFState_48cb= sFStates_48c6.begin(), itExec_48d4= execs_48c8.begin(); itSFState_48cb!= sFStates_48c6.end(), itExec_48d4!= execs_48c8.end(); ++itSFState_48cb, ++itExec_48d4)
	{
		bool isUnique= isInputUnique( *itSFState_48cb, *itExec_48d4);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_48cb, *itExec_48d4);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InputArgs_48c5::patternMatcher( const Udm::Object& sFState_48cc, const Udm::Object& exec_48d5)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_48cc.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_48d1= CyberComposition::Simulink::SFState::Cast( sFState_48cc);
		if( false== Uml::IsDerivedFrom( exec_48d5.type(), SFC::Function::meta))
			continue;
		SFC::Function exec_48da= SFC::Function::Cast( exec_48d5);
		set< CyberComposition::Simulink::SFData> sFDatas_48dc= sFState_48d1.SFData_kind_children();
		for( set< CyberComposition::Simulink::SFData>::const_iterator itSFData_48dd= sFDatas_48dc.begin(); itSFData_48dd!= sFDatas_48dc.end(); ++itSFData_48dd)
		{
			CyberComposition::Simulink::SFData currSFData_48de= *itSFData_48dd;
			set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_48df= currSFData_48de.TypeBaseRef_kind_children();
			for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_48e0= typeBaseRefs_48df.begin(); itTypeBaseRef_48e0!= typeBaseRefs_48df.end(); ++itTypeBaseRef_48e0)
			{
				CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_48e1= *itTypeBaseRef_48e0;
				set< SFC::StateLabel> stateLabels_48e2= sFState_48d1.src();
				for( set< SFC::StateLabel>::const_iterator itStateLabels_48e3= stateLabels_48e2.begin(); itStateLabels_48e3!= stateLabels_48e2.end(); ++itStateLabels_48e3)
				{
					SFC::StateLabel currStateLabel_48e4= *itStateLabels_48e3;
					CyberComposition::Simulink::SF_TypeBase typeBase_48e5= currTypeBaseRef_48e1.ref();
					if( !typeBase_48e5)
						continue;
					SFC::DT dT_48e6= typeBase_48e5.dt();
					if( !dT_48e6)
						continue;
					Match currMatch;
					currMatch.sFState_48e8= sFState_48d1;
					currMatch.exec_48e9= exec_48da;
					currMatch.stateLabel_48ea= currStateLabel_48e4;
					currMatch.sFData_48eb= currSFData_48de;
					currMatch.typeBaseRef_48ec= currTypeBaseRef_48e1;
					currMatch.typeBase_48ed= typeBase_48e5;
					currMatch.dT_48ee= dT_48e6;
					bool Gz_guard= isGuardTrue( currMatch.dT_48ee, currMatch.exec_48e9, currMatch.sFData_48eb, currMatch.sFState_48e8, currMatch.stateLabel_48ea, currMatch.typeBase_48ed, currMatch.typeBaseRef_48ec);
					if( true== Gz_guard)
						_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void InputArgs_48c5::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg newArg_48f6= SFC::Arg::Create( currMatch.exec_48e9);
		SFC::Arg& Arg= newArg_48f6;
		SFC::DT& DT= currMatch.dT_48ee;
		SFC::Function& Exec= currMatch.exec_48e9;
		CyberComposition::Simulink::SFData& SFData= currMatch.sFData_48eb;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_48e8;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_48ea;
		CyberComposition::Simulink::SF_TypeBase& TypeBase= currMatch.typeBase_48ed;
		CyberComposition::Simulink::TypeBaseRef& TypeBaseRef= currMatch.typeBaseRef_48ec;
		{
Arg.RefId() = SFData.RefId();
};
		{
std::string name = SFData.name();
Arg.name() = name;
Arg.scope() = StateLabel.comment(); /* comment contains the extend state name */
Arg.argIndex() = SFManager::FunctionArgMapManager::get_singleton().getArgNo( Exec, name );
Arg.indexBase() = SFData.ArrayFirstIndex();

Exec.argCount() = Exec.argCount() + 1;

SFManager::AddTypedEntityScope( Arg );
};
		newArg_48f6.dt()= currMatch.dT_48ee;
	}
}

void FuncLocalVars_48fa::operator()( const Packets_t& states_48fb, const Packets_t& fcns_48fd, Packets_t& states_48ff, Packets_t& fcns_4900)
{
#ifdef PRINT_INFO
	printLog( "FuncLocalVars_48fa" );
#endif
	_state_4901= &states_48ff;
	_fcn_4902= &fcns_4900;
	if( ( !states_48fb.empty())&& ( !fcns_48fd.empty()))
		callFuncLocalVars_4938( states_48fb, fcns_48fd);
	_state_4901->insert( _state_4901->end(), states_48fb.begin(), states_48fb.end());
	_fcn_4902->insert( _fcn_4902->end(), fcns_48fd.begin(), fcns_48fd.end());
}

void FuncLocalVars_48fa::callFuncLocalVars_4938( const Packets_t& sFStates_4904, const Packets_t& execs_4906)
{
	FuncLocalVars_4903 funcLocalVars_4903;
	funcLocalVars_4903( sFStates_4904, execs_4906);
}

void FuncLocalVars_4903::operator()( const Packets_t& sFStates_4904, const Packets_t& execs_4906)
{
#ifdef PRINT_INFO
	printLog( "FuncLocalVars_4903" );
#endif
	RTTGenerator::Instance()->generateRule(3972, "FuncLocalVars");
	processInputPackets( sFStates_4904, execs_4906);
}

bool FuncLocalVars_4903::isInputUnique( const Udm::Object& sFState_490c, const Udm::Object& exec_4915)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_490e= _sFState_4908.begin(), itExec_4917= _exec_4911.begin(); itSFState_490e!= _sFState_4908.end(), itExec_4917!= _exec_4911.end(); ++itSFState_490e, ++itExec_4917)
	{
		if( ( *itSFState_490e== sFState_490c)&& ( *itExec_4917== exec_4915))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4908.push_back( sFState_490c);
		_exec_4911.push_back( exec_4915);
	}
	return isUnique;
}

bool FuncLocalVars_4903::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool FuncLocalVars_4903::isGuardTrue( SFC::DT& DT, SFC::Function& Exec, CyberComposition::Simulink::SFData& SFData, CyberComposition::Simulink::SFState& SFState, SFC::StateLabel& StateLabel, CyberComposition::Simulink::SF_TypeBase& TypeBase, CyberComposition::Simulink::TypeBaseRef& TypeBaseRef)
{
	bool Gz_guard= false;
	std::string scope = SFData.Scope();
Gz_guard = ((scope != "INPUT_DATA") && (scope != "OUTPUT_DATA"));;
	return Gz_guard;
}

void FuncLocalVars_4903::processInputPackets( const Packets_t& sFStates_4904, const Packets_t& execs_4906)
{
	for( Packets_t::const_iterator itSFState_4909= sFStates_4904.begin(), itExec_4912= execs_4906.begin(); itSFState_4909!= sFStates_4904.end(), itExec_4912!= execs_4906.end(); ++itSFState_4909, ++itExec_4912)
	{
		bool isUnique= isInputUnique( *itSFState_4909, *itExec_4912);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4909, *itExec_4912);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool FuncLocalVars_4903::patternMatcher( const Udm::Object& sFState_490a, const Udm::Object& exec_4913)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_490a.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_490f= CyberComposition::Simulink::SFState::Cast( sFState_490a);
		if( false== Uml::IsDerivedFrom( exec_4913.type(), SFC::Function::meta))
			continue;
		SFC::Function exec_4918= SFC::Function::Cast( exec_4913);
		set< CyberComposition::Simulink::SFData> sFDatas_491a= sFState_490f.SFData_kind_children();
		for( set< CyberComposition::Simulink::SFData>::const_iterator itSFData_491b= sFDatas_491a.begin(); itSFData_491b!= sFDatas_491a.end(); ++itSFData_491b)
		{
			CyberComposition::Simulink::SFData currSFData_491c= *itSFData_491b;
			set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_491d= currSFData_491c.TypeBaseRef_kind_children();
			for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_491e= typeBaseRefs_491d.begin(); itTypeBaseRef_491e!= typeBaseRefs_491d.end(); ++itTypeBaseRef_491e)
			{
				CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_491f= *itTypeBaseRef_491e;
				CyberComposition::Simulink::SF_TypeBase typeBase_4920= currTypeBaseRef_491f.ref();
				if( !typeBase_4920)
					continue;
				SFC::DT dT_4921= typeBase_4920.dt();
				if( !dT_4921)
					continue;
				set< SFC::StateLabel> stateLabels_4922= sFState_490f.src();
				for( set< SFC::StateLabel>::const_iterator itStateLabels_4923= stateLabels_4922.begin(); itStateLabels_4923!= stateLabels_4922.end(); ++itStateLabels_4923)
				{
					SFC::StateLabel currStateLabel_4924= *itStateLabels_4923;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_4928;
					if( !isValidBound(boundObjs_4928, sFState_490f, true))
						continue;
					currMatch.sFState_4929= sFState_490f;
					if( !isValidBound(boundObjs_4928, exec_4918, true))
						continue;
					currMatch.exec_492a= exec_4918;
					if( !isValidBound(boundObjs_4928, currStateLabel_4924, false))
						continue;
					currMatch.stateLabel_492b= currStateLabel_4924;
					if( !isValidBound(boundObjs_4928, currSFData_491c, false))
						continue;
					currMatch.sFData_492c= currSFData_491c;
					if( !isValidBound(boundObjs_4928, currTypeBaseRef_491f, false))
						continue;
					currMatch.typeBaseRef_492d= currTypeBaseRef_491f;
					if( !isValidBound(boundObjs_4928, typeBase_4920, false))
						continue;
					currMatch.typeBase_492e= typeBase_4920;
					if( !isValidBound(boundObjs_4928, dT_4921, false))
						continue;
					currMatch.dT_492f= dT_4921;
					bool Gz_guard= isGuardTrue( currMatch.dT_492f, currMatch.exec_492a, currMatch.sFData_492c, currMatch.sFState_4929, currMatch.stateLabel_492b, currMatch.typeBase_492e, currMatch.typeBaseRef_492d);
					if( true== Gz_guard)
						_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void FuncLocalVars_4903::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newLocalVar_4937= SFC::LocalVar::Create( currMatch.exec_492a, SFC::Function::meta_stmnt);
		SFC::DT& DT= currMatch.dT_492f;
		SFC::Function& Exec= currMatch.exec_492a;
		SFC::LocalVar& LocalVar= newLocalVar_4937;
		CyberComposition::Simulink::SFData& SFData= currMatch.sFData_492c;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_4929;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_492b;
		CyberComposition::Simulink::SF_TypeBase& TypeBase= currMatch.typeBase_492e;
		CyberComposition::Simulink::TypeBaseRef& TypeBaseRef= currMatch.typeBaseRef_492d;
		{
LocalVar.RefId() = SFData.RefId();
};
		{
std::string dataName = SFData.Name();
if(dataName.empty())
	dataName = SFData.name();
LocalVar.name() = dataName;
LocalVar.scope() = StateLabel.comment(); /* comment contains the extend state name */
LocalVar.initial() = SFData.InitialValue();
LocalVar.indexBase() = SFData.ArrayFirstIndex();

SFManager::AddTypedEntityScope( LocalVar );
};
		{
__int64 statementCount = Exec.statementCount();
LocalVar.statementIndex() = statementCount++;
Exec.statementCount() = statementCount;
};
		newLocalVar_4937.dt()= currMatch.dT_492f;
	}
}

void PopulateGRFSFunction_494a::operator()( const Packets_t& states_494b, const Packets_t& programs_494d, Packets_t& states_494f, Packets_t& programs_4950)
{
#ifdef PRINT_INFO
	printLog( "PopulateGRFSFunction_494a" );
#endif
	_state_4951= &states_494f;
	_program_4952= &programs_4950;
	if( ( !states_494b.empty())&& ( !programs_494d.empty()))
		callCreateGRFuncStateFunction_4982( states_494b, programs_494d);
	_state_4951->insert( _state_4951->end(), states_494b.begin(), states_494b.end());
	_program_4952->insert( _program_4952->end(), programs_494d.begin(), programs_494d.end());
}

void PopulateGRFSFunction_494a::callCreateGRFuncStateFunction_4982( const Packets_t& sFStates_4954, const Packets_t& programs_4957)
{
	Packets_t sFStates_4956;
	Packets_t execs_4959;
	CreateGRFuncStateFunction_4953 createGRFuncStateFunction_4953;
	createGRFuncStateFunction_4953( sFStates_4954, programs_4957, sFStates_4956, execs_4959);
	if( ( !sFStates_4956.empty())&& ( !execs_4959.empty()))
		callFuncArgsAndVars_4985( sFStates_4956, execs_4959);
}

void PopulateGRFSFunction_494a::callFuncArgsAndVars_4985( const Packets_t& states_4873, const Packets_t& fcns_4875)
{
	Packets_t states_4877;
	Packets_t fcns_4878;
	FuncArgsAndVars_4872 funcArgsAndVars_4872;
	funcArgsAndVars_4872( states_4873, fcns_4875, states_4877, fcns_4878);
}

void CreateGRFuncStateFunction_4953::operator()( const Packets_t& sFStates_4954, const Packets_t& programs_4957, Packets_t& sFStates_4956, Packets_t& execs_4959)
{
#ifdef PRINT_INFO
	printLog( "CreateGRFuncStateFunction_4953" );
#endif
	RTTGenerator::Instance()->generateRule(3899, "CreateGRFuncStateFunction");
	_sFState_495a= &sFStates_4956;
	_exec_495b= &execs_4959;
	processInputPackets( sFStates_4954, programs_4957);
}

bool CreateGRFuncStateFunction_4953::isInputUnique( const Udm::Object& sFState_4960, const Udm::Object& program_4969)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4962= _sFState_495c.begin(), itProgram_496b= _program_4965.begin(); itSFState_4962!= _sFState_495c.end(), itProgram_496b!= _program_4965.end(); ++itSFState_4962, ++itProgram_496b)
	{
		if( ( *itSFState_4962== sFState_4960)&& ( *itProgram_496b== program_4969))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_495c.push_back( sFState_4960);
		_program_4965.push_back( program_4969);
	}
	return isUnique;
}

bool CreateGRFuncStateFunction_4953::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool CreateGRFuncStateFunction_4953::isGuardTrue( SFC::Program& Program, CyberComposition::Simulink::SFState& SFState, SFC::StateLabel& StateLabel)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( SFState.Decomposition() ) == "FUNC_STATE" &&
 static_cast< std::string >( SFState.Order() ) == "-1";;
	return Gz_guard;
}

void CreateGRFuncStateFunction_4953::processInputPackets( const Packets_t& sFStates_4954, const Packets_t& programs_4957)
{
	for( Packets_t::const_iterator itSFState_495d= sFStates_4954.begin(), itProgram_4966= programs_4957.begin(); itSFState_495d!= sFStates_4954.end(), itProgram_4966!= programs_4957.end(); ++itSFState_495d, ++itProgram_4966)
	{
		bool isUnique= isInputUnique( *itSFState_495d, *itProgram_4966);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_495d, *itProgram_4966);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateGRFuncStateFunction_4953::patternMatcher( const Udm::Object& sFState_495e, const Udm::Object& program_4967)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_495e.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4963= CyberComposition::Simulink::SFState::Cast( sFState_495e);
		if( false== Uml::IsDerivedFrom( program_4967.type(), SFC::Program::meta))
			continue;
		SFC::Program program_496c= SFC::Program::Cast( program_4967);
		set< SFC::StateLabel> stateLabels_496e= sFState_4963.src();
		for( set< SFC::StateLabel>::const_iterator itStateLabels_496f= stateLabels_496e.begin(); itStateLabels_496f!= stateLabels_496e.end(); ++itStateLabels_496f)
		{
			SFC::StateLabel currStateLabel_4970= *itStateLabels_496f;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_4974;
			if( !isValidBound(boundObjs_4974, sFState_4963, true))
				continue;
			currMatch.sFState_4975= sFState_4963;
			if( !isValidBound(boundObjs_4974, program_496c, true))
				continue;
			currMatch.program_4976= program_496c;
			if( !isValidBound(boundObjs_4974, currStateLabel_4970, false))
				continue;
			currMatch.stateLabel_4977= currStateLabel_4970;
			bool Gz_guard= isGuardTrue( currMatch.program_4976, currMatch.sFState_4975, currMatch.stateLabel_4977);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateGRFuncStateFunction_4953::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function newExec_497b= SFC::Function::Create( currMatch.program_4976, SFC::Program::meta_stmnt);
		SFC::LocalVar newExecTCVar_497c= SFC::LocalVar::Create( newExec_497b, SFC::Function::meta_stmnt);
		SFC::LocalVar newExecHTPVar_497d= SFC::LocalVar::Create( newExec_497b, SFC::Function::meta_stmnt);
		SFC::Function& Exec= newExec_497b;
		SFC::LocalVar& ExecHTPVar= newExecHTPVar_497d;
		SFC::LocalVar& ExecTCVar= newExecTCVar_497c;
		SFC::Program& Program= currMatch.program_4976;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_4975;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_4977;
		{
Exec.RefId() = ExecHTPVar.RefId() = ExecTCVar.RefId() = SFState.RefId();
};
		{
ExecHTPVar.name() = "_HTPVar_";
ExecHTPVar.dt() = SFCTypesManager::getSingleton().getBasicType( "int32" );
ExecTCVar.name() = "_TCVar_";
ExecTCVar.dt() = SFCTypesManager::getSingleton().getBasicType( "int32" );
};
		{
__int64 statementCount = Exec.statementCount();
ExecTCVar.statementIndex() = statementCount++;
ExecHTPVar.statementIndex() = statementCount++;
Exec.statementCount() = statementCount;
};
		{
Exec.name() = SFState.name();
Exec.scope() = StateLabel.comment();

SFManager::FunctionArgMapManager::get_singleton().parseFunctionSpec( Exec, SFState.EnterAction() );

SFManager::AddTypedEntityScope( Exec );
};
		{
__int64 statementCount = Program.statementCount();
Exec.statementIndex() = statementCount++;
Program.statementCount() = statementCount;
};
		newExec_497b.SFexecSt()+= currMatch.sFState_4975;
		outputAppender( currMatch.sFState_4975, newExec_497b);
	}
}

void CreateGRFuncStateFunction_4953::outputAppender( const CyberComposition::Simulink::SFState& sFState_497e, const SFC::Function& exec_4980)
{
	_sFState_495a->push_back( sFState_497e);
	_exec_495b->push_back( exec_4980);
}

void PopulateFunctions_4991::operator()( const Packets_t& states_4992, const Packets_t& programs_4994, Packets_t& states_4996, Packets_t& programs_4997)
{
#ifdef PRINT_INFO
	printLog( "PopulateFunctions_4991" );
#endif
	_state_4998= &states_4996;
	_program_4999= &programs_4997;
	if( ( !states_4992.empty())&& ( !programs_4994.empty()))
		callNoFunctionStates_570a( states_4992, programs_4994);
	_state_4998->insert( _state_4998->end(), states_4992.begin(), states_4992.end());
	_program_4999->insert( _program_4999->end(), programs_4994.begin(), programs_4994.end());
}

void PopulateFunctions_4991::callNoFunctionStates_570a( const Packets_t& states_4c43, const Packets_t& programs_4c45)
{
	Packets_t states_4c47;
	Packets_t programs_4c48;
	NoFunctionStates_4c42 noFunctionStates_4c42;
	noFunctionStates_4c42( states_4c43, programs_4c45, states_4c47, programs_4c48);
	if( ( !states_4c47.empty())&& ( !programs_4c48.empty()))
		callPopulateEnterFunction_570d( states_4c47, programs_4c48);
}

void PopulateFunctions_4991::callPopulateEnterFunction_570d( const Packets_t& states_4c81, const Packets_t& programs_4c83)
{
	Packets_t states_4c85;
	Packets_t programs_4c86;
	PopulateEnterFunction_4c80 populateEnterFunction_4c80;
	populateEnterFunction_4c80( states_4c81, programs_4c83, states_4c85, programs_4c86);
	if( ( !states_4c85.empty())&& ( !programs_4c86.empty()))
		callPopulateExecFunction_5710( states_4c85, programs_4c86);
}

void PopulateFunctions_4991::callPopulateExecFunction_5710( const Packets_t& states_503d, const Packets_t& programs_503f)
{
	Packets_t states_5041;
	Packets_t programs_5042;
	PopulateExecFunction_503c populateExecFunction_503c;
	populateExecFunction_503c( states_503d, programs_503f, states_5041, programs_5042);
	if( ( !states_5041.empty())&& ( !programs_5042.empty()))
		callPopulateExitFunction_5713( states_5041, programs_5042);
}

void PopulateFunctions_4991::callPopulateExitFunction_5713( const Packets_t& states_54e4, const Packets_t& programs_54e6)
{
	Packets_t states_54e8;
	Packets_t programs_54e9;
	PopulateExitFunction_54e3 populateExitFunction_54e3;
	populateExitFunction_54e3( states_54e4, programs_54e6, states_54e8, programs_54e9);
	if( ( !states_54e8.empty())&& ( !programs_54e9.empty()))
		callPopulateStatusFunction_5716( states_54e8, programs_54e9);
}

void PopulateFunctions_4991::callPopulateStatusFunction_5716( const Packets_t& states_499b, const Packets_t& programs_499d)
{
	Packets_t states_499f;
	Packets_t programs_49a0;
	PopulateStatusFunction_499a populateStatusFunction_499a;
	populateStatusFunction_499a( states_499b, programs_499d, states_499f, programs_49a0);
	if( ( !states_499f.empty())&& ( !programs_49a0.empty()))
		callGetSubStates_5719( states_499f, programs_49a0);
}

void PopulateFunctions_4991::callGetSubStates_5719( const Packets_t& sFStates_4223, const Packets_t& parStmnts_4226)
{
	Packets_t sFSubStates_4225;
	Packets_t parStmnts_4228;
	GetSubStates_4222 getSubStates_4222;
	getSubStates_4222( sFStates_4223, parStmnts_4226, sFSubStates_4225, parStmnts_4228);
	if( ( !sFSubStates_4225.empty())&& ( !parStmnts_4228.empty()))
		callNoFunctionStates_570a( sFSubStates_4225, parStmnts_4228);
}

void PopulateStatusFunction_499a::operator()( const Packets_t& states_499b, const Packets_t& programs_499d, Packets_t& states_499f, Packets_t& programs_49a0)
{
#ifdef PRINT_INFO
	printLog( "PopulateStatusFunction_499a" );
#endif
	_state_49a1= &states_499f;
	_program_49a2= &programs_49a0;
	_state_49a1->insert( _state_49a1->end(), states_499b.begin(), states_499b.end());
	_program_49a2->insert( _program_49a2->end(), programs_499d.begin(), programs_499d.end());
	if( ( !states_499b.empty()))
		callGetStatusFunction_4c24( states_499b);
}

void PopulateStatusFunction_499a::callGetStatusFunction_4c24( const Packets_t& sFStates_4bfd)
{
	Packets_t sFStates_4bff;
	Packets_t statuss_4c00;
	GetStatusFunction_4bfc getStatusFunction_4bfc;
	getStatusFunction_4bfc( sFStates_4bfd, sFStates_4bff, statuss_4c00);
	if( ( !sFStates_4bff.empty())&& ( !statuss_4c00.empty()))
		callHasChildren_4c26( sFStates_4bff, statuss_4c00);
}

void PopulateStatusFunction_499a::callHasChildren_4c26( const Packets_t& states_49c3, const Packets_t& statuss_49c5)
{
	Packets_t states_49c7;
	Packets_t statuss_49c8;
	Packets_t states_49c9;
	Packets_t statuss_49ca;
	HasChildren_49c2 hasChildren_49c2;
	hasChildren_49c2( states_49c3, statuss_49c5, states_49c7, statuss_49c8, states_49c9, statuss_49ca);
	if( ( !states_49c9.empty())&& ( !statuss_49ca.empty()))
		callElimState_4c29( states_49c9, statuss_49ca);
	if( ( !states_49c7.empty())&& ( !statuss_49c8.empty()))
		callnewIndent_4c2c( states_49c7, statuss_49c8);
}

void PopulateStatusFunction_499a::callElimState_4c29( const Packets_t& sFStates_49a4, const Packets_t& statuss_49a6)
{
	Packets_t statuss_49a8;
	ElimState_49a3 elimState_49a3;
	elimState_49a3( sFStates_49a4, statuss_49a6, statuss_49a8);
	if( ( !statuss_49a8.empty()))
		callReturnValue_4c2f( statuss_49a8);
}

void PopulateStatusFunction_499a::callnewIndent_4c2c( const Packets_t& sFStates_4a2f, const Packets_t& statuss_4a32)
{
	Packets_t sFStates_4a31;
	Packets_t statuss_4a34;
	Packets_t stateVars_4a35;
	NewIndent_4a2e newIndent_4a2e;
	newIndent_4a2e( sFStates_4a2f, statuss_4a32, sFStates_4a31, statuss_4a34, stateVars_4a35);
	if( ( !sFStates_4a31.empty())&& ( !statuss_4a34.empty())&& ( !stateVars_4a35.empty()))
		callDecompTest_4c31( sFStates_4a31, statuss_4a34, stateVars_4a35);
}

void PopulateStatusFunction_499a::callReturnValue_4c2f( const Packets_t& statuss_4a6a)
{
	ReturnValue_4a69 returnValue_4a69;
	returnValue_4a69( statuss_4a6a);
}

void PopulateStatusFunction_499a::callDecompTest_4c31( const Packets_t& states_4ae8, const Packets_t& statuss_4aea, const Packets_t& svs_4aec)
{
	Packets_t states_4aee;
	Packets_t statuss_4aef;
	Packets_t svs_4af0;
	Packets_t states_4af1;
	Packets_t statuss_4af2;
	Packets_t svs_4af3;
	DecompTest_4ae7 decompTest_4ae7;
	decompTest_4ae7( states_4ae8, statuss_4aea, svs_4aec, states_4aee, statuss_4aef, svs_4af0, states_4af1, statuss_4af2, svs_4af3);
	if( ( !states_4aee.empty())&& ( !statuss_4aef.empty())&& ( !svs_4af0.empty()))
		callGetChildStates_4c35( states_4aee, statuss_4aef, svs_4af0);
	if( ( !states_4af1.empty())&& ( !statuss_4af2.empty())&& ( !svs_4af3.empty()))
		callCreateConditionalGroup_4c39( states_4af1, statuss_4af2, svs_4af3);
}

void PopulateStatusFunction_499a::callGetChildStates_4c35( const Packets_t& sFStates_4b8a, const Packets_t& compoundStatements_4b8e, const Packets_t& stateVars_4b91)
{
	Packets_t sFStates_4b8c;
	Packets_t sFChildStates_4b8d;
	Packets_t compoundStatements_4b90;
	Packets_t stateVars_4b93;
	GetChildStates_4b89 getChildStates_4b89;
	getChildStates_4b89( sFStates_4b8a, compoundStatements_4b8e, stateVars_4b91, sFStates_4b8c, sFChildStates_4b8d, compoundStatements_4b90, stateVars_4b93);
	if( ( !sFStates_4b8c.empty())&& ( !sFChildStates_4b8d.empty())&& ( !compoundStatements_4b90.empty())&& ( !stateVars_4b93.empty()))
		callCreateConditionals_4c3d( sFStates_4b8c, sFChildStates_4b8d, compoundStatements_4b90, stateVars_4b93);
}

void PopulateStatusFunction_499a::callCreateConditionalGroup_4c39( const Packets_t& sFStates_4bc7, const Packets_t& statuss_4bca, const Packets_t& stateVars_4bcd)
{
	Packets_t sFStates_4bc9;
	Packets_t conditionalGroups_4bcc;
	Packets_t stateVars_4bcf;
	CreateConditionalGroup_4bc6 createConditionalGroup_4bc6;
	createConditionalGroup_4bc6( sFStates_4bc7, statuss_4bca, stateVars_4bcd, sFStates_4bc9, conditionalGroups_4bcc, stateVars_4bcf);
	if( ( !sFStates_4bc9.empty())&& ( !conditionalGroups_4bcc.empty())&& ( !stateVars_4bcf.empty()))
		callGetChildStates_4c35( sFStates_4bc9, conditionalGroups_4bcc, stateVars_4bcf);
}

void PopulateStatusFunction_499a::callCreateConditionals_4c3d( const Packets_t& sFStates_4a83, const Packets_t& sFChildStates_4a86, const Packets_t& compoundStatements_4a88, const Packets_t& stateVars_4a8a)
{
	Packets_t statuss_4a85;
	CreateConditionals_4a82 createConditionals_4a82;
	createConditionals_4a82( sFStates_4a83, sFChildStates_4a86, compoundStatements_4a88, stateVars_4a8a, statuss_4a85);
	if( ( !statuss_4a85.empty()))
		callReturnValue_4c2f( statuss_4a85);
}

void ElimState_49a3::operator()( const Packets_t& sFStates_49a4, const Packets_t& statuss_49a6, Packets_t& statuss_49a8)
{
#ifdef PRINT_INFO
	printLog( "ElimState_49a3" );
#endif
	RTTGenerator::Instance()->generateRule(4001, "ElimState");
	_status_49a9= &statuss_49a8;
	processInputPackets( sFStates_49a4, statuss_49a6);
	forwardInputs( );
}

bool ElimState_49a3::isInputUnique( const Udm::Object& sFState_49ae, const Udm::Object& status_49b7)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_49b0= _sFState_49aa.begin(), itStatus_49b9= _status_49b3.begin(); itSFState_49b0!= _sFState_49aa.end(), itStatus_49b9!= _status_49b3.end(); ++itSFState_49b0, ++itStatus_49b9)
	{
		if( ( *itSFState_49b0== sFState_49ae)&& ( *itStatus_49b9== status_49b7))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_49aa.push_back( sFState_49ae);
		_status_49b3.push_back( status_49b7);
	}
	return isUnique;
}

bool ElimState_49a3::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void ElimState_49a3::processInputPackets( const Packets_t& sFStates_49a4, const Packets_t& statuss_49a6)
{
	for( Packets_t::const_iterator itSFState_49ab= sFStates_49a4.begin(), itStatus_49b4= statuss_49a6.begin(); itSFState_49ab!= sFStates_49a4.end(), itStatus_49b4!= statuss_49a6.end(); ++itSFState_49ab, ++itStatus_49b4)
	{
		bool isUnique= isInputUnique( *itSFState_49ab, *itStatus_49b4);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_49ab, *itStatus_49b4);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ElimState_49a3::patternMatcher( const Udm::Object& sFState_49ac, const Udm::Object& status_49b5)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_49ac.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_49b1= CyberComposition::Simulink::SFState::Cast( sFState_49ac);
		if( false== Uml::IsDerivedFrom( status_49b5.type(), SFC::Function::meta))
			continue;
		SFC::Function status_49ba= SFC::Function::Cast( status_49b5);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_49bf;
		if( !isValidBound(boundObjs_49bf, sFState_49b1, true))
			continue;
		currMatch.sFState_49c0= sFState_49b1;
		if( !isValidBound(boundObjs_49bf, status_49ba, true))
			continue;
		currMatch.status_49c1= status_49ba;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void ElimState_49a3::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
	}
}

void ElimState_49a3::forwardInputs()
{
	*_status_49a9= _status_49b3;
}

void HasChildren_49c2::operator()( const Packets_t& states_49c3, const Packets_t& statuss_49c5, Packets_t& states_49c7, Packets_t& statuss_49c8, Packets_t& states_49c9, Packets_t& statuss_49ca)
{
#ifdef PRINT_INFO
	printLog( "HasChildren_49c2" );
#endif
	_state_49cb= &states_49c7;
	_status_49cc= &statuss_49c8;
	_state_49cd= &states_49c9;
	_status_49ce= &statuss_49ca;
	for( Packets_t::const_iterator itstate_49d0= states_49c3.begin(), itstatus_49d7= statuss_49c5.begin(); itstate_49d0!= states_49c3.end(), itstatus_49d7!= statuss_49c5.end(); ++itstate_49d0, ++itstatus_49d7)
	{
		bool isUnique= isInputUnique( *itstate_49d0, *itstatus_49d7);
		if( !isUnique)
			continue;
		Packets_t onestate_49d4( 1, *itstate_49d0);
		Packets_t onestatus_49db( 1, *itstatus_49d7);
		executeOne( onestate_49d4, onestatus_49db);
	}
}

void HasChildren_49c2::executeOne( const Packets_t& states_49c3, const Packets_t& statuss_49c5)
{
	Packets_t sFStates_49e0;
	Packets_t statuss_49e3;
	HasChildren_49dd hasChildren_49dd;
	bool isMatchHasChildren_49dd= hasChildren_49dd( states_49c3, statuss_49c5, sFStates_49e0, statuss_49e3);
	_state_49cb->insert( _state_49cb->end(), sFStates_49e0.begin(), sFStates_49e0.end());
	_status_49cc->insert( _status_49cc->end(), statuss_49e3.begin(), statuss_49e3.end());
	if( isMatchHasChildren_49dd)
		return;
	Packets_t sFStates_4a0c;
	Packets_t statuss_4a0f;
	NoChildren_4a09 noChildren_4a09;
	bool isMatchNoChildren_4a09= noChildren_4a09( states_49c3, statuss_49c5, sFStates_4a0c, statuss_4a0f);
	_state_49cd->insert( _state_49cd->end(), sFStates_4a0c.begin(), sFStates_4a0c.end());
	_status_49ce->insert( _status_49ce->end(), statuss_4a0f.begin(), statuss_4a0f.end());
	if( isMatchNoChildren_4a09)
		return;
}

bool HasChildren_49c2::isInputUnique( const Udm::Object& state_49d1, const Udm::Object& status_49d8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_49d3= _state_49cf.begin(), itstatus_49da= _status_49d6.begin(); itstate_49d3!= _state_49cf.end(), itstatus_49da!= _status_49d6.end(); ++itstate_49d3, ++itstatus_49da)
	{
		if( ( *itstate_49d3== state_49d1)&& ( *itstatus_49da== status_49d8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_49cf.push_back( state_49d1);
		_status_49d6.push_back( status_49d8);
	}
	return isUnique;
}

bool HasChildren_49dd::operator()( const Packets_t& sFStates_49de, const Packets_t& statuss_49e1, Packets_t& sFStates_49e0, Packets_t& statuss_49e3)
{
#ifdef PRINT_INFO
	printLog( "HasChildren_49dd" );
#endif
	_sFState_49e4= &sFStates_49e0;
	_status_49e5= &statuss_49e3;
	processInputPackets( sFStates_49de, statuss_49e1);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasChildren_49dd::isInputUnique( const Udm::Object& sFState_49ea, const Udm::Object& status_49f3)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_49ec= _sFState_49e6.begin(), itStatus_49f5= _status_49ef.begin(); itSFState_49ec!= _sFState_49e6.end(), itStatus_49f5!= _status_49ef.end(); ++itSFState_49ec, ++itStatus_49f5)
	{
		if( ( *itSFState_49ec== sFState_49ea)&& ( *itStatus_49f5== status_49f3))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_49e6.push_back( sFState_49ea);
		_status_49ef.push_back( status_49f3);
	}
	return isUnique;
}

bool HasChildren_49dd::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool HasChildren_49dd::isGuardTrue( CyberComposition::Simulink::SFState& SFChildState, CyberComposition::Simulink::SFState& SFState, SFC::Function& Status)
{
	bool Gz_guard= false;
	return static_cast< std::string >( SFChildState.Decomposition() ) != "FUNC_STATE";;
	return Gz_guard;
}

void HasChildren_49dd::processInputPackets( const Packets_t& sFStates_49de, const Packets_t& statuss_49e1)
{
	for( Packets_t::const_iterator itSFState_49e7= sFStates_49de.begin(), itStatus_49f0= statuss_49e1.begin(); itSFState_49e7!= sFStates_49de.end(), itStatus_49f0!= statuss_49e1.end(); ++itSFState_49e7, ++itStatus_49f0)
	{
		bool isUnique= isInputUnique( *itSFState_49e7, *itStatus_49f0);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_49e7, *itStatus_49f0);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_49ff, currMatch.status_4a00);
	}
}

bool HasChildren_49dd::patternMatcher( const Udm::Object& sFState_49e8, const Udm::Object& status_49f1)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_49e8.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_49ed= CyberComposition::Simulink::SFState::Cast( sFState_49e8);
		if( false== Uml::IsDerivedFrom( status_49f1.type(), SFC::Function::meta))
			continue;
		SFC::Function status_49f6= SFC::Function::Cast( status_49f1);
		set< CyberComposition::Simulink::SFState> sFChildStates_49f8= sFState_49ed.SFState_kind_children();
		for( set< CyberComposition::Simulink::SFState>::const_iterator itSFChildState_49f9= sFChildStates_49f8.begin(); itSFChildState_49f9!= sFChildStates_49f8.end(); ++itSFChildState_49f9)
		{
			CyberComposition::Simulink::SFState currSFChildState_49fa= *itSFChildState_49f9;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_49fe;
			if( !isValidBound(boundObjs_49fe, sFState_49ed, true))
				continue;
			currMatch.sFState_49ff= sFState_49ed;
			if( !isValidBound(boundObjs_49fe, status_49f6, true))
				continue;
			currMatch.status_4a00= status_49f6;
			if( !isValidBound(boundObjs_49fe, currSFChildState_49fa, false))
				continue;
			currMatch.sFChildState_4a01= currSFChildState_49fa;
			bool Gz_guard= isGuardTrue( currMatch.sFChildState_4a01, currMatch.sFState_49ff, currMatch.status_4a00);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void HasChildren_49dd::outputAppender( const CyberComposition::Simulink::SFState& sFState_4a05, const SFC::Function& status_4a07)
{
	_sFState_49e4->push_back( sFState_4a05);
	_status_49e5->push_back( status_4a07);
}

bool NoChildren_4a09::operator()( const Packets_t& sFStates_4a0a, const Packets_t& statuss_4a0d, Packets_t& sFStates_4a0c, Packets_t& statuss_4a0f)
{
#ifdef PRINT_INFO
	printLog( "NoChildren_4a09" );
#endif
	_sFState_4a10= &sFStates_4a0c;
	_status_4a11= &statuss_4a0f;
	processInputPackets( sFStates_4a0a, statuss_4a0d);
	if( false== _matches.empty())
		return true;
	return false;
}

bool NoChildren_4a09::isInputUnique( const Udm::Object& sFState_4a16, const Udm::Object& status_4a1f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4a18= _sFState_4a12.begin(), itStatus_4a21= _status_4a1b.begin(); itSFState_4a18!= _sFState_4a12.end(), itStatus_4a21!= _status_4a1b.end(); ++itSFState_4a18, ++itStatus_4a21)
	{
		if( ( *itSFState_4a18== sFState_4a16)&& ( *itStatus_4a21== status_4a1f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4a12.push_back( sFState_4a16);
		_status_4a1b.push_back( status_4a1f);
	}
	return isUnique;
}

bool NoChildren_4a09::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void NoChildren_4a09::processInputPackets( const Packets_t& sFStates_4a0a, const Packets_t& statuss_4a0d)
{
	for( Packets_t::const_iterator itSFState_4a13= sFStates_4a0a.begin(), itStatus_4a1c= statuss_4a0d.begin(); itSFState_4a13!= sFStates_4a0a.end(), itStatus_4a1c!= statuss_4a0d.end(); ++itSFState_4a13, ++itStatus_4a1c)
	{
		bool isUnique= isInputUnique( *itSFState_4a13, *itStatus_4a1c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4a13, *itStatus_4a1c);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4a28, currMatch.status_4a29);
	}
}

bool NoChildren_4a09::patternMatcher( const Udm::Object& sFState_4a14, const Udm::Object& status_4a1d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4a14.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4a19= CyberComposition::Simulink::SFState::Cast( sFState_4a14);
		if( false== Uml::IsDerivedFrom( status_4a1d.type(), SFC::Function::meta))
			continue;
		SFC::Function status_4a22= SFC::Function::Cast( status_4a1d);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4a27;
		if( !isValidBound(boundObjs_4a27, sFState_4a19, true))
			continue;
		currMatch.sFState_4a28= sFState_4a19;
		if( !isValidBound(boundObjs_4a27, status_4a22, true))
			continue;
		currMatch.status_4a29= status_4a22;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void NoChildren_4a09::outputAppender( const CyberComposition::Simulink::SFState& sFState_4a2a, const SFC::Function& status_4a2c)
{
	_sFState_4a10->push_back( sFState_4a2a);
	_status_4a11->push_back( status_4a2c);
}

void NewIndent_4a2e::operator()( const Packets_t& sFStates_4a2f, const Packets_t& statuss_4a32, Packets_t& sFStates_4a31, Packets_t& statuss_4a34, Packets_t& stateVars_4a35)
{
#ifdef PRINT_INFO
	printLog( "NewIndent_4a2e" );
#endif
	RTTGenerator::Instance()->generateRule(4019, "newIndent");
	_sFState_4a36= &sFStates_4a31;
	_status_4a37= &statuss_4a34;
	_stateVar_4a38= &stateVars_4a35;
	processInputPackets( sFStates_4a2f, statuss_4a32);
}

bool NewIndent_4a2e::isInputUnique( const Udm::Object& sFState_4a3d, const Udm::Object& status_4a46)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4a3f= _sFState_4a39.begin(), itStatus_4a48= _status_4a42.begin(); itSFState_4a3f!= _sFState_4a39.end(), itStatus_4a48!= _status_4a42.end(); ++itSFState_4a3f, ++itStatus_4a48)
	{
		if( ( *itSFState_4a3f== sFState_4a3d)&& ( *itStatus_4a48== status_4a46))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4a39.push_back( sFState_4a3d);
		_status_4a42.push_back( status_4a46);
	}
	return isUnique;
}

bool NewIndent_4a2e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void NewIndent_4a2e::processInputPackets( const Packets_t& sFStates_4a2f, const Packets_t& statuss_4a32)
{
	for( Packets_t::const_iterator itSFState_4a3a= sFStates_4a2f.begin(), itStatus_4a43= statuss_4a32.begin(); itSFState_4a3a!= sFStates_4a2f.end(), itStatus_4a43!= statuss_4a32.end(); ++itSFState_4a3a, ++itStatus_4a43)
	{
		bool isUnique= isInputUnique( *itSFState_4a3a, *itStatus_4a43);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4a3a, *itStatus_4a43);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool NewIndent_4a2e::patternMatcher( const Udm::Object& sFState_4a3b, const Udm::Object& status_4a44)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4a3b.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4a40= CyberComposition::Simulink::SFState::Cast( sFState_4a3b);
		if( false== Uml::IsDerivedFrom( status_4a44.type(), SFC::Function::meta))
			continue;
		SFC::Function status_4a49= SFC::Function::Cast( status_4a44);
		Udm::Object statusParent_4a4b= status_4a49.container();
		if( false== Uml::IsDerivedFrom( statusParent_4a4b.type(), SFC::Program::meta))
			continue;
		SFC::Program programStatus_4a4c= SFC::Program::Cast( statusParent_4a4b);
		set< SFC::Arg> args_4a4d= status_4a49.Arg_kind_children();
		for( set< SFC::Arg>::const_iterator itArg_4a4e= args_4a4d.begin(); itArg_4a4e!= args_4a4d.end(); ++itArg_4a4e)
		{
			SFC::Arg currArg_4a4f= *itArg_4a4e;
			set< SFC::StateVar> stateVars_4a50= programStatus_4a4c.StateVar_kind_children();
			for( set< SFC::StateVar>::const_iterator itStateVar_4a51= stateVars_4a50.begin(); itStateVar_4a51!= stateVars_4a50.end(); ++itStateVar_4a51)
			{
				SFC::StateVar currStateVar_4a52= *itStateVar_4a51;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_4a56;
				if( !isValidBound(boundObjs_4a56, sFState_4a40, true))
					continue;
				currMatch.sFState_4a57= sFState_4a40;
				if( !isValidBound(boundObjs_4a56, status_4a49, true))
					continue;
				currMatch.status_4a58= status_4a49;
				if( !isValidBound(boundObjs_4a56, currArg_4a4f, false))
					continue;
				currMatch.arg_4a59= currArg_4a4f;
				if( !isValidBound(boundObjs_4a56, programStatus_4a4c, false))
					continue;
				currMatch.program_4a5a= programStatus_4a4c;
				if( !isValidBound(boundObjs_4a56, currStateVar_4a52, false))
					continue;
				currMatch.stateVar_4a5b= currStateVar_4a52;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void NewIndent_4a2e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newnewIndent_4a5c= SFC::LocalVar::Create( currMatch.status_4a58, SFC::Function::meta_stmnt);
		SFC::UserCode newnewIndentAssign_4a5d= SFC::UserCode::Create( currMatch.status_4a58, SFC::Function::meta_stmnt);
		SFC::BinaryExprs newAssign_4a5e= SFC::BinaryExprs::Create( newnewIndentAssign_4a5d, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newArgDeclRef4_4a5f= SFC::ArgDeclRef::Create( newAssign_4a5e, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newPlus_4a60= SFC::BinaryExprs::Create( newAssign_4a5e, SFC::BinaryExprs::meta_rightexpr);
		SFC::Str newStr_4a61= SFC::Str::Create( newPlus_4a60, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef3_4a62= SFC::ArgDeclRef::Create( newPlus_4a60, SFC::BinaryExprs::meta_leftexpr);
		SFC::Arg& Arg= currMatch.arg_4a59;
		SFC::ArgDeclRef& ArgDeclRef3= newArgDeclRef3_4a62;
		SFC::ArgDeclRef& ArgDeclRef4= newArgDeclRef4_4a5f;
		SFC::BinaryExprs& Assign= newAssign_4a5e;
		SFC::BinaryExprs& Plus= newPlus_4a60;
		SFC::Program& Program= currMatch.program_4a5a;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_4a57;
		SFC::StateVar& StateVar= currMatch.stateVar_4a5b;
		SFC::Function& Status= currMatch.status_4a58;
		SFC::Str& Str= newStr_4a61;
		SFC::LocalVar& newIndent= newnewIndent_4a5c;
		SFC::UserCode& newIndentAssign= newnewIndentAssign_4a5d;
		{
newIndentAssign.RefId() = newIndent.RefId() = Status.RefId();
};
		{
Str.val() = "\\t";
};
		{
Plus.op() = "+";
};
		{
newIndent.name() = "newIndent";
newIndent.dt() = SFCTypesManager::getSingleton().getBasicType( "string" );
};
		{
Assign.op() = "=";
};
		{
__int64 statementCount = Status.statementCount();
newIndent.statementIndex() = statementCount++;
newIndentAssign.statementIndex() = statementCount++;
Status.statementCount() = statementCount;
};
		newArgDeclRef3_4a62.argdecl()= currMatch.arg_4a59;
		newArgDeclRef4_4a5f.argdecl()= newnewIndent_4a5c;
		outputAppender( currMatch.sFState_4a57, currMatch.status_4a58, currMatch.stateVar_4a5b);
	}
}

void NewIndent_4a2e::outputAppender( const CyberComposition::Simulink::SFState& sFState_4a63, const SFC::Function& status_4a65, const SFC::StateVar& stateVar_4a67)
{
	_sFState_4a36->push_back( sFState_4a63);
	_status_4a37->push_back( status_4a65);
	_stateVar_4a38->push_back( stateVar_4a67);
}

void ReturnValue_4a69::operator()( const Packets_t& statuss_4a6a)
{
#ifdef PRINT_INFO
	printLog( "ReturnValue_4a69" );
#endif
	RTTGenerator::Instance()->generateRule(4050, "ReturnValue");
	processInputPackets( statuss_4a6a);
}

bool ReturnValue_4a69::isInputUnique( const Udm::Object& status_4a70)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itStatus_4a72= _status_4a6c.begin(); itStatus_4a72!= _status_4a6c.end(); ++itStatus_4a72)
	{
		if( ( *itStatus_4a72== status_4a70))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_status_4a6c.push_back( status_4a70);
	return isUnique;
}

bool ReturnValue_4a69::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool ReturnValue_4a69::isGuardTrue( SFC::Function& Status, SFC::LocalVar& retval)
{
	bool Gz_guard= false;
	return static_cast< std::string >( retval.name() ) == "retval";;
	return Gz_guard;
}

void ReturnValue_4a69::processInputPackets( const Packets_t& statuss_4a6a)
{
	for( Packets_t::const_iterator itStatus_4a6d= statuss_4a6a.begin(); itStatus_4a6d!= statuss_4a6a.end(); ++itStatus_4a6d)
	{
		bool isUnique= isInputUnique( *itStatus_4a6d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itStatus_4a6d);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ReturnValue_4a69::patternMatcher( const Udm::Object& status_4a6e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( status_4a6e.type(), SFC::Function::meta))
			continue;
		SFC::Function status_4a73= SFC::Function::Cast( status_4a6e);
		set< SFC::LocalVar> retvals_4a75= status_4a73.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itretval_4a76= retvals_4a75.begin(); itretval_4a76!= retvals_4a75.end(); ++itretval_4a76)
		{
			SFC::LocalVar currretval_4a77= *itretval_4a76;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_4a7b;
			if( !isValidBound(boundObjs_4a7b, status_4a73, true))
				continue;
			currMatch.status_4a7c= status_4a73;
			if( !isValidBound(boundObjs_4a7b, currretval_4a77, false))
				continue;
			currMatch.retval_4a7d= currretval_4a77;
			bool Gz_guard= isGuardTrue( currMatch.status_4a7c, currMatch.retval_4a7d);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void ReturnValue_4a69::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Return newReturn_4a80= SFC::Return::Create( currMatch.status_4a7c, SFC::Function::meta_stmnt);
		SFC::ArgDeclRef newArgDeclRef_4a81= SFC::ArgDeclRef::Create( newReturn_4a80, SFC::Return::meta_retexpr);
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_4a81;
		SFC::Return& Return= newReturn_4a80;
		SFC::Function& Status= currMatch.status_4a7c;
		SFC::LocalVar& retval= currMatch.retval_4a7d;
		{
Return.RefId() = Status.RefId();
};
		{
__int64 statementCount = Status.statementCount();
Return.statementIndex() = statementCount++;
Status.statementCount() = statementCount;
};
		newArgDeclRef_4a81.argdecl()= currMatch.retval_4a7d;
	}
}

void CreateConditionals_4a82::operator()( const Packets_t& sFStates_4a83, const Packets_t& sFChildStates_4a86, const Packets_t& compoundStatements_4a88, const Packets_t& stateVars_4a8a, Packets_t& statuss_4a85)
{
#ifdef PRINT_INFO
	printLog( "CreateConditionals_4a82" );
#endif
	RTTGenerator::Instance()->generateRule(4061, "CreateConditionals");
	_status_4a8c= &statuss_4a85;
	processInputPackets( sFStates_4a83, sFChildStates_4a86, compoundStatements_4a88, stateVars_4a8a);
}

bool CreateConditionals_4a82::isInputUnique( const Udm::Object& sFState_4a91, const Udm::Object& sFChildState_4a9a, const Udm::Object& compoundStatement_4aa3, const Udm::Object& stateVar_4aac)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4a93= _sFState_4a8d.begin(), itSFChildState_4a9c= _sFChildState_4a96.begin(), itCompoundStatement_4aa5= _compoundStatement_4a9f.begin(), itStateVar_4aae= _stateVar_4aa8.begin(); itSFState_4a93!= _sFState_4a8d.end(), itSFChildState_4a9c!= _sFChildState_4a96.end(), itCompoundStatement_4aa5!= _compoundStatement_4a9f.end(), itStateVar_4aae!= _stateVar_4aa8.end(); ++itSFState_4a93, ++itSFChildState_4a9c, ++itCompoundStatement_4aa5, ++itStateVar_4aae)
	{
		if( ( *itSFState_4a93== sFState_4a91)&& ( *itSFChildState_4a9c== sFChildState_4a9a)&& ( *itCompoundStatement_4aa5== compoundStatement_4aa3)&& ( *itStateVar_4aae== stateVar_4aac))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4a8d.push_back( sFState_4a91);
		_sFChildState_4a96.push_back( sFChildState_4a9a);
		_compoundStatement_4a9f.push_back( compoundStatement_4aa3);
		_stateVar_4aa8.push_back( stateVar_4aac);
	}
	return isUnique;
}

bool CreateConditionals_4a82::isGuardTrue( SFC::StateLabel& ChildStateLabel, SFC::Function& ChildStatus, SFC::CompoundStatement& CompoundStatement, SFC::Arg& IndentArg, CyberComposition::Simulink::SFState& SFChildState, CyberComposition::Simulink::SFState& SFState, SFC::StateLabel& StateLabel, SFC::StateVar& StateVar, SFC::Function& Status, SFC::LocalVar& newIndent, SFC::LocalVar& retval)
{
	bool Gz_guard= false;
	return static_cast< std::string >( retval.name() ) == "retval" && static_cast< std::string >( newIndent.name() ) == "newIndent";;
	return Gz_guard;
}

void CreateConditionals_4a82::processInputPackets( const Packets_t& sFStates_4a83, const Packets_t& sFChildStates_4a86, const Packets_t& compoundStatements_4a88, const Packets_t& stateVars_4a8a)
{
	for( Packets_t::const_iterator itSFState_4a8e= sFStates_4a83.begin(), itSFChildState_4a97= sFChildStates_4a86.begin(), itCompoundStatement_4aa0= compoundStatements_4a88.begin(), itStateVar_4aa9= stateVars_4a8a.begin(); itSFState_4a8e!= sFStates_4a83.end(), itSFChildState_4a97!= sFChildStates_4a86.end(), itCompoundStatement_4aa0!= compoundStatements_4a88.end(), itStateVar_4aa9!= stateVars_4a8a.end(); ++itSFState_4a8e, ++itSFChildState_4a97, ++itCompoundStatement_4aa0, ++itStateVar_4aa9)
	{
		bool isUnique= isInputUnique( *itSFState_4a8e, *itSFChildState_4a97, *itCompoundStatement_4aa0, *itStateVar_4aa9);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4a8e, *itSFChildState_4a97, *itCompoundStatement_4aa0, *itStateVar_4aa9);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateConditionals_4a82::patternMatcher( const Udm::Object& sFState_4a8f, const Udm::Object& sFChildState_4a98, const Udm::Object& compoundStatement_4aa1, const Udm::Object& stateVar_4aaa)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4a8f.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4a94= CyberComposition::Simulink::SFState::Cast( sFState_4a8f);
		if( false== Uml::IsDerivedFrom( sFChildState_4a98.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFChildState_4a9d= CyberComposition::Simulink::SFState::Cast( sFChildState_4a98);
		if( false== Uml::IsDerivedFrom( compoundStatement_4aa1.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_4aa6= SFC::CompoundStatement::Cast( compoundStatement_4aa1);
		if( false== Uml::IsDerivedFrom( stateVar_4aaa.type(), SFC::StateVar::meta))
			continue;
		SFC::StateVar stateVar_4aaf= SFC::StateVar::Cast( stateVar_4aaa);
		set< SFC::Function> statuss_4ab1= sFState_4a94.status();
		for( set< SFC::Function>::const_iterator itStatuss_4ab2= statuss_4ab1.begin(); itStatuss_4ab2!= statuss_4ab1.end(); ++itStatuss_4ab2)
		{
			SFC::Function currStatus_4ab3= *itStatuss_4ab2;
			set< SFC::LocalVar> newIndents_4ab4= currStatus_4ab3.LocalVar_kind_children();
			for( set< SFC::LocalVar>::const_iterator itnewIndent_4ab5= newIndents_4ab4.begin(); itnewIndent_4ab5!= newIndents_4ab4.end(); ++itnewIndent_4ab5)
			{
				SFC::LocalVar currnewIndent_4ab6= *itnewIndent_4ab5;
				set< SFC::LocalVar> retvals_4ab7= currStatus_4ab3.LocalVar_kind_children();
				for( set< SFC::LocalVar>::const_iterator itretval_4ab8= retvals_4ab7.begin(); itretval_4ab8!= retvals_4ab7.end(); ++itretval_4ab8)
				{
					SFC::LocalVar currretval_4ab9= *itretval_4ab8;
					set< SFC::Function> childStatuss_4aba= sFChildState_4a9d.status();
					for( set< SFC::Function>::const_iterator itChildStatuss_4abb= childStatuss_4aba.begin(); itChildStatuss_4abb!= childStatuss_4aba.end(); ++itChildStatuss_4abb)
					{
						SFC::Function currChildStatus_4abc= *itChildStatuss_4abb;
						set< SFC::Arg> indentArgs_4abd= currChildStatus_4abc.Arg_kind_children();
						for( set< SFC::Arg>::const_iterator itIndentArg_4abe= indentArgs_4abd.begin(); itIndentArg_4abe!= indentArgs_4abd.end(); ++itIndentArg_4abe)
						{
							SFC::Arg currIndentArg_4abf= *itIndentArg_4abe;
							set< SFC::StateLabel> childStateLabels_4ac0= sFChildState_4a9d.src();
							for( set< SFC::StateLabel>::const_iterator itChildStateLabels_4ac1= childStateLabels_4ac0.begin(); itChildStateLabels_4ac1!= childStateLabels_4ac0.end(); ++itChildStateLabels_4ac1)
							{
								SFC::StateLabel currChildStateLabel_4ac2= *itChildStateLabels_4ac1;
								set< SFC::StateLabel> stateLabels_4ac3= sFState_4a94.src();
								for( set< SFC::StateLabel>::const_iterator itStateLabels_4ac4= stateLabels_4ac3.begin(); itStateLabels_4ac4!= stateLabels_4ac3.end(); ++itStateLabels_4ac4)
								{
									SFC::StateLabel currStateLabel_4ac5= *itStateLabels_4ac4;
									Match currMatch;
									currMatch.sFState_4ac7= sFState_4a94;
									currMatch.sFChildState_4ac8= sFChildState_4a9d;
									currMatch.compoundStatement_4ac9= compoundStatement_4aa6;
									currMatch.stateVar_4aca= stateVar_4aaf;
									currMatch.status_4acb= currStatus_4ab3;
									currMatch.retval_4acc= currretval_4ab9;
									currMatch.indentArg_4acd= currIndentArg_4abf;
									currMatch.childStatus_4ace= currChildStatus_4abc;
									currMatch.newIndent_4acf= currnewIndent_4ab6;
									currMatch.stateLabel_4ad0= currStateLabel_4ac5;
									currMatch.childStateLabel_4ad1= currChildStateLabel_4ac2;
									bool Gz_guard= isGuardTrue( currMatch.childStateLabel_4ad1, currMatch.childStatus_4ace, currMatch.compoundStatement_4ac9, currMatch.indentArg_4acd, currMatch.sFChildState_4ac8, currMatch.sFState_4ac7, currMatch.stateLabel_4ad0, currMatch.stateVar_4aca, currMatch.status_4acb, currMatch.newIndent_4acf, currMatch.retval_4acc);
									if( true== Gz_guard)
										_matches.push_back( currMatch);
								}
							}
						}
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void CreateConditionals_4a82::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_4add= SFC::ConditionalBlock::Create( currMatch.compoundStatement_4ac9, SFC::CompoundStatement::meta_stmnt);
		SFC::UserCode newUserCode_4ade= SFC::UserCode::Create( newConditionalBlock_4add, SFC::ConditionalBlock::meta_stmnt);
		SFC::BinaryExprs newAddEquals_4adf= SFC::BinaryExprs::Create( newUserCode_4ade, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newArgDeclRef2_4ae0= SFC::ArgDeclRef::Create( newAddEquals_4adf, SFC::BinaryExprs::meta_leftexpr);
		SFC::FunctionCall newFunctionCall_4ae1= SFC::FunctionCall::Create( newAddEquals_4adf, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgVal newArgVal_4ae2= SFC::ArgVal::Create( newFunctionCall_4ae1);
		SFC::ArgDeclRef newArgDeclRef1_4ae3= SFC::ArgDeclRef::Create( newArgVal_4ae2, SFC::ArgVal::meta_argexpr);
		SFC::CheckState newCheckState_4ae4= SFC::CheckState::Create( newConditionalBlock_4add, SFC::ConditionalBlock::meta_cond);
		SFC::BinaryExprs& AddEquals= newAddEquals_4adf;
		SFC::ArgDeclRef& ArgDeclRef1= newArgDeclRef1_4ae3;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_4ae0;
		SFC::ArgVal& ArgVal= newArgVal_4ae2;
		SFC::CheckState& CheckState= newCheckState_4ae4;
		SFC::StateLabel& ChildStateLabel= currMatch.childStateLabel_4ad1;
		SFC::Function& ChildStatus= currMatch.childStatus_4ace;
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_4ac9;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_4add;
		SFC::FunctionCall& FunctionCall= newFunctionCall_4ae1;
		SFC::Arg& IndentArg= currMatch.indentArg_4acd;
		CyberComposition::Simulink::SFState& SFChildState= currMatch.sFChildState_4ac8;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_4ac7;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_4ad0;
		SFC::StateVar& StateVar= currMatch.stateVar_4aca;
		SFC::Function& Status= currMatch.status_4acb;
		SFC::UserCode& UserCode= newUserCode_4ade;
		SFC::LocalVar& newIndent= currMatch.newIndent_4acf;
		SFC::LocalVar& retval= currMatch.retval_4acc;
		{
ConditionalBlock.RefId() = UserCode.RefId() = CompoundStatement.RefId();
};
		{
CheckState.andState() = static_cast< std::string >( SFChildState.Decomposition() ) == "AND_STATE";
};
		{
__int64 statementCount = ConditionalBlock.statementCount();
UserCode.statementIndex() = statementCount++;
ConditionalBlock.statementCount() = statementCount;
};
		{
__int64 statementCount = CompoundStatement.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		{
AddEquals.op() = "+=";
};
		newArgDeclRef1_4ae3.argdecl()= currMatch.newIndent_4acf;
		newArgVal_4ae2.arg()+= currMatch.indentArg_4acd;
		newArgDeclRef2_4ae0.argdecl()= currMatch.retval_4acc;
		newFunctionCall_4ae1.callee()= currMatch.childStatus_4ace;
		newCheckState_4ae4.svar()= currMatch.stateVar_4aca;
		newCheckState_4ae4.value()= currMatch.childStateLabel_4ad1;
		newCheckState_4ae4.index()= currMatch.stateLabel_4ad0;
		outputAppender( currMatch.status_4acb);
	}
}

void CreateConditionals_4a82::outputAppender( const SFC::Function& status_4ae5)
{
	_status_4a8c->push_back( status_4ae5);
}

void DecompTest_4ae7::operator()( const Packets_t& states_4ae8, const Packets_t& statuss_4aea, const Packets_t& svs_4aec, Packets_t& states_4aee, Packets_t& statuss_4aef, Packets_t& svs_4af0, Packets_t& states_4af1, Packets_t& statuss_4af2, Packets_t& svs_4af3)
{
#ifdef PRINT_INFO
	printLog( "DecompTest_4ae7" );
#endif
	_state_4af4= &states_4aee;
	_status_4af5= &statuss_4aef;
	_sv_4af6= &svs_4af0;
	_state_4af7= &states_4af1;
	_status_4af8= &statuss_4af2;
	_sv_4af9= &svs_4af3;
	for( Packets_t::const_iterator itstate_4afb= states_4ae8.begin(), itstatus_4b02= statuss_4aea.begin(), itsv_4b09= svs_4aec.begin(); itstate_4afb!= states_4ae8.end(), itstatus_4b02!= statuss_4aea.end(), itsv_4b09!= svs_4aec.end(); ++itstate_4afb, ++itstatus_4b02, ++itsv_4b09)
	{
		bool isUnique= isInputUnique( *itstate_4afb, *itstatus_4b02, *itsv_4b09);
		if( !isUnique)
			continue;
		Packets_t onestate_4aff( 1, *itstate_4afb);
		Packets_t onestatus_4b06( 1, *itstatus_4b02);
		Packets_t onesv_4b0d( 1, *itsv_4b09);
		executeOne( onestate_4aff, onestatus_4b06, onesv_4b0d);
	}
}

void DecompTest_4ae7::executeOne( const Packets_t& states_4ae8, const Packets_t& statuss_4aea, const Packets_t& svs_4aec)
{
	Packets_t sFStates_4b12;
	Packets_t statuss_4b15;
	Packets_t stateVars_4b18;
	AndState_4b0f andState_4b0f;
	bool isMatchAndState_4b0f= andState_4b0f( states_4ae8, statuss_4aea, svs_4aec, sFStates_4b12, statuss_4b15, stateVars_4b18);
	_state_4af4->insert( _state_4af4->end(), sFStates_4b12.begin(), sFStates_4b12.end());
	_status_4af5->insert( _status_4af5->end(), statuss_4b15.begin(), statuss_4b15.end());
	_sv_4af6->insert( _sv_4af6->end(), stateVars_4b18.begin(), stateVars_4b18.end());
	if( isMatchAndState_4b0f)
		return;
	Packets_t sFStates_4b4f;
	Packets_t statuss_4b52;
	Packets_t stateVars_4b55;
	OrState_4b4c orState_4b4c;
	bool isMatchOrState_4b4c= orState_4b4c( states_4ae8, statuss_4aea, svs_4aec, sFStates_4b4f, statuss_4b52, stateVars_4b55);
	_state_4af7->insert( _state_4af7->end(), sFStates_4b4f.begin(), sFStates_4b4f.end());
	_status_4af8->insert( _status_4af8->end(), statuss_4b52.begin(), statuss_4b52.end());
	_sv_4af9->insert( _sv_4af9->end(), stateVars_4b55.begin(), stateVars_4b55.end());
	if( isMatchOrState_4b4c)
		return;
}

bool DecompTest_4ae7::isInputUnique( const Udm::Object& state_4afc, const Udm::Object& status_4b03, const Udm::Object& sv_4b0a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_4afe= _state_4afa.begin(), itstatus_4b05= _status_4b01.begin(), itsv_4b0c= _sv_4b08.begin(); itstate_4afe!= _state_4afa.end(), itstatus_4b05!= _status_4b01.end(), itsv_4b0c!= _sv_4b08.end(); ++itstate_4afe, ++itstatus_4b05, ++itsv_4b0c)
	{
		if( ( *itstate_4afe== state_4afc)&& ( *itstatus_4b05== status_4b03)&& ( *itsv_4b0c== sv_4b0a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_4afa.push_back( state_4afc);
		_status_4b01.push_back( status_4b03);
		_sv_4b08.push_back( sv_4b0a);
	}
	return isUnique;
}

bool AndState_4b0f::operator()( const Packets_t& sFStates_4b10, const Packets_t& statuss_4b13, const Packets_t& stateVars_4b16, Packets_t& sFStates_4b12, Packets_t& statuss_4b15, Packets_t& stateVars_4b18)
{
#ifdef PRINT_INFO
	printLog( "AndState_4b0f" );
#endif
	_sFState_4b19= &sFStates_4b12;
	_status_4b1a= &statuss_4b15;
	_stateVar_4b1b= &stateVars_4b18;
	processInputPackets( sFStates_4b10, statuss_4b13, stateVars_4b16);
	if( false== _matches.empty())
		return true;
	return false;
}

bool AndState_4b0f::isInputUnique( const Udm::Object& sFState_4b20, const Udm::Object& status_4b29, const Udm::Object& stateVar_4b32)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4b22= _sFState_4b1c.begin(), itStatus_4b2b= _status_4b25.begin(), itStateVar_4b34= _stateVar_4b2e.begin(); itSFState_4b22!= _sFState_4b1c.end(), itStatus_4b2b!= _status_4b25.end(), itStateVar_4b34!= _stateVar_4b2e.end(); ++itSFState_4b22, ++itStatus_4b2b, ++itStateVar_4b34)
	{
		if( ( *itSFState_4b22== sFState_4b20)&& ( *itStatus_4b2b== status_4b29)&& ( *itStateVar_4b34== stateVar_4b32))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4b1c.push_back( sFState_4b20);
		_status_4b25.push_back( status_4b29);
		_stateVar_4b2e.push_back( stateVar_4b32);
	}
	return isUnique;
}

bool AndState_4b0f::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool AndState_4b0f::isGuardTrue( CyberComposition::Simulink::SFState& SFChildState, CyberComposition::Simulink::SFState& SFState, SFC::StateVar& StateVar, SFC::Function& Status)
{
	bool Gz_guard= false;
	return static_cast< std::string >( SFChildState.Decomposition() ) == "AND_STATE";;
	return Gz_guard;
}

void AndState_4b0f::processInputPackets( const Packets_t& sFStates_4b10, const Packets_t& statuss_4b13, const Packets_t& stateVars_4b16)
{
	for( Packets_t::const_iterator itSFState_4b1d= sFStates_4b10.begin(), itStatus_4b26= statuss_4b13.begin(), itStateVar_4b2f= stateVars_4b16.begin(); itSFState_4b1d!= sFStates_4b10.end(), itStatus_4b26!= statuss_4b13.end(), itStateVar_4b2f!= stateVars_4b16.end(); ++itSFState_4b1d, ++itStatus_4b26, ++itStateVar_4b2f)
	{
		bool isUnique= isInputUnique( *itSFState_4b1d, *itStatus_4b26, *itStateVar_4b2f);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4b1d, *itStatus_4b26, *itStateVar_4b2f);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4b3e, currMatch.status_4b3f, currMatch.stateVar_4b40);
	}
}

bool AndState_4b0f::patternMatcher( const Udm::Object& sFState_4b1e, const Udm::Object& status_4b27, const Udm::Object& stateVar_4b30)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4b1e.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4b23= CyberComposition::Simulink::SFState::Cast( sFState_4b1e);
		if( false== Uml::IsDerivedFrom( status_4b27.type(), SFC::Function::meta))
			continue;
		SFC::Function status_4b2c= SFC::Function::Cast( status_4b27);
		if( false== Uml::IsDerivedFrom( stateVar_4b30.type(), SFC::StateVar::meta))
			continue;
		SFC::StateVar stateVar_4b35= SFC::StateVar::Cast( stateVar_4b30);
		set< CyberComposition::Simulink::SFState> sFChildStates_4b37= sFState_4b23.SFState_kind_children();
		for( set< CyberComposition::Simulink::SFState>::const_iterator itSFChildState_4b38= sFChildStates_4b37.begin(); itSFChildState_4b38!= sFChildStates_4b37.end(); ++itSFChildState_4b38)
		{
			CyberComposition::Simulink::SFState currSFChildState_4b39= *itSFChildState_4b38;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_4b3d;
			if( !isValidBound(boundObjs_4b3d, sFState_4b23, true))
				continue;
			currMatch.sFState_4b3e= sFState_4b23;
			if( !isValidBound(boundObjs_4b3d, status_4b2c, true))
				continue;
			currMatch.status_4b3f= status_4b2c;
			if( !isValidBound(boundObjs_4b3d, stateVar_4b35, true))
				continue;
			currMatch.stateVar_4b40= stateVar_4b35;
			if( !isValidBound(boundObjs_4b3d, currSFChildState_4b39, false))
				continue;
			currMatch.sFChildState_4b41= currSFChildState_4b39;
			bool Gz_guard= isGuardTrue( currMatch.sFChildState_4b41, currMatch.sFState_4b3e, currMatch.stateVar_4b40, currMatch.status_4b3f);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void AndState_4b0f::outputAppender( const CyberComposition::Simulink::SFState& sFState_4b46, const SFC::Function& status_4b48, const SFC::StateVar& stateVar_4b4a)
{
	_sFState_4b19->push_back( sFState_4b46);
	_status_4b1a->push_back( status_4b48);
	_stateVar_4b1b->push_back( stateVar_4b4a);
}

bool OrState_4b4c::operator()( const Packets_t& sFStates_4b4d, const Packets_t& statuss_4b50, const Packets_t& stateVars_4b53, Packets_t& sFStates_4b4f, Packets_t& statuss_4b52, Packets_t& stateVars_4b55)
{
#ifdef PRINT_INFO
	printLog( "OrState_4b4c" );
#endif
	_sFState_4b56= &sFStates_4b4f;
	_status_4b57= &statuss_4b52;
	_stateVar_4b58= &stateVars_4b55;
	processInputPackets( sFStates_4b4d, statuss_4b50, stateVars_4b53);
	if( false== _matches.empty())
		return true;
	return false;
}

bool OrState_4b4c::isInputUnique( const Udm::Object& sFState_4b5d, const Udm::Object& status_4b66, const Udm::Object& stateVar_4b6f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4b5f= _sFState_4b59.begin(), itStatus_4b68= _status_4b62.begin(), itStateVar_4b71= _stateVar_4b6b.begin(); itSFState_4b5f!= _sFState_4b59.end(), itStatus_4b68!= _status_4b62.end(), itStateVar_4b71!= _stateVar_4b6b.end(); ++itSFState_4b5f, ++itStatus_4b68, ++itStateVar_4b71)
	{
		if( ( *itSFState_4b5f== sFState_4b5d)&& ( *itStatus_4b68== status_4b66)&& ( *itStateVar_4b71== stateVar_4b6f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4b59.push_back( sFState_4b5d);
		_status_4b62.push_back( status_4b66);
		_stateVar_4b6b.push_back( stateVar_4b6f);
	}
	return isUnique;
}

bool OrState_4b4c::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool OrState_4b4c::isGuardTrue( CyberComposition::Simulink::SFState& SFChildState, CyberComposition::Simulink::SFState& SFState, SFC::StateVar& StateVar, SFC::Function& Status)
{
	bool Gz_guard= false;
	return static_cast< std::string >( SFChildState.Decomposition() ) == "OR_STATE";;
	return Gz_guard;
}

void OrState_4b4c::processInputPackets( const Packets_t& sFStates_4b4d, const Packets_t& statuss_4b50, const Packets_t& stateVars_4b53)
{
	for( Packets_t::const_iterator itSFState_4b5a= sFStates_4b4d.begin(), itStatus_4b63= statuss_4b50.begin(), itStateVar_4b6c= stateVars_4b53.begin(); itSFState_4b5a!= sFStates_4b4d.end(), itStatus_4b63!= statuss_4b50.end(), itStateVar_4b6c!= stateVars_4b53.end(); ++itSFState_4b5a, ++itStatus_4b63, ++itStateVar_4b6c)
	{
		bool isUnique= isInputUnique( *itSFState_4b5a, *itStatus_4b63, *itStateVar_4b6c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4b5a, *itStatus_4b63, *itStateVar_4b6c);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4b7b, currMatch.status_4b7c, currMatch.stateVar_4b7d);
	}
}

bool OrState_4b4c::patternMatcher( const Udm::Object& sFState_4b5b, const Udm::Object& status_4b64, const Udm::Object& stateVar_4b6d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4b5b.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4b60= CyberComposition::Simulink::SFState::Cast( sFState_4b5b);
		if( false== Uml::IsDerivedFrom( status_4b64.type(), SFC::Function::meta))
			continue;
		SFC::Function status_4b69= SFC::Function::Cast( status_4b64);
		if( false== Uml::IsDerivedFrom( stateVar_4b6d.type(), SFC::StateVar::meta))
			continue;
		SFC::StateVar stateVar_4b72= SFC::StateVar::Cast( stateVar_4b6d);
		set< CyberComposition::Simulink::SFState> sFChildStates_4b74= sFState_4b60.SFState_kind_children();
		for( set< CyberComposition::Simulink::SFState>::const_iterator itSFChildState_4b75= sFChildStates_4b74.begin(); itSFChildState_4b75!= sFChildStates_4b74.end(); ++itSFChildState_4b75)
		{
			CyberComposition::Simulink::SFState currSFChildState_4b76= *itSFChildState_4b75;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_4b7a;
			if( !isValidBound(boundObjs_4b7a, sFState_4b60, true))
				continue;
			currMatch.sFState_4b7b= sFState_4b60;
			if( !isValidBound(boundObjs_4b7a, status_4b69, true))
				continue;
			currMatch.status_4b7c= status_4b69;
			if( !isValidBound(boundObjs_4b7a, stateVar_4b72, true))
				continue;
			currMatch.stateVar_4b7d= stateVar_4b72;
			if( !isValidBound(boundObjs_4b7a, currSFChildState_4b76, false))
				continue;
			currMatch.sFChildState_4b7e= currSFChildState_4b76;
			bool Gz_guard= isGuardTrue( currMatch.sFChildState_4b7e, currMatch.sFState_4b7b, currMatch.stateVar_4b7d, currMatch.status_4b7c);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void OrState_4b4c::outputAppender( const CyberComposition::Simulink::SFState& sFState_4b83, const SFC::Function& status_4b85, const SFC::StateVar& stateVar_4b87)
{
	_sFState_4b56->push_back( sFState_4b83);
	_status_4b57->push_back( status_4b85);
	_stateVar_4b58->push_back( stateVar_4b87);
}

void GetChildStates_4b89::operator()( const Packets_t& sFStates_4b8a, const Packets_t& compoundStatements_4b8e, const Packets_t& stateVars_4b91, Packets_t& sFStates_4b8c, Packets_t& sFChildStates_4b8d, Packets_t& compoundStatements_4b90, Packets_t& stateVars_4b93)
{
#ifdef PRINT_INFO
	printLog( "GetChildStates_4b89" );
#endif
	RTTGenerator::Instance()->generateRule(4130, "GetChildStates");
	_sFState_4b94= &sFStates_4b8c;
	_sFChildState_4b95= &sFChildStates_4b8d;
	_compoundStatement_4b96= &compoundStatements_4b90;
	_stateVar_4b97= &stateVars_4b93;
	processInputPackets( sFStates_4b8a, compoundStatements_4b8e, stateVars_4b91);
	sortOutputs( );
}

bool GetChildStates_4b89::isInputUnique( const Udm::Object& sFState_4b9c, const Udm::Object& compoundStatement_4ba5, const Udm::Object& stateVar_4bae)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4b9e= _sFState_4b98.begin(), itCompoundStatement_4ba7= _compoundStatement_4ba1.begin(), itStateVar_4bb0= _stateVar_4baa.begin(); itSFState_4b9e!= _sFState_4b98.end(), itCompoundStatement_4ba7!= _compoundStatement_4ba1.end(), itStateVar_4bb0!= _stateVar_4baa.end(); ++itSFState_4b9e, ++itCompoundStatement_4ba7, ++itStateVar_4bb0)
	{
		if( ( *itSFState_4b9e== sFState_4b9c)&& ( *itCompoundStatement_4ba7== compoundStatement_4ba5)&& ( *itStateVar_4bb0== stateVar_4bae))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4b98.push_back( sFState_4b9c);
		_compoundStatement_4ba1.push_back( compoundStatement_4ba5);
		_stateVar_4baa.push_back( stateVar_4bae);
	}
	return isUnique;
}

bool GetChildStates_4b89::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetChildStates_4b89::processInputPackets( const Packets_t& sFStates_4b8a, const Packets_t& compoundStatements_4b8e, const Packets_t& stateVars_4b91)
{
	for( Packets_t::const_iterator itSFState_4b99= sFStates_4b8a.begin(), itCompoundStatement_4ba2= compoundStatements_4b8e.begin(), itStateVar_4bab= stateVars_4b91.begin(); itSFState_4b99!= sFStates_4b8a.end(), itCompoundStatement_4ba2!= compoundStatements_4b8e.end(), itStateVar_4bab!= stateVars_4b91.end(); ++itSFState_4b99, ++itCompoundStatement_4ba2, ++itStateVar_4bab)
	{
		bool isUnique= isInputUnique( *itSFState_4b99, *itCompoundStatement_4ba2, *itStateVar_4bab);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4b99, *itCompoundStatement_4ba2, *itStateVar_4bab);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetChildStates_4b89::patternMatcher( const Udm::Object& sFState_4b9a, const Udm::Object& compoundStatement_4ba3, const Udm::Object& stateVar_4bac)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4b9a.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4b9f= CyberComposition::Simulink::SFState::Cast( sFState_4b9a);
		if( false== Uml::IsDerivedFrom( compoundStatement_4ba3.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_4ba8= SFC::CompoundStatement::Cast( compoundStatement_4ba3);
		if( false== Uml::IsDerivedFrom( stateVar_4bac.type(), SFC::StateVar::meta))
			continue;
		SFC::StateVar stateVar_4bb1= SFC::StateVar::Cast( stateVar_4bac);
		set< CyberComposition::Simulink::SFState> sFChildStates_4bb3= sFState_4b9f.SFState_kind_children();
		for( set< CyberComposition::Simulink::SFState>::const_iterator itSFChildState_4bb4= sFChildStates_4bb3.begin(); itSFChildState_4bb4!= sFChildStates_4bb3.end(); ++itSFChildState_4bb4)
		{
			CyberComposition::Simulink::SFState currSFChildState_4bb5= *itSFChildState_4bb4;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_4bb9;
			if( !isValidBound(boundObjs_4bb9, sFState_4b9f, true))
				continue;
			currMatch.sFState_4bba= sFState_4b9f;
			if( !isValidBound(boundObjs_4bb9, compoundStatement_4ba8, true))
				continue;
			currMatch.compoundStatement_4bbb= compoundStatement_4ba8;
			if( !isValidBound(boundObjs_4bb9, stateVar_4bb1, true))
				continue;
			currMatch.stateVar_4bbc= stateVar_4bb1;
			if( !isValidBound(boundObjs_4bb9, currSFChildState_4bb5, false))
				continue;
			currMatch.sFChildState_4bbd= currSFChildState_4bb5;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetChildStates_4b89::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4bba, currMatch.sFChildState_4bbd, currMatch.compoundStatement_4bbb, currMatch.stateVar_4bbc);
	}
}

void GetChildStates_4b89::outputAppender( const CyberComposition::Simulink::SFState& sFState_4bbe, const CyberComposition::Simulink::SFState& sFChildState_4bc0, const SFC::CompoundStatement& compoundStatement_4bc2, const SFC::StateVar& stateVar_4bc4)
{
	_sFState_4b94->push_back( sFState_4bbe);
	_sFChildState_4b95->push_back( sFChildState_4bc0);
	_compoundStatement_4b96->push_back( compoundStatement_4bc2);
	_stateVar_4b97->push_back( stateVar_4bc4);
}

void GetChildStates_4b89::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::SFState, std::pointer_to_binary_function< const CyberComposition::Simulink::SFState&, const CyberComposition::Simulink::SFState&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::SFState&, const CyberComposition::Simulink::SFState&, bool> ptr_StateOrder( StateOrder< CyberComposition::Simulink::SFState>);
	SortedSet_t sortedSet( ptr_StateOrder);
	std::vector< int> permutationVector( _sFChildState_4b95->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _sFChildState_4b95->begin(); it!= _sFChildState_4b95->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::SFState::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _sFChildState_4b95->begin());
	// order rest of the containers
	permutate( permutationVector, *_sFState_4b94);
	permutate( permutationVector, *_compoundStatement_4b96);
	permutate( permutationVector, *_stateVar_4b97);
}

void CreateConditionalGroup_4bc6::operator()( const Packets_t& sFStates_4bc7, const Packets_t& statuss_4bca, const Packets_t& stateVars_4bcd, Packets_t& sFStates_4bc9, Packets_t& conditionalGroups_4bcc, Packets_t& stateVars_4bcf)
{
#ifdef PRINT_INFO
	printLog( "CreateConditionalGroup_4bc6" );
#endif
	RTTGenerator::Instance()->generateRule(4136, "CreateConditionalGroup");
	_sFState_4bd0= &sFStates_4bc9;
	_conditionalGroup_4bd1= &conditionalGroups_4bcc;
	_stateVar_4bd2= &stateVars_4bcf;
	processInputPackets( sFStates_4bc7, statuss_4bca, stateVars_4bcd);
}

bool CreateConditionalGroup_4bc6::isInputUnique( const Udm::Object& sFState_4bd7, const Udm::Object& status_4be0, const Udm::Object& stateVar_4be9)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4bd9= _sFState_4bd3.begin(), itStatus_4be2= _status_4bdc.begin(), itStateVar_4beb= _stateVar_4be5.begin(); itSFState_4bd9!= _sFState_4bd3.end(), itStatus_4be2!= _status_4bdc.end(), itStateVar_4beb!= _stateVar_4be5.end(); ++itSFState_4bd9, ++itStatus_4be2, ++itStateVar_4beb)
	{
		if( ( *itSFState_4bd9== sFState_4bd7)&& ( *itStatus_4be2== status_4be0)&& ( *itStateVar_4beb== stateVar_4be9))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4bd3.push_back( sFState_4bd7);
		_status_4bdc.push_back( status_4be0);
		_stateVar_4be5.push_back( stateVar_4be9);
	}
	return isUnique;
}

bool CreateConditionalGroup_4bc6::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateConditionalGroup_4bc6::processInputPackets( const Packets_t& sFStates_4bc7, const Packets_t& statuss_4bca, const Packets_t& stateVars_4bcd)
{
	for( Packets_t::const_iterator itSFState_4bd4= sFStates_4bc7.begin(), itStatus_4bdd= statuss_4bca.begin(), itStateVar_4be6= stateVars_4bcd.begin(); itSFState_4bd4!= sFStates_4bc7.end(), itStatus_4bdd!= statuss_4bca.end(), itStateVar_4be6!= stateVars_4bcd.end(); ++itSFState_4bd4, ++itStatus_4bdd, ++itStateVar_4be6)
	{
		bool isUnique= isInputUnique( *itSFState_4bd4, *itStatus_4bdd, *itStateVar_4be6);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4bd4, *itStatus_4bdd, *itStateVar_4be6);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateConditionalGroup_4bc6::patternMatcher( const Udm::Object& sFState_4bd5, const Udm::Object& status_4bde, const Udm::Object& stateVar_4be7)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4bd5.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4bda= CyberComposition::Simulink::SFState::Cast( sFState_4bd5);
		if( false== Uml::IsDerivedFrom( status_4bde.type(), SFC::Function::meta))
			continue;
		SFC::Function status_4be3= SFC::Function::Cast( status_4bde);
		if( false== Uml::IsDerivedFrom( stateVar_4be7.type(), SFC::StateVar::meta))
			continue;
		SFC::StateVar stateVar_4bec= SFC::StateVar::Cast( stateVar_4be7);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4bf1;
		if( !isValidBound(boundObjs_4bf1, sFState_4bda, true))
			continue;
		currMatch.sFState_4bf2= sFState_4bda;
		if( !isValidBound(boundObjs_4bf1, status_4be3, true))
			continue;
		currMatch.status_4bf3= status_4be3;
		if( !isValidBound(boundObjs_4bf1, stateVar_4bec, true))
			continue;
		currMatch.stateVar_4bf4= stateVar_4bec;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateConditionalGroup_4bc6::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalGroup newConditionalGroup_4bf5= SFC::ConditionalGroup::Create( currMatch.status_4bf3, SFC::Function::meta_stmnt);
		SFC::ConditionalGroup& ConditionalGroup= newConditionalGroup_4bf5;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_4bf2;
		SFC::StateVar& StateVar= currMatch.stateVar_4bf4;
		SFC::Function& Status= currMatch.status_4bf3;
		{
ConditionalGroup.RefId() = Status.RefId();
};
		{
__int64 statementCount = Status.statementCount();
ConditionalGroup.statementIndex() = statementCount++;
Status.statementCount() = statementCount;
};
		outputAppender( currMatch.sFState_4bf2, newConditionalGroup_4bf5, currMatch.stateVar_4bf4);
	}
}

void CreateConditionalGroup_4bc6::outputAppender( const CyberComposition::Simulink::SFState& sFState_4bf6, const SFC::ConditionalGroup& conditionalGroup_4bf8, const SFC::StateVar& stateVar_4bfa)
{
	_sFState_4bd0->push_back( sFState_4bf6);
	_conditionalGroup_4bd1->push_back( conditionalGroup_4bf8);
	_stateVar_4bd2->push_back( stateVar_4bfa);
}

void GetStatusFunction_4bfc::operator()( const Packets_t& sFStates_4bfd, Packets_t& sFStates_4bff, Packets_t& statuss_4c00)
{
#ifdef PRINT_INFO
	printLog( "GetStatusFunction_4bfc" );
#endif
	RTTGenerator::Instance()->generateRule(4144, "GetStatusFunction");
	_sFState_4c01= &sFStates_4bff;
	_status_4c02= &statuss_4c00;
	processInputPackets( sFStates_4bfd);
}

bool GetStatusFunction_4bfc::isInputUnique( const Udm::Object& sFState_4c07)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4c09= _sFState_4c03.begin(); itSFState_4c09!= _sFState_4c03.end(); ++itSFState_4c09)
	{
		if( ( *itSFState_4c09== sFState_4c07))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_sFState_4c03.push_back( sFState_4c07);
	return isUnique;
}

bool GetStatusFunction_4bfc::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetStatusFunction_4bfc::processInputPackets( const Packets_t& sFStates_4bfd)
{
	for( Packets_t::const_iterator itSFState_4c04= sFStates_4bfd.begin(); itSFState_4c04!= sFStates_4bfd.end(); ++itSFState_4c04)
	{
		bool isUnique= isInputUnique( *itSFState_4c04);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4c04);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetStatusFunction_4bfc::patternMatcher( const Udm::Object& sFState_4c05)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4c05.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4c0a= CyberComposition::Simulink::SFState::Cast( sFState_4c05);
		set< SFC::Function> statuss_4c0c= sFState_4c0a.status();
		for( set< SFC::Function>::const_iterator itStatuss_4c0d= statuss_4c0c.begin(); itStatuss_4c0d!= statuss_4c0c.end(); ++itStatuss_4c0d)
		{
			SFC::Function currStatus_4c0e= *itStatuss_4c0d;
			set< SFC::Arg> args_4c0f= currStatus_4c0e.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itArg_4c10= args_4c0f.begin(); itArg_4c10!= args_4c0f.end(); ++itArg_4c10)
			{
				SFC::Arg currArg_4c11= *itArg_4c10;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_4c15;
				if( !isValidBound(boundObjs_4c15, sFState_4c0a, true))
					continue;
				currMatch.sFState_4c16= sFState_4c0a;
				if( !isValidBound(boundObjs_4c15, currStatus_4c0e, false))
					continue;
				currMatch.status_4c17= currStatus_4c0e;
				if( !isValidBound(boundObjs_4c15, currArg_4c11, false))
					continue;
				currMatch.arg_4c18= currArg_4c11;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetStatusFunction_4bfc::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newretval_4c19= SFC::LocalVar::Create( currMatch.status_4c17, SFC::Function::meta_stmnt);
		SFC::UserCode newretvalAssign_4c1a= SFC::UserCode::Create( currMatch.status_4c17, SFC::Function::meta_stmnt);
		SFC::BinaryExprs newAssign_4c1b= SFC::BinaryExprs::Create( newretvalAssign_4c1a, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newPlus_4c1c= SFC::BinaryExprs::Create( newAssign_4c1b, SFC::BinaryExprs::meta_rightexpr);
		SFC::Str newStr_4c1d= SFC::Str::Create( newPlus_4c1c, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef1_4c1e= SFC::ArgDeclRef::Create( newPlus_4c1c, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_4c1f= SFC::ArgDeclRef::Create( newAssign_4c1b, SFC::BinaryExprs::meta_leftexpr);
		SFC::Arg& Arg= currMatch.arg_4c18;
		SFC::ArgDeclRef& ArgDeclRef1= newArgDeclRef1_4c1e;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_4c1f;
		SFC::BinaryExprs& Assign= newAssign_4c1b;
		SFC::BinaryExprs& Plus= newPlus_4c1c;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_4c16;
		SFC::Function& Status= currMatch.status_4c17;
		SFC::Str& Str= newStr_4c1d;
		SFC::LocalVar& retval= newretval_4c19;
		SFC::UserCode& retvalAssign= newretvalAssign_4c1a;
		{
retval.RefId() = retvalAssign.RefId() = Status.RefId();
};
		{
Plus.op() = "+";
};
		{
Assign.op() = "=";
};
		{
Str.val() = static_cast< std::string >( SFState.name() ) + "\\n";
};
		{
retval.name() = "retval";
retval.dt() = SFCTypesManager::getSingleton().getBasicType( "string" );
};
		{
__int64 statementCount = Status.statementCount();
retval.statementIndex() = statementCount++;
retvalAssign.statementIndex() = statementCount++;
Status.statementCount() = statementCount;
};
		newArgDeclRef1_4c1e.argdecl()= currMatch.arg_4c18;
		newArgDeclRef2_4c1f.argdecl()= newretval_4c19;
		outputAppender( currMatch.sFState_4c16, currMatch.status_4c17);
	}
}

void GetStatusFunction_4bfc::outputAppender( const CyberComposition::Simulink::SFState& sFState_4c20, const SFC::Function& status_4c22)
{
	_sFState_4c01->push_back( sFState_4c20);
	_status_4c02->push_back( status_4c22);
}

void NoFunctionStates_4c42::operator()( const Packets_t& states_4c43, const Packets_t& programs_4c45, Packets_t& states_4c47, Packets_t& programs_4c48)
{
#ifdef PRINT_INFO
	printLog( "NoFunctionStates_4c42" );
#endif
	_state_4c49= &states_4c47;
	_program_4c4a= &programs_4c48;
	for( Packets_t::const_iterator itstate_4c4c= states_4c43.begin(), itprogram_4c53= programs_4c45.begin(); itstate_4c4c!= states_4c43.end(), itprogram_4c53!= programs_4c45.end(); ++itstate_4c4c, ++itprogram_4c53)
	{
		bool isUnique= isInputUnique( *itstate_4c4c, *itprogram_4c53);
		if( !isUnique)
			continue;
		Packets_t onestate_4c50( 1, *itstate_4c4c);
		Packets_t oneprogram_4c57( 1, *itprogram_4c53);
		executeOne( onestate_4c50, oneprogram_4c57);
	}
}

void NoFunctionStates_4c42::executeOne( const Packets_t& states_4c43, const Packets_t& programs_4c45)
{
	Packets_t sFStates_4c5c;
	Packets_t programs_4c5f;
	NotFunctionState_4c59 notFunctionState_4c59;
	bool isMatchNotFunctionState_4c59= notFunctionState_4c59( states_4c43, programs_4c45, sFStates_4c5c, programs_4c5f);
	_state_4c49->insert( _state_4c49->end(), sFStates_4c5c.begin(), sFStates_4c5c.end());
	_program_4c4a->insert( _program_4c4a->end(), programs_4c5f.begin(), programs_4c5f.end());
	if( isMatchNotFunctionState_4c59)
		return;
}

bool NoFunctionStates_4c42::isInputUnique( const Udm::Object& state_4c4d, const Udm::Object& program_4c54)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_4c4f= _state_4c4b.begin(), itprogram_4c56= _program_4c52.begin(); itstate_4c4f!= _state_4c4b.end(), itprogram_4c56!= _program_4c52.end(); ++itstate_4c4f, ++itprogram_4c56)
	{
		if( ( *itstate_4c4f== state_4c4d)&& ( *itprogram_4c56== program_4c54))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_4c4b.push_back( state_4c4d);
		_program_4c52.push_back( program_4c54);
	}
	return isUnique;
}

bool NotFunctionState_4c59::operator()( const Packets_t& sFStates_4c5a, const Packets_t& programs_4c5d, Packets_t& sFStates_4c5c, Packets_t& programs_4c5f)
{
#ifdef PRINT_INFO
	printLog( "NotFunctionState_4c59" );
#endif
	_sFState_4c60= &sFStates_4c5c;
	_program_4c61= &programs_4c5f;
	processInputPackets( sFStates_4c5a, programs_4c5d);
	if( false== _matches.empty())
		return true;
	return false;
}

bool NotFunctionState_4c59::isInputUnique( const Udm::Object& sFState_4c66, const Udm::Object& program_4c6f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4c68= _sFState_4c62.begin(), itProgram_4c71= _program_4c6b.begin(); itSFState_4c68!= _sFState_4c62.end(), itProgram_4c71!= _program_4c6b.end(); ++itSFState_4c68, ++itProgram_4c71)
	{
		if( ( *itSFState_4c68== sFState_4c66)&& ( *itProgram_4c71== program_4c6f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4c62.push_back( sFState_4c66);
		_program_4c6b.push_back( program_4c6f);
	}
	return isUnique;
}

bool NotFunctionState_4c59::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool NotFunctionState_4c59::isGuardTrue( SFC::Program& Program, CyberComposition::Simulink::SFState& SFState)
{
	bool Gz_guard= false;
	return static_cast< std::string >( SFState.Decomposition() ) != "FUNC_STATE";;
	return Gz_guard;
}

void NotFunctionState_4c59::processInputPackets( const Packets_t& sFStates_4c5a, const Packets_t& programs_4c5d)
{
	for( Packets_t::const_iterator itSFState_4c63= sFStates_4c5a.begin(), itProgram_4c6c= programs_4c5d.begin(); itSFState_4c63!= sFStates_4c5a.end(), itProgram_4c6c!= programs_4c5d.end(); ++itSFState_4c63, ++itProgram_4c6c)
	{
		bool isUnique= isInputUnique( *itSFState_4c63, *itProgram_4c6c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4c63, *itProgram_4c6c);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4c78, currMatch.program_4c79);
	}
}

bool NotFunctionState_4c59::patternMatcher( const Udm::Object& sFState_4c64, const Udm::Object& program_4c6d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4c64.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4c69= CyberComposition::Simulink::SFState::Cast( sFState_4c64);
		if( false== Uml::IsDerivedFrom( program_4c6d.type(), SFC::Program::meta))
			continue;
		SFC::Program program_4c72= SFC::Program::Cast( program_4c6d);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4c77;
		if( !isValidBound(boundObjs_4c77, sFState_4c69, true))
			continue;
		currMatch.sFState_4c78= sFState_4c69;
		if( !isValidBound(boundObjs_4c77, program_4c72, true))
			continue;
		currMatch.program_4c79= program_4c72;
		bool Gz_guard= isGuardTrue( currMatch.program_4c79, currMatch.sFState_4c78);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void NotFunctionState_4c59::outputAppender( const CyberComposition::Simulink::SFState& sFState_4c7c, const SFC::Program& program_4c7e)
{
	_sFState_4c60->push_back( sFState_4c7c);
	_program_4c61->push_back( program_4c7e);
}

void PopulateEnterFunction_4c80::operator()( const Packets_t& states_4c81, const Packets_t& programs_4c83, Packets_t& states_4c85, Packets_t& programs_4c86)
{
#ifdef PRINT_INFO
	printLog( "PopulateEnterFunction_4c80" );
#endif
	_state_4c87= &states_4c85;
	_program_4c88= &programs_4c86;
	if( ( !states_4c81.empty()))
		callTestEAIOff_5030( states_4c81);
	_state_4c87->insert( _state_4c87->end(), states_4c81.begin(), states_4c81.end());
	_program_4c88->insert( _program_4c88->end(), programs_4c83.begin(), programs_4c83.end());
}

void PopulateEnterFunction_4c80::callTestEAIOff_5030( const Packets_t& states_4c8a)
{
	Packets_t states_4c8c;
	Packets_t states_4c8d;
	TestEAIOff_4c89 testEAIOff_4c89;
	testEAIOff_4c89( states_4c8a, states_4c8c, states_4c8d);
	if( ( !states_4c8d.empty()))
		callReturnAtTopState_5032( states_4c8d);
}

void PopulateEnterFunction_4c80::callReturnAtTopState_5032( const Packets_t& states_5003)
{
	Packets_t states_5005;
	ReturnAtTopState_5002 returnAtTopState_5002;
	returnAtTopState_5002( states_5003, states_5005);
	if( ( !states_5005.empty()))
		callMode0or1_5034( states_5005);
}

void PopulateEnterFunction_4c80::callMode0or1_5034( const Packets_t& states_4f7a)
{
	Packets_t states_4f7c;
	Mode0or1_4f79 mode0or1_4f79;
	mode0or1_4f79( states_4f7a, states_4f7c);
	if( ( !states_4f7c.empty()))
		callMode0or1or2_5036( states_4f7c);
}

void PopulateEnterFunction_4c80::callMode0or1or2_5036( const Packets_t& states_4f39)
{
	Packets_t states_4f3b;
	Mode0or1or2_4f38 mode0or1or2_4f38;
	mode0or1or2_4f38( states_4f39, states_4f3b);
	if( ( !states_4f3b.empty()))
		callMode0or2_5038( states_4f3b);
}

void PopulateEnterFunction_4c80::callMode0or2_5038( const Packets_t& states_4e0a)
{
	Packets_t states_4e0c;
	Mode0or2_4e09 mode0or2_4e09;
	mode0or2_4e09( states_4e0a, states_4e0c);
	if( ( !states_4e0c.empty()))
		callMode0or3_503a( states_4e0c);
}

void PopulateEnterFunction_4c80::callMode0or3_503a( const Packets_t& states_4ccc)
{
	Packets_t states_4cce;
	Mode0or3_4ccb mode0or3_4ccb;
	mode0or3_4ccb( states_4ccc, states_4cce);
}

void TestEAIOff_4c89::operator()( const Packets_t& states_4c8a, Packets_t& states_4c8c, Packets_t& states_4c8d)
{
#ifdef PRINT_INFO
	printLog( "TestEAIOff_4c89" );
#endif
	_state_4c8e= &states_4c8c;
	_state_4c8f= &states_4c8d;
	for( Packets_t::const_iterator itstate_4c91= states_4c8a.begin(); itstate_4c91!= states_4c8a.end(); ++itstate_4c91)
	{
		bool isUnique= isInputUnique( *itstate_4c91);
		if( !isUnique)
			continue;
		Packets_t onestate_4c95( 1, *itstate_4c91);
		executeOne( onestate_4c95);
	}
}

void TestEAIOff_4c89::executeOne( const Packets_t& states_4c8a)
{
	Packets_t sFStates_4c9a;
	EAIOff_4c97 eAIOff_4c97;
	bool isMatchEAIOff_4c97= eAIOff_4c97( states_4c8a, sFStates_4c9a);
	_state_4c8e->insert( _state_4c8e->end(), sFStates_4c9a.begin(), sFStates_4c9a.end());
	if( isMatchEAIOff_4c97)
		return;
	Packets_t sFStates_4cb9;
	Otherwise_4cb6 otherwise_4cb6;
	bool isMatchOtherwise_4cb6= otherwise_4cb6( states_4c8a, sFStates_4cb9);
	_state_4c8f->insert( _state_4c8f->end(), sFStates_4cb9.begin(), sFStates_4cb9.end());
	if( isMatchOtherwise_4cb6)
		return;
}

bool TestEAIOff_4c89::isInputUnique( const Udm::Object& state_4c92)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_4c94= _state_4c90.begin(); itstate_4c94!= _state_4c90.end(); ++itstate_4c94)
	{
		if( ( *itstate_4c94== state_4c92))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_4c90.push_back( state_4c92);
	return isUnique;
}

bool EAIOff_4c97::operator()( const Packets_t& sFStates_4c98, Packets_t& sFStates_4c9a)
{
#ifdef PRINT_INFO
	printLog( "EAIOff_4c97" );
#endif
	_sFState_4c9b= &sFStates_4c9a;
	processInputPackets( sFStates_4c98);
	if( false== _matches.empty())
		return true;
	return false;
}

bool EAIOff_4c97::isInputUnique( const Udm::Object& sFState_4ca0)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4ca2= _sFState_4c9c.begin(); itSFState_4ca2!= _sFState_4c9c.end(); ++itSFState_4ca2)
	{
		if( ( *itSFState_4ca2== sFState_4ca0))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_sFState_4c9c.push_back( sFState_4ca0);
	return isUnique;
}

bool EAIOff_4c97::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool EAIOff_4c97::isGuardTrue( CyberComposition::Simulink::SF_Parameter& Parameter, CyberComposition::Simulink::SFState& SFState, CyberComposition::Simulink::Subsystem& Subsystem)
{
	bool Gz_guard= false;
	return static_cast< std::string >( Parameter.name() ) == "ExecuteAtInitialization" &&
 static_cast< std::string >(  Parameter.Value() ) == "off";;
	return Gz_guard;
}

void EAIOff_4c97::processInputPackets( const Packets_t& sFStates_4c98)
{
	for( Packets_t::const_iterator itSFState_4c9d= sFStates_4c98.begin(); itSFState_4c9d!= sFStates_4c98.end(); ++itSFState_4c9d)
	{
		bool isUnique= isInputUnique( *itSFState_4c9d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4c9d);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4cae);
	}
}

bool EAIOff_4c97::patternMatcher( const Udm::Object& sFState_4c9e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4c9e.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4ca3= CyberComposition::Simulink::SFState::Cast( sFState_4c9e);
		Udm::Object sFStateParent_4ca5= sFState_4ca3.container();
		if( false== Uml::IsDerivedFrom( sFStateParent_4ca5.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystemSFState_4ca6= CyberComposition::Simulink::Subsystem::Cast( sFStateParent_4ca5);
		set< CyberComposition::Simulink::SF_Parameter> parameters_4ca7= subsystemSFState_4ca6.SF_Parameter_kind_children();
		for( set< CyberComposition::Simulink::SF_Parameter>::const_iterator itParameter_4ca8= parameters_4ca7.begin(); itParameter_4ca8!= parameters_4ca7.end(); ++itParameter_4ca8)
		{
			CyberComposition::Simulink::SF_Parameter currParameter_4ca9= *itParameter_4ca8;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_4cad;
			if( !isValidBound(boundObjs_4cad, sFState_4ca3, true))
				continue;
			currMatch.sFState_4cae= sFState_4ca3;
			if( !isValidBound(boundObjs_4cad, currParameter_4ca9, false))
				continue;
			currMatch.parameter_4caf= currParameter_4ca9;
			if( !isValidBound(boundObjs_4cad, subsystemSFState_4ca6, false))
				continue;
			currMatch.subsystem_4cb0= subsystemSFState_4ca6;
			bool Gz_guard= isGuardTrue( currMatch.parameter_4caf, currMatch.sFState_4cae, currMatch.subsystem_4cb0);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void EAIOff_4c97::outputAppender( const CyberComposition::Simulink::SFState& sFState_4cb4)
{
	_sFState_4c9b->push_back( sFState_4cb4);
}

bool Otherwise_4cb6::operator()( const Packets_t& sFStates_4cb7, Packets_t& sFStates_4cb9)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_4cb6" );
#endif
	_sFState_4cba= &sFStates_4cb9;
	processInputPackets( sFStates_4cb7);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_4cb6::isInputUnique( const Udm::Object& sFState_4cbf)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4cc1= _sFState_4cbb.begin(); itSFState_4cc1!= _sFState_4cbb.end(); ++itSFState_4cc1)
	{
		if( ( *itSFState_4cc1== sFState_4cbf))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_sFState_4cbb.push_back( sFState_4cbf);
	return isUnique;
}

bool Otherwise_4cb6::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_4cb6::processInputPackets( const Packets_t& sFStates_4cb7)
{
	for( Packets_t::const_iterator itSFState_4cbc= sFStates_4cb7.begin(); itSFState_4cbc!= sFStates_4cb7.end(); ++itSFState_4cbc)
	{
		bool isUnique= isInputUnique( *itSFState_4cbc);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4cbc);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4cc8);
	}
}

bool Otherwise_4cb6::patternMatcher( const Udm::Object& sFState_4cbd)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4cbd.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4cc2= CyberComposition::Simulink::SFState::Cast( sFState_4cbd);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4cc7;
		if( !isValidBound(boundObjs_4cc7, sFState_4cc2, true))
			continue;
		currMatch.sFState_4cc8= sFState_4cc2;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_4cb6::outputAppender( const CyberComposition::Simulink::SFState& sFState_4cc9)
{
	_sFState_4cba->push_back( sFState_4cc9);
}

void Mode0or3_4ccb::operator()( const Packets_t& states_4ccc, Packets_t& states_4cce)
{
#ifdef PRINT_INFO
	printLog( "Mode0or3_4ccb" );
#endif
	_state_4ccf= &states_4cce;
	_state_4ccf->insert( _state_4ccf->end(), states_4ccc.begin(), states_4ccc.end());
	if( ( !states_4ccc.empty()))
		callTestMode03_4e01( states_4ccc);
}

void Mode0or3_4ccb::callTestMode03_4e01( const Packets_t& sFStates_4dd8)
{
	Packets_t sFStates_4dda;
	Packets_t conditionalBlocks_4ddb;
	TestMode03_4dd7 testMode03_4dd7;
	testMode03_4dd7( sFStates_4dd8, sFStates_4dda, conditionalBlocks_4ddb);
	if( ( !sFStates_4dda.empty())&& ( !conditionalBlocks_4ddb.empty()))
		callCallLOSibs_4e03( sFStates_4dda, conditionalBlocks_4ddb);
}

void Mode0or3_4ccb::callCallLOSibs_4e03( const Packets_t& states_4cd1, const Packets_t& css_4cd3)
{
	Packets_t states_4cd5;
	Packets_t css_4cd6;
	CallLOSibs_4cd0 callLOSibs_4cd0;
	callLOSibs_4cd0( states_4cd1, css_4cd3, states_4cd5, css_4cd6);
	if( ( !states_4cd5.empty())&& ( !css_4cd6.empty()))
		callCallParent_4e06( states_4cd5, css_4cd6);
}

void Mode0or3_4ccb::callCallParent_4e06( const Packets_t& sFStates_4d9a, const Packets_t& conditionalBlocks_4d9c)
{
	CallParent_4d99 callParent_4d99;
	callParent_4d99( sFStates_4d9a, conditionalBlocks_4d9c);
}

void CallLOSibs_4cd0::operator()( const Packets_t& states_4cd1, const Packets_t& css_4cd3, Packets_t& states_4cd5, Packets_t& css_4cd6)
{
#ifdef PRINT_INFO
	printLog( "CallLOSibs_4cd0" );
#endif
	_state_4cd7= &states_4cd5;
	_cs_4cd8= &css_4cd6;
	if( ( !states_4cd1.empty())&& ( !css_4cd3.empty()))
		callIsAndState_4d8f( states_4cd1, css_4cd3);
	_state_4cd7->insert( _state_4cd7->end(), states_4cd1.begin(), states_4cd1.end());
	_cs_4cd8->insert( _cs_4cd8->end(), css_4cd3.begin(), css_4cd3.end());
}

void CallLOSibs_4cd0::callIsAndState_4d8f( const Packets_t& states_4d0b, const Packets_t& css_4d0d)
{
	Packets_t states_4d0f;
	Packets_t css_4d10;
	IsAndState_4d0a isAndState_4d0a;
	isAndState_4d0a( states_4d0b, css_4d0d, states_4d0f, css_4d10);
	if( ( !states_4d0f.empty())&& ( !css_4d10.empty()))
		callGetLOSibs_4d92( states_4d0f, css_4d10);
}

void CallLOSibs_4cd0::callGetLOSibs_4d92( const Packets_t& sFStates_4cda, const Packets_t& compoundStatements_4cde)
{
	Packets_t sFStates_4cdc;
	Packets_t sFSibStates_4cdd;
	Packets_t compoundStatements_4ce0;
	GetLOSibs_4cd9 getLOSibs_4cd9;
	getLOSibs_4cd9( sFStates_4cda, compoundStatements_4cde, sFStates_4cdc, sFSibStates_4cdd, compoundStatements_4ce0);
	if( ( !sFStates_4cdc.empty())&& ( !sFSibStates_4cdd.empty())&& ( !compoundStatements_4ce0.empty()))
		callCallSibsOrChildren_4d95( sFStates_4cdc, sFSibStates_4cdd, compoundStatements_4ce0);
}

void CallLOSibs_4cd0::callCallSibsOrChildren_4d95( const Packets_t& sFStates_4d46, const Packets_t& sFSOCStates_4d48, const Packets_t& compoundStatements_4d4a)
{
	CallSibsOrChildren_4d45 callSibsOrChildren_4d45;
	callSibsOrChildren_4d45( sFStates_4d46, sFSOCStates_4d48, compoundStatements_4d4a);
}

void GetLOSibs_4cd9::operator()( const Packets_t& sFStates_4cda, const Packets_t& compoundStatements_4cde, Packets_t& sFStates_4cdc, Packets_t& sFSibStates_4cdd, Packets_t& compoundStatements_4ce0)
{
#ifdef PRINT_INFO
	printLog( "GetLOSibs_4cd9" );
#endif
	RTTGenerator::Instance()->generateRule(4205, "GetLOSibs");
	_sFState_4ce1= &sFStates_4cdc;
	_sFSibState_4ce2= &sFSibStates_4cdd;
	_compoundStatement_4ce3= &compoundStatements_4ce0;
	processInputPackets( sFStates_4cda, compoundStatements_4cde);
	sortOutputs( );
}

bool GetLOSibs_4cd9::isInputUnique( const Udm::Object& sFState_4ce8, const Udm::Object& compoundStatement_4cf1)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4cea= _sFState_4ce4.begin(), itCompoundStatement_4cf3= _compoundStatement_4ced.begin(); itSFState_4cea!= _sFState_4ce4.end(), itCompoundStatement_4cf3!= _compoundStatement_4ced.end(); ++itSFState_4cea, ++itCompoundStatement_4cf3)
	{
		if( ( *itSFState_4cea== sFState_4ce8)&& ( *itCompoundStatement_4cf3== compoundStatement_4cf1))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4ce4.push_back( sFState_4ce8);
		_compoundStatement_4ced.push_back( compoundStatement_4cf1);
	}
	return isUnique;
}

bool GetLOSibs_4cd9::isGuardTrue( SFC::CompoundStatement& CompoundStatement, CyberComposition::Simulink::SFState& SFParentState, CyberComposition::Simulink::SFState& SFSibState, CyberComposition::Simulink::SFState& SFState)
{
	bool Gz_guard= false;
	std::string stateOrder = SFManager::trim(  static_cast< std::string >( SFState.Order() )  );
if ( stateOrder.empty() ) stateOrder = "0";

std::string sibStateOrder = SFManager::trim(  static_cast< std::string >( SFSibState.Order() )  );
if ( sibStateOrder.empty() ) sibStateOrder = "0";

return boost::lexical_cast< int >( stateOrder ) > boost::lexical_cast< int >( sibStateOrder );;
	return Gz_guard;
}

void GetLOSibs_4cd9::processInputPackets( const Packets_t& sFStates_4cda, const Packets_t& compoundStatements_4cde)
{
	for( Packets_t::const_iterator itSFState_4ce5= sFStates_4cda.begin(), itCompoundStatement_4cee= compoundStatements_4cde.begin(); itSFState_4ce5!= sFStates_4cda.end(), itCompoundStatement_4cee!= compoundStatements_4cde.end(); ++itSFState_4ce5, ++itCompoundStatement_4cee)
	{
		bool isUnique= isInputUnique( *itSFState_4ce5, *itCompoundStatement_4cee);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4ce5, *itCompoundStatement_4cee);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetLOSibs_4cd9::patternMatcher( const Udm::Object& sFState_4ce6, const Udm::Object& compoundStatement_4cef)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4ce6.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4ceb= CyberComposition::Simulink::SFState::Cast( sFState_4ce6);
		if( false== Uml::IsDerivedFrom( compoundStatement_4cef.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_4cf4= SFC::CompoundStatement::Cast( compoundStatement_4cef);
		Udm::Object sFStateParent_4cf6= sFState_4ceb.container();
		if( false== Uml::IsDerivedFrom( sFStateParent_4cf6.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFParentStateSFState_4cf7= CyberComposition::Simulink::SFState::Cast( sFStateParent_4cf6);
		set< CyberComposition::Simulink::SFState> sFSibStates_4cf8= sFParentStateSFState_4cf7.SFState_kind_children();
		for( set< CyberComposition::Simulink::SFState>::const_iterator itSFSibState_4cf9= sFSibStates_4cf8.begin(); itSFSibState_4cf9!= sFSibStates_4cf8.end(); ++itSFSibState_4cf9)
		{
			CyberComposition::Simulink::SFState currSFSibState_4cfa= *itSFSibState_4cf9;
			Match currMatch;
			currMatch.sFState_4cfc= sFState_4ceb;
			currMatch.compoundStatement_4cfd= compoundStatement_4cf4;
			currMatch.sFParentState_4cfe= sFParentStateSFState_4cf7;
			currMatch.sFSibState_4cff= currSFSibState_4cfa;
			bool Gz_guard= isGuardTrue( currMatch.compoundStatement_4cfd, currMatch.sFParentState_4cfe, currMatch.sFSibState_4cff, currMatch.sFState_4cfc);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetLOSibs_4cd9::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4cfc, currMatch.sFSibState_4cff, currMatch.compoundStatement_4cfd);
	}
}

void GetLOSibs_4cd9::outputAppender( const CyberComposition::Simulink::SFState& sFState_4d04, const CyberComposition::Simulink::SFState& sFSibState_4d06, const SFC::CompoundStatement& compoundStatement_4d08)
{
	_sFState_4ce1->push_back( sFState_4d04);
	_sFSibState_4ce2->push_back( sFSibState_4d06);
	_compoundStatement_4ce3->push_back( compoundStatement_4d08);
}

void GetLOSibs_4cd9::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::SFState, std::pointer_to_binary_function< const CyberComposition::Simulink::SFState&, const CyberComposition::Simulink::SFState&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::SFState&, const CyberComposition::Simulink::SFState&, bool> ptr_StateOrder( StateOrder< CyberComposition::Simulink::SFState>);
	SortedSet_t sortedSet( ptr_StateOrder);
	std::vector< int> permutationVector( _sFSibState_4ce2->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _sFSibState_4ce2->begin(); it!= _sFSibState_4ce2->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::SFState::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _sFSibState_4ce2->begin());
	// order rest of the containers
	permutate( permutationVector, *_sFState_4ce1);
	permutate( permutationVector, *_compoundStatement_4ce3);
}

void IsAndState_4d0a::operator()( const Packets_t& states_4d0b, const Packets_t& css_4d0d, Packets_t& states_4d0f, Packets_t& css_4d10)
{
#ifdef PRINT_INFO
	printLog( "IsAndState_4d0a" );
#endif
	_state_4d11= &states_4d0f;
	_cs_4d12= &css_4d10;
	for( Packets_t::const_iterator itstate_4d14= states_4d0b.begin(), itcs_4d1b= css_4d0d.begin(); itstate_4d14!= states_4d0b.end(), itcs_4d1b!= css_4d0d.end(); ++itstate_4d14, ++itcs_4d1b)
	{
		bool isUnique= isInputUnique( *itstate_4d14, *itcs_4d1b);
		if( !isUnique)
			continue;
		Packets_t onestate_4d18( 1, *itstate_4d14);
		Packets_t onecs_4d1f( 1, *itcs_4d1b);
		executeOne( onestate_4d18, onecs_4d1f);
	}
}

void IsAndState_4d0a::executeOne( const Packets_t& states_4d0b, const Packets_t& css_4d0d)
{
	Packets_t sFStates_4d24;
	Packets_t compoundStatements_4d27;
	AndState_4d21 andState_4d21;
	bool isMatchAndState_4d21= andState_4d21( states_4d0b, css_4d0d, sFStates_4d24, compoundStatements_4d27);
	_state_4d11->insert( _state_4d11->end(), sFStates_4d24.begin(), sFStates_4d24.end());
	_cs_4d12->insert( _cs_4d12->end(), compoundStatements_4d27.begin(), compoundStatements_4d27.end());
	if( isMatchAndState_4d21)
		return;
}

bool IsAndState_4d0a::isInputUnique( const Udm::Object& state_4d15, const Udm::Object& cs_4d1c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_4d17= _state_4d13.begin(), itcs_4d1e= _cs_4d1a.begin(); itstate_4d17!= _state_4d13.end(), itcs_4d1e!= _cs_4d1a.end(); ++itstate_4d17, ++itcs_4d1e)
	{
		if( ( *itstate_4d17== state_4d15)&& ( *itcs_4d1e== cs_4d1c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_4d13.push_back( state_4d15);
		_cs_4d1a.push_back( cs_4d1c);
	}
	return isUnique;
}

bool AndState_4d21::operator()( const Packets_t& sFStates_4d22, const Packets_t& compoundStatements_4d25, Packets_t& sFStates_4d24, Packets_t& compoundStatements_4d27)
{
#ifdef PRINT_INFO
	printLog( "AndState_4d21" );
#endif
	_sFState_4d28= &sFStates_4d24;
	_compoundStatement_4d29= &compoundStatements_4d27;
	processInputPackets( sFStates_4d22, compoundStatements_4d25);
	if( false== _matches.empty())
		return true;
	return false;
}

bool AndState_4d21::isInputUnique( const Udm::Object& sFState_4d2e, const Udm::Object& compoundStatement_4d37)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4d30= _sFState_4d2a.begin(), itCompoundStatement_4d39= _compoundStatement_4d33.begin(); itSFState_4d30!= _sFState_4d2a.end(), itCompoundStatement_4d39!= _compoundStatement_4d33.end(); ++itSFState_4d30, ++itCompoundStatement_4d39)
	{
		if( ( *itSFState_4d30== sFState_4d2e)&& ( *itCompoundStatement_4d39== compoundStatement_4d37))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4d2a.push_back( sFState_4d2e);
		_compoundStatement_4d33.push_back( compoundStatement_4d37);
	}
	return isUnique;
}

bool AndState_4d21::isGuardTrue( SFC::CompoundStatement& CompoundStatement, CyberComposition::Simulink::SFState& SFState)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( SFState.Decomposition() ) == "AND_STATE";;
	return Gz_guard;
}

void AndState_4d21::processInputPackets( const Packets_t& sFStates_4d22, const Packets_t& compoundStatements_4d25)
{
	for( Packets_t::const_iterator itSFState_4d2b= sFStates_4d22.begin(), itCompoundStatement_4d34= compoundStatements_4d25.begin(); itSFState_4d2b!= sFStates_4d22.end(), itCompoundStatement_4d34!= compoundStatements_4d25.end(); ++itSFState_4d2b, ++itCompoundStatement_4d34)
	{
		bool isUnique= isInputUnique( *itSFState_4d2b, *itCompoundStatement_4d34);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4d2b, *itCompoundStatement_4d34);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4d3d, currMatch.compoundStatement_4d3e);
	}
}

bool AndState_4d21::patternMatcher( const Udm::Object& sFState_4d2c, const Udm::Object& compoundStatement_4d35)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4d2c.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4d31= CyberComposition::Simulink::SFState::Cast( sFState_4d2c);
		if( false== Uml::IsDerivedFrom( compoundStatement_4d35.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_4d3a= SFC::CompoundStatement::Cast( compoundStatement_4d35);
		Match currMatch;
		currMatch.sFState_4d3d= sFState_4d31;
		currMatch.compoundStatement_4d3e= compoundStatement_4d3a;
		bool Gz_guard= isGuardTrue( currMatch.compoundStatement_4d3e, currMatch.sFState_4d3d);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void AndState_4d21::outputAppender( const CyberComposition::Simulink::SFState& sFState_4d41, const SFC::CompoundStatement& compoundStatement_4d43)
{
	_sFState_4d28->push_back( sFState_4d41);
	_compoundStatement_4d29->push_back( compoundStatement_4d43);
}

void CallSibsOrChildren_4d45::operator()( const Packets_t& sFStates_4d46, const Packets_t& sFSOCStates_4d48, const Packets_t& compoundStatements_4d4a)
{
#ifdef PRINT_INFO
	printLog( "CallSibsOrChildren_4d45" );
#endif
	RTTGenerator::Instance()->generateRule(4461, "CallSibsOrChildren");
	processInputPackets( sFStates_4d46, sFSOCStates_4d48, compoundStatements_4d4a);
}

bool CallSibsOrChildren_4d45::isInputUnique( const Udm::Object& sFState_4d50, const Udm::Object& sFSOCState_4d59, const Udm::Object& compoundStatement_4d62)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4d52= _sFState_4d4c.begin(), itSFSOCState_4d5b= _sFSOCState_4d55.begin(), itCompoundStatement_4d64= _compoundStatement_4d5e.begin(); itSFState_4d52!= _sFState_4d4c.end(), itSFSOCState_4d5b!= _sFSOCState_4d55.end(), itCompoundStatement_4d64!= _compoundStatement_4d5e.end(); ++itSFState_4d52, ++itSFSOCState_4d5b, ++itCompoundStatement_4d64)
	{
		if( ( *itSFState_4d52== sFState_4d50)&& ( *itSFSOCState_4d5b== sFSOCState_4d59)&& ( *itCompoundStatement_4d64== compoundStatement_4d62))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4d4c.push_back( sFState_4d50);
		_sFSOCState_4d55.push_back( sFSOCState_4d59);
		_compoundStatement_4d5e.push_back( compoundStatement_4d62);
	}
	return isUnique;
}

bool CallSibsOrChildren_4d45::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool CallSibsOrChildren_4d45::isGuardTrue( SFC::Arg& Arg1, SFC::CompoundStatement& CompoundStatement, SFC::Function& Enter, CyberComposition::Simulink::SFState& SFSOCState, CyberComposition::Simulink::SFState& SFState, SFC::Arg& SOCArg0, SFC::Arg& SOCArg1, SFC::Function& SOCEnter)
{
	bool Gz_guard= false;
	return SOCArg0.argIndex() == 0 && SOCArg1.argIndex() == 1 && Arg1.argIndex() == 1;;
	return Gz_guard;
}

void CallSibsOrChildren_4d45::processInputPackets( const Packets_t& sFStates_4d46, const Packets_t& sFSOCStates_4d48, const Packets_t& compoundStatements_4d4a)
{
	for( Packets_t::const_iterator itSFState_4d4d= sFStates_4d46.begin(), itSFSOCState_4d56= sFSOCStates_4d48.begin(), itCompoundStatement_4d5f= compoundStatements_4d4a.begin(); itSFState_4d4d!= sFStates_4d46.end(), itSFSOCState_4d56!= sFSOCStates_4d48.end(), itCompoundStatement_4d5f!= compoundStatements_4d4a.end(); ++itSFState_4d4d, ++itSFSOCState_4d56, ++itCompoundStatement_4d5f)
	{
		bool isUnique= isInputUnique( *itSFState_4d4d, *itSFSOCState_4d56, *itCompoundStatement_4d5f);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4d4d, *itSFSOCState_4d56, *itCompoundStatement_4d5f);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CallSibsOrChildren_4d45::patternMatcher( const Udm::Object& sFState_4d4e, const Udm::Object& sFSOCState_4d57, const Udm::Object& compoundStatement_4d60)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4d4e.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4d53= CyberComposition::Simulink::SFState::Cast( sFState_4d4e);
		if( false== Uml::IsDerivedFrom( sFSOCState_4d57.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFSOCState_4d5c= CyberComposition::Simulink::SFState::Cast( sFSOCState_4d57);
		if( false== Uml::IsDerivedFrom( compoundStatement_4d60.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_4d65= SFC::CompoundStatement::Cast( compoundStatement_4d60);
		set< SFC::Function> sOCEnters_4d67= sFSOCState_4d5c.enter();
		for( set< SFC::Function>::const_iterator itSOCEnters_4d68= sOCEnters_4d67.begin(); itSOCEnters_4d68!= sOCEnters_4d67.end(); ++itSOCEnters_4d68)
		{
			SFC::Function currSOCEnter_4d69= *itSOCEnters_4d68;
			set< SFC::Arg> sOCArg1s_4d6a= currSOCEnter_4d69.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itSOCArg1_4d6b= sOCArg1s_4d6a.begin(); itSOCArg1_4d6b!= sOCArg1s_4d6a.end(); ++itSOCArg1_4d6b)
			{
				SFC::Arg currSOCArg1_4d6c= *itSOCArg1_4d6b;
				set< SFC::Arg> sOCArg0s_4d6d= currSOCEnter_4d69.Arg_kind_children();
				for( set< SFC::Arg>::const_iterator itSOCArg0_4d6e= sOCArg0s_4d6d.begin(); itSOCArg0_4d6e!= sOCArg0s_4d6d.end(); ++itSOCArg0_4d6e)
				{
					SFC::Arg currSOCArg0_4d6f= *itSOCArg0_4d6e;
					set< SFC::Function> enters_4d70= sFState_4d53.enter();
					for( set< SFC::Function>::const_iterator itEnters_4d71= enters_4d70.begin(); itEnters_4d71!= enters_4d70.end(); ++itEnters_4d71)
					{
						SFC::Function currEnter_4d72= *itEnters_4d71;
						set< SFC::Arg> arg1s_4d73= currEnter_4d72.Arg_kind_children();
						for( set< SFC::Arg>::const_iterator itArg1_4d74= arg1s_4d73.begin(); itArg1_4d74!= arg1s_4d73.end(); ++itArg1_4d74)
						{
							SFC::Arg currArg1_4d75= *itArg1_4d74;
							Match currMatch;
							set< pair<int, Udm::Object> > boundObjs_4d79;
							if( !isValidBound(boundObjs_4d79, sFState_4d53, true))
								continue;
							currMatch.sFState_4d7a= sFState_4d53;
							if( !isValidBound(boundObjs_4d79, sFSOCState_4d5c, true))
								continue;
							currMatch.sFSOCState_4d7b= sFSOCState_4d5c;
							if( !isValidBound(boundObjs_4d79, compoundStatement_4d65, true))
								continue;
							currMatch.compoundStatement_4d7c= compoundStatement_4d65;
							if( !isValidBound(boundObjs_4d79, currEnter_4d72, false))
								continue;
							currMatch.enter_4d7d= currEnter_4d72;
							if( !isValidBound(boundObjs_4d79, currSOCArg0_4d6f, false))
								continue;
							currMatch.sOCArg0_4d7e= currSOCArg0_4d6f;
							if( !isValidBound(boundObjs_4d79, currSOCArg1_4d6c, false))
								continue;
							currMatch.sOCArg1_4d7f= currSOCArg1_4d6c;
							if( !isValidBound(boundObjs_4d79, currArg1_4d75, false))
								continue;
							currMatch.arg1_4d80= currArg1_4d75;
							if( !isValidBound(boundObjs_4d79, currSOCEnter_4d69, false))
								continue;
							currMatch.sOCEnter_4d81= currSOCEnter_4d69;
							bool Gz_guard= isGuardTrue( currMatch.arg1_4d80, currMatch.compoundStatement_4d7c, currMatch.enter_4d7d, currMatch.sFSOCState_4d7b, currMatch.sFState_4d7a, currMatch.sOCArg0_4d7e, currMatch.sOCArg1_4d7f, currMatch.sOCEnter_4d81);
							if( true== Gz_guard)
								_matches.push_back( currMatch);
						}
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void CallSibsOrChildren_4d45::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::FunctionCall newFunctionCall_4d8a= SFC::FunctionCall::Create( currMatch.compoundStatement_4d7c, SFC::CompoundStatement::meta_stmnt);
		SFC::ArgVal newArgVal1_4d8b= SFC::ArgVal::Create( newFunctionCall_4d8a);
		SFC::ArgDeclRef newArgDeclRef_4d8c= SFC::ArgDeclRef::Create( newArgVal1_4d8b, SFC::ArgVal::meta_argexpr);
		SFC::ArgVal newArgVal0_4d8d= SFC::ArgVal::Create( newFunctionCall_4d8a);
		SFC::Int newTwo_4d8e= SFC::Int::Create( newArgVal0_4d8d, SFC::ArgVal::meta_argexpr);
		SFC::Arg& Arg1= currMatch.arg1_4d80;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_4d8c;
		SFC::ArgVal& ArgVal0= newArgVal0_4d8d;
		SFC::ArgVal& ArgVal1= newArgVal1_4d8b;
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_4d7c;
		SFC::Function& Enter= currMatch.enter_4d7d;
		SFC::FunctionCall& FunctionCall= newFunctionCall_4d8a;
		CyberComposition::Simulink::SFState& SFSOCState= currMatch.sFSOCState_4d7b;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_4d7a;
		SFC::Arg& SOCArg0= currMatch.sOCArg0_4d7e;
		SFC::Arg& SOCArg1= currMatch.sOCArg1_4d7f;
		SFC::Function& SOCEnter= currMatch.sOCEnter_4d81;
		SFC::Int& Two= newTwo_4d8e;
		{
FunctionCall.RefId() = CompoundStatement.RefId();
};
		{
FunctionCall.argCount() = 2;
};
		{
__int64 statementCount = CompoundStatement.statementCount();
FunctionCall.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		{
Two.val() = 2;
};
		{
ArgVal1.argIndex() = 1;
};
		{
ArgVal0.argIndex() = 0;
};
		newFunctionCall_4d8a.callee()= currMatch.sOCEnter_4d81;
		newArgDeclRef_4d8c.argdecl()= currMatch.arg1_4d80;
		newArgVal1_4d8b.arg()+= currMatch.sOCArg1_4d7f;
		newArgVal0_4d8d.arg()+= currMatch.sOCArg0_4d7e;
	}
}

void CallParent_4d99::operator()( const Packets_t& sFStates_4d9a, const Packets_t& conditionalBlocks_4d9c)
{
#ifdef PRINT_INFO
	printLog( "CallParent_4d99" );
#endif
	RTTGenerator::Instance()->generateRule(4212, "CallParent");
	processInputPackets( sFStates_4d9a, conditionalBlocks_4d9c);
}

bool CallParent_4d99::isInputUnique( const Udm::Object& sFState_4da2, const Udm::Object& conditionalBlock_4dab)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4da4= _sFState_4d9e.begin(), itConditionalBlock_4dad= _conditionalBlock_4da7.begin(); itSFState_4da4!= _sFState_4d9e.end(), itConditionalBlock_4dad!= _conditionalBlock_4da7.end(); ++itSFState_4da4, ++itConditionalBlock_4dad)
	{
		if( ( *itSFState_4da4== sFState_4da2)&& ( *itConditionalBlock_4dad== conditionalBlock_4dab))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4d9e.push_back( sFState_4da2);
		_conditionalBlock_4da7.push_back( conditionalBlock_4dab);
	}
	return isUnique;
}

bool CallParent_4d99::isGuardTrue( SFC::Arg& Arg1, SFC::ConditionalBlock& ConditionalBlock, SFC::Function& Enter, SFC::Arg& ParentArg0, SFC::Arg& ParentArg1, SFC::Function& ParentEnter, CyberComposition::Simulink::SFState& SFParentState, CyberComposition::Simulink::SFState& SFState)
{
	bool Gz_guard= false;
	return Arg1.argIndex() == 1 && ParentArg0.argIndex() == 0 && ParentArg1.argIndex() == 1;;
	return Gz_guard;
}

void CallParent_4d99::processInputPackets( const Packets_t& sFStates_4d9a, const Packets_t& conditionalBlocks_4d9c)
{
	for( Packets_t::const_iterator itSFState_4d9f= sFStates_4d9a.begin(), itConditionalBlock_4da8= conditionalBlocks_4d9c.begin(); itSFState_4d9f!= sFStates_4d9a.end(), itConditionalBlock_4da8!= conditionalBlocks_4d9c.end(); ++itSFState_4d9f, ++itConditionalBlock_4da8)
	{
		bool isUnique= isInputUnique( *itSFState_4d9f, *itConditionalBlock_4da8);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4d9f, *itConditionalBlock_4da8);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CallParent_4d99::patternMatcher( const Udm::Object& sFState_4da0, const Udm::Object& conditionalBlock_4da9)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4da0.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4da5= CyberComposition::Simulink::SFState::Cast( sFState_4da0);
		if( false== Uml::IsDerivedFrom( conditionalBlock_4da9.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock conditionalBlock_4dae= SFC::ConditionalBlock::Cast( conditionalBlock_4da9);
		Udm::Object sFStateParent_4db0= sFState_4da5.container();
		if( false== Uml::IsDerivedFrom( sFStateParent_4db0.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFParentStateSFState_4db1= CyberComposition::Simulink::SFState::Cast( sFStateParent_4db0);
		set< SFC::Function> enters_4db2= sFState_4da5.enter();
		for( set< SFC::Function>::const_iterator itEnters_4db3= enters_4db2.begin(); itEnters_4db3!= enters_4db2.end(); ++itEnters_4db3)
		{
			SFC::Function currEnter_4db4= *itEnters_4db3;
			set< SFC::Arg> arg1s_4db5= currEnter_4db4.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itArg1_4db6= arg1s_4db5.begin(); itArg1_4db6!= arg1s_4db5.end(); ++itArg1_4db6)
			{
				SFC::Arg currArg1_4db7= *itArg1_4db6;
				set< SFC::Function> parentEnters_4db8= sFParentStateSFState_4db1.enter();
				for( set< SFC::Function>::const_iterator itParentEnters_4db9= parentEnters_4db8.begin(); itParentEnters_4db9!= parentEnters_4db8.end(); ++itParentEnters_4db9)
				{
					SFC::Function currParentEnter_4dba= *itParentEnters_4db9;
					set< SFC::Arg> parentArg0s_4dbb= currParentEnter_4dba.Arg_kind_children();
					for( set< SFC::Arg>::const_iterator itParentArg0_4dbc= parentArg0s_4dbb.begin(); itParentArg0_4dbc!= parentArg0s_4dbb.end(); ++itParentArg0_4dbc)
					{
						SFC::Arg currParentArg0_4dbd= *itParentArg0_4dbc;
						set< SFC::Arg> parentArg1s_4dbe= currParentEnter_4dba.Arg_kind_children();
						for( set< SFC::Arg>::const_iterator itParentArg1_4dbf= parentArg1s_4dbe.begin(); itParentArg1_4dbf!= parentArg1s_4dbe.end(); ++itParentArg1_4dbf)
						{
							SFC::Arg currParentArg1_4dc0= *itParentArg1_4dbf;
							Match currMatch;
							currMatch.sFState_4dc2= sFState_4da5;
							currMatch.conditionalBlock_4dc3= conditionalBlock_4dae;
							currMatch.sFParentState_4dc4= sFParentStateSFState_4db1;
							currMatch.parentArg1_4dc5= currParentArg1_4dc0;
							currMatch.parentArg0_4dc6= currParentArg0_4dbd;
							currMatch.parentEnter_4dc7= currParentEnter_4dba;
							currMatch.enter_4dc8= currEnter_4db4;
							currMatch.arg1_4dc9= currArg1_4db7;
							bool Gz_guard= isGuardTrue( currMatch.arg1_4dc9, currMatch.conditionalBlock_4dc3, currMatch.enter_4dc8, currMatch.parentArg0_4dc6, currMatch.parentArg1_4dc5, currMatch.parentEnter_4dc7, currMatch.sFParentState_4dc4, currMatch.sFState_4dc2);
							if( true== Gz_guard)
								_matches.push_back( currMatch);
						}
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void CallParent_4d99::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::FunctionCall newFunctionCall_4dd2= SFC::FunctionCall::Create( currMatch.conditionalBlock_4dc3, SFC::ConditionalBlock::meta_stmnt);
		SFC::ArgVal newArgVal1_4dd3= SFC::ArgVal::Create( newFunctionCall_4dd2);
		SFC::ArgDeclRef newArgDeclRef_4dd4= SFC::ArgDeclRef::Create( newArgVal1_4dd3, SFC::ArgVal::meta_argexpr);
		SFC::ArgVal newArgVal0_4dd5= SFC::ArgVal::Create( newFunctionCall_4dd2);
		SFC::Int newThree_4dd6= SFC::Int::Create( newArgVal0_4dd5, SFC::ArgVal::meta_argexpr);
		SFC::Arg& Arg1= currMatch.arg1_4dc9;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_4dd4;
		SFC::ArgVal& ArgVal0= newArgVal0_4dd5;
		SFC::ArgVal& ArgVal1= newArgVal1_4dd3;
		SFC::ConditionalBlock& ConditionalBlock= currMatch.conditionalBlock_4dc3;
		SFC::Function& Enter= currMatch.enter_4dc8;
		SFC::FunctionCall& FunctionCall= newFunctionCall_4dd2;
		SFC::Arg& ParentArg0= currMatch.parentArg0_4dc6;
		SFC::Arg& ParentArg1= currMatch.parentArg1_4dc5;
		SFC::Function& ParentEnter= currMatch.parentEnter_4dc7;
		CyberComposition::Simulink::SFState& SFParentState= currMatch.sFParentState_4dc4;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_4dc2;
		SFC::Int& Three= newThree_4dd6;
		{
FunctionCall.RefId() = ConditionalBlock.RefId();
};
		{
FunctionCall.argCount() = 2;
};
		{
ArgVal0.argIndex() = 0;
};
		{
Three.val() = 3;
};
		{
__int64 statementCount = ConditionalBlock.statementCount();
FunctionCall.statementIndex() = statementCount++;
ConditionalBlock.statementCount() = statementCount;
};
		{
ArgVal1.argIndex() = 1;
};
		newFunctionCall_4dd2.callee()= currMatch.parentEnter_4dc7;
		newArgDeclRef_4dd4.argdecl()= currMatch.arg1_4dc9;
		newArgVal0_4dd5.arg()+= currMatch.parentArg0_4dc6;
		newArgVal1_4dd3.arg()+= currMatch.parentArg1_4dc5;
	}
}

void TestMode03_4dd7::operator()( const Packets_t& sFStates_4dd8, Packets_t& sFStates_4dda, Packets_t& conditionalBlocks_4ddb)
{
#ifdef PRINT_INFO
	printLog( "TestMode03_4dd7" );
#endif
	RTTGenerator::Instance()->generateRule(4247, "TestMode03");
	_sFState_4ddc= &sFStates_4dda;
	_conditionalBlock_4ddd= &conditionalBlocks_4ddb;
	processInputPackets( sFStates_4dd8);
}

bool TestMode03_4dd7::isInputUnique( const Udm::Object& sFState_4de2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4de4= _sFState_4dde.begin(); itSFState_4de4!= _sFState_4dde.end(); ++itSFState_4de4)
	{
		if( ( *itSFState_4de4== sFState_4de2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_sFState_4dde.push_back( sFState_4de2);
	return isUnique;
}

bool TestMode03_4dd7::isGuardTrue( SFC::Arg& Arg0, SFC::Function& Enter, CyberComposition::Simulink::SFState& SFState)
{
	bool Gz_guard= false;
	Gz_guard = Arg0.argIndex() == 0;;
	return Gz_guard;
}

void TestMode03_4dd7::processInputPackets( const Packets_t& sFStates_4dd8)
{
	for( Packets_t::const_iterator itSFState_4ddf= sFStates_4dd8.begin(); itSFState_4ddf!= sFStates_4dd8.end(); ++itSFState_4ddf)
	{
		bool isUnique= isInputUnique( *itSFState_4ddf);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4ddf);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool TestMode03_4dd7::patternMatcher( const Udm::Object& sFState_4de0)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4de0.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4de5= CyberComposition::Simulink::SFState::Cast( sFState_4de0);
		set< SFC::Function> enters_4de7= sFState_4de5.enter();
		for( set< SFC::Function>::const_iterator itEnters_4de8= enters_4de7.begin(); itEnters_4de8!= enters_4de7.end(); ++itEnters_4de8)
		{
			SFC::Function currEnter_4de9= *itEnters_4de8;
			set< SFC::Arg> arg0s_4dea= currEnter_4de9.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itArg0_4deb= arg0s_4dea.begin(); itArg0_4deb!= arg0s_4dea.end(); ++itArg0_4deb)
			{
				SFC::Arg currArg0_4dec= *itArg0_4deb;
				Match currMatch;
				currMatch.sFState_4dee= sFState_4de5;
				currMatch.arg0_4def= currArg0_4dec;
				currMatch.enter_4df0= currEnter_4de9;
				bool Gz_guard= isGuardTrue( currMatch.arg0_4def, currMatch.enter_4df0, currMatch.sFState_4dee);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void TestMode03_4dd7::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_4df4= SFC::ConditionalBlock::Create( currMatch.enter_4df0, SFC::Function::meta_stmnt);
		SFC::UserCode newUserCode_4df5= SFC::UserCode::Create( newConditionalBlock_4df4, SFC::ConditionalBlock::meta_cond);
		SFC::BinaryExprs newLOR_4df6= SFC::BinaryExprs::Create( newUserCode_4df5, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newEquals1_4df7= SFC::BinaryExprs::Create( newLOR_4df6, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newZero_4df8= SFC::Int::Create( newEquals1_4df7, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef1_4df9= SFC::ArgDeclRef::Create( newEquals1_4df7, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newEquals2_4dfa= SFC::BinaryExprs::Create( newLOR_4df6, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newThree_4dfb= SFC::Int::Create( newEquals2_4dfa, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef2_4dfc= SFC::ArgDeclRef::Create( newEquals2_4dfa, SFC::BinaryExprs::meta_leftexpr);
		SFC::Arg& Arg0= currMatch.arg0_4def;
		SFC::ArgDeclRef& ArgDeclRef1= newArgDeclRef1_4df9;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_4dfc;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_4df4;
		SFC::Function& Enter= currMatch.enter_4df0;
		SFC::BinaryExprs& Equals1= newEquals1_4df7;
		SFC::BinaryExprs& Equals2= newEquals2_4dfa;
		SFC::BinaryExprs& LOR= newLOR_4df6;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_4dee;
		SFC::Int& Three= newThree_4dfb;
		SFC::UserCode& UserCode= newUserCode_4df5;
		SFC::Int& Zero= newZero_4df8;
		{
ConditionalBlock.RefId() = UserCode.RefId() = Enter.RefId();
};
		{
Equals2.op() = "==";
};
		{
Three.val() = 3;
};
		{
LOR.op() = "||";
};
		{
Zero.val() = 0;
};
		{
Equals1.op() = "==";
};
		{
__int64 statementCount = Enter.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
Enter.statementCount() = statementCount;
};
		newArgDeclRef2_4dfc.argdecl()= currMatch.arg0_4def;
		newArgDeclRef1_4df9.argdecl()= currMatch.arg0_4def;
		outputAppender( currMatch.sFState_4dee, newConditionalBlock_4df4);
	}
}

void TestMode03_4dd7::outputAppender( const CyberComposition::Simulink::SFState& sFState_4dfd, const SFC::ConditionalBlock& conditionalBlock_4dff)
{
	_sFState_4ddc->push_back( sFState_4dfd);
	_conditionalBlock_4ddd->push_back( conditionalBlock_4dff);
}

void Mode0or2_4e09::operator()( const Packets_t& states_4e0a, Packets_t& states_4e0c)
{
#ifdef PRINT_INFO
	printLog( "Mode0or2_4e09" );
#endif
	_state_4e0d= &states_4e0c;
	if( ( !states_4e0a.empty()))
		callChildTest_4f20( states_4e0a);
	_state_4e0d->insert( _state_4e0d->end(), states_4e0a.begin(), states_4e0a.end());
}

void Mode0or2_4e09::callChildTest_4f20( const Packets_t& states_4e0f)
{
	Packets_t states_4e11;
	ChildTest_4e0e childTest_4e0e;
	childTest_4e0e( states_4e0f, states_4e11);
	if( ( !states_4e11.empty()))
		callTestMode02_4f22( states_4e11);
}

void Mode0or2_4e09::callTestMode02_4f22( const Packets_t& sFStates_4e5e)
{
	Packets_t sFStates_4e60;
	Packets_t conditionalBlocks_4e61;
	TestMode02_4e5d testMode02_4e5d;
	testMode02_4e5d( sFStates_4e5e, sFStates_4e60, conditionalBlocks_4e61);
	if( ( !sFStates_4e60.empty())&& ( !conditionalBlocks_4e61.empty()))
		callChildStateType_4f24( sFStates_4e60, conditionalBlocks_4e61);
}

void Mode0or2_4e09::callChildStateType_4f24( const Packets_t& states_4eb5, const Packets_t& css_4eb7)
{
	Packets_t states_4eb9;
	Packets_t css_4eba;
	Packets_t states_4ebb;
	Packets_t css_4ebc;
	ChildStateType_4eb4 childStateType_4eb4;
	childStateType_4eb4( states_4eb5, css_4eb7, states_4eb9, css_4eba, states_4ebb, css_4ebc);
	if( ( !states_4ebb.empty())&& ( !css_4ebc.empty()))
		callTransStartMap_4f27( states_4ebb, css_4ebc);
	if( ( !states_4eb9.empty())&& ( !css_4eba.empty()))
		callGetChildStates_4f2a( states_4eb9, css_4eba);
}

void Mode0or2_4e09::callTransStartMap_4f27( const Packets_t& states_3f9f, const Packets_t& css_3fa1)
{
	Packets_t states_3fa3;
	Packets_t css_3fa4;
	TransStartMap_3f9e transStartMap_3f9e;
	transStartMap_3f9e( states_3f9f, css_3fa1, states_3fa3, css_3fa4);
	if( ( !states_3fa3.empty())&& ( !css_3fa4.empty()))
		callRefetchEnterFcn_4f2d( states_3fa3, css_3fa4);
}

void Mode0or2_4e09::callGetChildStates_4f2a( const Packets_t& sFStates_4e88, const Packets_t& compoundStatements_4e8c)
{
	Packets_t sFStates_4e8a;
	Packets_t sFChildStates_4e8b;
	Packets_t compoundStatements_4e8e;
	GetChildStates_4e87 getChildStates_4e87;
	getChildStates_4e87( sFStates_4e88, compoundStatements_4e8c, sFStates_4e8a, sFChildStates_4e8b, compoundStatements_4e8e);
	if( ( !sFStates_4e8a.empty())&& ( !sFChildStates_4e8b.empty())&& ( !compoundStatements_4e8e.empty()))
		callCallSibsOrChildren_4f30( sFStates_4e8a, sFChildStates_4e8b, compoundStatements_4e8e);
}

void Mode0or2_4e09::callRefetchEnterFcn_4f2d( const Packets_t& sFStates_4e34, const Packets_t& compoundStatements_4e38)
{
	Packets_t sFStates_4e36;
	Packets_t functions_4e37;
	Packets_t compoundStatements_4e3a;
	RefetchEnterFcn_4e33 refetchEnterFcn_4e33;
	refetchEnterFcn_4e33( sFStates_4e34, compoundStatements_4e38, sFStates_4e36, functions_4e37, compoundStatements_4e3a);
	if( ( !sFStates_4e36.empty())&& ( !functions_4e37.empty())&& ( !compoundStatements_4e3a.empty()))
		callTransStartTransitions_4f34( sFStates_4e36, functions_4e37, compoundStatements_4e3a);
}

void Mode0or2_4e09::callCallSibsOrChildren_4f30( const Packets_t& sFStates_4d46, const Packets_t& sFSOCStates_4d48, const Packets_t& compoundStatements_4d4a)
{
	CallSibsOrChildren_4d45 callSibsOrChildren_4d45;
	callSibsOrChildren_4d45( sFStates_4d46, sFSOCStates_4d48, compoundStatements_4d4a);
}

void Mode0or2_4e09::callTransStartTransitions_4f34( const Packets_t& states_3e20, const Packets_t& fcns_3e22, const Packets_t& css_3e24)
{
	TransStartTransitions_3e1f transStartTransitions_3e1f;
	transStartTransitions_3e1f( states_3e20, fcns_3e22, css_3e24);
}

void ChildTest_4e0e::operator()( const Packets_t& states_4e0f, Packets_t& states_4e11)
{
#ifdef PRINT_INFO
	printLog( "ChildTest_4e0e" );
#endif
	_state_4e12= &states_4e11;
	for( Packets_t::const_iterator itstate_4e14= states_4e0f.begin(); itstate_4e14!= states_4e0f.end(); ++itstate_4e14)
	{
		bool isUnique= isInputUnique( *itstate_4e14);
		if( !isUnique)
			continue;
		Packets_t onestate_4e18( 1, *itstate_4e14);
		executeOne( onestate_4e18);
	}
}

void ChildTest_4e0e::executeOne( const Packets_t& states_4e0f)
{
	Packets_t sFStates_4e1d;
	HasChildTransConnector_4e1a hasChildTransConnector_4e1a;
	bool isMatchHasChildTransConnector_4e1a= hasChildTransConnector_4e1a( states_4e0f, sFStates_4e1d);
	_state_4e12->insert( _state_4e12->end(), sFStates_4e1d.begin(), sFStates_4e1d.end());
	if( isMatchHasChildTransConnector_4e1a)
		return;
}

bool ChildTest_4e0e::isInputUnique( const Udm::Object& state_4e15)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_4e17= _state_4e13.begin(); itstate_4e17!= _state_4e13.end(); ++itstate_4e17)
	{
		if( ( *itstate_4e17== state_4e15))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_4e13.push_back( state_4e15);
	return isUnique;
}

bool HasChildTransConnector_4e1a::operator()( const Packets_t& sFStates_4e1b, Packets_t& sFStates_4e1d)
{
#ifdef PRINT_INFO
	printLog( "HasChildTransConnector_4e1a" );
#endif
	_sFState_4e1e= &sFStates_4e1d;
	processInputPackets( sFStates_4e1b);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasChildTransConnector_4e1a::isInputUnique( const Udm::Object& sFState_4e23)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4e25= _sFState_4e1f.begin(); itSFState_4e25!= _sFState_4e1f.end(); ++itSFState_4e25)
	{
		if( ( *itSFState_4e25== sFState_4e23))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_sFState_4e1f.push_back( sFState_4e23);
	return isUnique;
}

bool HasChildTransConnector_4e1a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void HasChildTransConnector_4e1a::processInputPackets( const Packets_t& sFStates_4e1b)
{
	for( Packets_t::const_iterator itSFState_4e20= sFStates_4e1b.begin(); itSFState_4e20!= sFStates_4e1b.end(); ++itSFState_4e20)
	{
		bool isUnique= isInputUnique( *itSFState_4e20);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4e20);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4e2f);
	}
}

bool HasChildTransConnector_4e1a::patternMatcher( const Udm::Object& sFState_4e21)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4e21.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4e26= CyberComposition::Simulink::SFState::Cast( sFState_4e21);
		set< CyberComposition::Simulink::SFTransConnector> sFTransConnectors_4e28= sFState_4e26.SFTransConnector_kind_children();
		for( set< CyberComposition::Simulink::SFTransConnector>::const_iterator itSFTransConnector_4e29= sFTransConnectors_4e28.begin(); itSFTransConnector_4e29!= sFTransConnectors_4e28.end(); ++itSFTransConnector_4e29)
		{
			CyberComposition::Simulink::SFTransConnector currSFTransConnector_4e2a= *itSFTransConnector_4e29;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_4e2e;
			if( !isValidBound(boundObjs_4e2e, sFState_4e26, true))
				continue;
			currMatch.sFState_4e2f= sFState_4e26;
			if( !isValidBound(boundObjs_4e2e, currSFTransConnector_4e2a, false))
				continue;
			currMatch.sFTransConnector_4e30= currSFTransConnector_4e2a;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void HasChildTransConnector_4e1a::outputAppender( const CyberComposition::Simulink::SFState& sFState_4e31)
{
	_sFState_4e1e->push_back( sFState_4e31);
}

void RefetchEnterFcn_4e33::operator()( const Packets_t& sFStates_4e34, const Packets_t& compoundStatements_4e38, Packets_t& sFStates_4e36, Packets_t& functions_4e37, Packets_t& compoundStatements_4e3a)
{
#ifdef PRINT_INFO
	printLog( "RefetchEnterFcn_4e33" );
#endif
	RTTGenerator::Instance()->generateRule(4290, "RefetchEnterFcn");
	_sFState_4e3b= &sFStates_4e36;
	_function_4e3c= &functions_4e37;
	_compoundStatement_4e3d= &compoundStatements_4e3a;
	processInputPackets( sFStates_4e34, compoundStatements_4e38);
}

bool RefetchEnterFcn_4e33::isInputUnique( const Udm::Object& sFState_4e42, const Udm::Object& compoundStatement_4e4b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4e44= _sFState_4e3e.begin(), itCompoundStatement_4e4d= _compoundStatement_4e47.begin(); itSFState_4e44!= _sFState_4e3e.end(), itCompoundStatement_4e4d!= _compoundStatement_4e47.end(); ++itSFState_4e44, ++itCompoundStatement_4e4d)
	{
		if( ( *itSFState_4e44== sFState_4e42)&& ( *itCompoundStatement_4e4d== compoundStatement_4e4b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4e3e.push_back( sFState_4e42);
		_compoundStatement_4e47.push_back( compoundStatement_4e4b);
	}
	return isUnique;
}

void RefetchEnterFcn_4e33::processInputPackets( const Packets_t& sFStates_4e34, const Packets_t& compoundStatements_4e38)
{
	for( Packets_t::const_iterator itSFState_4e3f= sFStates_4e34.begin(), itCompoundStatement_4e48= compoundStatements_4e38.begin(); itSFState_4e3f!= sFStates_4e34.end(), itCompoundStatement_4e48!= compoundStatements_4e38.end(); ++itSFState_4e3f, ++itCompoundStatement_4e48)
	{
		bool isUnique= isInputUnique( *itSFState_4e3f, *itCompoundStatement_4e48);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4e3f, *itCompoundStatement_4e48);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool RefetchEnterFcn_4e33::patternMatcher( const Udm::Object& sFState_4e40, const Udm::Object& compoundStatement_4e49)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4e40.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4e45= CyberComposition::Simulink::SFState::Cast( sFState_4e40);
		if( false== Uml::IsDerivedFrom( compoundStatement_4e49.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_4e4e= SFC::CompoundStatement::Cast( compoundStatement_4e49);
		set< SFC::Function> functions_4e50= sFState_4e45.enter();
		for( set< SFC::Function>::const_iterator itFunctions_4e51= functions_4e50.begin(); itFunctions_4e51!= functions_4e50.end(); ++itFunctions_4e51)
		{
			SFC::Function currFunction_4e52= *itFunctions_4e51;
			Match currMatch;
			currMatch.sFState_4e54= sFState_4e45;
			currMatch.compoundStatement_4e55= compoundStatement_4e4e;
			currMatch.function_4e56= currFunction_4e52;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void RefetchEnterFcn_4e33::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4e54, currMatch.function_4e56, currMatch.compoundStatement_4e55);
	}
}

void RefetchEnterFcn_4e33::outputAppender( const CyberComposition::Simulink::SFState& sFState_4e57, const SFC::Function& function_4e59, const SFC::CompoundStatement& compoundStatement_4e5b)
{
	_sFState_4e3b->push_back( sFState_4e57);
	_function_4e3c->push_back( function_4e59);
	_compoundStatement_4e3d->push_back( compoundStatement_4e5b);
}

void TestMode02_4e5d::operator()( const Packets_t& sFStates_4e5e, Packets_t& sFStates_4e60, Packets_t& conditionalBlocks_4e61)
{
#ifdef PRINT_INFO
	printLog( "TestMode02_4e5d" );
#endif
	RTTGenerator::Instance()->generateRule(4295, "TestMode02");
	_sFState_4e62= &sFStates_4e60;
	_conditionalBlock_4e63= &conditionalBlocks_4e61;
	processInputPackets( sFStates_4e5e);
}

bool TestMode02_4e5d::isInputUnique( const Udm::Object& sFState_4e68)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4e6a= _sFState_4e64.begin(); itSFState_4e6a!= _sFState_4e64.end(); ++itSFState_4e6a)
	{
		if( ( *itSFState_4e6a== sFState_4e68))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_sFState_4e64.push_back( sFState_4e68);
	return isUnique;
}

bool TestMode02_4e5d::isGuardTrue( SFC::Arg& Arg0, SFC::Function& Enter, CyberComposition::Simulink::SFState& SFState)
{
	bool Gz_guard= false;
	Gz_guard = Arg0.argIndex() == 0;;
	return Gz_guard;
}

void TestMode02_4e5d::processInputPackets( const Packets_t& sFStates_4e5e)
{
	for( Packets_t::const_iterator itSFState_4e65= sFStates_4e5e.begin(); itSFState_4e65!= sFStates_4e5e.end(); ++itSFState_4e65)
	{
		bool isUnique= isInputUnique( *itSFState_4e65);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4e65);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool TestMode02_4e5d::patternMatcher( const Udm::Object& sFState_4e66)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4e66.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4e6b= CyberComposition::Simulink::SFState::Cast( sFState_4e66);
		set< SFC::Function> enters_4e6d= sFState_4e6b.enter();
		for( set< SFC::Function>::const_iterator itEnters_4e6e= enters_4e6d.begin(); itEnters_4e6e!= enters_4e6d.end(); ++itEnters_4e6e)
		{
			SFC::Function currEnter_4e6f= *itEnters_4e6e;
			set< SFC::Arg> arg0s_4e70= currEnter_4e6f.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itArg0_4e71= arg0s_4e70.begin(); itArg0_4e71!= arg0s_4e70.end(); ++itArg0_4e71)
			{
				SFC::Arg currArg0_4e72= *itArg0_4e71;
				Match currMatch;
				currMatch.sFState_4e74= sFState_4e6b;
				currMatch.arg0_4e75= currArg0_4e72;
				currMatch.enter_4e76= currEnter_4e6f;
				bool Gz_guard= isGuardTrue( currMatch.arg0_4e75, currMatch.enter_4e76, currMatch.sFState_4e74);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void TestMode02_4e5d::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_4e7a= SFC::ConditionalBlock::Create( currMatch.enter_4e76, SFC::Function::meta_stmnt);
		SFC::UserCode newUserCode_4e7b= SFC::UserCode::Create( newConditionalBlock_4e7a, SFC::ConditionalBlock::meta_cond);
		SFC::BinaryExprs newLOR_4e7c= SFC::BinaryExprs::Create( newUserCode_4e7b, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newEquals1_4e7d= SFC::BinaryExprs::Create( newLOR_4e7c, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newZero_4e7e= SFC::Int::Create( newEquals1_4e7d, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef1_4e7f= SFC::ArgDeclRef::Create( newEquals1_4e7d, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newEquals2_4e80= SFC::BinaryExprs::Create( newLOR_4e7c, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newTwo_4e81= SFC::Int::Create( newEquals2_4e80, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef2_4e82= SFC::ArgDeclRef::Create( newEquals2_4e80, SFC::BinaryExprs::meta_leftexpr);
		SFC::Arg& Arg0= currMatch.arg0_4e75;
		SFC::ArgDeclRef& ArgDeclRef1= newArgDeclRef1_4e7f;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_4e82;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_4e7a;
		SFC::Function& Enter= currMatch.enter_4e76;
		SFC::BinaryExprs& Equals1= newEquals1_4e7d;
		SFC::BinaryExprs& Equals2= newEquals2_4e80;
		SFC::BinaryExprs& LOR= newLOR_4e7c;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_4e74;
		SFC::Int& Two= newTwo_4e81;
		SFC::UserCode& UserCode= newUserCode_4e7b;
		SFC::Int& Zero= newZero_4e7e;
		{
ConditionalBlock.RefId() = UserCode.RefId() = Enter.RefId();
};
		{
Equals2.op() = "==";
};
		{
Two.val() = 2;
};
		{
LOR.op() = "||";
};
		{
Zero.val() = 0;
};
		{
Equals1.op() = "==";
};
		{
__int64 statementCount = Enter.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
Enter.statementCount() = statementCount;
};
		newArgDeclRef2_4e82.argdecl()= currMatch.arg0_4e75;
		newArgDeclRef1_4e7f.argdecl()= currMatch.arg0_4e75;
		outputAppender( currMatch.sFState_4e74, newConditionalBlock_4e7a);
	}
}

void TestMode02_4e5d::outputAppender( const CyberComposition::Simulink::SFState& sFState_4e83, const SFC::ConditionalBlock& conditionalBlock_4e85)
{
	_sFState_4e62->push_back( sFState_4e83);
	_conditionalBlock_4e63->push_back( conditionalBlock_4e85);
}

void GetChildStates_4e87::operator()( const Packets_t& sFStates_4e88, const Packets_t& compoundStatements_4e8c, Packets_t& sFStates_4e8a, Packets_t& sFChildStates_4e8b, Packets_t& compoundStatements_4e8e)
{
#ifdef PRINT_INFO
	printLog( "GetChildStates_4e87" );
#endif
	RTTGenerator::Instance()->generateRule(4695, "GetChildStates");
	_sFState_4e8f= &sFStates_4e8a;
	_sFChildState_4e90= &sFChildStates_4e8b;
	_compoundStatement_4e91= &compoundStatements_4e8e;
	processInputPackets( sFStates_4e88, compoundStatements_4e8c);
	sortOutputs( );
}

bool GetChildStates_4e87::isInputUnique( const Udm::Object& sFState_4e96, const Udm::Object& compoundStatement_4e9f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4e98= _sFState_4e92.begin(), itCompoundStatement_4ea1= _compoundStatement_4e9b.begin(); itSFState_4e98!= _sFState_4e92.end(), itCompoundStatement_4ea1!= _compoundStatement_4e9b.end(); ++itSFState_4e98, ++itCompoundStatement_4ea1)
	{
		if( ( *itSFState_4e98== sFState_4e96)&& ( *itCompoundStatement_4ea1== compoundStatement_4e9f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4e92.push_back( sFState_4e96);
		_compoundStatement_4e9b.push_back( compoundStatement_4e9f);
	}
	return isUnique;
}

bool GetChildStates_4e87::isGuardTrue( SFC::CompoundStatement& CompoundStatement, CyberComposition::Simulink::SFState& SFChildState, CyberComposition::Simulink::SFState& SFState)
{
	bool Gz_guard= false;
	return static_cast< std::string >( SFChildState.Decomposition() ) != "FUNC_STATE";;
	return Gz_guard;
}

void GetChildStates_4e87::processInputPackets( const Packets_t& sFStates_4e88, const Packets_t& compoundStatements_4e8c)
{
	for( Packets_t::const_iterator itSFState_4e93= sFStates_4e88.begin(), itCompoundStatement_4e9c= compoundStatements_4e8c.begin(); itSFState_4e93!= sFStates_4e88.end(), itCompoundStatement_4e9c!= compoundStatements_4e8c.end(); ++itSFState_4e93, ++itCompoundStatement_4e9c)
	{
		bool isUnique= isInputUnique( *itSFState_4e93, *itCompoundStatement_4e9c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4e93, *itCompoundStatement_4e9c);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetChildStates_4e87::patternMatcher( const Udm::Object& sFState_4e94, const Udm::Object& compoundStatement_4e9d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4e94.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4e99= CyberComposition::Simulink::SFState::Cast( sFState_4e94);
		if( false== Uml::IsDerivedFrom( compoundStatement_4e9d.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_4ea2= SFC::CompoundStatement::Cast( compoundStatement_4e9d);
		set< CyberComposition::Simulink::SFState> sFChildStates_4ea4= sFState_4e99.SFState_kind_children();
		for( set< CyberComposition::Simulink::SFState>::const_iterator itSFChildState_4ea5= sFChildStates_4ea4.begin(); itSFChildState_4ea5!= sFChildStates_4ea4.end(); ++itSFChildState_4ea5)
		{
			CyberComposition::Simulink::SFState currSFChildState_4ea6= *itSFChildState_4ea5;
			Match currMatch;
			currMatch.sFState_4ea8= sFState_4e99;
			currMatch.compoundStatement_4ea9= compoundStatement_4ea2;
			currMatch.sFChildState_4eaa= currSFChildState_4ea6;
			bool Gz_guard= isGuardTrue( currMatch.compoundStatement_4ea9, currMatch.sFChildState_4eaa, currMatch.sFState_4ea8);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetChildStates_4e87::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4ea8, currMatch.sFChildState_4eaa, currMatch.compoundStatement_4ea9);
	}
}

void GetChildStates_4e87::outputAppender( const CyberComposition::Simulink::SFState& sFState_4eae, const CyberComposition::Simulink::SFState& sFChildState_4eb0, const SFC::CompoundStatement& compoundStatement_4eb2)
{
	_sFState_4e8f->push_back( sFState_4eae);
	_sFChildState_4e90->push_back( sFChildState_4eb0);
	_compoundStatement_4e91->push_back( compoundStatement_4eb2);
}

void GetChildStates_4e87::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::SFState, std::pointer_to_binary_function< const CyberComposition::Simulink::SFState&, const CyberComposition::Simulink::SFState&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::SFState&, const CyberComposition::Simulink::SFState&, bool> ptr_StateOrder( StateOrder< CyberComposition::Simulink::SFState>);
	SortedSet_t sortedSet( ptr_StateOrder);
	std::vector< int> permutationVector( _sFChildState_4e90->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _sFChildState_4e90->begin(); it!= _sFChildState_4e90->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::SFState::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _sFChildState_4e90->begin());
	// order rest of the containers
	permutate( permutationVector, *_sFState_4e8f);
	permutate( permutationVector, *_compoundStatement_4e91);
}

void ChildStateType_4eb4::operator()( const Packets_t& states_4eb5, const Packets_t& css_4eb7, Packets_t& states_4eb9, Packets_t& css_4eba, Packets_t& states_4ebb, Packets_t& css_4ebc)
{
#ifdef PRINT_INFO
	printLog( "ChildStateType_4eb4" );
#endif
	_state_4ebd= &states_4eb9;
	_cs_4ebe= &css_4eba;
	_state_4ebf= &states_4ebb;
	_cs_4ec0= &css_4ebc;
	for( Packets_t::const_iterator itstate_4ec2= states_4eb5.begin(), itcs_4ec9= css_4eb7.begin(); itstate_4ec2!= states_4eb5.end(), itcs_4ec9!= css_4eb7.end(); ++itstate_4ec2, ++itcs_4ec9)
	{
		bool isUnique= isInputUnique( *itstate_4ec2, *itcs_4ec9);
		if( !isUnique)
			continue;
		Packets_t onestate_4ec6( 1, *itstate_4ec2);
		Packets_t onecs_4ecd( 1, *itcs_4ec9);
		executeOne( onestate_4ec6, onecs_4ecd);
	}
}

void ChildStateType_4eb4::executeOne( const Packets_t& states_4eb5, const Packets_t& css_4eb7)
{
	Packets_t sFStates_4ed2;
	Packets_t compoundStatements_4ed5;
	ChildANDStates_4ecf childANDStates_4ecf;
	bool isMatchChildANDStates_4ecf= childANDStates_4ecf( states_4eb5, css_4eb7, sFStates_4ed2, compoundStatements_4ed5);
	_state_4ebd->insert( _state_4ebd->end(), sFStates_4ed2.begin(), sFStates_4ed2.end());
	_cs_4ebe->insert( _cs_4ebe->end(), compoundStatements_4ed5.begin(), compoundStatements_4ed5.end());
	if( isMatchChildANDStates_4ecf)
		return;
	Packets_t sFStates_4efe;
	Packets_t compoundStatements_4f01;
	Otherwise_4efb otherwise_4efb;
	bool isMatchOtherwise_4efb= otherwise_4efb( states_4eb5, css_4eb7, sFStates_4efe, compoundStatements_4f01);
	_state_4ebf->insert( _state_4ebf->end(), sFStates_4efe.begin(), sFStates_4efe.end());
	_cs_4ec0->insert( _cs_4ec0->end(), compoundStatements_4f01.begin(), compoundStatements_4f01.end());
	if( isMatchOtherwise_4efb)
		return;
}

bool ChildStateType_4eb4::isInputUnique( const Udm::Object& state_4ec3, const Udm::Object& cs_4eca)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_4ec5= _state_4ec1.begin(), itcs_4ecc= _cs_4ec8.begin(); itstate_4ec5!= _state_4ec1.end(), itcs_4ecc!= _cs_4ec8.end(); ++itstate_4ec5, ++itcs_4ecc)
	{
		if( ( *itstate_4ec5== state_4ec3)&& ( *itcs_4ecc== cs_4eca))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_4ec1.push_back( state_4ec3);
		_cs_4ec8.push_back( cs_4eca);
	}
	return isUnique;
}

bool ChildANDStates_4ecf::operator()( const Packets_t& sFStates_4ed0, const Packets_t& compoundStatements_4ed3, Packets_t& sFStates_4ed2, Packets_t& compoundStatements_4ed5)
{
#ifdef PRINT_INFO
	printLog( "ChildANDStates_4ecf" );
#endif
	_sFState_4ed6= &sFStates_4ed2;
	_compoundStatement_4ed7= &compoundStatements_4ed5;
	processInputPackets( sFStates_4ed0, compoundStatements_4ed3);
	if( false== _matches.empty())
		return true;
	return false;
}

bool ChildANDStates_4ecf::isInputUnique( const Udm::Object& sFState_4edc, const Udm::Object& compoundStatement_4ee5)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4ede= _sFState_4ed8.begin(), itCompoundStatement_4ee7= _compoundStatement_4ee1.begin(); itSFState_4ede!= _sFState_4ed8.end(), itCompoundStatement_4ee7!= _compoundStatement_4ee1.end(); ++itSFState_4ede, ++itCompoundStatement_4ee7)
	{
		if( ( *itSFState_4ede== sFState_4edc)&& ( *itCompoundStatement_4ee7== compoundStatement_4ee5))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4ed8.push_back( sFState_4edc);
		_compoundStatement_4ee1.push_back( compoundStatement_4ee5);
	}
	return isUnique;
}

bool ChildANDStates_4ecf::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool ChildANDStates_4ecf::isGuardTrue( SFC::CompoundStatement& CompoundStatement, CyberComposition::Simulink::SFState& SFChildState, CyberComposition::Simulink::SFState& SFState)
{
	bool Gz_guard= false;
	return static_cast< std::string >( SFChildState.Decomposition() ) == "AND_STATE";;
	return Gz_guard;
}

void ChildANDStates_4ecf::processInputPackets( const Packets_t& sFStates_4ed0, const Packets_t& compoundStatements_4ed3)
{
	for( Packets_t::const_iterator itSFState_4ed9= sFStates_4ed0.begin(), itCompoundStatement_4ee2= compoundStatements_4ed3.begin(); itSFState_4ed9!= sFStates_4ed0.end(), itCompoundStatement_4ee2!= compoundStatements_4ed3.end(); ++itSFState_4ed9, ++itCompoundStatement_4ee2)
	{
		bool isUnique= isInputUnique( *itSFState_4ed9, *itCompoundStatement_4ee2);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4ed9, *itCompoundStatement_4ee2);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4ef1, currMatch.compoundStatement_4ef2);
	}
}

bool ChildANDStates_4ecf::patternMatcher( const Udm::Object& sFState_4eda, const Udm::Object& compoundStatement_4ee3)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4eda.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4edf= CyberComposition::Simulink::SFState::Cast( sFState_4eda);
		if( false== Uml::IsDerivedFrom( compoundStatement_4ee3.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_4ee8= SFC::CompoundStatement::Cast( compoundStatement_4ee3);
		set< CyberComposition::Simulink::SFState> sFChildStates_4eea= sFState_4edf.SFState_kind_children();
		for( set< CyberComposition::Simulink::SFState>::const_iterator itSFChildState_4eeb= sFChildStates_4eea.begin(); itSFChildState_4eeb!= sFChildStates_4eea.end(); ++itSFChildState_4eeb)
		{
			CyberComposition::Simulink::SFState currSFChildState_4eec= *itSFChildState_4eeb;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_4ef0;
			if( !isValidBound(boundObjs_4ef0, sFState_4edf, true))
				continue;
			currMatch.sFState_4ef1= sFState_4edf;
			if( !isValidBound(boundObjs_4ef0, compoundStatement_4ee8, true))
				continue;
			currMatch.compoundStatement_4ef2= compoundStatement_4ee8;
			if( !isValidBound(boundObjs_4ef0, currSFChildState_4eec, false))
				continue;
			currMatch.sFChildState_4ef3= currSFChildState_4eec;
			bool Gz_guard= isGuardTrue( currMatch.compoundStatement_4ef2, currMatch.sFChildState_4ef3, currMatch.sFState_4ef1);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void ChildANDStates_4ecf::outputAppender( const CyberComposition::Simulink::SFState& sFState_4ef7, const SFC::CompoundStatement& compoundStatement_4ef9)
{
	_sFState_4ed6->push_back( sFState_4ef7);
	_compoundStatement_4ed7->push_back( compoundStatement_4ef9);
}

bool Otherwise_4efb::operator()( const Packets_t& sFStates_4efc, const Packets_t& compoundStatements_4eff, Packets_t& sFStates_4efe, Packets_t& compoundStatements_4f01)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_4efb" );
#endif
	_sFState_4f02= &sFStates_4efe;
	_compoundStatement_4f03= &compoundStatements_4f01;
	processInputPackets( sFStates_4efc, compoundStatements_4eff);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_4efb::isInputUnique( const Udm::Object& sFState_4f08, const Udm::Object& compoundStatement_4f11)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4f0a= _sFState_4f04.begin(), itCompoundStatement_4f13= _compoundStatement_4f0d.begin(); itSFState_4f0a!= _sFState_4f04.end(), itCompoundStatement_4f13!= _compoundStatement_4f0d.end(); ++itSFState_4f0a, ++itCompoundStatement_4f13)
	{
		if( ( *itSFState_4f0a== sFState_4f08)&& ( *itCompoundStatement_4f13== compoundStatement_4f11))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4f04.push_back( sFState_4f08);
		_compoundStatement_4f0d.push_back( compoundStatement_4f11);
	}
	return isUnique;
}

bool Otherwise_4efb::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_4efb::processInputPackets( const Packets_t& sFStates_4efc, const Packets_t& compoundStatements_4eff)
{
	for( Packets_t::const_iterator itSFState_4f05= sFStates_4efc.begin(), itCompoundStatement_4f0e= compoundStatements_4eff.begin(); itSFState_4f05!= sFStates_4efc.end(), itCompoundStatement_4f0e!= compoundStatements_4eff.end(); ++itSFState_4f05, ++itCompoundStatement_4f0e)
	{
		bool isUnique= isInputUnique( *itSFState_4f05, *itCompoundStatement_4f0e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4f05, *itCompoundStatement_4f0e);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4f1a, currMatch.compoundStatement_4f1b);
	}
}

bool Otherwise_4efb::patternMatcher( const Udm::Object& sFState_4f06, const Udm::Object& compoundStatement_4f0f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4f06.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4f0b= CyberComposition::Simulink::SFState::Cast( sFState_4f06);
		if( false== Uml::IsDerivedFrom( compoundStatement_4f0f.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_4f14= SFC::CompoundStatement::Cast( compoundStatement_4f0f);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4f19;
		if( !isValidBound(boundObjs_4f19, sFState_4f0b, true))
			continue;
		currMatch.sFState_4f1a= sFState_4f0b;
		if( !isValidBound(boundObjs_4f19, compoundStatement_4f14, true))
			continue;
		currMatch.compoundStatement_4f1b= compoundStatement_4f14;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_4efb::outputAppender( const CyberComposition::Simulink::SFState& sFState_4f1c, const SFC::CompoundStatement& compoundStatement_4f1e)
{
	_sFState_4f02->push_back( sFState_4f1c);
	_compoundStatement_4f03->push_back( compoundStatement_4f1e);
}

void Mode0or1or2_4f38::operator()( const Packets_t& states_4f39, Packets_t& states_4f3b)
{
#ifdef PRINT_INFO
	printLog( "Mode0or1or2_4f38" );
#endif
	_state_4f3c= &states_4f3b;
	_state_4f3c->insert( _state_4f3c->end(), states_4f39.begin(), states_4f39.end());
	if( ( !states_4f39.empty()))
		callTestMode012EnterAction_4f77( states_4f39);
}

void Mode0or1or2_4f38::callTestMode012EnterAction_4f77( const Packets_t& sFStates_4f3e)
{
	TestMode012EnterAction_4f3d testMode012EnterAction_4f3d;
	testMode012EnterAction_4f3d( sFStates_4f3e);
}

void TestMode012EnterAction_4f3d::operator()( const Packets_t& sFStates_4f3e)
{
#ifdef PRINT_INFO
	printLog( "TestMode012EnterAction_4f3d" );
#endif
	RTTGenerator::Instance()->generateRule(4331, "TestMode012EnterAction");
	processInputPackets( sFStates_4f3e);
}

bool TestMode012EnterAction_4f3d::isInputUnique( const Udm::Object& sFState_4f44)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4f46= _sFState_4f40.begin(); itSFState_4f46!= _sFState_4f40.end(); ++itSFState_4f46)
	{
		if( ( *itSFState_4f46== sFState_4f44))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_sFState_4f40.push_back( sFState_4f44);
	return isUnique;
}

bool TestMode012EnterAction_4f3d::isGuardTrue( SFC::Arg& Arg0, SFC::Function& Enter, SFC::StateLabel& ParentStateLabel, SFC::Program& Program, CyberComposition::Simulink::SFState& SFParentState, CyberComposition::Simulink::SFState& SFState, SFC::StateLabel& StateLabel, SFC::StateVar& StateVar)
{
	bool Gz_guard= false;
	Gz_guard = Arg0.argIndex() == 0;;
	return Gz_guard;
}

void TestMode012EnterAction_4f3d::processInputPackets( const Packets_t& sFStates_4f3e)
{
	for( Packets_t::const_iterator itSFState_4f41= sFStates_4f3e.begin(); itSFState_4f41!= sFStates_4f3e.end(); ++itSFState_4f41)
	{
		bool isUnique= isInputUnique( *itSFState_4f41);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4f41);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool TestMode012EnterAction_4f3d::patternMatcher( const Udm::Object& sFState_4f42)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4f42.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4f47= CyberComposition::Simulink::SFState::Cast( sFState_4f42);
		Udm::Object sFStateParent_4f49= sFState_4f47.container();
		if( false== Uml::IsDerivedFrom( sFStateParent_4f49.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFParentStateSFState_4f4a= CyberComposition::Simulink::SFState::Cast( sFStateParent_4f49);
		set< SFC::StateLabel> stateLabels_4f4b= sFState_4f47.src();
		for( set< SFC::StateLabel>::const_iterator itStateLabels_4f4c= stateLabels_4f4b.begin(); itStateLabels_4f4c!= stateLabels_4f4b.end(); ++itStateLabels_4f4c)
		{
			SFC::StateLabel currStateLabel_4f4d= *itStateLabels_4f4c;
			set< SFC::StateLabel> parentStateLabels_4f4e= sFParentStateSFState_4f4a.src();
			for( set< SFC::StateLabel>::const_iterator itParentStateLabels_4f4f= parentStateLabels_4f4e.begin(); itParentStateLabels_4f4f!= parentStateLabels_4f4e.end(); ++itParentStateLabels_4f4f)
			{
				SFC::StateLabel currParentStateLabel_4f50= *itParentStateLabels_4f4f;
				set< SFC::Function> enters_4f51= sFState_4f47.enter();
				for( set< SFC::Function>::const_iterator itEnters_4f52= enters_4f51.begin(); itEnters_4f52!= enters_4f51.end(); ++itEnters_4f52)
				{
					SFC::Function currEnter_4f53= *itEnters_4f52;
					Udm::Object enterParent_4f54= currEnter_4f53.container();
					if( false== Uml::IsDerivedFrom( enterParent_4f54.type(), SFC::Program::meta))
						continue;
					SFC::Program programEnter_4f55= SFC::Program::Cast( enterParent_4f54);
					set< SFC::StateVar> stateVars_4f56= programEnter_4f55.StateVar_kind_children();
					for( set< SFC::StateVar>::const_iterator itStateVar_4f57= stateVars_4f56.begin(); itStateVar_4f57!= stateVars_4f56.end(); ++itStateVar_4f57)
					{
						SFC::StateVar currStateVar_4f58= *itStateVar_4f57;
						set< SFC::Arg> arg0s_4f59= currEnter_4f53.Arg_kind_children();
						for( set< SFC::Arg>::const_iterator itArg0_4f5a= arg0s_4f59.begin(); itArg0_4f5a!= arg0s_4f59.end(); ++itArg0_4f5a)
						{
							SFC::Arg currArg0_4f5b= *itArg0_4f5a;
							Match currMatch;
							currMatch.sFState_4f5d= sFState_4f47;
							currMatch.sFParentState_4f5e= sFParentStateSFState_4f4a;
							currMatch.parentStateLabel_4f5f= currParentStateLabel_4f50;
							currMatch.stateLabel_4f60= currStateLabel_4f4d;
							currMatch.arg0_4f61= currArg0_4f5b;
							currMatch.enter_4f62= currEnter_4f53;
							currMatch.program_4f63= programEnter_4f55;
							currMatch.stateVar_4f64= currStateVar_4f58;
							bool Gz_guard= isGuardTrue( currMatch.arg0_4f61, currMatch.enter_4f62, currMatch.parentStateLabel_4f5f, currMatch.program_4f63, currMatch.sFParentState_4f5e, currMatch.sFState_4f5d, currMatch.stateLabel_4f60, currMatch.stateVar_4f64);
							if( true== Gz_guard)
								_matches.push_back( currMatch);
						}
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void TestMode012EnterAction_4f3d::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_4f6d= SFC::ConditionalBlock::Create( currMatch.enter_4f62, SFC::Function::meta_stmnt);
		SFC::SetState newSetState_4f6e= SFC::SetState::Create( newConditionalBlock_4f6d, SFC::ConditionalBlock::meta_stmnt);
		SFC::UserCode newUserCode_4f6f= SFC::UserCode::Create( newConditionalBlock_4f6d, SFC::ConditionalBlock::meta_cond);
		SFC::BinaryExprs newLAND_4f70= SFC::BinaryExprs::Create( newUserCode_4f6f, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newGE_4f71= SFC::BinaryExprs::Create( newLAND_4f70, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newZero_4f72= SFC::Int::Create( newGE_4f71, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef1_4f73= SFC::ArgDeclRef::Create( newGE_4f71, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newLE_4f74= SFC::BinaryExprs::Create( newLAND_4f70, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newTwo_4f75= SFC::Int::Create( newLE_4f74, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef2_4f76= SFC::ArgDeclRef::Create( newLE_4f74, SFC::BinaryExprs::meta_leftexpr);
		SFC::Arg& Arg0= currMatch.arg0_4f61;
		SFC::ArgDeclRef& ArgDeclRef1= newArgDeclRef1_4f73;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_4f76;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_4f6d;
		SFC::Function& Enter= currMatch.enter_4f62;
		SFC::BinaryExprs& GE= newGE_4f71;
		SFC::BinaryExprs& LAND= newLAND_4f70;
		SFC::BinaryExprs& LE= newLE_4f74;
		SFC::StateLabel& ParentStateLabel= currMatch.parentStateLabel_4f5f;
		SFC::Program& Program= currMatch.program_4f63;
		CyberComposition::Simulink::SFState& SFParentState= currMatch.sFParentState_4f5e;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_4f5d;
		SFC::SetState& SetState= newSetState_4f6e;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_4f60;
		SFC::StateVar& StateVar= currMatch.stateVar_4f64;
		SFC::Int& Two= newTwo_4f75;
		SFC::UserCode& UserCode= newUserCode_4f6f;
		SFC::Int& Zero= newZero_4f72;
		{
ConditionalBlock.RefId() = UserCode.RefId() = SetState.RefId() = Enter.RefId();
};
		{
SetState.invert() = false;
SetState.andState() = static_cast< std::string >( SFState.Decomposition() ) == "AND_STATE";
};
		{
__int64 statementCount = ConditionalBlock.statementCount();
SetState.statementIndex() = statementCount++;
ConditionalBlock.statementCount() = statementCount;

SFManager::mstat2SFC( ConditionalBlock, SFState.EnterAction() );
};
		{
LE.op() = "<=";
};
		{
Two.val() = 2;
};
		{
LAND.op() = "&&";
};
		{
Zero.val() = 0;
};
		{
GE.op() = ">=";
};
		{
__int64 statementCount = Enter.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
Enter.statementCount() = statementCount;
};
		newSetState_4f6e.index()= currMatch.parentStateLabel_4f5f;
		newSetState_4f6e.value()= currMatch.stateLabel_4f60;
		newSetState_4f6e.svar()= currMatch.stateVar_4f64;
		newArgDeclRef2_4f76.argdecl()= currMatch.arg0_4f61;
		newArgDeclRef1_4f73.argdecl()= currMatch.arg0_4f61;
	}
}

void Mode0or1_4f79::operator()( const Packets_t& states_4f7a, Packets_t& states_4f7c)
{
#ifdef PRINT_INFO
	printLog( "Mode0or1_4f79" );
#endif
	_state_4f7d= &states_4f7c;
	_state_4f7d->insert( _state_4f7d->end(), states_4f7a.begin(), states_4f7a.end());
	if( ( !states_4f7a.empty()))
		callTestMode01CallParent_4ff6( states_4f7a);
}

void Mode0or1_4f79::callTestMode01CallParent_4ff6( const Packets_t& sFStates_4fb0)
{
	Packets_t sFStates_4fb2;
	Packets_t conditionalBlocks_4fb3;
	TestMode01CallParent_4faf testMode01CallParent_4faf;
	testMode01CallParent_4faf( sFStates_4fb0, sFStates_4fb2, conditionalBlocks_4fb3);
	if( ( !sFStates_4fb2.empty())&& ( !conditionalBlocks_4fb3.empty()))
		callIsAndState_4ff8( sFStates_4fb2, conditionalBlocks_4fb3);
}

void Mode0or1_4f79::callIsAndState_4ff8( const Packets_t& states_4d0b, const Packets_t& css_4d0d)
{
	Packets_t states_4d0f;
	Packets_t css_4d10;
	IsAndState_4d0a isAndState_4d0a;
	isAndState_4d0a( states_4d0b, css_4d0d, states_4d0f, css_4d10);
	if( ( !states_4d0f.empty())&& ( !css_4d10.empty()))
		callGetHOSibs_4ffb( states_4d0f, css_4d10);
}

void Mode0or1_4f79::callGetHOSibs_4ffb( const Packets_t& sFStates_4f7f, const Packets_t& compoundStatements_4f83)
{
	Packets_t sFStates_4f81;
	Packets_t sFSibStates_4f82;
	Packets_t compoundStatements_4f85;
	GetHOSibs_4f7e getHOSibs_4f7e;
	getHOSibs_4f7e( sFStates_4f7f, compoundStatements_4f83, sFStates_4f81, sFSibStates_4f82, compoundStatements_4f85);
	if( ( !sFStates_4f81.empty())&& ( !sFSibStates_4f82.empty())&& ( !compoundStatements_4f85.empty()))
		callCallSibsOrChildren_4ffe( sFStates_4f81, sFSibStates_4f82, compoundStatements_4f85);
}

void Mode0or1_4f79::callCallSibsOrChildren_4ffe( const Packets_t& sFStates_4d46, const Packets_t& sFSOCStates_4d48, const Packets_t& compoundStatements_4d4a)
{
	CallSibsOrChildren_4d45 callSibsOrChildren_4d45;
	callSibsOrChildren_4d45( sFStates_4d46, sFSOCStates_4d48, compoundStatements_4d4a);
}

void GetHOSibs_4f7e::operator()( const Packets_t& sFStates_4f7f, const Packets_t& compoundStatements_4f83, Packets_t& sFStates_4f81, Packets_t& sFSibStates_4f82, Packets_t& compoundStatements_4f85)
{
#ifdef PRINT_INFO
	printLog( "GetHOSibs_4f7e" );
#endif
	RTTGenerator::Instance()->generateRule(4384, "GetHOSibs");
	_sFState_4f86= &sFStates_4f81;
	_sFSibState_4f87= &sFSibStates_4f82;
	_compoundStatement_4f88= &compoundStatements_4f85;
	processInputPackets( sFStates_4f7f, compoundStatements_4f83);
	sortOutputs( );
}

bool GetHOSibs_4f7e::isInputUnique( const Udm::Object& sFState_4f8d, const Udm::Object& compoundStatement_4f96)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4f8f= _sFState_4f89.begin(), itCompoundStatement_4f98= _compoundStatement_4f92.begin(); itSFState_4f8f!= _sFState_4f89.end(), itCompoundStatement_4f98!= _compoundStatement_4f92.end(); ++itSFState_4f8f, ++itCompoundStatement_4f98)
	{
		if( ( *itSFState_4f8f== sFState_4f8d)&& ( *itCompoundStatement_4f98== compoundStatement_4f96))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_4f89.push_back( sFState_4f8d);
		_compoundStatement_4f92.push_back( compoundStatement_4f96);
	}
	return isUnique;
}

bool GetHOSibs_4f7e::isGuardTrue( SFC::CompoundStatement& CompoundStatement, CyberComposition::Simulink::SFState& SFParentState, CyberComposition::Simulink::SFState& SFSibState, CyberComposition::Simulink::SFState& SFState)
{
	bool Gz_guard= false;
	std::string stateOrder = SFManager::trim(  static_cast< std::string >( SFState.Order() )  );
if ( stateOrder.empty() ) stateOrder = "0";

std::string sibStateOrder = SFManager::trim(  static_cast< std::string >( SFSibState.Order() )  );
if ( sibStateOrder.empty() ) sibStateOrder = "0";

return boost::lexical_cast< int >( stateOrder ) < boost::lexical_cast< int >( sibStateOrder );;
	return Gz_guard;
}

void GetHOSibs_4f7e::processInputPackets( const Packets_t& sFStates_4f7f, const Packets_t& compoundStatements_4f83)
{
	for( Packets_t::const_iterator itSFState_4f8a= sFStates_4f7f.begin(), itCompoundStatement_4f93= compoundStatements_4f83.begin(); itSFState_4f8a!= sFStates_4f7f.end(), itCompoundStatement_4f93!= compoundStatements_4f83.end(); ++itSFState_4f8a, ++itCompoundStatement_4f93)
	{
		bool isUnique= isInputUnique( *itSFState_4f8a, *itCompoundStatement_4f93);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4f8a, *itCompoundStatement_4f93);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetHOSibs_4f7e::patternMatcher( const Udm::Object& sFState_4f8b, const Udm::Object& compoundStatement_4f94)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4f8b.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4f90= CyberComposition::Simulink::SFState::Cast( sFState_4f8b);
		if( false== Uml::IsDerivedFrom( compoundStatement_4f94.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_4f99= SFC::CompoundStatement::Cast( compoundStatement_4f94);
		Udm::Object sFStateParent_4f9b= sFState_4f90.container();
		if( false== Uml::IsDerivedFrom( sFStateParent_4f9b.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFParentStateSFState_4f9c= CyberComposition::Simulink::SFState::Cast( sFStateParent_4f9b);
		set< CyberComposition::Simulink::SFState> sFSibStates_4f9d= sFParentStateSFState_4f9c.SFState_kind_children();
		for( set< CyberComposition::Simulink::SFState>::const_iterator itSFSibState_4f9e= sFSibStates_4f9d.begin(); itSFSibState_4f9e!= sFSibStates_4f9d.end(); ++itSFSibState_4f9e)
		{
			CyberComposition::Simulink::SFState currSFSibState_4f9f= *itSFSibState_4f9e;
			Match currMatch;
			currMatch.sFState_4fa1= sFState_4f90;
			currMatch.compoundStatement_4fa2= compoundStatement_4f99;
			currMatch.sFParentState_4fa3= sFParentStateSFState_4f9c;
			currMatch.sFSibState_4fa4= currSFSibState_4f9f;
			bool Gz_guard= isGuardTrue( currMatch.compoundStatement_4fa2, currMatch.sFParentState_4fa3, currMatch.sFSibState_4fa4, currMatch.sFState_4fa1);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetHOSibs_4f7e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_4fa1, currMatch.sFSibState_4fa4, currMatch.compoundStatement_4fa2);
	}
}

void GetHOSibs_4f7e::outputAppender( const CyberComposition::Simulink::SFState& sFState_4fa9, const CyberComposition::Simulink::SFState& sFSibState_4fab, const SFC::CompoundStatement& compoundStatement_4fad)
{
	_sFState_4f86->push_back( sFState_4fa9);
	_sFSibState_4f87->push_back( sFSibState_4fab);
	_compoundStatement_4f88->push_back( compoundStatement_4fad);
}

void GetHOSibs_4f7e::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::SFState, std::pointer_to_binary_function< const CyberComposition::Simulink::SFState&, const CyberComposition::Simulink::SFState&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::SFState&, const CyberComposition::Simulink::SFState&, bool> ptr_StateOrder( StateOrder< CyberComposition::Simulink::SFState>);
	SortedSet_t sortedSet( ptr_StateOrder);
	std::vector< int> permutationVector( _sFSibState_4f87->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _sFSibState_4f87->begin(); it!= _sFSibState_4f87->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::SFState::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _sFSibState_4f87->begin());
	// order rest of the containers
	permutate( permutationVector, *_sFState_4f86);
	permutate( permutationVector, *_compoundStatement_4f88);
}

void TestMode01CallParent_4faf::operator()( const Packets_t& sFStates_4fb0, Packets_t& sFStates_4fb2, Packets_t& conditionalBlocks_4fb3)
{
#ifdef PRINT_INFO
	printLog( "TestMode01CallParent_4faf" );
#endif
	RTTGenerator::Instance()->generateRule(4391, "TestMode01CallParent");
	_sFState_4fb4= &sFStates_4fb2;
	_conditionalBlock_4fb5= &conditionalBlocks_4fb3;
	processInputPackets( sFStates_4fb0);
}

bool TestMode01CallParent_4faf::isInputUnique( const Udm::Object& sFState_4fba)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_4fbc= _sFState_4fb6.begin(); itSFState_4fbc!= _sFState_4fb6.end(); ++itSFState_4fbc)
	{
		if( ( *itSFState_4fbc== sFState_4fba))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_sFState_4fb6.push_back( sFState_4fba);
	return isUnique;
}

bool TestMode01CallParent_4faf::isGuardTrue( SFC::Arg& Arg0, SFC::Arg& Arg1, SFC::Function& Enter, SFC::Arg& ParentArg0, SFC::Arg& ParentArg1, SFC::Function& ParentEnter, CyberComposition::Simulink::SFState& SFParentState, CyberComposition::Simulink::SFState& SFState)
{
	bool Gz_guard= false;
	return ParentArg0.argIndex() == 0 && ParentArg1.argIndex() == 1 && Arg0.argIndex() == 0 && Arg1.argIndex() == 1;;
	return Gz_guard;
}

void TestMode01CallParent_4faf::processInputPackets( const Packets_t& sFStates_4fb0)
{
	for( Packets_t::const_iterator itSFState_4fb7= sFStates_4fb0.begin(); itSFState_4fb7!= sFStates_4fb0.end(); ++itSFState_4fb7)
	{
		bool isUnique= isInputUnique( *itSFState_4fb7);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_4fb7);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool TestMode01CallParent_4faf::patternMatcher( const Udm::Object& sFState_4fb8)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_4fb8.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_4fbd= CyberComposition::Simulink::SFState::Cast( sFState_4fb8);
		Udm::Object sFStateParent_4fbf= sFState_4fbd.container();
		if( false== Uml::IsDerivedFrom( sFStateParent_4fbf.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFParentStateSFState_4fc0= CyberComposition::Simulink::SFState::Cast( sFStateParent_4fbf);
		set< SFC::Function> parentEnters_4fc1= sFParentStateSFState_4fc0.enter();
		for( set< SFC::Function>::const_iterator itParentEnters_4fc2= parentEnters_4fc1.begin(); itParentEnters_4fc2!= parentEnters_4fc1.end(); ++itParentEnters_4fc2)
		{
			SFC::Function currParentEnter_4fc3= *itParentEnters_4fc2;
			set< SFC::Arg> parentArg1s_4fc4= currParentEnter_4fc3.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itParentArg1_4fc5= parentArg1s_4fc4.begin(); itParentArg1_4fc5!= parentArg1s_4fc4.end(); ++itParentArg1_4fc5)
			{
				SFC::Arg currParentArg1_4fc6= *itParentArg1_4fc5;
				set< SFC::Arg> parentArg0s_4fc7= currParentEnter_4fc3.Arg_kind_children();
				for( set< SFC::Arg>::const_iterator itParentArg0_4fc8= parentArg0s_4fc7.begin(); itParentArg0_4fc8!= parentArg0s_4fc7.end(); ++itParentArg0_4fc8)
				{
					SFC::Arg currParentArg0_4fc9= *itParentArg0_4fc8;
					set< SFC::Function> enters_4fca= sFState_4fbd.enter();
					for( set< SFC::Function>::const_iterator itEnters_4fcb= enters_4fca.begin(); itEnters_4fcb!= enters_4fca.end(); ++itEnters_4fcb)
					{
						SFC::Function currEnter_4fcc= *itEnters_4fcb;
						set< SFC::Arg> arg0s_4fcd= currEnter_4fcc.Arg_kind_children();
						for( set< SFC::Arg>::const_iterator itArg0_4fce= arg0s_4fcd.begin(); itArg0_4fce!= arg0s_4fcd.end(); ++itArg0_4fce)
						{
							SFC::Arg currArg0_4fcf= *itArg0_4fce;
							set< SFC::Arg> arg1s_4fd0= currEnter_4fcc.Arg_kind_children();
							for( set< SFC::Arg>::const_iterator itArg1_4fd1= arg1s_4fd0.begin(); itArg1_4fd1!= arg1s_4fd0.end(); ++itArg1_4fd1)
							{
								SFC::Arg currArg1_4fd2= *itArg1_4fd1;
								Match currMatch;
								currMatch.sFState_4fd4= sFState_4fbd;
								currMatch.sFParentState_4fd5= sFParentStateSFState_4fc0;
								currMatch.parentArg0_4fd6= currParentArg0_4fc9;
								currMatch.parentEnter_4fd7= currParentEnter_4fc3;
								currMatch.arg0_4fd8= currArg0_4fcf;
								currMatch.arg1_4fd9= currArg1_4fd2;
								currMatch.parentArg1_4fda= currParentArg1_4fc6;
								currMatch.enter_4fdb= currEnter_4fcc;
								bool Gz_guard= isGuardTrue( currMatch.arg0_4fd8, currMatch.arg1_4fd9, currMatch.enter_4fdb, currMatch.parentArg0_4fd6, currMatch.parentArg1_4fda, currMatch.parentEnter_4fd7, currMatch.sFParentState_4fd5, currMatch.sFState_4fd4);
								if( true== Gz_guard)
									_matches.push_back( currMatch);
							}
						}
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void TestMode01CallParent_4faf::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_4fe4= SFC::ConditionalBlock::Create( currMatch.enter_4fdb, SFC::Function::meta_stmnt);
		SFC::FunctionCall newFunctionCall_4fe5= SFC::FunctionCall::Create( newConditionalBlock_4fe4, SFC::ConditionalBlock::meta_stmnt);
		SFC::ArgVal newArgVal1_4fe6= SFC::ArgVal::Create( newFunctionCall_4fe5);
		SFC::ArgDeclRef newFCArgDeclRef_4fe7= SFC::ArgDeclRef::Create( newArgVal1_4fe6, SFC::ArgVal::meta_argexpr);
		SFC::ArgVal newArgVal0_4fe8= SFC::ArgVal::Create( newFunctionCall_4fe5);
		SFC::Int newArgOne_4fe9= SFC::Int::Create( newArgVal0_4fe8, SFC::ArgVal::meta_argexpr);
		SFC::UserCode newUserCode_4fea= SFC::UserCode::Create( newConditionalBlock_4fe4, SFC::ConditionalBlock::meta_cond);
		SFC::BinaryExprs newLOR_4feb= SFC::BinaryExprs::Create( newUserCode_4fea, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newEquals2_4fec= SFC::BinaryExprs::Create( newLOR_4feb, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newOne_4fed= SFC::Int::Create( newEquals2_4fec, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef2_4fee= SFC::ArgDeclRef::Create( newEquals2_4fec, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newEquals1_4fef= SFC::BinaryExprs::Create( newLOR_4feb, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef1_4ff0= SFC::ArgDeclRef::Create( newEquals1_4fef, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newZero_4ff1= SFC::Int::Create( newEquals1_4fef, SFC::BinaryExprs::meta_rightexpr);
		SFC::Arg& Arg0= currMatch.arg0_4fd8;
		SFC::Arg& Arg1= currMatch.arg1_4fd9;
		SFC::ArgDeclRef& ArgDeclRef1= newArgDeclRef1_4ff0;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_4fee;
		SFC::Int& ArgOne= newArgOne_4fe9;
		SFC::ArgVal& ArgVal0= newArgVal0_4fe8;
		SFC::ArgVal& ArgVal1= newArgVal1_4fe6;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_4fe4;
		SFC::Function& Enter= currMatch.enter_4fdb;
		SFC::BinaryExprs& Equals1= newEquals1_4fef;
		SFC::BinaryExprs& Equals2= newEquals2_4fec;
		SFC::ArgDeclRef& FCArgDeclRef= newFCArgDeclRef_4fe7;
		SFC::FunctionCall& FunctionCall= newFunctionCall_4fe5;
		SFC::BinaryExprs& LOR= newLOR_4feb;
		SFC::Int& One= newOne_4fed;
		SFC::Arg& ParentArg0= currMatch.parentArg0_4fd6;
		SFC::Arg& ParentArg1= currMatch.parentArg1_4fda;
		SFC::Function& ParentEnter= currMatch.parentEnter_4fd7;
		CyberComposition::Simulink::SFState& SFParentState= currMatch.sFParentState_4fd5;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_4fd4;
		SFC::UserCode& UserCode= newUserCode_4fea;
		SFC::Int& Zero= newZero_4ff1;
		{
ConditionalBlock.RefId() = UserCode.RefId() = FunctionCall.RefId() = Enter.RefId();
};
		{
ArgOne.val() = 1;
};
		{
FunctionCall.argCount() = 2;
};
		{
ArgVal0.argIndex() = 0;
};
		{
ArgVal1.argIndex() = 1;
};
		{
__int64 statementCount = Enter.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
Enter.statementCount() = statementCount;
};
		{
__int64 statementCount = ConditionalBlock.statementCount();
FunctionCall.statementIndex() = statementCount++;
ConditionalBlock.statementCount() = statementCount;
};
		{
Zero.val() = 0;
};
		{
One.val() = 1;
};
		{
Equals2.op() = "==";
};
		{
Equals1.op() = "==";
};
		{
LOR.op() = "||";
};
		newFunctionCall_4fe5.callee()= currMatch.parentEnter_4fd7;
		newArgVal0_4fe8.arg()+= currMatch.parentArg0_4fd6;
		newArgVal1_4fe6.arg()+= currMatch.parentArg1_4fda;
		newFCArgDeclRef_4fe7.argdecl()= currMatch.arg1_4fd9;
		newArgDeclRef1_4ff0.argdecl()= currMatch.arg0_4fd8;
		newArgDeclRef2_4fee.argdecl()= currMatch.arg0_4fd8;
		outputAppender( currMatch.sFState_4fd4, newConditionalBlock_4fe4);
	}
}

void TestMode01CallParent_4faf::outputAppender( const CyberComposition::Simulink::SFState& sFState_4ff2, const SFC::ConditionalBlock& conditionalBlock_4ff4)
{
	_sFState_4fb4->push_back( sFState_4ff2);
	_conditionalBlock_4fb5->push_back( conditionalBlock_4ff4);
}

void ReturnAtTopState_5002::operator()( const Packets_t& states_5003, Packets_t& states_5005)
{
#ifdef PRINT_INFO
	printLog( "ReturnAtTopState_5002" );
#endif
	_state_5006= &states_5005;
	if( ( !states_5003.empty()))
		callTopState_502e( states_5003);
	_state_5006->insert( _state_5006->end(), states_5003.begin(), states_5003.end());
}

void ReturnAtTopState_5002::callTopState_502e( const Packets_t& sFStates_5008)
{
	TopState_5007 topState_5007;
	topState_5007( sFStates_5008);
}

void TopState_5007::operator()( const Packets_t& sFStates_5008)
{
#ifdef PRINT_INFO
	printLog( "TopState_5007" );
#endif
	RTTGenerator::Instance()->generateRule(4498, "TopState");
	processInputPackets( sFStates_5008);
}

bool TopState_5007::isInputUnique( const Udm::Object& sFState_500e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_5010= _sFState_500a.begin(); itSFState_5010!= _sFState_500a.end(); ++itSFState_5010)
	{
		if( ( *itSFState_5010== sFState_500e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_sFState_500a.push_back( sFState_500e);
	return isUnique;
}

bool TopState_5007::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool TopState_5007::isGuardTrue( SFC::Arg& Arg, SFC::Function& Enter, CyberComposition::Simulink::SFState& SFState, SFC::StateLabel& StateLabel)
{
	bool Gz_guard= false;
	Gz_guard = Arg.argIndex() == 1;;
	return Gz_guard;
}

void TopState_5007::processInputPackets( const Packets_t& sFStates_5008)
{
	for( Packets_t::const_iterator itSFState_500b= sFStates_5008.begin(); itSFState_500b!= sFStates_5008.end(); ++itSFState_500b)
	{
		bool isUnique= isInputUnique( *itSFState_500b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_500b);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool TopState_5007::patternMatcher( const Udm::Object& sFState_500c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_500c.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_5011= CyberComposition::Simulink::SFState::Cast( sFState_500c);
		set< SFC::Function> enters_5013= sFState_5011.enter();
		for( set< SFC::Function>::const_iterator itEnters_5014= enters_5013.begin(); itEnters_5014!= enters_5013.end(); ++itEnters_5014)
		{
			SFC::Function currEnter_5015= *itEnters_5014;
			set< SFC::Arg> args_5016= currEnter_5015.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itArg_5017= args_5016.begin(); itArg_5017!= args_5016.end(); ++itArg_5017)
			{
				SFC::Arg currArg_5018= *itArg_5017;
				set< SFC::StateLabel> stateLabels_5019= sFState_5011.src();
				for( set< SFC::StateLabel>::const_iterator itStateLabels_501a= stateLabels_5019.begin(); itStateLabels_501a!= stateLabels_5019.end(); ++itStateLabels_501a)
				{
					SFC::StateLabel currStateLabel_501b= *itStateLabels_501a;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_501f;
					if( !isValidBound(boundObjs_501f, sFState_5011, true))
						continue;
					currMatch.sFState_5020= sFState_5011;
					if( !isValidBound(boundObjs_501f, currStateLabel_501b, false))
						continue;
					currMatch.stateLabel_5021= currStateLabel_501b;
					if( !isValidBound(boundObjs_501f, currEnter_5015, false))
						continue;
					currMatch.enter_5022= currEnter_5015;
					if( !isValidBound(boundObjs_501f, currArg_5018, false))
						continue;
					currMatch.arg_5023= currArg_5018;
					bool Gz_guard= isGuardTrue( currMatch.arg_5023, currMatch.enter_5022, currMatch.sFState_5020, currMatch.stateLabel_5021);
					if( true== Gz_guard)
						_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void TopState_5007::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_5028= SFC::ConditionalBlock::Create( currMatch.enter_5022, SFC::Function::meta_stmnt);
		SFC::UserCode newUserCode_5029= SFC::UserCode::Create( newConditionalBlock_5028, SFC::ConditionalBlock::meta_cond);
		SFC::Return newReturn_502a= SFC::Return::Create( newConditionalBlock_5028, SFC::ConditionalBlock::meta_stmnt);
		SFC::BinaryExprs newEquals_502b= SFC::BinaryExprs::Create( newUserCode_5029, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newArgDeclRef_502c= SFC::ArgDeclRef::Create( newEquals_502b, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newSLArgDeclRef_502d= SFC::ArgDeclRef::Create( newEquals_502b, SFC::BinaryExprs::meta_rightexpr);
		SFC::Arg& Arg= currMatch.arg_5023;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_502c;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_5028;
		SFC::Function& Enter= currMatch.enter_5022;
		SFC::BinaryExprs& Equals= newEquals_502b;
		SFC::Return& Return= newReturn_502a;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_5020;
		SFC::ArgDeclRef& SLArgDeclRef= newSLArgDeclRef_502d;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_5021;
		SFC::UserCode& UserCode= newUserCode_5029;
		{
ConditionalBlock.RefId() = Return.RefId() = UserCode.RefId() = Enter.RefId();
};
		{
Equals.op() = "==";
};
		{
__int64 statementCount = Enter.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
Enter.statementCount() = statementCount;
};
		{
__int64 statementCount = ConditionalBlock.statementCount();
Return.statementIndex() = statementCount++;
ConditionalBlock.statementCount() = statementCount;
};
		newArgDeclRef_502c.argdecl()= currMatch.arg_5023;
		newSLArgDeclRef_502d.argdecl()= currMatch.stateLabel_5021;
	}
}

void PopulateExecFunction_503c::operator()( const Packets_t& states_503d, const Packets_t& programs_503f, Packets_t& states_5041, Packets_t& programs_5042)
{
#ifdef PRINT_INFO
	printLog( "PopulateExecFunction_503c" );
#endif
	_state_5043= &states_5041;
	_program_5044= &programs_5042;
	if( ( !states_503d.empty()))
		callInitTransConnMap_54d7( states_503d);
	_state_5043->insert( _state_5043->end(), states_503d.begin(), states_503d.end());
	_program_5044->insert( _program_5044->end(), programs_503f.begin(), programs_503f.end());
}

void PopulateExecFunction_503c::callInitTransConnMap_54d7( const Packets_t& states_5458)
{
	Packets_t states_545a;
	InitTransConnMap_5457 initTransConnMap_5457;
	initTransConnMap_5457( states_5458, states_545a);
	if( ( !states_545a.empty()))
		callOuterTransitions_54d9( states_545a);
}

void PopulateExecFunction_503c::callOuterTransitions_54d9( const Packets_t& states_5462)
{
	Packets_t states_5464;
	OuterTransitions_5461 outerTransitions_5461;
	outerTransitions_5461( states_5462, states_5464);
	if( ( !states_5464.empty()))
		callDuringAction_54db( states_5464);
}

void PopulateExecFunction_503c::callDuringAction_54db( const Packets_t& sFStates_5441)
{
	Packets_t sFStates_5443;
	DuringAction_5440 duringAction_5440;
	duringAction_5440( sFStates_5441, sFStates_5443);
	if( ( !sFStates_5443.empty()))
		callInitTransConnMapInner_54dd( sFStates_5443);
}

void PopulateExecFunction_503c::callInitTransConnMapInner_54dd( const Packets_t& states_53f3)
{
	Packets_t states_53f5;
	InitTransConnMapInner_53f2 initTransConnMapInner_53f2;
	initTransConnMapInner_53f2( states_53f3, states_53f5);
	if( ( !states_53f5.empty()))
		callInnerTransitions_54df( states_53f5);
}

void PopulateExecFunction_503c::callInnerTransitions_54df( const Packets_t& states_52a9)
{
	Packets_t states_52ab;
	InnerTransitions_52a8 innerTransitions_52a8;
	innerTransitions_52a8( states_52a9, states_52ab);
	if( ( !states_52ab.empty()))
		callExecChildren_54e1( states_52ab);
}

void PopulateExecFunction_503c::callExecChildren_54e1( const Packets_t& states_5046)
{
	ExecChildren_5045 execChildren_5045;
	execChildren_5045( states_5046);
}

void ExecChildren_5045::operator()( const Packets_t& states_5046)
{
#ifdef PRINT_INFO
	printLog( "ExecChildren_5045" );
#endif
	if( ( !states_5046.empty()))
		callGetExecFcn_5284( states_5046);
}

void ExecChildren_5045::callGetExecFcn_5284( const Packets_t& sFStates_526b)
{
	Packets_t sFStates_526d;
	Packets_t functions_526e;
	GetExecFcn_526a getExecFcn_526a;
	getExecFcn_526a( sFStates_526b, sFStates_526d, functions_526e);
	if( ( !sFStates_526d.empty())&& ( !functions_526e.empty()))
		callChildStateType_5286( sFStates_526d, functions_526e);
}

void ExecChildren_5045::callChildStateType_5286( const Packets_t& states_4eb5, const Packets_t& css_4eb7)
{
	Packets_t states_4eb9;
	Packets_t css_4eba;
	Packets_t states_4ebb;
	Packets_t css_4ebc;
	ChildStateType_4eb4 childStateType_4eb4;
	childStateType_4eb4( states_4eb5, css_4eb7, states_4eb9, css_4eba, states_4ebb, css_4ebc);
	if( ( !states_4eb9.empty())&& ( !css_4eba.empty()))
		callTopLevelState_5289( states_4eb9, css_4eba);
	if( ( !states_4ebb.empty())&& ( !css_4ebc.empty()))
		callCG_528c( states_4ebb, css_4ebc);
}

void ExecChildren_5045::callTopLevelState_5289( const Packets_t& states_5162, const Packets_t& css_5164)
{
	Packets_t states_5166;
	Packets_t css_5167;
	Packets_t states_5168;
	Packets_t css_5169;
	TopLevelState_5161 topLevelState_5161;
	topLevelState_5161( states_5162, css_5164, states_5166, css_5167, states_5168, css_5169);
	if( ( !states_5168.empty())&& ( !css_5169.empty()))
		callChildStatesExec_528f( states_5168, css_5169);
	if( ( !states_5166.empty())&& ( !css_5167.empty()))
		callCreateCG_5292( states_5166, css_5167);
}

void ExecChildren_5045::callCG_528c( const Packets_t& sFStates_5245, const Packets_t& compoundStatements_5248)
{
	Packets_t sFStates_5247;
	Packets_t conditionalGroups_524a;
	CG_5244 cG_5244;
	cG_5244( sFStates_5245, compoundStatements_5248, sFStates_5247, conditionalGroups_524a);
	if( ( !sFStates_5247.empty())&& ( !conditionalGroups_524a.empty()))
		callCallActiveChildExec_5295( sFStates_5247, conditionalGroups_524a);
}

void ExecChildren_5045::callChildStatesExec_528f( const Packets_t& states_5076, const Packets_t& css_5078)
{
	ChildStatesExec_5075 childStatesExec_5075;
	childStatesExec_5075( states_5076, css_5078);
}

void ExecChildren_5045::callCreateCG_5292( const Packets_t& sFStates_513c, const Packets_t& execs_513f)
{
	Packets_t sFStates_513e;
	Packets_t conditionalGroups_5141;
	CreateCG_513b createCG_513b;
	createCG_513b( sFStates_513c, execs_513f, sFStates_513e, conditionalGroups_5141);
	if( ( !sFStates_513e.empty())&& ( !conditionalGroups_5141.empty()))
		callEnterFunctionCondition_5298( sFStates_513e, conditionalGroups_5141);
}

void ExecChildren_5045::callCallActiveChildExec_5295( const Packets_t& states_51f8, const Packets_t& css_51fa)
{
	Packets_t states_51fc;
	Packets_t css_51fd;
	CallActiveChildExec_51f7 callActiveChildExec_51f7;
	callActiveChildExec_51f7( states_51f8, css_51fa, states_51fc, css_51fd);
	if( ( !states_51fc.empty())&& ( !css_51fd.empty()))
		callTransStartMap_529b( states_51fc, css_51fd);
}

void ExecChildren_5045::callEnterFunctionCondition_5298( const Packets_t& states_50b3, const Packets_t& cgs_50b5)
{
	Packets_t states_50b7;
	Packets_t cgs_50b8;
	EnterFunctionCondition_50b2 enterFunctionCondition_50b2;
	enterFunctionCondition_50b2( states_50b3, cgs_50b5, states_50b7, cgs_50b8);
	if( ( !states_50b7.empty())&& ( !cgs_50b8.empty()))
		callExecFunctionCondition_529e( states_50b7, cgs_50b8);
}

void ExecChildren_5045::callTransStartMap_529b( const Packets_t& states_3f9f, const Packets_t& css_3fa1)
{
	Packets_t states_3fa3;
	Packets_t css_3fa4;
	TransStartMap_3f9e transStartMap_3f9e;
	transStartMap_3f9e( states_3f9f, css_3fa1, states_3fa3, css_3fa4);
	if( ( !states_3fa3.empty())&& ( !css_3fa4.empty()))
		callDefaultCondition_52a1( states_3fa3, css_3fa4);
}

void ExecChildren_5045::callExecFunctionCondition_529e( const Packets_t& states_5049, const Packets_t& cgs_504b)
{
	ExecFunctionCondition_5048 execFunctionCondition_5048;
	execFunctionCondition_5048( states_5049, cgs_504b);
}

void ExecChildren_5045::callDefaultCondition_52a1( const Packets_t& sFStates_51cb, const Packets_t& compoundStatements_51cf)
{
	Packets_t sFStates_51cd;
	Packets_t functions_51ce;
	Packets_t conditionalBlocks_51d1;
	DefaultCondition_51ca defaultCondition_51ca;
	defaultCondition_51ca( sFStates_51cb, compoundStatements_51cf, sFStates_51cd, functions_51ce, conditionalBlocks_51d1);
	if( ( !sFStates_51cd.empty())&& ( !functions_51ce.empty())&& ( !conditionalBlocks_51d1.empty()))
		callTransStartTransitions_52a4( sFStates_51cd, functions_51ce, conditionalBlocks_51d1);
}

void ExecChildren_5045::callTransStartTransitions_52a4( const Packets_t& states_3e20, const Packets_t& fcns_3e22, const Packets_t& css_3e24)
{
	TransStartTransitions_3e1f transStartTransitions_3e1f;
	transStartTransitions_3e1f( states_3e20, fcns_3e22, css_3e24);
}

void ExecFunctionCondition_5048::operator()( const Packets_t& states_5049, const Packets_t& cgs_504b)
{
#ifdef PRINT_INFO
	printLog( "ExecFunctionCondition_5048" );
#endif
	if( ( !states_5049.empty())&& ( !cgs_504b.empty()))
		callCreateDefaultCB_50ac( states_5049, cgs_504b);
}

void ExecFunctionCondition_5048::callCreateDefaultCB_50ac( const Packets_t& sFStates_504e, const Packets_t& conditionalGroups_5051)
{
	Packets_t sFStates_5050;
	Packets_t conditionalBlocks_5053;
	CreateDefaultCB_504d createDefaultCB_504d;
	createDefaultCB_504d( sFStates_504e, conditionalGroups_5051, sFStates_5050, conditionalBlocks_5053);
	if( ( !sFStates_5050.empty())&& ( !conditionalBlocks_5053.empty()))
		callChildStatesExec_50af( sFStates_5050, conditionalBlocks_5053);
}

void ExecFunctionCondition_5048::callChildStatesExec_50af( const Packets_t& states_5076, const Packets_t& css_5078)
{
	ChildStatesExec_5075 childStatesExec_5075;
	childStatesExec_5075( states_5076, css_5078);
}

void CreateDefaultCB_504d::operator()( const Packets_t& sFStates_504e, const Packets_t& conditionalGroups_5051, Packets_t& sFStates_5050, Packets_t& conditionalBlocks_5053)
{
#ifdef PRINT_INFO
	printLog( "CreateDefaultCB_504d" );
#endif
	RTTGenerator::Instance()->generateRule(4534, "CreateDefaultCB");
	_sFState_5054= &sFStates_5050;
	_conditionalBlock_5055= &conditionalBlocks_5053;
	processInputPackets( sFStates_504e, conditionalGroups_5051);
}

bool CreateDefaultCB_504d::isInputUnique( const Udm::Object& sFState_505a, const Udm::Object& conditionalGroup_5063)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_505c= _sFState_5056.begin(), itConditionalGroup_5065= _conditionalGroup_505f.begin(); itSFState_505c!= _sFState_5056.end(), itConditionalGroup_5065!= _conditionalGroup_505f.end(); ++itSFState_505c, ++itConditionalGroup_5065)
	{
		if( ( *itSFState_505c== sFState_505a)&& ( *itConditionalGroup_5065== conditionalGroup_5063))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_5056.push_back( sFState_505a);
		_conditionalGroup_505f.push_back( conditionalGroup_5063);
	}
	return isUnique;
}

bool CreateDefaultCB_504d::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateDefaultCB_504d::processInputPackets( const Packets_t& sFStates_504e, const Packets_t& conditionalGroups_5051)
{
	for( Packets_t::const_iterator itSFState_5057= sFStates_504e.begin(), itConditionalGroup_5060= conditionalGroups_5051.begin(); itSFState_5057!= sFStates_504e.end(), itConditionalGroup_5060!= conditionalGroups_5051.end(); ++itSFState_5057, ++itConditionalGroup_5060)
	{
		bool isUnique= isInputUnique( *itSFState_5057, *itConditionalGroup_5060);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5057, *itConditionalGroup_5060);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateDefaultCB_504d::patternMatcher( const Udm::Object& sFState_5058, const Udm::Object& conditionalGroup_5061)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5058.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_505d= CyberComposition::Simulink::SFState::Cast( sFState_5058);
		if( false== Uml::IsDerivedFrom( conditionalGroup_5061.type(), SFC::ConditionalGroup::meta))
			continue;
		SFC::ConditionalGroup conditionalGroup_5066= SFC::ConditionalGroup::Cast( conditionalGroup_5061);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_506b;
		if( !isValidBound(boundObjs_506b, sFState_505d, true))
			continue;
		currMatch.sFState_506c= sFState_505d;
		if( !isValidBound(boundObjs_506b, conditionalGroup_5066, true))
			continue;
		currMatch.conditionalGroup_506d= conditionalGroup_5066;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateDefaultCB_504d::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_506e= SFC::ConditionalBlock::Create( currMatch.conditionalGroup_506d, SFC::ConditionalGroup::meta_stmnt);
		SFC::UserCode newUserCode_506f= SFC::UserCode::Create( newConditionalBlock_506e, SFC::ConditionalBlock::meta_cond);
		SFC::Int newOne_5070= SFC::Int::Create( newUserCode_506f, SFC::UserCode::meta_codeexpr);
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_506e;
		SFC::ConditionalGroup& ConditionalGroup= currMatch.conditionalGroup_506d;
		SFC::Int& One= newOne_5070;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_506c;
		SFC::UserCode& UserCode= newUserCode_506f;
		{
ConditionalBlock.RefId() = UserCode.RefId() = ConditionalGroup.RefId();
};
		{
__int64 statementCount = ConditionalGroup.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
ConditionalGroup.statementCount() = statementCount;
};
		{
One.val() = 1;
};
		outputAppender( currMatch.sFState_506c, newConditionalBlock_506e);
	}
}

void CreateDefaultCB_504d::outputAppender( const CyberComposition::Simulink::SFState& sFState_5071, const SFC::ConditionalBlock& conditionalBlock_5073)
{
	_sFState_5054->push_back( sFState_5071);
	_conditionalBlock_5055->push_back( conditionalBlock_5073);
}

void ChildStatesExec_5075::operator()( const Packets_t& states_5076, const Packets_t& css_5078)
{
#ifdef PRINT_INFO
	printLog( "ChildStatesExec_5075" );
#endif
	if( ( !states_5076.empty())&& ( !css_5078.empty()))
		callGetChildStates_50a5( states_5076, css_5078);
}

void ChildStatesExec_5075::callGetChildStates_50a5( const Packets_t& sFStates_4e88, const Packets_t& compoundStatements_4e8c)
{
	Packets_t sFStates_4e8a;
	Packets_t sFChildStates_4e8b;
	Packets_t compoundStatements_4e8e;
	GetChildStates_4e87 getChildStates_4e87;
	getChildStates_4e87( sFStates_4e88, compoundStatements_4e8c, sFStates_4e8a, sFChildStates_4e8b, compoundStatements_4e8e);
	if( ( !sFStates_4e8a.empty())&& ( !sFChildStates_4e8b.empty())&& ( !compoundStatements_4e8e.empty()))
		callExecChildAndStates_50a8( sFStates_4e8a, sFChildStates_4e8b, compoundStatements_4e8e);
}

void ChildStatesExec_5075::callExecChildAndStates_50a8( const Packets_t& sFStates_507b, const Packets_t& sFChildStates_507d, const Packets_t& compoundStatements_507f)
{
	ExecChildAndStates_507a execChildAndStates_507a;
	execChildAndStates_507a( sFStates_507b, sFChildStates_507d, compoundStatements_507f);
}

void ExecChildAndStates_507a::operator()( const Packets_t& sFStates_507b, const Packets_t& sFChildStates_507d, const Packets_t& compoundStatements_507f)
{
#ifdef PRINT_INFO
	printLog( "ExecChildAndStates_507a" );
#endif
	RTTGenerator::Instance()->generateRule(4549, "ExecChildAndStates");
	processInputPackets( sFStates_507b, sFChildStates_507d, compoundStatements_507f);
}

bool ExecChildAndStates_507a::isInputUnique( const Udm::Object& sFState_5085, const Udm::Object& sFChildState_508e, const Udm::Object& compoundStatement_5097)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_5087= _sFState_5081.begin(), itSFChildState_5090= _sFChildState_508a.begin(), itCompoundStatement_5099= _compoundStatement_5093.begin(); itSFState_5087!= _sFState_5081.end(), itSFChildState_5090!= _sFChildState_508a.end(), itCompoundStatement_5099!= _compoundStatement_5093.end(); ++itSFState_5087, ++itSFChildState_5090, ++itCompoundStatement_5099)
	{
		if( ( *itSFState_5087== sFState_5085)&& ( *itSFChildState_5090== sFChildState_508e)&& ( *itCompoundStatement_5099== compoundStatement_5097))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_5081.push_back( sFState_5085);
		_sFChildState_508a.push_back( sFChildState_508e);
		_compoundStatement_5093.push_back( compoundStatement_5097);
	}
	return isUnique;
}

void ExecChildAndStates_507a::processInputPackets( const Packets_t& sFStates_507b, const Packets_t& sFChildStates_507d, const Packets_t& compoundStatements_507f)
{
	for( Packets_t::const_iterator itSFState_5082= sFStates_507b.begin(), itSFChildState_508b= sFChildStates_507d.begin(), itCompoundStatement_5094= compoundStatements_507f.begin(); itSFState_5082!= sFStates_507b.end(), itSFChildState_508b!= sFChildStates_507d.end(), itCompoundStatement_5094!= compoundStatements_507f.end(); ++itSFState_5082, ++itSFChildState_508b, ++itCompoundStatement_5094)
	{
		bool isUnique= isInputUnique( *itSFState_5082, *itSFChildState_508b, *itCompoundStatement_5094);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5082, *itSFChildState_508b, *itCompoundStatement_5094);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ExecChildAndStates_507a::patternMatcher( const Udm::Object& sFState_5083, const Udm::Object& sFChildState_508c, const Udm::Object& compoundStatement_5095)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5083.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_5088= CyberComposition::Simulink::SFState::Cast( sFState_5083);
		if( false== Uml::IsDerivedFrom( sFChildState_508c.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFChildState_5091= CyberComposition::Simulink::SFState::Cast( sFChildState_508c);
		if( false== Uml::IsDerivedFrom( compoundStatement_5095.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_509a= SFC::CompoundStatement::Cast( compoundStatement_5095);
		set< SFC::Function> functions_509c= sFChildState_5091.exec();
		for( set< SFC::Function>::const_iterator itFunctions_509d= functions_509c.begin(); itFunctions_509d!= functions_509c.end(); ++itFunctions_509d)
		{
			SFC::Function currFunction_509e= *itFunctions_509d;
			Match currMatch;
			currMatch.sFState_50a0= sFState_5088;
			currMatch.sFChildState_50a1= sFChildState_5091;
			currMatch.compoundStatement_50a2= compoundStatement_509a;
			currMatch.function_50a3= currFunction_509e;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void ExecChildAndStates_507a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::FunctionCall newFunctionCall_50a4= SFC::FunctionCall::Create( currMatch.compoundStatement_50a2, SFC::CompoundStatement::meta_stmnt);
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_50a2;
		SFC::Function& Function= currMatch.function_50a3;
		SFC::FunctionCall& FunctionCall= newFunctionCall_50a4;
		CyberComposition::Simulink::SFState& SFChildState= currMatch.sFChildState_50a1;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_50a0;
		{
FunctionCall.RefId() = CompoundStatement.RefId();
};
		{
__int64 statementCount = CompoundStatement.statementCount();
FunctionCall.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		newFunctionCall_50a4.callee()= currMatch.function_50a3;
	}
}

void EnterFunctionCondition_50b2::operator()( const Packets_t& states_50b3, const Packets_t& cgs_50b5, Packets_t& states_50b7, Packets_t& cgs_50b8)
{
#ifdef PRINT_INFO
	printLog( "EnterFunctionCondition_50b2" );
#endif
	_state_50b9= &states_50b7;
	_cg_50ba= &cgs_50b8;
	if( ( !states_50b3.empty())&& ( !cgs_50b5.empty()))
		callCreateCB_5131( states_50b3, cgs_50b5);
	_state_50b9->insert( _state_50b9->end(), states_50b3.begin(), states_50b3.end());
	_cg_50ba->insert( _cg_50ba->end(), cgs_50b5.begin(), cgs_50b5.end());
}

void EnterFunctionCondition_50b2::callCreateCB_5131( const Packets_t& sFStates_50fc, const Packets_t& conditionalGroups_50ff)
{
	Packets_t sFStates_50fe;
	Packets_t conditionalBlocks_5101;
	CreateCB_50fb createCB_50fb;
	createCB_50fb( sFStates_50fc, conditionalGroups_50ff, sFStates_50fe, conditionalBlocks_5101);
	if( ( !sFStates_50fe.empty())&& ( !conditionalBlocks_5101.empty()))
		callGetChildStates_5134( sFStates_50fe, conditionalBlocks_5101);
}

void EnterFunctionCondition_50b2::callGetChildStates_5134( const Packets_t& sFStates_4e88, const Packets_t& compoundStatements_4e8c)
{
	Packets_t sFStates_4e8a;
	Packets_t sFChildStates_4e8b;
	Packets_t compoundStatements_4e8e;
	GetChildStates_4e87 getChildStates_4e87;
	getChildStates_4e87( sFStates_4e88, compoundStatements_4e8c, sFStates_4e8a, sFChildStates_4e8b, compoundStatements_4e8e);
	if( ( !sFStates_4e8a.empty())&& ( !sFChildStates_4e8b.empty())&& ( !compoundStatements_4e8e.empty()))
		callCallChildren_5137( sFStates_4e8a, sFChildStates_4e8b, compoundStatements_4e8e);
}

void EnterFunctionCondition_50b2::callCallChildren_5137( const Packets_t& sFStates_50bc, const Packets_t& sFChildStates_50be, const Packets_t& compoundStatements_50c0)
{
	CallChildren_50bb callChildren_50bb;
	callChildren_50bb( sFStates_50bc, sFChildStates_50be, compoundStatements_50c0);
}

void CallChildren_50bb::operator()( const Packets_t& sFStates_50bc, const Packets_t& sFChildStates_50be, const Packets_t& compoundStatements_50c0)
{
#ifdef PRINT_INFO
	printLog( "CallChildren_50bb" );
#endif
	RTTGenerator::Instance()->generateRule(4565, "CallChildren");
	processInputPackets( sFStates_50bc, sFChildStates_50be, compoundStatements_50c0);
}

bool CallChildren_50bb::isInputUnique( const Udm::Object& sFState_50c6, const Udm::Object& sFChildState_50cf, const Udm::Object& compoundStatement_50d8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_50c8= _sFState_50c2.begin(), itSFChildState_50d1= _sFChildState_50cb.begin(), itCompoundStatement_50da= _compoundStatement_50d4.begin(); itSFState_50c8!= _sFState_50c2.end(), itSFChildState_50d1!= _sFChildState_50cb.end(), itCompoundStatement_50da!= _compoundStatement_50d4.end(); ++itSFState_50c8, ++itSFChildState_50d1, ++itCompoundStatement_50da)
	{
		if( ( *itSFState_50c8== sFState_50c6)&& ( *itSFChildState_50d1== sFChildState_50cf)&& ( *itCompoundStatement_50da== compoundStatement_50d8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_50c2.push_back( sFState_50c6);
		_sFChildState_50cb.push_back( sFChildState_50cf);
		_compoundStatement_50d4.push_back( compoundStatement_50d8);
	}
	return isUnique;
}

bool CallChildren_50bb::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool CallChildren_50bb::isGuardTrue( SFC::Arg& ChildArg0, SFC::Arg& ChildArg1, SFC::Function& ChildEnter, SFC::CompoundStatement& CompoundStatement, CyberComposition::Simulink::SFState& SFChildState, CyberComposition::Simulink::SFState& SFState)
{
	bool Gz_guard= false;
	return ChildArg0.argIndex() == 0 && ChildArg1.argIndex() == 1;;
	return Gz_guard;
}

void CallChildren_50bb::processInputPackets( const Packets_t& sFStates_50bc, const Packets_t& sFChildStates_50be, const Packets_t& compoundStatements_50c0)
{
	for( Packets_t::const_iterator itSFState_50c3= sFStates_50bc.begin(), itSFChildState_50cc= sFChildStates_50be.begin(), itCompoundStatement_50d5= compoundStatements_50c0.begin(); itSFState_50c3!= sFStates_50bc.end(), itSFChildState_50cc!= sFChildStates_50be.end(), itCompoundStatement_50d5!= compoundStatements_50c0.end(); ++itSFState_50c3, ++itSFChildState_50cc, ++itCompoundStatement_50d5)
	{
		bool isUnique= isInputUnique( *itSFState_50c3, *itSFChildState_50cc, *itCompoundStatement_50d5);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_50c3, *itSFChildState_50cc, *itCompoundStatement_50d5);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CallChildren_50bb::patternMatcher( const Udm::Object& sFState_50c4, const Udm::Object& sFChildState_50cd, const Udm::Object& compoundStatement_50d6)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_50c4.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_50c9= CyberComposition::Simulink::SFState::Cast( sFState_50c4);
		if( false== Uml::IsDerivedFrom( sFChildState_50cd.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFChildState_50d2= CyberComposition::Simulink::SFState::Cast( sFChildState_50cd);
		if( false== Uml::IsDerivedFrom( compoundStatement_50d6.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_50db= SFC::CompoundStatement::Cast( compoundStatement_50d6);
		set< SFC::Function> childEnters_50dd= sFChildState_50d2.enter();
		for( set< SFC::Function>::const_iterator itChildEnters_50de= childEnters_50dd.begin(); itChildEnters_50de!= childEnters_50dd.end(); ++itChildEnters_50de)
		{
			SFC::Function currChildEnter_50df= *itChildEnters_50de;
			set< SFC::Arg> childArg0s_50e0= currChildEnter_50df.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itChildArg0_50e1= childArg0s_50e0.begin(); itChildArg0_50e1!= childArg0s_50e0.end(); ++itChildArg0_50e1)
			{
				SFC::Arg currChildArg0_50e2= *itChildArg0_50e1;
				set< SFC::Arg> childArg1s_50e3= currChildEnter_50df.Arg_kind_children();
				for( set< SFC::Arg>::const_iterator itChildArg1_50e4= childArg1s_50e3.begin(); itChildArg1_50e4!= childArg1s_50e3.end(); ++itChildArg1_50e4)
				{
					SFC::Arg currChildArg1_50e5= *itChildArg1_50e4;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_50e9;
					if( !isValidBound(boundObjs_50e9, sFState_50c9, true))
						continue;
					currMatch.sFState_50ea= sFState_50c9;
					if( !isValidBound(boundObjs_50e9, sFChildState_50d2, true))
						continue;
					currMatch.sFChildState_50eb= sFChildState_50d2;
					if( !isValidBound(boundObjs_50e9, compoundStatement_50db, true))
						continue;
					currMatch.compoundStatement_50ec= compoundStatement_50db;
					if( !isValidBound(boundObjs_50e9, currChildArg0_50e2, false))
						continue;
					currMatch.childArg0_50ed= currChildArg0_50e2;
					if( !isValidBound(boundObjs_50e9, currChildArg1_50e5, false))
						continue;
					currMatch.childArg1_50ee= currChildArg1_50e5;
					if( !isValidBound(boundObjs_50e9, currChildEnter_50df, false))
						continue;
					currMatch.childEnter_50ef= currChildEnter_50df;
					bool Gz_guard= isGuardTrue( currMatch.childArg0_50ed, currMatch.childArg1_50ee, currMatch.childEnter_50ef, currMatch.compoundStatement_50ec, currMatch.sFChildState_50eb, currMatch.sFState_50ea);
					if( true== Gz_guard)
						_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void CallChildren_50bb::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::FunctionCall newFunctionCall_50f6= SFC::FunctionCall::Create( currMatch.compoundStatement_50ec, SFC::CompoundStatement::meta_stmnt);
		SFC::ArgVal newArgVal0_50f7= SFC::ArgVal::Create( newFunctionCall_50f6);
		SFC::Int newTwo_50f8= SFC::Int::Create( newArgVal0_50f7, SFC::ArgVal::meta_argexpr);
		SFC::ArgVal newArgVal1_50f9= SFC::ArgVal::Create( newFunctionCall_50f6);
		SFC::Int newZero_50fa= SFC::Int::Create( newArgVal1_50f9, SFC::ArgVal::meta_argexpr);
		SFC::ArgVal& ArgVal0= newArgVal0_50f7;
		SFC::ArgVal& ArgVal1= newArgVal1_50f9;
		SFC::Arg& ChildArg0= currMatch.childArg0_50ed;
		SFC::Arg& ChildArg1= currMatch.childArg1_50ee;
		SFC::Function& ChildEnter= currMatch.childEnter_50ef;
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_50ec;
		SFC::FunctionCall& FunctionCall= newFunctionCall_50f6;
		CyberComposition::Simulink::SFState& SFChildState= currMatch.sFChildState_50eb;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_50ea;
		SFC::Int& Two= newTwo_50f8;
		SFC::Int& Zero= newZero_50fa;
		{
FunctionCall.RefId() = CompoundStatement.RefId();
};
		{
Zero.val() = 0;
};
		{
ArgVal0.argIndex() = 0;
};
		{
ArgVal1.argIndex() = 1;
};
		{
Two.val() = 2;
};
		{
__int64 statementCount = CompoundStatement.statementCount();
FunctionCall.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		{
FunctionCall.argCount() = 2;
};
		newArgVal0_50f7.arg()+= currMatch.childArg0_50ed;
		newArgVal1_50f9.arg()+= currMatch.childArg1_50ee;
		newFunctionCall_50f6.callee()= currMatch.childEnter_50ef;
	}
}

void CreateCB_50fb::operator()( const Packets_t& sFStates_50fc, const Packets_t& conditionalGroups_50ff, Packets_t& sFStates_50fe, Packets_t& conditionalBlocks_5101)
{
#ifdef PRINT_INFO
	printLog( "CreateCB_50fb" );
#endif
	RTTGenerator::Instance()->generateRule(4595, "CreateCB");
	_sFState_5102= &sFStates_50fe;
	_conditionalBlock_5103= &conditionalBlocks_5101;
	processInputPackets( sFStates_50fc, conditionalGroups_50ff);
}

bool CreateCB_50fb::isInputUnique( const Udm::Object& sFState_5108, const Udm::Object& conditionalGroup_5111)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_510a= _sFState_5104.begin(), itConditionalGroup_5113= _conditionalGroup_510d.begin(); itSFState_510a!= _sFState_5104.end(), itConditionalGroup_5113!= _conditionalGroup_510d.end(); ++itSFState_510a, ++itConditionalGroup_5113)
	{
		if( ( *itSFState_510a== sFState_5108)&& ( *itConditionalGroup_5113== conditionalGroup_5111))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_5104.push_back( sFState_5108);
		_conditionalGroup_510d.push_back( conditionalGroup_5111);
	}
	return isUnique;
}

bool CreateCB_50fb::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateCB_50fb::processInputPackets( const Packets_t& sFStates_50fc, const Packets_t& conditionalGroups_50ff)
{
	for( Packets_t::const_iterator itSFState_5105= sFStates_50fc.begin(), itConditionalGroup_510e= conditionalGroups_50ff.begin(); itSFState_5105!= sFStates_50fc.end(), itConditionalGroup_510e!= conditionalGroups_50ff.end(); ++itSFState_5105, ++itConditionalGroup_510e)
	{
		bool isUnique= isInputUnique( *itSFState_5105, *itConditionalGroup_510e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5105, *itConditionalGroup_510e);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateCB_50fb::patternMatcher( const Udm::Object& sFState_5106, const Udm::Object& conditionalGroup_510f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5106.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_510b= CyberComposition::Simulink::SFState::Cast( sFState_5106);
		if( false== Uml::IsDerivedFrom( conditionalGroup_510f.type(), SFC::ConditionalGroup::meta))
			continue;
		SFC::ConditionalGroup conditionalGroup_5114= SFC::ConditionalGroup::Cast( conditionalGroup_510f);
		Udm::Object conditionalGroupParent_5116= conditionalGroup_5114.container();
		if( false== Uml::IsDerivedFrom( conditionalGroupParent_5116.type(), SFC::Function::meta))
			continue;
		SFC::Function functionConditionalGroup_5117= SFC::Function::Cast( conditionalGroupParent_5116);
		Udm::Object functionParent_5118= functionConditionalGroup_5117.container();
		if( false== Uml::IsDerivedFrom( functionParent_5118.type(), SFC::Program::meta))
			continue;
		SFC::Program programFunction_5119= SFC::Program::Cast( functionParent_5118);
		set< SFC::StateVar> stateVars_511a= programFunction_5119.StateVar_kind_children();
		for( set< SFC::StateVar>::const_iterator itStateVar_511b= stateVars_511a.begin(); itStateVar_511b!= stateVars_511a.end(); ++itStateVar_511b)
		{
			SFC::StateVar currStateVar_511c= *itStateVar_511b;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_5120;
			if( !isValidBound(boundObjs_5120, sFState_510b, true))
				continue;
			currMatch.sFState_5121= sFState_510b;
			if( !isValidBound(boundObjs_5120, conditionalGroup_5114, true))
				continue;
			currMatch.conditionalGroup_5122= conditionalGroup_5114;
			if( !isValidBound(boundObjs_5120, functionConditionalGroup_5117, false))
				continue;
			currMatch.function_5123= functionConditionalGroup_5117;
			if( !isValidBound(boundObjs_5120, programFunction_5119, false))
				continue;
			currMatch.program_5124= programFunction_5119;
			if( !isValidBound(boundObjs_5120, currStateVar_511c, false))
				continue;
			currMatch.stateVar_5125= currStateVar_511c;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateCB_50fb::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_5126= SFC::ConditionalBlock::Create( currMatch.conditionalGroup_5122, SFC::ConditionalGroup::meta_stmnt);
		SFC::UserCode newUserCode_5127= SFC::UserCode::Create( newConditionalBlock_5126, SFC::ConditionalBlock::meta_cond);
		SFC::BinaryExprs newLE_5128= SFC::BinaryExprs::Create( newUserCode_5127, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newIndexOp_5129= SFC::BinaryExprs::Create( newLE_5128, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef_512a= SFC::ArgDeclRef::Create( newIndexOp_5129, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newZero2_512b= SFC::Int::Create( newIndexOp_5129, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newZero1_512c= SFC::Int::Create( newLE_5128, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_512a;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_5126;
		SFC::ConditionalGroup& ConditionalGroup= currMatch.conditionalGroup_5122;
		SFC::Function& Function= currMatch.function_5123;
		SFC::BinaryExprs& IndexOp= newIndexOp_5129;
		SFC::BinaryExprs& LE= newLE_5128;
		SFC::Program& Program= currMatch.program_5124;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_5121;
		SFC::StateVar& StateVar= currMatch.stateVar_5125;
		SFC::UserCode& UserCode= newUserCode_5127;
		SFC::Int& Zero1= newZero1_512c;
		SFC::Int& Zero2= newZero2_512b;
		{
ConditionalBlock.RefId() = UserCode.RefId() = ConditionalGroup.RefId();
};
		{
Zero2.val() = 0;
};
		{
IndexOp.op() = "[";
};
		{
Zero1.val() = 0;
};
		{
LE.op() = "<=";
};
		{
__int64 statementCount = ConditionalGroup.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
ConditionalGroup.statementCount() = statementCount;
};
		newArgDeclRef_512a.argdecl()= currMatch.stateVar_5125;
		outputAppender( currMatch.sFState_5121, newConditionalBlock_5126);
	}
}

void CreateCB_50fb::outputAppender( const CyberComposition::Simulink::SFState& sFState_512d, const SFC::ConditionalBlock& conditionalBlock_512f)
{
	_sFState_5102->push_back( sFState_512d);
	_conditionalBlock_5103->push_back( conditionalBlock_512f);
}

void CreateCG_513b::operator()( const Packets_t& sFStates_513c, const Packets_t& execs_513f, Packets_t& sFStates_513e, Packets_t& conditionalGroups_5141)
{
#ifdef PRINT_INFO
	printLog( "CreateCG_513b" );
#endif
	RTTGenerator::Instance()->generateRule(4625, "CreateCG");
	_sFState_5142= &sFStates_513e;
	_conditionalGroup_5143= &conditionalGroups_5141;
	processInputPackets( sFStates_513c, execs_513f);
}

bool CreateCG_513b::isInputUnique( const Udm::Object& sFState_5148, const Udm::Object& exec_5151)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_514a= _sFState_5144.begin(), itExec_5153= _exec_514d.begin(); itSFState_514a!= _sFState_5144.end(), itExec_5153!= _exec_514d.end(); ++itSFState_514a, ++itExec_5153)
	{
		if( ( *itSFState_514a== sFState_5148)&& ( *itExec_5153== exec_5151))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_5144.push_back( sFState_5148);
		_exec_514d.push_back( exec_5151);
	}
	return isUnique;
}

bool CreateCG_513b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateCG_513b::processInputPackets( const Packets_t& sFStates_513c, const Packets_t& execs_513f)
{
	for( Packets_t::const_iterator itSFState_5145= sFStates_513c.begin(), itExec_514e= execs_513f.begin(); itSFState_5145!= sFStates_513c.end(), itExec_514e!= execs_513f.end(); ++itSFState_5145, ++itExec_514e)
	{
		bool isUnique= isInputUnique( *itSFState_5145, *itExec_514e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5145, *itExec_514e);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateCG_513b::patternMatcher( const Udm::Object& sFState_5146, const Udm::Object& exec_514f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5146.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_514b= CyberComposition::Simulink::SFState::Cast( sFState_5146);
		if( false== Uml::IsDerivedFrom( exec_514f.type(), SFC::Function::meta))
			continue;
		SFC::Function exec_5154= SFC::Function::Cast( exec_514f);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5159;
		if( !isValidBound(boundObjs_5159, sFState_514b, true))
			continue;
		currMatch.sFState_515a= sFState_514b;
		if( !isValidBound(boundObjs_5159, exec_5154, true))
			continue;
		currMatch.exec_515b= exec_5154;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateCG_513b::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalGroup newConditionalGroup_515c= SFC::ConditionalGroup::Create( currMatch.exec_515b, SFC::Function::meta_stmnt);
		SFC::ConditionalGroup& ConditionalGroup= newConditionalGroup_515c;
		SFC::Function& Exec= currMatch.exec_515b;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_515a;
		{
ConditionalGroup.RefId() = Exec.RefId();
};
		{
__int64 statementCount = Exec.statementCount();
ConditionalGroup.statementIndex() = statementCount++;
Exec.statementCount() = statementCount;
};
		outputAppender( currMatch.sFState_515a, newConditionalGroup_515c);
	}
}

void CreateCG_513b::outputAppender( const CyberComposition::Simulink::SFState& sFState_515d, const SFC::ConditionalGroup& conditionalGroup_515f)
{
	_sFState_5142->push_back( sFState_515d);
	_conditionalGroup_5143->push_back( conditionalGroup_515f);
}

void TopLevelState_5161::operator()( const Packets_t& states_5162, const Packets_t& css_5164, Packets_t& states_5166, Packets_t& css_5167, Packets_t& states_5168, Packets_t& css_5169)
{
#ifdef PRINT_INFO
	printLog( "TopLevelState_5161" );
#endif
	_state_516a= &states_5166;
	_cs_516b= &css_5167;
	_state_516c= &states_5168;
	_cs_516d= &css_5169;
	for( Packets_t::const_iterator itstate_516f= states_5162.begin(), itcs_5176= css_5164.begin(); itstate_516f!= states_5162.end(), itcs_5176!= css_5164.end(); ++itstate_516f, ++itcs_5176)
	{
		bool isUnique= isInputUnique( *itstate_516f, *itcs_5176);
		if( !isUnique)
			continue;
		Packets_t onestate_5173( 1, *itstate_516f);
		Packets_t onecs_517a( 1, *itcs_5176);
		executeOne( onestate_5173, onecs_517a);
	}
}

void TopLevelState_5161::executeOne( const Packets_t& states_5162, const Packets_t& css_5164)
{
	Packets_t sFStates_517f;
	Packets_t compoundStatements_5182;
	IsTopLevelState_517c isTopLevelState_517c;
	bool isMatchIsTopLevelState_517c= isTopLevelState_517c( states_5162, css_5164, sFStates_517f, compoundStatements_5182);
	_state_516a->insert( _state_516a->end(), sFStates_517f.begin(), sFStates_517f.end());
	_cs_516b->insert( _cs_516b->end(), compoundStatements_5182.begin(), compoundStatements_5182.end());
	if( isMatchIsTopLevelState_517c)
		return;
	Packets_t sFStates_51a8;
	Packets_t compoundStatements_51ab;
	Otherwise_51a5 otherwise_51a5;
	bool isMatchOtherwise_51a5= otherwise_51a5( states_5162, css_5164, sFStates_51a8, compoundStatements_51ab);
	_state_516c->insert( _state_516c->end(), sFStates_51a8.begin(), sFStates_51a8.end());
	_cs_516d->insert( _cs_516d->end(), compoundStatements_51ab.begin(), compoundStatements_51ab.end());
	if( isMatchOtherwise_51a5)
		return;
}

bool TopLevelState_5161::isInputUnique( const Udm::Object& state_5170, const Udm::Object& cs_5177)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_5172= _state_516e.begin(), itcs_5179= _cs_5175.begin(); itstate_5172!= _state_516e.end(), itcs_5179!= _cs_5175.end(); ++itstate_5172, ++itcs_5179)
	{
		if( ( *itstate_5172== state_5170)&& ( *itcs_5179== cs_5177))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_516e.push_back( state_5170);
		_cs_5175.push_back( cs_5177);
	}
	return isUnique;
}

bool IsTopLevelState_517c::operator()( const Packets_t& sFStates_517d, const Packets_t& compoundStatements_5180, Packets_t& sFStates_517f, Packets_t& compoundStatements_5182)
{
#ifdef PRINT_INFO
	printLog( "IsTopLevelState_517c" );
#endif
	_sFState_5183= &sFStates_517f;
	_compoundStatement_5184= &compoundStatements_5182;
	processInputPackets( sFStates_517d, compoundStatements_5180);
	if( false== _matches.empty())
		return true;
	return false;
}

bool IsTopLevelState_517c::isInputUnique( const Udm::Object& sFState_5189, const Udm::Object& compoundStatement_5192)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_518b= _sFState_5185.begin(), itCompoundStatement_5194= _compoundStatement_518e.begin(); itSFState_518b!= _sFState_5185.end(), itCompoundStatement_5194!= _compoundStatement_518e.end(); ++itSFState_518b, ++itCompoundStatement_5194)
	{
		if( ( *itSFState_518b== sFState_5189)&& ( *itCompoundStatement_5194== compoundStatement_5192))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_5185.push_back( sFState_5189);
		_compoundStatement_518e.push_back( compoundStatement_5192);
	}
	return isUnique;
}

bool IsTopLevelState_517c::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void IsTopLevelState_517c::processInputPackets( const Packets_t& sFStates_517d, const Packets_t& compoundStatements_5180)
{
	for( Packets_t::const_iterator itSFState_5186= sFStates_517d.begin(), itCompoundStatement_518f= compoundStatements_5180.begin(); itSFState_5186!= sFStates_517d.end(), itCompoundStatement_518f!= compoundStatements_5180.end(); ++itSFState_5186, ++itCompoundStatement_518f)
	{
		bool isUnique= isInputUnique( *itSFState_5186, *itCompoundStatement_518f);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5186, *itCompoundStatement_518f);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_519e, currMatch.compoundStatement_519f);
	}
}

bool IsTopLevelState_517c::patternMatcher( const Udm::Object& sFState_5187, const Udm::Object& compoundStatement_5190)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5187.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_518c= CyberComposition::Simulink::SFState::Cast( sFState_5187);
		if( false== Uml::IsDerivedFrom( compoundStatement_5190.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_5195= SFC::CompoundStatement::Cast( compoundStatement_5190);
		set< CyberComposition::Simulink::SFConnectorRef> sFConnectorRefs_5197= sFState_518c.referedbyConnectorRef();
		for( set< CyberComposition::Simulink::SFConnectorRef>::const_iterator itSFConnectorRefs_5198= sFConnectorRefs_5197.begin(); itSFConnectorRefs_5198!= sFConnectorRefs_5197.end(); ++itSFConnectorRefs_5198)
		{
			CyberComposition::Simulink::SFConnectorRef currSFConnectorRef_5199= *itSFConnectorRefs_5198;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_519d;
			if( !isValidBound(boundObjs_519d, sFState_518c, true))
				continue;
			currMatch.sFState_519e= sFState_518c;
			if( !isValidBound(boundObjs_519d, compoundStatement_5195, true))
				continue;
			currMatch.compoundStatement_519f= compoundStatement_5195;
			if( !isValidBound(boundObjs_519d, currSFConnectorRef_5199, false))
				continue;
			currMatch.sFConnectorRef_51a0= currSFConnectorRef_5199;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void IsTopLevelState_517c::outputAppender( const CyberComposition::Simulink::SFState& sFState_51a1, const SFC::CompoundStatement& compoundStatement_51a3)
{
	_sFState_5183->push_back( sFState_51a1);
	_compoundStatement_5184->push_back( compoundStatement_51a3);
}

bool Otherwise_51a5::operator()( const Packets_t& sFStates_51a6, const Packets_t& compoundStatements_51a9, Packets_t& sFStates_51a8, Packets_t& compoundStatements_51ab)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_51a5" );
#endif
	_sFState_51ac= &sFStates_51a8;
	_compoundStatement_51ad= &compoundStatements_51ab;
	processInputPackets( sFStates_51a6, compoundStatements_51a9);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_51a5::isInputUnique( const Udm::Object& sFState_51b2, const Udm::Object& compoundStatement_51bb)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_51b4= _sFState_51ae.begin(), itCompoundStatement_51bd= _compoundStatement_51b7.begin(); itSFState_51b4!= _sFState_51ae.end(), itCompoundStatement_51bd!= _compoundStatement_51b7.end(); ++itSFState_51b4, ++itCompoundStatement_51bd)
	{
		if( ( *itSFState_51b4== sFState_51b2)&& ( *itCompoundStatement_51bd== compoundStatement_51bb))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_51ae.push_back( sFState_51b2);
		_compoundStatement_51b7.push_back( compoundStatement_51bb);
	}
	return isUnique;
}

bool Otherwise_51a5::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_51a5::processInputPackets( const Packets_t& sFStates_51a6, const Packets_t& compoundStatements_51a9)
{
	for( Packets_t::const_iterator itSFState_51af= sFStates_51a6.begin(), itCompoundStatement_51b8= compoundStatements_51a9.begin(); itSFState_51af!= sFStates_51a6.end(), itCompoundStatement_51b8!= compoundStatements_51a9.end(); ++itSFState_51af, ++itCompoundStatement_51b8)
	{
		bool isUnique= isInputUnique( *itSFState_51af, *itCompoundStatement_51b8);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_51af, *itCompoundStatement_51b8);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_51c4, currMatch.compoundStatement_51c5);
	}
}

bool Otherwise_51a5::patternMatcher( const Udm::Object& sFState_51b0, const Udm::Object& compoundStatement_51b9)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_51b0.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_51b5= CyberComposition::Simulink::SFState::Cast( sFState_51b0);
		if( false== Uml::IsDerivedFrom( compoundStatement_51b9.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_51be= SFC::CompoundStatement::Cast( compoundStatement_51b9);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_51c3;
		if( !isValidBound(boundObjs_51c3, sFState_51b5, true))
			continue;
		currMatch.sFState_51c4= sFState_51b5;
		if( !isValidBound(boundObjs_51c3, compoundStatement_51be, true))
			continue;
		currMatch.compoundStatement_51c5= compoundStatement_51be;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_51a5::outputAppender( const CyberComposition::Simulink::SFState& sFState_51c6, const SFC::CompoundStatement& compoundStatement_51c8)
{
	_sFState_51ac->push_back( sFState_51c6);
	_compoundStatement_51ad->push_back( compoundStatement_51c8);
}

void DefaultCondition_51ca::operator()( const Packets_t& sFStates_51cb, const Packets_t& compoundStatements_51cf, Packets_t& sFStates_51cd, Packets_t& functions_51ce, Packets_t& conditionalBlocks_51d1)
{
#ifdef PRINT_INFO
	printLog( "DefaultCondition_51ca" );
#endif
	RTTGenerator::Instance()->generateRule(4647, "DefaultCondition");
	_sFState_51d2= &sFStates_51cd;
	_function_51d3= &functions_51ce;
	_conditionalBlock_51d4= &conditionalBlocks_51d1;
	processInputPackets( sFStates_51cb, compoundStatements_51cf);
}

bool DefaultCondition_51ca::isInputUnique( const Udm::Object& sFState_51d9, const Udm::Object& compoundStatement_51e2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_51db= _sFState_51d5.begin(), itCompoundStatement_51e4= _compoundStatement_51de.begin(); itSFState_51db!= _sFState_51d5.end(), itCompoundStatement_51e4!= _compoundStatement_51de.end(); ++itSFState_51db, ++itCompoundStatement_51e4)
	{
		if( ( *itSFState_51db== sFState_51d9)&& ( *itCompoundStatement_51e4== compoundStatement_51e2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_51d5.push_back( sFState_51d9);
		_compoundStatement_51de.push_back( compoundStatement_51e2);
	}
	return isUnique;
}

void DefaultCondition_51ca::processInputPackets( const Packets_t& sFStates_51cb, const Packets_t& compoundStatements_51cf)
{
	for( Packets_t::const_iterator itSFState_51d6= sFStates_51cb.begin(), itCompoundStatement_51df= compoundStatements_51cf.begin(); itSFState_51d6!= sFStates_51cb.end(), itCompoundStatement_51df!= compoundStatements_51cf.end(); ++itSFState_51d6, ++itCompoundStatement_51df)
	{
		bool isUnique= isInputUnique( *itSFState_51d6, *itCompoundStatement_51df);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_51d6, *itCompoundStatement_51df);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool DefaultCondition_51ca::patternMatcher( const Udm::Object& sFState_51d7, const Udm::Object& compoundStatement_51e0)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_51d7.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_51dc= CyberComposition::Simulink::SFState::Cast( sFState_51d7);
		if( false== Uml::IsDerivedFrom( compoundStatement_51e0.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_51e5= SFC::CompoundStatement::Cast( compoundStatement_51e0);
		set< SFC::Function> functions_51e7= sFState_51dc.exec();
		for( set< SFC::Function>::const_iterator itFunctions_51e8= functions_51e7.begin(); itFunctions_51e8!= functions_51e7.end(); ++itFunctions_51e8)
		{
			SFC::Function currFunction_51e9= *itFunctions_51e8;
			Match currMatch;
			currMatch.sFState_51eb= sFState_51dc;
			currMatch.compoundStatement_51ec= compoundStatement_51e5;
			currMatch.function_51ed= currFunction_51e9;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void DefaultCondition_51ca::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_51ee= SFC::ConditionalBlock::Create( currMatch.compoundStatement_51ec, SFC::CompoundStatement::meta_stmnt);
		SFC::UserCode newUserCode_51ef= SFC::UserCode::Create( newConditionalBlock_51ee, SFC::ConditionalBlock::meta_cond);
		SFC::Int newOne_51f0= SFC::Int::Create( newUserCode_51ef, SFC::UserCode::meta_codeexpr);
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_51ec;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_51ee;
		SFC::Function& Function= currMatch.function_51ed;
		SFC::Int& One= newOne_51f0;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_51eb;
		SFC::UserCode& UserCode= newUserCode_51ef;
		{
ConditionalBlock.RefId() = UserCode.RefId() = CompoundStatement.RefId();
};
		{
One.val() = 1;
};
		{
__int64 statementCount = CompoundStatement.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		outputAppender( currMatch.sFState_51eb, currMatch.function_51ed, newConditionalBlock_51ee);
	}
}

void DefaultCondition_51ca::outputAppender( const CyberComposition::Simulink::SFState& sFState_51f1, const SFC::Function& function_51f3, const SFC::ConditionalBlock& conditionalBlock_51f5)
{
	_sFState_51d2->push_back( sFState_51f1);
	_function_51d3->push_back( function_51f3);
	_conditionalBlock_51d4->push_back( conditionalBlock_51f5);
}

void CallActiveChildExec_51f7::operator()( const Packets_t& states_51f8, const Packets_t& css_51fa, Packets_t& states_51fc, Packets_t& css_51fd)
{
#ifdef PRINT_INFO
	printLog( "CallActiveChildExec_51f7" );
#endif
	_state_51fe= &states_51fc;
	_cs_51ff= &css_51fd;
	if( ( !states_51f8.empty())&& ( !css_51fa.empty()))
		callGetChildStates_523d( states_51f8, css_51fa);
	_state_51fe->insert( _state_51fe->end(), states_51f8.begin(), states_51f8.end());
	_cs_51ff->insert( _cs_51ff->end(), css_51fa.begin(), css_51fa.end());
}

void CallActiveChildExec_51f7::callGetChildStates_523d( const Packets_t& sFStates_4e88, const Packets_t& compoundStatements_4e8c)
{
	Packets_t sFStates_4e8a;
	Packets_t sFChildStates_4e8b;
	Packets_t compoundStatements_4e8e;
	GetChildStates_4e87 getChildStates_4e87;
	getChildStates_4e87( sFStates_4e88, compoundStatements_4e8c, sFStates_4e8a, sFChildStates_4e8b, compoundStatements_4e8e);
	if( ( !sFStates_4e8a.empty())&& ( !sFChildStates_4e8b.empty())&& ( !compoundStatements_4e8e.empty()))
		callExecActiveChildState_5240( sFStates_4e8a, sFChildStates_4e8b, compoundStatements_4e8e);
}

void CallActiveChildExec_51f7::callExecActiveChildState_5240( const Packets_t& sFStates_5201, const Packets_t& sFChildStates_5203, const Packets_t& compoundStatements_5205)
{
	ExecActiveChildState_5200 execActiveChildState_5200;
	execActiveChildState_5200( sFStates_5201, sFChildStates_5203, compoundStatements_5205);
}

void ExecActiveChildState_5200::operator()( const Packets_t& sFStates_5201, const Packets_t& sFChildStates_5203, const Packets_t& compoundStatements_5205)
{
#ifdef PRINT_INFO
	printLog( "ExecActiveChildState_5200" );
#endif
	RTTGenerator::Instance()->generateRule(4666, "ExecActiveChildState");
	processInputPackets( sFStates_5201, sFChildStates_5203, compoundStatements_5205);
}

bool ExecActiveChildState_5200::isInputUnique( const Udm::Object& sFState_520b, const Udm::Object& sFChildState_5214, const Udm::Object& compoundStatement_521d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_520d= _sFState_5207.begin(), itSFChildState_5216= _sFChildState_5210.begin(), itCompoundStatement_521f= _compoundStatement_5219.begin(); itSFState_520d!= _sFState_5207.end(), itSFChildState_5216!= _sFChildState_5210.end(), itCompoundStatement_521f!= _compoundStatement_5219.end(); ++itSFState_520d, ++itSFChildState_5216, ++itCompoundStatement_521f)
	{
		if( ( *itSFState_520d== sFState_520b)&& ( *itSFChildState_5216== sFChildState_5214)&& ( *itCompoundStatement_521f== compoundStatement_521d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_5207.push_back( sFState_520b);
		_sFChildState_5210.push_back( sFChildState_5214);
		_compoundStatement_5219.push_back( compoundStatement_521d);
	}
	return isUnique;
}

void ExecActiveChildState_5200::processInputPackets( const Packets_t& sFStates_5201, const Packets_t& sFChildStates_5203, const Packets_t& compoundStatements_5205)
{
	for( Packets_t::const_iterator itSFState_5208= sFStates_5201.begin(), itSFChildState_5211= sFChildStates_5203.begin(), itCompoundStatement_521a= compoundStatements_5205.begin(); itSFState_5208!= sFStates_5201.end(), itSFChildState_5211!= sFChildStates_5203.end(), itCompoundStatement_521a!= compoundStatements_5205.end(); ++itSFState_5208, ++itSFChildState_5211, ++itCompoundStatement_521a)
	{
		bool isUnique= isInputUnique( *itSFState_5208, *itSFChildState_5211, *itCompoundStatement_521a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5208, *itSFChildState_5211, *itCompoundStatement_521a);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ExecActiveChildState_5200::patternMatcher( const Udm::Object& sFState_5209, const Udm::Object& sFChildState_5212, const Udm::Object& compoundStatement_521b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5209.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_520e= CyberComposition::Simulink::SFState::Cast( sFState_5209);
		if( false== Uml::IsDerivedFrom( sFChildState_5212.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFChildState_5217= CyberComposition::Simulink::SFState::Cast( sFChildState_5212);
		if( false== Uml::IsDerivedFrom( compoundStatement_521b.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_5220= SFC::CompoundStatement::Cast( compoundStatement_521b);
		set< SFC::StateLabel> childStateLabels_5222= sFChildState_5217.src();
		for( set< SFC::StateLabel>::const_iterator itChildStateLabels_5223= childStateLabels_5222.begin(); itChildStateLabels_5223!= childStateLabels_5222.end(); ++itChildStateLabels_5223)
		{
			SFC::StateLabel currChildStateLabel_5224= *itChildStateLabels_5223;
			set< SFC::Function> functions_5225= sFChildState_5217.exec();
			for( set< SFC::Function>::const_iterator itFunctions_5226= functions_5225.begin(); itFunctions_5226!= functions_5225.end(); ++itFunctions_5226)
			{
				SFC::Function currFunction_5227= *itFunctions_5226;
				Udm::Object functionParent_5228= currFunction_5227.container();
				if( false== Uml::IsDerivedFrom( functionParent_5228.type(), SFC::Program::meta))
					continue;
				SFC::Program programFunction_5229= SFC::Program::Cast( functionParent_5228);
				set< SFC::StateVar> stateVars_522a= programFunction_5229.StateVar_kind_children();
				for( set< SFC::StateVar>::const_iterator itStateVar_522b= stateVars_522a.begin(); itStateVar_522b!= stateVars_522a.end(); ++itStateVar_522b)
				{
					SFC::StateVar currStateVar_522c= *itStateVar_522b;
					set< SFC::StateLabel> stateLabels_522d= sFState_520e.src();
					for( set< SFC::StateLabel>::const_iterator itStateLabels_522e= stateLabels_522d.begin(); itStateLabels_522e!= stateLabels_522d.end(); ++itStateLabels_522e)
					{
						SFC::StateLabel currStateLabel_522f= *itStateLabels_522e;
						Match currMatch;
						currMatch.sFState_5231= sFState_520e;
						currMatch.sFChildState_5232= sFChildState_5217;
						currMatch.compoundStatement_5233= compoundStatement_5220;
						currMatch.stateLabel_5234= currStateLabel_522f;
						currMatch.childStateLabel_5235= currChildStateLabel_5224;
						currMatch.function_5236= currFunction_5227;
						currMatch.program_5237= programFunction_5229;
						currMatch.stateVar_5238= currStateVar_522c;
						_matches.push_back( currMatch);
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void ExecActiveChildState_5200::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_5239= SFC::ConditionalBlock::Create( currMatch.compoundStatement_5233, SFC::CompoundStatement::meta_stmnt);
		SFC::Return newReturn_523a= SFC::Return::Create( newConditionalBlock_5239, SFC::ConditionalBlock::meta_stmnt);
		SFC::FunctionCall newFunctionCall_523b= SFC::FunctionCall::Create( newConditionalBlock_5239, SFC::ConditionalBlock::meta_stmnt);
		SFC::CheckState newCheckState_523c= SFC::CheckState::Create( newConditionalBlock_5239, SFC::ConditionalBlock::meta_cond);
		SFC::CheckState& CheckState= newCheckState_523c;
		SFC::StateLabel& ChildStateLabel= currMatch.childStateLabel_5235;
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_5233;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_5239;
		SFC::Function& Function= currMatch.function_5236;
		SFC::FunctionCall& FunctionCall= newFunctionCall_523b;
		SFC::Program& Program= currMatch.program_5237;
		SFC::Return& Return= newReturn_523a;
		CyberComposition::Simulink::SFState& SFChildState= currMatch.sFChildState_5232;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_5231;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_5234;
		SFC::StateVar& StateVar= currMatch.stateVar_5238;
		{
ConditionalBlock.RefId() = FunctionCall.RefId() = Return.RefId() = CompoundStatement.RefId();
};
		{
__int64 statementCount = CompoundStatement.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		{
__int64 statementCount = ConditionalBlock.statementCount();
FunctionCall.statementIndex() = statementCount++;
Return.statementIndex() = statementCount++;
ConditionalBlock.statementCount() = statementCount;
};
		newFunctionCall_523b.callee()= currMatch.function_5236;
		newCheckState_523c.index()= currMatch.stateLabel_5234;
		newCheckState_523c.svar()= currMatch.stateVar_5238;
		newCheckState_523c.value()= currMatch.childStateLabel_5235;
	}
}

void CG_5244::operator()( const Packets_t& sFStates_5245, const Packets_t& compoundStatements_5248, Packets_t& sFStates_5247, Packets_t& conditionalGroups_524a)
{
#ifdef PRINT_INFO
	printLog( "CG_5244" );
#endif
	RTTGenerator::Instance()->generateRule(4700, "CG");
	_sFState_524b= &sFStates_5247;
	_conditionalGroup_524c= &conditionalGroups_524a;
	processInputPackets( sFStates_5245, compoundStatements_5248);
}

bool CG_5244::isInputUnique( const Udm::Object& sFState_5251, const Udm::Object& compoundStatement_525a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_5253= _sFState_524d.begin(), itCompoundStatement_525c= _compoundStatement_5256.begin(); itSFState_5253!= _sFState_524d.end(), itCompoundStatement_525c!= _compoundStatement_5256.end(); ++itSFState_5253, ++itCompoundStatement_525c)
	{
		if( ( *itSFState_5253== sFState_5251)&& ( *itCompoundStatement_525c== compoundStatement_525a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_524d.push_back( sFState_5251);
		_compoundStatement_5256.push_back( compoundStatement_525a);
	}
	return isUnique;
}

bool CG_5244::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CG_5244::processInputPackets( const Packets_t& sFStates_5245, const Packets_t& compoundStatements_5248)
{
	for( Packets_t::const_iterator itSFState_524e= sFStates_5245.begin(), itCompoundStatement_5257= compoundStatements_5248.begin(); itSFState_524e!= sFStates_5245.end(), itCompoundStatement_5257!= compoundStatements_5248.end(); ++itSFState_524e, ++itCompoundStatement_5257)
	{
		bool isUnique= isInputUnique( *itSFState_524e, *itCompoundStatement_5257);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_524e, *itCompoundStatement_5257);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CG_5244::patternMatcher( const Udm::Object& sFState_524f, const Udm::Object& compoundStatement_5258)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_524f.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_5254= CyberComposition::Simulink::SFState::Cast( sFState_524f);
		if( false== Uml::IsDerivedFrom( compoundStatement_5258.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_525d= SFC::CompoundStatement::Cast( compoundStatement_5258);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5262;
		if( !isValidBound(boundObjs_5262, sFState_5254, true))
			continue;
		currMatch.sFState_5263= sFState_5254;
		if( !isValidBound(boundObjs_5262, compoundStatement_525d, true))
			continue;
		currMatch.compoundStatement_5264= compoundStatement_525d;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CG_5244::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalGroup newConditionalGroup_5265= SFC::ConditionalGroup::Create( currMatch.compoundStatement_5264, SFC::CompoundStatement::meta_stmnt);
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_5264;
		SFC::ConditionalGroup& ConditionalGroup= newConditionalGroup_5265;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_5263;
		{
ConditionalGroup.RefId() = CompoundStatement.RefId();
};
		{
__int64 statementCount = CompoundStatement.statementCount();
ConditionalGroup.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		outputAppender( currMatch.sFState_5263, newConditionalGroup_5265);
	}
}

void CG_5244::outputAppender( const CyberComposition::Simulink::SFState& sFState_5266, const SFC::ConditionalGroup& conditionalGroup_5268)
{
	_sFState_524b->push_back( sFState_5266);
	_conditionalGroup_524c->push_back( conditionalGroup_5268);
}

void GetExecFcn_526a::operator()( const Packets_t& sFStates_526b, Packets_t& sFStates_526d, Packets_t& functions_526e)
{
#ifdef PRINT_INFO
	printLog( "GetExecFcn_526a" );
#endif
	RTTGenerator::Instance()->generateRule(4707, "GetExecFcn");
	_sFState_526f= &sFStates_526d;
	_function_5270= &functions_526e;
	processInputPackets( sFStates_526b);
}

bool GetExecFcn_526a::isInputUnique( const Udm::Object& sFState_5275)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_5277= _sFState_5271.begin(); itSFState_5277!= _sFState_5271.end(); ++itSFState_5277)
	{
		if( ( *itSFState_5277== sFState_5275))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_sFState_5271.push_back( sFState_5275);
	return isUnique;
}

void GetExecFcn_526a::processInputPackets( const Packets_t& sFStates_526b)
{
	for( Packets_t::const_iterator itSFState_5272= sFStates_526b.begin(); itSFState_5272!= sFStates_526b.end(); ++itSFState_5272)
	{
		bool isUnique= isInputUnique( *itSFState_5272);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5272);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetExecFcn_526a::patternMatcher( const Udm::Object& sFState_5273)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5273.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_5278= CyberComposition::Simulink::SFState::Cast( sFState_5273);
		set< SFC::Function> functions_527a= sFState_5278.exec();
		for( set< SFC::Function>::const_iterator itFunctions_527b= functions_527a.begin(); itFunctions_527b!= functions_527a.end(); ++itFunctions_527b)
		{
			SFC::Function currFunction_527c= *itFunctions_527b;
			Match currMatch;
			currMatch.sFState_527e= sFState_5278;
			currMatch.function_527f= currFunction_527c;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetExecFcn_526a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_527e, currMatch.function_527f);
	}
}

void GetExecFcn_526a::outputAppender( const CyberComposition::Simulink::SFState& sFState_5280, const SFC::Function& function_5282)
{
	_sFState_526f->push_back( sFState_5280);
	_function_5270->push_back( function_5282);
}

void InnerTransitions_52a8::operator()( const Packets_t& states_52a9, Packets_t& states_52ab)
{
#ifdef PRINT_INFO
	printLog( "InnerTransitions_52a8" );
#endif
	_state_52ac= &states_52ab;
	if( ( !states_52a9.empty()))
		callCheckForInnerTransitions_53df( states_52a9);
	_state_52ac->insert( _state_52ac->end(), states_52a9.begin(), states_52a9.end());
}

void InnerTransitions_52a8::callCheckForInnerTransitions_53df( const Packets_t& states_5317)
{
	Packets_t states_5319;
	CheckForInnerTransitions_5316 checkForInnerTransitions_5316;
	checkForInnerTransitions_5316( states_5317, states_5319);
	if( ( !states_5319.empty()))
		callInit_53e1( states_5319);
}

void InnerTransitions_52a8::callInit_53e1( const Packets_t& states_5344)
{
	Packets_t states_5346;
	Packets_t tcs_5347;
	Packets_t fcns_5348;
	Packets_t cgs_5349;
	Init_5343 init_5343;
	init_5343( states_5344, states_5346, tcs_5347, fcns_5348, cgs_5349);
	if( ( !states_5346.empty())&& ( !tcs_5347.empty())&& ( !fcns_5348.empty())&& ( !cgs_5349.empty()))
		callCreateTransitionCG_53e3( states_5346, tcs_5347, fcns_5348, cgs_5349);
}

void InnerTransitions_52a8::callCreateTransitionCG_53e3( const Packets_t& sFStates_36fd, const Packets_t& sFTransConnectors_3700, const Packets_t& functions_3703, const Packets_t& tCVarCGs_3707)
{
	Packets_t sFStates_36ff;
	Packets_t sFTransConnectors_3702;
	Packets_t functions_3705;
	Packets_t transitionCGs_3706;
	CreateTransitionCG_36fc createTransitionCG_36fc;
	createTransitionCG_36fc( sFStates_36fd, sFTransConnectors_3700, functions_3703, tCVarCGs_3707, sFStates_36ff, sFTransConnectors_3702, functions_3705, transitionCGs_3706);
	if( ( !sFStates_36ff.empty())&& ( !sFTransConnectors_3702.empty())&& ( !functions_3705.empty())&& ( !transitionCGs_3706.empty()))
		callExecInnerTransitions_53e8( sFStates_36ff, sFTransConnectors_3702, functions_3705, transitionCGs_3706);
}

void InnerTransitions_52a8::callExecInnerTransitions_53e8( const Packets_t& states_52ae, const Packets_t& tcs_52b0, const Packets_t& fcns_52b2, const Packets_t& css_52b4)
{
	Packets_t states_52b6;
	Packets_t tcs_52b7;
	Packets_t fcns_52b8;
	Packets_t css_52b9;
	ExecInnerTransitions_52ad execInnerTransitions_52ad;
	execInnerTransitions_52ad( states_52ae, tcs_52b0, fcns_52b2, css_52b4, states_52b6, tcs_52b7, fcns_52b8, css_52b9);
	if( ( !states_52b6.empty())&& ( !tcs_52b7.empty())&& ( !fcns_52b8.empty())&& ( !css_52b9.empty()))
		callNoDefaultTransition_53ed( states_52b6, tcs_52b7, fcns_52b8, css_52b9);
}

void InnerTransitions_52a8::callNoDefaultTransition_53ed( const Packets_t& states_2e48, const Packets_t& tcs_2e4a, const Packets_t& fcns_2e4c, const Packets_t& css_2e4e)
{
	NoDefaultTransition_2e47 noDefaultTransition_2e47;
	noDefaultTransition_2e47( states_2e48, tcs_2e4a, fcns_2e4c, css_2e4e);
}

void ExecInnerTransitions_52ad::operator()( const Packets_t& states_52ae, const Packets_t& tcs_52b0, const Packets_t& fcns_52b2, const Packets_t& css_52b4, Packets_t& states_52b6, Packets_t& tcs_52b7, Packets_t& fcns_52b8, Packets_t& css_52b9)
{
#ifdef PRINT_INFO
	printLog( "ExecInnerTransitions_52ad" );
#endif
	_state_52ba= &states_52b6;
	_tc_52bb= &tcs_52b7;
	_fcn_52bc= &fcns_52b8;
	_cs_52bd= &css_52b9;
	if( ( !states_52ae.empty())&& ( !tcs_52b0.empty())&& ( !fcns_52b2.empty())&& ( !css_52b4.empty()))
		callGetInnerTransitions_530c( states_52ae, tcs_52b0, fcns_52b2, css_52b4);
	_state_52ba->insert( _state_52ba->end(), states_52ae.begin(), states_52ae.end());
	_tc_52bb->insert( _tc_52bb->end(), tcs_52b0.begin(), tcs_52b0.end());
	_fcn_52bc->insert( _fcn_52bc->end(), fcns_52b2.begin(), fcns_52b2.end());
	_cs_52bd->insert( _cs_52bd->end(), css_52b4.begin(), css_52b4.end());
}

void ExecInnerTransitions_52ad::callGetInnerTransitions_530c( const Packets_t& sFStates_52bf, const Packets_t& sFParentStates_52c2, const Packets_t& functions_52c5, const Packets_t& compoundStatements_52c8)
{
	Packets_t sFStates_52c1;
	Packets_t sFTransitions_52c4;
	Packets_t functions_52c7;
	Packets_t compoundStatements_52ca;
	GetInnerTransitions_52be getInnerTransitions_52be;
	getInnerTransitions_52be( sFStates_52bf, sFParentStates_52c2, functions_52c5, compoundStatements_52c8, sFStates_52c1, sFTransitions_52c4, functions_52c7, compoundStatements_52ca);
	if( ( !sFStates_52c1.empty())&& ( !sFTransitions_52c4.empty())&& ( !functions_52c7.empty())&& ( !compoundStatements_52ca.empty()))
		callExecProcessTransitions_5311( sFStates_52c1, sFTransitions_52c4, functions_52c7, compoundStatements_52ca);
}

void ExecInnerTransitions_52ad::callExecProcessTransitions_5311( const Packets_t& states_2fb3, const Packets_t& transs_2fb5, const Packets_t& fcns_2fb7, const Packets_t& css_2fb9)
{
	ExecProcessTransitions_2fb2 execProcessTransitions_2fb2;
	execProcessTransitions_2fb2( states_2fb3, transs_2fb5, fcns_2fb7, css_2fb9);
}

void GetInnerTransitions_52be::operator()( const Packets_t& sFStates_52bf, const Packets_t& sFParentStates_52c2, const Packets_t& functions_52c5, const Packets_t& compoundStatements_52c8, Packets_t& sFStates_52c1, Packets_t& sFTransitions_52c4, Packets_t& functions_52c7, Packets_t& compoundStatements_52ca)
{
#ifdef PRINT_INFO
	printLog( "GetInnerTransitions_52be" );
#endif
	RTTGenerator::Instance()->generateRule(4758, "GetInnerTransitions");
	_sFState_52cb= &sFStates_52c1;
	_sFTransition_52cc= &sFTransitions_52c4;
	_function_52cd= &functions_52c7;
	_compoundStatement_52ce= &compoundStatements_52ca;
	processInputPackets( sFStates_52bf, sFParentStates_52c2, functions_52c5, compoundStatements_52c8);
}

bool GetInnerTransitions_52be::isInputUnique( const Udm::Object& sFState_52d3, const Udm::Object& sFParentState_52dc, const Udm::Object& function_52e5, const Udm::Object& compoundStatement_52ee)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_52d5= _sFState_52cf.begin(), itSFParentState_52de= _sFParentState_52d8.begin(), itFunction_52e7= _function_52e1.begin(), itCompoundStatement_52f0= _compoundStatement_52ea.begin(); itSFState_52d5!= _sFState_52cf.end(), itSFParentState_52de!= _sFParentState_52d8.end(), itFunction_52e7!= _function_52e1.end(), itCompoundStatement_52f0!= _compoundStatement_52ea.end(); ++itSFState_52d5, ++itSFParentState_52de, ++itFunction_52e7, ++itCompoundStatement_52f0)
	{
		if( ( *itSFState_52d5== sFState_52d3)&& ( *itSFParentState_52de== sFParentState_52dc)&& ( *itFunction_52e7== function_52e5)&& ( *itCompoundStatement_52f0== compoundStatement_52ee))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_52cf.push_back( sFState_52d3);
		_sFParentState_52d8.push_back( sFParentState_52dc);
		_function_52e1.push_back( function_52e5);
		_compoundStatement_52ea.push_back( compoundStatement_52ee);
	}
	return isUnique;
}

void GetInnerTransitions_52be::processInputPackets( const Packets_t& sFStates_52bf, const Packets_t& sFParentStates_52c2, const Packets_t& functions_52c5, const Packets_t& compoundStatements_52c8)
{
	for( Packets_t::const_iterator itSFState_52d0= sFStates_52bf.begin(), itSFParentState_52d9= sFParentStates_52c2.begin(), itFunction_52e2= functions_52c5.begin(), itCompoundStatement_52eb= compoundStatements_52c8.begin(); itSFState_52d0!= sFStates_52bf.end(), itSFParentState_52d9!= sFParentStates_52c2.end(), itFunction_52e2!= functions_52c5.end(), itCompoundStatement_52eb!= compoundStatements_52c8.end(); ++itSFState_52d0, ++itSFParentState_52d9, ++itFunction_52e2, ++itCompoundStatement_52eb)
	{
		bool isUnique= isInputUnique( *itSFState_52d0, *itSFParentState_52d9, *itFunction_52e2, *itCompoundStatement_52eb);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_52d0, *itSFParentState_52d9, *itFunction_52e2, *itCompoundStatement_52eb);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetInnerTransitions_52be::patternMatcher( const Udm::Object& sFState_52d1, const Udm::Object& sFParentState_52da, const Udm::Object& function_52e3, const Udm::Object& compoundStatement_52ec)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_52d1.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_52d6= CyberComposition::Simulink::SFState::Cast( sFState_52d1);
		if( false== Uml::IsDerivedFrom( sFParentState_52da.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFParentState_52df= CyberComposition::Simulink::SFState::Cast( sFParentState_52da);
		if( false== Uml::IsDerivedFrom( function_52e3.type(), SFC::Function::meta))
			continue;
		SFC::Function function_52e8= SFC::Function::Cast( function_52e3);
		if( false== Uml::IsDerivedFrom( compoundStatement_52ec.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_52f1= SFC::CompoundStatement::Cast( compoundStatement_52ec);
		set< CyberComposition::Simulink::SFConnectorRef> sFConnectorRefs_52f3= sFParentState_52df.SFConnectorRef_kind_children();
		for( set< CyberComposition::Simulink::SFConnectorRef>::const_iterator itSFConnectorRef_52f4= sFConnectorRefs_52f3.begin(); itSFConnectorRef_52f4!= sFConnectorRefs_52f3.end(); ++itSFConnectorRef_52f4)
		{
			CyberComposition::Simulink::SFConnectorRef currSFConnectorRef_52f5= *itSFConnectorRef_52f4;
			CyberComposition::Simulink::SFTransConnector sFParentState_52f6= currSFConnectorRef_52f5.ref();
			if( false== Uml::IsDerivedFrom( sFParentState_52f6.type(), CyberComposition::Simulink::SFState::meta))
				continue;
			CyberComposition::Simulink::SFState sFParentState_52f7= CyberComposition::Simulink::SFState::Cast( sFParentState_52f6);
			if( !sFParentState_52f7)
				continue;
			if( sFParentState_52df!= sFParentState_52f7)
				continue;
			set< CyberComposition::Simulink::SFTransition> sFTransitions_52f8= currSFConnectorRef_52f5.dstTransition();
			for( set< CyberComposition::Simulink::SFTransition>::const_iterator itSFTransitions_52f9= sFTransitions_52f8.begin(); itSFTransitions_52f9!= sFTransitions_52f8.end(); ++itSFTransitions_52f9)
			{
				CyberComposition::Simulink::SFTransition currSFTransition_52fa= *itSFTransitions_52f9;
				CyberComposition::Simulink::SFTransConnector sFTransConnector_52fb= currSFTransition_52fa.dstTransition_end();
				Match currMatch;
				currMatch.sFState_52fd= sFState_52d6;
				currMatch.sFParentState_52fe= sFParentState_52df;
				currMatch.function_52ff= function_52e8;
				currMatch.compoundStatement_5300= compoundStatement_52f1;
				currMatch.sFConnectorRef_5301= currSFConnectorRef_52f5;
				currMatch.sFTransConnector_5302= sFTransConnector_52fb;
				currMatch.sFTransition_5303= currSFTransition_52fa;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetInnerTransitions_52be::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_52fd, currMatch.sFTransition_5303, currMatch.function_52ff, currMatch.compoundStatement_5300);
	}
}

void GetInnerTransitions_52be::outputAppender( const CyberComposition::Simulink::SFState& sFState_5304, const CyberComposition::Simulink::SFTransition& sFTransition_5306, const SFC::Function& function_5308, const SFC::CompoundStatement& compoundStatement_530a)
{
	_sFState_52cb->push_back( sFState_5304);
	_sFTransition_52cc->push_back( sFTransition_5306);
	_function_52cd->push_back( function_5308);
	_compoundStatement_52ce->push_back( compoundStatement_530a);
}

void CheckForInnerTransitions_5316::operator()( const Packets_t& states_5317, Packets_t& states_5319)
{
#ifdef PRINT_INFO
	printLog( "CheckForInnerTransitions_5316" );
#endif
	_state_531a= &states_5319;
	for( Packets_t::const_iterator itstate_531c= states_5317.begin(); itstate_531c!= states_5317.end(); ++itstate_531c)
	{
		bool isUnique= isInputUnique( *itstate_531c);
		if( !isUnique)
			continue;
		Packets_t onestate_5320( 1, *itstate_531c);
		executeOne( onestate_5320);
	}
}

void CheckForInnerTransitions_5316::executeOne( const Packets_t& states_5317)
{
	Packets_t sFStates_5325;
	HasInnerTransition_5322 hasInnerTransition_5322;
	bool isMatchHasInnerTransition_5322= hasInnerTransition_5322( states_5317, sFStates_5325);
	_state_531a->insert( _state_531a->end(), sFStates_5325.begin(), sFStates_5325.end());
	if( isMatchHasInnerTransition_5322)
		return;
}

bool CheckForInnerTransitions_5316::isInputUnique( const Udm::Object& state_531d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_531f= _state_531b.begin(); itstate_531f!= _state_531b.end(); ++itstate_531f)
	{
		if( ( *itstate_531f== state_531d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_531b.push_back( state_531d);
	return isUnique;
}

bool HasInnerTransition_5322::operator()( const Packets_t& sFStates_5323, Packets_t& sFStates_5325)
{
#ifdef PRINT_INFO
	printLog( "HasInnerTransition_5322" );
#endif
	_sFState_5326= &sFStates_5325;
	processInputPackets( sFStates_5323);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasInnerTransition_5322::isInputUnique( const Udm::Object& sFState_532b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_532d= _sFState_5327.begin(); itSFState_532d!= _sFState_5327.end(); ++itSFState_532d)
	{
		if( ( *itSFState_532d== sFState_532b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_sFState_5327.push_back( sFState_532b);
	return isUnique;
}

bool HasInnerTransition_5322::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void HasInnerTransition_5322::processInputPackets( const Packets_t& sFStates_5323)
{
	for( Packets_t::const_iterator itSFState_5328= sFStates_5323.begin(); itSFState_5328!= sFStates_5323.end(); ++itSFState_5328)
	{
		bool isUnique= isInputUnique( *itSFState_5328);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5328);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_533d);
	}
}

bool HasInnerTransition_5322::patternMatcher( const Udm::Object& sFState_5329)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5329.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_532e= CyberComposition::Simulink::SFState::Cast( sFState_5329);
		set< CyberComposition::Simulink::SFConnectorRef> sFConnectorRefs_5330= sFState_532e.SFConnectorRef_kind_children();
		for( set< CyberComposition::Simulink::SFConnectorRef>::const_iterator itSFConnectorRef_5331= sFConnectorRefs_5330.begin(); itSFConnectorRef_5331!= sFConnectorRefs_5330.end(); ++itSFConnectorRef_5331)
		{
			CyberComposition::Simulink::SFConnectorRef currSFConnectorRef_5332= *itSFConnectorRef_5331;
			CyberComposition::Simulink::SFTransConnector sFState_5333= currSFConnectorRef_5332.ref();
			if( false== Uml::IsDerivedFrom( sFState_5333.type(), CyberComposition::Simulink::SFState::meta))
				continue;
			CyberComposition::Simulink::SFState sFState_5334= CyberComposition::Simulink::SFState::Cast( sFState_5333);
			if( !sFState_5334)
				continue;
			if( sFState_532e!= sFState_5334)
				continue;
			set< CyberComposition::Simulink::SFTransition> sFTransitions_5335= currSFConnectorRef_5332.dstTransition();
			for( set< CyberComposition::Simulink::SFTransition>::const_iterator itSFTransitions_5336= sFTransitions_5335.begin(); itSFTransitions_5336!= sFTransitions_5335.end(); ++itSFTransitions_5336)
			{
				CyberComposition::Simulink::SFTransition currSFTransition_5337= *itSFTransitions_5336;
				CyberComposition::Simulink::SFTransConnector sFTransConnector_5338= currSFTransition_5337.dstTransition_end();
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_533c;
				if( !isValidBound(boundObjs_533c, sFState_532e, true))
					continue;
				currMatch.sFState_533d= sFState_532e;
				if( !isValidBound(boundObjs_533c, currSFTransition_5337, false))
					continue;
				currMatch.sFTransition_533e= currSFTransition_5337;
				if( !isValidBound(boundObjs_533c, currSFConnectorRef_5332, false))
					continue;
				currMatch.sFConnectorRef_533f= currSFConnectorRef_5332;
				if( !isValidBound(boundObjs_533c, sFTransConnector_5338, false))
					continue;
				currMatch.sFTransConnector_5340= sFTransConnector_5338;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void HasInnerTransition_5322::outputAppender( const CyberComposition::Simulink::SFState& sFState_5341)
{
	_sFState_5326->push_back( sFState_5341);
}

void Init_5343::operator()( const Packets_t& states_5344, Packets_t& states_5346, Packets_t& tcs_5347, Packets_t& fcns_5348, Packets_t& cgs_5349)
{
#ifdef PRINT_INFO
	printLog( "Init_5343" );
#endif
	_state_534a= &states_5346;
	_tc_534b= &tcs_5347;
	_fcn_534c= &fcns_5348;
	_cg_534d= &cgs_5349;
	if( ( !states_5344.empty()))
		callGetExecFunction_53d1( states_5344);
}

void Init_5343::callGetExecFunction_53d1( const Packets_t& sFStates_53b8)
{
	Packets_t sFStates_53ba;
	Packets_t execs_53bb;
	GetExecFunction_53b7 getExecFunction_53b7;
	getExecFunction_53b7( sFStates_53b8, sFStates_53ba, execs_53bb);
	if( ( !sFStates_53ba.empty())&& ( !execs_53bb.empty())&& ( !execs_53bb.empty()))
		callInitHTPVar_53d3( sFStates_53ba, execs_53bb, execs_53bb);
}

void Init_5343::callInitHTPVar_53d3( const Packets_t& sFStates_537b, const Packets_t& functions_537e, const Packets_t& compoundStatements_5381)
{
	Packets_t sFStates_537d;
	Packets_t functions_5380;
	Packets_t compoundStatements_5383;
	InitHTPVar_537a initHTPVar_537a;
	initHTPVar_537a( sFStates_537b, functions_537e, compoundStatements_5381, sFStates_537d, functions_5380, compoundStatements_5383);
	if( ( !sFStates_537d.empty())&& ( !functions_5380.empty())&& ( !compoundStatements_5383.empty()))
		callInitTCVarLoop_53d7( sFStates_537d, functions_5380, compoundStatements_5383);
}

void Init_5343::callInitTCVarLoop_53d7( const Packets_t& sFStates_3f4e, const Packets_t& functions_3f51, const Packets_t& compoundStatements_3f54)
{
	Packets_t sFStates_3f50;
	Packets_t functions_3f53;
	Packets_t conditionalGroups_3f56;
	InitTCVarLoop_3f4d initTCVarLoop_3f4d;
	initTCVarLoop_3f4d( sFStates_3f4e, functions_3f51, compoundStatements_3f54, sFStates_3f50, functions_3f53, conditionalGroups_3f56);
	if( ( !sFStates_3f50.empty())&& ( !functions_3f53.empty())&& ( !conditionalGroups_3f56.empty()))
		callGetStartTC_53db( sFStates_3f50, functions_3f53, conditionalGroups_3f56);
}

void Init_5343::callGetStartTC_53db( const Packets_t& sFStates_534f, const Packets_t& functions_5352, const Packets_t& conditionalGroups_5355)
{
	Packets_t sFStates_5351;
	Packets_t functions_5354;
	Packets_t conditionalGroups_5357;
	GetStartTC_534e getStartTC_534e;
	getStartTC_534e( sFStates_534f, functions_5352, conditionalGroups_5355, sFStates_5351, functions_5354, conditionalGroups_5357);
	_tc_534b->insert( _tc_534b->end(), sFStates_5351.begin(), sFStates_5351.end());
	_state_534a->insert( _state_534a->end(), sFStates_5351.begin(), sFStates_5351.end());
	_fcn_534c->insert( _fcn_534c->end(), functions_5354.begin(), functions_5354.end());
	_cg_534d->insert( _cg_534d->end(), conditionalGroups_5357.begin(), conditionalGroups_5357.end());
}

void GetStartTC_534e::operator()( const Packets_t& sFStates_534f, const Packets_t& functions_5352, const Packets_t& conditionalGroups_5355, Packets_t& sFStates_5351, Packets_t& functions_5354, Packets_t& conditionalGroups_5357)
{
#ifdef PRINT_INFO
	printLog( "GetStartTC_534e" );
#endif
	RTTGenerator::Instance()->generateRule(4878, "GetStartTC");
	_sFState_5358= &sFStates_5351;
	_function_5359= &functions_5354;
	_conditionalGroup_535a= &conditionalGroups_5357;
	processInputPackets( sFStates_534f, functions_5352, conditionalGroups_5355);
	forwardInputs( );
}

bool GetStartTC_534e::isInputUnique( const Udm::Object& sFState_535f, const Udm::Object& function_5368, const Udm::Object& conditionalGroup_5371)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_5361= _sFState_535b.begin(), itFunction_536a= _function_5364.begin(), itConditionalGroup_5373= _conditionalGroup_536d.begin(); itSFState_5361!= _sFState_535b.end(), itFunction_536a!= _function_5364.end(), itConditionalGroup_5373!= _conditionalGroup_536d.end(); ++itSFState_5361, ++itFunction_536a, ++itConditionalGroup_5373)
	{
		if( ( *itSFState_5361== sFState_535f)&& ( *itFunction_536a== function_5368)&& ( *itConditionalGroup_5373== conditionalGroup_5371))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_535b.push_back( sFState_535f);
		_function_5364.push_back( function_5368);
		_conditionalGroup_536d.push_back( conditionalGroup_5371);
	}
	return isUnique;
}

void GetStartTC_534e::processInputPackets( const Packets_t& sFStates_534f, const Packets_t& functions_5352, const Packets_t& conditionalGroups_5355)
{
	for( Packets_t::const_iterator itSFState_535c= sFStates_534f.begin(), itFunction_5365= functions_5352.begin(), itConditionalGroup_536e= conditionalGroups_5355.begin(); itSFState_535c!= sFStates_534f.end(), itFunction_5365!= functions_5352.end(), itConditionalGroup_536e!= conditionalGroups_5355.end(); ++itSFState_535c, ++itFunction_5365, ++itConditionalGroup_536e)
	{
		bool isUnique= isInputUnique( *itSFState_535c, *itFunction_5365, *itConditionalGroup_536e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_535c, *itFunction_5365, *itConditionalGroup_536e);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetStartTC_534e::patternMatcher( const Udm::Object& sFState_535d, const Udm::Object& function_5366, const Udm::Object& conditionalGroup_536f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_535d.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_5362= CyberComposition::Simulink::SFState::Cast( sFState_535d);
		if( false== Uml::IsDerivedFrom( function_5366.type(), SFC::Function::meta))
			continue;
		SFC::Function function_536b= SFC::Function::Cast( function_5366);
		if( false== Uml::IsDerivedFrom( conditionalGroup_536f.type(), SFC::ConditionalGroup::meta))
			continue;
		SFC::ConditionalGroup conditionalGroup_5374= SFC::ConditionalGroup::Cast( conditionalGroup_536f);
		Match currMatch;
		currMatch.sFState_5377= sFState_5362;
		currMatch.function_5378= function_536b;
		currMatch.conditionalGroup_5379= conditionalGroup_5374;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void GetStartTC_534e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
	}
}

void GetStartTC_534e::forwardInputs()
{
	*_sFState_5358= _sFState_535b;
	*_function_5359= _function_5364;
	*_conditionalGroup_535a= _conditionalGroup_536d;
}

void InitHTPVar_537a::operator()( const Packets_t& sFStates_537b, const Packets_t& functions_537e, const Packets_t& compoundStatements_5381, Packets_t& sFStates_537d, Packets_t& functions_5380, Packets_t& compoundStatements_5383)
{
#ifdef PRINT_INFO
	printLog( "InitHTPVar_537a" );
#endif
	RTTGenerator::Instance()->generateRule(4882, "InitHTPVar");
	_sFState_5384= &sFStates_537d;
	_function_5385= &functions_5380;
	_compoundStatement_5386= &compoundStatements_5383;
	processInputPackets( sFStates_537b, functions_537e, compoundStatements_5381);
	forwardInputs( );
}

bool InitHTPVar_537a::isInputUnique( const Udm::Object& sFState_538b, const Udm::Object& function_5394, const Udm::Object& compoundStatement_539d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_538d= _sFState_5387.begin(), itFunction_5396= _function_5390.begin(), itCompoundStatement_539f= _compoundStatement_5399.begin(); itSFState_538d!= _sFState_5387.end(), itFunction_5396!= _function_5390.end(), itCompoundStatement_539f!= _compoundStatement_5399.end(); ++itSFState_538d, ++itFunction_5396, ++itCompoundStatement_539f)
	{
		if( ( *itSFState_538d== sFState_538b)&& ( *itFunction_5396== function_5394)&& ( *itCompoundStatement_539f== compoundStatement_539d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_5387.push_back( sFState_538b);
		_function_5390.push_back( function_5394);
		_compoundStatement_5399.push_back( compoundStatement_539d);
	}
	return isUnique;
}

bool InitHTPVar_537a::isGuardTrue( SFC::CompoundStatement& CompoundStatement, SFC::Function& Function, SFC::LocalVar& HTPVar, CyberComposition::Simulink::SFState& SFState, SFC::StateLabel& StateLabel)
{
	bool Gz_guard= false;
	return static_cast< std::string >( HTPVar.name() ) == "_HTPVar_";;
	return Gz_guard;
}

void InitHTPVar_537a::processInputPackets( const Packets_t& sFStates_537b, const Packets_t& functions_537e, const Packets_t& compoundStatements_5381)
{
	for( Packets_t::const_iterator itSFState_5388= sFStates_537b.begin(), itFunction_5391= functions_537e.begin(), itCompoundStatement_539a= compoundStatements_5381.begin(); itSFState_5388!= sFStates_537b.end(), itFunction_5391!= functions_537e.end(), itCompoundStatement_539a!= compoundStatements_5381.end(); ++itSFState_5388, ++itFunction_5391, ++itCompoundStatement_539a)
	{
		bool isUnique= isInputUnique( *itSFState_5388, *itFunction_5391, *itCompoundStatement_539a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5388, *itFunction_5391, *itCompoundStatement_539a);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InitHTPVar_537a::patternMatcher( const Udm::Object& sFState_5389, const Udm::Object& function_5392, const Udm::Object& compoundStatement_539b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5389.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_538e= CyberComposition::Simulink::SFState::Cast( sFState_5389);
		if( false== Uml::IsDerivedFrom( function_5392.type(), SFC::Function::meta))
			continue;
		SFC::Function function_5397= SFC::Function::Cast( function_5392);
		if( false== Uml::IsDerivedFrom( compoundStatement_539b.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_53a0= SFC::CompoundStatement::Cast( compoundStatement_539b);
		set< SFC::LocalVar> hTPVars_53a2= function_5397.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itHTPVar_53a3= hTPVars_53a2.begin(); itHTPVar_53a3!= hTPVars_53a2.end(); ++itHTPVar_53a3)
		{
			SFC::LocalVar currHTPVar_53a4= *itHTPVar_53a3;
			set< SFC::StateLabel> stateLabels_53a5= sFState_538e.src();
			for( set< SFC::StateLabel>::const_iterator itStateLabels_53a6= stateLabels_53a5.begin(); itStateLabels_53a6!= stateLabels_53a5.end(); ++itStateLabels_53a6)
			{
				SFC::StateLabel currStateLabel_53a7= *itStateLabels_53a6;
				Match currMatch;
				currMatch.sFState_53a9= sFState_538e;
				currMatch.function_53aa= function_5397;
				currMatch.compoundStatement_53ab= compoundStatement_53a0;
				currMatch.stateLabel_53ac= currStateLabel_53a7;
				currMatch.hTPVar_53ad= currHTPVar_53a4;
				bool Gz_guard= isGuardTrue( currMatch.compoundStatement_53ab, currMatch.function_53aa, currMatch.hTPVar_53ad, currMatch.sFState_53a9, currMatch.stateLabel_53ac);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void InitHTPVar_537a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newInitHTPVar_53b3= SFC::UserCode::Create( currMatch.compoundStatement_53ab, SFC::CompoundStatement::meta_stmnt);
		SFC::BinaryExprs newAssignHTPVar_53b4= SFC::BinaryExprs::Create( newInitHTPVar_53b3, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newHTPArgDeclRef_53b5= SFC::ArgDeclRef::Create( newAssignHTPVar_53b4, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef_53b6= SFC::ArgDeclRef::Create( newAssignHTPVar_53b4, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_53b6;
		SFC::BinaryExprs& AssignHTPVar= newAssignHTPVar_53b4;
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_53ab;
		SFC::Function& Function= currMatch.function_53aa;
		SFC::ArgDeclRef& HTPArgDeclRef= newHTPArgDeclRef_53b5;
		SFC::LocalVar& HTPVar= currMatch.hTPVar_53ad;
		SFC::UserCode& InitHTPVar= newInitHTPVar_53b3;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_53a9;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_53ac;
		{
InitHTPVar.RefId() = CompoundStatement.RefId();
};
		{
__int64 statementCount = CompoundStatement.statementCount();
InitHTPVar.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		{
AssignHTPVar.op() = "=";
};
		newArgDeclRef_53b6.argdecl()= currMatch.stateLabel_53ac;
		newHTPArgDeclRef_53b5.argdecl()= currMatch.hTPVar_53ad;
	}
}

void InitHTPVar_537a::forwardInputs()
{
	*_sFState_5384= _sFState_5387;
	*_function_5385= _function_5390;
	*_compoundStatement_5386= _compoundStatement_5399;
}

void GetExecFunction_53b7::operator()( const Packets_t& sFStates_53b8, Packets_t& sFStates_53ba, Packets_t& execs_53bb)
{
#ifdef PRINT_INFO
	printLog( "GetExecFunction_53b7" );
#endif
	RTTGenerator::Instance()->generateRule(4903, "GetExecFunction");
	_sFState_53bc= &sFStates_53ba;
	_exec_53bd= &execs_53bb;
	processInputPackets( sFStates_53b8);
}

bool GetExecFunction_53b7::isInputUnique( const Udm::Object& sFState_53c2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_53c4= _sFState_53be.begin(); itSFState_53c4!= _sFState_53be.end(); ++itSFState_53c4)
	{
		if( ( *itSFState_53c4== sFState_53c2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_sFState_53be.push_back( sFState_53c2);
	return isUnique;
}

void GetExecFunction_53b7::processInputPackets( const Packets_t& sFStates_53b8)
{
	for( Packets_t::const_iterator itSFState_53bf= sFStates_53b8.begin(); itSFState_53bf!= sFStates_53b8.end(); ++itSFState_53bf)
	{
		bool isUnique= isInputUnique( *itSFState_53bf);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_53bf);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetExecFunction_53b7::patternMatcher( const Udm::Object& sFState_53c0)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_53c0.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_53c5= CyberComposition::Simulink::SFState::Cast( sFState_53c0);
		set< SFC::Function> execs_53c7= sFState_53c5.exec();
		for( set< SFC::Function>::const_iterator itExecs_53c8= execs_53c7.begin(); itExecs_53c8!= execs_53c7.end(); ++itExecs_53c8)
		{
			SFC::Function currExec_53c9= *itExecs_53c8;
			Match currMatch;
			currMatch.sFState_53cb= sFState_53c5;
			currMatch.exec_53cc= currExec_53c9;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetExecFunction_53b7::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_53cb, currMatch.exec_53cc);
	}
}

void GetExecFunction_53b7::outputAppender( const CyberComposition::Simulink::SFState& sFState_53cd, const SFC::Function& exec_53cf)
{
	_sFState_53bc->push_back( sFState_53cd);
	_exec_53bd->push_back( exec_53cf);
}

void InitTransConnMapInner_53f2::operator()( const Packets_t& states_53f3, Packets_t& states_53f5)
{
#ifdef PRINT_INFO
	printLog( "InitTransConnMapInner_53f2" );
#endif
	_state_53f6= &states_53f5;
	if( ( !states_53f3.empty()))
		callInitTransConnectorMap_5435( states_53f3);
	_state_53f6->insert( _state_53f6->end(), states_53f3.begin(), states_53f3.end());
}

void InitTransConnMapInner_53f2::callInitTransConnectorMap_5435( const Packets_t& sFStates_5426)
{
	Packets_t sFStates_5428;
	InitTransConnectorMap_5425 initTransConnectorMap_5425;
	initTransConnectorMap_5425( sFStates_5426, sFStates_5428);
	if( ( !sFStates_5428.empty())&& ( !sFStates_5428.empty()))
		callAddTransConnector_5437( sFStates_5428, sFStates_5428);
}

void InitTransConnMapInner_53f2::callAddTransConnector_5437( const Packets_t& sFStates_418a, const Packets_t& sFTransConnectors_418d)
{
	Packets_t sFStates_418c;
	Packets_t sFTransConnectors_418f;
	AddTransConnector_4189 addTransConnector_4189;
	addTransConnector_4189( sFStates_418a, sFTransConnectors_418d, sFStates_418c, sFTransConnectors_418f);
	if( ( !sFStates_418c.empty())&& ( !sFTransConnectors_418f.empty()))
		callGetInnerTransitions_543a( sFStates_418c, sFTransConnectors_418f);
}

void InitTransConnMapInner_53f2::callGetInnerTransitions_543a( const Packets_t& sFStates_53f8, const Packets_t& sFStates_53fc)
{
	Packets_t sFStates_53fa;
	Packets_t sFTransitions_53fb;
	GetInnerTransitions_53f7 getInnerTransitions_53f7;
	getInnerTransitions_53f7( sFStates_53f8, sFStates_53fc, sFStates_53fa, sFTransitions_53fb);
	if( ( !sFStates_53fa.empty())&& ( !sFTransitions_53fb.empty()))
		callProcessTransitionsMap_543d( sFStates_53fa, sFTransitions_53fb);
}

void InitTransConnMapInner_53f2::callProcessTransitionsMap_543d( const Packets_t& states_4070, const Packets_t& transs_4072)
{
	ProcessTransitionsMap_406f processTransitionsMap_406f;
	processTransitionsMap_406f( states_4070, transs_4072);
}

void GetInnerTransitions_53f7::operator()( const Packets_t& sFStates_53f8, const Packets_t& sFStates_53fc, Packets_t& sFStates_53fa, Packets_t& sFTransitions_53fb)
{
#ifdef PRINT_INFO
	printLog( "GetInnerTransitions_53f7" );
#endif
	RTTGenerator::Instance()->generateRule(4785, "GetInnerTransitions");
	_sFState_53fe= &sFStates_53fa;
	_sFTransition_53ff= &sFTransitions_53fb;
	processInputPackets( sFStates_53f8, sFStates_53fc);
}

bool GetInnerTransitions_53f7::isInputUnique( const Udm::Object& sFState_5404, const Udm::Object& sFState_540d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_5406= _sFState_5400.begin(), itSFState_540f= _sFState_5409.begin(); itSFState_5406!= _sFState_5400.end(), itSFState_540f!= _sFState_5409.end(); ++itSFState_5406, ++itSFState_540f)
	{
		if( ( *itSFState_5406== sFState_5404)&& ( *itSFState_540f== sFState_540d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_5400.push_back( sFState_5404);
		_sFState_5409.push_back( sFState_540d);
	}
	return isUnique;
}

void GetInnerTransitions_53f7::processInputPackets( const Packets_t& sFStates_53f8, const Packets_t& sFStates_53fc)
{
	for( Packets_t::const_iterator itSFState_5401= sFStates_53f8.begin(), itSFState_540a= sFStates_53fc.begin(); itSFState_5401!= sFStates_53f8.end(), itSFState_540a!= sFStates_53fc.end(); ++itSFState_5401, ++itSFState_540a)
	{
		bool isUnique= isInputUnique( *itSFState_5401, *itSFState_540a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5401, *itSFState_540a);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetInnerTransitions_53f7::patternMatcher( const Udm::Object& sFState_5402, const Udm::Object& sFState_540b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5402.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_5407= CyberComposition::Simulink::SFState::Cast( sFState_5402);
		if( false== Uml::IsDerivedFrom( sFState_540b.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_5410= CyberComposition::Simulink::SFState::Cast( sFState_540b);
		set< CyberComposition::Simulink::SFConnectorRef> sFConnectorRefs_5412= sFState_5410.SFConnectorRef_kind_children();
		for( set< CyberComposition::Simulink::SFConnectorRef>::const_iterator itSFConnectorRef_5413= sFConnectorRefs_5412.begin(); itSFConnectorRef_5413!= sFConnectorRefs_5412.end(); ++itSFConnectorRef_5413)
		{
			CyberComposition::Simulink::SFConnectorRef currSFConnectorRef_5414= *itSFConnectorRef_5413;
			CyberComposition::Simulink::SFTransConnector sFState_5415= currSFConnectorRef_5414.ref();
			if( false== Uml::IsDerivedFrom( sFState_5415.type(), CyberComposition::Simulink::SFState::meta))
				continue;
			CyberComposition::Simulink::SFState sFState_5416= CyberComposition::Simulink::SFState::Cast( sFState_5415);
			if( !sFState_5416)
				continue;
			if( sFState_5410!= sFState_5416)
				continue;
			set< CyberComposition::Simulink::SFTransition> sFTransitions_5417= currSFConnectorRef_5414.dstTransition();
			for( set< CyberComposition::Simulink::SFTransition>::const_iterator itSFTransitions_5418= sFTransitions_5417.begin(); itSFTransitions_5418!= sFTransitions_5417.end(); ++itSFTransitions_5418)
			{
				CyberComposition::Simulink::SFTransition currSFTransition_5419= *itSFTransitions_5418;
				CyberComposition::Simulink::SFTransConnector sFDstTransConnector_541a= currSFTransition_5419.dstTransition_end();
				Match currMatch;
				currMatch.sFState_541c= sFState_5407;
				currMatch.sFState_541d= sFState_5410;
				currMatch.sFDstTransConnector_541e= sFDstTransConnector_541a;
				currMatch.sFTransition_541f= currSFTransition_5419;
				currMatch.sFConnectorRef_5420= currSFConnectorRef_5414;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetInnerTransitions_53f7::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_541c, currMatch.sFTransition_541f);
	}
}

void GetInnerTransitions_53f7::outputAppender( const CyberComposition::Simulink::SFState& sFState_5421, const CyberComposition::Simulink::SFTransition& sFTransition_5423)
{
	_sFState_53fe->push_back( sFState_5421);
	_sFTransition_53ff->push_back( sFTransition_5423);
}

void InitTransConnectorMap_5425::operator()( const Packets_t& sFStates_5426, Packets_t& sFStates_5428)
{
#ifdef PRINT_INFO
	printLog( "InitTransConnectorMap_5425" );
#endif
	RTTGenerator::Instance()->generateRule(4803, "InitTransConnectorMap");
	_sFState_5429= &sFStates_5428;
	processInputPackets( sFStates_5426);
	forwardInputs( );
}

bool InitTransConnectorMap_5425::isInputUnique( const Udm::Object& sFState_542e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_5430= _sFState_542a.begin(); itSFState_5430!= _sFState_542a.end(); ++itSFState_5430)
	{
		if( ( *itSFState_5430== sFState_542e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_sFState_542a.push_back( sFState_542e);
	return isUnique;
}

void InitTransConnectorMap_5425::processInputPackets( const Packets_t& sFStates_5426)
{
	for( Packets_t::const_iterator itSFState_542b= sFStates_5426.begin(); itSFState_542b!= sFStates_5426.end(); ++itSFState_542b)
	{
		bool isUnique= isInputUnique( *itSFState_542b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_542b);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InitTransConnectorMap_5425::patternMatcher( const Udm::Object& sFState_542c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_542c.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_5431= CyberComposition::Simulink::SFState::Cast( sFState_542c);
		Match currMatch;
		currMatch.sFState_5434= sFState_5431;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void InitTransConnectorMap_5425::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_5434;
		{
SFManager::SFStateTransConnectorMap::get_singleton().clearState( SFState );
};
	}
}

void InitTransConnectorMap_5425::forwardInputs()
{
	*_sFState_5429= _sFState_542a;
}

void DuringAction_5440::operator()( const Packets_t& sFStates_5441, Packets_t& sFStates_5443)
{
#ifdef PRINT_INFO
	printLog( "DuringAction_5440" );
#endif
	RTTGenerator::Instance()->generateRule(4795, "DuringAction");
	_sFState_5444= &sFStates_5443;
	processInputPackets( sFStates_5441);
	forwardInputs( );
}

bool DuringAction_5440::isInputUnique( const Udm::Object& sFState_5449)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_544b= _sFState_5445.begin(); itSFState_544b!= _sFState_5445.end(); ++itSFState_544b)
	{
		if( ( *itSFState_544b== sFState_5449))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_sFState_5445.push_back( sFState_5449);
	return isUnique;
}

bool DuringAction_5440::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void DuringAction_5440::processInputPackets( const Packets_t& sFStates_5441)
{
	for( Packets_t::const_iterator itSFState_5446= sFStates_5441.begin(); itSFState_5446!= sFStates_5441.end(); ++itSFState_5446)
	{
		bool isUnique= isInputUnique( *itSFState_5446);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5446);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool DuringAction_5440::patternMatcher( const Udm::Object& sFState_5447)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5447.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_544c= CyberComposition::Simulink::SFState::Cast( sFState_5447);
		set< SFC::Function> execs_544e= sFState_544c.exec();
		for( set< SFC::Function>::const_iterator itExecs_544f= execs_544e.begin(); itExecs_544f!= execs_544e.end(); ++itExecs_544f)
		{
			SFC::Function currExec_5450= *itExecs_544f;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_5454;
			if( !isValidBound(boundObjs_5454, sFState_544c, true))
				continue;
			currMatch.sFState_5455= sFState_544c;
			if( !isValidBound(boundObjs_5454, currExec_5450, false))
				continue;
			currMatch.exec_5456= currExec_5450;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void DuringAction_5440::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function& Exec= currMatch.exec_5456;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_5455;
		{
std::string duringAction = SFState.DuringAction();
SFManager::mstat2SFC( Exec, duringAction );
};
	}
}

void DuringAction_5440::forwardInputs()
{
	*_sFState_5444= _sFState_5445;
}

void InitTransConnMap_5457::operator()( const Packets_t& states_5458, Packets_t& states_545a)
{
#ifdef PRINT_INFO
	printLog( "InitTransConnMap_5457" );
#endif
	_state_545b= &states_545a;
	if( ( !states_5458.empty()))
		callInitTransConnectorMap_545c( states_5458);
	_state_545b->insert( _state_545b->end(), states_5458.begin(), states_5458.end());
}

void InitTransConnMap_5457::callInitTransConnectorMap_545c( const Packets_t& sFStates_5426)
{
	Packets_t sFStates_5428;
	InitTransConnectorMap_5425 initTransConnectorMap_5425;
	initTransConnectorMap_5425( sFStates_5426, sFStates_5428);
	if( ( !sFStates_5428.empty())&& ( !sFStates_5428.empty()))
		callTransConnectorMapRecurse_545e( sFStates_5428, sFStates_5428);
}

void InitTransConnMap_5457::callTransConnectorMapRecurse_545e( const Packets_t& states_3fc2, const Packets_t& tcs_3fc4)
{
	TransConnectorMapRecurse2_3fc1 transConnectorMapRecurse2_3fc1;
	transConnectorMapRecurse2_3fc1( states_3fc2, tcs_3fc4);
}

void OuterTransitions_5461::operator()( const Packets_t& states_5462, Packets_t& states_5464)
{
#ifdef PRINT_INFO
	printLog( "OuterTransitions_5461" );
#endif
	_state_5465= &states_5464;
	if( ( !states_5462.empty()))
		callCheckForOuterTransitions_54ce( states_5462);
	_state_5465->insert( _state_5465->end(), states_5462.begin(), states_5462.end());
}

void OuterTransitions_5461::callCheckForOuterTransitions_54ce( const Packets_t& states_5467)
{
	Packets_t states_5469;
	CheckForOuterTransitions_5466 checkForOuterTransitions_5466;
	checkForOuterTransitions_5466( states_5467, states_5469);
	if( ( !states_5469.empty()))
		callInit_54d0( states_5469);
}

void OuterTransitions_5461::callInit_54d0( const Packets_t& states_5344)
{
	Packets_t states_5346;
	Packets_t tcs_5347;
	Packets_t fcns_5348;
	Packets_t cgs_5349;
	Init_5343 init_5343;
	init_5343( states_5344, states_5346, tcs_5347, fcns_5348, cgs_5349);
	if( ( !states_5346.empty())&& ( !tcs_5347.empty())&& ( !fcns_5348.empty())&& ( !cgs_5349.empty()))
		callExecTransConnectorRecurse_54d2( states_5346, tcs_5347, fcns_5348, cgs_5349);
}

void OuterTransitions_5461::callExecTransConnectorRecurse_54d2( const Packets_t& states_2e23, const Packets_t& tcs_2e25, const Packets_t& fcns_2e27, const Packets_t& cgs_2e29)
{
	ExecTransConnectorRecurse2_2e22 execTransConnectorRecurse2_2e22;
	execTransConnectorRecurse2_2e22( states_2e23, tcs_2e25, fcns_2e27, cgs_2e29);
}

void CheckForOuterTransitions_5466::operator()( const Packets_t& states_5467, Packets_t& states_5469)
{
#ifdef PRINT_INFO
	printLog( "CheckForOuterTransitions_5466" );
#endif
	_state_546a= &states_5469;
	for( Packets_t::const_iterator itstate_546c= states_5467.begin(); itstate_546c!= states_5467.end(); ++itstate_546c)
	{
		bool isUnique= isInputUnique( *itstate_546c);
		if( !isUnique)
			continue;
		Packets_t onestate_5470( 1, *itstate_546c);
		executeOne( onestate_5470);
	}
}

void CheckForOuterTransitions_5466::executeOne( const Packets_t& states_5467)
{
	Packets_t sFStates_5475;
	HasOuterTransition_5472 hasOuterTransition_5472;
	bool isMatchHasOuterTransition_5472= hasOuterTransition_5472( states_5467, sFStates_5475);
	_state_546a->insert( _state_546a->end(), sFStates_5475.begin(), sFStates_5475.end());
	if( isMatchHasOuterTransition_5472)
		return;
	HasInnerTransition_548a hasInnerTransition_548a;
	bool isMatchHasInnerTransition_548a= hasInnerTransition_548a( states_5467);
	if( isMatchHasInnerTransition_548a)
		return;
	Packets_t sFStates_54a7;
	HasRefOuterTransition_54a4 hasRefOuterTransition_54a4;
	bool isMatchHasRefOuterTransition_54a4= hasRefOuterTransition_54a4( states_5467, sFStates_54a7);
	_state_546a->insert( _state_546a->end(), sFStates_54a7.begin(), sFStates_54a7.end());
	if( isMatchHasRefOuterTransition_54a4)
		return;
	Otherwise_54c0 otherwise_54c0;
	bool isMatchOtherwise_54c0= otherwise_54c0( states_5467);
	if( isMatchOtherwise_54c0)
		return;
}

bool CheckForOuterTransitions_5466::isInputUnique( const Udm::Object& state_546d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_546f= _state_546b.begin(); itstate_546f!= _state_546b.end(); ++itstate_546f)
	{
		if( ( *itstate_546f== state_546d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_state_546b.push_back( state_546d);
	return isUnique;
}

bool HasOuterTransition_5472::operator()( const Packets_t& sFStates_5473, Packets_t& sFStates_5475)
{
#ifdef PRINT_INFO
	printLog( "HasOuterTransition_5472" );
#endif
	_sFState_5476= &sFStates_5475;
	processInputPackets( sFStates_5473);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasOuterTransition_5472::isInputUnique( const Udm::Object& sFState_547b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_547d= _sFState_5477.begin(); itSFState_547d!= _sFState_5477.end(); ++itSFState_547d)
	{
		if( ( *itSFState_547d== sFState_547b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_sFState_5477.push_back( sFState_547b);
	return isUnique;
}

void HasOuterTransition_5472::processInputPackets( const Packets_t& sFStates_5473)
{
	for( Packets_t::const_iterator itSFState_5478= sFStates_5473.begin(); itSFState_5478!= sFStates_5473.end(); ++itSFState_5478)
	{
		bool isUnique= isInputUnique( *itSFState_5478);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5478);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_5485);
	}
}

bool HasOuterTransition_5472::patternMatcher( const Udm::Object& sFState_5479)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5479.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_547e= CyberComposition::Simulink::SFState::Cast( sFState_5479);
		set< CyberComposition::Simulink::SFTransition> sFTransitions_5480= sFState_547e.dstTransition();
		for( set< CyberComposition::Simulink::SFTransition>::const_iterator itSFTransitions_5481= sFTransitions_5480.begin(); itSFTransitions_5481!= sFTransitions_5480.end(); ++itSFTransitions_5481)
		{
			CyberComposition::Simulink::SFTransition currSFTransition_5482= *itSFTransitions_5481;
			CyberComposition::Simulink::SFTransConnector sFTransConnector_5483= currSFTransition_5482.dstTransition_end();
			Match currMatch;
			currMatch.sFState_5485= sFState_547e;
			currMatch.sFTransition_5486= currSFTransition_5482;
			currMatch.sFTransConnector_5487= sFTransConnector_5483;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void HasOuterTransition_5472::outputAppender( const CyberComposition::Simulink::SFState& sFState_5488)
{
	_sFState_5476->push_back( sFState_5488);
}

bool HasInnerTransition_548a::operator()( const Packets_t& sFStates_548b)
{
#ifdef PRINT_INFO
	printLog( "HasInnerTransition_548a" );
#endif
	processInputPackets( sFStates_548b);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasInnerTransition_548a::isInputUnique( const Udm::Object& sFState_5491)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_5493= _sFState_548d.begin(); itSFState_5493!= _sFState_548d.end(); ++itSFState_5493)
	{
		if( ( *itSFState_5493== sFState_5491))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_sFState_548d.push_back( sFState_5491);
	return isUnique;
}

void HasInnerTransition_548a::processInputPackets( const Packets_t& sFStates_548b)
{
	for( Packets_t::const_iterator itSFState_548e= sFStates_548b.begin(); itSFState_548e!= sFStates_548b.end(); ++itSFState_548e)
	{
		bool isUnique= isInputUnique( *itSFState_548e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_548e);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( );
	}
}

bool HasInnerTransition_548a::patternMatcher( const Udm::Object& sFState_548f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_548f.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_5494= CyberComposition::Simulink::SFState::Cast( sFState_548f);
		set< CyberComposition::Simulink::SFConnectorRef> sFConnectorRefs_5496= sFState_5494.SFConnectorRef_kind_children();
		for( set< CyberComposition::Simulink::SFConnectorRef>::const_iterator itSFConnectorRef_5497= sFConnectorRefs_5496.begin(); itSFConnectorRef_5497!= sFConnectorRefs_5496.end(); ++itSFConnectorRef_5497)
		{
			CyberComposition::Simulink::SFConnectorRef currSFConnectorRef_5498= *itSFConnectorRef_5497;
			CyberComposition::Simulink::SFTransConnector sFState_5499= currSFConnectorRef_5498.ref();
			if( false== Uml::IsDerivedFrom( sFState_5499.type(), CyberComposition::Simulink::SFState::meta))
				continue;
			CyberComposition::Simulink::SFState sFState_549a= CyberComposition::Simulink::SFState::Cast( sFState_5499);
			if( !sFState_549a)
				continue;
			if( sFState_5494!= sFState_549a)
				continue;
			set< CyberComposition::Simulink::SFTransition> sFTransitions_549b= currSFConnectorRef_5498.dstTransition();
			for( set< CyberComposition::Simulink::SFTransition>::const_iterator itSFTransitions_549c= sFTransitions_549b.begin(); itSFTransitions_549c!= sFTransitions_549b.end(); ++itSFTransitions_549c)
			{
				CyberComposition::Simulink::SFTransition currSFTransition_549d= *itSFTransitions_549c;
				CyberComposition::Simulink::SFTransConnector sFTransConnector_549e= currSFTransition_549d.dstTransition_end();
				Match currMatch;
				currMatch.sFState_54a0= sFState_5494;
				currMatch.sFTransition_54a1= currSFTransition_549d;
				currMatch.sFConnectorRef_54a2= currSFConnectorRef_5498;
				currMatch.sFTransConnector_54a3= sFTransConnector_549e;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void HasInnerTransition_548a::outputAppender()
{
}

bool HasRefOuterTransition_54a4::operator()( const Packets_t& sFStates_54a5, Packets_t& sFStates_54a7)
{
#ifdef PRINT_INFO
	printLog( "HasRefOuterTransition_54a4" );
#endif
	_sFState_54a8= &sFStates_54a7;
	processInputPackets( sFStates_54a5);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasRefOuterTransition_54a4::isInputUnique( const Udm::Object& sFState_54ad)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_54af= _sFState_54a9.begin(); itSFState_54af!= _sFState_54a9.end(); ++itSFState_54af)
	{
		if( ( *itSFState_54af== sFState_54ad))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_sFState_54a9.push_back( sFState_54ad);
	return isUnique;
}

void HasRefOuterTransition_54a4::processInputPackets( const Packets_t& sFStates_54a5)
{
	for( Packets_t::const_iterator itSFState_54aa= sFStates_54a5.begin(); itSFState_54aa!= sFStates_54a5.end(); ++itSFState_54aa)
	{
		bool isUnique= isInputUnique( *itSFState_54aa);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_54aa);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_54ba);
	}
}

bool HasRefOuterTransition_54a4::patternMatcher( const Udm::Object& sFState_54ab)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_54ab.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_54b0= CyberComposition::Simulink::SFState::Cast( sFState_54ab);
		set< CyberComposition::Simulink::SFConnectorRef> sFConnectorRefs_54b2= sFState_54b0.referedbyConnectorRef();
		for( set< CyberComposition::Simulink::SFConnectorRef>::const_iterator itSFConnectorRefs_54b3= sFConnectorRefs_54b2.begin(); itSFConnectorRefs_54b3!= sFConnectorRefs_54b2.end(); ++itSFConnectorRefs_54b3)
		{
			CyberComposition::Simulink::SFConnectorRef currSFConnectorRef_54b4= *itSFConnectorRefs_54b3;
			set< CyberComposition::Simulink::SFTransition> sFTransitions_54b5= currSFConnectorRef_54b4.dstTransition();
			for( set< CyberComposition::Simulink::SFTransition>::const_iterator itSFTransitions_54b6= sFTransitions_54b5.begin(); itSFTransitions_54b6!= sFTransitions_54b5.end(); ++itSFTransitions_54b6)
			{
				CyberComposition::Simulink::SFTransition currSFTransition_54b7= *itSFTransitions_54b6;
				CyberComposition::Simulink::SFTransConnector sFTransConnector_54b8= currSFTransition_54b7.dstTransition_end();
				Match currMatch;
				currMatch.sFState_54ba= sFState_54b0;
				currMatch.sFTransition_54bb= currSFTransition_54b7;
				currMatch.sFConnectorRef_54bc= currSFConnectorRef_54b4;
				currMatch.sFTransConnector_54bd= sFTransConnector_54b8;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void HasRefOuterTransition_54a4::outputAppender( const CyberComposition::Simulink::SFState& sFState_54be)
{
	_sFState_54a8->push_back( sFState_54be);
}

bool Otherwise_54c0::operator()( const Packets_t& sFStates_54c1)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_54c0" );
#endif
	processInputPackets( sFStates_54c1);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_54c0::isInputUnique( const Udm::Object& sFState_54c7)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_54c9= _sFState_54c3.begin(); itSFState_54c9!= _sFState_54c3.end(); ++itSFState_54c9)
	{
		if( ( *itSFState_54c9== sFState_54c7))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_sFState_54c3.push_back( sFState_54c7);
	return isUnique;
}

void Otherwise_54c0::processInputPackets( const Packets_t& sFStates_54c1)
{
	for( Packets_t::const_iterator itSFState_54c4= sFStates_54c1.begin(); itSFState_54c4!= sFStates_54c1.end(); ++itSFState_54c4)
	{
		bool isUnique= isInputUnique( *itSFState_54c4);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_54c4);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( );
	}
}

bool Otherwise_54c0::patternMatcher( const Udm::Object& sFState_54c5)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_54c5.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_54ca= CyberComposition::Simulink::SFState::Cast( sFState_54c5);
		Match currMatch;
		currMatch.sFState_54cd= sFState_54ca;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_54c0::outputAppender()
{
}

void PopulateExitFunction_54e3::operator()( const Packets_t& states_54e4, const Packets_t& programs_54e6, Packets_t& states_54e8, Packets_t& programs_54e9)
{
#ifdef PRINT_INFO
	printLog( "PopulateExitFunction_54e3" );
#endif
	_state_54ea= &states_54e8;
	_program_54eb= &programs_54e9;
	if( ( !states_54e4.empty()))
		callGetExitFunction_5702( states_54e4);
	_state_54ea->insert( _state_54ea->end(), states_54e4.begin(), states_54e4.end());
	_program_54eb->insert( _program_54eb->end(), programs_54e6.begin(), programs_54e6.end());
}

void PopulateExitFunction_54e3::callGetExitFunction_5702( const Packets_t& sFStates_56e6)
{
	Packets_t sFStates_56e8;
	Packets_t exits_56e9;
	GetExitFunction_56e5 getExitFunction_56e5;
	getExitFunction_56e5( sFStates_56e6, sFStates_56e8, exits_56e9);
	if( ( !sFStates_56e8.empty())&& ( !exits_56e9.empty()))
		callExitChildStates_5704( sFStates_56e8, exits_56e9);
}

void PopulateExitFunction_54e3::callExitChildStates_5704( const Packets_t& states_5528, const Packets_t& fcns_552a)
{
	Packets_t states_552c;
	Packets_t fcns_552d;
	ExitChildStates_5527 exitChildStates_5527;
	exitChildStates_5527( states_5528, fcns_552a, states_552c, fcns_552d);
	if( ( !states_552c.empty())&& ( !fcns_552d.empty()))
		callGoToParent_5707( states_552c, fcns_552d);
}

void PopulateExitFunction_54e3::callGoToParent_5707( const Packets_t& states_54ed, const Packets_t& fcns_54ef)
{
	Packets_t states_54f1;
	Packets_t fcns_54f2;
	GoToParent_54ec goToParent_54ec;
	goToParent_54ec( states_54ed, fcns_54ef, states_54f1, fcns_54f2);
}

void GoToParent_54ec::operator()( const Packets_t& states_54ed, const Packets_t& fcns_54ef, Packets_t& states_54f1, Packets_t& fcns_54f2)
{
#ifdef PRINT_INFO
	printLog( "GoToParent_54ec" );
#endif
	_state_54f3= &states_54f1;
	_fcn_54f4= &fcns_54f2;
	if( ( !states_54ed.empty())&& ( !fcns_54ef.empty()))
		callArgToParent_5524( states_54ed, fcns_54ef);
	_state_54f3->insert( _state_54f3->end(), states_54ed.begin(), states_54ed.end());
	_fcn_54f4->insert( _fcn_54f4->end(), fcns_54ef.begin(), fcns_54ef.end());
}

void GoToParent_54ec::callArgToParent_5524( const Packets_t& sFStates_54f6, const Packets_t& functions_54f8)
{
	ArgToParent_54f5 argToParent_54f5;
	argToParent_54f5( sFStates_54f6, functions_54f8);
}

void ArgToParent_54f5::operator()( const Packets_t& sFStates_54f6, const Packets_t& functions_54f8)
{
#ifdef PRINT_INFO
	printLog( "ArgToParent_54f5" );
#endif
	RTTGenerator::Instance()->generateRule(4917, "ArgToParent");
	processInputPackets( sFStates_54f6, functions_54f8);
}

bool ArgToParent_54f5::isInputUnique( const Udm::Object& sFState_54fe, const Udm::Object& function_5507)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_5500= _sFState_54fa.begin(), itFunction_5509= _function_5503.begin(); itSFState_5500!= _sFState_54fa.end(), itFunction_5509!= _function_5503.end(); ++itSFState_5500, ++itFunction_5509)
	{
		if( ( *itSFState_5500== sFState_54fe)&& ( *itFunction_5509== function_5507))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_54fa.push_back( sFState_54fe);
		_function_5503.push_back( function_5507);
	}
	return isUnique;
}

bool ArgToParent_54f5::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void ArgToParent_54f5::processInputPackets( const Packets_t& sFStates_54f6, const Packets_t& functions_54f8)
{
	for( Packets_t::const_iterator itSFState_54fb= sFStates_54f6.begin(), itFunction_5504= functions_54f8.begin(); itSFState_54fb!= sFStates_54f6.end(), itFunction_5504!= functions_54f8.end(); ++itSFState_54fb, ++itFunction_5504)
	{
		bool isUnique= isInputUnique( *itSFState_54fb, *itFunction_5504);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_54fb, *itFunction_5504);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ArgToParent_54f5::patternMatcher( const Udm::Object& sFState_54fc, const Udm::Object& function_5505)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_54fc.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_5501= CyberComposition::Simulink::SFState::Cast( sFState_54fc);
		if( false== Uml::IsDerivedFrom( function_5505.type(), SFC::Function::meta))
			continue;
		SFC::Function function_550a= SFC::Function::Cast( function_5505);
		set< SFC::Arg> args_550c= function_550a.Arg_kind_children();
		for( set< SFC::Arg>::const_iterator itArg_550d= args_550c.begin(); itArg_550d!= args_550c.end(); ++itArg_550d)
		{
			SFC::Arg currArg_550e= *itArg_550d;
			Udm::Object sFStateParent_550f= sFState_5501.container();
			if( false== Uml::IsDerivedFrom( sFStateParent_550f.type(), CyberComposition::Simulink::SFState::meta))
				continue;
			CyberComposition::Simulink::SFState sFParentStateSFState_5510= CyberComposition::Simulink::SFState::Cast( sFStateParent_550f);
			set< SFC::Function> parentExits_5511= sFParentStateSFState_5510.exit();
			for( set< SFC::Function>::const_iterator itParentExits_5512= parentExits_5511.begin(); itParentExits_5512!= parentExits_5511.end(); ++itParentExits_5512)
			{
				SFC::Function currParentExit_5513= *itParentExits_5512;
				set< SFC::Arg> parentArgs_5514= currParentExit_5513.Arg_kind_children();
				for( set< SFC::Arg>::const_iterator itParentArg_5515= parentArgs_5514.begin(); itParentArg_5515!= parentArgs_5514.end(); ++itParentArg_5515)
				{
					SFC::Arg currParentArg_5516= *itParentArg_5515;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_551a;
					if( !isValidBound(boundObjs_551a, sFState_5501, true))
						continue;
					currMatch.sFState_551b= sFState_5501;
					if( !isValidBound(boundObjs_551a, function_550a, true))
						continue;
					currMatch.function_551c= function_550a;
					if( !isValidBound(boundObjs_551a, sFParentStateSFState_5510, false))
						continue;
					currMatch.sFParentState_551d= sFParentStateSFState_5510;
					if( !isValidBound(boundObjs_551a, currParentArg_5516, false))
						continue;
					currMatch.parentArg_551e= currParentArg_5516;
					if( !isValidBound(boundObjs_551a, currParentExit_5513, false))
						continue;
					currMatch.parentExit_551f= currParentExit_5513;
					if( !isValidBound(boundObjs_551a, currArg_550e, false))
						continue;
					currMatch.arg_5520= currArg_550e;
					_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void ArgToParent_54f5::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::FunctionCall newFunctionCall_5521= SFC::FunctionCall::Create( currMatch.function_551c, SFC::Function::meta_stmnt);
		SFC::ArgVal newArgVal_5522= SFC::ArgVal::Create( newFunctionCall_5521);
		SFC::ArgDeclRef newArgDeclRef_5523= SFC::ArgDeclRef::Create( newArgVal_5522, SFC::ArgVal::meta_argexpr);
		SFC::Arg& Arg= currMatch.arg_5520;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_5523;
		SFC::ArgVal& ArgVal= newArgVal_5522;
		SFC::Function& Function= currMatch.function_551c;
		SFC::FunctionCall& FunctionCall= newFunctionCall_5521;
		SFC::Arg& ParentArg= currMatch.parentArg_551e;
		SFC::Function& ParentExit= currMatch.parentExit_551f;
		CyberComposition::Simulink::SFState& SFParentState= currMatch.sFParentState_551d;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_551b;
		{
FunctionCall.RefId() = Function.RefId();
};
		{
__int64 statementCount = Function.statementCount();
FunctionCall.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		newFunctionCall_5521.callee()= currMatch.parentExit_551f;
		newArgVal_5522.arg()+= currMatch.parentArg_551e;
		newArgDeclRef_5523.argdecl()= currMatch.arg_5520;
	}
}

void ExitChildStates_5527::operator()( const Packets_t& states_5528, const Packets_t& fcns_552a, Packets_t& states_552c, Packets_t& fcns_552d)
{
#ifdef PRINT_INFO
	printLog( "ExitChildStates_5527" );
#endif
	_state_552e= &states_552c;
	_fcn_552f= &fcns_552d;
	if( ( !states_5528.empty())&& ( !fcns_552a.empty()))
		callArgNegOneOrState_56da( states_5528, fcns_552a);
	_state_552e->insert( _state_552e->end(), states_5528.begin(), states_5528.end());
	_fcn_552f->insert( _fcn_552f->end(), fcns_552a.begin(), fcns_552a.end());
}

void ExitChildStates_5527::callArgNegOneOrState_56da( const Packets_t& sFStates_56a1, const Packets_t& functions_56a5)
{
	Packets_t sFStates_56a3;
	Packets_t args_56a4;
	Packets_t conditionalBlocks_56a7;
	ArgNegOneOrState_56a0 argNegOneOrState_56a0;
	argNegOneOrState_56a0( sFStates_56a1, functions_56a5, sFStates_56a3, args_56a4, conditionalBlocks_56a7);
	if( ( !sFStates_56a3.empty())&& ( !args_56a4.empty())&& ( !conditionalBlocks_56a7.empty()))
		callCallChildExits_56dd( sFStates_56a3, args_56a4, conditionalBlocks_56a7);
}

void ExitChildStates_5527::callCallChildExits_56dd( const Packets_t& states_5577, const Packets_t& args_5579, const Packets_t& cbs_557b)
{
	Packets_t states_557d;
	Packets_t args_557e;
	Packets_t cbs_557f;
	CallChildExits_5576 callChildExits_5576;
	callChildExits_5576( states_5577, args_5579, cbs_557b, states_557d, args_557e, cbs_557f);
	if( ( !states_557d.empty())&& ( !args_557e.empty())&& ( !cbs_557f.empty()))
		callDeactivateState_56e1( states_557d, args_557e, cbs_557f);
}

void ExitChildStates_5527::callDeactivateState_56e1( const Packets_t& sFStates_5531, const Packets_t& args_5533, const Packets_t& childrenCalledCBs_5535)
{
	DeactivateState_5530 deactivateState_5530;
	deactivateState_5530( sFStates_5531, args_5533, childrenCalledCBs_5535);
}

void DeactivateState_5530::operator()( const Packets_t& sFStates_5531, const Packets_t& args_5533, const Packets_t& childrenCalledCBs_5535)
{
#ifdef PRINT_INFO
	printLog( "DeactivateState_5530" );
#endif
	RTTGenerator::Instance()->generateRule(4944, "DeactivateState");
	processInputPackets( sFStates_5531, args_5533, childrenCalledCBs_5535);
}

bool DeactivateState_5530::isInputUnique( const Udm::Object& sFState_553b, const Udm::Object& arg_5544, const Udm::Object& childrenCalledCB_554d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_553d= _sFState_5537.begin(), itArg_5546= _arg_5540.begin(), itChildrenCalledCB_554f= _childrenCalledCB_5549.begin(); itSFState_553d!= _sFState_5537.end(), itArg_5546!= _arg_5540.end(), itChildrenCalledCB_554f!= _childrenCalledCB_5549.end(); ++itSFState_553d, ++itArg_5546, ++itChildrenCalledCB_554f)
	{
		if( ( *itSFState_553d== sFState_553b)&& ( *itArg_5546== arg_5544)&& ( *itChildrenCalledCB_554f== childrenCalledCB_554d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_5537.push_back( sFState_553b);
		_arg_5540.push_back( arg_5544);
		_childrenCalledCB_5549.push_back( childrenCalledCB_554d);
	}
	return isUnique;
}

bool DeactivateState_5530::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void DeactivateState_5530::processInputPackets( const Packets_t& sFStates_5531, const Packets_t& args_5533, const Packets_t& childrenCalledCBs_5535)
{
	for( Packets_t::const_iterator itSFState_5538= sFStates_5531.begin(), itArg_5541= args_5533.begin(), itChildrenCalledCB_554a= childrenCalledCBs_5535.begin(); itSFState_5538!= sFStates_5531.end(), itArg_5541!= args_5533.end(), itChildrenCalledCB_554a!= childrenCalledCBs_5535.end(); ++itSFState_5538, ++itArg_5541, ++itChildrenCalledCB_554a)
	{
		bool isUnique= isInputUnique( *itSFState_5538, *itArg_5541, *itChildrenCalledCB_554a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5538, *itArg_5541, *itChildrenCalledCB_554a);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool DeactivateState_5530::patternMatcher( const Udm::Object& sFState_5539, const Udm::Object& arg_5542, const Udm::Object& childrenCalledCB_554b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5539.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_553e= CyberComposition::Simulink::SFState::Cast( sFState_5539);
		if( false== Uml::IsDerivedFrom( arg_5542.type(), SFC::Arg::meta))
			continue;
		SFC::Arg arg_5547= SFC::Arg::Cast( arg_5542);
		if( false== Uml::IsDerivedFrom( childrenCalledCB_554b.type(), SFC::ConditionalBlock::meta))
			continue;
		SFC::ConditionalBlock childrenCalledCB_5550= SFC::ConditionalBlock::Cast( childrenCalledCB_554b);
		Udm::Object sFStateParent_5552= sFState_553e.container();
		if( false== Uml::IsDerivedFrom( sFStateParent_5552.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFParentStateSFState_5553= CyberComposition::Simulink::SFState::Cast( sFStateParent_5552);
		set< SFC::Function> functions_5554= sFParentStateSFState_5553.exit();
		for( set< SFC::Function>::const_iterator itFunctions_5555= functions_5554.begin(); itFunctions_5555!= functions_5554.end(); ++itFunctions_5555)
		{
			SFC::Function currFunction_5556= *itFunctions_5555;
			Udm::Object functionParent_5557= currFunction_5556.container();
			if( false== Uml::IsDerivedFrom( functionParent_5557.type(), SFC::Program::meta))
				continue;
			SFC::Program programFunction_5558= SFC::Program::Cast( functionParent_5557);
			set< SFC::StateVar> stateVars_5559= programFunction_5558.StateVar_kind_children();
			for( set< SFC::StateVar>::const_iterator itStateVar_555a= stateVars_5559.begin(); itStateVar_555a!= stateVars_5559.end(); ++itStateVar_555a)
			{
				SFC::StateVar currStateVar_555b= *itStateVar_555a;
				set< SFC::StateLabel> parentStateLabels_555c= sFParentStateSFState_5553.src();
				for( set< SFC::StateLabel>::const_iterator itParentStateLabels_555d= parentStateLabels_555c.begin(); itParentStateLabels_555d!= parentStateLabels_555c.end(); ++itParentStateLabels_555d)
				{
					SFC::StateLabel currParentStateLabel_555e= *itParentStateLabels_555d;
					set< SFC::StateLabel> stateLabels_555f= sFState_553e.src();
					for( set< SFC::StateLabel>::const_iterator itStateLabels_5560= stateLabels_555f.begin(); itStateLabels_5560!= stateLabels_555f.end(); ++itStateLabels_5560)
					{
						SFC::StateLabel currStateLabel_5561= *itStateLabels_5560;
						Match currMatch;
						set< pair<int, Udm::Object> > boundObjs_5565;
						if( !isValidBound(boundObjs_5565, sFState_553e, true))
							continue;
						currMatch.sFState_5566= sFState_553e;
						if( !isValidBound(boundObjs_5565, arg_5547, true))
							continue;
						currMatch.arg_5567= arg_5547;
						if( !isValidBound(boundObjs_5565, childrenCalledCB_5550, true))
							continue;
						currMatch.childrenCalledCB_5568= childrenCalledCB_5550;
						if( !isValidBound(boundObjs_5565, sFParentStateSFState_5553, false))
							continue;
						currMatch.sFParentState_5569= sFParentStateSFState_5553;
						if( !isValidBound(boundObjs_5565, currFunction_5556, false))
							continue;
						currMatch.function_556a= currFunction_5556;
						if( !isValidBound(boundObjs_5565, currStateLabel_5561, false))
							continue;
						currMatch.stateLabel_556b= currStateLabel_5561;
						if( !isValidBound(boundObjs_5565, currParentStateLabel_555e, false))
							continue;
						currMatch.parentStateLabel_556c= currParentStateLabel_555e;
						if( !isValidBound(boundObjs_5565, programFunction_5558, false))
							continue;
						currMatch.program_556d= programFunction_5558;
						if( !isValidBound(boundObjs_5565, currStateVar_555b, false))
							continue;
						currMatch.stateVar_556e= currStateVar_555b;
						_matches.push_back( currMatch);
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void DeactivateState_5530::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Return newReturn_556f= SFC::Return::Create( currMatch.childrenCalledCB_5568, SFC::ConditionalBlock::meta_stmnt);
		SFC::ConditionalBlock newConditionalBlock_5570= SFC::ConditionalBlock::Create( currMatch.childrenCalledCB_5568, SFC::ConditionalBlock::meta_stmnt);
		SFC::SetState newSetState_5571= SFC::SetState::Create( newConditionalBlock_5570, SFC::ConditionalBlock::meta_stmnt);
		SFC::UserCode newUserCode_5572= SFC::UserCode::Create( newConditionalBlock_5570, SFC::ConditionalBlock::meta_cond);
		SFC::BinaryExprs newEqual_5573= SFC::BinaryExprs::Create( newUserCode_5572, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newArgDeclRef_5574= SFC::ArgDeclRef::Create( newEqual_5573, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newInt_5575= SFC::Int::Create( newEqual_5573, SFC::BinaryExprs::meta_rightexpr);
		SFC::Arg& Arg= currMatch.arg_5567;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_5574;
		SFC::ConditionalBlock& ChildrenCalledCB= currMatch.childrenCalledCB_5568;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_5570;
		SFC::BinaryExprs& Equal= newEqual_5573;
		SFC::Function& Function= currMatch.function_556a;
		SFC::Int& Int= newInt_5575;
		SFC::StateLabel& ParentStateLabel= currMatch.parentStateLabel_556c;
		SFC::Program& Program= currMatch.program_556d;
		SFC::Return& Return= newReturn_556f;
		CyberComposition::Simulink::SFState& SFParentState= currMatch.sFParentState_5569;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_5566;
		SFC::SetState& SetState= newSetState_5571;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_556b;
		SFC::StateVar& StateVar= currMatch.stateVar_556e;
		SFC::UserCode& UserCode= newUserCode_5572;
		{
ConditionalBlock.RefId() = UserCode.RefId() = SetState.RefId() = Return.RefId() = ChildrenCalledCB.RefId();
};
		{
std::string exitAction = SFState.ExitAction();
exitAction = SFManager::trim( exitAction );

SFManager::mstat2SFC( ConditionalBlock, exitAction );

__int64 statementCount = ConditionalBlock.statementCount();
SetState.statementIndex() = statementCount++;
ConditionalBlock.statementCount() = statementCount;

};
		{
SetState.invert() = true;
SetState.andState() = static_cast< std::string >( SFState.Decomposition() ) == "AND_STATE";
};
		{
__int64 statementCount = ChildrenCalledCB.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
Return.statementIndex() = statementCount++;
ChildrenCalledCB.statementCount() = statementCount;
};
		{
Equal.op() = "==";
Int.val() = -1;
};
		newSetState_5571.index()= currMatch.parentStateLabel_556c;
		newSetState_5571.value()= currMatch.stateLabel_556b;
		newSetState_5571.svar()= currMatch.stateVar_556e;
		newArgDeclRef_5574.argdecl()= currMatch.arg_5567;
	}
}

void CallChildExits_5576::operator()( const Packets_t& states_5577, const Packets_t& args_5579, const Packets_t& cbs_557b, Packets_t& states_557d, Packets_t& args_557e, Packets_t& cbs_557f)
{
#ifdef PRINT_INFO
	printLog( "CallChildExits_5576" );
#endif
	_state_5580= &states_557d;
	_arg_5581= &args_557e;
	_cb_5582= &cbs_557f;
	if( ( !states_5577.empty())&& ( !cbs_557b.empty()))
		callOrStateCG_5696( states_5577, cbs_557b);
	_state_5580->insert( _state_5580->end(), states_5577.begin(), states_5577.end());
	_arg_5581->insert( _arg_5581->end(), args_5579.begin(), args_5579.end());
	_cb_5582->insert( _cb_5582->end(), cbs_557b.begin(), cbs_557b.end());
}

void CallChildExits_5576::callOrStateCG_5696( const Packets_t& states_5584, const Packets_t& css_5586)
{
	Packets_t states_5588;
	Packets_t css_5589;
	OrStateCG_5583 orStateCG_5583;
	orStateCG_5583( states_5584, css_5586, states_5588, css_5589);
	if( ( !states_5588.empty())&& ( !css_5589.empty()))
		callROrderChildStates_5699( states_5588, css_5589);
}

void CallChildExits_5576::callROrderChildStates_5699( const Packets_t& sFStates_5625, const Packets_t& compoundStatements_5629)
{
	Packets_t sFStates_5627;
	Packets_t sFStates_5628;
	Packets_t compoundStatements_562b;
	ROrderChildStates_5624 rOrderChildStates_5624;
	rOrderChildStates_5624( sFStates_5625, compoundStatements_5629, sFStates_5627, sFStates_5628, compoundStatements_562b);
	if( ( !sFStates_5627.empty())&& ( !sFStates_5628.empty())&& ( !compoundStatements_562b.empty()))
		callExitChildStates_569c( sFStates_5627, sFStates_5628, compoundStatements_562b);
}

void CallChildExits_5576::callExitChildStates_569c( const Packets_t& sFStates_5652, const Packets_t& sFChildStates_5654, const Packets_t& compoundStatements_5656)
{
	ExitChildStates_5651 exitChildStates_5651;
	exitChildStates_5651( sFStates_5652, sFChildStates_5654, compoundStatements_5656);
}

void OrStateCG_5583::operator()( const Packets_t& states_5584, const Packets_t& css_5586, Packets_t& states_5588, Packets_t& css_5589)
{
#ifdef PRINT_INFO
	printLog( "OrStateCG_5583" );
#endif
	_state_558a= &states_5588;
	_cs_558b= &css_5589;
	if( ( !states_5584.empty())&& ( !css_5586.empty()))
		callChildStateType_561e( states_5584, css_5586);
}

void OrStateCG_5583::callChildStateType_561e( const Packets_t& states_55b3, const Packets_t& css_55b5)
{
	Packets_t states_55b7;
	Packets_t css_55b8;
	Packets_t states_55b9;
	Packets_t css_55ba;
	ChildStateType_55b2 childStateType_55b2;
	childStateType_55b2( states_55b3, css_55b5, states_55b7, css_55b8, states_55b9, css_55ba);
	_state_558a->insert( _state_558a->end(), states_55b7.begin(), states_55b7.end());
	_cs_558b->insert( _cs_558b->end(), css_55b8.begin(), css_55b8.end());
	if( ( !states_55b9.empty())&& ( !css_55ba.empty()))
		callCG_5621( states_55b9, css_55ba);
}

void OrStateCG_5583::callCG_5621( const Packets_t& sFStates_558d, const Packets_t& compoundStatements_5590)
{
	Packets_t sFStates_558f;
	Packets_t conditionalGroups_5592;
	CG_558c cG_558c;
	cG_558c( sFStates_558d, compoundStatements_5590, sFStates_558f, conditionalGroups_5592);
	_state_558a->insert( _state_558a->end(), sFStates_558f.begin(), sFStates_558f.end());
	_cs_558b->insert( _cs_558b->end(), conditionalGroups_5592.begin(), conditionalGroups_5592.end());
}

void CG_558c::operator()( const Packets_t& sFStates_558d, const Packets_t& compoundStatements_5590, Packets_t& sFStates_558f, Packets_t& conditionalGroups_5592)
{
#ifdef PRINT_INFO
	printLog( "CG_558c" );
#endif
	RTTGenerator::Instance()->generateRule(4995, "CG");
	_sFState_5593= &sFStates_558f;
	_conditionalGroup_5594= &conditionalGroups_5592;
	processInputPackets( sFStates_558d, compoundStatements_5590);
}

bool CG_558c::isInputUnique( const Udm::Object& sFState_5599, const Udm::Object& compoundStatement_55a2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_559b= _sFState_5595.begin(), itCompoundStatement_55a4= _compoundStatement_559e.begin(); itSFState_559b!= _sFState_5595.end(), itCompoundStatement_55a4!= _compoundStatement_559e.end(); ++itSFState_559b, ++itCompoundStatement_55a4)
	{
		if( ( *itSFState_559b== sFState_5599)&& ( *itCompoundStatement_55a4== compoundStatement_55a2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_5595.push_back( sFState_5599);
		_compoundStatement_559e.push_back( compoundStatement_55a2);
	}
	return isUnique;
}

bool CG_558c::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CG_558c::processInputPackets( const Packets_t& sFStates_558d, const Packets_t& compoundStatements_5590)
{
	for( Packets_t::const_iterator itSFState_5596= sFStates_558d.begin(), itCompoundStatement_559f= compoundStatements_5590.begin(); itSFState_5596!= sFStates_558d.end(), itCompoundStatement_559f!= compoundStatements_5590.end(); ++itSFState_5596, ++itCompoundStatement_559f)
	{
		bool isUnique= isInputUnique( *itSFState_5596, *itCompoundStatement_559f);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5596, *itCompoundStatement_559f);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CG_558c::patternMatcher( const Udm::Object& sFState_5597, const Udm::Object& compoundStatement_55a0)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5597.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_559c= CyberComposition::Simulink::SFState::Cast( sFState_5597);
		if( false== Uml::IsDerivedFrom( compoundStatement_55a0.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_55a5= SFC::CompoundStatement::Cast( compoundStatement_55a0);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_55aa;
		if( !isValidBound(boundObjs_55aa, sFState_559c, true))
			continue;
		currMatch.sFState_55ab= sFState_559c;
		if( !isValidBound(boundObjs_55aa, compoundStatement_55a5, true))
			continue;
		currMatch.compoundStatement_55ac= compoundStatement_55a5;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CG_558c::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalGroup newConditionalGroup_55ad= SFC::ConditionalGroup::Create( currMatch.compoundStatement_55ac, SFC::CompoundStatement::meta_stmnt);
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_55ac;
		SFC::ConditionalGroup& ConditionalGroup= newConditionalGroup_55ad;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_55ab;
		{
ConditionalGroup.RefId() = CompoundStatement.RefId();
};
		{
__int64 statementCount = CompoundStatement.statementCount();
ConditionalGroup.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		outputAppender( currMatch.sFState_55ab, newConditionalGroup_55ad);
	}
}

void CG_558c::outputAppender( const CyberComposition::Simulink::SFState& sFState_55ae, const SFC::ConditionalGroup& conditionalGroup_55b0)
{
	_sFState_5593->push_back( sFState_55ae);
	_conditionalGroup_5594->push_back( conditionalGroup_55b0);
}

void ChildStateType_55b2::operator()( const Packets_t& states_55b3, const Packets_t& css_55b5, Packets_t& states_55b7, Packets_t& css_55b8, Packets_t& states_55b9, Packets_t& css_55ba)
{
#ifdef PRINT_INFO
	printLog( "ChildStateType_55b2" );
#endif
	_state_55bb= &states_55b7;
	_cs_55bc= &css_55b8;
	_state_55bd= &states_55b9;
	_cs_55be= &css_55ba;
	for( Packets_t::const_iterator itstate_55c0= states_55b3.begin(), itcs_55c7= css_55b5.begin(); itstate_55c0!= states_55b3.end(), itcs_55c7!= css_55b5.end(); ++itstate_55c0, ++itcs_55c7)
	{
		bool isUnique= isInputUnique( *itstate_55c0, *itcs_55c7);
		if( !isUnique)
			continue;
		Packets_t onestate_55c4( 1, *itstate_55c0);
		Packets_t onecs_55cb( 1, *itcs_55c7);
		executeOne( onestate_55c4, onecs_55cb);
	}
}

void ChildStateType_55b2::executeOne( const Packets_t& states_55b3, const Packets_t& css_55b5)
{
	Packets_t sFStates_55d0;
	Packets_t compoundStatements_55d3;
	ChildAndStates_55cd childAndStates_55cd;
	bool isMatchChildAndStates_55cd= childAndStates_55cd( states_55b3, css_55b5, sFStates_55d0, compoundStatements_55d3);
	_state_55bb->insert( _state_55bb->end(), sFStates_55d0.begin(), sFStates_55d0.end());
	_cs_55bc->insert( _cs_55bc->end(), compoundStatements_55d3.begin(), compoundStatements_55d3.end());
	if( isMatchChildAndStates_55cd)
		return;
	Packets_t sFStates_55fc;
	Packets_t compoundStatements_55ff;
	ChildOrStates_55f9 childOrStates_55f9;
	bool isMatchChildOrStates_55f9= childOrStates_55f9( states_55b3, css_55b5, sFStates_55fc, compoundStatements_55ff);
	_state_55bd->insert( _state_55bd->end(), sFStates_55fc.begin(), sFStates_55fc.end());
	_cs_55be->insert( _cs_55be->end(), compoundStatements_55ff.begin(), compoundStatements_55ff.end());
	if( isMatchChildOrStates_55f9)
		return;
}

bool ChildStateType_55b2::isInputUnique( const Udm::Object& state_55c1, const Udm::Object& cs_55c8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_55c3= _state_55bf.begin(), itcs_55ca= _cs_55c6.begin(); itstate_55c3!= _state_55bf.end(), itcs_55ca!= _cs_55c6.end(); ++itstate_55c3, ++itcs_55ca)
	{
		if( ( *itstate_55c3== state_55c1)&& ( *itcs_55ca== cs_55c8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_55bf.push_back( state_55c1);
		_cs_55c6.push_back( cs_55c8);
	}
	return isUnique;
}

bool ChildAndStates_55cd::operator()( const Packets_t& sFStates_55ce, const Packets_t& compoundStatements_55d1, Packets_t& sFStates_55d0, Packets_t& compoundStatements_55d3)
{
#ifdef PRINT_INFO
	printLog( "ChildAndStates_55cd" );
#endif
	_sFState_55d4= &sFStates_55d0;
	_compoundStatement_55d5= &compoundStatements_55d3;
	processInputPackets( sFStates_55ce, compoundStatements_55d1);
	if( false== _matches.empty())
		return true;
	return false;
}

bool ChildAndStates_55cd::isInputUnique( const Udm::Object& sFState_55da, const Udm::Object& compoundStatement_55e3)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_55dc= _sFState_55d6.begin(), itCompoundStatement_55e5= _compoundStatement_55df.begin(); itSFState_55dc!= _sFState_55d6.end(), itCompoundStatement_55e5!= _compoundStatement_55df.end(); ++itSFState_55dc, ++itCompoundStatement_55e5)
	{
		if( ( *itSFState_55dc== sFState_55da)&& ( *itCompoundStatement_55e5== compoundStatement_55e3))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_55d6.push_back( sFState_55da);
		_compoundStatement_55df.push_back( compoundStatement_55e3);
	}
	return isUnique;
}

bool ChildAndStates_55cd::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool ChildAndStates_55cd::isGuardTrue( SFC::CompoundStatement& CompoundStatement, CyberComposition::Simulink::SFState& SFChildState, CyberComposition::Simulink::SFState& SFState)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( SFChildState.Decomposition() ) == "AND_STATE";;
	return Gz_guard;
}

void ChildAndStates_55cd::processInputPackets( const Packets_t& sFStates_55ce, const Packets_t& compoundStatements_55d1)
{
	for( Packets_t::const_iterator itSFState_55d7= sFStates_55ce.begin(), itCompoundStatement_55e0= compoundStatements_55d1.begin(); itSFState_55d7!= sFStates_55ce.end(), itCompoundStatement_55e0!= compoundStatements_55d1.end(); ++itSFState_55d7, ++itCompoundStatement_55e0)
	{
		bool isUnique= isInputUnique( *itSFState_55d7, *itCompoundStatement_55e0);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_55d7, *itCompoundStatement_55e0);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_55ef, currMatch.compoundStatement_55f0);
	}
}

bool ChildAndStates_55cd::patternMatcher( const Udm::Object& sFState_55d8, const Udm::Object& compoundStatement_55e1)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_55d8.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_55dd= CyberComposition::Simulink::SFState::Cast( sFState_55d8);
		if( false== Uml::IsDerivedFrom( compoundStatement_55e1.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_55e6= SFC::CompoundStatement::Cast( compoundStatement_55e1);
		set< CyberComposition::Simulink::SFState> sFChildStates_55e8= sFState_55dd.SFState_kind_children();
		for( set< CyberComposition::Simulink::SFState>::const_iterator itSFChildState_55e9= sFChildStates_55e8.begin(); itSFChildState_55e9!= sFChildStates_55e8.end(); ++itSFChildState_55e9)
		{
			CyberComposition::Simulink::SFState currSFChildState_55ea= *itSFChildState_55e9;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_55ee;
			if( !isValidBound(boundObjs_55ee, sFState_55dd, true))
				continue;
			currMatch.sFState_55ef= sFState_55dd;
			if( !isValidBound(boundObjs_55ee, compoundStatement_55e6, true))
				continue;
			currMatch.compoundStatement_55f0= compoundStatement_55e6;
			if( !isValidBound(boundObjs_55ee, currSFChildState_55ea, false))
				continue;
			currMatch.sFChildState_55f1= currSFChildState_55ea;
			bool Gz_guard= isGuardTrue( currMatch.compoundStatement_55f0, currMatch.sFChildState_55f1, currMatch.sFState_55ef);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void ChildAndStates_55cd::outputAppender( const CyberComposition::Simulink::SFState& sFState_55f5, const SFC::CompoundStatement& compoundStatement_55f7)
{
	_sFState_55d4->push_back( sFState_55f5);
	_compoundStatement_55d5->push_back( compoundStatement_55f7);
}

bool ChildOrStates_55f9::operator()( const Packets_t& sFStates_55fa, const Packets_t& compoundStatements_55fd, Packets_t& sFStates_55fc, Packets_t& compoundStatements_55ff)
{
#ifdef PRINT_INFO
	printLog( "ChildOrStates_55f9" );
#endif
	_sFState_5600= &sFStates_55fc;
	_compoundStatement_5601= &compoundStatements_55ff;
	processInputPackets( sFStates_55fa, compoundStatements_55fd);
	if( false== _matches.empty())
		return true;
	return false;
}

bool ChildOrStates_55f9::isInputUnique( const Udm::Object& sFState_5606, const Udm::Object& compoundStatement_560f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_5608= _sFState_5602.begin(), itCompoundStatement_5611= _compoundStatement_560b.begin(); itSFState_5608!= _sFState_5602.end(), itCompoundStatement_5611!= _compoundStatement_560b.end(); ++itSFState_5608, ++itCompoundStatement_5611)
	{
		if( ( *itSFState_5608== sFState_5606)&& ( *itCompoundStatement_5611== compoundStatement_560f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_5602.push_back( sFState_5606);
		_compoundStatement_560b.push_back( compoundStatement_560f);
	}
	return isUnique;
}

bool ChildOrStates_55f9::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void ChildOrStates_55f9::processInputPackets( const Packets_t& sFStates_55fa, const Packets_t& compoundStatements_55fd)
{
	for( Packets_t::const_iterator itSFState_5603= sFStates_55fa.begin(), itCompoundStatement_560c= compoundStatements_55fd.begin(); itSFState_5603!= sFStates_55fa.end(), itCompoundStatement_560c!= compoundStatements_55fd.end(); ++itSFState_5603, ++itCompoundStatement_560c)
	{
		bool isUnique= isInputUnique( *itSFState_5603, *itCompoundStatement_560c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5603, *itCompoundStatement_560c);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_5618, currMatch.compoundStatement_5619);
	}
}

bool ChildOrStates_55f9::patternMatcher( const Udm::Object& sFState_5604, const Udm::Object& compoundStatement_560d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5604.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_5609= CyberComposition::Simulink::SFState::Cast( sFState_5604);
		if( false== Uml::IsDerivedFrom( compoundStatement_560d.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_5612= SFC::CompoundStatement::Cast( compoundStatement_560d);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5617;
		if( !isValidBound(boundObjs_5617, sFState_5609, true))
			continue;
		currMatch.sFState_5618= sFState_5609;
		if( !isValidBound(boundObjs_5617, compoundStatement_5612, true))
			continue;
		currMatch.compoundStatement_5619= compoundStatement_5612;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void ChildOrStates_55f9::outputAppender( const CyberComposition::Simulink::SFState& sFState_561a, const SFC::CompoundStatement& compoundStatement_561c)
{
	_sFState_5600->push_back( sFState_561a);
	_compoundStatement_5601->push_back( compoundStatement_561c);
}

void ROrderChildStates_5624::operator()( const Packets_t& sFStates_5625, const Packets_t& compoundStatements_5629, Packets_t& sFStates_5627, Packets_t& sFStates_5628, Packets_t& compoundStatements_562b)
{
#ifdef PRINT_INFO
	printLog( "ROrderChildStates_5624" );
#endif
	RTTGenerator::Instance()->generateRule(5017, "ROrderChildStates");
	_sFState_562c= &sFStates_5627;
	_sFState_562d= &sFStates_5628;
	_compoundStatement_562e= &compoundStatements_562b;
	processInputPackets( sFStates_5625, compoundStatements_5629);
	sortOutputs( );
}

bool ROrderChildStates_5624::isInputUnique( const Udm::Object& sFState_5633, const Udm::Object& compoundStatement_563c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_5635= _sFState_562f.begin(), itCompoundStatement_563e= _compoundStatement_5638.begin(); itSFState_5635!= _sFState_562f.end(), itCompoundStatement_563e!= _compoundStatement_5638.end(); ++itSFState_5635, ++itCompoundStatement_563e)
	{
		if( ( *itSFState_5635== sFState_5633)&& ( *itCompoundStatement_563e== compoundStatement_563c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_562f.push_back( sFState_5633);
		_compoundStatement_5638.push_back( compoundStatement_563c);
	}
	return isUnique;
}

bool ROrderChildStates_5624::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void ROrderChildStates_5624::processInputPackets( const Packets_t& sFStates_5625, const Packets_t& compoundStatements_5629)
{
	for( Packets_t::const_iterator itSFState_5630= sFStates_5625.begin(), itCompoundStatement_5639= compoundStatements_5629.begin(); itSFState_5630!= sFStates_5625.end(), itCompoundStatement_5639!= compoundStatements_5629.end(); ++itSFState_5630, ++itCompoundStatement_5639)
	{
		bool isUnique= isInputUnique( *itSFState_5630, *itCompoundStatement_5639);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5630, *itCompoundStatement_5639);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ROrderChildStates_5624::patternMatcher( const Udm::Object& sFState_5631, const Udm::Object& compoundStatement_563a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5631.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_5636= CyberComposition::Simulink::SFState::Cast( sFState_5631);
		if( false== Uml::IsDerivedFrom( compoundStatement_563a.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_563f= SFC::CompoundStatement::Cast( compoundStatement_563a);
		set< CyberComposition::Simulink::SFState> sFStates_5641= sFState_5636.SFState_kind_children();
		for( set< CyberComposition::Simulink::SFState>::const_iterator itSFState_5642= sFStates_5641.begin(); itSFState_5642!= sFStates_5641.end(); ++itSFState_5642)
		{
			CyberComposition::Simulink::SFState currSFState_5643= *itSFState_5642;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_5647;
			if( !isValidBound(boundObjs_5647, sFState_5636, true))
				continue;
			currMatch.sFState_5648= sFState_5636;
			if( !isValidBound(boundObjs_5647, compoundStatement_563f, true))
				continue;
			currMatch.compoundStatement_5649= compoundStatement_563f;
			if( !isValidBound(boundObjs_5647, currSFState_5643, false))
				continue;
			currMatch.sFState_564a= currSFState_5643;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void ROrderChildStates_5624::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_5648, currMatch.sFState_564a, currMatch.compoundStatement_5649);
	}
}

void ROrderChildStates_5624::outputAppender( const CyberComposition::Simulink::SFState& sFState_564b, const CyberComposition::Simulink::SFState& sFState_564d, const SFC::CompoundStatement& compoundStatement_564f)
{
	_sFState_562c->push_back( sFState_564b);
	_sFState_562d->push_back( sFState_564d);
	_compoundStatement_562e->push_back( compoundStatement_564f);
}

void ROrderChildStates_5624::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::SFState, std::pointer_to_binary_function< const CyberComposition::Simulink::SFState&, const CyberComposition::Simulink::SFState&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::SFState&, const CyberComposition::Simulink::SFState&, bool> ptr_StateRevOrder( StateRevOrder< CyberComposition::Simulink::SFState>);
	SortedSet_t sortedSet( ptr_StateRevOrder);
	std::vector< int> permutationVector( _sFState_562d->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _sFState_562d->begin(); it!= _sFState_562d->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::SFState::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _sFState_562d->begin());
	// order rest of the containers
	permutate( permutationVector, *_sFState_562c);
	permutate( permutationVector, *_compoundStatement_562e);
}

void ExitChildStates_5651::operator()( const Packets_t& sFStates_5652, const Packets_t& sFChildStates_5654, const Packets_t& compoundStatements_5656)
{
#ifdef PRINT_INFO
	printLog( "ExitChildStates_5651" );
#endif
	RTTGenerator::Instance()->generateRule(5022, "ExitChildStates");
	processInputPackets( sFStates_5652, sFChildStates_5654, compoundStatements_5656);
}

bool ExitChildStates_5651::isInputUnique( const Udm::Object& sFState_565c, const Udm::Object& sFChildState_5665, const Udm::Object& compoundStatement_566e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_565e= _sFState_5658.begin(), itSFChildState_5667= _sFChildState_5661.begin(), itCompoundStatement_5670= _compoundStatement_566a.begin(); itSFState_565e!= _sFState_5658.end(), itSFChildState_5667!= _sFChildState_5661.end(), itCompoundStatement_5670!= _compoundStatement_566a.end(); ++itSFState_565e, ++itSFChildState_5667, ++itCompoundStatement_5670)
	{
		if( ( *itSFState_565e== sFState_565c)&& ( *itSFChildState_5667== sFChildState_5665)&& ( *itCompoundStatement_5670== compoundStatement_566e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_5658.push_back( sFState_565c);
		_sFChildState_5661.push_back( sFChildState_5665);
		_compoundStatement_566a.push_back( compoundStatement_566e);
	}
	return isUnique;
}

bool ExitChildStates_5651::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void ExitChildStates_5651::processInputPackets( const Packets_t& sFStates_5652, const Packets_t& sFChildStates_5654, const Packets_t& compoundStatements_5656)
{
	for( Packets_t::const_iterator itSFState_5659= sFStates_5652.begin(), itSFChildState_5662= sFChildStates_5654.begin(), itCompoundStatement_566b= compoundStatements_5656.begin(); itSFState_5659!= sFStates_5652.end(), itSFChildState_5662!= sFChildStates_5654.end(), itCompoundStatement_566b!= compoundStatements_5656.end(); ++itSFState_5659, ++itSFChildState_5662, ++itCompoundStatement_566b)
	{
		bool isUnique= isInputUnique( *itSFState_5659, *itSFChildState_5662, *itCompoundStatement_566b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5659, *itSFChildState_5662, *itCompoundStatement_566b);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ExitChildStates_5651::patternMatcher( const Udm::Object& sFState_565a, const Udm::Object& sFChildState_5663, const Udm::Object& compoundStatement_566c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_565a.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_565f= CyberComposition::Simulink::SFState::Cast( sFState_565a);
		if( false== Uml::IsDerivedFrom( sFChildState_5663.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFChildState_5668= CyberComposition::Simulink::SFState::Cast( sFChildState_5663);
		if( false== Uml::IsDerivedFrom( compoundStatement_566c.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_5671= SFC::CompoundStatement::Cast( compoundStatement_566c);
		set< SFC::StateLabel> stateLabels_5673= sFState_565f.src();
		for( set< SFC::StateLabel>::const_iterator itStateLabels_5674= stateLabels_5673.begin(); itStateLabels_5674!= stateLabels_5673.end(); ++itStateLabels_5674)
		{
			SFC::StateLabel currStateLabel_5675= *itStateLabels_5674;
			set< SFC::Function> exits_5676= sFChildState_5668.exit();
			for( set< SFC::Function>::const_iterator itExits_5677= exits_5676.begin(); itExits_5677!= exits_5676.end(); ++itExits_5677)
			{
				SFC::Function currExit_5678= *itExits_5677;
				Udm::Object exitParent_5679= currExit_5678.container();
				if( false== Uml::IsDerivedFrom( exitParent_5679.type(), SFC::Program::meta))
					continue;
				SFC::Program programExit_567a= SFC::Program::Cast( exitParent_5679);
				set< SFC::StateVar> stateVars_567b= programExit_567a.StateVar_kind_children();
				for( set< SFC::StateVar>::const_iterator itStateVar_567c= stateVars_567b.begin(); itStateVar_567c!= stateVars_567b.end(); ++itStateVar_567c)
				{
					SFC::StateVar currStateVar_567d= *itStateVar_567c;
					set< SFC::Arg> args_567e= currExit_5678.Arg_kind_children();
					for( set< SFC::Arg>::const_iterator itArg_567f= args_567e.begin(); itArg_567f!= args_567e.end(); ++itArg_567f)
					{
						SFC::Arg currArg_5680= *itArg_567f;
						set< SFC::StateLabel> childStateLabels_5681= sFChildState_5668.src();
						for( set< SFC::StateLabel>::const_iterator itChildStateLabels_5682= childStateLabels_5681.begin(); itChildStateLabels_5682!= childStateLabels_5681.end(); ++itChildStateLabels_5682)
						{
							SFC::StateLabel currChildStateLabel_5683= *itChildStateLabels_5682;
							Match currMatch;
							set< pair<int, Udm::Object> > boundObjs_5687;
							if( !isValidBound(boundObjs_5687, sFState_565f, true))
								continue;
							currMatch.sFState_5688= sFState_565f;
							if( !isValidBound(boundObjs_5687, sFChildState_5668, true))
								continue;
							currMatch.sFChildState_5689= sFChildState_5668;
							if( !isValidBound(boundObjs_5687, compoundStatement_5671, true))
								continue;
							currMatch.compoundStatement_568a= compoundStatement_5671;
							if( !isValidBound(boundObjs_5687, currChildStateLabel_5683, false))
								continue;
							currMatch.childStateLabel_568b= currChildStateLabel_5683;
							if( !isValidBound(boundObjs_5687, currStateLabel_5675, false))
								continue;
							currMatch.stateLabel_568c= currStateLabel_5675;
							if( !isValidBound(boundObjs_5687, currStateVar_567d, false))
								continue;
							currMatch.stateVar_568d= currStateVar_567d;
							if( !isValidBound(boundObjs_5687, currArg_5680, false))
								continue;
							currMatch.arg_568e= currArg_5680;
							if( !isValidBound(boundObjs_5687, currExit_5678, false))
								continue;
							currMatch.exit_568f= currExit_5678;
							if( !isValidBound(boundObjs_5687, programExit_567a, false))
								continue;
							currMatch.program_5690= programExit_567a;
							_matches.push_back( currMatch);
						}
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void ExitChildStates_5651::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_5691= SFC::ConditionalBlock::Create( currMatch.compoundStatement_568a, SFC::CompoundStatement::meta_stmnt);
		SFC::CheckState newCheckState_5692= SFC::CheckState::Create( newConditionalBlock_5691, SFC::ConditionalBlock::meta_cond);
		SFC::FunctionCall newFunctionCall_5693= SFC::FunctionCall::Create( newConditionalBlock_5691, SFC::ConditionalBlock::meta_stmnt);
		SFC::ArgVal newArgVal_5694= SFC::ArgVal::Create( newFunctionCall_5693);
		SFC::Int newInt_5695= SFC::Int::Create( newArgVal_5694, SFC::ArgVal::meta_argexpr);
		SFC::Arg& Arg= currMatch.arg_568e;
		SFC::ArgVal& ArgVal= newArgVal_5694;
		SFC::CheckState& CheckState= newCheckState_5692;
		SFC::StateLabel& ChildStateLabel= currMatch.childStateLabel_568b;
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_568a;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_5691;
		SFC::Function& Exit= currMatch.exit_568f;
		SFC::FunctionCall& FunctionCall= newFunctionCall_5693;
		SFC::Int& Int= newInt_5695;
		SFC::Program& Program= currMatch.program_5690;
		CyberComposition::Simulink::SFState& SFChildState= currMatch.sFChildState_5689;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_5688;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_568c;
		SFC::StateVar& StateVar= currMatch.stateVar_568d;
		{
ConditionalBlock.RefId() = FunctionCall.RefId() = CompoundStatement.RefId();
};
		{
Int.val() = -1;
};
		{
__int64 statementCount = CompoundStatement.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		{
__int64 statementCount = ConditionalBlock.statementCount();
FunctionCall.statementIndex() = statementCount++;
ConditionalBlock.statementCount() = statementCount;
};
		newFunctionCall_5693.callee()= currMatch.exit_568f;
		newCheckState_5692.svar()= currMatch.stateVar_568d;
		newCheckState_5692.value()= currMatch.childStateLabel_568b;
		newCheckState_5692.index()= currMatch.stateLabel_568c;
		newArgVal_5694.arg()+= currMatch.arg_568e;
	}
}

void ArgNegOneOrState_56a0::operator()( const Packets_t& sFStates_56a1, const Packets_t& functions_56a5, Packets_t& sFStates_56a3, Packets_t& args_56a4, Packets_t& conditionalBlocks_56a7)
{
#ifdef PRINT_INFO
	printLog( "ArgNegOneOrState_56a0" );
#endif
	RTTGenerator::Instance()->generateRule(5057, "ArgNegOneOrState");
	_sFState_56a8= &sFStates_56a3;
	_arg_56a9= &args_56a4;
	_conditionalBlock_56aa= &conditionalBlocks_56a7;
	processInputPackets( sFStates_56a1, functions_56a5);
}

bool ArgNegOneOrState_56a0::isInputUnique( const Udm::Object& sFState_56af, const Udm::Object& function_56b8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_56b1= _sFState_56ab.begin(), itFunction_56ba= _function_56b4.begin(); itSFState_56b1!= _sFState_56ab.end(), itFunction_56ba!= _function_56b4.end(); ++itSFState_56b1, ++itFunction_56ba)
	{
		if( ( *itSFState_56b1== sFState_56af)&& ( *itFunction_56ba== function_56b8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_56ab.push_back( sFState_56af);
		_function_56b4.push_back( function_56b8);
	}
	return isUnique;
}

bool ArgNegOneOrState_56a0::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void ArgNegOneOrState_56a0::processInputPackets( const Packets_t& sFStates_56a1, const Packets_t& functions_56a5)
{
	for( Packets_t::const_iterator itSFState_56ac= sFStates_56a1.begin(), itFunction_56b5= functions_56a5.begin(); itSFState_56ac!= sFStates_56a1.end(), itFunction_56b5!= functions_56a5.end(); ++itSFState_56ac, ++itFunction_56b5)
	{
		bool isUnique= isInputUnique( *itSFState_56ac, *itFunction_56b5);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_56ac, *itFunction_56b5);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ArgNegOneOrState_56a0::patternMatcher( const Udm::Object& sFState_56ad, const Udm::Object& function_56b6)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_56ad.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_56b2= CyberComposition::Simulink::SFState::Cast( sFState_56ad);
		if( false== Uml::IsDerivedFrom( function_56b6.type(), SFC::Function::meta))
			continue;
		SFC::Function function_56bb= SFC::Function::Cast( function_56b6);
		set< SFC::Arg> args_56bd= function_56bb.Arg_kind_children();
		for( set< SFC::Arg>::const_iterator itArg_56be= args_56bd.begin(); itArg_56be!= args_56bd.end(); ++itArg_56be)
		{
			SFC::Arg currArg_56bf= *itArg_56be;
			set< SFC::StateLabel> stateLabels_56c0= sFState_56b2.src();
			for( set< SFC::StateLabel>::const_iterator itStateLabels_56c1= stateLabels_56c0.begin(); itStateLabels_56c1!= stateLabels_56c0.end(); ++itStateLabels_56c1)
			{
				SFC::StateLabel currStateLabel_56c2= *itStateLabels_56c1;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_56c6;
				if( !isValidBound(boundObjs_56c6, sFState_56b2, true))
					continue;
				currMatch.sFState_56c7= sFState_56b2;
				if( !isValidBound(boundObjs_56c6, function_56bb, true))
					continue;
				currMatch.function_56c8= function_56bb;
				if( !isValidBound(boundObjs_56c6, currStateLabel_56c2, false))
					continue;
				currMatch.stateLabel_56c9= currStateLabel_56c2;
				if( !isValidBound(boundObjs_56c6, currArg_56bf, false))
					continue;
				currMatch.arg_56ca= currArg_56bf;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void ArgNegOneOrState_56a0::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_56cb= SFC::ConditionalBlock::Create( currMatch.function_56c8, SFC::Function::meta_stmnt);
		SFC::UserCode newUserCode_56cc= SFC::UserCode::Create( newConditionalBlock_56cb, SFC::ConditionalBlock::meta_cond);
		SFC::BinaryExprs newLogOR_56cd= SFC::BinaryExprs::Create( newUserCode_56cc, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newEqual2_56ce= SFC::BinaryExprs::Create( newLogOR_56cd, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_56cf= SFC::ArgDeclRef::Create( newEqual2_56ce, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_56d0= SFC::ArgDeclRef::Create( newEqual2_56ce, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newEqual1_56d1= SFC::BinaryExprs::Create( newLogOR_56cd, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRe1f_56d2= SFC::ArgDeclRef::Create( newEqual1_56d1, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newInt_56d3= SFC::Int::Create( newEqual1_56d1, SFC::BinaryExprs::meta_rightexpr);
		SFC::Arg& Arg= currMatch.arg_56ca;
		SFC::ArgDeclRef& ArgDeclRe1f= newArgDeclRe1f_56d2;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_56cf;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_56d0;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_56cb;
		SFC::BinaryExprs& Equal1= newEqual1_56d1;
		SFC::BinaryExprs& Equal2= newEqual2_56ce;
		SFC::Function& Function= currMatch.function_56c8;
		SFC::Int& Int= newInt_56d3;
		SFC::BinaryExprs& LogOR= newLogOR_56cd;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_56c7;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_56c9;
		SFC::UserCode& UserCode= newUserCode_56cc;
		{
ConditionalBlock.RefId() = UserCode.RefId() = Function.RefId();
};
		{
Equal2.op() = "==";
};
		{
LogOR.op() = "||";
};
		{
Equal1.op() = "==";
Int.val() = -1;
};
		{
__int64 statementCount = Function.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		newArgDeclRef2_56d0.argdecl()= currMatch.stateLabel_56c9;
		newArgDeclRef_56cf.argdecl()= currMatch.arg_56ca;
		newArgDeclRe1f_56d2.argdecl()= currMatch.arg_56ca;
		outputAppender( currMatch.sFState_56c7, currMatch.arg_56ca, newConditionalBlock_56cb);
	}
}

void ArgNegOneOrState_56a0::outputAppender( const CyberComposition::Simulink::SFState& sFState_56d4, const SFC::Arg& arg_56d6, const SFC::ConditionalBlock& conditionalBlock_56d8)
{
	_sFState_56a8->push_back( sFState_56d4);
	_arg_56a9->push_back( arg_56d6);
	_conditionalBlock_56aa->push_back( conditionalBlock_56d8);
}

void GetExitFunction_56e5::operator()( const Packets_t& sFStates_56e6, Packets_t& sFStates_56e8, Packets_t& exits_56e9)
{
#ifdef PRINT_INFO
	printLog( "GetExitFunction_56e5" );
#endif
	RTTGenerator::Instance()->generateRule(5090, "GetExitFunction");
	_sFState_56ea= &sFStates_56e8;
	_exit_56eb= &exits_56e9;
	processInputPackets( sFStates_56e6);
}

bool GetExitFunction_56e5::isInputUnique( const Udm::Object& sFState_56f0)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_56f2= _sFState_56ec.begin(); itSFState_56f2!= _sFState_56ec.end(); ++itSFState_56f2)
	{
		if( ( *itSFState_56f2== sFState_56f0))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_sFState_56ec.push_back( sFState_56f0);
	return isUnique;
}

bool GetExitFunction_56e5::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetExitFunction_56e5::processInputPackets( const Packets_t& sFStates_56e6)
{
	for( Packets_t::const_iterator itSFState_56ed= sFStates_56e6.begin(); itSFState_56ed!= sFStates_56e6.end(); ++itSFState_56ed)
	{
		bool isUnique= isInputUnique( *itSFState_56ed);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_56ed);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetExitFunction_56e5::patternMatcher( const Udm::Object& sFState_56ee)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_56ee.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_56f3= CyberComposition::Simulink::SFState::Cast( sFState_56ee);
		set< SFC::Function> exits_56f5= sFState_56f3.exit();
		for( set< SFC::Function>::const_iterator itExits_56f6= exits_56f5.begin(); itExits_56f6!= exits_56f5.end(); ++itExits_56f6)
		{
			SFC::Function currExit_56f7= *itExits_56f6;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_56fb;
			if( !isValidBound(boundObjs_56fb, sFState_56f3, true))
				continue;
			currMatch.sFState_56fc= sFState_56f3;
			if( !isValidBound(boundObjs_56fb, currExit_56f7, false))
				continue;
			currMatch.exit_56fd= currExit_56f7;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetExitFunction_56e5::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_56fc, currMatch.exit_56fd);
	}
}

void GetExitFunction_56e5::outputAppender( const CyberComposition::Simulink::SFState& sFState_56fe, const SFC::Function& exit_5700)
{
	_sFState_56ea->push_back( sFState_56fe);
	_exit_56eb->push_back( exit_5700);
}

void CreateFunctions_571c::operator()( const Packets_t& states_571d, const Packets_t& programs_571f, Packets_t& states_5721, Packets_t& programs_5722)
{
#ifdef PRINT_INFO
	printLog( "CreateFunctions_571c" );
#endif
	_state_5723= &states_5721;
	_program_5724= &programs_5722;
	_state_5723->insert( _state_5723->end(), states_571d.begin(), states_571d.end());
	_program_5724->insert( _program_5724->end(), programs_571f.begin(), programs_571f.end());
	if( ( !states_571d.empty())&& ( !programs_571f.empty()))
		callCreateFunctions_5758( states_571d, programs_571f);
}

void CreateFunctions_571c::callCreateFunctions_5758( const Packets_t& sFStates_5726, const Packets_t& programs_5729)
{
	Packets_t sFStates_5728;
	Packets_t programs_572b;
	CreateFunctions_5725 createFunctions_5725;
	createFunctions_5725( sFStates_5726, programs_5729, sFStates_5728, programs_572b);
	if( ( !sFStates_5728.empty())&& ( !programs_572b.empty()))
		callGetSubStates_575b( sFStates_5728, programs_572b);
}

void CreateFunctions_571c::callGetSubStates_575b( const Packets_t& sFStates_4223, const Packets_t& parStmnts_4226)
{
	Packets_t sFSubStates_4225;
	Packets_t parStmnts_4228;
	GetSubStates_4222 getSubStates_4222;
	getSubStates_4222( sFStates_4223, parStmnts_4226, sFSubStates_4225, parStmnts_4228);
	if( ( !sFSubStates_4225.empty())&& ( !parStmnts_4228.empty()))
		callCreateFunctions_5758( sFSubStates_4225, parStmnts_4228);
}

void CreateFunctions_5725::operator()( const Packets_t& sFStates_5726, const Packets_t& programs_5729, Packets_t& sFStates_5728, Packets_t& programs_572b)
{
#ifdef PRINT_INFO
	printLog( "CreateFunctions_5725" );
#endif
	RTTGenerator::Instance()->generateRule(5099, "CreateFunctions");
	_sFState_572c= &sFStates_5728;
	_program_572d= &programs_572b;
	processInputPackets( sFStates_5726, programs_5729);
	forwardInputs( );
}

bool CreateFunctions_5725::isInputUnique( const Udm::Object& sFState_5732, const Udm::Object& program_573b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_5734= _sFState_572e.begin(), itProgram_573d= _program_5737.begin(); itSFState_5734!= _sFState_572e.end(), itProgram_573d!= _program_5737.end(); ++itSFState_5734, ++itProgram_573d)
	{
		if( ( *itSFState_5734== sFState_5732)&& ( *itProgram_573d== program_573b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_572e.push_back( sFState_5732);
		_program_5737.push_back( program_573b);
	}
	return isUnique;
}

bool CreateFunctions_5725::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool CreateFunctions_5725::isGuardTrue( SFC::Program& Program, CyberComposition::Simulink::SFState& SFState, SFC::StateLabel& StateLabel)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( SFState.Decomposition() ) != "FUNC_STATE";;
	return Gz_guard;
}

void CreateFunctions_5725::processInputPackets( const Packets_t& sFStates_5726, const Packets_t& programs_5729)
{
	for( Packets_t::const_iterator itSFState_572f= sFStates_5726.begin(), itProgram_5738= programs_5729.begin(); itSFState_572f!= sFStates_5726.end(), itProgram_5738!= programs_5729.end(); ++itSFState_572f, ++itProgram_5738)
	{
		bool isUnique= isInputUnique( *itSFState_572f, *itProgram_5738);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_572f, *itProgram_5738);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateFunctions_5725::patternMatcher( const Udm::Object& sFState_5730, const Udm::Object& program_5739)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5730.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_5735= CyberComposition::Simulink::SFState::Cast( sFState_5730);
		if( false== Uml::IsDerivedFrom( program_5739.type(), SFC::Program::meta))
			continue;
		SFC::Program program_573e= SFC::Program::Cast( program_5739);
		set< SFC::StateLabel> stateLabels_5740= sFState_5735.src();
		for( set< SFC::StateLabel>::const_iterator itStateLabels_5741= stateLabels_5740.begin(); itStateLabels_5741!= stateLabels_5740.end(); ++itStateLabels_5741)
		{
			SFC::StateLabel currStateLabel_5742= *itStateLabels_5741;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_5746;
			if( !isValidBound(boundObjs_5746, sFState_5735, true))
				continue;
			currMatch.sFState_5747= sFState_5735;
			if( !isValidBound(boundObjs_5746, program_573e, true))
				continue;
			currMatch.program_5748= program_573e;
			if( !isValidBound(boundObjs_5746, currStateLabel_5742, false))
				continue;
			currMatch.stateLabel_5749= currStateLabel_5742;
			bool Gz_guard= isGuardTrue( currMatch.program_5748, currMatch.sFState_5747, currMatch.stateLabel_5749);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateFunctions_5725::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function newStatus_574d= SFC::Function::Create( currMatch.program_5748, SFC::Program::meta_stmnt);
		SFC::Arg newIndentArg_574e= SFC::Arg::Create( newStatus_574d);
		SFC::Function newEnter_574f= SFC::Function::Create( currMatch.program_5748, SFC::Program::meta_stmnt);
		SFC::LocalVar newEnterTCVar_5750= SFC::LocalVar::Create( newEnter_574f, SFC::Function::meta_stmnt);
		SFC::Arg newTrPathParArg_5751= SFC::Arg::Create( newEnter_574f);
		SFC::Arg newModeArg_5752= SFC::Arg::Create( newEnter_574f);
		SFC::Function newExec_5753= SFC::Function::Create( currMatch.program_5748, SFC::Program::meta_stmnt);
		SFC::LocalVar newExecTCVar_5754= SFC::LocalVar::Create( newExec_5753, SFC::Function::meta_stmnt);
		SFC::LocalVar newExecHTPVar_5755= SFC::LocalVar::Create( newExec_5753, SFC::Function::meta_stmnt);
		SFC::Function newExit_5756= SFC::Function::Create( currMatch.program_5748, SFC::Program::meta_stmnt);
		SFC::Arg newTrParArg_5757= SFC::Arg::Create( newExit_5756);
		SFC::Function& Enter= newEnter_574f;
		SFC::LocalVar& EnterTCVar= newEnterTCVar_5750;
		SFC::Function& Exec= newExec_5753;
		SFC::LocalVar& ExecHTPVar= newExecHTPVar_5755;
		SFC::LocalVar& ExecTCVar= newExecTCVar_5754;
		SFC::Function& Exit= newExit_5756;
		SFC::Arg& IndentArg= newIndentArg_574e;
		SFC::Arg& ModeArg= newModeArg_5752;
		SFC::Program& Program= currMatch.program_5748;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_5747;
		SFC::StateLabel& StateLabel= currMatch.stateLabel_5749;
		SFC::Function& Status= newStatus_574d;
		SFC::Arg& TrParArg= newTrParArg_5757;
		SFC::Arg& TrPathParArg= newTrPathParArg_5751;
		{
Enter.RefId() = Exec.RefId() = Exit.RefId() = Status.RefId() = EnterTCVar.RefId() = ExecHTPVar.RefId() = ExecTCVar.RefId() = ModeArg.RefId() = TrPathParArg.RefId() = TrParArg.RefId() = IndentArg.RefId() = SFState.RefId();
};
		{
__int64 argCount = Status.argCount();
IndentArg.argIndex() = argCount++;
Status.argCount() = argCount;

IndentArg.dt() = SFCTypesManager::getSingleton().getBasicType( "string" );
IndentArg.name() = "indent";
};
		{
Status.dt() = SFCTypesManager::getSingleton().getBasicType( "string" );
};
		{
ExecHTPVar.name() = "_HTPVar_";
ExecHTPVar.dt() = SFCTypesManager::getSingleton().getBasicType( "int32" );
ExecTCVar.name() = "_TCVar_";
ExecTCVar.dt() = SFCTypesManager::getSingleton().getBasicType( "int32" );
};
		{
EnterTCVar.name() = "_TCVar_";
EnterTCVar.dt() = SFCTypesManager::getSingleton().getBasicType( "int32" );
};
		{
__int64 statementCount = Exec.statementCount();
ExecTCVar.statementIndex() = statementCount++;
ExecHTPVar.statementIndex() = statementCount++;
Exec.statementCount() = statementCount;
};
		{
__int64 statementCount = Enter.statementCount();
EnterTCVar.statementIndex() = statementCount++;
Enter.statementCount() = statementCount;
};
		{
TrParArg.name() = "_transitionParent_";
TrParArg.dt() = SFCTypesManager::getSingleton().getBasicType( "int" );
TrParArg.argIndex() = 0;

Exit.argCount() = 1;
};
		{
Enter.annotation() = SFState.Description();
};
		{
std::string name = static_cast< std::string >( SFState.name() ) + "_" + boost::lexical_cast< std::string >( SFState.uniqueId() );
Enter.name() = name + "_enter";
Enter.scope() = StateLabel.comment();
Exec.name() = name + "_exec";
Exec.scope() = StateLabel.comment();
Exit.name() = name + "_exit";
Exit.scope() = StateLabel.comment();
Status.name() = name + "_status";
Status.scope() = StateLabel.comment();
};
		{
ModeArg.name() = "entryMode";
ModeArg.dt() = SFCTypesManager::getSingleton().getBasicType( "int" );
ModeArg.argIndex() = 0;

TrPathParArg.name() = "tpp";
TrPathParArg.dt() = SFCTypesManager::getSingleton().getBasicType( "int" );
TrPathParArg.argIndex() = 1;

Enter.argCount() = 2;
};
		{
__int64 statementCount = Program.statementCount();
Enter.statementIndex() = statementCount++;
Exec.statementIndex()  = statementCount++;
Exit.statementIndex()  = statementCount++;
Status.statementIndex()  = statementCount++;
Program.statementCount() = statementCount;
};
		newStatus_574d.SFstatusSt()+= currMatch.sFState_5747;
		newEnter_574f.SFenterSt()+= currMatch.sFState_5747;
		newExec_5753.SFexecSt()+= currMatch.sFState_5747;
		newExit_5756.SFexitSt()+= currMatch.sFState_5747;
	}
}

void CreateFunctions_5725::forwardInputs()
{
	*_sFState_572c= _sFState_572e;
	*_program_572d= _program_5737;
}

void CreateRootFunction_575e::operator()( const Packets_t& states_575f, const Packets_t& programs_5761, Packets_t& states_5763, Packets_t& programs_5764)
{
#ifdef PRINT_INFO
	printLog( "CreateRootFunction_575e" );
#endif
	_state_5765= &states_5763;
	_program_5766= &programs_5764;
	if( ( !states_575f.empty())&& ( !programs_5761.empty()))
		callCreateRootFunction_5991( states_575f, programs_5761);
	_state_5765->insert( _state_5765->end(), states_575f.begin(), states_575f.end());
	_program_5766->insert( _program_5766->end(), programs_5761.begin(), programs_5761.end());
}

void CreateRootFunction_575e::callCreateRootFunction_5991( const Packets_t& sFStates_578e, const Packets_t& programs_5791)
{
	Packets_t sFStates_5790;
	Packets_t rootFunctions_5793;
	CreateRootFunction_578d createRootFunction_578d;
	createRootFunction_578d( sFStates_578e, programs_5791, sFStates_5790, rootFunctions_5793);
	if( ( !sFStates_5790.empty())&& ( !rootFunctions_5793.empty()))
		callCreateInputArgs_5994( sFStates_5790, rootFunctions_5793);
}

void CreateRootFunction_575e::callCreateInputArgs_5994( const Packets_t& states_57b4, const Packets_t& rootFxns_57b6)
{
	Packets_t states_57b8;
	Packets_t rootFxns_57b9;
	CreateInputArgs_57b3 createInputArgs_57b3;
	createInputArgs_57b3( states_57b4, rootFxns_57b6, states_57b8, rootFxns_57b9);
	if( ( !states_57b8.empty())&& ( !rootFxns_57b9.empty()))
		callCreateRootExecCall_5997( states_57b8, rootFxns_57b9);
}

void CreateRootFunction_575e::callCreateRootExecCall_5997( const Packets_t& sFStates_5768, const Packets_t& rootFunctions_576b)
{
	Packets_t sFStates_576a;
	Packets_t rootFunctions_576d;
	CreateRootExecCall_5767 createRootExecCall_5767;
	createRootExecCall_5767( sFStates_5768, rootFunctions_576b, sFStates_576a, rootFunctions_576d);
	if( ( !sFStates_576a.empty())&& ( !rootFunctions_576d.empty()))
		callCreateOutputArgs_599a( sFStates_576a, rootFunctions_576d);
}

void CreateRootFunction_575e::callCreateOutputArgs_599a( const Packets_t& states_58bd, const Packets_t& rootFxns_58bf)
{
	Packets_t states_58c1;
	Packets_t rootFxns_58c2;
	CreateOutputArgs_58bc createOutputArgs_58bc;
	createOutputArgs_58bc( states_58bd, rootFxns_58bf, states_58c1, rootFxns_58c2);
}

void CreateRootExecCall_5767::operator()( const Packets_t& sFStates_5768, const Packets_t& rootFunctions_576b, Packets_t& sFStates_576a, Packets_t& rootFunctions_576d)
{
#ifdef PRINT_INFO
	printLog( "CreateRootExecCall_5767" );
#endif
	RTTGenerator::Instance()->generateRule(5147, "CreateRootExecCall");
	_sFState_576e= &sFStates_576a;
	_rootFunction_576f= &rootFunctions_576d;
	processInputPackets( sFStates_5768, rootFunctions_576b);
	forwardInputs( );
}

bool CreateRootExecCall_5767::isInputUnique( const Udm::Object& sFState_5774, const Udm::Object& rootFunction_577d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_5776= _sFState_5770.begin(), itRootFunction_577f= _rootFunction_5779.begin(); itSFState_5776!= _sFState_5770.end(), itRootFunction_577f!= _rootFunction_5779.end(); ++itSFState_5776, ++itRootFunction_577f)
	{
		if( ( *itSFState_5776== sFState_5774)&& ( *itRootFunction_577f== rootFunction_577d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_5770.push_back( sFState_5774);
		_rootFunction_5779.push_back( rootFunction_577d);
	}
	return isUnique;
}

bool CreateRootExecCall_5767::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateRootExecCall_5767::processInputPackets( const Packets_t& sFStates_5768, const Packets_t& rootFunctions_576b)
{
	for( Packets_t::const_iterator itSFState_5771= sFStates_5768.begin(), itRootFunction_577a= rootFunctions_576b.begin(); itSFState_5771!= sFStates_5768.end(), itRootFunction_577a!= rootFunctions_576b.end(); ++itSFState_5771, ++itRootFunction_577a)
	{
		bool isUnique= isInputUnique( *itSFState_5771, *itRootFunction_577a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5771, *itRootFunction_577a);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateRootExecCall_5767::patternMatcher( const Udm::Object& sFState_5772, const Udm::Object& rootFunction_577b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5772.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_5777= CyberComposition::Simulink::SFState::Cast( sFState_5772);
		if( false== Uml::IsDerivedFrom( rootFunction_577b.type(), SFC::Function::meta))
			continue;
		SFC::Function rootFunction_5780= SFC::Function::Cast( rootFunction_577b);
		set< SFC::Function> execs_5782= sFState_5777.exec();
		for( set< SFC::Function>::const_iterator itExecs_5783= execs_5782.begin(); itExecs_5783!= execs_5782.end(); ++itExecs_5783)
		{
			SFC::Function currExec_5784= *itExecs_5783;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_5788;
			if( !isValidBound(boundObjs_5788, sFState_5777, true))
				continue;
			currMatch.sFState_5789= sFState_5777;
			if( !isValidBound(boundObjs_5788, rootFunction_5780, true))
				continue;
			currMatch.rootFunction_578a= rootFunction_5780;
			if( !isValidBound(boundObjs_5788, currExec_5784, false))
				continue;
			currMatch.exec_578b= currExec_5784;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateRootExecCall_5767::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::FunctionCall newFunctionCall_578c= SFC::FunctionCall::Create( currMatch.rootFunction_578a, SFC::Function::meta_stmnt);
		SFC::Function& Exec= currMatch.exec_578b;
		SFC::FunctionCall& FunctionCall= newFunctionCall_578c;
		SFC::Function& RootFunction= currMatch.rootFunction_578a;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_5789;
		{
FunctionCall.RefId() = RootFunction.RefId();
};
		{
__int64 statementCount = RootFunction.statementCount();
FunctionCall.statementIndex() = statementCount++;
RootFunction.statementCount() = statementCount;
};
		newFunctionCall_578c.callee()= currMatch.exec_578b;
	}
}

void CreateRootExecCall_5767::forwardInputs()
{
	*_sFState_576e= _sFState_5770;
	*_rootFunction_576f= _rootFunction_5779;
}

void CreateRootFunction_578d::operator()( const Packets_t& sFStates_578e, const Packets_t& programs_5791, Packets_t& sFStates_5790, Packets_t& rootFunctions_5793)
{
#ifdef PRINT_INFO
	printLog( "CreateRootFunction_578d" );
#endif
	RTTGenerator::Instance()->generateRule(5157, "CreateRootFunction");
	_sFState_5794= &sFStates_5790;
	_rootFunction_5795= &rootFunctions_5793;
	processInputPackets( sFStates_578e, programs_5791);
}

bool CreateRootFunction_578d::isInputUnique( const Udm::Object& sFState_579a, const Udm::Object& program_57a3)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_579c= _sFState_5796.begin(), itProgram_57a5= _program_579f.begin(); itSFState_579c!= _sFState_5796.end(), itProgram_57a5!= _program_579f.end(); ++itSFState_579c, ++itProgram_57a5)
	{
		if( ( *itSFState_579c== sFState_579a)&& ( *itProgram_57a5== program_57a3))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_5796.push_back( sFState_579a);
		_program_579f.push_back( program_57a3);
	}
	return isUnique;
}

bool CreateRootFunction_578d::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateRootFunction_578d::processInputPackets( const Packets_t& sFStates_578e, const Packets_t& programs_5791)
{
	for( Packets_t::const_iterator itSFState_5797= sFStates_578e.begin(), itProgram_57a0= programs_5791.begin(); itSFState_5797!= sFStates_578e.end(), itProgram_57a0!= programs_5791.end(); ++itSFState_5797, ++itProgram_57a0)
	{
		bool isUnique= isInputUnique( *itSFState_5797, *itProgram_57a0);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5797, *itProgram_57a0);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateRootFunction_578d::patternMatcher( const Udm::Object& sFState_5798, const Udm::Object& program_57a1)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5798.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_579d= CyberComposition::Simulink::SFState::Cast( sFState_5798);
		if( false== Uml::IsDerivedFrom( program_57a1.type(), SFC::Program::meta))
			continue;
		SFC::Program program_57a6= SFC::Program::Cast( program_57a1);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_57ab;
		if( !isValidBound(boundObjs_57ab, sFState_579d, true))
			continue;
		currMatch.sFState_57ac= sFState_579d;
		if( !isValidBound(boundObjs_57ab, program_57a6, true))
			continue;
		currMatch.program_57ad= program_57a6;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateRootFunction_578d::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function newRootFunction_57ae= SFC::Function::Create( currMatch.program_57ad);
		SFC::Program& Program= currMatch.program_57ad;
		SFC::Function& RootFunction= newRootFunction_57ae;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_57ac;
		{
RootFunction.RefId() = SFState.RefId();
};
		{
RootFunction.name() = static_cast< std::string >( SFState.name() ) + "_main";
};
		{
__int64 statementCount = Program.statementCount();
RootFunction.statementIndex() = statementCount++;
Program.statementCount() = statementCount;
};
		outputAppender( currMatch.sFState_57ac, newRootFunction_57ae);
	}
}

void CreateRootFunction_578d::outputAppender( const CyberComposition::Simulink::SFState& sFState_57af, const SFC::Function& rootFunction_57b1)
{
	_sFState_5794->push_back( sFState_57af);
	_rootFunction_5795->push_back( rootFunction_57b1);
}

void CreateInputArgs_57b3::operator()( const Packets_t& states_57b4, const Packets_t& rootFxns_57b6, Packets_t& states_57b8, Packets_t& rootFxns_57b9)
{
#ifdef PRINT_INFO
	printLog( "CreateInputArgs_57b3" );
#endif
	_state_57ba= &states_57b8;
	_rootFxn_57bb= &rootFxns_57b9;
	_state_57ba->insert( _state_57ba->end(), states_57b4.begin(), states_57b4.end());
	_rootFxn_57bb->insert( _rootFxn_57bb->end(), rootFxns_57b6.begin(), rootFxns_57b6.end());
	if( ( !states_57b4.empty())&& ( !rootFxns_57b6.empty()))
		callCheckStateDecomp_58ad( states_57b4, rootFxns_57b6);
}

void CreateInputArgs_57b3::callCheckStateDecomp_58ad( const Packets_t& states_47be, const Packets_t& programs_47c0)
{
	Packets_t states_47c2;
	Packets_t programs_47c3;
	Packets_t states_47c4;
	Packets_t programs_47c5;
	CheckStateDecomp_47bd checkStateDecomp_47bd;
	checkStateDecomp_47bd( states_47be, programs_47c0, states_47c2, programs_47c3, states_47c4, programs_47c5);
	if( ( !states_47c2.empty())&& ( !programs_47c3.empty()))
		callGetSubStates_58b0( states_47c2, programs_47c3);
	if( ( !states_47c4.empty())&& ( !programs_47c5.empty()))
		callCreateIDArgs_58b3( states_47c4, programs_47c5);
}

void CreateInputArgs_57b3::callGetSubStates_58b0( const Packets_t& sFStates_4223, const Packets_t& parStmnts_4226)
{
	Packets_t sFSubStates_4225;
	Packets_t parStmnts_4228;
	GetSubStates_4222 getSubStates_4222;
	getSubStates_4222( sFStates_4223, parStmnts_4226, sFSubStates_4225, parStmnts_4228);
	if( ( !sFSubStates_4225.empty())&& ( !parStmnts_4228.empty()))
		callCheckStateDecomp_58ad( sFSubStates_4225, parStmnts_4228);
}

void CreateInputArgs_57b3::callCreateIDArgs_58b3( const Packets_t& states_57ee, const Packets_t& rootFxns_57f0)
{
	Packets_t states_57f2;
	Packets_t rootFxns_57f3;
	CreateIDArgs_57ed createIDArgs_57ed;
	createIDArgs_57ed( states_57ee, rootFxns_57f0, states_57f2, rootFxns_57f3);
	if( ( !states_57f2.empty())&& ( !rootFxns_57f3.empty()))
		callCreateIEArgs_58b6( states_57f2, rootFxns_57f3);
}

void CreateInputArgs_57b3::callCreateIEArgs_58b6( const Packets_t& states_584e, const Packets_t& rootFxns_5850)
{
	Packets_t states_5852;
	Packets_t rootFxns_5853;
	CreateIEArgs_584d createIEArgs_584d;
	createIEArgs_584d( states_584e, rootFxns_5850, states_5852, rootFxns_5853);
	if( ( !states_5852.empty())&& ( !rootFxns_5853.empty()))
		callCreateLEInit_58b9( states_5852, rootFxns_5853);
}

void CreateInputArgs_57b3::callCreateLEInit_58b9( const Packets_t& sFStates_57bd, const Packets_t& rootFunctions_57c0)
{
	Packets_t sFStates_57bf;
	Packets_t rootFunctions_57c2;
	CreateLEInit_57bc createLEInit_57bc;
	createLEInit_57bc( sFStates_57bd, rootFunctions_57c0, sFStates_57bf, rootFunctions_57c2);
	if( ( !sFStates_57bf.empty())&& ( !rootFunctions_57c2.empty()))
		callGetSubStates_58b0( sFStates_57bf, rootFunctions_57c2);
}

void CreateLEInit_57bc::operator()( const Packets_t& sFStates_57bd, const Packets_t& rootFunctions_57c0, Packets_t& sFStates_57bf, Packets_t& rootFunctions_57c2)
{
#ifdef PRINT_INFO
	printLog( "CreateLEInit_57bc" );
#endif
	RTTGenerator::Instance()->generateRule(5170, "CreateLEInit");
	_sFState_57c3= &sFStates_57bf;
	_rootFunction_57c4= &rootFunctions_57c2;
	processInputPackets( sFStates_57bd, rootFunctions_57c0);
	forwardInputs( );
}

bool CreateLEInit_57bc::isInputUnique( const Udm::Object& sFState_57c9, const Udm::Object& rootFunction_57d2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_57cb= _sFState_57c5.begin(), itRootFunction_57d4= _rootFunction_57ce.begin(); itSFState_57cb!= _sFState_57c5.end(), itRootFunction_57d4!= _rootFunction_57ce.end(); ++itSFState_57cb, ++itRootFunction_57d4)
	{
		if( ( *itSFState_57cb== sFState_57c9)&& ( *itRootFunction_57d4== rootFunction_57d2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_57c5.push_back( sFState_57c9);
		_rootFunction_57ce.push_back( rootFunction_57d2);
	}
	return isUnique;
}

bool CreateLEInit_57bc::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool CreateLEInit_57bc::isGuardTrue( SFC::LocalVar& LocalVar, SFC::Function& RootFunction, CyberComposition::Simulink::SFEvent& SFEvent, CyberComposition::Simulink::SFState& SFState)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( SFEvent.Scope() ) == "LOCAL_EVENT";;
	return Gz_guard;
}

void CreateLEInit_57bc::processInputPackets( const Packets_t& sFStates_57bd, const Packets_t& rootFunctions_57c0)
{
	for( Packets_t::const_iterator itSFState_57c6= sFStates_57bd.begin(), itRootFunction_57cf= rootFunctions_57c0.begin(); itSFState_57c6!= sFStates_57bd.end(), itRootFunction_57cf!= rootFunctions_57c0.end(); ++itSFState_57c6, ++itRootFunction_57cf)
	{
		bool isUnique= isInputUnique( *itSFState_57c6, *itRootFunction_57cf);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_57c6, *itRootFunction_57cf);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateLEInit_57bc::patternMatcher( const Udm::Object& sFState_57c7, const Udm::Object& rootFunction_57d0)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_57c7.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_57cc= CyberComposition::Simulink::SFState::Cast( sFState_57c7);
		if( false== Uml::IsDerivedFrom( rootFunction_57d0.type(), SFC::Function::meta))
			continue;
		SFC::Function rootFunction_57d5= SFC::Function::Cast( rootFunction_57d0);
		set< CyberComposition::Simulink::SFEvent> sFEvents_57d7= sFState_57cc.SFEvent_kind_children();
		for( set< CyberComposition::Simulink::SFEvent>::const_iterator itSFEvent_57d8= sFEvents_57d7.begin(); itSFEvent_57d8!= sFEvents_57d7.end(); ++itSFEvent_57d8)
		{
			CyberComposition::Simulink::SFEvent currSFEvent_57d9= *itSFEvent_57d8;
			set< SFC::LocalVar> localVars_57da= currSFEvent_57d9.src();
			for( set< SFC::LocalVar>::const_iterator itLocalVars_57db= localVars_57da.begin(); itLocalVars_57db!= localVars_57da.end(); ++itLocalVars_57db)
			{
				SFC::LocalVar currLocalVar_57dc= *itLocalVars_57db;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_57e0;
				if( !isValidBound(boundObjs_57e0, sFState_57cc, true))
					continue;
				currMatch.sFState_57e1= sFState_57cc;
				if( !isValidBound(boundObjs_57e0, rootFunction_57d5, true))
					continue;
				currMatch.rootFunction_57e2= rootFunction_57d5;
				if( !isValidBound(boundObjs_57e0, currSFEvent_57d9, false))
					continue;
				currMatch.sFEvent_57e3= currSFEvent_57d9;
				if( !isValidBound(boundObjs_57e0, currLocalVar_57dc, false))
					continue;
				currMatch.localVar_57e4= currLocalVar_57dc;
				bool Gz_guard= isGuardTrue( currMatch.localVar_57e4, currMatch.rootFunction_57e2, currMatch.sFEvent_57e3, currMatch.sFState_57e1);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void CreateLEInit_57bc::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newInitEventCode_57e9= SFC::UserCode::Create( currMatch.rootFunction_57e2, SFC::Function::meta_stmnt);
		SFC::BinaryExprs newBinaryExprs_57ea= SFC::BinaryExprs::Create( newInitEventCode_57e9, SFC::UserCode::meta_codeexpr);
		SFC::Int newInt_57eb= SFC::Int::Create( newBinaryExprs_57ea, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_57ec= SFC::ArgDeclRef::Create( newBinaryExprs_57ea, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_57ec;
		SFC::BinaryExprs& BinaryExprs= newBinaryExprs_57ea;
		SFC::UserCode& InitEventCode= newInitEventCode_57e9;
		SFC::Int& Int= newInt_57eb;
		SFC::LocalVar& LocalVar= currMatch.localVar_57e4;
		SFC::Function& RootFunction= currMatch.rootFunction_57e2;
		CyberComposition::Simulink::SFEvent& SFEvent= currMatch.sFEvent_57e3;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_57e1;
		{
InitEventCode.RefId() = RootFunction.RefId();
};
		{
__int64 statementCount = RootFunction.statementCount();
InitEventCode.statementIndex() = statementCount++;
RootFunction.statementCount() = statementCount;
};
		{
Int.val() = 0;
};
		{
BinaryExprs.op() = "=";
};
		newArgDeclRef_57ec.argdecl()= currMatch.localVar_57e4;
	}
}

void CreateLEInit_57bc::forwardInputs()
{
	*_sFState_57c3= _sFState_57c5;
	*_rootFunction_57c4= _rootFunction_57ce;
}

void CreateIDArgs_57ed::operator()( const Packets_t& states_57ee, const Packets_t& rootFxns_57f0, Packets_t& states_57f2, Packets_t& rootFxns_57f3)
{
#ifdef PRINT_INFO
	printLog( "CreateIDArgs_57ed" );
#endif
	_state_57f4= &states_57f2;
	_rootFxn_57f5= &rootFxns_57f3;
	_state_57f4->insert( _state_57f4->end(), states_57ee.begin(), states_57ee.end());
	_rootFxn_57f5->insert( _rootFxn_57f5->end(), rootFxns_57f0.begin(), rootFxns_57f0.end());
	if( ( !states_57ee.empty())&& ( !rootFxns_57f0.empty()))
		callGetInData_5847( states_57ee, rootFxns_57f0);
}

void CreateIDArgs_57ed::callGetInData_5847( const Packets_t& sFStates_581d, const Packets_t& rootFunctions_581f)
{
	Packets_t sFDatas_581c;
	Packets_t rootFunctions_5821;
	GetInData_581b getInData_581b;
	getInData_581b( sFStates_581d, rootFunctions_581f, sFDatas_581c, rootFunctions_5821);
	if( ( !sFDatas_581c.empty())&& ( !rootFunctions_5821.empty()))
		callCreateIDArg_584a( sFDatas_581c, rootFunctions_5821);
}

void CreateIDArgs_57ed::callCreateIDArg_584a( const Packets_t& sFDatas_57f7, const Packets_t& rootFunctions_57f9)
{
	CreateIDArg_57f6 createIDArg_57f6;
	createIDArg_57f6( sFDatas_57f7, rootFunctions_57f9);
}

void CreateIDArg_57f6::operator()( const Packets_t& sFDatas_57f7, const Packets_t& rootFunctions_57f9)
{
#ifdef PRINT_INFO
	printLog( "CreateIDArg_57f6" );
#endif
	RTTGenerator::Instance()->generateRule(5195, "CreateIDArg");
	processInputPackets( sFDatas_57f7, rootFunctions_57f9);
}

bool CreateIDArg_57f6::isInputUnique( const Udm::Object& sFData_57ff, const Udm::Object& rootFunction_5808)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFData_5801= _sFData_57fb.begin(), itRootFunction_580a= _rootFunction_5804.begin(); itSFData_5801!= _sFData_57fb.end(), itRootFunction_580a!= _rootFunction_5804.end(); ++itSFData_5801, ++itRootFunction_580a)
	{
		if( ( *itSFData_5801== sFData_57ff)&& ( *itRootFunction_580a== rootFunction_5808))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFData_57fb.push_back( sFData_57ff);
		_rootFunction_5804.push_back( rootFunction_5808);
	}
	return isUnique;
}

bool CreateIDArg_57f6::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateIDArg_57f6::processInputPackets( const Packets_t& sFDatas_57f7, const Packets_t& rootFunctions_57f9)
{
	for( Packets_t::const_iterator itSFData_57fc= sFDatas_57f7.begin(), itRootFunction_5805= rootFunctions_57f9.begin(); itSFData_57fc!= sFDatas_57f7.end(), itRootFunction_5805!= rootFunctions_57f9.end(); ++itSFData_57fc, ++itRootFunction_5805)
	{
		bool isUnique= isInputUnique( *itSFData_57fc, *itRootFunction_5805);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFData_57fc, *itRootFunction_5805);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateIDArg_57f6::patternMatcher( const Udm::Object& sFData_57fd, const Udm::Object& rootFunction_5806)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFData_57fd.type(), CyberComposition::Simulink::SFData::meta))
			continue;
		CyberComposition::Simulink::SFData sFData_5802= CyberComposition::Simulink::SFData::Cast( sFData_57fd);
		if( false== Uml::IsDerivedFrom( rootFunction_5806.type(), SFC::Function::meta))
			continue;
		SFC::Function rootFunction_580b= SFC::Function::Cast( rootFunction_5806);
		set< SFC::LocalVar> localVars_580d= sFData_5802.src();
		for( set< SFC::LocalVar>::const_iterator itLocalVars_580e= localVars_580d.begin(); itLocalVars_580e!= localVars_580d.end(); ++itLocalVars_580e)
		{
			SFC::LocalVar currLocalVar_580f= *itLocalVars_580e;
			SFC::DT dT_5810= currLocalVar_580f.dt();
			if( !dT_5810)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_5814;
			if( !isValidBound(boundObjs_5814, sFData_5802, true))
				continue;
			currMatch.sFData_5815= sFData_5802;
			if( !isValidBound(boundObjs_5814, rootFunction_580b, true))
				continue;
			currMatch.rootFunction_5816= rootFunction_580b;
			if( !isValidBound(boundObjs_5814, currLocalVar_580f, false))
				continue;
			currMatch.localVar_5817= currLocalVar_580f;
			if( !isValidBound(boundObjs_5814, dT_5810, false))
				continue;
			currMatch.dT_5818= dT_5810;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateIDArg_57f6::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg newArg_5819= SFC::Arg::Create( currMatch.rootFunction_5816);
		SFC::SetVar newSetVar_581a= SFC::SetVar::Create( currMatch.rootFunction_5816);
		SFC::Arg& Arg= newArg_5819;
		SFC::DT& DT= currMatch.dT_5818;
		SFC::LocalVar& LocalVar= currMatch.localVar_5817;
		SFC::Function& RootFunction= currMatch.rootFunction_5816;
		CyberComposition::Simulink::SFData& SFData= currMatch.sFData_5815;
		SFC::SetVar& SetVar= newSetVar_581a;
		{
Arg.RefId() = SetVar.RefId() = LocalVar.RefId();
};
		{
Arg.name() = static_cast< std::string >( SFData.name() ) + "_";
Arg.indexBase() = SFData.ArrayFirstIndex();
};
		{
__int64 argCount = RootFunction.argCount();
Arg.argIndex() = argCount++;
RootFunction.argCount() = argCount;
};
		{
__int64 statementCount = RootFunction.statementCount();
SetVar.statementIndex() = statementCount++;
RootFunction.statementCount() = statementCount;
};
		newArg_5819.dt()= currMatch.dT_5818;
		newSetVar_581a.arg_end()= newArg_5819;
		newSetVar_581a.lvar_end()= currMatch.localVar_5817;
	}
}

void GetInData_581b::operator()( const Packets_t& sFStates_581d, const Packets_t& rootFunctions_581f, Packets_t& sFDatas_581c, Packets_t& rootFunctions_5821)
{
#ifdef PRINT_INFO
	printLog( "GetInData_581b" );
#endif
	RTTGenerator::Instance()->generateRule(5213, "GetInData");
	_sFData_5822= &sFDatas_581c;
	_rootFunction_5823= &rootFunctions_5821;
	processInputPackets( sFStates_581d, rootFunctions_581f);
	sortOutputs( );
}

bool GetInData_581b::isInputUnique( const Udm::Object& sFState_5828, const Udm::Object& rootFunction_5831)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_582a= _sFState_5824.begin(), itRootFunction_5833= _rootFunction_582d.begin(); itSFState_582a!= _sFState_5824.end(), itRootFunction_5833!= _rootFunction_582d.end(); ++itSFState_582a, ++itRootFunction_5833)
	{
		if( ( *itSFState_582a== sFState_5828)&& ( *itRootFunction_5833== rootFunction_5831))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_5824.push_back( sFState_5828);
		_rootFunction_582d.push_back( rootFunction_5831);
	}
	return isUnique;
}

bool GetInData_581b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool GetInData_581b::isGuardTrue( SFC::Function& RootFunction, CyberComposition::Simulink::SFData& SFData, CyberComposition::Simulink::SFState& SFState)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( SFData.Scope() ) == "INPUT_DATA";;
	return Gz_guard;
}

void GetInData_581b::processInputPackets( const Packets_t& sFStates_581d, const Packets_t& rootFunctions_581f)
{
	for( Packets_t::const_iterator itSFState_5825= sFStates_581d.begin(), itRootFunction_582e= rootFunctions_581f.begin(); itSFState_5825!= sFStates_581d.end(), itRootFunction_582e!= rootFunctions_581f.end(); ++itSFState_5825, ++itRootFunction_582e)
	{
		bool isUnique= isInputUnique( *itSFState_5825, *itRootFunction_582e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5825, *itRootFunction_582e);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetInData_581b::patternMatcher( const Udm::Object& sFState_5826, const Udm::Object& rootFunction_582f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5826.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_582b= CyberComposition::Simulink::SFState::Cast( sFState_5826);
		if( false== Uml::IsDerivedFrom( rootFunction_582f.type(), SFC::Function::meta))
			continue;
		SFC::Function rootFunction_5834= SFC::Function::Cast( rootFunction_582f);
		set< CyberComposition::Simulink::SFData> sFDatas_5836= sFState_582b.SFData_kind_children();
		for( set< CyberComposition::Simulink::SFData>::const_iterator itSFData_5837= sFDatas_5836.begin(); itSFData_5837!= sFDatas_5836.end(); ++itSFData_5837)
		{
			CyberComposition::Simulink::SFData currSFData_5838= *itSFData_5837;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_583c;
			if( !isValidBound(boundObjs_583c, sFState_582b, true))
				continue;
			currMatch.sFState_583d= sFState_582b;
			if( !isValidBound(boundObjs_583c, rootFunction_5834, true))
				continue;
			currMatch.rootFunction_583e= rootFunction_5834;
			if( !isValidBound(boundObjs_583c, currSFData_5838, false))
				continue;
			currMatch.sFData_583f= currSFData_5838;
			bool Gz_guard= isGuardTrue( currMatch.rootFunction_583e, currMatch.sFData_583f, currMatch.sFState_583d);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetInData_581b::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFData_583f, currMatch.rootFunction_583e);
	}
}

void GetInData_581b::outputAppender( const CyberComposition::Simulink::SFData& sFData_5843, const SFC::Function& rootFunction_5845)
{
	_sFData_5822->push_back( sFData_5843);
	_rootFunction_5823->push_back( rootFunction_5845);
}

void GetInData_581b::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::SFData, std::pointer_to_binary_function< const CyberComposition::Simulink::SFData&, const CyberComposition::Simulink::SFData&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::SFData&, const CyberComposition::Simulink::SFData&, bool> ptr_DEOrder( DEOrder< CyberComposition::Simulink::SFData>);
	SortedSet_t sortedSet( ptr_DEOrder);
	std::vector< int> permutationVector( _sFData_5822->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _sFData_5822->begin(); it!= _sFData_5822->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::SFData::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _sFData_5822->begin());
	// order rest of the containers
	permutate( permutationVector, *_rootFunction_5823);
}

void CreateIEArgs_584d::operator()( const Packets_t& states_584e, const Packets_t& rootFxns_5850, Packets_t& states_5852, Packets_t& rootFxns_5853)
{
#ifdef PRINT_INFO
	printLog( "CreateIEArgs_584d" );
#endif
	_state_5854= &states_5852;
	_rootFxn_5855= &rootFxns_5853;
	_state_5854->insert( _state_5854->end(), states_584e.begin(), states_584e.end());
	_rootFxn_5855->insert( _rootFxn_5855->end(), rootFxns_5850.begin(), rootFxns_5850.end());
	if( ( !states_584e.empty())&& ( !rootFxns_5850.empty()))
		callGetInEvent_58a7( states_584e, rootFxns_5850);
}

void CreateIEArgs_584d::callGetInEvent_58a7( const Packets_t& sFStates_587c, const Packets_t& rootFunctions_587f)
{
	Packets_t sFEvents_587e;
	Packets_t rootFunctions_5881;
	GetInEvent_587b getInEvent_587b;
	getInEvent_587b( sFStates_587c, rootFunctions_587f, sFEvents_587e, rootFunctions_5881);
	if( ( !sFEvents_587e.empty())&& ( !rootFunctions_5881.empty()))
		callCreateIEArg_58aa( sFEvents_587e, rootFunctions_5881);
}

void CreateIEArgs_584d::callCreateIEArg_58aa( const Packets_t& sFEvents_5857, const Packets_t& rootFunctions_5859)
{
	CreateIEArg_5856 createIEArg_5856;
	createIEArg_5856( sFEvents_5857, rootFunctions_5859);
}

void CreateIEArg_5856::operator()( const Packets_t& sFEvents_5857, const Packets_t& rootFunctions_5859)
{
#ifdef PRINT_INFO
	printLog( "CreateIEArg_5856" );
#endif
	RTTGenerator::Instance()->generateRule(5223, "CreateIEArg");
	processInputPackets( sFEvents_5857, rootFunctions_5859);
}

bool CreateIEArg_5856::isInputUnique( const Udm::Object& sFEvent_585f, const Udm::Object& rootFunction_5868)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFEvent_5861= _sFEvent_585b.begin(), itRootFunction_586a= _rootFunction_5864.begin(); itSFEvent_5861!= _sFEvent_585b.end(), itRootFunction_586a!= _rootFunction_5864.end(); ++itSFEvent_5861, ++itRootFunction_586a)
	{
		if( ( *itSFEvent_5861== sFEvent_585f)&& ( *itRootFunction_586a== rootFunction_5868))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFEvent_585b.push_back( sFEvent_585f);
		_rootFunction_5864.push_back( rootFunction_5868);
	}
	return isUnique;
}

bool CreateIEArg_5856::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateIEArg_5856::processInputPackets( const Packets_t& sFEvents_5857, const Packets_t& rootFunctions_5859)
{
	for( Packets_t::const_iterator itSFEvent_585c= sFEvents_5857.begin(), itRootFunction_5865= rootFunctions_5859.begin(); itSFEvent_585c!= sFEvents_5857.end(), itRootFunction_5865!= rootFunctions_5859.end(); ++itSFEvent_585c, ++itRootFunction_5865)
	{
		bool isUnique= isInputUnique( *itSFEvent_585c, *itRootFunction_5865);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFEvent_585c, *itRootFunction_5865);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateIEArg_5856::patternMatcher( const Udm::Object& sFEvent_585d, const Udm::Object& rootFunction_5866)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFEvent_585d.type(), CyberComposition::Simulink::SFEvent::meta))
			continue;
		CyberComposition::Simulink::SFEvent sFEvent_5862= CyberComposition::Simulink::SFEvent::Cast( sFEvent_585d);
		if( false== Uml::IsDerivedFrom( rootFunction_5866.type(), SFC::Function::meta))
			continue;
		SFC::Function rootFunction_586b= SFC::Function::Cast( rootFunction_5866);
		set< SFC::LocalVar> localVars_586d= sFEvent_5862.src();
		for( set< SFC::LocalVar>::const_iterator itLocalVars_586e= localVars_586d.begin(); itLocalVars_586e!= localVars_586d.end(); ++itLocalVars_586e)
		{
			SFC::LocalVar currLocalVar_586f= *itLocalVars_586e;
			SFC::DT dT_5870= currLocalVar_586f.dt();
			if( !dT_5870)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_5874;
			if( !isValidBound(boundObjs_5874, sFEvent_5862, true))
				continue;
			currMatch.sFEvent_5875= sFEvent_5862;
			if( !isValidBound(boundObjs_5874, rootFunction_586b, true))
				continue;
			currMatch.rootFunction_5876= rootFunction_586b;
			if( !isValidBound(boundObjs_5874, currLocalVar_586f, false))
				continue;
			currMatch.localVar_5877= currLocalVar_586f;
			if( !isValidBound(boundObjs_5874, dT_5870, false))
				continue;
			currMatch.dT_5878= dT_5870;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateIEArg_5856::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg newArg_5879= SFC::Arg::Create( currMatch.rootFunction_5876);
		SFC::SetVar newSetVar_587a= SFC::SetVar::Create( currMatch.rootFunction_5876);
		SFC::Arg& Arg= newArg_5879;
		SFC::DT& DT= currMatch.dT_5878;
		SFC::LocalVar& LocalVar= currMatch.localVar_5877;
		SFC::Function& RootFunction= currMatch.rootFunction_5876;
		CyberComposition::Simulink::SFEvent& SFEvent= currMatch.sFEvent_5875;
		SFC::SetVar& SetVar= newSetVar_587a;
		{
Arg.RefId() = SetVar.RefId() = LocalVar.RefId();
};
		{
Arg.name() = static_cast< std::string >( SFEvent.name() ) + "_";
};
		{
__int64 statementCount = RootFunction.statementCount();
SetVar.statementIndex() = statementCount++;
RootFunction.statementCount() = statementCount;
};
		{
__int64 argCount = RootFunction.argCount();
Arg.argIndex() = argCount++;
RootFunction.argCount() = argCount;
};
		newArg_5879.dt()= currMatch.dT_5878;
		newSetVar_587a.arg_end()= newArg_5879;
		newSetVar_587a.lvar_end()= currMatch.localVar_5877;
	}
}

void GetInEvent_587b::operator()( const Packets_t& sFStates_587c, const Packets_t& rootFunctions_587f, Packets_t& sFEvents_587e, Packets_t& rootFunctions_5881)
{
#ifdef PRINT_INFO
	printLog( "GetInEvent_587b" );
#endif
	RTTGenerator::Instance()->generateRule(5241, "GetInEvent");
	_sFEvent_5882= &sFEvents_587e;
	_rootFunction_5883= &rootFunctions_5881;
	processInputPackets( sFStates_587c, rootFunctions_587f);
	sortOutputs( );
}

bool GetInEvent_587b::isInputUnique( const Udm::Object& sFState_5888, const Udm::Object& rootFunction_5891)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_588a= _sFState_5884.begin(), itRootFunction_5893= _rootFunction_588d.begin(); itSFState_588a!= _sFState_5884.end(), itRootFunction_5893!= _rootFunction_588d.end(); ++itSFState_588a, ++itRootFunction_5893)
	{
		if( ( *itSFState_588a== sFState_5888)&& ( *itRootFunction_5893== rootFunction_5891))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_5884.push_back( sFState_5888);
		_rootFunction_588d.push_back( rootFunction_5891);
	}
	return isUnique;
}

bool GetInEvent_587b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool GetInEvent_587b::isGuardTrue( SFC::Function& RootFunction, CyberComposition::Simulink::SFEvent& SFEvent, CyberComposition::Simulink::SFState& SFState)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( SFEvent.Scope() ) == "INPUT_EVENT";;
	return Gz_guard;
}

void GetInEvent_587b::processInputPackets( const Packets_t& sFStates_587c, const Packets_t& rootFunctions_587f)
{
	for( Packets_t::const_iterator itSFState_5885= sFStates_587c.begin(), itRootFunction_588e= rootFunctions_587f.begin(); itSFState_5885!= sFStates_587c.end(), itRootFunction_588e!= rootFunctions_587f.end(); ++itSFState_5885, ++itRootFunction_588e)
	{
		bool isUnique= isInputUnique( *itSFState_5885, *itRootFunction_588e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5885, *itRootFunction_588e);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetInEvent_587b::patternMatcher( const Udm::Object& sFState_5886, const Udm::Object& rootFunction_588f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5886.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_588b= CyberComposition::Simulink::SFState::Cast( sFState_5886);
		if( false== Uml::IsDerivedFrom( rootFunction_588f.type(), SFC::Function::meta))
			continue;
		SFC::Function rootFunction_5894= SFC::Function::Cast( rootFunction_588f);
		set< CyberComposition::Simulink::SFEvent> sFEvents_5896= sFState_588b.SFEvent_kind_children();
		for( set< CyberComposition::Simulink::SFEvent>::const_iterator itSFEvent_5897= sFEvents_5896.begin(); itSFEvent_5897!= sFEvents_5896.end(); ++itSFEvent_5897)
		{
			CyberComposition::Simulink::SFEvent currSFEvent_5898= *itSFEvent_5897;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_589c;
			if( !isValidBound(boundObjs_589c, sFState_588b, true))
				continue;
			currMatch.sFState_589d= sFState_588b;
			if( !isValidBound(boundObjs_589c, rootFunction_5894, true))
				continue;
			currMatch.rootFunction_589e= rootFunction_5894;
			if( !isValidBound(boundObjs_589c, currSFEvent_5898, false))
				continue;
			currMatch.sFEvent_589f= currSFEvent_5898;
			bool Gz_guard= isGuardTrue( currMatch.rootFunction_589e, currMatch.sFEvent_589f, currMatch.sFState_589d);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetInEvent_587b::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFEvent_589f, currMatch.rootFunction_589e);
	}
}

void GetInEvent_587b::outputAppender( const CyberComposition::Simulink::SFEvent& sFEvent_58a3, const SFC::Function& rootFunction_58a5)
{
	_sFEvent_5882->push_back( sFEvent_58a3);
	_rootFunction_5883->push_back( rootFunction_58a5);
}

void GetInEvent_587b::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::SFEvent, std::pointer_to_binary_function< const CyberComposition::Simulink::SFEvent&, const CyberComposition::Simulink::SFEvent&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::SFEvent&, const CyberComposition::Simulink::SFEvent&, bool> ptr_DEOrder( DEOrder< CyberComposition::Simulink::SFEvent>);
	SortedSet_t sortedSet( ptr_DEOrder);
	std::vector< int> permutationVector( _sFEvent_5882->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _sFEvent_5882->begin(); it!= _sFEvent_5882->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::SFEvent::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _sFEvent_5882->begin());
	// order rest of the containers
	permutate( permutationVector, *_rootFunction_5883);
}

void CreateOutputArgs_58bc::operator()( const Packets_t& states_58bd, const Packets_t& rootFxns_58bf, Packets_t& states_58c1, Packets_t& rootFxns_58c2)
{
#ifdef PRINT_INFO
	printLog( "CreateOutputArgs_58bc" );
#endif
	_state_58c3= &states_58c1;
	_rootFxn_58c4= &rootFxns_58c2;
	_state_58c3->insert( _state_58c3->end(), states_58bd.begin(), states_58bd.end());
	_rootFxn_58c4->insert( _rootFxn_58c4->end(), rootFxns_58bf.begin(), rootFxns_58bf.end());
	if( ( !states_58bd.empty())&& ( !rootFxns_58bf.empty()))
		callCheckStateDecomp_5985( states_58bd, rootFxns_58bf);
}

void CreateOutputArgs_58bc::callCheckStateDecomp_5985( const Packets_t& states_47be, const Packets_t& programs_47c0)
{
	Packets_t states_47c2;
	Packets_t programs_47c3;
	Packets_t states_47c4;
	Packets_t programs_47c5;
	CheckStateDecomp_47bd checkStateDecomp_47bd;
	checkStateDecomp_47bd( states_47be, programs_47c0, states_47c2, programs_47c3, states_47c4, programs_47c5);
	if( ( !states_47c2.empty())&& ( !programs_47c3.empty()))
		callGetSubStates_5988( states_47c2, programs_47c3);
	if( ( !states_47c4.empty())&& ( !programs_47c5.empty()))
		callCreateODArgs_598b( states_47c4, programs_47c5);
}

void CreateOutputArgs_58bc::callGetSubStates_5988( const Packets_t& sFStates_4223, const Packets_t& parStmnts_4226)
{
	Packets_t sFSubStates_4225;
	Packets_t parStmnts_4228;
	GetSubStates_4222 getSubStates_4222;
	getSubStates_4222( sFStates_4223, parStmnts_4226, sFSubStates_4225, parStmnts_4228);
	if( ( !sFSubStates_4225.empty())&& ( !parStmnts_4228.empty()))
		callCheckStateDecomp_5985( sFSubStates_4225, parStmnts_4228);
}

void CreateOutputArgs_58bc::callCreateODArgs_598b( const Packets_t& states_58c6, const Packets_t& rootFxns_58c8)
{
	Packets_t states_58ca;
	Packets_t rootFxns_58cb;
	CreateODArgs_58c5 createODArgs_58c5;
	createODArgs_58c5( states_58c6, rootFxns_58c8, states_58ca, rootFxns_58cb);
	if( ( !states_58ca.empty())&& ( !rootFxns_58cb.empty()))
		callCreateOEArgs_598e( states_58ca, rootFxns_58cb);
}

void CreateOutputArgs_58bc::callCreateOEArgs_598e( const Packets_t& states_5926, const Packets_t& rootFxns_5928)
{
	Packets_t states_592a;
	Packets_t rootFxns_592b;
	CreateOEArgs_5925 createOEArgs_5925;
	createOEArgs_5925( states_5926, rootFxns_5928, states_592a, rootFxns_592b);
	if( ( !states_592a.empty())&& ( !rootFxns_592b.empty()))
		callGetSubStates_5988( states_592a, rootFxns_592b);
}

void CreateODArgs_58c5::operator()( const Packets_t& states_58c6, const Packets_t& rootFxns_58c8, Packets_t& states_58ca, Packets_t& rootFxns_58cb)
{
#ifdef PRINT_INFO
	printLog( "CreateODArgs_58c5" );
#endif
	_state_58cc= &states_58ca;
	_rootFxn_58cd= &rootFxns_58cb;
	_state_58cc->insert( _state_58cc->end(), states_58c6.begin(), states_58c6.end());
	_rootFxn_58cd->insert( _rootFxn_58cd->end(), rootFxns_58c8.begin(), rootFxns_58c8.end());
	if( ( !states_58c6.empty())&& ( !rootFxns_58c8.empty()))
		callGetOutData_591f( states_58c6, rootFxns_58c8);
}

void CreateODArgs_58c5::callGetOutData_591f( const Packets_t& sFStates_58d0, const Packets_t& rootFunctions_58d2)
{
	Packets_t sFDatas_58cf;
	Packets_t rootFunctions_58d4;
	GetOutData_58ce getOutData_58ce;
	getOutData_58ce( sFStates_58d0, rootFunctions_58d2, sFDatas_58cf, rootFunctions_58d4);
	if( ( !sFDatas_58cf.empty())&& ( !rootFunctions_58d4.empty()))
		callCreateODArg_5922( sFDatas_58cf, rootFunctions_58d4);
}

void CreateODArgs_58c5::callCreateODArg_5922( const Packets_t& sFDatas_58fb, const Packets_t& rootFunctions_58fd)
{
	CreateODArg_58fa createODArg_58fa;
	createODArg_58fa( sFDatas_58fb, rootFunctions_58fd);
}

void GetOutData_58ce::operator()( const Packets_t& sFStates_58d0, const Packets_t& rootFunctions_58d2, Packets_t& sFDatas_58cf, Packets_t& rootFunctions_58d4)
{
#ifdef PRINT_INFO
	printLog( "GetOutData_58ce" );
#endif
	RTTGenerator::Instance()->generateRule(5256, "GetOutData");
	_sFData_58d5= &sFDatas_58cf;
	_rootFunction_58d6= &rootFunctions_58d4;
	processInputPackets( sFStates_58d0, rootFunctions_58d2);
	sortOutputs( );
}

bool GetOutData_58ce::isInputUnique( const Udm::Object& sFState_58db, const Udm::Object& rootFunction_58e4)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_58dd= _sFState_58d7.begin(), itRootFunction_58e6= _rootFunction_58e0.begin(); itSFState_58dd!= _sFState_58d7.end(), itRootFunction_58e6!= _rootFunction_58e0.end(); ++itSFState_58dd, ++itRootFunction_58e6)
	{
		if( ( *itSFState_58dd== sFState_58db)&& ( *itRootFunction_58e6== rootFunction_58e4))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_58d7.push_back( sFState_58db);
		_rootFunction_58e0.push_back( rootFunction_58e4);
	}
	return isUnique;
}

bool GetOutData_58ce::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool GetOutData_58ce::isGuardTrue( SFC::Function& RootFunction, CyberComposition::Simulink::SFData& SFData, CyberComposition::Simulink::SFState& SFState)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( SFData.Scope() ) == "OUTPUT_DATA";;
	return Gz_guard;
}

void GetOutData_58ce::processInputPackets( const Packets_t& sFStates_58d0, const Packets_t& rootFunctions_58d2)
{
	for( Packets_t::const_iterator itSFState_58d8= sFStates_58d0.begin(), itRootFunction_58e1= rootFunctions_58d2.begin(); itSFState_58d8!= sFStates_58d0.end(), itRootFunction_58e1!= rootFunctions_58d2.end(); ++itSFState_58d8, ++itRootFunction_58e1)
	{
		bool isUnique= isInputUnique( *itSFState_58d8, *itRootFunction_58e1);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_58d8, *itRootFunction_58e1);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetOutData_58ce::patternMatcher( const Udm::Object& sFState_58d9, const Udm::Object& rootFunction_58e2)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_58d9.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_58de= CyberComposition::Simulink::SFState::Cast( sFState_58d9);
		if( false== Uml::IsDerivedFrom( rootFunction_58e2.type(), SFC::Function::meta))
			continue;
		SFC::Function rootFunction_58e7= SFC::Function::Cast( rootFunction_58e2);
		set< CyberComposition::Simulink::SFData> sFDatas_58e9= sFState_58de.SFData_kind_children();
		for( set< CyberComposition::Simulink::SFData>::const_iterator itSFData_58ea= sFDatas_58e9.begin(); itSFData_58ea!= sFDatas_58e9.end(); ++itSFData_58ea)
		{
			CyberComposition::Simulink::SFData currSFData_58eb= *itSFData_58ea;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_58ef;
			if( !isValidBound(boundObjs_58ef, sFState_58de, true))
				continue;
			currMatch.sFState_58f0= sFState_58de;
			if( !isValidBound(boundObjs_58ef, rootFunction_58e7, true))
				continue;
			currMatch.rootFunction_58f1= rootFunction_58e7;
			if( !isValidBound(boundObjs_58ef, currSFData_58eb, false))
				continue;
			currMatch.sFData_58f2= currSFData_58eb;
			bool Gz_guard= isGuardTrue( currMatch.rootFunction_58f1, currMatch.sFData_58f2, currMatch.sFState_58f0);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetOutData_58ce::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFData_58f2, currMatch.rootFunction_58f1);
	}
}

void GetOutData_58ce::outputAppender( const CyberComposition::Simulink::SFData& sFData_58f6, const SFC::Function& rootFunction_58f8)
{
	_sFData_58d5->push_back( sFData_58f6);
	_rootFunction_58d6->push_back( rootFunction_58f8);
}

void GetOutData_58ce::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::SFData, std::pointer_to_binary_function< const CyberComposition::Simulink::SFData&, const CyberComposition::Simulink::SFData&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::SFData&, const CyberComposition::Simulink::SFData&, bool> ptr_DEOrder( DEOrder< CyberComposition::Simulink::SFData>);
	SortedSet_t sortedSet( ptr_DEOrder);
	std::vector< int> permutationVector( _sFData_58d5->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _sFData_58d5->begin(); it!= _sFData_58d5->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::SFData::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _sFData_58d5->begin());
	// order rest of the containers
	permutate( permutationVector, *_rootFunction_58d6);
}

void CreateODArg_58fa::operator()( const Packets_t& sFDatas_58fb, const Packets_t& rootFunctions_58fd)
{
#ifdef PRINT_INFO
	printLog( "CreateODArg_58fa" );
#endif
	RTTGenerator::Instance()->generateRule(5261, "CreateODArg");
	processInputPackets( sFDatas_58fb, rootFunctions_58fd);
}

bool CreateODArg_58fa::isInputUnique( const Udm::Object& sFData_5903, const Udm::Object& rootFunction_590c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFData_5905= _sFData_58ff.begin(), itRootFunction_590e= _rootFunction_5908.begin(); itSFData_5905!= _sFData_58ff.end(), itRootFunction_590e!= _rootFunction_5908.end(); ++itSFData_5905, ++itRootFunction_590e)
	{
		if( ( *itSFData_5905== sFData_5903)&& ( *itRootFunction_590e== rootFunction_590c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFData_58ff.push_back( sFData_5903);
		_rootFunction_5908.push_back( rootFunction_590c);
	}
	return isUnique;
}

bool CreateODArg_58fa::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateODArg_58fa::processInputPackets( const Packets_t& sFDatas_58fb, const Packets_t& rootFunctions_58fd)
{
	for( Packets_t::const_iterator itSFData_5900= sFDatas_58fb.begin(), itRootFunction_5909= rootFunctions_58fd.begin(); itSFData_5900!= sFDatas_58fb.end(), itRootFunction_5909!= rootFunctions_58fd.end(); ++itSFData_5900, ++itRootFunction_5909)
	{
		bool isUnique= isInputUnique( *itSFData_5900, *itRootFunction_5909);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFData_5900, *itRootFunction_5909);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateODArg_58fa::patternMatcher( const Udm::Object& sFData_5901, const Udm::Object& rootFunction_590a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFData_5901.type(), CyberComposition::Simulink::SFData::meta))
			continue;
		CyberComposition::Simulink::SFData sFData_5906= CyberComposition::Simulink::SFData::Cast( sFData_5901);
		if( false== Uml::IsDerivedFrom( rootFunction_590a.type(), SFC::Function::meta))
			continue;
		SFC::Function rootFunction_590f= SFC::Function::Cast( rootFunction_590a);
		set< SFC::LocalVar> localVars_5911= sFData_5906.src();
		for( set< SFC::LocalVar>::const_iterator itLocalVars_5912= localVars_5911.begin(); itLocalVars_5912!= localVars_5911.end(); ++itLocalVars_5912)
		{
			SFC::LocalVar currLocalVar_5913= *itLocalVars_5912;
			SFC::DT dT_5914= currLocalVar_5913.dt();
			if( !dT_5914)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_5918;
			if( !isValidBound(boundObjs_5918, sFData_5906, true))
				continue;
			currMatch.sFData_5919= sFData_5906;
			if( !isValidBound(boundObjs_5918, rootFunction_590f, true))
				continue;
			currMatch.rootFunction_591a= rootFunction_590f;
			if( !isValidBound(boundObjs_5918, currLocalVar_5913, false))
				continue;
			currMatch.localVar_591b= currLocalVar_5913;
			if( !isValidBound(boundObjs_5918, dT_5914, false))
				continue;
			currMatch.dT_591c= dT_5914;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateODArg_58fa::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::SetVar newSetVar_591d= SFC::SetVar::Create( currMatch.rootFunction_591a);
		SFC::Arg newArg_591e= SFC::Arg::Create( currMatch.rootFunction_591a);
		SFC::Arg& Arg= newArg_591e;
		SFC::DT& DT= currMatch.dT_591c;
		SFC::LocalVar& LocalVar= currMatch.localVar_591b;
		SFC::Function& RootFunction= currMatch.rootFunction_591a;
		CyberComposition::Simulink::SFData& SFData= currMatch.sFData_5919;
		SFC::SetVar& SetVar= newSetVar_591d;
		{
Arg.RefId() = SetVar.RefId() = LocalVar.RefId();
};
		{
__int64 statementCount = RootFunction.statementCount();
SetVar.statementIndex() = statementCount++;
RootFunction.statementCount() = statementCount;
};
		{
__int64 argCount = RootFunction.argCount();
Arg.argIndex() = argCount++;
RootFunction.argCount() = argCount;
};
		{
Arg.name() = static_cast< std::string >( SFData.name() ) + "_";
Arg.indexBase() = SFData.ArrayFirstIndex();
Arg.ptr() = true;
};
		{
SetVar.invert() = true;
};
		newArg_591e.dt()= currMatch.dT_591c;
		newSetVar_591d.arg_end()= newArg_591e;
		newSetVar_591d.lvar_end()= currMatch.localVar_591b;
	}
}

void CreateOEArgs_5925::operator()( const Packets_t& states_5926, const Packets_t& rootFxns_5928, Packets_t& states_592a, Packets_t& rootFxns_592b)
{
#ifdef PRINT_INFO
	printLog( "CreateOEArgs_5925" );
#endif
	_state_592c= &states_592a;
	_rootFxn_592d= &rootFxns_592b;
	_state_592c->insert( _state_592c->end(), states_5926.begin(), states_5926.end());
	_rootFxn_592d->insert( _rootFxn_592d->end(), rootFxns_5928.begin(), rootFxns_5928.end());
	if( ( !states_5926.empty())&& ( !rootFxns_5928.empty()))
		callGetOutEvent_597f( states_5926, rootFxns_5928);
}

void CreateOEArgs_5925::callGetOutEvent_597f( const Packets_t& sFStates_592f, const Packets_t& rootFunctions_5932)
{
	Packets_t sFEvents_5931;
	Packets_t rootFunctions_5934;
	GetOutEvent_592e getOutEvent_592e;
	getOutEvent_592e( sFStates_592f, rootFunctions_5932, sFEvents_5931, rootFunctions_5934);
	if( ( !sFEvents_5931.empty())&& ( !rootFunctions_5934.empty()))
		callCreateOEArg_5982( sFEvents_5931, rootFunctions_5934);
}

void CreateOEArgs_5925::callCreateOEArg_5982( const Packets_t& sFEvents_595b, const Packets_t& rootFunctions_595d)
{
	CreateOEArg_595a createOEArg_595a;
	createOEArg_595a( sFEvents_595b, rootFunctions_595d);
}

void GetOutEvent_592e::operator()( const Packets_t& sFStates_592f, const Packets_t& rootFunctions_5932, Packets_t& sFEvents_5931, Packets_t& rootFunctions_5934)
{
#ifdef PRINT_INFO
	printLog( "GetOutEvent_592e" );
#endif
	RTTGenerator::Instance()->generateRule(5285, "GetOutEvent");
	_sFEvent_5935= &sFEvents_5931;
	_rootFunction_5936= &rootFunctions_5934;
	processInputPackets( sFStates_592f, rootFunctions_5932);
	sortOutputs( );
}

bool GetOutEvent_592e::isInputUnique( const Udm::Object& sFState_593b, const Udm::Object& rootFunction_5944)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_593d= _sFState_5937.begin(), itRootFunction_5946= _rootFunction_5940.begin(); itSFState_593d!= _sFState_5937.end(), itRootFunction_5946!= _rootFunction_5940.end(); ++itSFState_593d, ++itRootFunction_5946)
	{
		if( ( *itSFState_593d== sFState_593b)&& ( *itRootFunction_5946== rootFunction_5944))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_5937.push_back( sFState_593b);
		_rootFunction_5940.push_back( rootFunction_5944);
	}
	return isUnique;
}

bool GetOutEvent_592e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool GetOutEvent_592e::isGuardTrue( SFC::Function& RootFunction, CyberComposition::Simulink::SFEvent& SFEvent, CyberComposition::Simulink::SFState& SFState)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( SFEvent.Scope() ) == "OUTPUT_EVENT";;
	return Gz_guard;
}

void GetOutEvent_592e::processInputPackets( const Packets_t& sFStates_592f, const Packets_t& rootFunctions_5932)
{
	for( Packets_t::const_iterator itSFState_5938= sFStates_592f.begin(), itRootFunction_5941= rootFunctions_5932.begin(); itSFState_5938!= sFStates_592f.end(), itRootFunction_5941!= rootFunctions_5932.end(); ++itSFState_5938, ++itRootFunction_5941)
	{
		bool isUnique= isInputUnique( *itSFState_5938, *itRootFunction_5941);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5938, *itRootFunction_5941);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetOutEvent_592e::patternMatcher( const Udm::Object& sFState_5939, const Udm::Object& rootFunction_5942)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5939.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_593e= CyberComposition::Simulink::SFState::Cast( sFState_5939);
		if( false== Uml::IsDerivedFrom( rootFunction_5942.type(), SFC::Function::meta))
			continue;
		SFC::Function rootFunction_5947= SFC::Function::Cast( rootFunction_5942);
		set< CyberComposition::Simulink::SFEvent> sFEvents_5949= sFState_593e.SFEvent_kind_children();
		for( set< CyberComposition::Simulink::SFEvent>::const_iterator itSFEvent_594a= sFEvents_5949.begin(); itSFEvent_594a!= sFEvents_5949.end(); ++itSFEvent_594a)
		{
			CyberComposition::Simulink::SFEvent currSFEvent_594b= *itSFEvent_594a;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_594f;
			if( !isValidBound(boundObjs_594f, sFState_593e, true))
				continue;
			currMatch.sFState_5950= sFState_593e;
			if( !isValidBound(boundObjs_594f, rootFunction_5947, true))
				continue;
			currMatch.rootFunction_5951= rootFunction_5947;
			if( !isValidBound(boundObjs_594f, currSFEvent_594b, false))
				continue;
			currMatch.sFEvent_5952= currSFEvent_594b;
			bool Gz_guard= isGuardTrue( currMatch.rootFunction_5951, currMatch.sFEvent_5952, currMatch.sFState_5950);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetOutEvent_592e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFEvent_5952, currMatch.rootFunction_5951);
	}
}

void GetOutEvent_592e::outputAppender( const CyberComposition::Simulink::SFEvent& sFEvent_5956, const SFC::Function& rootFunction_5958)
{
	_sFEvent_5935->push_back( sFEvent_5956);
	_rootFunction_5936->push_back( rootFunction_5958);
}

void GetOutEvent_592e::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::SFEvent, std::pointer_to_binary_function< const CyberComposition::Simulink::SFEvent&, const CyberComposition::Simulink::SFEvent&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::SFEvent&, const CyberComposition::Simulink::SFEvent&, bool> ptr_DEOrder( DEOrder< CyberComposition::Simulink::SFEvent>);
	SortedSet_t sortedSet( ptr_DEOrder);
	std::vector< int> permutationVector( _sFEvent_5935->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _sFEvent_5935->begin(); it!= _sFEvent_5935->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::SFEvent::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _sFEvent_5935->begin());
	// order rest of the containers
	permutate( permutationVector, *_rootFunction_5936);
}

void CreateOEArg_595a::operator()( const Packets_t& sFEvents_595b, const Packets_t& rootFunctions_595d)
{
#ifdef PRINT_INFO
	printLog( "CreateOEArg_595a" );
#endif
	RTTGenerator::Instance()->generateRule(5290, "CreateOEArg");
	processInputPackets( sFEvents_595b, rootFunctions_595d);
}

bool CreateOEArg_595a::isInputUnique( const Udm::Object& sFEvent_5963, const Udm::Object& rootFunction_596c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFEvent_5965= _sFEvent_595f.begin(), itRootFunction_596e= _rootFunction_5968.begin(); itSFEvent_5965!= _sFEvent_595f.end(), itRootFunction_596e!= _rootFunction_5968.end(); ++itSFEvent_5965, ++itRootFunction_596e)
	{
		if( ( *itSFEvent_5965== sFEvent_5963)&& ( *itRootFunction_596e== rootFunction_596c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFEvent_595f.push_back( sFEvent_5963);
		_rootFunction_5968.push_back( rootFunction_596c);
	}
	return isUnique;
}

bool CreateOEArg_595a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateOEArg_595a::processInputPackets( const Packets_t& sFEvents_595b, const Packets_t& rootFunctions_595d)
{
	for( Packets_t::const_iterator itSFEvent_5960= sFEvents_595b.begin(), itRootFunction_5969= rootFunctions_595d.begin(); itSFEvent_5960!= sFEvents_595b.end(), itRootFunction_5969!= rootFunctions_595d.end(); ++itSFEvent_5960, ++itRootFunction_5969)
	{
		bool isUnique= isInputUnique( *itSFEvent_5960, *itRootFunction_5969);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFEvent_5960, *itRootFunction_5969);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateOEArg_595a::patternMatcher( const Udm::Object& sFEvent_5961, const Udm::Object& rootFunction_596a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFEvent_5961.type(), CyberComposition::Simulink::SFEvent::meta))
			continue;
		CyberComposition::Simulink::SFEvent sFEvent_5966= CyberComposition::Simulink::SFEvent::Cast( sFEvent_5961);
		if( false== Uml::IsDerivedFrom( rootFunction_596a.type(), SFC::Function::meta))
			continue;
		SFC::Function rootFunction_596f= SFC::Function::Cast( rootFunction_596a);
		set< SFC::LocalVar> localVars_5971= sFEvent_5966.src();
		for( set< SFC::LocalVar>::const_iterator itLocalVars_5972= localVars_5971.begin(); itLocalVars_5972!= localVars_5971.end(); ++itLocalVars_5972)
		{
			SFC::LocalVar currLocalVar_5973= *itLocalVars_5972;
			SFC::DT dT_5974= currLocalVar_5973.dt();
			if( !dT_5974)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_5978;
			if( !isValidBound(boundObjs_5978, sFEvent_5966, true))
				continue;
			currMatch.sFEvent_5979= sFEvent_5966;
			if( !isValidBound(boundObjs_5978, rootFunction_596f, true))
				continue;
			currMatch.rootFunction_597a= rootFunction_596f;
			if( !isValidBound(boundObjs_5978, currLocalVar_5973, false))
				continue;
			currMatch.localVar_597b= currLocalVar_5973;
			if( !isValidBound(boundObjs_5978, dT_5974, false))
				continue;
			currMatch.dT_597c= dT_5974;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateOEArg_595a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::SetVar newSetVar_597d= SFC::SetVar::Create( currMatch.rootFunction_597a);
		SFC::Arg newArg_597e= SFC::Arg::Create( currMatch.rootFunction_597a);
		SFC::Arg& Arg= newArg_597e;
		SFC::DT& DT= currMatch.dT_597c;
		SFC::LocalVar& LocalVar= currMatch.localVar_597b;
		SFC::Function& RootFunction= currMatch.rootFunction_597a;
		CyberComposition::Simulink::SFEvent& SFEvent= currMatch.sFEvent_5979;
		SFC::SetVar& SetVar= newSetVar_597d;
		{
Arg.RefId() = SetVar.RefId() = LocalVar.RefId();
};
		{
__int64 argCount = RootFunction.argCount();
Arg.argIndex() = argCount++;
RootFunction.argCount() = argCount;
};
		{
__int64 statementCount = RootFunction.statementCount();
SetVar.statementIndex() = statementCount++;
RootFunction.statementCount() = statementCount;
};
		{
Arg.name() = static_cast< std::string >( SFEvent.name() ) + "_";
Arg.ptr() = true;
};
		{
SetVar.invert() = true;
};
		newArg_597e.dt()= currMatch.dT_597c;
		newSetVar_597d.arg_end()= newArg_597e;
		newSetVar_597d.lvar_end()= currMatch.localVar_597b;
	}
}

void CreateInitFunction_599d::operator()( const Packets_t& states_599e, const Packets_t& programs_59a0, Packets_t& states_59a2, Packets_t& programs_59a3)
{
#ifdef PRINT_INFO
	printLog( "CreateInitFunction_599d" );
#endif
	_state_59a4= &states_59a2;
	_program_59a5= &programs_59a3;
	_state_59a4->insert( _state_59a4->end(), states_599e.begin(), states_599e.end());
	_program_59a5->insert( _program_59a5->end(), programs_59a0.begin(), programs_59a0.end());
	if( ( !states_599e.empty())&& ( !programs_59a0.empty()))
		callCreateInitFunction_5bc6( states_599e, programs_59a0);
}

void CreateInitFunction_599d::callCreateInitFunction_5bc6( const Packets_t& sFStates_5a45, const Packets_t& programs_5a48)
{
	Packets_t sFStates_5a47;
	Packets_t programs_5a4a;
	Packets_t initFunctions_5a4b;
	Packets_t initIdxs_5a4c;
	CreateInitFunction_5a44 createInitFunction_5a44;
	createInitFunction_5a44( sFStates_5a45, programs_5a48, sFStates_5a47, programs_5a4a, initFunctions_5a4b, initIdxs_5a4c);
	if( ( !sFStates_5a47.empty())&& ( !programs_5a4a.empty())&& ( !initFunctions_5a4b.empty())&& ( !initIdxs_5a4c.empty()))
		callInitLocalVars_5bc9( sFStates_5a47, programs_5a4a, initFunctions_5a4b, initIdxs_5a4c);
}

void CreateInitFunction_599d::callInitLocalVars_5bc9( const Packets_t& states_5a78, const Packets_t& programs_5a7a, const Packets_t& initFns_5a7c, const Packets_t& initIdxs_5a7e)
{
	Packets_t states_5a80;
	Packets_t initfns_5a81;
	InitLocalVars_5a77 initLocalVars_5a77;
	initLocalVars_5a77( states_5a78, programs_5a7a, initFns_5a7c, initIdxs_5a7e, states_5a80, initfns_5a81);
	if( ( !states_5a80.empty())&& ( !initfns_5a81.empty()))
		callTestEAIOn_5bce( states_5a80, initfns_5a81);
}

void CreateInitFunction_599d::callTestEAIOn_5bce( const Packets_t& states_59a7, const Packets_t& initfns_59a9)
{
	Packets_t states_59ab;
	Packets_t initfns_59ac;
	TestEAIOn_59a6 testEAIOn_59a6;
	testEAIOn_59a6( states_59a7, initfns_59a9, states_59ab, initfns_59ac);
	if( ( !states_59ab.empty())&& ( !initfns_59ac.empty()))
		callCreateFunction_FunctionCall_5bd1( states_59ab, initfns_59ac);
}

void CreateInitFunction_599d::callCreateFunction_FunctionCall_5bd1( const Packets_t& sFStates_59ee, const Packets_t& initFns_59f1)
{
	Packets_t enters_59f0;
	Packets_t functionCalls_59f3;
	CreateFunction_FunctionCall_59ed createFunction_FunctionCall_59ed;
	createFunction_FunctionCall_59ed( sFStates_59ee, initFns_59f1, enters_59f0, functionCalls_59f3);
	if( ( !enters_59f0.empty())&& ( !functionCalls_59f3.empty()))
		callFunctionCall_Vals_5bd4( enters_59f0, functionCalls_59f3);
}

void CreateInitFunction_599d::callFunctionCall_Vals_5bd4( const Packets_t& enters_5a18, const Packets_t& functionCalls_5a1a)
{
	FunctionCall_Vals_5a17 functionCall_Vals_5a17;
	functionCall_Vals_5a17( enters_5a18, functionCalls_5a1a);
}

void TestEAIOn_59a6::operator()( const Packets_t& states_59a7, const Packets_t& initfns_59a9, Packets_t& states_59ab, Packets_t& initfns_59ac)
{
#ifdef PRINT_INFO
	printLog( "TestEAIOn_59a6" );
#endif
	_state_59ad= &states_59ab;
	_initfn_59ae= &initfns_59ac;
	for( Packets_t::const_iterator itstate_59b0= states_59a7.begin(), itinitfn_59b7= initfns_59a9.begin(); itstate_59b0!= states_59a7.end(), itinitfn_59b7!= initfns_59a9.end(); ++itstate_59b0, ++itinitfn_59b7)
	{
		bool isUnique= isInputUnique( *itstate_59b0, *itinitfn_59b7);
		if( !isUnique)
			continue;
		Packets_t onestate_59b4( 1, *itstate_59b0);
		Packets_t oneinitfn_59bb( 1, *itinitfn_59b7);
		executeOne( onestate_59b4, oneinitfn_59bb);
	}
}

void TestEAIOn_59a6::executeOne( const Packets_t& states_59a7, const Packets_t& initfns_59a9)
{
	Packets_t sFStates_59c0;
	Packets_t initFns_59c3;
	EAIOn_59bd eAIOn_59bd;
	bool isMatchEAIOn_59bd= eAIOn_59bd( states_59a7, initfns_59a9, sFStates_59c0, initFns_59c3);
	_state_59ad->insert( _state_59ad->end(), sFStates_59c0.begin(), sFStates_59c0.end());
	_initfn_59ae->insert( _initfn_59ae->end(), initFns_59c3.begin(), initFns_59c3.end());
}

bool TestEAIOn_59a6::isInputUnique( const Udm::Object& state_59b1, const Udm::Object& initfn_59b8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstate_59b3= _state_59af.begin(), itinitfn_59ba= _initfn_59b6.begin(); itstate_59b3!= _state_59af.end(), itinitfn_59ba!= _initfn_59b6.end(); ++itstate_59b3, ++itinitfn_59ba)
	{
		if( ( *itstate_59b3== state_59b1)&& ( *itinitfn_59ba== initfn_59b8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_59af.push_back( state_59b1);
		_initfn_59b6.push_back( initfn_59b8);
	}
	return isUnique;
}

bool EAIOn_59bd::operator()( const Packets_t& sFStates_59be, const Packets_t& initFns_59c1, Packets_t& sFStates_59c0, Packets_t& initFns_59c3)
{
#ifdef PRINT_INFO
	printLog( "EAIOn_59bd" );
#endif
	_sFState_59c4= &sFStates_59c0;
	_initFn_59c5= &initFns_59c3;
	processInputPackets( sFStates_59be, initFns_59c1);
	if( false== _matches.empty())
		return true;
	return false;
}

bool EAIOn_59bd::isInputUnique( const Udm::Object& sFState_59ca, const Udm::Object& initFn_59d3)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_59cc= _sFState_59c6.begin(), itInitFn_59d5= _initFn_59cf.begin(); itSFState_59cc!= _sFState_59c6.end(), itInitFn_59d5!= _initFn_59cf.end(); ++itSFState_59cc, ++itInitFn_59d5)
	{
		if( ( *itSFState_59cc== sFState_59ca)&& ( *itInitFn_59d5== initFn_59d3))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_59c6.push_back( sFState_59ca);
		_initFn_59cf.push_back( initFn_59d3);
	}
	return isUnique;
}

bool EAIOn_59bd::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool EAIOn_59bd::isGuardTrue( SFC::Function& InitFn, CyberComposition::Simulink::SF_Parameter& Parameter, CyberComposition::Simulink::SFState& SFState, CyberComposition::Simulink::Subsystem& Subsystem)
{
	bool Gz_guard= false;
	return static_cast< std::string >( Parameter.name() ) == "ExecuteAtInitialization" &&
 static_cast< std::string >(  Parameter.Value() ) == "on";;
	return Gz_guard;
}

void EAIOn_59bd::processInputPackets( const Packets_t& sFStates_59be, const Packets_t& initFns_59c1)
{
	for( Packets_t::const_iterator itSFState_59c7= sFStates_59be.begin(), itInitFn_59d0= initFns_59c1.begin(); itSFState_59c7!= sFStates_59be.end(), itInitFn_59d0!= initFns_59c1.end(); ++itSFState_59c7, ++itInitFn_59d0)
	{
		bool isUnique= isInputUnique( *itSFState_59c7, *itInitFn_59d0);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_59c7, *itInitFn_59d0);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.sFState_59e1, currMatch.initFn_59e2);
	}
}

bool EAIOn_59bd::patternMatcher( const Udm::Object& sFState_59c8, const Udm::Object& initFn_59d1)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_59c8.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_59cd= CyberComposition::Simulink::SFState::Cast( sFState_59c8);
		if( false== Uml::IsDerivedFrom( initFn_59d1.type(), SFC::Function::meta))
			continue;
		SFC::Function initFn_59d6= SFC::Function::Cast( initFn_59d1);
		Udm::Object sFStateParent_59d8= sFState_59cd.container();
		if( false== Uml::IsDerivedFrom( sFStateParent_59d8.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystemSFState_59d9= CyberComposition::Simulink::Subsystem::Cast( sFStateParent_59d8);
		set< CyberComposition::Simulink::SF_Parameter> parameters_59da= subsystemSFState_59d9.SF_Parameter_kind_children();
		for( set< CyberComposition::Simulink::SF_Parameter>::const_iterator itParameter_59db= parameters_59da.begin(); itParameter_59db!= parameters_59da.end(); ++itParameter_59db)
		{
			CyberComposition::Simulink::SF_Parameter currParameter_59dc= *itParameter_59db;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_59e0;
			if( !isValidBound(boundObjs_59e0, sFState_59cd, true))
				continue;
			currMatch.sFState_59e1= sFState_59cd;
			if( !isValidBound(boundObjs_59e0, initFn_59d6, true))
				continue;
			currMatch.initFn_59e2= initFn_59d6;
			if( !isValidBound(boundObjs_59e0, currParameter_59dc, false))
				continue;
			currMatch.parameter_59e3= currParameter_59dc;
			if( !isValidBound(boundObjs_59e0, subsystemSFState_59d9, false))
				continue;
			currMatch.subsystem_59e4= subsystemSFState_59d9;
			bool Gz_guard= isGuardTrue( currMatch.initFn_59e2, currMatch.parameter_59e3, currMatch.sFState_59e1, currMatch.subsystem_59e4);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void EAIOn_59bd::outputAppender( const CyberComposition::Simulink::SFState& sFState_59e9, const SFC::Function& initFn_59eb)
{
	_sFState_59c4->push_back( sFState_59e9);
	_initFn_59c5->push_back( initFn_59eb);
}

void CreateFunction_FunctionCall_59ed::operator()( const Packets_t& sFStates_59ee, const Packets_t& initFns_59f1, Packets_t& enters_59f0, Packets_t& functionCalls_59f3)
{
#ifdef PRINT_INFO
	printLog( "CreateFunction_FunctionCall_59ed" );
#endif
	RTTGenerator::Instance()->generateRule(5326, "CreateFunction_FunctionCall");
	_enter_59f4= &enters_59f0;
	_functionCall_59f5= &functionCalls_59f3;
	processInputPackets( sFStates_59ee, initFns_59f1);
}

bool CreateFunction_FunctionCall_59ed::isInputUnique( const Udm::Object& sFState_59fa, const Udm::Object& initFn_5a03)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_59fc= _sFState_59f6.begin(), itInitFn_5a05= _initFn_59ff.begin(); itSFState_59fc!= _sFState_59f6.end(), itInitFn_5a05!= _initFn_59ff.end(); ++itSFState_59fc, ++itInitFn_5a05)
	{
		if( ( *itSFState_59fc== sFState_59fa)&& ( *itInitFn_5a05== initFn_5a03))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_59f6.push_back( sFState_59fa);
		_initFn_59ff.push_back( initFn_5a03);
	}
	return isUnique;
}

bool CreateFunction_FunctionCall_59ed::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateFunction_FunctionCall_59ed::processInputPackets( const Packets_t& sFStates_59ee, const Packets_t& initFns_59f1)
{
	for( Packets_t::const_iterator itSFState_59f7= sFStates_59ee.begin(), itInitFn_5a00= initFns_59f1.begin(); itSFState_59f7!= sFStates_59ee.end(), itInitFn_5a00!= initFns_59f1.end(); ++itSFState_59f7, ++itInitFn_5a00)
	{
		bool isUnique= isInputUnique( *itSFState_59f7, *itInitFn_5a00);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_59f7, *itInitFn_5a00);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateFunction_FunctionCall_59ed::patternMatcher( const Udm::Object& sFState_59f8, const Udm::Object& initFn_5a01)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_59f8.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_59fd= CyberComposition::Simulink::SFState::Cast( sFState_59f8);
		if( false== Uml::IsDerivedFrom( initFn_5a01.type(), SFC::Function::meta))
			continue;
		SFC::Function initFn_5a06= SFC::Function::Cast( initFn_5a01);
		set< SFC::Function> enters_5a08= sFState_59fd.enter();
		for( set< SFC::Function>::const_iterator itEnters_5a09= enters_5a08.begin(); itEnters_5a09!= enters_5a08.end(); ++itEnters_5a09)
		{
			SFC::Function currEnter_5a0a= *itEnters_5a09;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_5a0e;
			if( !isValidBound(boundObjs_5a0e, sFState_59fd, true))
				continue;
			currMatch.sFState_5a0f= sFState_59fd;
			if( !isValidBound(boundObjs_5a0e, initFn_5a06, true))
				continue;
			currMatch.initFn_5a10= initFn_5a06;
			if( !isValidBound(boundObjs_5a0e, currEnter_5a0a, false))
				continue;
			currMatch.enter_5a11= currEnter_5a0a;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateFunction_FunctionCall_59ed::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::FunctionCall newFunctionCall_5a12= SFC::FunctionCall::Create( currMatch.initFn_5a10);
		SFC::Function& Enter= currMatch.enter_5a11;
		SFC::FunctionCall& FunctionCall= newFunctionCall_5a12;
		SFC::Function& InitFn= currMatch.initFn_5a10;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_5a0f;
		{
FunctionCall.RefId() = InitFn.RefId();
};
		{
__int64 statementCount = InitFn.statementCount();
FunctionCall.statementIndex() = statementCount++;
InitFn.statementCount() = statementCount;
};
		newFunctionCall_5a12.callee()= currMatch.enter_5a11;
		outputAppender( currMatch.enter_5a11, newFunctionCall_5a12);
	}
}

void CreateFunction_FunctionCall_59ed::outputAppender( const SFC::Function& enter_5a13, const SFC::FunctionCall& functionCall_5a15)
{
	_enter_59f4->push_back( enter_5a13);
	_functionCall_59f5->push_back( functionCall_5a15);
}

void FunctionCall_Vals_5a17::operator()( const Packets_t& enters_5a18, const Packets_t& functionCalls_5a1a)
{
#ifdef PRINT_INFO
	printLog( "FunctionCall_Vals_5a17" );
#endif
	RTTGenerator::Instance()->generateRule(5336, "FunctionCall_Vals");
	processInputPackets( enters_5a18, functionCalls_5a1a);
}

bool FunctionCall_Vals_5a17::isInputUnique( const Udm::Object& enter_5a20, const Udm::Object& functionCall_5a29)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itEnter_5a22= _enter_5a1c.begin(), itFunctionCall_5a2b= _functionCall_5a25.begin(); itEnter_5a22!= _enter_5a1c.end(), itFunctionCall_5a2b!= _functionCall_5a25.end(); ++itEnter_5a22, ++itFunctionCall_5a2b)
	{
		if( ( *itEnter_5a22== enter_5a20)&& ( *itFunctionCall_5a2b== functionCall_5a29))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_enter_5a1c.push_back( enter_5a20);
		_functionCall_5a25.push_back( functionCall_5a29);
	}
	return isUnique;
}

bool FunctionCall_Vals_5a17::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool FunctionCall_Vals_5a17::isGuardTrue( SFC::Arg& Arg0, SFC::Arg& Arg1, SFC::Function& Enter, SFC::FunctionCall& FunctionCall)
{
	bool Gz_guard= false;
	return Arg0.argIndex() == 0 && Arg1.argIndex() == 1;;
	return Gz_guard;
}

void FunctionCall_Vals_5a17::processInputPackets( const Packets_t& enters_5a18, const Packets_t& functionCalls_5a1a)
{
	for( Packets_t::const_iterator itEnter_5a1d= enters_5a18.begin(), itFunctionCall_5a26= functionCalls_5a1a.begin(); itEnter_5a1d!= enters_5a18.end(), itFunctionCall_5a26!= functionCalls_5a1a.end(); ++itEnter_5a1d, ++itFunctionCall_5a26)
	{
		bool isUnique= isInputUnique( *itEnter_5a1d, *itFunctionCall_5a26);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itEnter_5a1d, *itFunctionCall_5a26);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool FunctionCall_Vals_5a17::patternMatcher( const Udm::Object& enter_5a1e, const Udm::Object& functionCall_5a27)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( enter_5a1e.type(), SFC::Function::meta))
			continue;
		SFC::Function enter_5a23= SFC::Function::Cast( enter_5a1e);
		if( false== Uml::IsDerivedFrom( functionCall_5a27.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall functionCall_5a2c= SFC::FunctionCall::Cast( functionCall_5a27);
		set< SFC::Arg> arg1s_5a2e= enter_5a23.Arg_kind_children();
		for( set< SFC::Arg>::const_iterator itArg1_5a2f= arg1s_5a2e.begin(); itArg1_5a2f!= arg1s_5a2e.end(); ++itArg1_5a2f)
		{
			SFC::Arg currArg1_5a30= *itArg1_5a2f;
			set< SFC::Arg> arg0s_5a31= enter_5a23.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itArg0_5a32= arg0s_5a31.begin(); itArg0_5a32!= arg0s_5a31.end(); ++itArg0_5a32)
			{
				SFC::Arg currArg0_5a33= *itArg0_5a32;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_5a37;
				if( !isValidBound(boundObjs_5a37, enter_5a23, true))
					continue;
				currMatch.enter_5a38= enter_5a23;
				if( !isValidBound(boundObjs_5a37, functionCall_5a2c, true))
					continue;
				currMatch.functionCall_5a39= functionCall_5a2c;
				if( !isValidBound(boundObjs_5a37, currArg0_5a33, false))
					continue;
				currMatch.arg0_5a3a= currArg0_5a33;
				if( !isValidBound(boundObjs_5a37, currArg1_5a30, false))
					continue;
				currMatch.arg1_5a3b= currArg1_5a30;
				bool Gz_guard= isGuardTrue( currMatch.arg0_5a3a, currMatch.arg1_5a3b, currMatch.enter_5a38, currMatch.functionCall_5a39);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void FunctionCall_Vals_5a17::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ArgVal newArgVal1_5a40= SFC::ArgVal::Create( currMatch.functionCall_5a39);
		SFC::Int newNegOne_5a41= SFC::Int::Create( newArgVal1_5a40);
		SFC::ArgVal newArgVal0_5a42= SFC::ArgVal::Create( currMatch.functionCall_5a39);
		SFC::Int newZero_5a43= SFC::Int::Create( newArgVal0_5a42);
		SFC::Arg& Arg0= currMatch.arg0_5a3a;
		SFC::Arg& Arg1= currMatch.arg1_5a3b;
		SFC::ArgVal& ArgVal0= newArgVal0_5a42;
		SFC::ArgVal& ArgVal1= newArgVal1_5a40;
		SFC::Function& Enter= currMatch.enter_5a38;
		SFC::FunctionCall& FunctionCall= currMatch.functionCall_5a39;
		SFC::Int& NegOne= newNegOne_5a41;
		SFC::Int& Zero= newZero_5a43;
		{
ArgVal1.argIndex() = Arg1.argIndex();
};
		{
ArgVal0.argIndex() = Arg0.argIndex();
};
		{
FunctionCall.argCount() = FunctionCall.argCount() + 2;
};
		{
NegOne.val() = -1;
};
		{
Zero.val() = 0;
};
		newArgVal1_5a40.arg()+= currMatch.arg1_5a3b;
		newArgVal0_5a42.arg()+= currMatch.arg0_5a3a;
	}
}

void CreateInitFunction_5a44::operator()( const Packets_t& sFStates_5a45, const Packets_t& programs_5a48, Packets_t& sFStates_5a47, Packets_t& programs_5a4a, Packets_t& initFunctions_5a4b, Packets_t& initIdxs_5a4c)
{
#ifdef PRINT_INFO
	printLog( "CreateInitFunction_5a44" );
#endif
	RTTGenerator::Instance()->generateRule(5358, "CreateInitFunction");
	_sFState_5a4d= &sFStates_5a47;
	_program_5a4e= &programs_5a4a;
	_initFunction_5a4f= &initFunctions_5a4b;
	_initIdx_5a50= &initIdxs_5a4c;
	processInputPackets( sFStates_5a45, programs_5a48);
}

bool CreateInitFunction_5a44::isInputUnique( const Udm::Object& sFState_5a55, const Udm::Object& program_5a5e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_5a57= _sFState_5a51.begin(), itProgram_5a60= _program_5a5a.begin(); itSFState_5a57!= _sFState_5a51.end(), itProgram_5a60!= _program_5a5a.end(); ++itSFState_5a57, ++itProgram_5a60)
	{
		if( ( *itSFState_5a57== sFState_5a55)&& ( *itProgram_5a60== program_5a5e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_5a51.push_back( sFState_5a55);
		_program_5a5a.push_back( program_5a5e);
	}
	return isUnique;
}

bool CreateInitFunction_5a44::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateInitFunction_5a44::processInputPackets( const Packets_t& sFStates_5a45, const Packets_t& programs_5a48)
{
	for( Packets_t::const_iterator itSFState_5a52= sFStates_5a45.begin(), itProgram_5a5b= programs_5a48.begin(); itSFState_5a52!= sFStates_5a45.end(), itProgram_5a5b!= programs_5a48.end(); ++itSFState_5a52, ++itProgram_5a5b)
	{
		bool isUnique= isInputUnique( *itSFState_5a52, *itProgram_5a5b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5a52, *itProgram_5a5b);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateInitFunction_5a44::patternMatcher( const Udm::Object& sFState_5a53, const Udm::Object& program_5a5c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5a53.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_5a58= CyberComposition::Simulink::SFState::Cast( sFState_5a53);
		if( false== Uml::IsDerivedFrom( program_5a5c.type(), SFC::Program::meta))
			continue;
		SFC::Program program_5a61= SFC::Program::Cast( program_5a5c);
		set< SFC::StateVar> stateVars_5a63= program_5a61.StateVar_kind_children();
		for( set< SFC::StateVar>::const_iterator itStateVar_5a64= stateVars_5a63.begin(); itStateVar_5a64!= stateVars_5a63.end(); ++itStateVar_5a64)
		{
			SFC::StateVar currStateVar_5a65= *itStateVar_5a64;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_5a69;
			if( !isValidBound(boundObjs_5a69, sFState_5a58, true))
				continue;
			currMatch.sFState_5a6a= sFState_5a58;
			if( !isValidBound(boundObjs_5a69, program_5a61, true))
				continue;
			currMatch.program_5a6b= program_5a61;
			if( !isValidBound(boundObjs_5a69, currStateVar_5a65, false))
				continue;
			currMatch.stateVar_5a6c= currStateVar_5a65;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateInitFunction_5a44::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function newInitFunction_5a6d= SFC::Function::Create( currMatch.program_5a6b);
		SFC::LocalVar newInitIdx_5a6e= SFC::LocalVar::Create( newInitFunction_5a6d);
		SFC::Function& InitFunction= newInitFunction_5a6d;
		SFC::LocalVar& InitIdx= newInitIdx_5a6e;
		SFC::Program& Program= currMatch.program_5a6b;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_5a6a;
		SFC::StateVar& StateVar= currMatch.stateVar_5a6c;
		{
InitFunction.RefId() = InitIdx.RefId() = SFState.RefId();
};
		{
__int64 sc;
sc = Program.statementCount();
InitFunction.statementIndex() = sc++;
Program.statementCount() = sc;
};
		{
InitFunction.name() = static_cast< std::string >( SFState.name() ) + "_init";
};
		{
__int64 sc;
sc = InitFunction.statementCount();
InitIdx.statementIndex() = sc++;
InitFunction.statementCount() = sc;
};
		{
InitIdx.name() = "i";
InitIdx.dt() = SFCTypesManager::getSingleton().getBasicType( "int" );
InitIdx.initial() = "0";
};
		outputAppender( currMatch.sFState_5a6a, currMatch.program_5a6b, newInitFunction_5a6d, newInitIdx_5a6e);
	}
}

void CreateInitFunction_5a44::outputAppender( const CyberComposition::Simulink::SFState& sFState_5a6f, const SFC::Program& program_5a71, const SFC::Function& initFunction_5a73, const SFC::LocalVar& initIdx_5a75)
{
	_sFState_5a4d->push_back( sFState_5a6f);
	_program_5a4e->push_back( program_5a71);
	_initFunction_5a4f->push_back( initFunction_5a73);
	_initIdx_5a50->push_back( initIdx_5a75);
}

void InitLocalVars_5a77::operator()( const Packets_t& states_5a78, const Packets_t& programs_5a7a, const Packets_t& initFns_5a7c, const Packets_t& initIdxs_5a7e, Packets_t& states_5a80, Packets_t& initfns_5a81)
{
#ifdef PRINT_INFO
	printLog( "InitLocalVars_5a77" );
#endif
	_state_5a82= &states_5a80;
	_initfn_5a83= &initfns_5a81;
	_state_5a82->insert( _state_5a82->end(), states_5a78.begin(), states_5a78.end());
	_initfn_5a83->insert( _initfn_5a83->end(), initFns_5a7c.begin(), initFns_5a7c.end());
	if( ( !programs_5a7a.empty())&& ( !initFns_5a7c.empty())&& ( !initIdxs_5a7e.empty()))
		callGetSortedVars_5bb6( programs_5a7a, initFns_5a7c, initIdxs_5a7e);
}

void InitLocalVars_5a77::callGetSortedVars_5bb6( const Packets_t& programs_5a85, const Packets_t& initFns_5a88, const Packets_t& initIdxs_5a8b)
{
	Packets_t vars_5a87;
	Packets_t initFns_5a8a;
	Packets_t initIdxs_5a8d;
	GetSortedVars_5a84 getSortedVars_5a84;
	getSortedVars_5a84( programs_5a85, initFns_5a88, initIdxs_5a8b, vars_5a87, initFns_5a8a, initIdxs_5a8d);
	if( ( !vars_5a87.empty())&& ( !initFns_5a8a.empty())&& ( !initIdxs_5a8d.empty()))
		callArrayVars_5bba( vars_5a87, initFns_5a8a, initIdxs_5a8d);
}

void InitLocalVars_5a77::callArrayVars_5bba( const Packets_t& programs_5af9, const Packets_t& initFns_5afb, const Packets_t& initIdxs_5afd)
{
	Packets_t vars_5aff;
	Packets_t initfns_5b00;
	Packets_t initidxs_5b01;
	Packets_t vars_5b02;
	Packets_t initfns_5b03;
	Packets_t initidxs_5b04;
	ArrayVars_5af8 arrayVars_5af8;
	arrayVars_5af8( programs_5af9, initFns_5afb, initIdxs_5afd, vars_5aff, initfns_5b00, initidxs_5b01, vars_5b02, initfns_5b03, initidxs_5b04);
	if( ( !vars_5aff.empty())&& ( !initfns_5b00.empty())&& ( !initidxs_5b01.empty()))
		callInitArrayVar_5bbe( vars_5aff, initfns_5b00, initidxs_5b01);
	if( ( !vars_5b02.empty())&& ( !initfns_5b03.empty())&& ( !initidxs_5b04.empty()))
		callInitScalarVar_5bc2( vars_5b02, initfns_5b03, initidxs_5b04);
}

void InitLocalVars_5a77::callInitArrayVar_5bbe( const Packets_t& vars_5abe, const Packets_t& initFns_5ac0, const Packets_t& idxVars_5ac2)
{
	InitArrayVar_5abd initArrayVar_5abd;
	initArrayVar_5abd( vars_5abe, initFns_5ac0, idxVars_5ac2);
}

void InitLocalVars_5a77::callInitScalarVar_5bc2( const Packets_t& vars_5b8e, const Packets_t& initFns_5b90, const Packets_t& idxVars_5b92)
{
	InitScalarVar_5b8d initScalarVar_5b8d;
	initScalarVar_5b8d( vars_5b8e, initFns_5b90, idxVars_5b92);
}

void GetSortedVars_5a84::operator()( const Packets_t& programs_5a85, const Packets_t& initFns_5a88, const Packets_t& initIdxs_5a8b, Packets_t& vars_5a87, Packets_t& initFns_5a8a, Packets_t& initIdxs_5a8d)
{
#ifdef PRINT_INFO
	printLog( "GetSortedVars_5a84" );
#endif
	RTTGenerator::Instance()->generateRule(5379, "GetSortedVars");
	_var_5a8e= &vars_5a87;
	_initFn_5a8f= &initFns_5a8a;
	_initIdx_5a90= &initIdxs_5a8d;
	processInputPackets( programs_5a85, initFns_5a88, initIdxs_5a8b);
	sortOutputs( );
}

bool GetSortedVars_5a84::isInputUnique( const Udm::Object& program_5a95, const Udm::Object& initFn_5a9e, const Udm::Object& initIdx_5aa7)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itProgram_5a97= _program_5a91.begin(), itInitFn_5aa0= _initFn_5a9a.begin(), itInitIdx_5aa9= _initIdx_5aa3.begin(); itProgram_5a97!= _program_5a91.end(), itInitFn_5aa0!= _initFn_5a9a.end(), itInitIdx_5aa9!= _initIdx_5aa3.end(); ++itProgram_5a97, ++itInitFn_5aa0, ++itInitIdx_5aa9)
	{
		if( ( *itProgram_5a97== program_5a95)&& ( *itInitFn_5aa0== initFn_5a9e)&& ( *itInitIdx_5aa9== initIdx_5aa7))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_program_5a91.push_back( program_5a95);
		_initFn_5a9a.push_back( initFn_5a9e);
		_initIdx_5aa3.push_back( initIdx_5aa7);
	}
	return isUnique;
}

bool GetSortedVars_5a84::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetSortedVars_5a84::processInputPackets( const Packets_t& programs_5a85, const Packets_t& initFns_5a88, const Packets_t& initIdxs_5a8b)
{
	for( Packets_t::const_iterator itProgram_5a92= programs_5a85.begin(), itInitFn_5a9b= initFns_5a88.begin(), itInitIdx_5aa4= initIdxs_5a8b.begin(); itProgram_5a92!= programs_5a85.end(), itInitFn_5a9b!= initFns_5a88.end(), itInitIdx_5aa4!= initIdxs_5a8b.end(); ++itProgram_5a92, ++itInitFn_5a9b, ++itInitIdx_5aa4)
	{
		bool isUnique= isInputUnique( *itProgram_5a92, *itInitFn_5a9b, *itInitIdx_5aa4);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itProgram_5a92, *itInitFn_5a9b, *itInitIdx_5aa4);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetSortedVars_5a84::patternMatcher( const Udm::Object& program_5a93, const Udm::Object& initFn_5a9c, const Udm::Object& initIdx_5aa5)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( program_5a93.type(), SFC::Program::meta))
			continue;
		SFC::Program program_5a98= SFC::Program::Cast( program_5a93);
		if( false== Uml::IsDerivedFrom( initFn_5a9c.type(), SFC::Function::meta))
			continue;
		SFC::Function initFn_5aa1= SFC::Function::Cast( initFn_5a9c);
		if( false== Uml::IsDerivedFrom( initIdx_5aa5.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar initIdx_5aaa= SFC::LocalVar::Cast( initIdx_5aa5);
		set< SFC::Var> vars_5aac= program_5a98.Var_kind_children();
		for( set< SFC::Var>::const_iterator itVar_5aad= vars_5aac.begin(); itVar_5aad!= vars_5aac.end(); ++itVar_5aad)
		{
			SFC::Var currVar_5aae= *itVar_5aad;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_5ab2;
			if( !isValidBound(boundObjs_5ab2, program_5a98, true))
				continue;
			currMatch.program_5ab3= program_5a98;
			if( !isValidBound(boundObjs_5ab2, initFn_5aa1, true))
				continue;
			currMatch.initFn_5ab4= initFn_5aa1;
			if( !isValidBound(boundObjs_5ab2, initIdx_5aaa, true))
				continue;
			currMatch.initIdx_5ab5= initIdx_5aaa;
			if( !isValidBound(boundObjs_5ab2, currVar_5aae, false))
				continue;
			currMatch.var_5ab6= currVar_5aae;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetSortedVars_5a84::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.var_5ab6, currMatch.initFn_5ab4, currMatch.initIdx_5ab5);
	}
}

void GetSortedVars_5a84::outputAppender( const SFC::Var& var_5ab7, const SFC::Function& initFn_5ab9, const SFC::LocalVar& initIdx_5abb)
{
	_var_5a8e->push_back( var_5ab7);
	_initFn_5a8f->push_back( initFn_5ab9);
	_initIdx_5a90->push_back( initIdx_5abb);
}

void GetSortedVars_5a84::sortOutputs()
{
	typedef std::multiset< SFC::Var, std::pointer_to_binary_function< const SFC::Var&, const SFC::Var&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const SFC::Var&, const SFC::Var&, bool> ptr_StatementOrder( StatementOrder< SFC::Var>);
	SortedSet_t sortedSet( ptr_StatementOrder);
	std::vector< int> permutationVector( _var_5a8e->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _var_5a8e->begin(); it!= _var_5a8e->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( SFC::Var::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _var_5a8e->begin());
	// order rest of the containers
	permutate( permutationVector, *_initFn_5a8f);
	permutate( permutationVector, *_initIdx_5a90);
}

void InitArrayVar_5abd::operator()( const Packets_t& vars_5abe, const Packets_t& initFns_5ac0, const Packets_t& idxVars_5ac2)
{
#ifdef PRINT_INFO
	printLog( "InitArrayVar_5abd" );
#endif
	RTTGenerator::Instance()->generateRule(5385, "InitArrayVar");
	processInputPackets( vars_5abe, initFns_5ac0, idxVars_5ac2);
}

bool InitArrayVar_5abd::isInputUnique( const Udm::Object& var_5ac8, const Udm::Object& initFn_5ad1, const Udm::Object& idxVar_5ada)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itVar_5aca= _var_5ac4.begin(), itInitFn_5ad3= _initFn_5acd.begin(), itIdxVar_5adc= _idxVar_5ad6.begin(); itVar_5aca!= _var_5ac4.end(), itInitFn_5ad3!= _initFn_5acd.end(), itIdxVar_5adc!= _idxVar_5ad6.end(); ++itVar_5aca, ++itInitFn_5ad3, ++itIdxVar_5adc)
	{
		if( ( *itVar_5aca== var_5ac8)&& ( *itInitFn_5ad3== initFn_5ad1)&& ( *itIdxVar_5adc== idxVar_5ada))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_var_5ac4.push_back( var_5ac8);
		_initFn_5acd.push_back( initFn_5ad1);
		_idxVar_5ad6.push_back( idxVar_5ada);
	}
	return isUnique;
}

bool InitArrayVar_5abd::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void InitArrayVar_5abd::processInputPackets( const Packets_t& vars_5abe, const Packets_t& initFns_5ac0, const Packets_t& idxVars_5ac2)
{
	for( Packets_t::const_iterator itVar_5ac5= vars_5abe.begin(), itInitFn_5ace= initFns_5ac0.begin(), itIdxVar_5ad7= idxVars_5ac2.begin(); itVar_5ac5!= vars_5abe.end(), itInitFn_5ace!= initFns_5ac0.end(), itIdxVar_5ad7!= idxVars_5ac2.end(); ++itVar_5ac5, ++itInitFn_5ace, ++itIdxVar_5ad7)
	{
		bool isUnique= isInputUnique( *itVar_5ac5, *itInitFn_5ace, *itIdxVar_5ad7);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itVar_5ac5, *itInitFn_5ace, *itIdxVar_5ad7);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InitArrayVar_5abd::patternMatcher( const Udm::Object& var_5ac6, const Udm::Object& initFn_5acf, const Udm::Object& idxVar_5ad8)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( var_5ac6.type(), SFC::Var::meta))
			continue;
		SFC::Var var_5acb= SFC::Var::Cast( var_5ac6);
		if( false== Uml::IsDerivedFrom( initFn_5acf.type(), SFC::Function::meta))
			continue;
		SFC::Function initFn_5ad4= SFC::Function::Cast( initFn_5acf);
		if( false== Uml::IsDerivedFrom( idxVar_5ad8.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar idxVar_5add= SFC::LocalVar::Cast( idxVar_5ad8);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5ae2;
		if( !isValidBound(boundObjs_5ae2, var_5acb, true))
			continue;
		currMatch.var_5ae3= var_5acb;
		if( !isValidBound(boundObjs_5ae2, initFn_5ad4, true))
			continue;
		currMatch.initFn_5ae4= initFn_5ad4;
		if( !isValidBound(boundObjs_5ae2, idxVar_5add, true))
			continue;
		currMatch.idxVar_5ae5= idxVar_5add;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void InitArrayVar_5abd::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newInitIdxVar_5ae6= SFC::UserCode::Create( currMatch.initFn_5ae4);
		SFC::BinaryExprs newopAssign_5ae7= SFC::BinaryExprs::Create( newInitIdxVar_5ae6, SFC::UserCode::meta_codeexpr);
		SFC::Int newzeroVal_5ae8= SFC::Int::Create( newopAssign_5ae7, SFC::BinaryExprs::meta_rightexpr);
		SFC::IterativeBlock newloopBlock_5ae9= SFC::IterativeBlock::Create( currMatch.initFn_5ae4);
		SFC::UserCode newincIdxVar_5aea= SFC::UserCode::Create( newloopBlock_5ae9, SFC::IterativeBlock::meta_stmnt);
		SFC::UnaryExprs newopInc_5aeb= SFC::UnaryExprs::Create( newincIdxVar_5aea, SFC::UserCode::meta_codeexpr);
		SFC::UserCode newloopCond_5aec= SFC::UserCode::Create( newloopBlock_5ae9, SFC::IterativeBlock::meta_cond);
		SFC::BinaryExprs newopLe_5aed= SFC::BinaryExprs::Create( newloopCond_5aec, SFC::UserCode::meta_codeexpr);
		SFC::Int newloopBound_5aee= SFC::Int::Create( newopLe_5aed, SFC::BinaryExprs::meta_rightexpr);
		SFC::UserCode newloopAction_5aef= SFC::UserCode::Create( newloopBlock_5ae9, SFC::IterativeBlock::meta_stmnt);
		SFC::ArgDeclRef newidxVarRef_5af0= SFC::ArgDeclRef::Create( newopAssign_5ae7, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newidxVarRef2_5af1= SFC::ArgDeclRef::Create( newopInc_5aeb, SFC::UnaryExprs::meta_subexpr);
		SFC::ArgDeclRef newidxVarRef3_5af2= SFC::ArgDeclRef::Create( newopLe_5aed, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newVarAssign_5af3= SFC::BinaryExprs::Create( newloopAction_5aef, SFC::UserCode::meta_codeexpr);
		SFC::Int newZero_5af4= SFC::Int::Create( newVarAssign_5af3, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newVarIndexOp_5af5= SFC::BinaryExprs::Create( newVarAssign_5af3, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newidxVarRef4_5af6= SFC::ArgDeclRef::Create( newVarIndexOp_5af5, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newVarRef_5af7= SFC::ArgDeclRef::Create( newVarIndexOp_5af5, SFC::BinaryExprs::meta_leftexpr);
		SFC::LocalVar& IdxVar= currMatch.idxVar_5ae5;
		SFC::Function& InitFn= currMatch.initFn_5ae4;
		SFC::UserCode& InitIdxVar= newInitIdxVar_5ae6;
		SFC::Var& Var= currMatch.var_5ae3;
		SFC::BinaryExprs& VarAssign= newVarAssign_5af3;
		SFC::BinaryExprs& VarIndexOp= newVarIndexOp_5af5;
		SFC::ArgDeclRef& VarRef= newVarRef_5af7;
		SFC::Int& Zero= newZero_5af4;
		SFC::ArgDeclRef& idxVarRef= newidxVarRef_5af0;
		SFC::ArgDeclRef& idxVarRef2= newidxVarRef2_5af1;
		SFC::ArgDeclRef& idxVarRef3= newidxVarRef3_5af2;
		SFC::ArgDeclRef& idxVarRef4= newidxVarRef4_5af6;
		SFC::UserCode& incIdxVar= newincIdxVar_5aea;
		SFC::UserCode& loopAction= newloopAction_5aef;
		SFC::IterativeBlock& loopBlock= newloopBlock_5ae9;
		SFC::Int& loopBound= newloopBound_5aee;
		SFC::UserCode& loopCond= newloopCond_5aec;
		SFC::BinaryExprs& opAssign= newopAssign_5ae7;
		SFC::UnaryExprs& opInc= newopInc_5aeb;
		SFC::BinaryExprs& opLe= newopLe_5aed;
		SFC::Int& zeroVal= newzeroVal_5ae8;
		{
InitIdxVar.RefId() = loopBlock.RefId() = loopCond.RefId() = incIdxVar.RefId() = InitFn.RefId();
loopAction.RefId() = Var.RefId();
};
		{
Zero.val() = 0;
};
		{
__int64 sc;
sc = loopBlock.statementCount();
loopAction.statementIndex() = sc++;
incIdxVar.statementIndex() = sc++;
loopBlock.statementCount() = sc;
};
		{
__int64 sc;
sc = InitFn.statementCount();
InitIdxVar.statementIndex() = sc++;
loopBlock.statementIndex() = sc++;
InitFn.statementCount() = sc;
};
		{
opAssign.op() = string("=");
opInc.op() = string("++");
opLe.op() = string("<");
};
		{
zeroVal.val() = 0;
loopBound.val() = Var.size();
};
		{
loopAction.expr() = "";

VarAssign.op() = "=";
VarIndexOp.op() = "[";
VarRef.unres() = "";
idxVarRef4.unres() = "";

};
		{
idxVarRef.unres() = "";
idxVarRef2.unres() = "";
idxVarRef3.unres() = "";

};
		newidxVarRef_5af0.argdecl()= currMatch.idxVar_5ae5;
		newidxVarRef2_5af1.argdecl()= currMatch.idxVar_5ae5;
		newidxVarRef3_5af2.argdecl()= currMatch.idxVar_5ae5;
		newidxVarRef4_5af6.argdecl()= currMatch.idxVar_5ae5;
		newVarRef_5af7.argdecl()= currMatch.var_5ae3;
	}
}

void ArrayVars_5af8::operator()( const Packets_t& programs_5af9, const Packets_t& initFns_5afb, const Packets_t& initIdxs_5afd, Packets_t& vars_5aff, Packets_t& initfns_5b00, Packets_t& initidxs_5b01, Packets_t& vars_5b02, Packets_t& initfns_5b03, Packets_t& initidxs_5b04)
{
#ifdef PRINT_INFO
	printLog( "ArrayVars_5af8" );
#endif
	_var_5b05= &vars_5aff;
	_initfn_5b06= &initfns_5b00;
	_initidx_5b07= &initidxs_5b01;
	_var_5b08= &vars_5b02;
	_initfn_5b09= &initfns_5b03;
	_initidx_5b0a= &initidxs_5b04;
	for( Packets_t::const_iterator itprogram_5b0c= programs_5af9.begin(), itinitFn_5b13= initFns_5afb.begin(), itinitIdx_5b1a= initIdxs_5afd.begin(); itprogram_5b0c!= programs_5af9.end(), itinitFn_5b13!= initFns_5afb.end(), itinitIdx_5b1a!= initIdxs_5afd.end(); ++itprogram_5b0c, ++itinitFn_5b13, ++itinitIdx_5b1a)
	{
		bool isUnique= isInputUnique( *itprogram_5b0c, *itinitFn_5b13, *itinitIdx_5b1a);
		if( !isUnique)
			continue;
		Packets_t oneprogram_5b10( 1, *itprogram_5b0c);
		Packets_t oneinitFn_5b17( 1, *itinitFn_5b13);
		Packets_t oneinitIdx_5b1e( 1, *itinitIdx_5b1a);
		executeOne( oneprogram_5b10, oneinitFn_5b17, oneinitIdx_5b1e);
	}
}

void ArrayVars_5af8::executeOne( const Packets_t& programs_5af9, const Packets_t& initFns_5afb, const Packets_t& initIdxs_5afd)
{
	Packets_t vars_5b23;
	Packets_t initFns_5b26;
	Packets_t initIdxs_5b29;
	ArrayVar_5b20 arrayVar_5b20;
	bool isMatchArrayVar_5b20= arrayVar_5b20( programs_5af9, initFns_5afb, initIdxs_5afd, vars_5b23, initFns_5b26, initIdxs_5b29);
	_var_5b05->insert( _var_5b05->end(), vars_5b23.begin(), vars_5b23.end());
	_initfn_5b06->insert( _initfn_5b06->end(), initFns_5b26.begin(), initFns_5b26.end());
	_initidx_5b07->insert( _initidx_5b07->end(), initIdxs_5b29.begin(), initIdxs_5b29.end());
	if( isMatchArrayVar_5b20)
		return;
	Packets_t vars_5b5b;
	Packets_t initFns_5b5e;
	Packets_t initIdxs_5b61;
	Otherwise_5b58 otherwise_5b58;
	bool isMatchOtherwise_5b58= otherwise_5b58( programs_5af9, initFns_5afb, initIdxs_5afd, vars_5b5b, initFns_5b5e, initIdxs_5b61);
	_var_5b08->insert( _var_5b08->end(), vars_5b5b.begin(), vars_5b5b.end());
	_initfn_5b09->insert( _initfn_5b09->end(), initFns_5b5e.begin(), initFns_5b5e.end());
	_initidx_5b0a->insert( _initidx_5b0a->end(), initIdxs_5b61.begin(), initIdxs_5b61.end());
	if( isMatchOtherwise_5b58)
		return;
}

bool ArrayVars_5af8::isInputUnique( const Udm::Object& program_5b0d, const Udm::Object& initFn_5b14, const Udm::Object& initIdx_5b1b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itprogram_5b0f= _program_5b0b.begin(), itinitFn_5b16= _initFn_5b12.begin(), itinitIdx_5b1d= _initIdx_5b19.begin(); itprogram_5b0f!= _program_5b0b.end(), itinitFn_5b16!= _initFn_5b12.end(), itinitIdx_5b1d!= _initIdx_5b19.end(); ++itprogram_5b0f, ++itinitFn_5b16, ++itinitIdx_5b1d)
	{
		if( ( *itprogram_5b0f== program_5b0d)&& ( *itinitFn_5b16== initFn_5b14)&& ( *itinitIdx_5b1d== initIdx_5b1b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_program_5b0b.push_back( program_5b0d);
		_initFn_5b12.push_back( initFn_5b14);
		_initIdx_5b19.push_back( initIdx_5b1b);
	}
	return isUnique;
}

bool ArrayVar_5b20::operator()( const Packets_t& vars_5b21, const Packets_t& initFns_5b24, const Packets_t& initIdxs_5b27, Packets_t& vars_5b23, Packets_t& initFns_5b26, Packets_t& initIdxs_5b29)
{
#ifdef PRINT_INFO
	printLog( "ArrayVar_5b20" );
#endif
	_var_5b2a= &vars_5b23;
	_initFn_5b2b= &initFns_5b26;
	_initIdx_5b2c= &initIdxs_5b29;
	processInputPackets( vars_5b21, initFns_5b24, initIdxs_5b27);
	sortOutputs( );
	if( false== _matches.empty())
		return true;
	return false;
}

bool ArrayVar_5b20::isInputUnique( const Udm::Object& var_5b31, const Udm::Object& initFn_5b3a, const Udm::Object& initIdx_5b43)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itVar_5b33= _var_5b2d.begin(), itInitFn_5b3c= _initFn_5b36.begin(), itInitIdx_5b45= _initIdx_5b3f.begin(); itVar_5b33!= _var_5b2d.end(), itInitFn_5b3c!= _initFn_5b36.end(), itInitIdx_5b45!= _initIdx_5b3f.end(); ++itVar_5b33, ++itInitFn_5b3c, ++itInitIdx_5b45)
	{
		if( ( *itVar_5b33== var_5b31)&& ( *itInitFn_5b3c== initFn_5b3a)&& ( *itInitIdx_5b45== initIdx_5b43))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_var_5b2d.push_back( var_5b31);
		_initFn_5b36.push_back( initFn_5b3a);
		_initIdx_5b3f.push_back( initIdx_5b43);
	}
	return isUnique;
}

bool ArrayVar_5b20::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool ArrayVar_5b20::isGuardTrue( SFC::Function& InitFn, SFC::LocalVar& InitIdx, SFC::Var& Var)
{
	bool Gz_guard= false;
	__int64 sz = Var.size();
const Udm::Object& o = Var;
Gz_guard = (sz > 1) || Udm::IsDerivedFrom(o.type(), SFC::StateVar::meta);;
	return Gz_guard;
}

void ArrayVar_5b20::processInputPackets( const Packets_t& vars_5b21, const Packets_t& initFns_5b24, const Packets_t& initIdxs_5b27)
{
	for( Packets_t::const_iterator itVar_5b2e= vars_5b21.begin(), itInitFn_5b37= initFns_5b24.begin(), itInitIdx_5b40= initIdxs_5b27.begin(); itVar_5b2e!= vars_5b21.end(), itInitFn_5b37!= initFns_5b24.end(), itInitIdx_5b40!= initIdxs_5b27.end(); ++itVar_5b2e, ++itInitFn_5b37, ++itInitIdx_5b40)
	{
		bool isUnique= isInputUnique( *itVar_5b2e, *itInitFn_5b37, *itInitIdx_5b40);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itVar_5b2e, *itInitFn_5b37, *itInitIdx_5b40);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.var_5b4c, currMatch.initFn_5b4d, currMatch.initIdx_5b4e);
	}
}

bool ArrayVar_5b20::patternMatcher( const Udm::Object& var_5b2f, const Udm::Object& initFn_5b38, const Udm::Object& initIdx_5b41)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( var_5b2f.type(), SFC::Var::meta))
			continue;
		SFC::Var var_5b34= SFC::Var::Cast( var_5b2f);
		if( false== Uml::IsDerivedFrom( initFn_5b38.type(), SFC::Function::meta))
			continue;
		SFC::Function initFn_5b3d= SFC::Function::Cast( initFn_5b38);
		if( false== Uml::IsDerivedFrom( initIdx_5b41.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar initIdx_5b46= SFC::LocalVar::Cast( initIdx_5b41);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5b4b;
		if( !isValidBound(boundObjs_5b4b, var_5b34, true))
			continue;
		currMatch.var_5b4c= var_5b34;
		if( !isValidBound(boundObjs_5b4b, initFn_5b3d, true))
			continue;
		currMatch.initFn_5b4d= initFn_5b3d;
		if( !isValidBound(boundObjs_5b4b, initIdx_5b46, true))
			continue;
		currMatch.initIdx_5b4e= initIdx_5b46;
		bool Gz_guard= isGuardTrue( currMatch.initFn_5b4d, currMatch.initIdx_5b4e, currMatch.var_5b4c);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void ArrayVar_5b20::outputAppender( const SFC::Var& var_5b52, const SFC::Function& initFn_5b54, const SFC::LocalVar& initIdx_5b56)
{
	_var_5b2a->push_back( var_5b52);
	_initFn_5b2b->push_back( initFn_5b54);
	_initIdx_5b2c->push_back( initIdx_5b56);
}

void ArrayVar_5b20::sortOutputs()
{
	typedef std::multiset< SFC::Var, std::pointer_to_binary_function< const SFC::Var&, const SFC::Var&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const SFC::Var&, const SFC::Var&, bool> ptr_StatementOrder( StatementOrder< SFC::Var>);
	SortedSet_t sortedSet( ptr_StatementOrder);
	std::vector< int> permutationVector( _var_5b2a->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _var_5b2a->begin(); it!= _var_5b2a->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( SFC::Var::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _var_5b2a->begin());
	// order rest of the containers
	permutate( permutationVector, *_initFn_5b2b);
	permutate( permutationVector, *_initIdx_5b2c);
}

bool Otherwise_5b58::operator()( const Packets_t& vars_5b59, const Packets_t& initFns_5b5c, const Packets_t& initIdxs_5b5f, Packets_t& vars_5b5b, Packets_t& initFns_5b5e, Packets_t& initIdxs_5b61)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_5b58" );
#endif
	_var_5b62= &vars_5b5b;
	_initFn_5b63= &initFns_5b5e;
	_initIdx_5b64= &initIdxs_5b61;
	processInputPackets( vars_5b59, initFns_5b5c, initIdxs_5b5f);
	sortOutputs( );
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_5b58::isInputUnique( const Udm::Object& var_5b69, const Udm::Object& initFn_5b72, const Udm::Object& initIdx_5b7b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itVar_5b6b= _var_5b65.begin(), itInitFn_5b74= _initFn_5b6e.begin(), itInitIdx_5b7d= _initIdx_5b77.begin(); itVar_5b6b!= _var_5b65.end(), itInitFn_5b74!= _initFn_5b6e.end(), itInitIdx_5b7d!= _initIdx_5b77.end(); ++itVar_5b6b, ++itInitFn_5b74, ++itInitIdx_5b7d)
	{
		if( ( *itVar_5b6b== var_5b69)&& ( *itInitFn_5b74== initFn_5b72)&& ( *itInitIdx_5b7d== initIdx_5b7b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_var_5b65.push_back( var_5b69);
		_initFn_5b6e.push_back( initFn_5b72);
		_initIdx_5b77.push_back( initIdx_5b7b);
	}
	return isUnique;
}

bool Otherwise_5b58::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_5b58::processInputPackets( const Packets_t& vars_5b59, const Packets_t& initFns_5b5c, const Packets_t& initIdxs_5b5f)
{
	for( Packets_t::const_iterator itVar_5b66= vars_5b59.begin(), itInitFn_5b6f= initFns_5b5c.begin(), itInitIdx_5b78= initIdxs_5b5f.begin(); itVar_5b66!= vars_5b59.end(), itInitFn_5b6f!= initFns_5b5c.end(), itInitIdx_5b78!= initIdxs_5b5f.end(); ++itVar_5b66, ++itInitFn_5b6f, ++itInitIdx_5b78)
	{
		bool isUnique= isInputUnique( *itVar_5b66, *itInitFn_5b6f, *itInitIdx_5b78);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itVar_5b66, *itInitFn_5b6f, *itInitIdx_5b78);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.var_5b84, currMatch.initFn_5b85, currMatch.initIdx_5b86);
	}
}

bool Otherwise_5b58::patternMatcher( const Udm::Object& var_5b67, const Udm::Object& initFn_5b70, const Udm::Object& initIdx_5b79)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( var_5b67.type(), SFC::Var::meta))
			continue;
		SFC::Var var_5b6c= SFC::Var::Cast( var_5b67);
		if( false== Uml::IsDerivedFrom( initFn_5b70.type(), SFC::Function::meta))
			continue;
		SFC::Function initFn_5b75= SFC::Function::Cast( initFn_5b70);
		if( false== Uml::IsDerivedFrom( initIdx_5b79.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar initIdx_5b7e= SFC::LocalVar::Cast( initIdx_5b79);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5b83;
		if( !isValidBound(boundObjs_5b83, var_5b6c, true))
			continue;
		currMatch.var_5b84= var_5b6c;
		if( !isValidBound(boundObjs_5b83, initFn_5b75, true))
			continue;
		currMatch.initFn_5b85= initFn_5b75;
		if( !isValidBound(boundObjs_5b83, initIdx_5b7e, true))
			continue;
		currMatch.initIdx_5b86= initIdx_5b7e;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_5b58::outputAppender( const SFC::Var& var_5b87, const SFC::Function& initFn_5b89, const SFC::LocalVar& initIdx_5b8b)
{
	_var_5b62->push_back( var_5b87);
	_initFn_5b63->push_back( initFn_5b89);
	_initIdx_5b64->push_back( initIdx_5b8b);
}

void Otherwise_5b58::sortOutputs()
{
	typedef std::multiset< SFC::Var, std::pointer_to_binary_function< const SFC::Var&, const SFC::Var&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const SFC::Var&, const SFC::Var&, bool> ptr_StatementOrder( StatementOrder< SFC::Var>);
	SortedSet_t sortedSet( ptr_StatementOrder);
	std::vector< int> permutationVector( _var_5b62->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _var_5b62->begin(); it!= _var_5b62->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( SFC::Var::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _var_5b62->begin());
	// order rest of the containers
	permutate( permutationVector, *_initFn_5b63);
	permutate( permutationVector, *_initIdx_5b64);
}

void InitScalarVar_5b8d::operator()( const Packets_t& vars_5b8e, const Packets_t& initFns_5b90, const Packets_t& idxVars_5b92)
{
#ifdef PRINT_INFO
	printLog( "InitScalarVar_5b8d" );
#endif
	RTTGenerator::Instance()->generateRule(5456, "InitScalarVar");
	processInputPackets( vars_5b8e, initFns_5b90, idxVars_5b92);
}

bool InitScalarVar_5b8d::isInputUnique( const Udm::Object& var_5b98, const Udm::Object& initFn_5ba1, const Udm::Object& idxVar_5baa)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itVar_5b9a= _var_5b94.begin(), itInitFn_5ba3= _initFn_5b9d.begin(), itIdxVar_5bac= _idxVar_5ba6.begin(); itVar_5b9a!= _var_5b94.end(), itInitFn_5ba3!= _initFn_5b9d.end(), itIdxVar_5bac!= _idxVar_5ba6.end(); ++itVar_5b9a, ++itInitFn_5ba3, ++itIdxVar_5bac)
	{
		if( ( *itVar_5b9a== var_5b98)&& ( *itInitFn_5ba3== initFn_5ba1)&& ( *itIdxVar_5bac== idxVar_5baa))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_var_5b94.push_back( var_5b98);
		_initFn_5b9d.push_back( initFn_5ba1);
		_idxVar_5ba6.push_back( idxVar_5baa);
	}
	return isUnique;
}

bool InitScalarVar_5b8d::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void InitScalarVar_5b8d::processInputPackets( const Packets_t& vars_5b8e, const Packets_t& initFns_5b90, const Packets_t& idxVars_5b92)
{
	for( Packets_t::const_iterator itVar_5b95= vars_5b8e.begin(), itInitFn_5b9e= initFns_5b90.begin(), itIdxVar_5ba7= idxVars_5b92.begin(); itVar_5b95!= vars_5b8e.end(), itInitFn_5b9e!= initFns_5b90.end(), itIdxVar_5ba7!= idxVars_5b92.end(); ++itVar_5b95, ++itInitFn_5b9e, ++itIdxVar_5ba7)
	{
		bool isUnique= isInputUnique( *itVar_5b95, *itInitFn_5b9e, *itIdxVar_5ba7);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itVar_5b95, *itInitFn_5b9e, *itIdxVar_5ba7);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InitScalarVar_5b8d::patternMatcher( const Udm::Object& var_5b96, const Udm::Object& initFn_5b9f, const Udm::Object& idxVar_5ba8)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( var_5b96.type(), SFC::Var::meta))
			continue;
		SFC::Var var_5b9b= SFC::Var::Cast( var_5b96);
		if( false== Uml::IsDerivedFrom( initFn_5b9f.type(), SFC::Function::meta))
			continue;
		SFC::Function initFn_5ba4= SFC::Function::Cast( initFn_5b9f);
		if( false== Uml::IsDerivedFrom( idxVar_5ba8.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar idxVar_5bad= SFC::LocalVar::Cast( idxVar_5ba8);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5bb2;
		if( !isValidBound(boundObjs_5bb2, var_5b9b, true))
			continue;
		currMatch.var_5bb3= var_5b9b;
		if( !isValidBound(boundObjs_5bb2, initFn_5ba4, true))
			continue;
		currMatch.initFn_5bb4= initFn_5ba4;
		if( !isValidBound(boundObjs_5bb2, idxVar_5bad, true))
			continue;
		currMatch.idxVar_5bb5= idxVar_5bad;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void InitScalarVar_5b8d::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar& IdxVar= currMatch.idxVar_5bb5;
		SFC::Function& InitFn= currMatch.initFn_5bb4;
		SFC::Var& Var= currMatch.var_5bb3;
		{
SFManager::initVar( InitFn, Var );
};
	}
}

void MarkLegacy_5bd7::operator()( const Packets_t& sFStates_5bd8, const Packets_t& programs_5bda)
{
#ifdef PRINT_INFO
	printLog( "MarkLegacy_5bd7" );
#endif
	RTTGenerator::Instance()->generateRule(5461, "MarkLegacy");
	processInputPackets( sFStates_5bd8, programs_5bda);
}

bool MarkLegacy_5bd7::isInputUnique( const Udm::Object& sFState_5be0, const Udm::Object& program_5be9)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSFState_5be2= _sFState_5bdc.begin(), itProgram_5beb= _program_5be5.begin(); itSFState_5be2!= _sFState_5bdc.end(), itProgram_5beb!= _program_5be5.end(); ++itSFState_5be2, ++itProgram_5beb)
	{
		if( ( *itSFState_5be2== sFState_5be0)&& ( *itProgram_5beb== program_5be9))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_sFState_5bdc.push_back( sFState_5be0);
		_program_5be5.push_back( program_5be9);
	}
	return isUnique;
}

bool MarkLegacy_5bd7::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void MarkLegacy_5bd7::processInputPackets( const Packets_t& sFStates_5bd8, const Packets_t& programs_5bda)
{
	for( Packets_t::const_iterator itSFState_5bdd= sFStates_5bd8.begin(), itProgram_5be6= programs_5bda.begin(); itSFState_5bdd!= sFStates_5bd8.end(), itProgram_5be6!= programs_5bda.end(); ++itSFState_5bdd, ++itProgram_5be6)
	{
		bool isUnique= isInputUnique( *itSFState_5bdd, *itProgram_5be6);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSFState_5bdd, *itProgram_5be6);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool MarkLegacy_5bd7::patternMatcher( const Udm::Object& sFState_5bde, const Udm::Object& program_5be7)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sFState_5bde.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_5be3= CyberComposition::Simulink::SFState::Cast( sFState_5bde);
		if( false== Uml::IsDerivedFrom( program_5be7.type(), SFC::Program::meta))
			continue;
		SFC::Program program_5bec= SFC::Program::Cast( program_5be7);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5bf1;
		if( !isValidBound(boundObjs_5bf1, sFState_5be3, true))
			continue;
		currMatch.sFState_5bf2= sFState_5be3;
		if( !isValidBound(boundObjs_5bf1, program_5bec, true))
			continue;
		currMatch.program_5bf3= program_5bec;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void MarkLegacy_5bd7::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Program& Program= currMatch.program_5bf3;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_5bf2;
		{
__int64 statementCount = Program.statementCount();
if ( statementCount > 0 ) statementCount = -statementCount;
Program.statementCount() = statementCount;
};
	}
}

