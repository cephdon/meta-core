/* GenCyber2SLC.cpp generated on Sun Jul 21 09:54:27 2013
 */

#include "GenCyber2SLC.h"
#include <UmlExt.h>
#include "GReATSort.h"
#include "RTTGenerator.h"
#include "Cyber2SLC-gr_cmptempl.h"
#include "CGLog.h"

void TL_0::operator()( const Packets_t& dataflows_1, const Packets_t& projects_3)
{
#ifdef PRINT_INFO
	printLog( "TL_0" );
#endif
	if( ( !dataflows_1.empty())&& ( !projects_3.empty()))
		callGetProject_5a12( dataflows_1, projects_3);
}

void TL_0::callGetProject_5a12( const Packets_t& dataflows_6, const Packets_t& projects_9)
{
	Packets_t dataflows_8;
	Packets_t projects_b;
	GetProject_5 getProject_5;
	getProject_5( dataflows_6, projects_9, dataflows_8, projects_b);
	if( ( !dataflows_8.empty())&& ( !projects_b.empty()))
		callCheckPorts_5a15( dataflows_8, projects_b);
}

void TL_0::callCheckPorts_5a15( const Packets_t& comptypes_5585, const Packets_t& projects_5587)
{
	Packets_t dataflows_5589;
	Packets_t projects_558a;
	CheckPorts_5584 checkPorts_5584;
	checkPorts_5584( comptypes_5585, projects_5587, dataflows_5589, projects_558a);
	if( ( !dataflows_5589.empty())&& ( !projects_558a.empty()))
		callCreateTypes_5a18( dataflows_5589, projects_558a);
}

void TL_0::callCreateTypes_5a18( const Packets_t& dataflows_27, const Packets_t& projects_29)
{
	Packets_t dataflows_2b;
	Packets_t projects_2c;
	CreateTypes_26 createTypes_26;
	createTypes_26( dataflows_27, projects_29, dataflows_2b, projects_2c);
	if( ( !dataflows_2b.empty())&& ( !projects_2c.empty()))
		callMakeClasses_5a1b( dataflows_2b, projects_2c);
}

void TL_0::callMakeClasses_5a1b( const Packets_t& dataflows_117e, const Packets_t& projects_1180)
{
	Packets_t dataflows_1182;
	Packets_t projects_1183;
	MakeClasses_117d makeClasses_117d;
	makeClasses_117d( dataflows_117e, projects_1180, dataflows_1182, projects_1183);
	if( ( !dataflows_1182.empty())&& ( !projects_1183.empty()))
		callFinishClasses_5a1e( dataflows_1182, projects_1183);
}

void TL_0::callFinishClasses_5a1e( const Packets_t& dataflows_532a, const Packets_t& projects_532c)
{
	Packets_t dataflows_532e;
	Packets_t projects_532f;
	FinishClasses_5329 finishClasses_5329;
	finishClasses_5329( dataflows_532a, projects_532c, dataflows_532e, projects_532f);
	if( ( !dataflows_532e.empty())&& ( !projects_532f.empty()))
		callMergeClasses_5a21( dataflows_532e, projects_532f);
}

void TL_0::callMergeClasses_5a21( const Packets_t& dataflows_61a, const Packets_t& projects_61c)
{
	Packets_t dataflows_61e;
	Packets_t projects_61f;
	MergeClasses_619 mergeClasses_619;
	mergeClasses_619( dataflows_61a, projects_61c, dataflows_61e, projects_61f);
	if( ( !dataflows_61e.empty())&& ( !projects_61f.empty()))
		callConstructors_5a24( dataflows_61e, projects_61f);
}

void TL_0::callConstructors_5a24( const Packets_t& dataflows_cf5, const Packets_t& projects_cf7)
{
	Packets_t dataflows_cf9;
	Packets_t projects_cfa;
	Constructors_cf4 constructors_cf4;
	constructors_cf4( dataflows_cf5, projects_cf7, dataflows_cf9, projects_cfa);
}

void GetProject_5::operator()( const Packets_t& dataflows_6, const Packets_t& projects_9, Packets_t& dataflows_8, Packets_t& projects_b)
{
#ifdef PRINT_INFO
	printLog( "GetProject_5" );
#endif
	RTTGenerator::Instance()->generateRule(6, "GetProject");
	_dataflow_c= &dataflows_8;
	_project_d= &projects_b;
	processInputPackets( dataflows_6, projects_9);
	forwardInputs( );
}

bool GetProject_5::isInputUnique( const Udm::Object& dataflow_12, const Udm::Object& project_1b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itDataflow_14= _dataflow_e.begin(), itProject_1d= _project_17.begin(); itDataflow_14!= _dataflow_e.end(), itProject_1d!= _project_17.end(); ++itDataflow_14, ++itProject_1d)
	{
		if( ( *itDataflow_14== dataflow_12)&& ( *itProject_1d== project_1b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_dataflow_e.push_back( dataflow_12);
		_project_17.push_back( project_1b);
	}
	return isUnique;
}

bool GetProject_5::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetProject_5::processInputPackets( const Packets_t& dataflows_6, const Packets_t& projects_9)
{
	for( Packets_t::const_iterator itDataflow_f= dataflows_6.begin(), itProject_18= projects_9.begin(); itDataflow_f!= dataflows_6.end(), itProject_18!= projects_9.end(); ++itDataflow_f, ++itProject_18)
	{
		bool isUnique= isInputUnique( *itDataflow_f, *itProject_18);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itDataflow_f, *itProject_18);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetProject_5::patternMatcher( const Udm::Object& dataflow_10, const Udm::Object& project_19)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( dataflow_10.type(), CyberComposition::SimulinkWrapper::meta))
			continue;
		CyberComposition::SimulinkWrapper dataflow_15= CyberComposition::SimulinkWrapper::Cast( dataflow_10);
		if( false== Uml::IsDerivedFrom( project_19.type(), SFC::Project::meta))
			continue;
		SFC::Project project_1e= SFC::Project::Cast( project_19);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_23;
		if( !isValidBound(boundObjs_23, dataflow_15, true))
			continue;
		currMatch.dataflow_24= dataflow_15;
		if( !isValidBound(boundObjs_23, project_1e, true))
			continue;
		currMatch.project_25= project_1e;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void GetProject_5::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		CyberComposition::SimulinkWrapper& Dataflow= currMatch.dataflow_24;
		SFC::Project& Project= currMatch.project_25;
		{
SFCTypesManager::initSingleton( Project );
};
	}
}

void GetProject_5::forwardInputs()
{
	*_dataflow_c= _dataflow_e;
	*_project_d= _project_17;
}

void CreateTypes_26::operator()( const Packets_t& dataflows_27, const Packets_t& projects_29, Packets_t& dataflows_2b, Packets_t& projects_2c)
{
#ifdef PRINT_INFO
	printLog( "CreateTypes_26" );
#endif
	_dataflow_2d= &dataflows_2b;
	_project_2e= &projects_2c;
	_dataflow_2d->insert( _dataflow_2d->end(), dataflows_27.begin(), dataflows_27.end());
	_project_2e->insert( _project_2e->end(), projects_29.begin(), projects_29.end());
	if( ( !dataflows_27.empty())&& ( !projects_29.empty()))
		callGetTypes_60e( dataflows_27, projects_29);
}

void CreateTypes_26::callGetTypes_60e( const Packets_t& states_565, const Packets_t& projects_567)
{
	Packets_t typess_569;
	Packets_t projects_56a;
	GetTypes_564 getTypes_564;
	getTypes_564( states_565, projects_567, typess_569, projects_56a);
	if( ( !typess_569.empty())&& ( !projects_56a.empty()))
		callCreateTypesInner_611( typess_569, projects_56a);
}

void CreateTypes_26::callCreateTypesInner_611( const Packets_t& typess_30, const Packets_t& projects_32)
{
	Packets_t typess_34;
	Packets_t newStructs_35;
	CreateTypesInner_2f createTypesInner_2f;
	createTypesInner_2f( typess_30, projects_32, typess_34, newStructs_35);
	if( ( !typess_34.empty())&& ( !newStructs_35.empty()))
		callStructMembers_614( typess_34, newStructs_35);
}

void CreateTypes_26::callStructMembers_614( const Packets_t& typess_524, const Packets_t& newStructs_526)
{
	Packets_t newStructs_528;
	StructMembers_523 structMembers_523;
	structMembers_523( typess_524, newStructs_526, newStructs_528);
	if( ( !newStructs_528.empty()))
		callRegisterStruct_617( newStructs_528);
}

void CreateTypes_26::callRegisterStruct_617( const Packets_t& sfcStructs_554)
{
	RegisterStruct_553 registerStruct_553;
	registerStruct_553( sfcStructs_554);
}

void CreateTypesInner_2f::operator()( const Packets_t& typess_30, const Packets_t& projects_32, Packets_t& typess_34, Packets_t& newStructs_35)
{
#ifdef PRINT_INFO
	printLog( "CreateTypesInner_2f" );
#endif
	_types_36= &typess_34;
	_newStruct_37= &newStructs_35;
	for( Packets_t::const_iterator ittypes_39= typess_30.begin(), itproject_40= projects_32.begin(); ittypes_39!= typess_30.end(), itproject_40!= projects_32.end(); ++ittypes_39, ++itproject_40)
	{
		bool isUnique= isInputUnique( *ittypes_39, *itproject_40);
		if( !isUnique)
			continue;
		Packets_t onetypes_3d( 1, *ittypes_39);
		Packets_t oneproject_44( 1, *itproject_40);
		executeOne( onetypes_3d, oneproject_44);
	}
}

void CreateTypesInner_2f::executeOne( const Packets_t& typess_30, const Packets_t& projects_32)
{
	if( ( !typess_30.empty())&& ( !projects_32.empty()))
		callStructOrMatrix_51a( typess_30, projects_32);
}

bool CreateTypesInner_2f::isInputUnique( const Udm::Object& types_3a, const Udm::Object& project_41)
{
	bool isUnique= true;
	for( Packets_t::const_iterator ittypes_3c= _types_38.begin(), itproject_43= _project_3f.begin(); ittypes_3c!= _types_38.end(), itproject_43!= _project_3f.end(); ++ittypes_3c, ++itproject_43)
	{
		if( ( *ittypes_3c== types_3a)&& ( *itproject_43== project_41))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_types_38.push_back( types_3a);
		_project_3f.push_back( project_41);
	}
	return isUnique;
}

void CreateTypesInner_2f::callStructOrMatrix_51a( const Packets_t& typess_6d, const Packets_t& projects_6f)
{
	Packets_t typess_71;
	Packets_t projects_72;
	Packets_t typess_73;
	Packets_t projects_74;
	StructOrMatrix_6c structOrMatrix_6c;
	structOrMatrix_6c( typess_6d, projects_6f, typess_71, projects_72, typess_73, projects_74);
	if( ( !typess_73.empty())&& ( !projects_74.empty()))
		callCreateArrayOrBasicType_51d( typess_73, projects_74);
	if( ( !typess_71.empty())&& ( !projects_72.empty()))
		callCreateStructType_520( typess_71, projects_72);
}

void CreateTypesInner_2f::callCreateArrayOrBasicType_51d( const Packets_t& typess_d2, const Packets_t& projects_d4)
{
	CreateArrayOrBasicType_d1 createArrayOrBasicType_d1;
	createArrayOrBasicType_d1( typess_d2, projects_d4);
}

void CreateTypesInner_2f::callCreateStructType_520( const Packets_t& eSMoL_Structs_47, const Packets_t& projects_4b)
{
	Packets_t eSMoL_Structs_49;
	Packets_t sfc_Structs_4a;
	CreateStructType_46 createStructType_46;
	createStructType_46( eSMoL_Structs_47, projects_4b, eSMoL_Structs_49, sfc_Structs_4a);
	_types_36->insert( _types_36->end(), eSMoL_Structs_49.begin(), eSMoL_Structs_49.end());
	_newStruct_37->insert( _newStruct_37->end(), sfc_Structs_4a.begin(), sfc_Structs_4a.end());
}

void CreateStructType_46::operator()( const Packets_t& eSMoL_Structs_47, const Packets_t& projects_4b, Packets_t& eSMoL_Structs_49, Packets_t& sfc_Structs_4a)
{
#ifdef PRINT_INFO
	printLog( "CreateStructType_46" );
#endif
	RTTGenerator::Instance()->generateRule(20, "CreateStructType");
	_eSMoL_Struct_4d= &eSMoL_Structs_49;
	_sfc_Struct_4e= &sfc_Structs_4a;
	processInputPackets( eSMoL_Structs_47, projects_4b);
}

bool CreateStructType_46::isInputUnique( const Udm::Object& eSMoL_Struct_53, const Udm::Object& project_5c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itESMoL_Struct_55= _eSMoL_Struct_4f.begin(), itProject_5e= _project_58.begin(); itESMoL_Struct_55!= _eSMoL_Struct_4f.end(), itProject_5e!= _project_58.end(); ++itESMoL_Struct_55, ++itProject_5e)
	{
		if( ( *itESMoL_Struct_55== eSMoL_Struct_53)&& ( *itProject_5e== project_5c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_eSMoL_Struct_4f.push_back( eSMoL_Struct_53);
		_project_58.push_back( project_5c);
	}
	return isUnique;
}

bool CreateStructType_46::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateStructType_46::processInputPackets( const Packets_t& eSMoL_Structs_47, const Packets_t& projects_4b)
{
	for( Packets_t::const_iterator itESMoL_Struct_50= eSMoL_Structs_47.begin(), itProject_59= projects_4b.begin(); itESMoL_Struct_50!= eSMoL_Structs_47.end(), itProject_59!= projects_4b.end(); ++itESMoL_Struct_50, ++itProject_59)
	{
		bool isUnique= isInputUnique( *itESMoL_Struct_50, *itProject_59);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itESMoL_Struct_50, *itProject_59);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateStructType_46::patternMatcher( const Udm::Object& eSMoL_Struct_51, const Udm::Object& project_5a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( eSMoL_Struct_51.type(), CyberComposition::Simulink::TypeStruct::meta))
			continue;
		CyberComposition::Simulink::TypeStruct eSMoL_Struct_56= CyberComposition::Simulink::TypeStruct::Cast( eSMoL_Struct_51);
		if( false== Uml::IsDerivedFrom( project_5a.type(), SFC::Project::meta))
			continue;
		SFC::Project project_5f= SFC::Project::Cast( project_5a);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_64;
		if( !isValidBound(boundObjs_64, eSMoL_Struct_56, true))
			continue;
		currMatch.eSMoL_Struct_65= eSMoL_Struct_56;
		if( !isValidBound(boundObjs_64, project_5f, true))
			continue;
		currMatch.project_66= project_5f;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateStructType_46::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Struct newsfc_Struct_67= SFC::Struct::Create( currMatch.project_66, SFC::Project::meta_stmnt);
		CyberComposition::Simulink::TypeStruct& ESMoL_Struct= currMatch.eSMoL_Struct_65;
		SFC::Project& Project= currMatch.project_66;
		SFC::Struct& sfc_Struct= newsfc_Struct_67;
		{
__int64 sc = Project.statementCount();
sfc_Struct.statementIndex() = sc++;
Project.statementCount() = sc;
};
		{
sfc_Struct.memberCount() = ESMoL_Struct.MemberCount();
sfc_Struct.name() = ESMoL_Struct.name();
};
		newsfc_Struct_67.tb()+= currMatch.eSMoL_Struct_65;
		outputAppender( currMatch.eSMoL_Struct_65, newsfc_Struct_67);
	}
}

void CreateStructType_46::outputAppender( const CyberComposition::Simulink::TypeStruct& eSMoL_Struct_68, const SFC::Struct& sfc_Struct_6a)
{
	_eSMoL_Struct_4d->push_back( eSMoL_Struct_68);
	_sfc_Struct_4e->push_back( sfc_Struct_6a);
}

void StructOrMatrix_6c::operator()( const Packets_t& typess_6d, const Packets_t& projects_6f, Packets_t& typess_71, Packets_t& projects_72, Packets_t& typess_73, Packets_t& projects_74)
{
#ifdef PRINT_INFO
	printLog( "StructOrMatrix_6c" );
#endif
	_types_75= &typess_71;
	_project_76= &projects_72;
	_types_77= &typess_73;
	_project_78= &projects_74;
	for( Packets_t::const_iterator ittypes_7a= typess_6d.begin(), itproject_81= projects_6f.begin(); ittypes_7a!= typess_6d.end(), itproject_81!= projects_6f.end(); ++ittypes_7a, ++itproject_81)
	{
		bool isUnique= isInputUnique( *ittypes_7a, *itproject_81);
		if( !isUnique)
			continue;
		Packets_t onetypes_7e( 1, *ittypes_7a);
		Packets_t oneproject_85( 1, *itproject_81);
		executeOne( onetypes_7e, oneproject_85);
	}
}

void StructOrMatrix_6c::executeOne( const Packets_t& typess_6d, const Packets_t& projects_6f)
{
	Packets_t typeStructs_8a;
	Packets_t projects_8d;
	IsStruct_87 isStruct_87;
	bool isMatchIsStruct_87= isStruct_87( typess_6d, projects_6f, typeStructs_8a, projects_8d);
	_types_75->insert( _types_75->end(), typeStructs_8a.begin(), typeStructs_8a.end());
	_project_76->insert( _project_76->end(), projects_8d.begin(), projects_8d.end());
	Packets_t matrixs_af;
	Packets_t projects_b2;
	IsMatrix_ac isMatrix_ac;
	bool isMatchIsMatrix_ac= isMatrix_ac( typess_6d, projects_6f, matrixs_af, projects_b2);
	_types_77->insert( _types_77->end(), matrixs_af.begin(), matrixs_af.end());
	_project_78->insert( _project_78->end(), projects_b2.begin(), projects_b2.end());
}

bool StructOrMatrix_6c::isInputUnique( const Udm::Object& types_7b, const Udm::Object& project_82)
{
	bool isUnique= true;
	for( Packets_t::const_iterator ittypes_7d= _types_79.begin(), itproject_84= _project_80.begin(); ittypes_7d!= _types_79.end(), itproject_84!= _project_80.end(); ++ittypes_7d, ++itproject_84)
	{
		if( ( *ittypes_7d== types_7b)&& ( *itproject_84== project_82))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_types_79.push_back( types_7b);
		_project_80.push_back( project_82);
	}
	return isUnique;
}

bool IsStruct_87::operator()( const Packets_t& typeStructs_88, const Packets_t& projects_8b, Packets_t& typeStructs_8a, Packets_t& projects_8d)
{
#ifdef PRINT_INFO
	printLog( "IsStruct_87" );
#endif
	_typeStruct_8e= &typeStructs_8a;
	_project_8f= &projects_8d;
	processInputPackets( typeStructs_88, projects_8b);
	if( false== _matches.empty())
		return true;
	return false;
}

bool IsStruct_87::isInputUnique( const Udm::Object& typeStruct_94, const Udm::Object& project_9d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itTypeStruct_96= _typeStruct_90.begin(), itProject_9f= _project_99.begin(); itTypeStruct_96!= _typeStruct_90.end(), itProject_9f!= _project_99.end(); ++itTypeStruct_96, ++itProject_9f)
	{
		if( ( *itTypeStruct_96== typeStruct_94)&& ( *itProject_9f== project_9d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_typeStruct_90.push_back( typeStruct_94);
		_project_99.push_back( project_9d);
	}
	return isUnique;
}

bool IsStruct_87::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void IsStruct_87::processInputPackets( const Packets_t& typeStructs_88, const Packets_t& projects_8b)
{
	for( Packets_t::const_iterator itTypeStruct_91= typeStructs_88.begin(), itProject_9a= projects_8b.begin(); itTypeStruct_91!= typeStructs_88.end(), itProject_9a!= projects_8b.end(); ++itTypeStruct_91, ++itProject_9a)
	{
		bool isUnique= isInputUnique( *itTypeStruct_91, *itProject_9a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itTypeStruct_91, *itProject_9a);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.typeStruct_a6, currMatch.project_a7);
	}
}

bool IsStruct_87::patternMatcher( const Udm::Object& typeStruct_92, const Udm::Object& project_9b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( typeStruct_92.type(), CyberComposition::Simulink::TypeStruct::meta))
			continue;
		CyberComposition::Simulink::TypeStruct typeStruct_97= CyberComposition::Simulink::TypeStruct::Cast( typeStruct_92);
		if( false== Uml::IsDerivedFrom( project_9b.type(), SFC::Project::meta))
			continue;
		SFC::Project project_a0= SFC::Project::Cast( project_9b);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_a5;
		if( !isValidBound(boundObjs_a5, typeStruct_97, true))
			continue;
		currMatch.typeStruct_a6= typeStruct_97;
		if( !isValidBound(boundObjs_a5, project_a0, true))
			continue;
		currMatch.project_a7= project_a0;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void IsStruct_87::outputAppender( const CyberComposition::Simulink::TypeStruct& typeStruct_a8, const SFC::Project& project_aa)
{
	_typeStruct_8e->push_back( typeStruct_a8);
	_project_8f->push_back( project_aa);
}

bool IsMatrix_ac::operator()( const Packets_t& matrixs_ad, const Packets_t& projects_b0, Packets_t& matrixs_af, Packets_t& projects_b2)
{
#ifdef PRINT_INFO
	printLog( "IsMatrix_ac" );
#endif
	_matrix_b3= &matrixs_af;
	_project_b4= &projects_b2;
	processInputPackets( matrixs_ad, projects_b0);
	if( false== _matches.empty())
		return true;
	return false;
}

bool IsMatrix_ac::isInputUnique( const Udm::Object& matrix_b9, const Udm::Object& project_c2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_bb= _matrix_b5.begin(), itProject_c4= _project_be.begin(); itMatrix_bb!= _matrix_b5.end(), itProject_c4!= _project_be.end(); ++itMatrix_bb, ++itProject_c4)
	{
		if( ( *itMatrix_bb== matrix_b9)&& ( *itProject_c4== project_c2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_b5.push_back( matrix_b9);
		_project_be.push_back( project_c2);
	}
	return isUnique;
}

bool IsMatrix_ac::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void IsMatrix_ac::processInputPackets( const Packets_t& matrixs_ad, const Packets_t& projects_b0)
{
	for( Packets_t::const_iterator itMatrix_b6= matrixs_ad.begin(), itProject_bf= projects_b0.begin(); itMatrix_b6!= matrixs_ad.end(), itProject_bf!= projects_b0.end(); ++itMatrix_b6, ++itProject_bf)
	{
		bool isUnique= isInputUnique( *itMatrix_b6, *itProject_bf);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_b6, *itProject_bf);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_cb, currMatch.project_cc);
	}
}

bool IsMatrix_ac::patternMatcher( const Udm::Object& matrix_b7, const Udm::Object& project_c0)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_b7.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_bc= CyberComposition::Simulink::SF_Matrix::Cast( matrix_b7);
		if( false== Uml::IsDerivedFrom( project_c0.type(), SFC::Project::meta))
			continue;
		SFC::Project project_c5= SFC::Project::Cast( project_c0);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_ca;
		if( !isValidBound(boundObjs_ca, matrix_bc, true))
			continue;
		currMatch.matrix_cb= matrix_bc;
		if( !isValidBound(boundObjs_ca, project_c5, true))
			continue;
		currMatch.project_cc= project_c5;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void IsMatrix_ac::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_cd, const SFC::Project& project_cf)
{
	_matrix_b3->push_back( matrix_cd);
	_project_b4->push_back( project_cf);
}

void CreateArrayOrBasicType_d1::operator()( const Packets_t& typess_d2, const Packets_t& projects_d4)
{
#ifdef PRINT_INFO
	printLog( "CreateArrayOrBasicType_d1" );
#endif
	if( ( !typess_d2.empty())&& ( !projects_d4.empty()))
		callDimensionTest_508( typess_d2, projects_d4);
}

void CreateArrayOrBasicType_d1::callDimensionTest_508( const Packets_t& typess_d7, const Packets_t& projects_d9)
{
	Packets_t typess_db;
	Packets_t projects_dc;
	Packets_t typess_dd;
	Packets_t projects_de;
	Packets_t typess_df;
	Packets_t projects_e0;
	DimensionTest_d6 dimensionTest_d6;
	dimensionTest_d6( typess_d7, projects_d9, typess_db, projects_dc, typess_dd, projects_de, typess_df, projects_e0);
	if( ( !typess_db.empty())&& ( !projects_dc.empty()))
		callProcessScalar_50b( typess_db, projects_dc);
	if( ( !typess_dd.empty())&& ( !projects_de.empty()))
		callProcessColumn_50e( typess_dd, projects_de);
	if( ( !typess_df.empty())&& ( !projects_e0.empty()))
		callProcessOther_511( typess_df, projects_e0);
}

void CreateArrayOrBasicType_d1::callProcessScalar_50b( const Packets_t& typess_169, const Packets_t& projects_16b)
{
	Packets_t typess_16d;
	Packets_t basictypes_16e;
	Packets_t projects_16f;
	ProcessScalar_168 processScalar_168;
	processScalar_168( typess_169, projects_16b, typess_16d, basictypes_16e, projects_16f);
	if( ( !typess_16d.empty())&& ( !basictypes_16e.empty()))
		callRegisterType_514( typess_16d, basictypes_16e);
}

void CreateArrayOrBasicType_d1::callProcessColumn_50e( const Packets_t& typess_243, const Packets_t& projects_245)
{
	Packets_t typess_247;
	Packets_t array1s_248;
	Packets_t projects_249;
	ProcessColumn_242 processColumn_242;
	processColumn_242( typess_243, projects_245, typess_247, array1s_248, projects_249);
	if( ( !typess_247.empty())&& ( !array1s_248.empty()))
		callRegisterType_514( typess_247, array1s_248);
}

void CreateArrayOrBasicType_d1::callProcessOther_511( const Packets_t& typess_37d, const Packets_t& projects_37f)
{
	Packets_t typess_381;
	Packets_t array1s_382;
	Packets_t projects_383;
	ProcessOther_37c processOther_37c;
	processOther_37c( typess_37d, projects_37f, typess_381, array1s_382, projects_383);
	if( ( !typess_381.empty())&& ( !array1s_382.empty()))
		callRegisterType_514( typess_381, array1s_382);
}

void CreateArrayOrBasicType_d1::callRegisterType_514( const Packets_t& matrixs_4e8, const Packets_t& dTs_4eb)
{
	Packets_t matrixs_4ea;
	Packets_t dTs_4ed;
	RegisterType_4e7 registerType_4e7;
	registerType_4e7( matrixs_4e8, dTs_4eb, matrixs_4ea, dTs_4ed);
	if( ( !matrixs_4ea.empty())&& ( !dTs_4ed.empty()))
		callMakeAssoc_517( matrixs_4ea, dTs_4ed);
}

void CreateArrayOrBasicType_d1::callMakeAssoc_517( const Packets_t& matrixs_4cb, const Packets_t& dTs_4cd)
{
	MakeAssoc_4ca makeAssoc_4ca;
	makeAssoc_4ca( matrixs_4cb, dTs_4cd);
}

void DimensionTest_d6::operator()( const Packets_t& typess_d7, const Packets_t& projects_d9, Packets_t& typess_db, Packets_t& projects_dc, Packets_t& typess_dd, Packets_t& projects_de, Packets_t& typess_df, Packets_t& projects_e0)
{
#ifdef PRINT_INFO
	printLog( "DimensionTest_d6" );
#endif
	_types_e1= &typess_db;
	_project_e2= &projects_dc;
	_types_e3= &typess_dd;
	_project_e4= &projects_de;
	_types_e5= &typess_df;
	_project_e6= &projects_e0;
	for( Packets_t::const_iterator ittypes_e8= typess_d7.begin(), itproject_ef= projects_d9.begin(); ittypes_e8!= typess_d7.end(), itproject_ef!= projects_d9.end(); ++ittypes_e8, ++itproject_ef)
	{
		bool isUnique= isInputUnique( *ittypes_e8, *itproject_ef);
		if( !isUnique)
			continue;
		Packets_t onetypes_ec( 1, *ittypes_e8);
		Packets_t oneproject_f3( 1, *itproject_ef);
		executeOne( onetypes_ec, oneproject_f3);
	}
}

void DimensionTest_d6::executeOne( const Packets_t& typess_d7, const Packets_t& projects_d9)
{
	Packets_t matrixs_f8;
	Packets_t projects_fb;
	Scalar_f5 scalar_f5;
	bool isMatchScalar_f5= scalar_f5( typess_d7, projects_d9, matrixs_f8, projects_fb);
	_types_e1->insert( _types_e1->end(), matrixs_f8.begin(), matrixs_f8.end());
	_project_e2->insert( _project_e2->end(), projects_fb.begin(), projects_fb.end());
	if( isMatchScalar_f5)
		return;
	Packets_t matrixs_11f;
	Packets_t projects_122;
	ColumnVector_11c columnVector_11c;
	bool isMatchColumnVector_11c= columnVector_11c( typess_d7, projects_d9, matrixs_11f, projects_122);
	_types_e3->insert( _types_e3->end(), matrixs_11f.begin(), matrixs_11f.end());
	_project_e4->insert( _project_e4->end(), projects_122.begin(), projects_122.end());
	if( isMatchColumnVector_11c)
		return;
	Packets_t matrixs_146;
	Packets_t projects_149;
	Other_143 other_143;
	bool isMatchOther_143= other_143( typess_d7, projects_d9, matrixs_146, projects_149);
	_types_e5->insert( _types_e5->end(), matrixs_146.begin(), matrixs_146.end());
	_project_e6->insert( _project_e6->end(), projects_149.begin(), projects_149.end());
	if( isMatchOther_143)
		return;
}

bool DimensionTest_d6::isInputUnique( const Udm::Object& types_e9, const Udm::Object& project_f0)
{
	bool isUnique= true;
	for( Packets_t::const_iterator ittypes_eb= _types_e7.begin(), itproject_f2= _project_ee.begin(); ittypes_eb!= _types_e7.end(), itproject_f2!= _project_ee.end(); ++ittypes_eb, ++itproject_f2)
	{
		if( ( *ittypes_eb== types_e9)&& ( *itproject_f2== project_f0))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_types_e7.push_back( types_e9);
		_project_ee.push_back( project_f0);
	}
	return isUnique;
}

bool Scalar_f5::operator()( const Packets_t& matrixs_f6, const Packets_t& projects_f9, Packets_t& matrixs_f8, Packets_t& projects_fb)
{
#ifdef PRINT_INFO
	printLog( "Scalar_f5" );
#endif
	_matrix_fc= &matrixs_f8;
	_project_fd= &projects_fb;
	processInputPackets( matrixs_f6, projects_f9);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Scalar_f5::isInputUnique( const Udm::Object& matrix_102, const Udm::Object& project_10b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_104= _matrix_fe.begin(), itProject_10d= _project_107.begin(); itMatrix_104!= _matrix_fe.end(), itProject_10d!= _project_107.end(); ++itMatrix_104, ++itProject_10d)
	{
		if( ( *itMatrix_104== matrix_102)&& ( *itProject_10d== project_10b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_fe.push_back( matrix_102);
		_project_107.push_back( project_10b);
	}
	return isUnique;
}

bool Scalar_f5::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool Scalar_f5::isGuardTrue( CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard = Matrix.rows() == 1 && Matrix.columns() == 1;;
	return Gz_guard;
}

void Scalar_f5::processInputPackets( const Packets_t& matrixs_f6, const Packets_t& projects_f9)
{
	for( Packets_t::const_iterator itMatrix_ff= matrixs_f6.begin(), itProject_108= projects_f9.begin(); itMatrix_ff!= matrixs_f6.end(), itProject_108!= projects_f9.end(); ++itMatrix_ff, ++itProject_108)
	{
		bool isUnique= isInputUnique( *itMatrix_ff, *itProject_108);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_ff, *itProject_108);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_114, currMatch.project_115);
	}
}

bool Scalar_f5::patternMatcher( const Udm::Object& matrix_100, const Udm::Object& project_109)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_100.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_105= CyberComposition::Simulink::SF_Matrix::Cast( matrix_100);
		if( false== Uml::IsDerivedFrom( project_109.type(), SFC::Project::meta))
			continue;
		SFC::Project project_10e= SFC::Project::Cast( project_109);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_113;
		if( !isValidBound(boundObjs_113, matrix_105, true))
			continue;
		currMatch.matrix_114= matrix_105;
		if( !isValidBound(boundObjs_113, project_10e, true))
			continue;
		currMatch.project_115= project_10e;
		bool Gz_guard= isGuardTrue( currMatch.matrix_114, currMatch.project_115);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Scalar_f5::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_118, const SFC::Project& project_11a)
{
	_matrix_fc->push_back( matrix_118);
	_project_fd->push_back( project_11a);
}

bool ColumnVector_11c::operator()( const Packets_t& matrixs_11d, const Packets_t& projects_120, Packets_t& matrixs_11f, Packets_t& projects_122)
{
#ifdef PRINT_INFO
	printLog( "ColumnVector_11c" );
#endif
	_matrix_123= &matrixs_11f;
	_project_124= &projects_122;
	processInputPackets( matrixs_11d, projects_120);
	if( false== _matches.empty())
		return true;
	return false;
}

bool ColumnVector_11c::isInputUnique( const Udm::Object& matrix_129, const Udm::Object& project_132)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_12b= _matrix_125.begin(), itProject_134= _project_12e.begin(); itMatrix_12b!= _matrix_125.end(), itProject_134!= _project_12e.end(); ++itMatrix_12b, ++itProject_134)
	{
		if( ( *itMatrix_12b== matrix_129)&& ( *itProject_134== project_132))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_125.push_back( matrix_129);
		_project_12e.push_back( project_132);
	}
	return isUnique;
}

bool ColumnVector_11c::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool ColumnVector_11c::isGuardTrue( CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard = Matrix.rows() != 1 && Matrix.columns() == 1;;
	return Gz_guard;
}

void ColumnVector_11c::processInputPackets( const Packets_t& matrixs_11d, const Packets_t& projects_120)
{
	for( Packets_t::const_iterator itMatrix_126= matrixs_11d.begin(), itProject_12f= projects_120.begin(); itMatrix_126!= matrixs_11d.end(), itProject_12f!= projects_120.end(); ++itMatrix_126, ++itProject_12f)
	{
		bool isUnique= isInputUnique( *itMatrix_126, *itProject_12f);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_126, *itProject_12f);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_13b, currMatch.project_13c);
	}
}

bool ColumnVector_11c::patternMatcher( const Udm::Object& matrix_127, const Udm::Object& project_130)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_127.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_12c= CyberComposition::Simulink::SF_Matrix::Cast( matrix_127);
		if( false== Uml::IsDerivedFrom( project_130.type(), SFC::Project::meta))
			continue;
		SFC::Project project_135= SFC::Project::Cast( project_130);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_13a;
		if( !isValidBound(boundObjs_13a, matrix_12c, true))
			continue;
		currMatch.matrix_13b= matrix_12c;
		if( !isValidBound(boundObjs_13a, project_135, true))
			continue;
		currMatch.project_13c= project_135;
		bool Gz_guard= isGuardTrue( currMatch.matrix_13b, currMatch.project_13c);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void ColumnVector_11c::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_13f, const SFC::Project& project_141)
{
	_matrix_123->push_back( matrix_13f);
	_project_124->push_back( project_141);
}

bool Other_143::operator()( const Packets_t& matrixs_144, const Packets_t& projects_147, Packets_t& matrixs_146, Packets_t& projects_149)
{
#ifdef PRINT_INFO
	printLog( "Other_143" );
#endif
	_matrix_14a= &matrixs_146;
	_project_14b= &projects_149;
	processInputPackets( matrixs_144, projects_147);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Other_143::isInputUnique( const Udm::Object& matrix_150, const Udm::Object& project_159)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_152= _matrix_14c.begin(), itProject_15b= _project_155.begin(); itMatrix_152!= _matrix_14c.end(), itProject_15b!= _project_155.end(); ++itMatrix_152, ++itProject_15b)
	{
		if( ( *itMatrix_152== matrix_150)&& ( *itProject_15b== project_159))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_14c.push_back( matrix_150);
		_project_155.push_back( project_159);
	}
	return isUnique;
}

bool Other_143::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Other_143::processInputPackets( const Packets_t& matrixs_144, const Packets_t& projects_147)
{
	for( Packets_t::const_iterator itMatrix_14d= matrixs_144.begin(), itProject_156= projects_147.begin(); itMatrix_14d!= matrixs_144.end(), itProject_156!= projects_147.end(); ++itMatrix_14d, ++itProject_156)
	{
		bool isUnique= isInputUnique( *itMatrix_14d, *itProject_156);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_14d, *itProject_156);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_162, currMatch.project_163);
	}
}

bool Other_143::patternMatcher( const Udm::Object& matrix_14e, const Udm::Object& project_157)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_14e.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_153= CyberComposition::Simulink::SF_Matrix::Cast( matrix_14e);
		if( false== Uml::IsDerivedFrom( project_157.type(), SFC::Project::meta))
			continue;
		SFC::Project project_15c= SFC::Project::Cast( project_157);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_161;
		if( !isValidBound(boundObjs_161, matrix_153, true))
			continue;
		currMatch.matrix_162= matrix_153;
		if( !isValidBound(boundObjs_161, project_15c, true))
			continue;
		currMatch.project_163= project_15c;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Other_143::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_164, const SFC::Project& project_166)
{
	_matrix_14a->push_back( matrix_164);
	_project_14b->push_back( project_166);
}

void ProcessScalar_168::operator()( const Packets_t& typess_169, const Packets_t& projects_16b, Packets_t& typess_16d, Packets_t& basictypes_16e, Packets_t& projects_16f)
{
#ifdef PRINT_INFO
	printLog( "ProcessScalar_168" );
#endif
	_types_170= &typess_16d;
	_basictype_171= &basictypes_16e;
	_project_172= &projects_16f;
	if( ( !typess_169.empty())&& ( !projects_16b.empty()))
		callGetBasicType_239( typess_169, projects_16b);
}

void ProcessScalar_168::callGetBasicType_239( const Packets_t& typess_174, const Packets_t& projects_176)
{
	Packets_t typess_178;
	Packets_t projectss_179;
	Packets_t typess_17a;
	Packets_t projectss_17b;
	GetBasicType_173 getBasicType_173;
	getBasicType_173( typess_174, projects_176, typess_178, projectss_179, typess_17a, projectss_17b);
	if( ( !typess_178.empty())&& ( !projectss_179.empty()))
		callUseBasicType_23c( typess_178, projectss_179);
	if( ( !typess_17a.empty())&& ( !projectss_17b.empty()))
		callCreateBasicType_23f( typess_17a, projectss_17b);
}

void ProcessScalar_168::callUseBasicType_23c( const Packets_t& matrixs_1e0, const Packets_t& projects_1e4)
{
	Packets_t matrixs_1e2;
	Packets_t basicTypes_1e3;
	Packets_t projects_1e6;
	UseBasicType_1df useBasicType_1df;
	useBasicType_1df( matrixs_1e0, projects_1e4, matrixs_1e2, basicTypes_1e3, projects_1e6);
	_types_170->insert( _types_170->end(), matrixs_1e2.begin(), matrixs_1e2.end());
	_basictype_171->insert( _basictype_171->end(), basicTypes_1e3.begin(), basicTypes_1e3.end());
	_project_172->insert( _project_172->end(), projects_1e6.begin(), projects_1e6.end());
}

void ProcessScalar_168::callCreateBasicType_23f( const Packets_t& matrixs_210, const Packets_t& projects_214)
{
	Packets_t matrixs_212;
	Packets_t basicTypes_213;
	Packets_t projects_216;
	CreateBasicType_20f createBasicType_20f;
	createBasicType_20f( matrixs_210, projects_214, matrixs_212, basicTypes_213, projects_216);
	_types_170->insert( _types_170->end(), matrixs_212.begin(), matrixs_212.end());
	_basictype_171->insert( _basictype_171->end(), basicTypes_213.begin(), basicTypes_213.end());
	_project_172->insert( _project_172->end(), projects_216.begin(), projects_216.end());
}

void GetBasicType_173::operator()( const Packets_t& typess_174, const Packets_t& projects_176, Packets_t& typess_178, Packets_t& projectss_179, Packets_t& typess_17a, Packets_t& projectss_17b)
{
#ifdef PRINT_INFO
	printLog( "GetBasicType_173" );
#endif
	_types_17c= &typess_178;
	_projects_17d= &projectss_179;
	_types_17e= &typess_17a;
	_projects_17f= &projectss_17b;
	for( Packets_t::const_iterator ittypes_181= typess_174.begin(), itproject_188= projects_176.begin(); ittypes_181!= typess_174.end(), itproject_188!= projects_176.end(); ++ittypes_181, ++itproject_188)
	{
		bool isUnique= isInputUnique( *ittypes_181, *itproject_188);
		if( !isUnique)
			continue;
		Packets_t onetypes_185( 1, *ittypes_181);
		Packets_t oneproject_18c( 1, *itproject_188);
		executeOne( onetypes_185, oneproject_18c);
	}
}

void GetBasicType_173::executeOne( const Packets_t& typess_174, const Packets_t& projects_176)
{
	Packets_t matrixs_191;
	Packets_t projects_194;
	BasicTypeExists_18e basicTypeExists_18e;
	bool isMatchBasicTypeExists_18e= basicTypeExists_18e( typess_174, projects_176, matrixs_191, projects_194);
	_types_17c->insert( _types_17c->end(), matrixs_191.begin(), matrixs_191.end());
	_projects_17d->insert( _projects_17d->end(), projects_194.begin(), projects_194.end());
	if( isMatchBasicTypeExists_18e)
		return;
	Packets_t matrixs_1bd;
	Packets_t projects_1c0;
	Otherwise_1ba otherwise_1ba;
	bool isMatchOtherwise_1ba= otherwise_1ba( typess_174, projects_176, matrixs_1bd, projects_1c0);
	_types_17e->insert( _types_17e->end(), matrixs_1bd.begin(), matrixs_1bd.end());
	_projects_17f->insert( _projects_17f->end(), projects_1c0.begin(), projects_1c0.end());
}

bool GetBasicType_173::isInputUnique( const Udm::Object& types_182, const Udm::Object& project_189)
{
	bool isUnique= true;
	for( Packets_t::const_iterator ittypes_184= _types_180.begin(), itproject_18b= _project_187.begin(); ittypes_184!= _types_180.end(), itproject_18b!= _project_187.end(); ++ittypes_184, ++itproject_18b)
	{
		if( ( *ittypes_184== types_182)&& ( *itproject_18b== project_189))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_types_180.push_back( types_182);
		_project_187.push_back( project_189);
	}
	return isUnique;
}

bool BasicTypeExists_18e::operator()( const Packets_t& matrixs_18f, const Packets_t& projects_192, Packets_t& matrixs_191, Packets_t& projects_194)
{
#ifdef PRINT_INFO
	printLog( "BasicTypeExists_18e" );
#endif
	_matrix_195= &matrixs_191;
	_project_196= &projects_194;
	processInputPackets( matrixs_18f, projects_192);
	if( false== _matches.empty())
		return true;
	return false;
}

bool BasicTypeExists_18e::isInputUnique( const Udm::Object& matrix_19b, const Udm::Object& project_1a4)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_19d= _matrix_197.begin(), itProject_1a6= _project_1a0.begin(); itMatrix_19d!= _matrix_197.end(), itProject_1a6!= _project_1a0.end(); ++itMatrix_19d, ++itProject_1a6)
	{
		if( ( *itMatrix_19d== matrix_19b)&& ( *itProject_1a6== project_1a4))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_197.push_back( matrix_19b);
		_project_1a0.push_back( project_1a4);
	}
	return isUnique;
}

bool BasicTypeExists_18e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool BasicTypeExists_18e::isGuardTrue( SFC::BasicType& BasicType, CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( Matrix.Type() ) ==
 static_cast< std::string >( BasicType.name() );;
	return Gz_guard;
}

void BasicTypeExists_18e::processInputPackets( const Packets_t& matrixs_18f, const Packets_t& projects_192)
{
	for( Packets_t::const_iterator itMatrix_198= matrixs_18f.begin(), itProject_1a1= projects_192.begin(); itMatrix_198!= matrixs_18f.end(), itProject_1a1!= projects_192.end(); ++itMatrix_198, ++itProject_1a1)
	{
		bool isUnique= isInputUnique( *itMatrix_198, *itProject_1a1);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_198, *itProject_1a1);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_1b0, currMatch.project_1b1);
	}
}

bool BasicTypeExists_18e::patternMatcher( const Udm::Object& matrix_199, const Udm::Object& project_1a2)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_199.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_19e= CyberComposition::Simulink::SF_Matrix::Cast( matrix_199);
		if( false== Uml::IsDerivedFrom( project_1a2.type(), SFC::Project::meta))
			continue;
		SFC::Project project_1a7= SFC::Project::Cast( project_1a2);
		set< SFC::BasicType> basicTypes_1a9= project_1a7.BasicType_kind_children();
		for( set< SFC::BasicType>::const_iterator itBasicType_1aa= basicTypes_1a9.begin(); itBasicType_1aa!= basicTypes_1a9.end(); ++itBasicType_1aa)
		{
			SFC::BasicType currBasicType_1ab= *itBasicType_1aa;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1af;
			if( !isValidBound(boundObjs_1af, matrix_19e, true))
				continue;
			currMatch.matrix_1b0= matrix_19e;
			if( !isValidBound(boundObjs_1af, project_1a7, true))
				continue;
			currMatch.project_1b1= project_1a7;
			if( !isValidBound(boundObjs_1af, currBasicType_1ab, false))
				continue;
			currMatch.basicType_1b2= currBasicType_1ab;
			bool Gz_guard= isGuardTrue( currMatch.basicType_1b2, currMatch.matrix_1b0, currMatch.project_1b1);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void BasicTypeExists_18e::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_1b6, const SFC::Project& project_1b8)
{
	_matrix_195->push_back( matrix_1b6);
	_project_196->push_back( project_1b8);
}

bool Otherwise_1ba::operator()( const Packets_t& matrixs_1bb, const Packets_t& projects_1be, Packets_t& matrixs_1bd, Packets_t& projects_1c0)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_1ba" );
#endif
	_matrix_1c1= &matrixs_1bd;
	_project_1c2= &projects_1c0;
	processInputPackets( matrixs_1bb, projects_1be);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_1ba::isInputUnique( const Udm::Object& matrix_1c7, const Udm::Object& project_1d0)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_1c9= _matrix_1c3.begin(), itProject_1d2= _project_1cc.begin(); itMatrix_1c9!= _matrix_1c3.end(), itProject_1d2!= _project_1cc.end(); ++itMatrix_1c9, ++itProject_1d2)
	{
		if( ( *itMatrix_1c9== matrix_1c7)&& ( *itProject_1d2== project_1d0))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_1c3.push_back( matrix_1c7);
		_project_1cc.push_back( project_1d0);
	}
	return isUnique;
}

bool Otherwise_1ba::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_1ba::processInputPackets( const Packets_t& matrixs_1bb, const Packets_t& projects_1be)
{
	for( Packets_t::const_iterator itMatrix_1c4= matrixs_1bb.begin(), itProject_1cd= projects_1be.begin(); itMatrix_1c4!= matrixs_1bb.end(), itProject_1cd!= projects_1be.end(); ++itMatrix_1c4, ++itProject_1cd)
	{
		bool isUnique= isInputUnique( *itMatrix_1c4, *itProject_1cd);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_1c4, *itProject_1cd);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_1d9, currMatch.project_1da);
	}
}

bool Otherwise_1ba::patternMatcher( const Udm::Object& matrix_1c5, const Udm::Object& project_1ce)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_1c5.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_1ca= CyberComposition::Simulink::SF_Matrix::Cast( matrix_1c5);
		if( false== Uml::IsDerivedFrom( project_1ce.type(), SFC::Project::meta))
			continue;
		SFC::Project project_1d3= SFC::Project::Cast( project_1ce);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1d8;
		if( !isValidBound(boundObjs_1d8, matrix_1ca, true))
			continue;
		currMatch.matrix_1d9= matrix_1ca;
		if( !isValidBound(boundObjs_1d8, project_1d3, true))
			continue;
		currMatch.project_1da= project_1d3;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_1ba::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_1db, const SFC::Project& project_1dd)
{
	_matrix_1c1->push_back( matrix_1db);
	_project_1c2->push_back( project_1dd);
}

void UseBasicType_1df::operator()( const Packets_t& matrixs_1e0, const Packets_t& projects_1e4, Packets_t& matrixs_1e2, Packets_t& basicTypes_1e3, Packets_t& projects_1e6)
{
#ifdef PRINT_INFO
	printLog( "UseBasicType_1df" );
#endif
	RTTGenerator::Instance()->generateRule(83, "UseBasicType");
	_matrix_1e7= &matrixs_1e2;
	_basicType_1e8= &basicTypes_1e3;
	_project_1e9= &projects_1e6;
	processInputPackets( matrixs_1e0, projects_1e4);
}

bool UseBasicType_1df::isInputUnique( const Udm::Object& matrix_1ee, const Udm::Object& project_1f7)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_1f0= _matrix_1ea.begin(), itProject_1f9= _project_1f3.begin(); itMatrix_1f0!= _matrix_1ea.end(), itProject_1f9!= _project_1f3.end(); ++itMatrix_1f0, ++itProject_1f9)
	{
		if( ( *itMatrix_1f0== matrix_1ee)&& ( *itProject_1f9== project_1f7))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_1ea.push_back( matrix_1ee);
		_project_1f3.push_back( project_1f7);
	}
	return isUnique;
}

bool UseBasicType_1df::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool UseBasicType_1df::isGuardTrue( SFC::BasicType& BasicType, CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( Matrix.Type() ) ==
 static_cast< std::string >( BasicType.name() );;
	return Gz_guard;
}

void UseBasicType_1df::processInputPackets( const Packets_t& matrixs_1e0, const Packets_t& projects_1e4)
{
	for( Packets_t::const_iterator itMatrix_1eb= matrixs_1e0.begin(), itProject_1f4= projects_1e4.begin(); itMatrix_1eb!= matrixs_1e0.end(), itProject_1f4!= projects_1e4.end(); ++itMatrix_1eb, ++itProject_1f4)
	{
		bool isUnique= isInputUnique( *itMatrix_1eb, *itProject_1f4);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_1eb, *itProject_1f4);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool UseBasicType_1df::patternMatcher( const Udm::Object& matrix_1ec, const Udm::Object& project_1f5)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_1ec.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_1f1= CyberComposition::Simulink::SF_Matrix::Cast( matrix_1ec);
		if( false== Uml::IsDerivedFrom( project_1f5.type(), SFC::Project::meta))
			continue;
		SFC::Project project_1fa= SFC::Project::Cast( project_1f5);
		set< SFC::BasicType> basicTypes_1fc= project_1fa.BasicType_kind_children();
		for( set< SFC::BasicType>::const_iterator itBasicType_1fd= basicTypes_1fc.begin(); itBasicType_1fd!= basicTypes_1fc.end(); ++itBasicType_1fd)
		{
			SFC::BasicType currBasicType_1fe= *itBasicType_1fd;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_202;
			if( !isValidBound(boundObjs_202, matrix_1f1, true))
				continue;
			currMatch.matrix_203= matrix_1f1;
			if( !isValidBound(boundObjs_202, project_1fa, true))
				continue;
			currMatch.project_204= project_1fa;
			if( !isValidBound(boundObjs_202, currBasicType_1fe, false))
				continue;
			currMatch.basicType_205= currBasicType_1fe;
			bool Gz_guard= isGuardTrue( currMatch.basicType_205, currMatch.matrix_203, currMatch.project_204);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void UseBasicType_1df::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_203, currMatch.basicType_205, currMatch.project_204);
	}
}

void UseBasicType_1df::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_209, const SFC::BasicType& basicType_20b, const SFC::Project& project_20d)
{
	_matrix_1e7->push_back( matrix_209);
	_basicType_1e8->push_back( basicType_20b);
	_project_1e9->push_back( project_20d);
}

void CreateBasicType_20f::operator()( const Packets_t& matrixs_210, const Packets_t& projects_214, Packets_t& matrixs_212, Packets_t& basicTypes_213, Packets_t& projects_216)
{
#ifdef PRINT_INFO
	printLog( "CreateBasicType_20f" );
#endif
	RTTGenerator::Instance()->generateRule(88, "CreateBasicType");
	_matrix_217= &matrixs_212;
	_basicType_218= &basicTypes_213;
	_project_219= &projects_216;
	processInputPackets( matrixs_210, projects_214);
}

bool CreateBasicType_20f::isInputUnique( const Udm::Object& matrix_21e, const Udm::Object& project_227)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_220= _matrix_21a.begin(), itProject_229= _project_223.begin(); itMatrix_220!= _matrix_21a.end(), itProject_229!= _project_223.end(); ++itMatrix_220, ++itProject_229)
	{
		if( ( *itMatrix_220== matrix_21e)&& ( *itProject_229== project_227))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_21a.push_back( matrix_21e);
		_project_223.push_back( project_227);
	}
	return isUnique;
}

bool CreateBasicType_20f::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateBasicType_20f::processInputPackets( const Packets_t& matrixs_210, const Packets_t& projects_214)
{
	for( Packets_t::const_iterator itMatrix_21b= matrixs_210.begin(), itProject_224= projects_214.begin(); itMatrix_21b!= matrixs_210.end(), itProject_224!= projects_214.end(); ++itMatrix_21b, ++itProject_224)
	{
		bool isUnique= isInputUnique( *itMatrix_21b, *itProject_224);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_21b, *itProject_224);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateBasicType_20f::patternMatcher( const Udm::Object& matrix_21c, const Udm::Object& project_225)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_21c.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_221= CyberComposition::Simulink::SF_Matrix::Cast( matrix_21c);
		if( false== Uml::IsDerivedFrom( project_225.type(), SFC::Project::meta))
			continue;
		SFC::Project project_22a= SFC::Project::Cast( project_225);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_22f;
		if( !isValidBound(boundObjs_22f, matrix_221, true))
			continue;
		currMatch.matrix_230= matrix_221;
		if( !isValidBound(boundObjs_22f, project_22a, true))
			continue;
		currMatch.project_231= project_22a;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateBasicType_20f::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BasicType newBasicType_232= SFC::BasicType::Create( currMatch.project_231);
		SFC::BasicType& BasicType= newBasicType_232;
		CyberComposition::Simulink::SF_Matrix& Matrix= currMatch.matrix_230;
		SFC::Project& Project= currMatch.project_231;
		{
__int64 statementCount = Project.statementCount();
BasicType.statementIndex() = statementCount++;
Project.statementCount() = statementCount;

BasicType.name() = Matrix.Type();

};
		outputAppender( currMatch.matrix_230, newBasicType_232, currMatch.project_231);
	}
}

void CreateBasicType_20f::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_233, const SFC::BasicType& basicType_235, const SFC::Project& project_237)
{
	_matrix_217->push_back( matrix_233);
	_basicType_218->push_back( basicType_235);
	_project_219->push_back( project_237);
}

void ProcessColumn_242::operator()( const Packets_t& typess_243, const Packets_t& projects_245, Packets_t& typess_247, Packets_t& array1s_248, Packets_t& projects_249)
{
#ifdef PRINT_INFO
	printLog( "ProcessColumn_242" );
#endif
	_types_24a= &typess_247;
	_array1_24b= &array1s_248;
	_project_24c= &projects_249;
	if( ( !typess_243.empty())&& ( !projects_245.empty()))
		callProcessScalar_375( typess_243, projects_245);
}

void ProcessColumn_242::callProcessScalar_375( const Packets_t& typess_169, const Packets_t& projects_16b)
{
	Packets_t typess_16d;
	Packets_t basictypes_16e;
	Packets_t projects_16f;
	ProcessScalar_168 processScalar_168;
	processScalar_168( typess_169, projects_16b, typess_16d, basictypes_16e, projects_16f);
	if( ( !typess_16d.empty())&& ( !basictypes_16e.empty())&& ( !projects_16f.empty()))
		callProcessArray1_378( typess_16d, basictypes_16e, projects_16f);
}

void ProcessColumn_242::callProcessArray1_378( const Packets_t& typess_24e, const Packets_t& basictypes_250, const Packets_t& projects_252)
{
	Packets_t typess_254;
	Packets_t array1s_255;
	Packets_t projects_256;
	ProcessArray1_24d processArray1_24d;
	processArray1_24d( typess_24e, basictypes_250, projects_252, typess_254, array1s_255, projects_256);
	_types_24a->insert( _types_24a->end(), typess_254.begin(), typess_254.end());
	_array1_24b->insert( _array1_24b->end(), array1s_255.begin(), array1s_255.end());
	_project_24c->insert( _project_24c->end(), projects_256.begin(), projects_256.end());
}

void ProcessArray1_24d::operator()( const Packets_t& typess_24e, const Packets_t& basictypes_250, const Packets_t& projects_252, Packets_t& typess_254, Packets_t& array1s_255, Packets_t& projects_256)
{
#ifdef PRINT_INFO
	printLog( "ProcessArray1_24d" );
#endif
	_types_257= &typess_254;
	_array1_258= &array1s_255;
	_project_259= &projects_256;
	if( ( !typess_24e.empty())&& ( !basictypes_250.empty())&& ( !projects_252.empty()))
		callGetArray1_369( typess_24e, basictypes_250, projects_252);
}

void ProcessArray1_24d::callGetArray1_369( const Packets_t& typess_25b, const Packets_t& dts_25d, const Packets_t& projects_25f)
{
	Packets_t typess_261;
	Packets_t dts_262;
	Packets_t projectss_263;
	Packets_t typess_264;
	Packets_t dts_265;
	Packets_t projectss_266;
	GetArray1_25a getArray1_25a;
	getArray1_25a( typess_25b, dts_25d, projects_25f, typess_261, dts_262, projectss_263, typess_264, dts_265, projectss_266);
	if( ( !typess_261.empty())&& ( !dts_262.empty())&& ( !projectss_263.empty()))
		callUseArray1_36d( typess_261, dts_262, projectss_263);
	if( ( !typess_264.empty())&& ( !dts_265.empty())&& ( !projectss_266.empty()))
		callCreateArray1_371( typess_264, dts_265, projectss_266);
}

void ProcessArray1_24d::callUseArray1_36d( const Packets_t& matrixs_2f6, const Packets_t& dTs_2f9, const Packets_t& projects_2fc)
{
	Packets_t matrixs_2f8;
	Packets_t arrays_2fb;
	Packets_t projects_2fe;
	UseArray1_2f5 useArray1_2f5;
	useArray1_2f5( matrixs_2f6, dTs_2f9, projects_2fc, matrixs_2f8, arrays_2fb, projects_2fe);
	_types_257->insert( _types_257->end(), matrixs_2f8.begin(), matrixs_2f8.end());
	_array1_258->insert( _array1_258->end(), arrays_2fb.begin(), arrays_2fb.end());
	_project_259->insert( _project_259->end(), projects_2fe.begin(), projects_2fe.end());
}

void ProcessArray1_24d::callCreateArray1_371( const Packets_t& matrixs_334, const Packets_t& dTs_337, const Packets_t& projects_33a)
{
	Packets_t matrixs_336;
	Packets_t arrays_339;
	Packets_t projects_33c;
	CreateArray1_333 createArray1_333;
	createArray1_333( matrixs_334, dTs_337, projects_33a, matrixs_336, arrays_339, projects_33c);
	_types_257->insert( _types_257->end(), matrixs_336.begin(), matrixs_336.end());
	_array1_258->insert( _array1_258->end(), arrays_339.begin(), arrays_339.end());
	_project_259->insert( _project_259->end(), projects_33c.begin(), projects_33c.end());
}

void GetArray1_25a::operator()( const Packets_t& typess_25b, const Packets_t& dts_25d, const Packets_t& projects_25f, Packets_t& typess_261, Packets_t& dts_262, Packets_t& projectss_263, Packets_t& typess_264, Packets_t& dts_265, Packets_t& projectss_266)
{
#ifdef PRINT_INFO
	printLog( "GetArray1_25a" );
#endif
	_types_267= &typess_261;
	_dt_268= &dts_262;
	_projects_269= &projectss_263;
	_types_26a= &typess_264;
	_dt_26b= &dts_265;
	_projects_26c= &projectss_266;
	for( Packets_t::const_iterator ittypes_26e= typess_25b.begin(), itdt_275= dts_25d.begin(), itproject_27c= projects_25f.begin(); ittypes_26e!= typess_25b.end(), itdt_275!= dts_25d.end(), itproject_27c!= projects_25f.end(); ++ittypes_26e, ++itdt_275, ++itproject_27c)
	{
		bool isUnique= isInputUnique( *ittypes_26e, *itdt_275, *itproject_27c);
		if( !isUnique)
			continue;
		Packets_t onetypes_272( 1, *ittypes_26e);
		Packets_t onedt_279( 1, *itdt_275);
		Packets_t oneproject_280( 1, *itproject_27c);
		executeOne( onetypes_272, onedt_279, oneproject_280);
	}
}

void GetArray1_25a::executeOne( const Packets_t& typess_25b, const Packets_t& dts_25d, const Packets_t& projects_25f)
{
	Packets_t matrixs_285;
	Packets_t dTs_288;
	Packets_t projects_28b;
	Array1Exists_282 array1Exists_282;
	bool isMatchArray1Exists_282= array1Exists_282( typess_25b, dts_25d, projects_25f, matrixs_285, dTs_288, projects_28b);
	_types_267->insert( _types_267->end(), matrixs_285.begin(), matrixs_285.end());
	_dt_268->insert( _dt_268->end(), dTs_288.begin(), dTs_288.end());
	_projects_269->insert( _projects_269->end(), projects_28b.begin(), projects_28b.end());
	if( isMatchArray1Exists_282)
		return;
	Packets_t matrixs_2c3;
	Packets_t dTs_2c6;
	Packets_t projects_2c9;
	Otherwise_2c0 otherwise_2c0;
	bool isMatchOtherwise_2c0= otherwise_2c0( typess_25b, dts_25d, projects_25f, matrixs_2c3, dTs_2c6, projects_2c9);
	_types_26a->insert( _types_26a->end(), matrixs_2c3.begin(), matrixs_2c3.end());
	_dt_26b->insert( _dt_26b->end(), dTs_2c6.begin(), dTs_2c6.end());
	_projects_26c->insert( _projects_26c->end(), projects_2c9.begin(), projects_2c9.end());
	if( isMatchOtherwise_2c0)
		return;
}

bool GetArray1_25a::isInputUnique( const Udm::Object& types_26f, const Udm::Object& dt_276, const Udm::Object& project_27d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator ittypes_271= _types_26d.begin(), itdt_278= _dt_274.begin(), itproject_27f= _project_27b.begin(); ittypes_271!= _types_26d.end(), itdt_278!= _dt_274.end(), itproject_27f!= _project_27b.end(); ++ittypes_271, ++itdt_278, ++itproject_27f)
	{
		if( ( *ittypes_271== types_26f)&& ( *itdt_278== dt_276)&& ( *itproject_27f== project_27d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_types_26d.push_back( types_26f);
		_dt_274.push_back( dt_276);
		_project_27b.push_back( project_27d);
	}
	return isUnique;
}

bool Array1Exists_282::operator()( const Packets_t& matrixs_283, const Packets_t& dTs_286, const Packets_t& projects_289, Packets_t& matrixs_285, Packets_t& dTs_288, Packets_t& projects_28b)
{
#ifdef PRINT_INFO
	printLog( "Array1Exists_282" );
#endif
	_matrix_28c= &matrixs_285;
	_dT_28d= &dTs_288;
	_project_28e= &projects_28b;
	processInputPackets( matrixs_283, dTs_286, projects_289);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Array1Exists_282::isInputUnique( const Udm::Object& matrix_293, const Udm::Object& dT_29c, const Udm::Object& project_2a5)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_295= _matrix_28f.begin(), itDT_29e= _dT_298.begin(), itProject_2a7= _project_2a1.begin(); itMatrix_295!= _matrix_28f.end(), itDT_29e!= _dT_298.end(), itProject_2a7!= _project_2a1.end(); ++itMatrix_295, ++itDT_29e, ++itProject_2a7)
	{
		if( ( *itMatrix_295== matrix_293)&& ( *itDT_29e== dT_29c)&& ( *itProject_2a7== project_2a5))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_28f.push_back( matrix_293);
		_dT_298.push_back( dT_29c);
		_project_2a1.push_back( project_2a5);
	}
	return isUnique;
}

bool Array1Exists_282::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool Array1Exists_282::isGuardTrue( SFC::Array& Array, SFC::DT& DT, CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard = Matrix.rows() == Array.noelem();;
	return Gz_guard;
}

void Array1Exists_282::processInputPackets( const Packets_t& matrixs_283, const Packets_t& dTs_286, const Packets_t& projects_289)
{
	for( Packets_t::const_iterator itMatrix_290= matrixs_283.begin(), itDT_299= dTs_286.begin(), itProject_2a2= projects_289.begin(); itMatrix_290!= matrixs_283.end(), itDT_299!= dTs_286.end(), itProject_2a2!= projects_289.end(); ++itMatrix_290, ++itDT_299, ++itProject_2a2)
	{
		bool isUnique= isInputUnique( *itMatrix_290, *itDT_299, *itProject_2a2);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_290, *itDT_299, *itProject_2a2);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_2b2, currMatch.dT_2b3, currMatch.project_2b4);
	}
}

bool Array1Exists_282::patternMatcher( const Udm::Object& matrix_291, const Udm::Object& dT_29a, const Udm::Object& project_2a3)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_291.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_296= CyberComposition::Simulink::SF_Matrix::Cast( matrix_291);
		if( false== Uml::IsDerivedFrom( dT_29a.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_29f= SFC::DT::Cast( dT_29a);
		if( false== Uml::IsDerivedFrom( project_2a3.type(), SFC::Project::meta))
			continue;
		SFC::Project project_2a8= SFC::Project::Cast( project_2a3);
		set< SFC::Array> arrays_2aa= project_2a8.Array_kind_children();
		for( set< SFC::Array>::const_iterator itArray_2ab= arrays_2aa.begin(); itArray_2ab!= arrays_2aa.end(); ++itArray_2ab)
		{
			SFC::Array currArray_2ac= *itArray_2ab;
			SFC::DT dT_2ad= currArray_2ac.dt();
			if( !dT_2ad)
				continue;
			if( dT_29f!= dT_2ad)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2b1;
			if( !isValidBound(boundObjs_2b1, matrix_296, true))
				continue;
			currMatch.matrix_2b2= matrix_296;
			if( !isValidBound(boundObjs_2b1, dT_29f, true))
				continue;
			currMatch.dT_2b3= dT_29f;
			if( !isValidBound(boundObjs_2b1, project_2a8, true))
				continue;
			currMatch.project_2b4= project_2a8;
			if( !isValidBound(boundObjs_2b1, currArray_2ac, false))
				continue;
			currMatch.array_2b5= currArray_2ac;
			bool Gz_guard= isGuardTrue( currMatch.array_2b5, currMatch.dT_2b3, currMatch.matrix_2b2, currMatch.project_2b4);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void Array1Exists_282::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_2ba, const SFC::DT& dT_2bc, const SFC::Project& project_2be)
{
	_matrix_28c->push_back( matrix_2ba);
	_dT_28d->push_back( dT_2bc);
	_project_28e->push_back( project_2be);
}

bool Otherwise_2c0::operator()( const Packets_t& matrixs_2c1, const Packets_t& dTs_2c4, const Packets_t& projects_2c7, Packets_t& matrixs_2c3, Packets_t& dTs_2c6, Packets_t& projects_2c9)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_2c0" );
#endif
	_matrix_2ca= &matrixs_2c3;
	_dT_2cb= &dTs_2c6;
	_project_2cc= &projects_2c9;
	processInputPackets( matrixs_2c1, dTs_2c4, projects_2c7);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_2c0::isInputUnique( const Udm::Object& matrix_2d1, const Udm::Object& dT_2da, const Udm::Object& project_2e3)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_2d3= _matrix_2cd.begin(), itDT_2dc= _dT_2d6.begin(), itProject_2e5= _project_2df.begin(); itMatrix_2d3!= _matrix_2cd.end(), itDT_2dc!= _dT_2d6.end(), itProject_2e5!= _project_2df.end(); ++itMatrix_2d3, ++itDT_2dc, ++itProject_2e5)
	{
		if( ( *itMatrix_2d3== matrix_2d1)&& ( *itDT_2dc== dT_2da)&& ( *itProject_2e5== project_2e3))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_2cd.push_back( matrix_2d1);
		_dT_2d6.push_back( dT_2da);
		_project_2df.push_back( project_2e3);
	}
	return isUnique;
}

bool Otherwise_2c0::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_2c0::processInputPackets( const Packets_t& matrixs_2c1, const Packets_t& dTs_2c4, const Packets_t& projects_2c7)
{
	for( Packets_t::const_iterator itMatrix_2ce= matrixs_2c1.begin(), itDT_2d7= dTs_2c4.begin(), itProject_2e0= projects_2c7.begin(); itMatrix_2ce!= matrixs_2c1.end(), itDT_2d7!= dTs_2c4.end(), itProject_2e0!= projects_2c7.end(); ++itMatrix_2ce, ++itDT_2d7, ++itProject_2e0)
	{
		bool isUnique= isInputUnique( *itMatrix_2ce, *itDT_2d7, *itProject_2e0);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_2ce, *itDT_2d7, *itProject_2e0);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_2ec, currMatch.dT_2ed, currMatch.project_2ee);
	}
}

bool Otherwise_2c0::patternMatcher( const Udm::Object& matrix_2cf, const Udm::Object& dT_2d8, const Udm::Object& project_2e1)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_2cf.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_2d4= CyberComposition::Simulink::SF_Matrix::Cast( matrix_2cf);
		if( false== Uml::IsDerivedFrom( dT_2d8.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_2dd= SFC::DT::Cast( dT_2d8);
		if( false== Uml::IsDerivedFrom( project_2e1.type(), SFC::Project::meta))
			continue;
		SFC::Project project_2e6= SFC::Project::Cast( project_2e1);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2eb;
		if( !isValidBound(boundObjs_2eb, matrix_2d4, true))
			continue;
		currMatch.matrix_2ec= matrix_2d4;
		if( !isValidBound(boundObjs_2eb, dT_2dd, true))
			continue;
		currMatch.dT_2ed= dT_2dd;
		if( !isValidBound(boundObjs_2eb, project_2e6, true))
			continue;
		currMatch.project_2ee= project_2e6;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_2c0::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_2ef, const SFC::DT& dT_2f1, const SFC::Project& project_2f3)
{
	_matrix_2ca->push_back( matrix_2ef);
	_dT_2cb->push_back( dT_2f1);
	_project_2cc->push_back( project_2f3);
}

void UseArray1_2f5::operator()( const Packets_t& matrixs_2f6, const Packets_t& dTs_2f9, const Packets_t& projects_2fc, Packets_t& matrixs_2f8, Packets_t& arrays_2fb, Packets_t& projects_2fe)
{
#ifdef PRINT_INFO
	printLog( "UseArray1_2f5" );
#endif
	RTTGenerator::Instance()->generateRule(128, "UseArray1");
	_matrix_2ff= &matrixs_2f8;
	_array_300= &arrays_2fb;
	_project_301= &projects_2fe;
	processInputPackets( matrixs_2f6, dTs_2f9, projects_2fc);
}

bool UseArray1_2f5::isInputUnique( const Udm::Object& matrix_306, const Udm::Object& dT_30f, const Udm::Object& project_318)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_308= _matrix_302.begin(), itDT_311= _dT_30b.begin(), itProject_31a= _project_314.begin(); itMatrix_308!= _matrix_302.end(), itDT_311!= _dT_30b.end(), itProject_31a!= _project_314.end(); ++itMatrix_308, ++itDT_311, ++itProject_31a)
	{
		if( ( *itMatrix_308== matrix_306)&& ( *itDT_311== dT_30f)&& ( *itProject_31a== project_318))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_302.push_back( matrix_306);
		_dT_30b.push_back( dT_30f);
		_project_314.push_back( project_318);
	}
	return isUnique;
}

bool UseArray1_2f5::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool UseArray1_2f5::isGuardTrue( SFC::Array& Array, SFC::DT& DT, CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard = Matrix.rows() == Array.noelem();;
	return Gz_guard;
}

void UseArray1_2f5::processInputPackets( const Packets_t& matrixs_2f6, const Packets_t& dTs_2f9, const Packets_t& projects_2fc)
{
	for( Packets_t::const_iterator itMatrix_303= matrixs_2f6.begin(), itDT_30c= dTs_2f9.begin(), itProject_315= projects_2fc.begin(); itMatrix_303!= matrixs_2f6.end(), itDT_30c!= dTs_2f9.end(), itProject_315!= projects_2fc.end(); ++itMatrix_303, ++itDT_30c, ++itProject_315)
	{
		bool isUnique= isInputUnique( *itMatrix_303, *itDT_30c, *itProject_315);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_303, *itDT_30c, *itProject_315);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool UseArray1_2f5::patternMatcher( const Udm::Object& matrix_304, const Udm::Object& dT_30d, const Udm::Object& project_316)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_304.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_309= CyberComposition::Simulink::SF_Matrix::Cast( matrix_304);
		if( false== Uml::IsDerivedFrom( dT_30d.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_312= SFC::DT::Cast( dT_30d);
		if( false== Uml::IsDerivedFrom( project_316.type(), SFC::Project::meta))
			continue;
		SFC::Project project_31b= SFC::Project::Cast( project_316);
		set< SFC::Array> arrays_31d= project_31b.Array_kind_children();
		for( set< SFC::Array>::const_iterator itArray_31e= arrays_31d.begin(); itArray_31e!= arrays_31d.end(); ++itArray_31e)
		{
			SFC::Array currArray_31f= *itArray_31e;
			SFC::DT dT_320= currArray_31f.dt();
			if( !dT_320)
				continue;
			if( dT_312!= dT_320)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_324;
			if( !isValidBound(boundObjs_324, matrix_309, true))
				continue;
			currMatch.matrix_325= matrix_309;
			if( !isValidBound(boundObjs_324, dT_312, true))
				continue;
			currMatch.dT_326= dT_312;
			if( !isValidBound(boundObjs_324, project_31b, true))
				continue;
			currMatch.project_327= project_31b;
			if( !isValidBound(boundObjs_324, currArray_31f, false))
				continue;
			currMatch.array_328= currArray_31f;
			bool Gz_guard= isGuardTrue( currMatch.array_328, currMatch.dT_326, currMatch.matrix_325, currMatch.project_327);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void UseArray1_2f5::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_325, currMatch.array_328, currMatch.project_327);
	}
}

void UseArray1_2f5::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_32d, const SFC::Array& array_32f, const SFC::Project& project_331)
{
	_matrix_2ff->push_back( matrix_32d);
	_array_300->push_back( array_32f);
	_project_301->push_back( project_331);
}

void CreateArray1_333::operator()( const Packets_t& matrixs_334, const Packets_t& dTs_337, const Packets_t& projects_33a, Packets_t& matrixs_336, Packets_t& arrays_339, Packets_t& projects_33c)
{
#ifdef PRINT_INFO
	printLog( "CreateArray1_333" );
#endif
	RTTGenerator::Instance()->generateRule(135, "CreateArray1");
	_matrix_33d= &matrixs_336;
	_array_33e= &arrays_339;
	_project_33f= &projects_33c;
	processInputPackets( matrixs_334, dTs_337, projects_33a);
}

bool CreateArray1_333::isInputUnique( const Udm::Object& matrix_344, const Udm::Object& dT_34d, const Udm::Object& project_356)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_346= _matrix_340.begin(), itDT_34f= _dT_349.begin(), itProject_358= _project_352.begin(); itMatrix_346!= _matrix_340.end(), itDT_34f!= _dT_349.end(), itProject_358!= _project_352.end(); ++itMatrix_346, ++itDT_34f, ++itProject_358)
	{
		if( ( *itMatrix_346== matrix_344)&& ( *itDT_34f== dT_34d)&& ( *itProject_358== project_356))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_340.push_back( matrix_344);
		_dT_349.push_back( dT_34d);
		_project_352.push_back( project_356);
	}
	return isUnique;
}

bool CreateArray1_333::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateArray1_333::processInputPackets( const Packets_t& matrixs_334, const Packets_t& dTs_337, const Packets_t& projects_33a)
{
	for( Packets_t::const_iterator itMatrix_341= matrixs_334.begin(), itDT_34a= dTs_337.begin(), itProject_353= projects_33a.begin(); itMatrix_341!= matrixs_334.end(), itDT_34a!= dTs_337.end(), itProject_353!= projects_33a.end(); ++itMatrix_341, ++itDT_34a, ++itProject_353)
	{
		bool isUnique= isInputUnique( *itMatrix_341, *itDT_34a, *itProject_353);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_341, *itDT_34a, *itProject_353);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateArray1_333::patternMatcher( const Udm::Object& matrix_342, const Udm::Object& dT_34b, const Udm::Object& project_354)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_342.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_347= CyberComposition::Simulink::SF_Matrix::Cast( matrix_342);
		if( false== Uml::IsDerivedFrom( dT_34b.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_350= SFC::DT::Cast( dT_34b);
		if( false== Uml::IsDerivedFrom( project_354.type(), SFC::Project::meta))
			continue;
		SFC::Project project_359= SFC::Project::Cast( project_354);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_35e;
		if( !isValidBound(boundObjs_35e, matrix_347, true))
			continue;
		currMatch.matrix_35f= matrix_347;
		if( !isValidBound(boundObjs_35e, dT_350, true))
			continue;
		currMatch.dT_360= dT_350;
		if( !isValidBound(boundObjs_35e, project_359, true))
			continue;
		currMatch.project_361= project_359;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateArray1_333::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Array newArray_362= SFC::Array::Create( currMatch.project_361);
		SFC::Array& Array= newArray_362;
		SFC::DT& DT= currMatch.dT_360;
		CyberComposition::Simulink::SF_Matrix& Matrix= currMatch.matrix_35f;
		SFC::Project& Project= currMatch.project_361;
		{
__int64 statementCount = Project.statementCount();
Array.statementIndex() = statementCount++;
Project.statementCount() = statementCount;

Array.noelem() = Matrix.rows();

};
		newArray_362.dt()= currMatch.dT_360;
		outputAppender( currMatch.matrix_35f, newArray_362, currMatch.project_361);
	}
}

void CreateArray1_333::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_363, const SFC::Array& array_365, const SFC::Project& project_367)
{
	_matrix_33d->push_back( matrix_363);
	_array_33e->push_back( array_365);
	_project_33f->push_back( project_367);
}

void ProcessOther_37c::operator()( const Packets_t& typess_37d, const Packets_t& projects_37f, Packets_t& typess_381, Packets_t& array1s_382, Packets_t& projects_383)
{
#ifdef PRINT_INFO
	printLog( "ProcessOther_37c" );
#endif
	_types_384= &typess_381;
	_array1_385= &array1s_382;
	_project_386= &projects_383;
	if( ( !typess_37d.empty())&& ( !projects_37f.empty()))
		callProcessRowVector_4c3( typess_37d, projects_37f);
}

void ProcessOther_37c::callProcessRowVector_4c3( const Packets_t& typess_388, const Packets_t& projects_38a)
{
	Packets_t typess_38c;
	Packets_t array2s_38d;
	Packets_t projectss_38e;
	ProcessRowVector_387 processRowVector_387;
	processRowVector_387( typess_388, projects_38a, typess_38c, array2s_38d, projectss_38e);
	if( ( !typess_38c.empty())&& ( !array2s_38d.empty())&& ( !projectss_38e.empty()))
		callProcessArray1_4c6( typess_38c, array2s_38d, projectss_38e);
}

void ProcessOther_37c::callProcessArray1_4c6( const Packets_t& typess_24e, const Packets_t& basictypes_250, const Packets_t& projects_252)
{
	Packets_t typess_254;
	Packets_t array1s_255;
	Packets_t projects_256;
	ProcessArray1_24d processArray1_24d;
	processArray1_24d( typess_24e, basictypes_250, projects_252, typess_254, array1s_255, projects_256);
	_array1_385->insert( _array1_385->end(), array1s_255.begin(), array1s_255.end());
	_types_384->insert( _types_384->end(), typess_254.begin(), typess_254.end());
	_project_386->insert( _project_386->end(), projects_256.begin(), projects_256.end());
}

void ProcessRowVector_387::operator()( const Packets_t& typess_388, const Packets_t& projects_38a, Packets_t& typess_38c, Packets_t& array2s_38d, Packets_t& projectss_38e)
{
#ifdef PRINT_INFO
	printLog( "ProcessRowVector_387" );
#endif
	_types_38f= &typess_38c;
	_array2_390= &array2s_38d;
	_projects_391= &projectss_38e;
	if( ( !typess_388.empty())&& ( !projects_38a.empty()))
		callProcessScalar_4bc( typess_388, projects_38a);
}

void ProcessRowVector_387::callProcessScalar_4bc( const Packets_t& typess_169, const Packets_t& projects_16b)
{
	Packets_t typess_16d;
	Packets_t basictypes_16e;
	Packets_t projects_16f;
	ProcessScalar_168 processScalar_168;
	processScalar_168( typess_169, projects_16b, typess_16d, basictypes_16e, projects_16f);
	if( ( !typess_16d.empty())&& ( !basictypes_16e.empty())&& ( !projects_16f.empty()))
		callProcessArray2_4bf( typess_16d, basictypes_16e, projects_16f);
}

void ProcessRowVector_387::callProcessArray2_4bf( const Packets_t& typess_393, const Packets_t& basictypes_395, const Packets_t& projects_397)
{
	Packets_t typess_399;
	Packets_t array2s_39a;
	Packets_t projectss_39b;
	ProcessArray2_392 processArray2_392;
	processArray2_392( typess_393, basictypes_395, projects_397, typess_399, array2s_39a, projectss_39b);
	_types_38f->insert( _types_38f->end(), typess_399.begin(), typess_399.end());
	_array2_390->insert( _array2_390->end(), array2s_39a.begin(), array2s_39a.end());
	_projects_391->insert( _projects_391->end(), projectss_39b.begin(), projectss_39b.end());
}

void ProcessArray2_392::operator()( const Packets_t& typess_393, const Packets_t& basictypes_395, const Packets_t& projects_397, Packets_t& typess_399, Packets_t& array2s_39a, Packets_t& projectss_39b)
{
#ifdef PRINT_INFO
	printLog( "ProcessArray2_392" );
#endif
	_types_39c= &typess_399;
	_array2_39d= &array2s_39a;
	_projects_39e= &projectss_39b;
	if( ( !typess_393.empty())&& ( !basictypes_395.empty())&& ( !projects_397.empty()))
		callGetArray2_4b0( typess_393, basictypes_395, projects_397);
}

void ProcessArray2_392::callGetArray2_4b0( const Packets_t& typess_415, const Packets_t& basictypes_417, const Packets_t& projects_419)
{
	Packets_t typess_41b;
	Packets_t basictypes_41c;
	Packets_t projectss_41d;
	Packets_t typess_41e;
	Packets_t basictypes_41f;
	Packets_t projectss_420;
	GetArray2_414 getArray2_414;
	getArray2_414( typess_415, basictypes_417, projects_419, typess_41b, basictypes_41c, projectss_41d, typess_41e, basictypes_41f, projectss_420);
	if( ( !typess_41e.empty())&& ( !basictypes_41f.empty())&& ( !projectss_420.empty()))
		callCreateArray2_4b4( typess_41e, basictypes_41f, projectss_420);
	if( ( !typess_41b.empty())&& ( !basictypes_41c.empty())&& ( !projectss_41d.empty()))
		callUseArray2_4b8( typess_41b, basictypes_41c, projectss_41d);
}

void ProcessArray2_392::callCreateArray2_4b4( const Packets_t& matrixs_3a0, const Packets_t& basicTypes_3a4, const Packets_t& projects_3a6)
{
	Packets_t matrixs_3a2;
	Packets_t arrays_3a3;
	Packets_t projects_3a8;
	CreateArray2_39f createArray2_39f;
	createArray2_39f( matrixs_3a0, basicTypes_3a4, projects_3a6, matrixs_3a2, arrays_3a3, projects_3a8);
	_types_39c->insert( _types_39c->end(), matrixs_3a2.begin(), matrixs_3a2.end());
	_array2_39d->insert( _array2_39d->end(), arrays_3a3.begin(), arrays_3a3.end());
	_projects_39e->insert( _projects_39e->end(), projects_3a8.begin(), projects_3a8.end());
}

void ProcessArray2_392::callUseArray2_4b8( const Packets_t& matrixs_3d6, const Packets_t& basicTypes_3da, const Packets_t& projects_3dc)
{
	Packets_t matrixs_3d8;
	Packets_t arrays_3d9;
	Packets_t projects_3de;
	UseArray2_3d5 useArray2_3d5;
	useArray2_3d5( matrixs_3d6, basicTypes_3da, projects_3dc, matrixs_3d8, arrays_3d9, projects_3de);
	_types_39c->insert( _types_39c->end(), matrixs_3d8.begin(), matrixs_3d8.end());
	_array2_39d->insert( _array2_39d->end(), arrays_3d9.begin(), arrays_3d9.end());
	_projects_39e->insert( _projects_39e->end(), projects_3de.begin(), projects_3de.end());
}

void CreateArray2_39f::operator()( const Packets_t& matrixs_3a0, const Packets_t& basicTypes_3a4, const Packets_t& projects_3a6, Packets_t& matrixs_3a2, Packets_t& arrays_3a3, Packets_t& projects_3a8)
{
#ifdef PRINT_INFO
	printLog( "CreateArray2_39f" );
#endif
	RTTGenerator::Instance()->generateRule(162, "CreateArray2");
	_matrix_3a9= &matrixs_3a2;
	_array_3aa= &arrays_3a3;
	_project_3ab= &projects_3a8;
	processInputPackets( matrixs_3a0, basicTypes_3a4, projects_3a6);
}

bool CreateArray2_39f::isInputUnique( const Udm::Object& matrix_3b0, const Udm::Object& basicType_3b9, const Udm::Object& project_3c2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_3b2= _matrix_3ac.begin(), itBasicType_3bb= _basicType_3b5.begin(), itProject_3c4= _project_3be.begin(); itMatrix_3b2!= _matrix_3ac.end(), itBasicType_3bb!= _basicType_3b5.end(), itProject_3c4!= _project_3be.end(); ++itMatrix_3b2, ++itBasicType_3bb, ++itProject_3c4)
	{
		if( ( *itMatrix_3b2== matrix_3b0)&& ( *itBasicType_3bb== basicType_3b9)&& ( *itProject_3c4== project_3c2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_3ac.push_back( matrix_3b0);
		_basicType_3b5.push_back( basicType_3b9);
		_project_3be.push_back( project_3c2);
	}
	return isUnique;
}

bool CreateArray2_39f::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateArray2_39f::processInputPackets( const Packets_t& matrixs_3a0, const Packets_t& basicTypes_3a4, const Packets_t& projects_3a6)
{
	for( Packets_t::const_iterator itMatrix_3ad= matrixs_3a0.begin(), itBasicType_3b6= basicTypes_3a4.begin(), itProject_3bf= projects_3a6.begin(); itMatrix_3ad!= matrixs_3a0.end(), itBasicType_3b6!= basicTypes_3a4.end(), itProject_3bf!= projects_3a6.end(); ++itMatrix_3ad, ++itBasicType_3b6, ++itProject_3bf)
	{
		bool isUnique= isInputUnique( *itMatrix_3ad, *itBasicType_3b6, *itProject_3bf);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_3ad, *itBasicType_3b6, *itProject_3bf);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateArray2_39f::patternMatcher( const Udm::Object& matrix_3ae, const Udm::Object& basicType_3b7, const Udm::Object& project_3c0)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_3ae.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_3b3= CyberComposition::Simulink::SF_Matrix::Cast( matrix_3ae);
		if( false== Uml::IsDerivedFrom( basicType_3b7.type(), SFC::BasicType::meta))
			continue;
		SFC::BasicType basicType_3bc= SFC::BasicType::Cast( basicType_3b7);
		if( false== Uml::IsDerivedFrom( project_3c0.type(), SFC::Project::meta))
			continue;
		SFC::Project project_3c5= SFC::Project::Cast( project_3c0);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3ca;
		if( !isValidBound(boundObjs_3ca, matrix_3b3, true))
			continue;
		currMatch.matrix_3cb= matrix_3b3;
		if( !isValidBound(boundObjs_3ca, basicType_3bc, true))
			continue;
		currMatch.basicType_3cc= basicType_3bc;
		if( !isValidBound(boundObjs_3ca, project_3c5, true))
			continue;
		currMatch.project_3cd= project_3c5;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateArray2_39f::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Array newArray_3ce= SFC::Array::Create( currMatch.project_3cd);
		SFC::Array& Array= newArray_3ce;
		SFC::BasicType& BasicType= currMatch.basicType_3cc;
		CyberComposition::Simulink::SF_Matrix& Matrix= currMatch.matrix_3cb;
		SFC::Project& Project= currMatch.project_3cd;
		{
__int64 statementCount = Project.statementCount();
Array.statementIndex() = statementCount++;
Project.statementCount() = statementCount;

Array.noelem() = Matrix.columns();
};
		newArray_3ce.dt()= currMatch.basicType_3cc;
		outputAppender( currMatch.matrix_3cb, newArray_3ce, currMatch.project_3cd);
	}
}

void CreateArray2_39f::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_3cf, const SFC::Array& array_3d1, const SFC::Project& project_3d3)
{
	_matrix_3a9->push_back( matrix_3cf);
	_array_3aa->push_back( array_3d1);
	_project_3ab->push_back( project_3d3);
}

void UseArray2_3d5::operator()( const Packets_t& matrixs_3d6, const Packets_t& basicTypes_3da, const Packets_t& projects_3dc, Packets_t& matrixs_3d8, Packets_t& arrays_3d9, Packets_t& projects_3de)
{
#ifdef PRINT_INFO
	printLog( "UseArray2_3d5" );
#endif
	RTTGenerator::Instance()->generateRule(170, "UseArray2");
	_matrix_3df= &matrixs_3d8;
	_array_3e0= &arrays_3d9;
	_project_3e1= &projects_3de;
	processInputPackets( matrixs_3d6, basicTypes_3da, projects_3dc);
}

bool UseArray2_3d5::isInputUnique( const Udm::Object& matrix_3e6, const Udm::Object& basicType_3ef, const Udm::Object& project_3f8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_3e8= _matrix_3e2.begin(), itBasicType_3f1= _basicType_3eb.begin(), itProject_3fa= _project_3f4.begin(); itMatrix_3e8!= _matrix_3e2.end(), itBasicType_3f1!= _basicType_3eb.end(), itProject_3fa!= _project_3f4.end(); ++itMatrix_3e8, ++itBasicType_3f1, ++itProject_3fa)
	{
		if( ( *itMatrix_3e8== matrix_3e6)&& ( *itBasicType_3f1== basicType_3ef)&& ( *itProject_3fa== project_3f8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_3e2.push_back( matrix_3e6);
		_basicType_3eb.push_back( basicType_3ef);
		_project_3f4.push_back( project_3f8);
	}
	return isUnique;
}

bool UseArray2_3d5::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool UseArray2_3d5::isGuardTrue( SFC::Array& Array, SFC::BasicType& BasicType, CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard = Matrix.columns() == Array.noelem();;
	return Gz_guard;
}

void UseArray2_3d5::processInputPackets( const Packets_t& matrixs_3d6, const Packets_t& basicTypes_3da, const Packets_t& projects_3dc)
{
	for( Packets_t::const_iterator itMatrix_3e3= matrixs_3d6.begin(), itBasicType_3ec= basicTypes_3da.begin(), itProject_3f5= projects_3dc.begin(); itMatrix_3e3!= matrixs_3d6.end(), itBasicType_3ec!= basicTypes_3da.end(), itProject_3f5!= projects_3dc.end(); ++itMatrix_3e3, ++itBasicType_3ec, ++itProject_3f5)
	{
		bool isUnique= isInputUnique( *itMatrix_3e3, *itBasicType_3ec, *itProject_3f5);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_3e3, *itBasicType_3ec, *itProject_3f5);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool UseArray2_3d5::patternMatcher( const Udm::Object& matrix_3e4, const Udm::Object& basicType_3ed, const Udm::Object& project_3f6)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_3e4.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_3e9= CyberComposition::Simulink::SF_Matrix::Cast( matrix_3e4);
		if( false== Uml::IsDerivedFrom( basicType_3ed.type(), SFC::BasicType::meta))
			continue;
		SFC::BasicType basicType_3f2= SFC::BasicType::Cast( basicType_3ed);
		if( false== Uml::IsDerivedFrom( project_3f6.type(), SFC::Project::meta))
			continue;
		SFC::Project project_3fb= SFC::Project::Cast( project_3f6);
		set< SFC::Array> arrays_3fd= project_3fb.Array_kind_children();
		for( set< SFC::Array>::const_iterator itArray_3fe= arrays_3fd.begin(); itArray_3fe!= arrays_3fd.end(); ++itArray_3fe)
		{
			SFC::Array currArray_3ff= *itArray_3fe;
			SFC::DT basicType_400= currArray_3ff.dt();
			if( !basicType_400 || false== Uml::IsDerivedFrom( basicType_400.type(), SFC::BasicType::meta))
				continue;
			SFC::BasicType basicType_401= SFC::BasicType::Cast( basicType_400);
			if( !basicType_401)
				continue;
			if( basicType_3f2!= basicType_401)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_405;
			if( !isValidBound(boundObjs_405, matrix_3e9, true))
				continue;
			currMatch.matrix_406= matrix_3e9;
			if( !isValidBound(boundObjs_405, basicType_3f2, true))
				continue;
			currMatch.basicType_407= basicType_3f2;
			if( !isValidBound(boundObjs_405, project_3fb, true))
				continue;
			currMatch.project_408= project_3fb;
			if( !isValidBound(boundObjs_405, currArray_3ff, false))
				continue;
			currMatch.array_409= currArray_3ff;
			bool Gz_guard= isGuardTrue( currMatch.array_409, currMatch.basicType_407, currMatch.matrix_406, currMatch.project_408);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void UseArray2_3d5::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_406, currMatch.array_409, currMatch.project_408);
	}
}

void UseArray2_3d5::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_40e, const SFC::Array& array_410, const SFC::Project& project_412)
{
	_matrix_3df->push_back( matrix_40e);
	_array_3e0->push_back( array_410);
	_project_3e1->push_back( project_412);
}

void GetArray2_414::operator()( const Packets_t& typess_415, const Packets_t& basictypes_417, const Packets_t& projects_419, Packets_t& typess_41b, Packets_t& basictypes_41c, Packets_t& projectss_41d, Packets_t& typess_41e, Packets_t& basictypes_41f, Packets_t& projectss_420)
{
#ifdef PRINT_INFO
	printLog( "GetArray2_414" );
#endif
	_types_421= &typess_41b;
	_basictype_422= &basictypes_41c;
	_projects_423= &projectss_41d;
	_types_424= &typess_41e;
	_basictype_425= &basictypes_41f;
	_projects_426= &projectss_420;
	for( Packets_t::const_iterator ittypes_428= typess_415.begin(), itbasictype_42f= basictypes_417.begin(), itproject_436= projects_419.begin(); ittypes_428!= typess_415.end(), itbasictype_42f!= basictypes_417.end(), itproject_436!= projects_419.end(); ++ittypes_428, ++itbasictype_42f, ++itproject_436)
	{
		bool isUnique= isInputUnique( *ittypes_428, *itbasictype_42f, *itproject_436);
		if( !isUnique)
			continue;
		Packets_t onetypes_42c( 1, *ittypes_428);
		Packets_t onebasictype_433( 1, *itbasictype_42f);
		Packets_t oneproject_43a( 1, *itproject_436);
		executeOne( onetypes_42c, onebasictype_433, oneproject_43a);
	}
}

void GetArray2_414::executeOne( const Packets_t& typess_415, const Packets_t& basictypes_417, const Packets_t& projects_419)
{
	Packets_t matrixs_43f;
	Packets_t basicTypes_442;
	Packets_t projects_445;
	Array2Exists_43c array2Exists_43c;
	bool isMatchArray2Exists_43c= array2Exists_43c( typess_415, basictypes_417, projects_419, matrixs_43f, basicTypes_442, projects_445);
	_types_421->insert( _types_421->end(), matrixs_43f.begin(), matrixs_43f.end());
	_basictype_422->insert( _basictype_422->end(), basicTypes_442.begin(), basicTypes_442.end());
	_projects_423->insert( _projects_423->end(), projects_445.begin(), projects_445.end());
	if( isMatchArray2Exists_43c)
		return;
	Packets_t matrixs_47e;
	Packets_t basicTypes_481;
	Packets_t projects_484;
	Otherwise_47b otherwise_47b;
	bool isMatchOtherwise_47b= otherwise_47b( typess_415, basictypes_417, projects_419, matrixs_47e, basicTypes_481, projects_484);
	_types_424->insert( _types_424->end(), matrixs_47e.begin(), matrixs_47e.end());
	_basictype_425->insert( _basictype_425->end(), basicTypes_481.begin(), basicTypes_481.end());
	_projects_426->insert( _projects_426->end(), projects_484.begin(), projects_484.end());
	if( isMatchOtherwise_47b)
		return;
}

bool GetArray2_414::isInputUnique( const Udm::Object& types_429, const Udm::Object& basictype_430, const Udm::Object& project_437)
{
	bool isUnique= true;
	for( Packets_t::const_iterator ittypes_42b= _types_427.begin(), itbasictype_432= _basictype_42e.begin(), itproject_439= _project_435.begin(); ittypes_42b!= _types_427.end(), itbasictype_432!= _basictype_42e.end(), itproject_439!= _project_435.end(); ++ittypes_42b, ++itbasictype_432, ++itproject_439)
	{
		if( ( *ittypes_42b== types_429)&& ( *itbasictype_432== basictype_430)&& ( *itproject_439== project_437))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_types_427.push_back( types_429);
		_basictype_42e.push_back( basictype_430);
		_project_435.push_back( project_437);
	}
	return isUnique;
}

bool Array2Exists_43c::operator()( const Packets_t& matrixs_43d, const Packets_t& basicTypes_440, const Packets_t& projects_443, Packets_t& matrixs_43f, Packets_t& basicTypes_442, Packets_t& projects_445)
{
#ifdef PRINT_INFO
	printLog( "Array2Exists_43c" );
#endif
	_matrix_446= &matrixs_43f;
	_basicType_447= &basicTypes_442;
	_project_448= &projects_445;
	processInputPackets( matrixs_43d, basicTypes_440, projects_443);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Array2Exists_43c::isInputUnique( const Udm::Object& matrix_44d, const Udm::Object& basicType_456, const Udm::Object& project_45f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_44f= _matrix_449.begin(), itBasicType_458= _basicType_452.begin(), itProject_461= _project_45b.begin(); itMatrix_44f!= _matrix_449.end(), itBasicType_458!= _basicType_452.end(), itProject_461!= _project_45b.end(); ++itMatrix_44f, ++itBasicType_458, ++itProject_461)
	{
		if( ( *itMatrix_44f== matrix_44d)&& ( *itBasicType_458== basicType_456)&& ( *itProject_461== project_45f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_449.push_back( matrix_44d);
		_basicType_452.push_back( basicType_456);
		_project_45b.push_back( project_45f);
	}
	return isUnique;
}

bool Array2Exists_43c::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool Array2Exists_43c::isGuardTrue( SFC::Array& Array, SFC::BasicType& BasicType, CyberComposition::Simulink::SF_Matrix& Matrix, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard = Matrix.columns() == Array.noelem();;
	return Gz_guard;
}

void Array2Exists_43c::processInputPackets( const Packets_t& matrixs_43d, const Packets_t& basicTypes_440, const Packets_t& projects_443)
{
	for( Packets_t::const_iterator itMatrix_44a= matrixs_43d.begin(), itBasicType_453= basicTypes_440.begin(), itProject_45c= projects_443.begin(); itMatrix_44a!= matrixs_43d.end(), itBasicType_453!= basicTypes_440.end(), itProject_45c!= projects_443.end(); ++itMatrix_44a, ++itBasicType_453, ++itProject_45c)
	{
		bool isUnique= isInputUnique( *itMatrix_44a, *itBasicType_453, *itProject_45c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_44a, *itBasicType_453, *itProject_45c);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_46d, currMatch.basicType_46e, currMatch.project_46f);
	}
}

bool Array2Exists_43c::patternMatcher( const Udm::Object& matrix_44b, const Udm::Object& basicType_454, const Udm::Object& project_45d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_44b.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_450= CyberComposition::Simulink::SF_Matrix::Cast( matrix_44b);
		if( false== Uml::IsDerivedFrom( basicType_454.type(), SFC::BasicType::meta))
			continue;
		SFC::BasicType basicType_459= SFC::BasicType::Cast( basicType_454);
		if( false== Uml::IsDerivedFrom( project_45d.type(), SFC::Project::meta))
			continue;
		SFC::Project project_462= SFC::Project::Cast( project_45d);
		set< SFC::Array> arrays_464= project_462.Array_kind_children();
		for( set< SFC::Array>::const_iterator itArray_465= arrays_464.begin(); itArray_465!= arrays_464.end(); ++itArray_465)
		{
			SFC::Array currArray_466= *itArray_465;
			SFC::DT basicType_467= currArray_466.dt();
			if(!basicType_467 || false== Uml::IsDerivedFrom( basicType_467.type(), SFC::BasicType::meta))
				continue;
			SFC::BasicType basicType_468= SFC::BasicType::Cast( basicType_467);
			if( !basicType_468)
				continue;
			if( basicType_459!= basicType_468)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_46c;
			if( !isValidBound(boundObjs_46c, matrix_450, true))
				continue;
			currMatch.matrix_46d= matrix_450;
			if( !isValidBound(boundObjs_46c, basicType_459, true))
				continue;
			currMatch.basicType_46e= basicType_459;
			if( !isValidBound(boundObjs_46c, project_462, true))
				continue;
			currMatch.project_46f= project_462;
			if( !isValidBound(boundObjs_46c, currArray_466, false))
				continue;
			currMatch.array_470= currArray_466;
			bool Gz_guard= isGuardTrue( currMatch.array_470, currMatch.basicType_46e, currMatch.matrix_46d, currMatch.project_46f);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void Array2Exists_43c::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_475, const SFC::BasicType& basicType_477, const SFC::Project& project_479)
{
	_matrix_446->push_back( matrix_475);
	_basicType_447->push_back( basicType_477);
	_project_448->push_back( project_479);
}

bool Otherwise_47b::operator()( const Packets_t& matrixs_47c, const Packets_t& basicTypes_47f, const Packets_t& projects_482, Packets_t& matrixs_47e, Packets_t& basicTypes_481, Packets_t& projects_484)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_47b" );
#endif
	_matrix_485= &matrixs_47e;
	_basicType_486= &basicTypes_481;
	_project_487= &projects_484;
	processInputPackets( matrixs_47c, basicTypes_47f, projects_482);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_47b::isInputUnique( const Udm::Object& matrix_48c, const Udm::Object& basicType_495, const Udm::Object& project_49e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_48e= _matrix_488.begin(), itBasicType_497= _basicType_491.begin(), itProject_4a0= _project_49a.begin(); itMatrix_48e!= _matrix_488.end(), itBasicType_497!= _basicType_491.end(), itProject_4a0!= _project_49a.end(); ++itMatrix_48e, ++itBasicType_497, ++itProject_4a0)
	{
		if( ( *itMatrix_48e== matrix_48c)&& ( *itBasicType_497== basicType_495)&& ( *itProject_4a0== project_49e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_488.push_back( matrix_48c);
		_basicType_491.push_back( basicType_495);
		_project_49a.push_back( project_49e);
	}
	return isUnique;
}

bool Otherwise_47b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_47b::processInputPackets( const Packets_t& matrixs_47c, const Packets_t& basicTypes_47f, const Packets_t& projects_482)
{
	for( Packets_t::const_iterator itMatrix_489= matrixs_47c.begin(), itBasicType_492= basicTypes_47f.begin(), itProject_49b= projects_482.begin(); itMatrix_489!= matrixs_47c.end(), itBasicType_492!= basicTypes_47f.end(), itProject_49b!= projects_482.end(); ++itMatrix_489, ++itBasicType_492, ++itProject_49b)
	{
		bool isUnique= isInputUnique( *itMatrix_489, *itBasicType_492, *itProject_49b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_489, *itBasicType_492, *itProject_49b);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.matrix_4a7, currMatch.basicType_4a8, currMatch.project_4a9);
	}
}

bool Otherwise_47b::patternMatcher( const Udm::Object& matrix_48a, const Udm::Object& basicType_493, const Udm::Object& project_49c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_48a.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_48f= CyberComposition::Simulink::SF_Matrix::Cast( matrix_48a);
		if( false== Uml::IsDerivedFrom( basicType_493.type(), SFC::BasicType::meta))
			continue;
		SFC::BasicType basicType_498= SFC::BasicType::Cast( basicType_493);
		if( false== Uml::IsDerivedFrom( project_49c.type(), SFC::Project::meta))
			continue;
		SFC::Project project_4a1= SFC::Project::Cast( project_49c);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4a6;
		if( !isValidBound(boundObjs_4a6, matrix_48f, true))
			continue;
		currMatch.matrix_4a7= matrix_48f;
		if( !isValidBound(boundObjs_4a6, basicType_498, true))
			continue;
		currMatch.basicType_4a8= basicType_498;
		if( !isValidBound(boundObjs_4a6, project_4a1, true))
			continue;
		currMatch.project_4a9= project_4a1;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_47b::outputAppender( const CyberComposition::Simulink::SF_Matrix& matrix_4aa, const SFC::BasicType& basicType_4ac, const SFC::Project& project_4ae)
{
	_matrix_485->push_back( matrix_4aa);
	_basicType_486->push_back( basicType_4ac);
	_project_487->push_back( project_4ae);
}

void MakeAssoc_4ca::operator()( const Packets_t& matrixs_4cb, const Packets_t& dTs_4cd)
{
#ifdef PRINT_INFO
	printLog( "MakeAssoc_4ca" );
#endif
	RTTGenerator::Instance()->generateRule(198, "MakeAssoc");
	processInputPackets( matrixs_4cb, dTs_4cd);
}

bool MakeAssoc_4ca::isInputUnique( const Udm::Object& matrix_4d3, const Udm::Object& dT_4dc)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_4d5= _matrix_4cf.begin(), itDT_4de= _dT_4d8.begin(); itMatrix_4d5!= _matrix_4cf.end(), itDT_4de!= _dT_4d8.end(); ++itMatrix_4d5, ++itDT_4de)
	{
		if( ( *itMatrix_4d5== matrix_4d3)&& ( *itDT_4de== dT_4dc))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_4cf.push_back( matrix_4d3);
		_dT_4d8.push_back( dT_4dc);
	}
	return isUnique;
}

bool MakeAssoc_4ca::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void MakeAssoc_4ca::processInputPackets( const Packets_t& matrixs_4cb, const Packets_t& dTs_4cd)
{
	for( Packets_t::const_iterator itMatrix_4d0= matrixs_4cb.begin(), itDT_4d9= dTs_4cd.begin(); itMatrix_4d0!= matrixs_4cb.end(), itDT_4d9!= dTs_4cd.end(); ++itMatrix_4d0, ++itDT_4d9)
	{
		bool isUnique= isInputUnique( *itMatrix_4d0, *itDT_4d9);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_4d0, *itDT_4d9);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool MakeAssoc_4ca::patternMatcher( const Udm::Object& matrix_4d1, const Udm::Object& dT_4da)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_4d1.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_4d6= CyberComposition::Simulink::SF_Matrix::Cast( matrix_4d1);
		if( false== Uml::IsDerivedFrom( dT_4da.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_4df= SFC::DT::Cast( dT_4da);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4e4;
		if( !isValidBound(boundObjs_4e4, matrix_4d6, true))
			continue;
		currMatch.matrix_4e5= matrix_4d6;
		if( !isValidBound(boundObjs_4e4, dT_4df, true))
			continue;
		currMatch.dT_4e6= dT_4df;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void MakeAssoc_4ca::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		currMatch.dT_4e6.tb()+= currMatch.matrix_4e5;
	}
}

void RegisterType_4e7::operator()( const Packets_t& matrixs_4e8, const Packets_t& dTs_4eb, Packets_t& matrixs_4ea, Packets_t& dTs_4ed)
{
#ifdef PRINT_INFO
	printLog( "RegisterType_4e7" );
#endif
	RTTGenerator::Instance()->generateRule(202, "RegisterType");
	_matrix_4ee= &matrixs_4ea;
	_dT_4ef= &dTs_4ed;
	processInputPackets( matrixs_4e8, dTs_4eb);
	forwardInputs( );
}

bool RegisterType_4e7::isInputUnique( const Udm::Object& matrix_4f4, const Udm::Object& dT_4fd)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMatrix_4f6= _matrix_4f0.begin(), itDT_4ff= _dT_4f9.begin(); itMatrix_4f6!= _matrix_4f0.end(), itDT_4ff!= _dT_4f9.end(); ++itMatrix_4f6, ++itDT_4ff)
	{
		if( ( *itMatrix_4f6== matrix_4f4)&& ( *itDT_4ff== dT_4fd))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_matrix_4f0.push_back( matrix_4f4);
		_dT_4f9.push_back( dT_4fd);
	}
	return isUnique;
}

bool RegisterType_4e7::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void RegisterType_4e7::processInputPackets( const Packets_t& matrixs_4e8, const Packets_t& dTs_4eb)
{
	for( Packets_t::const_iterator itMatrix_4f1= matrixs_4e8.begin(), itDT_4fa= dTs_4eb.begin(); itMatrix_4f1!= matrixs_4e8.end(), itDT_4fa!= dTs_4eb.end(); ++itMatrix_4f1, ++itDT_4fa)
	{
		bool isUnique= isInputUnique( *itMatrix_4f1, *itDT_4fa);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMatrix_4f1, *itDT_4fa);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool RegisterType_4e7::patternMatcher( const Udm::Object& matrix_4f2, const Udm::Object& dT_4fb)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( matrix_4f2.type(), CyberComposition::Simulink::SF_Matrix::meta))
			continue;
		CyberComposition::Simulink::SF_Matrix matrix_4f7= CyberComposition::Simulink::SF_Matrix::Cast( matrix_4f2);
		if( false== Uml::IsDerivedFrom( dT_4fb.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_500= SFC::DT::Cast( dT_4fb);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_505;
		if( !isValidBound(boundObjs_505, matrix_4f7, true))
			continue;
		currMatch.matrix_506= matrix_4f7;
		if( !isValidBound(boundObjs_505, dT_500, true))
			continue;
		currMatch.dT_507= dT_500;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void RegisterType_4e7::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::DT& DT= currMatch.dT_507;
		CyberComposition::Simulink::SF_Matrix& Matrix= currMatch.matrix_506;
		{
SFCTypesManager::getSingleton().makeTypeUnique( DT );
};
	}
}

void RegisterType_4e7::forwardInputs()
{
	*_matrix_4ee= _matrix_4f0;
	*_dT_4ef= _dT_4f9;
}

void StructMembers_523::operator()( const Packets_t& typess_524, const Packets_t& newStructs_526, Packets_t& newStructs_528)
{
#ifdef PRINT_INFO
	printLog( "StructMembers_523" );
#endif
	_newStruct_529= &newStructs_528;
	if( ( !typess_524.empty())&& ( !newStructs_526.empty()))
		callCreateStructMembers_550( typess_524, newStructs_526);
	_newStruct_529->insert( _newStruct_529->end(), newStructs_526.begin(), newStructs_526.end());
}

void StructMembers_523::callCreateStructMembers_550( const Packets_t& eSMoL_Structs_52b, const Packets_t& sfc_Structs_52d)
{
	CreateStructMembers_52a createStructMembers_52a;
	createStructMembers_52a( eSMoL_Structs_52b, sfc_Structs_52d);
}

void CreateStructMembers_52a::operator()( const Packets_t& eSMoL_Structs_52b, const Packets_t& sfc_Structs_52d)
{
#ifdef PRINT_INFO
	printLog( "CreateStructMembers_52a" );
#endif
	RTTGenerator::Instance()->generateRule(210, "CreateStructMembers");
	processInputPackets( eSMoL_Structs_52b, sfc_Structs_52d);
}

bool CreateStructMembers_52a::isInputUnique( const Udm::Object& eSMoL_Struct_533, const Udm::Object& sfc_Struct_53c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itESMoL_Struct_535= _eSMoL_Struct_52f.begin(), itsfc_Struct_53e= _sfc_Struct_538.begin(); itESMoL_Struct_535!= _eSMoL_Struct_52f.end(), itsfc_Struct_53e!= _sfc_Struct_538.end(); ++itESMoL_Struct_535, ++itsfc_Struct_53e)
	{
		if( ( *itESMoL_Struct_535== eSMoL_Struct_533)&& ( *itsfc_Struct_53e== sfc_Struct_53c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_eSMoL_Struct_52f.push_back( eSMoL_Struct_533);
		_sfc_Struct_538.push_back( sfc_Struct_53c);
	}
	return isUnique;
}

bool CreateStructMembers_52a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateStructMembers_52a::processInputPackets( const Packets_t& eSMoL_Structs_52b, const Packets_t& sfc_Structs_52d)
{
	for( Packets_t::const_iterator itESMoL_Struct_530= eSMoL_Structs_52b.begin(), itsfc_Struct_539= sfc_Structs_52d.begin(); itESMoL_Struct_530!= eSMoL_Structs_52b.end(), itsfc_Struct_539!= sfc_Structs_52d.end(); ++itESMoL_Struct_530, ++itsfc_Struct_539)
	{
		bool isUnique= isInputUnique( *itESMoL_Struct_530, *itsfc_Struct_539);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itESMoL_Struct_530, *itsfc_Struct_539);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateStructMembers_52a::patternMatcher( const Udm::Object& eSMoL_Struct_531, const Udm::Object& sfc_Struct_53a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( eSMoL_Struct_531.type(), CyberComposition::Simulink::TypeStruct::meta))
			continue;
		CyberComposition::Simulink::TypeStruct eSMoL_Struct_536= CyberComposition::Simulink::TypeStruct::Cast( eSMoL_Struct_531);
		if( false== Uml::IsDerivedFrom( sfc_Struct_53a.type(), SFC::Struct::meta))
			continue;
		SFC::Struct sfc_Struct_53f= SFC::Struct::Cast( sfc_Struct_53a);
		set< CyberComposition::Simulink::TypeBaseRef> eSMoL_StructRefs_541= eSMoL_Struct_536.TypeBaseRef_kind_children();
		for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itESMoL_StructRef_542= eSMoL_StructRefs_541.begin(); itESMoL_StructRef_542!= eSMoL_StructRefs_541.end(); ++itESMoL_StructRef_542)
		{
			CyberComposition::Simulink::TypeBaseRef currESMoL_StructRef_543= *itESMoL_StructRef_542;
			CyberComposition::Simulink::SF_TypeBase eSMoL_TypeBase_544= currESMoL_StructRef_543.ref();
			if( !eSMoL_TypeBase_544)
				continue;
			SFC::DT sfc_DT_545= eSMoL_TypeBase_544.dt();
			if( !sfc_DT_545)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_549;
			if( !isValidBound(boundObjs_549, eSMoL_Struct_536, true))
				continue;
			currMatch.eSMoL_Struct_54a= eSMoL_Struct_536;
			if( !isValidBound(boundObjs_549, sfc_Struct_53f, true))
				continue;
			currMatch.sfc_Struct_54b= sfc_Struct_53f;
			if( !isValidBound(boundObjs_549, currESMoL_StructRef_543, false))
				continue;
			currMatch.eSMoL_StructRef_54c= currESMoL_StructRef_543;
			if( !isValidBound(boundObjs_549, eSMoL_TypeBase_544, false))
				continue;
			currMatch.eSMoL_TypeBase_54d= eSMoL_TypeBase_544;
			if( !isValidBound(boundObjs_549, sfc_DT_545, false))
				continue;
			currMatch.sfc_DT_54e= sfc_DT_545;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateStructMembers_52a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newStructLocalVar_54f= SFC::LocalVar::Create( currMatch.sfc_Struct_54b, SFC::Struct::meta_memb);
		CyberComposition::Simulink::TypeStruct& ESMoL_Struct= currMatch.eSMoL_Struct_54a;
		CyberComposition::Simulink::TypeBaseRef& ESMoL_StructRef= currMatch.eSMoL_StructRef_54c;
		CyberComposition::Simulink::SF_TypeBase& ESMoL_TypeBase= currMatch.eSMoL_TypeBase_54d;
		SFC::LocalVar& StructLocalVar= newStructLocalVar_54f;
		SFC::DT& sfc_DT= currMatch.sfc_DT_54e;
		SFC::Struct& sfc_Struct= currMatch.sfc_Struct_54b;
		{
StructLocalVar.name() = ESMoL_StructRef.name();
StructLocalVar.statementIndex() = ESMoL_StructRef.MemberIndex();
};
		newStructLocalVar_54f.tbr()= currMatch.eSMoL_StructRef_54c;
		newStructLocalVar_54f.dt()= currMatch.sfc_DT_54e;
	}
}

void RegisterStruct_553::operator()( const Packets_t& sfcStructs_554)
{
#ifdef PRINT_INFO
	printLog( "RegisterStruct_553" );
#endif
	RTTGenerator::Instance()->generateRule(224, "RegisterStruct");
	processInputPackets( sfcStructs_554);
}

bool RegisterStruct_553::isInputUnique( const Udm::Object& sfcStruct_55a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itsfcStruct_55c= _sfcStruct_556.begin(); itsfcStruct_55c!= _sfcStruct_556.end(); ++itsfcStruct_55c)
	{
		if( ( *itsfcStruct_55c== sfcStruct_55a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_sfcStruct_556.push_back( sfcStruct_55a);
	return isUnique;
}

bool RegisterStruct_553::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void RegisterStruct_553::processInputPackets( const Packets_t& sfcStructs_554)
{
	for( Packets_t::const_iterator itsfcStruct_557= sfcStructs_554.begin(); itsfcStruct_557!= sfcStructs_554.end(); ++itsfcStruct_557)
	{
		bool isUnique= isInputUnique( *itsfcStruct_557);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itsfcStruct_557);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool RegisterStruct_553::patternMatcher( const Udm::Object& sfcStruct_558)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( sfcStruct_558.type(), SFC::Struct::meta))
			continue;
		SFC::Struct sfcStruct_55d= SFC::Struct::Cast( sfcStruct_558);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_562;
		if( !isValidBound(boundObjs_562, sfcStruct_55d, true))
			continue;
		currMatch.sfcStruct_563= sfcStruct_55d;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void RegisterStruct_553::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Struct& sfcStruct= currMatch.sfcStruct_563;
		{
SFCTypesManager::getSingleton().makeTypeUnique( sfcStruct );
};
	}
}

void GetTypes_564::operator()( const Packets_t& states_565, const Packets_t& projects_567, Packets_t& typess_569, Packets_t& projects_56a)
{
#ifdef PRINT_INFO
	printLog( "GetTypes_564" );
#endif
	_types_56b= &typess_569;
	_project_56c= &projects_56a;
	if( ( !states_565.empty())&& ( !projects_567.empty()))
		callGetContainer_608( states_565, projects_567);
}

void GetTypes_564::callGetContainer_608( const Packets_t& dataflows_56f, const Packets_t& projects_571)
{
	Packets_t designFolders_56e;
	Packets_t projects_573;
	GetContainer_56d getContainer_56d;
	getContainer_56d( dataflows_56f, projects_571, designFolders_56e, projects_573);
	if( ( !designFolders_56e.empty())&& ( !projects_573.empty()))
		callGetTypes_60b( designFolders_56e, projects_573);
}

void GetTypes_564::callGetTypes_60b( const Packets_t& containers_596, const Packets_t& projects_598)
{
	Packets_t typess_59a;
	Packets_t projects_59b;
	GetTypes_595 getTypes_595;
	getTypes_595( containers_596, projects_598, typess_59a, projects_59b);
	_types_56b->insert( _types_56b->end(), typess_59a.begin(), typess_59a.end());
	_project_56c->insert( _project_56c->end(), projects_59b.begin(), projects_59b.end());
}

void GetContainer_56d::operator()( const Packets_t& dataflows_56f, const Packets_t& projects_571, Packets_t& designFolders_56e, Packets_t& projects_573)
{
#ifdef PRINT_INFO
	printLog( "GetContainer_56d" );
#endif
	RTTGenerator::Instance()->generateRule(232, "GetContainer");
	_designFolder_574= &designFolders_56e;
	_project_575= &projects_573;
	processInputPackets( dataflows_56f, projects_571);
}

bool GetContainer_56d::isInputUnique( const Udm::Object& dataflow_57a, const Udm::Object& project_583)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itDataflow_57c= _dataflow_576.begin(), itProject_585= _project_57f.begin(); itDataflow_57c!= _dataflow_576.end(), itProject_585!= _project_57f.end(); ++itDataflow_57c, ++itProject_585)
	{
		if( ( *itDataflow_57c== dataflow_57a)&& ( *itProject_585== project_583))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_dataflow_576.push_back( dataflow_57a);
		_project_57f.push_back( project_583);
	}
	return isUnique;
}

bool GetContainer_56d::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetContainer_56d::processInputPackets( const Packets_t& dataflows_56f, const Packets_t& projects_571)
{
	for( Packets_t::const_iterator itDataflow_577= dataflows_56f.begin(), itProject_580= projects_571.begin(); itDataflow_577!= dataflows_56f.end(), itProject_580!= projects_571.end(); ++itDataflow_577, ++itProject_580)
	{
		bool isUnique= isInputUnique( *itDataflow_577, *itProject_580);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itDataflow_577, *itProject_580);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetContainer_56d::patternMatcher( const Udm::Object& dataflow_578, const Udm::Object& project_581)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( dataflow_578.type(), CyberComposition::SimulinkWrapper::meta))
			continue;
		CyberComposition::SimulinkWrapper dataflow_57d= CyberComposition::SimulinkWrapper::Cast( dataflow_578);
		if( false== Uml::IsDerivedFrom( project_581.type(), SFC::Project::meta))
			continue;
		SFC::Project project_586= SFC::Project::Cast( project_581);
		Udm::Object dataflowParent_588= dataflow_57d.container();
		if( false== Uml::IsDerivedFrom( dataflowParent_588.type(), CyberComposition::Components::meta))
			continue;
		CyberComposition::Components designFolderDataflow_589= CyberComposition::Components::Cast( dataflowParent_588);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_58d;
		if( !isValidBound(boundObjs_58d, dataflow_57d, true))
			continue;
		currMatch.dataflow_58e= dataflow_57d;
		if( !isValidBound(boundObjs_58d, project_586, true))
			continue;
		currMatch.project_58f= project_586;
		if( !isValidBound(boundObjs_58d, designFolderDataflow_589, false))
			continue;
		currMatch.designFolder_590= designFolderDataflow_589;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void GetContainer_56d::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.designFolder_590, currMatch.project_58f);
	}
}

void GetContainer_56d::outputAppender( const CyberComposition::Components& designFolder_591, const SFC::Project& project_593)
{
	_designFolder_574->push_back( designFolder_591);
	_project_575->push_back( project_593);
}

void GetTypes_595::operator()( const Packets_t& containers_596, const Packets_t& projects_598, Packets_t& typess_59a, Packets_t& projects_59b)
{
#ifdef PRINT_INFO
	printLog( "GetTypes_595" );
#endif
	_types_59c= &typess_59a;
	_project_59d= &projects_59b;
	if( ( !containers_596.empty())&& ( !projects_598.empty()))
		callGetTypes_NonLib_602( containers_596, projects_598);
	if( ( !containers_596.empty())&& ( !projects_598.empty()))
		callGetTypes_Lib_605( containers_596, projects_598);
}

void GetTypes_595::callGetTypes_NonLib_602( const Packets_t& designFolders_59f, const Packets_t& projects_5a2)
{
	Packets_t typeBases_5a1;
	Packets_t projects_5a4;
	GetTypes_NonLib_59e getTypes_NonLib_59e;
	getTypes_NonLib_59e( designFolders_59f, projects_5a2, typeBases_5a1, projects_5a4);
	_types_59c->insert( _types_59c->end(), typeBases_5a1.begin(), typeBases_5a1.end());
	_project_59d->insert( _project_59d->end(), projects_5a4.begin(), projects_5a4.end());
}

void GetTypes_595::callGetTypes_Lib_605( const Packets_t& designFolders_5cf, const Packets_t& projects_5d2)
{
	Packets_t typeBases_5d1;
	Packets_t projects_5d4;
	GetTypes_Lib_5ce getTypes_Lib_5ce;
	getTypes_Lib_5ce( designFolders_5cf, projects_5d2, typeBases_5d1, projects_5d4);
	_types_59c->insert( _types_59c->end(), typeBases_5d1.begin(), typeBases_5d1.end());
	_project_59d->insert( _project_59d->end(), projects_5d4.begin(), projects_5d4.end());
}

void GetTypes_NonLib_59e::operator()( const Packets_t& designFolders_59f, const Packets_t& projects_5a2, Packets_t& typeBases_5a1, Packets_t& projects_5a4)
{
#ifdef PRINT_INFO
	printLog( "GetTypes_NonLib_59e" );
#endif
	RTTGenerator::Instance()->generateRule(242, "GetTypes_NonLib");
	_typeBase_5a5= &typeBases_5a1;
	_project_5a6= &projects_5a4;
	processInputPackets( designFolders_59f, projects_5a2);
}

bool GetTypes_NonLib_59e::isInputUnique( const Udm::Object& designFolder_5ab, const Udm::Object& project_5b4)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itDesignFolder_5ad= _designFolder_5a7.begin(), itProject_5b6= _project_5b0.begin(); itDesignFolder_5ad!= _designFolder_5a7.end(), itProject_5b6!= _project_5b0.end(); ++itDesignFolder_5ad, ++itProject_5b6)
	{
		if( ( *itDesignFolder_5ad== designFolder_5ab)&& ( *itProject_5b6== project_5b4))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_designFolder_5a7.push_back( designFolder_5ab);
		_project_5b0.push_back( project_5b4);
	}
	return isUnique;
}

bool GetTypes_NonLib_59e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetTypes_NonLib_59e::processInputPackets( const Packets_t& designFolders_59f, const Packets_t& projects_5a2)
{
	for( Packets_t::const_iterator itDesignFolder_5a8= designFolders_59f.begin(), itProject_5b1= projects_5a2.begin(); itDesignFolder_5a8!= designFolders_59f.end(), itProject_5b1!= projects_5a2.end(); ++itDesignFolder_5a8, ++itProject_5b1)
	{
		bool isUnique= isInputUnique( *itDesignFolder_5a8, *itProject_5b1);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itDesignFolder_5a8, *itProject_5b1);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetTypes_NonLib_59e::patternMatcher( const Udm::Object& designFolder_5a9, const Udm::Object& project_5b2)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( designFolder_5a9.type(), CyberComposition::Components::meta))
			continue;
		CyberComposition::Components designFolder_5ae= CyberComposition::Components::Cast( designFolder_5a9);
		if( false== Uml::IsDerivedFrom( project_5b2.type(), SFC::Project::meta))
			continue;
		SFC::Project project_5b7= SFC::Project::Cast( project_5b2);
		Udm::Object designFolderParent_5b9= designFolder_5ae.container();
		if( false== Uml::IsDerivedFrom( designFolderParent_5b9.type(), CyberComposition::RootFolder::meta))
			continue;
		CyberComposition::RootFolder rootFolderDesignFolder_5ba= CyberComposition::RootFolder::Cast( designFolderParent_5b9);
		set< CyberComposition::Simulink::Types> typess_5bb= rootFolderDesignFolder_5ba.Simulink_Types_children();
		for( set< CyberComposition::Simulink::Types>::const_iterator itTypes_5bc= typess_5bb.begin(); itTypes_5bc!= typess_5bb.end(); ++itTypes_5bc)
		{
			CyberComposition::Simulink::Types currTypes_5bd= *itTypes_5bc;
			set< CyberComposition::Simulink::SF_TypeBase> typeBases_5be= currTypes_5bd.SF_TypeBase_kind_children();
			for( set< CyberComposition::Simulink::SF_TypeBase>::const_iterator itTypeBase_5bf= typeBases_5be.begin(); itTypeBase_5bf!= typeBases_5be.end(); ++itTypeBase_5bf)
			{
				CyberComposition::Simulink::SF_TypeBase currTypeBase_5c0= *itTypeBase_5bf;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_5c4;
				if( !isValidBound(boundObjs_5c4, designFolder_5ae, true))
					continue;
				currMatch.designFolder_5c5= designFolder_5ae;
				if( !isValidBound(boundObjs_5c4, project_5b7, true))
					continue;
				currMatch.project_5c6= project_5b7;
				if( !isValidBound(boundObjs_5c4, rootFolderDesignFolder_5ba, false))
					continue;
				currMatch.rootFolder_5c7= rootFolderDesignFolder_5ba;
				if( !isValidBound(boundObjs_5c4, currTypes_5bd, false))
					continue;
				currMatch.types_5c8= currTypes_5bd;
				if( !isValidBound(boundObjs_5c4, currTypeBase_5c0, false))
					continue;
				currMatch.typeBase_5c9= currTypeBase_5c0;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetTypes_NonLib_59e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.typeBase_5c9, currMatch.project_5c6);
	}
}

void GetTypes_NonLib_59e::outputAppender( const CyberComposition::Simulink::SF_TypeBase& typeBase_5ca, const SFC::Project& project_5cc)
{
	_typeBase_5a5->push_back( typeBase_5ca);
	_project_5a6->push_back( project_5cc);
}

void GetTypes_Lib_5ce::operator()( const Packets_t& designFolders_5cf, const Packets_t& projects_5d2, Packets_t& typeBases_5d1, Packets_t& projects_5d4)
{
#ifdef PRINT_INFO
	printLog( "GetTypes_Lib_5ce" );
#endif
	RTTGenerator::Instance()->generateRule(251, "GetTypes_Lib");
	_typeBase_5d5= &typeBases_5d1;
	_project_5d6= &projects_5d4;
	processInputPackets( designFolders_5cf, projects_5d2);
}

bool GetTypes_Lib_5ce::isInputUnique( const Udm::Object& designFolder_5db, const Udm::Object& project_5e4)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itDesignFolder_5dd= _designFolder_5d7.begin(), itProject_5e6= _project_5e0.begin(); itDesignFolder_5dd!= _designFolder_5d7.end(), itProject_5e6!= _project_5e0.end(); ++itDesignFolder_5dd, ++itProject_5e6)
	{
		if( ( *itDesignFolder_5dd== designFolder_5db)&& ( *itProject_5e6== project_5e4))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_designFolder_5d7.push_back( designFolder_5db);
		_project_5e0.push_back( project_5e4);
	}
	return isUnique;
}

bool GetTypes_Lib_5ce::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetTypes_Lib_5ce::processInputPackets( const Packets_t& designFolders_5cf, const Packets_t& projects_5d2)
{
	for( Packets_t::const_iterator itDesignFolder_5d8= designFolders_5cf.begin(), itProject_5e1= projects_5d2.begin(); itDesignFolder_5d8!= designFolders_5cf.end(), itProject_5e1!= projects_5d2.end(); ++itDesignFolder_5d8, ++itProject_5e1)
	{
		bool isUnique= isInputUnique( *itDesignFolder_5d8, *itProject_5e1);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itDesignFolder_5d8, *itProject_5e1);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetTypes_Lib_5ce::patternMatcher( const Udm::Object& designFolder_5d9, const Udm::Object& project_5e2)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( designFolder_5d9.type(), CyberComposition::Components::meta))
			continue;
		CyberComposition::Components designFolder_5de= CyberComposition::Components::Cast( designFolder_5d9);
		if( false== Uml::IsDerivedFrom( project_5e2.type(), SFC::Project::meta))
			continue;
		SFC::Project project_5e7= SFC::Project::Cast( project_5e2);
		Udm::Object designFolderParent_5e9= designFolder_5de.container();
		if( false== Uml::IsDerivedFrom( designFolderParent_5e9.type(), CyberComposition::RootFolder::meta))
			continue;
		CyberComposition::RootFolder rootFolderDesignFolder_5ea= CyberComposition::RootFolder::Cast( designFolderParent_5e9);
		set< CyberComposition::RootFolder> rootFolders_5eb= rootFolderDesignFolder_5ea.RootFolder_kind_children();
		for( set< CyberComposition::RootFolder>::const_iterator itRootFolder_5ec= rootFolders_5eb.begin(); itRootFolder_5ec!= rootFolders_5eb.end(); ++itRootFolder_5ec)
		{
			CyberComposition::RootFolder currRootFolder_5ed= *itRootFolder_5ec;
			set< CyberComposition::Simulink::Types> typess_5ee= currRootFolder_5ed.Simulink_Types_children();
			for( set< CyberComposition::Simulink::Types>::const_iterator itTypes_5ef= typess_5ee.begin(); itTypes_5ef!= typess_5ee.end(); ++itTypes_5ef)
			{
				CyberComposition::Simulink::Types currTypes_5f0= *itTypes_5ef;
				set< CyberComposition::Simulink::SF_TypeBase> typeBases_5f1= currTypes_5f0.SF_TypeBase_kind_children();
				for( set< CyberComposition::Simulink::SF_TypeBase>::const_iterator itTypeBase_5f2= typeBases_5f1.begin(); itTypeBase_5f2!= typeBases_5f1.end(); ++itTypeBase_5f2)
				{
					CyberComposition::Simulink::SF_TypeBase currTypeBase_5f3= *itTypeBase_5f2;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_5f7;
					if( !isValidBound(boundObjs_5f7, designFolder_5de, true))
						continue;
					currMatch.designFolder_5f8= designFolder_5de;
					if( !isValidBound(boundObjs_5f7, project_5e7, true))
						continue;
					currMatch.project_5f9= project_5e7;
					if( !isValidBound(boundObjs_5f7, rootFolderDesignFolder_5ea, false))
						continue;
					currMatch.rootFolder_5fa= rootFolderDesignFolder_5ea;
					if( !isValidBound(boundObjs_5f7, currRootFolder_5ed, false))
						continue;
					currMatch.rootFolder_5fb= currRootFolder_5ed;
					if( !isValidBound(boundObjs_5f7, currTypes_5f0, false))
						continue;
					currMatch.types_5fc= currTypes_5f0;
					if( !isValidBound(boundObjs_5f7, currTypeBase_5f3, false))
						continue;
					currMatch.typeBase_5fd= currTypeBase_5f3;
					_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void GetTypes_Lib_5ce::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.typeBase_5fd, currMatch.project_5f9);
	}
}

void GetTypes_Lib_5ce::outputAppender( const CyberComposition::Simulink::SF_TypeBase& typeBase_5fe, const SFC::Project& project_600)
{
	_typeBase_5d5->push_back( typeBase_5fe);
	_project_5d6->push_back( project_600);
}

void MergeClasses_619::operator()( const Packets_t& dataflows_61a, const Packets_t& projects_61c, Packets_t& dataflows_61e, Packets_t& projects_61f)
{
#ifdef PRINT_INFO
	printLog( "MergeClasses_619" );
#endif
	_dataflow_620= &dataflows_61e;
	_project_621= &projects_61f;
	_dataflow_620->insert( _dataflow_620->end(), dataflows_61a.begin(), dataflows_61a.end());
	_project_621->insert( _project_621->end(), projects_61c.begin(), projects_61c.end());
	if( ( !projects_61c.empty()))
		callMergeClasses_cf0( projects_61c);
}

void MergeClasses_619::callMergeClasses_cf0( const Packets_t& projects_623)
{
	Packets_t projects_625;
	MergeClasses_622 mergeClasses_622;
	mergeClasses_622( projects_623, projects_625);
	if( ( !projects_625.empty()))
		callElimRedundantClasses_cf2( projects_625);
}

void MergeClasses_619::callElimRedundantClasses_cf2( const Packets_t& projects_c96)
{
	Packets_t projects_c98;
	ElimRedundantClasses_c95 elimRedundantClasses_c95;
	elimRedundantClasses_c95( projects_c96, projects_c98);
}

void MergeClasses_622::operator()( const Packets_t& projects_623, Packets_t& projects_625)
{
#ifdef PRINT_INFO
	printLog( "MergeClasses_622" );
#endif
	_project_626= &projects_625;
	_project_626->insert( _project_626->end(), projects_623.begin(), projects_623.end());
	if( ( !projects_623.empty()))
		callMakeEquivalence_c8f( projects_623);
}

void MergeClasses_622::callMakeEquivalence_c8f( const Packets_t& projects_628)
{
	Packets_t projects_62a;
	MakeEquivalence_627 makeEquivalence_627;
	makeEquivalence_627( projects_628, projects_62a);
	if( ( !projects_62a.empty()))
		callGetClasses_c91( projects_62a);
}

void MergeClasses_622::callGetClasses_c91( const Packets_t& projects_656)
{
	Packets_t classs_655;
	GetClasses_654 getClasses_654;
	getClasses_654( projects_656, classs_655);
	if( ( !classs_655.empty()))
		callOneClassAtATime_c93( classs_655);
}

void MergeClasses_622::callOneClassAtATime_c93( const Packets_t& classs_672)
{
	OneClassAtATime_671 oneClassAtATime_671;
	oneClassAtATime_671( classs_672);
}

void MakeEquivalence_627::operator()( const Packets_t& projects_628, Packets_t& projects_62a)
{
#ifdef PRINT_INFO
	printLog( "MakeEquivalence_627" );
#endif
	RTTGenerator::Instance()->generateRule(270, "MakeEquivalence");
	_project_62b= &projects_62a;
	processInputPackets( projects_628);
	forwardInputs( );
}

bool MakeEquivalence_627::isInputUnique( const Udm::Object& project_630)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itProject_632= _project_62c.begin(); itProject_632!= _project_62c.end(); ++itProject_632)
	{
		if( ( *itProject_632== project_630))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_project_62c.push_back( project_630);
	return isUnique;
}

bool MakeEquivalence_627::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool MakeEquivalence_627::isGuardTrue( SFC::Class& Class1, SFC::Class& Class2, SFC::Program& Program, SFC::Project& Project, CyberComposition::Simulink::Subsystem& Subsystem1, CyberComposition::Simulink::Subsystem& Subsystem2)
{
	bool Gz_guard= false;
	Gz_guard =
 Class1.uniqueId() > Class2.uniqueId() &&
 SFUtils::InstanceEquivalent( Subsystem1, Subsystem2 );;
	return Gz_guard;
}

void MakeEquivalence_627::processInputPackets( const Packets_t& projects_628)
{
	for( Packets_t::const_iterator itProject_62d= projects_628.begin(); itProject_62d!= projects_628.end(); ++itProject_62d)
	{
		bool isUnique= isInputUnique( *itProject_62d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itProject_62d);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool MakeEquivalence_627::patternMatcher( const Udm::Object& project_62e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( project_62e.type(), SFC::Project::meta))
			continue;
		SFC::Project project_633= SFC::Project::Cast( project_62e);
		set< SFC::Program> programs_635= project_633.Program_kind_children();
		for( set< SFC::Program>::const_iterator itProgram_636= programs_635.begin(); itProgram_636!= programs_635.end(); ++itProgram_636)
		{
			SFC::Program currProgram_637= *itProgram_636;
			set< SFC::Class> class2s_638= currProgram_637.Class_kind_children();
			for( set< SFC::Class>::const_iterator itClass2_639= class2s_638.begin(); itClass2_639!= class2s_638.end(); ++itClass2_639)
			{
				SFC::Class currClass2_63a= *itClass2_639;
				set< SFC::Class> class1s_63b= currProgram_637.Class_kind_children();
				for( set< SFC::Class>::const_iterator itClass1_63c= class1s_63b.begin(); itClass1_63c!= class1s_63b.end(); ++itClass1_63c)
				{
					SFC::Class currClass1_63d= *itClass1_63c;
					set< CyberComposition::Simulink::Subsystem> subsystem1s_63e= currClass1_63d.obj();
					for( set< CyberComposition::Simulink::Subsystem>::const_iterator itSubsystem1s_63f= subsystem1s_63e.begin(); itSubsystem1s_63f!= subsystem1s_63e.end(); ++itSubsystem1s_63f)
					{
						CyberComposition::Simulink::Subsystem currSubsystem1_640= *itSubsystem1s_63f;
						set< CyberComposition::Simulink::Subsystem> subsystem2s_641= currClass2_63a.obj();
						for( set< CyberComposition::Simulink::Subsystem>::const_iterator itSubsystem2s_642= subsystem2s_641.begin(); itSubsystem2s_642!= subsystem2s_641.end(); ++itSubsystem2s_642)
						{
							CyberComposition::Simulink::Subsystem currSubsystem2_643= *itSubsystem2s_642;
							Match currMatch;
							set< pair<int, Udm::Object> > boundObjs_647;
							if( !isValidBound(boundObjs_647, project_633, true))
								continue;
							currMatch.project_648= project_633;
							if( !isValidBound(boundObjs_647, currProgram_637, false))
								continue;
							currMatch.program_649= currProgram_637;
							if( !isValidBound(boundObjs_647, currClass1_63d, false))
								continue;
							currMatch.class1_64a= currClass1_63d;
							if( !isValidBound(boundObjs_647, currClass2_63a, false))
								continue;
							currMatch.class2_64b= currClass2_63a;
							if( !isValidBound(boundObjs_647, currSubsystem1_640, false))
								continue;
							currMatch.subsystem1_64c= currSubsystem1_640;
							if( !isValidBound(boundObjs_647, currSubsystem2_643, false))
								continue;
							currMatch.subsystem2_64d= currSubsystem2_643;
							bool Gz_guard= isGuardTrue( currMatch.class1_64a, currMatch.class2_64b, currMatch.program_649, currMatch.project_648, currMatch.subsystem1_64c, currMatch.subsystem2_64d);
							if( true== Gz_guard)
								_matches.push_back( currMatch);
						}
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void MakeEquivalence_627::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		currMatch.class1_64a.equivdst()+= currMatch.class2_64b;
	}
}

void MakeEquivalence_627::forwardInputs()
{
	*_project_62b= _project_62c;
}

void GetClasses_654::operator()( const Packets_t& projects_656, Packets_t& classs_655)
{
#ifdef PRINT_INFO
	printLog( "GetClasses_654" );
#endif
	RTTGenerator::Instance()->generateRule(283, "GetClasses");
	_class_658= &classs_655;
	processInputPackets( projects_656);
}

bool GetClasses_654::isInputUnique( const Udm::Object& project_65d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itProject_65f= _project_659.begin(); itProject_65f!= _project_659.end(); ++itProject_65f)
	{
		if( ( *itProject_65f== project_65d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_project_659.push_back( project_65d);
	return isUnique;
}

bool GetClasses_654::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetClasses_654::processInputPackets( const Packets_t& projects_656)
{
	for( Packets_t::const_iterator itProject_65a= projects_656.begin(); itProject_65a!= projects_656.end(); ++itProject_65a)
	{
		bool isUnique= isInputUnique( *itProject_65a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itProject_65a);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetClasses_654::patternMatcher( const Udm::Object& project_65b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( project_65b.type(), SFC::Project::meta))
			continue;
		SFC::Project project_660= SFC::Project::Cast( project_65b);
		set< SFC::Program> programs_662= project_660.Program_kind_children();
		for( set< SFC::Program>::const_iterator itProgram_663= programs_662.begin(); itProgram_663!= programs_662.end(); ++itProgram_663)
		{
			SFC::Program currProgram_664= *itProgram_663;
			set< SFC::Class> classs_665= currProgram_664.Class_kind_children();
			for( set< SFC::Class>::const_iterator itClass_666= classs_665.begin(); itClass_666!= classs_665.end(); ++itClass_666)
			{
				SFC::Class currClass_667= *itClass_666;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_66b;
				if( !isValidBound(boundObjs_66b, project_660, true))
					continue;
				currMatch.project_66c= project_660;
				if( !isValidBound(boundObjs_66b, currProgram_664, false))
					continue;
				currMatch.program_66d= currProgram_664;
				if( !isValidBound(boundObjs_66b, currClass_667, false))
					continue;
				currMatch.class_66e= currClass_667;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetClasses_654::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.class_66e);
	}
}

void GetClasses_654::outputAppender( const SFC::Class& class_66f)
{
	_class_658->push_back( class_66f);
}

void OneClassAtATime_671::operator()( const Packets_t& classs_672)
{
#ifdef PRINT_INFO
	printLog( "OneClassAtATime_671" );
#endif
	for( Packets_t::const_iterator itclass_675= classs_672.begin(); itclass_675!= classs_672.end(); ++itclass_675)
	{
		bool isUnique= isInputUnique( *itclass_675);
		if( !isUnique)
			continue;
		Packets_t oneclass_679( 1, *itclass_675);
		executeOne( oneclass_679);
	}
}

void OneClassAtATime_671::executeOne( const Packets_t& classs_672)
{
	if( ( !classs_672.empty()))
		callClassFilter_c87( classs_672);
}

bool OneClassAtATime_671::isInputUnique( const Udm::Object& class_676)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itclass_678= _class_674.begin(); itclass_678!= _class_674.end(); ++itclass_678)
	{
		if( ( *itclass_678== class_676))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_class_674.push_back( class_676);
	return isUnique;
}

void OneClassAtATime_671::callClassFilter_c87( const Packets_t& classs_bf6)
{
	Packets_t classs_bf8;
	ClassFilter_bf5 classFilter_bf5;
	classFilter_bf5( classs_bf6, classs_bf8);
	if( ( !classs_bf8.empty()))
		callMergeClasses_c89( classs_bf8);
}

void OneClassAtATime_671::callMergeClasses_c89( const Packets_t& classs_67c)
{
	Packets_t classs_67e;
	MergeClasses_67b mergeClasses_67b;
	mergeClasses_67b( classs_67c, classs_67e);
	if( ( !classs_67e.empty()))
		callGetNextLevelClasses_c8b( classs_67e);
}

void OneClassAtATime_671::callGetNextLevelClasses_c8b( const Packets_t& childClasss_bd3)
{
	Packets_t parentClasss_bd5;
	GetNextLevelClasses_bd2 getNextLevelClasses_bd2;
	getNextLevelClasses_bd2( childClasss_bd3, parentClasss_bd5);
	if( ( !parentClasss_bd5.empty()))
		callOneClassAtATime_c8d( parentClasss_bd5);
}

void OneClassAtATime_671::callOneClassAtATime_c8d( const Packets_t& classs_672)
{
	OneClassAtATime_671 oneClassAtATime_671;
	oneClassAtATime_671( classs_672);
}

void MergeClasses_67b::operator()( const Packets_t& classs_67c, Packets_t& classs_67e)
{
#ifdef PRINT_INFO
	printLog( "MergeClasses_67b" );
#endif
	_class_67f= &classs_67e;
	if( ( !classs_67c.empty()))
		callTestEquivalence_bce( classs_67c);
	_class_67f->insert( _class_67f->end(), classs_67c.begin(), classs_67c.end());
}

void MergeClasses_67b::callTestEquivalence_bce( const Packets_t& classs_93e)
{
	Packets_t classs_940;
	TestEquivalence_93d testEquivalence_93d;
	testEquivalence_93d( classs_93e, classs_940);
	if( ( !classs_940.empty()))
		callElimEquiv_bd0( classs_940);
}

void MergeClasses_67b::callElimEquiv_bd0( const Packets_t& classs_681)
{
	ElimEquiv_680 elimEquiv_680;
	elimEquiv_680( classs_681);
}

void ElimEquiv_680::operator()( const Packets_t& classs_681)
{
#ifdef PRINT_INFO
	printLog( "ElimEquiv_680" );
#endif
	for( Packets_t::const_iterator itclass_684= classs_681.begin(); itclass_684!= classs_681.end(); ++itclass_684)
	{
		bool isUnique= isInputUnique( *itclass_684);
		if( !isUnique)
			continue;
		Packets_t oneclass_688( 1, *itclass_684);
		executeOne( oneclass_688);
	}
}

void ElimEquiv_680::executeOne( const Packets_t& classs_681)
{
	if( ( !classs_681.empty()))
		callGetEquivalence_930( classs_681);
}

bool ElimEquiv_680::isInputUnique( const Udm::Object& class_685)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itclass_687= _class_683.begin(); itclass_687!= _class_683.end(); ++itclass_687)
	{
		if( ( *itclass_687== class_685))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_class_683.push_back( class_685);
	return isUnique;
}

void ElimEquiv_680::callGetEquivalence_930( const Packets_t& class1s_68b)
{
	Packets_t class1s_68d;
	Packets_t class2s_68e;
	GetEquivalence_68a getEquivalence_68a;
	getEquivalence_68a( class1s_68b, class1s_68d, class2s_68e);
	if( ( !class1s_68d.empty())&& ( !class2s_68e.empty()))
		callTransferSubsystems_932( class1s_68d, class2s_68e);
}

void ElimEquiv_680::callTransferSubsystems_932( const Packets_t& class1s_6a8, const Packets_t& class2s_6aa)
{
	Packets_t class1s_6ac;
	Packets_t class2s_6ad;
	TransferSubsystems_6a7 transferSubsystems_6a7;
	transferSubsystems_6a7( class1s_6a8, class2s_6aa, class1s_6ac, class2s_6ad);
	if( ( !class1s_6ac.empty())&& ( !class2s_6ad.empty()))
		callTransferMethodCalls_935( class1s_6ac, class2s_6ad);
}

void ElimEquiv_680::callTransferMethodCalls_935( const Packets_t& class1s_83e, const Packets_t& class2s_840)
{
	Packets_t class1s_842;
	Packets_t class2s_843;
	TransferMethodCalls_83d transferMethodCalls_83d;
	transferMethodCalls_83d( class1s_83e, class2s_840, class1s_842, class2s_843);
	if( ( !class1s_842.empty())&& ( !class2s_843.empty()))
		callTransferStruct_938( class1s_842, class2s_843);
}

void ElimEquiv_680::callTransferStruct_938( const Packets_t& class1s_6d5, const Packets_t& class2s_6d7)
{
	Packets_t deleteclasss_6d9;
	TransferStruct_6d4 transferStruct_6d4;
	transferStruct_6d4( class1s_6d5, class2s_6d7, deleteclasss_6d9);
	if( ( !deleteclasss_6d9.empty()))
		callDeleteClass_93b( deleteclasss_6d9);
}

void ElimEquiv_680::callDeleteClass_93b( const Packets_t& deleteClasss_8e9)
{
	DeleteClass_8e8 deleteClass_8e8;
	deleteClass_8e8( deleteClasss_8e9);
}

void GetEquivalence_68a::operator()( const Packets_t& class1s_68b, Packets_t& class1s_68d, Packets_t& class2s_68e)
{
#ifdef PRINT_INFO
	printLog( "GetEquivalence_68a" );
#endif
	RTTGenerator::Instance()->generateRule(296, "GetEquivalence");
	_class1_68f= &class1s_68d;
	_class2_690= &class2s_68e;
	processInputPackets( class1s_68b);
}

bool GetEquivalence_68a::isInputUnique( const Udm::Object& class1_695)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass1_697= _class1_691.begin(); itClass1_697!= _class1_691.end(); ++itClass1_697)
	{
		if( ( *itClass1_697== class1_695))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_class1_691.push_back( class1_695);
	return isUnique;
}

bool GetEquivalence_68a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetEquivalence_68a::processInputPackets( const Packets_t& class1s_68b)
{
	for( Packets_t::const_iterator itClass1_692= class1s_68b.begin(); itClass1_692!= class1s_68b.end(); ++itClass1_692)
	{
		bool isUnique= isInputUnique( *itClass1_692);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass1_692);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetEquivalence_68a::patternMatcher( const Udm::Object& class1_693)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class1_693.type(), SFC::Class::meta))
			continue;
		SFC::Class class1_698= SFC::Class::Cast( class1_693);
		set< SFC::Class> class2s_69a= class1_698.equivdst();
		for( set< SFC::Class>::const_iterator itClass2s_69b= class2s_69a.begin(); itClass2s_69b!= class2s_69a.end(); ++itClass2s_69b)
		{
			SFC::Class currClass2_69c= *itClass2s_69b;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_6a0;
			if( !isValidBound(boundObjs_6a0, class1_698, true))
				continue;
			currMatch.class1_6a1= class1_698;
			if( !isValidBound(boundObjs_6a0, currClass2_69c, false))
				continue;
			currMatch.class2_6a2= currClass2_69c;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetEquivalence_68a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.class1_6a1, currMatch.class2_6a2);
	}
}

void GetEquivalence_68a::outputAppender( const SFC::Class& class1_6a3, const SFC::Class& class2_6a5)
{
	_class1_68f->push_back( class1_6a3);
	_class2_690->push_back( class2_6a5);
}

void TransferSubsystems_6a7::operator()( const Packets_t& class1s_6a8, const Packets_t& class2s_6aa, Packets_t& class1s_6ac, Packets_t& class2s_6ad)
{
#ifdef PRINT_INFO
	printLog( "TransferSubsystems_6a7" );
#endif
	_class1_6ae= &class1s_6ac;
	_class2_6af= &class2s_6ad;
	_class1_6ae->insert( _class1_6ae->end(), class1s_6a8.begin(), class1s_6a8.end());
	_class2_6af->insert( _class2_6af->end(), class2s_6aa.begin(), class2s_6aa.end());
	if( ( !class1s_6a8.empty())&& ( !class2s_6aa.empty()))
		callTransferSubsystem_6d1( class1s_6a8, class2s_6aa);
}

void TransferSubsystems_6a7::callTransferSubsystem_6d1( const Packets_t& class1s_6b1, const Packets_t& class2s_6b3)
{
	TransferSubsystem_6b0 transferSubsystem_6b0;
	transferSubsystem_6b0( class1s_6b1, class2s_6b3);
}

void TransferSubsystem_6b0::operator()( const Packets_t& class1s_6b1, const Packets_t& class2s_6b3)
{
#ifdef PRINT_INFO
	printLog( "TransferSubsystem_6b0" );
#endif
	RTTGenerator::Instance()->generateRule(305, "TransferSubsystem");
	processInputPackets( class1s_6b1, class2s_6b3);
}

bool TransferSubsystem_6b0::isInputUnique( const Udm::Object& class1_6b9, const Udm::Object& class2_6c2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass1_6bb= _class1_6b5.begin(), itClass2_6c4= _class2_6be.begin(); itClass1_6bb!= _class1_6b5.end(), itClass2_6c4!= _class2_6be.end(); ++itClass1_6bb, ++itClass2_6c4)
	{
		if( ( *itClass1_6bb== class1_6b9)&& ( *itClass2_6c4== class2_6c2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_class1_6b5.push_back( class1_6b9);
		_class2_6be.push_back( class2_6c2);
	}
	return isUnique;
}

bool TransferSubsystem_6b0::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void TransferSubsystem_6b0::processInputPackets( const Packets_t& class1s_6b1, const Packets_t& class2s_6b3)
{
	for( Packets_t::const_iterator itClass1_6b6= class1s_6b1.begin(), itClass2_6bf= class2s_6b3.begin(); itClass1_6b6!= class1s_6b1.end(), itClass2_6bf!= class2s_6b3.end(); ++itClass1_6b6, ++itClass2_6bf)
	{
		bool isUnique= isInputUnique( *itClass1_6b6, *itClass2_6bf);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass1_6b6, *itClass2_6bf);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool TransferSubsystem_6b0::patternMatcher( const Udm::Object& class1_6b7, const Udm::Object& class2_6c0)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class1_6b7.type(), SFC::Class::meta))
			continue;
		SFC::Class class1_6bc= SFC::Class::Cast( class1_6b7);
		if( false== Uml::IsDerivedFrom( class2_6c0.type(), SFC::Class::meta))
			continue;
		SFC::Class class2_6c5= SFC::Class::Cast( class2_6c0);
		set< CyberComposition::Simulink::Subsystem> subsystems_6c7= class2_6c5.obj();
		for( set< CyberComposition::Simulink::Subsystem>::const_iterator itSubsystems_6c8= subsystems_6c7.begin(); itSubsystems_6c8!= subsystems_6c7.end(); ++itSubsystems_6c8)
		{
			CyberComposition::Simulink::Subsystem currSubsystem_6c9= *itSubsystems_6c8;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_6cd;
			if( !isValidBound(boundObjs_6cd, class1_6bc, true))
				continue;
			currMatch.class1_6ce= class1_6bc;
			if( !isValidBound(boundObjs_6cd, class2_6c5, true))
				continue;
			currMatch.class2_6cf= class2_6c5;
			if( !isValidBound(boundObjs_6cd, currSubsystem_6c9, false))
				continue;
			currMatch.subsystem_6d0= currSubsystem_6c9;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void TransferSubsystem_6b0::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		currMatch.subsystem_6d0.cls()= currMatch.class1_6ce;
	}
}

void TransferStruct_6d4::operator()( const Packets_t& class1s_6d5, const Packets_t& class2s_6d7, Packets_t& deleteclasss_6d9)
{
#ifdef PRINT_INFO
	printLog( "TransferStruct_6d4" );
#endif
	_deleteclass_6da= &deleteclasss_6d9;
	if( ( !class1s_6d5.empty())&& ( !class2s_6d7.empty()))
		callTransferStructMembers_837( class1s_6d5, class2s_6d7);
	_deleteclass_6da->insert( _deleteclass_6da->end(), class2s_6d7.begin(), class2s_6d7.end());
}

void TransferStruct_6d4::callTransferStructMembers_837( const Packets_t& class1s_705, const Packets_t& class2s_707)
{
	Packets_t class1s_709;
	Packets_t class2s_70a;
	TransferStructMembers_704 transferStructMembers_704;
	transferStructMembers_704( class1s_705, class2s_707, class1s_709, class2s_70a);
	if( ( !class1s_709.empty())&& ( !class2s_70a.empty()))
		callTransferStruct_83a( class1s_709, class2s_70a);
}

void TransferStruct_6d4::callTransferStruct_83a( const Packets_t& class1s_6dc, const Packets_t& class2s_6de)
{
	TransferStruct_6db transferStruct_6db;
	transferStruct_6db( class1s_6dc, class2s_6de);
}

void TransferStruct_6db::operator()( const Packets_t& class1s_6dc, const Packets_t& class2s_6de)
{
#ifdef PRINT_INFO
	printLog( "TransferStruct_6db" );
#endif
	RTTGenerator::Instance()->generateRule(315, "TransferStruct");
	processInputPackets( class1s_6dc, class2s_6de);
}

bool TransferStruct_6db::isInputUnique( const Udm::Object& class1_6e4, const Udm::Object& class2_6ed)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass1_6e6= _class1_6e0.begin(), itClass2_6ef= _class2_6e9.begin(); itClass1_6e6!= _class1_6e0.end(), itClass2_6ef!= _class2_6e9.end(); ++itClass1_6e6, ++itClass2_6ef)
	{
		if( ( *itClass1_6e6== class1_6e4)&& ( *itClass2_6ef== class2_6ed))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_class1_6e0.push_back( class1_6e4);
		_class2_6e9.push_back( class2_6ed);
	}
	return isUnique;
}

bool TransferStruct_6db::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void TransferStruct_6db::processInputPackets( const Packets_t& class1s_6dc, const Packets_t& class2s_6de)
{
	for( Packets_t::const_iterator itClass1_6e1= class1s_6dc.begin(), itClass2_6ea= class2s_6de.begin(); itClass1_6e1!= class1s_6dc.end(), itClass2_6ea!= class2s_6de.end(); ++itClass1_6e1, ++itClass2_6ea)
	{
		bool isUnique= isInputUnique( *itClass1_6e1, *itClass2_6ea);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass1_6e1, *itClass2_6ea);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool TransferStruct_6db::patternMatcher( const Udm::Object& class1_6e2, const Udm::Object& class2_6eb)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class1_6e2.type(), SFC::Class::meta))
			continue;
		SFC::Class class1_6e7= SFC::Class::Cast( class1_6e2);
		if( false== Uml::IsDerivedFrom( class2_6eb.type(), SFC::Class::meta))
			continue;
		SFC::Class class2_6f0= SFC::Class::Cast( class2_6eb);
		set< SFC::Struct> struct1s_6f2= class1_6e7.Struct_kind_children();
		for( set< SFC::Struct>::const_iterator itStruct1_6f3= struct1s_6f2.begin(); itStruct1_6f3!= struct1s_6f2.end(); ++itStruct1_6f3)
		{
			SFC::Struct currStruct1_6f4= *itStruct1_6f3;
			set< SFC::Struct> struct2s_6f5= class2_6f0.Struct_kind_children();
			for( set< SFC::Struct>::const_iterator itStruct2_6f6= struct2s_6f5.begin(); itStruct2_6f6!= struct2s_6f5.end(); ++itStruct2_6f6)
			{
				SFC::Struct currStruct2_6f7= *itStruct2_6f6;
				set< SFC::TypedEntity> argDeclBases_6f8= currStruct2_6f7.te();
				for( set< SFC::TypedEntity>::const_iterator itArgDeclBases_6f9= argDeclBases_6f8.begin(); itArgDeclBases_6f9!= argDeclBases_6f8.end(); ++itArgDeclBases_6f9)
				{
					if( false== Uml::IsDerivedFrom( (*itArgDeclBases_6f9).type(), SFC::ArgDeclBase::meta))
						continue;
					SFC::ArgDeclBase currArgDeclBase_6fa= SFC::ArgDeclBase::Cast( *itArgDeclBases_6f9);
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_6fe;
					if( !isValidBound(boundObjs_6fe, class1_6e7, true))
						continue;
					currMatch.class1_6ff= class1_6e7;
					if( !isValidBound(boundObjs_6fe, class2_6f0, true))
						continue;
					currMatch.class2_700= class2_6f0;
					if( !isValidBound(boundObjs_6fe, currStruct1_6f4, false))
						continue;
					currMatch.struct1_701= currStruct1_6f4;
					if( !isValidBound(boundObjs_6fe, currArgDeclBase_6fa, false))
						continue;
					currMatch.argDeclBase_702= currArgDeclBase_6fa;
					if( !isValidBound(boundObjs_6fe, currStruct2_6f7, false))
						continue;
					currMatch.struct2_703= currStruct2_6f7;
					_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void TransferStruct_6db::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		currMatch.argDeclBase_702.dt()= currMatch.struct1_701;
	}
}

void TransferStructMembers_704::operator()( const Packets_t& class1s_705, const Packets_t& class2s_707, Packets_t& class1s_709, Packets_t& class2s_70a)
{
#ifdef PRINT_INFO
	printLog( "TransferStructMembers_704" );
#endif
	_class1_70b= &class1s_709;
	_class2_70c= &class2s_70a;
	_class1_70b->insert( _class1_70b->end(), class1s_705.begin(), class1s_705.end());
	_class2_70c->insert( _class2_70c->end(), class2s_707.begin(), class2s_707.end());
	if( ( !class1s_705.empty())&& ( !class2s_707.empty()))
		callTransferParameterMembers_82e( class1s_705, class2s_707);
}

void TransferStructMembers_704::callTransferParameterMembers_82e( const Packets_t& class1s_7db, const Packets_t& class2s_7dd)
{
	Packets_t class1s_7df;
	Packets_t class2s_7e0;
	TransferParameterMembers_7da transferParameterMembers_7da;
	transferParameterMembers_7da( class1s_7db, class2s_7dd, class1s_7df, class2s_7e0);
	if( ( !class1s_7df.empty())&& ( !class2s_7e0.empty()))
		callTransferTriggerMembers_831( class1s_7df, class2s_7e0);
}

void TransferStructMembers_704::callTransferTriggerMembers_831( const Packets_t& class1s_70e, const Packets_t& class2s_710)
{
	Packets_t class1s_712;
	Packets_t class2s_713;
	TransferTriggerMembers_70d transferTriggerMembers_70d;
	transferTriggerMembers_70d( class1s_70e, class2s_710, class1s_712, class2s_713);
	if( ( !class1s_712.empty())&& ( !class2s_713.empty()))
		callTransferStructMembers_834( class1s_712, class2s_713);
}

void TransferStructMembers_704::callTransferStructMembers_834( const Packets_t& class1s_783, const Packets_t& class2s_785)
{
	Packets_t class1s_787;
	Packets_t class2s_788;
	TransferStructMembers_782 transferStructMembers_782;
	transferStructMembers_782( class1s_783, class2s_785, class1s_787, class2s_788);
}

void TransferTriggerMembers_70d::operator()( const Packets_t& class1s_70e, const Packets_t& class2s_710, Packets_t& class1s_712, Packets_t& class2s_713)
{
#ifdef PRINT_INFO
	printLog( "TransferTriggerMembers_70d" );
#endif
	_class1_714= &class1s_712;
	_class2_715= &class2s_713;
	if( ( !class1s_70e.empty())&& ( !class2s_710.empty()))
		callTransferTriggerMember_77c( class1s_70e, class2s_710);
	_class1_714->insert( _class1_714->end(), class1s_70e.begin(), class1s_70e.end());
	_class2_715->insert( _class2_715->end(), class2s_710.begin(), class2s_710.end());
}

void TransferTriggerMembers_70d::callTransferTriggerMember_77c( const Packets_t& class1s_717, const Packets_t& class2s_71a)
{
	Packets_t localVar1s_719;
	Packets_t localVar2s_71c;
	TransferTriggerMember_716 transferTriggerMember_716;
	transferTriggerMember_716( class1s_717, class2s_71a, localVar1s_719, localVar2s_71c);
	if( ( !localVar1s_719.empty())&& ( !localVar2s_71c.empty()))
		callTransferArgDeclRef_77f( localVar1s_719, localVar2s_71c);
}

void TransferTriggerMembers_70d::callTransferArgDeclRef_77f( const Packets_t& localVar1s_75c, const Packets_t& localVar2s_75e)
{
	TransferArgDeclRef_75b transferArgDeclRef_75b;
	transferArgDeclRef_75b( localVar1s_75c, localVar2s_75e);
}

void TransferTriggerMember_716::operator()( const Packets_t& class1s_717, const Packets_t& class2s_71a, Packets_t& localVar1s_719, Packets_t& localVar2s_71c)
{
#ifdef PRINT_INFO
	printLog( "TransferTriggerMember_716" );
#endif
	RTTGenerator::Instance()->generateRule(335, "TransferTriggerMember");
	_localVar1_71d= &localVar1s_719;
	_localVar2_71e= &localVar2s_71c;
	processInputPackets( class1s_717, class2s_71a);
}

bool TransferTriggerMember_716::isInputUnique( const Udm::Object& class1_723, const Udm::Object& class2_72c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass1_725= _class1_71f.begin(), itClass2_72e= _class2_728.begin(); itClass1_725!= _class1_71f.end(), itClass2_72e!= _class2_728.end(); ++itClass1_725, ++itClass2_72e)
	{
		if( ( *itClass1_725== class1_723)&& ( *itClass2_72e== class2_72c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_class1_71f.push_back( class1_723);
		_class2_728.push_back( class2_72c);
	}
	return isUnique;
}

bool TransferTriggerMember_716::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool TransferTriggerMember_716::isGuardTrue( SFC::Class& Class1, SFC::Class& Class2, SFC::LocalVar& LocalVar1, SFC::LocalVar& LocalVar2, SFC::Struct& Struct1, SFC::Struct& Struct2, CyberComposition::Simulink::TriggerPort& TriggerPort1, CyberComposition::Simulink::TriggerPort& TriggerPort2)
{
	bool Gz_guard= false;
	Gz_guard = SFUtils::InstanceEquivalent( TriggerPort1, TriggerPort2 );;
	return Gz_guard;
}

void TransferTriggerMember_716::processInputPackets( const Packets_t& class1s_717, const Packets_t& class2s_71a)
{
	for( Packets_t::const_iterator itClass1_720= class1s_717.begin(), itClass2_729= class2s_71a.begin(); itClass1_720!= class1s_717.end(), itClass2_729!= class2s_71a.end(); ++itClass1_720, ++itClass2_729)
	{
		bool isUnique= isInputUnique( *itClass1_720, *itClass2_729);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass1_720, *itClass2_729);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool TransferTriggerMember_716::patternMatcher( const Udm::Object& class1_721, const Udm::Object& class2_72a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class1_721.type(), SFC::Class::meta))
			continue;
		SFC::Class class1_726= SFC::Class::Cast( class1_721);
		if( false== Uml::IsDerivedFrom( class2_72a.type(), SFC::Class::meta))
			continue;
		SFC::Class class2_72f= SFC::Class::Cast( class2_72a);
		set< SFC::Struct> struct1s_731= class1_726.Struct_kind_children();
		for( set< SFC::Struct>::const_iterator itStruct1_732= struct1s_731.begin(); itStruct1_732!= struct1s_731.end(); ++itStruct1_732)
		{
			SFC::Struct currStruct1_733= *itStruct1_732;
			set< SFC::Struct> struct2s_734= class2_72f.Struct_kind_children();
			for( set< SFC::Struct>::const_iterator itStruct2_735= struct2s_734.begin(); itStruct2_735!= struct2s_734.end(); ++itStruct2_735)
			{
				SFC::Struct currStruct2_736= *itStruct2_735;
				set< SFC::LocalVar> localVar1s_737= currStruct1_733.LocalVar_kind_children();
				for( set< SFC::LocalVar>::const_iterator itLocalVar1_738= localVar1s_737.begin(); itLocalVar1_738!= localVar1s_737.end(); ++itLocalVar1_738)
				{
					SFC::LocalVar currLocalVar1_739= *itLocalVar1_738;
					set< SFC::LocalVar> localVar2s_73a= currStruct2_736.LocalVar_kind_children();
					for( set< SFC::LocalVar>::const_iterator itLocalVar2_73b= localVar2s_73a.begin(); itLocalVar2_73b!= localVar2s_73a.end(); ++itLocalVar2_73b)
					{
						SFC::LocalVar currLocalVar2_73c= *itLocalVar2_73b;
						set< CyberComposition::Simulink::TriggerPort> triggerPort2s_73d= currLocalVar1_739.trig();
						for( set< CyberComposition::Simulink::TriggerPort>::const_iterator itTriggerPort2s_73e= triggerPort2s_73d.begin(); itTriggerPort2s_73e!= triggerPort2s_73d.end(); ++itTriggerPort2s_73e)
						{
							CyberComposition::Simulink::TriggerPort currTriggerPort2_73f= *itTriggerPort2s_73e;
							set< CyberComposition::Simulink::TriggerPort> triggerPort1s_740= currLocalVar2_73c.trig();
							for( set< CyberComposition::Simulink::TriggerPort>::const_iterator itTriggerPort1s_741= triggerPort1s_740.begin(); itTriggerPort1s_741!= triggerPort1s_740.end(); ++itTriggerPort1s_741)
							{
								CyberComposition::Simulink::TriggerPort currTriggerPort1_742= *itTriggerPort1s_741;
								Match currMatch;
								set< pair<int, Udm::Object> > boundObjs_746;
								if( !isValidBound(boundObjs_746, class1_726, true))
									continue;
								currMatch.class1_747= class1_726;
								if( !isValidBound(boundObjs_746, class2_72f, true))
									continue;
								currMatch.class2_748= class2_72f;
								if( !isValidBound(boundObjs_746, currStruct1_733, false))
									continue;
								currMatch.struct1_749= currStruct1_733;
								if( !isValidBound(boundObjs_746, currLocalVar1_739, false))
									continue;
								currMatch.localVar1_74a= currLocalVar1_739;
								if( !isValidBound(boundObjs_746, currTriggerPort2_73f, false))
									continue;
								currMatch.triggerPort2_74b= currTriggerPort2_73f;
								if( !isValidBound(boundObjs_746, currTriggerPort1_742, false))
									continue;
								currMatch.triggerPort1_74c= currTriggerPort1_742;
								if( !isValidBound(boundObjs_746, currStruct2_736, false))
									continue;
								currMatch.struct2_74d= currStruct2_736;
								if( !isValidBound(boundObjs_746, currLocalVar2_73c, false))
									continue;
								currMatch.localVar2_74e= currLocalVar2_73c;
								bool Gz_guard= isGuardTrue( currMatch.class1_747, currMatch.class2_748, currMatch.localVar1_74a, currMatch.localVar2_74e, currMatch.struct1_749, currMatch.struct2_74d, currMatch.triggerPort1_74c, currMatch.triggerPort2_74b);
								if( true== Gz_guard)
									_matches.push_back( currMatch);
							}
						}
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void TransferTriggerMember_716::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Class& Class1= currMatch.class1_747;
		SFC::Class& Class2= currMatch.class2_748;
		SFC::LocalVar& LocalVar1= currMatch.localVar1_74a;
		SFC::LocalVar& LocalVar2= currMatch.localVar2_74e;
		SFC::Struct& Struct1= currMatch.struct1_749;
		SFC::Struct& Struct2= currMatch.struct2_74d;
		CyberComposition::Simulink::TriggerPort& TriggerPort1= currMatch.triggerPort1_74c;
		CyberComposition::Simulink::TriggerPort& TriggerPort2= currMatch.triggerPort2_74b;
		{
TriggerPort1.memb() = LocalVar1;
};
		currMatch.localVar1_74a.trig()+= currMatch.triggerPort1_74c;
		outputAppender( currMatch.localVar1_74a, currMatch.localVar2_74e);
	}
}

void TransferTriggerMember_716::outputAppender( const SFC::LocalVar& localVar1_757, const SFC::LocalVar& localVar2_759)
{
	_localVar1_71d->push_back( localVar1_757);
	_localVar2_71e->push_back( localVar2_759);
}

void TransferArgDeclRef_75b::operator()( const Packets_t& localVar1s_75c, const Packets_t& localVar2s_75e)
{
#ifdef PRINT_INFO
	printLog( "TransferArgDeclRef_75b" );
#endif
	RTTGenerator::Instance()->generateRule(399, "TransferArgDeclRef");
	processInputPackets( localVar1s_75c, localVar2s_75e);
}

bool TransferArgDeclRef_75b::isInputUnique( const Udm::Object& localVar1_764, const Udm::Object& localVar2_76d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itLocalVar1_766= _localVar1_760.begin(), itLocalVar2_76f= _localVar2_769.begin(); itLocalVar1_766!= _localVar1_760.end(), itLocalVar2_76f!= _localVar2_769.end(); ++itLocalVar1_766, ++itLocalVar2_76f)
	{
		if( ( *itLocalVar1_766== localVar1_764)&& ( *itLocalVar2_76f== localVar2_76d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_localVar1_760.push_back( localVar1_764);
		_localVar2_769.push_back( localVar2_76d);
	}
	return isUnique;
}

bool TransferArgDeclRef_75b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void TransferArgDeclRef_75b::processInputPackets( const Packets_t& localVar1s_75c, const Packets_t& localVar2s_75e)
{
	for( Packets_t::const_iterator itLocalVar1_761= localVar1s_75c.begin(), itLocalVar2_76a= localVar2s_75e.begin(); itLocalVar1_761!= localVar1s_75c.end(), itLocalVar2_76a!= localVar2s_75e.end(); ++itLocalVar1_761, ++itLocalVar2_76a)
	{
		bool isUnique= isInputUnique( *itLocalVar1_761, *itLocalVar2_76a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itLocalVar1_761, *itLocalVar2_76a);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool TransferArgDeclRef_75b::patternMatcher( const Udm::Object& localVar1_762, const Udm::Object& localVar2_76b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( localVar1_762.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar1_767= SFC::LocalVar::Cast( localVar1_762);
		if( false== Uml::IsDerivedFrom( localVar2_76b.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar2_770= SFC::LocalVar::Cast( localVar2_76b);
		set< SFC::ArgDeclRef> argDeclRefs_772= localVar2_770.ref();
		for( set< SFC::ArgDeclRef>::const_iterator itArgDeclRefs_773= argDeclRefs_772.begin(); itArgDeclRefs_773!= argDeclRefs_772.end(); ++itArgDeclRefs_773)
		{
			SFC::ArgDeclRef currArgDeclRef_774= *itArgDeclRefs_773;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_778;
			if( !isValidBound(boundObjs_778, localVar1_767, true))
				continue;
			currMatch.localVar1_779= localVar1_767;
			if( !isValidBound(boundObjs_778, localVar2_770, true))
				continue;
			currMatch.localVar2_77a= localVar2_770;
			if( !isValidBound(boundObjs_778, currArgDeclRef_774, false))
				continue;
			currMatch.argDeclRef_77b= currArgDeclRef_774;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void TransferArgDeclRef_75b::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		currMatch.argDeclRef_77b.argdecl()= currMatch.localVar1_779;
	}
}

void TransferStructMembers_782::operator()( const Packets_t& class1s_783, const Packets_t& class2s_785, Packets_t& class1s_787, Packets_t& class2s_788)
{
#ifdef PRINT_INFO
	printLog( "TransferStructMembers_782" );
#endif
	_class1_789= &class1s_787;
	_class2_78a= &class2s_788;
	if( ( !class1s_783.empty())&& ( !class2s_785.empty()))
		callTransferStructMember_7d4( class1s_783, class2s_785);
	_class1_789->insert( _class1_789->end(), class1s_783.begin(), class1s_783.end());
	_class2_78a->insert( _class2_78a->end(), class2s_785.begin(), class2s_785.end());
}

void TransferStructMembers_782::callTransferStructMember_7d4( const Packets_t& class1s_78c, const Packets_t& class2s_78f)
{
	Packets_t localVar1s_78e;
	Packets_t localVar2s_791;
	TransferStructMember_78b transferStructMember_78b;
	transferStructMember_78b( class1s_78c, class2s_78f, localVar1s_78e, localVar2s_791);
	if( ( !localVar1s_78e.empty())&& ( !localVar2s_791.empty()))
		callTransferArgDeclRef_7d7( localVar1s_78e, localVar2s_791);
}

void TransferStructMembers_782::callTransferArgDeclRef_7d7( const Packets_t& localVar1s_75c, const Packets_t& localVar2s_75e)
{
	TransferArgDeclRef_75b transferArgDeclRef_75b;
	transferArgDeclRef_75b( localVar1s_75c, localVar2s_75e);
}

void TransferStructMember_78b::operator()( const Packets_t& class1s_78c, const Packets_t& class2s_78f, Packets_t& localVar1s_78e, Packets_t& localVar2s_791)
{
#ifdef PRINT_INFO
	printLog( "TransferStructMember_78b" );
#endif
	RTTGenerator::Instance()->generateRule(357, "TransferStructMember");
	_localVar1_792= &localVar1s_78e;
	_localVar2_793= &localVar2s_791;
	processInputPackets( class1s_78c, class2s_78f);
}

bool TransferStructMember_78b::isInputUnique( const Udm::Object& class1_798, const Udm::Object& class2_7a1)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass1_79a= _class1_794.begin(), itClass2_7a3= _class2_79d.begin(); itClass1_79a!= _class1_794.end(), itClass2_7a3!= _class2_79d.end(); ++itClass1_79a, ++itClass2_7a3)
	{
		if( ( *itClass1_79a== class1_798)&& ( *itClass2_7a3== class2_7a1))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_class1_794.push_back( class1_798);
		_class2_79d.push_back( class2_7a1);
	}
	return isUnique;
}

bool TransferStructMember_78b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool TransferStructMember_78b::isGuardTrue( SFC::Class& Class, SFC::Class& Class1, SFC::Class& Class2, SFC::LocalVar& LocalVar1, SFC::LocalVar& LocalVar2, SFC::Struct& Struct1, SFC::Struct& Struct2, CyberComposition::Simulink::Subsystem& SubSubsystem1, CyberComposition::Simulink::Subsystem& SubSubsystem2)
{
	bool Gz_guard= false;
	return SFUtils::InstanceCorrespond( SubSubsystem1, SubSubsystem2 );;
	return Gz_guard;
}

void TransferStructMember_78b::processInputPackets( const Packets_t& class1s_78c, const Packets_t& class2s_78f)
{
	for( Packets_t::const_iterator itClass1_795= class1s_78c.begin(), itClass2_79e= class2s_78f.begin(); itClass1_795!= class1s_78c.end(), itClass2_79e!= class2s_78f.end(); ++itClass1_795, ++itClass2_79e)
	{
		bool isUnique= isInputUnique( *itClass1_795, *itClass2_79e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass1_795, *itClass2_79e);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool TransferStructMember_78b::patternMatcher( const Udm::Object& class1_796, const Udm::Object& class2_79f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class1_796.type(), SFC::Class::meta))
			continue;
		SFC::Class class1_79b= SFC::Class::Cast( class1_796);
		if( false== Uml::IsDerivedFrom( class2_79f.type(), SFC::Class::meta))
			continue;
		SFC::Class class2_7a4= SFC::Class::Cast( class2_79f);
		set< SFC::Struct> struct1s_7a6= class1_79b.Struct_kind_children();
		for( set< SFC::Struct>::const_iterator itStruct1_7a7= struct1s_7a6.begin(); itStruct1_7a7!= struct1s_7a6.end(); ++itStruct1_7a7)
		{
			SFC::Struct currStruct1_7a8= *itStruct1_7a7;
			set< SFC::LocalVar> localVar1s_7a9= currStruct1_7a8.LocalVar_kind_children();
			for( set< SFC::LocalVar>::const_iterator itLocalVar1_7aa= localVar1s_7a9.begin(); itLocalVar1_7aa!= localVar1s_7a9.end(); ++itLocalVar1_7aa)
			{
				SFC::LocalVar currLocalVar1_7ab= *itLocalVar1_7aa;
				set< SFC::Struct> struct2s_7ac= class2_7a4.Struct_kind_children();
				for( set< SFC::Struct>::const_iterator itStruct2_7ad= struct2s_7ac.begin(); itStruct2_7ad!= struct2s_7ac.end(); ++itStruct2_7ad)
				{
					SFC::Struct currStruct2_7ae= *itStruct2_7ad;
					set< SFC::LocalVar> localVar2s_7af= currStruct2_7ae.LocalVar_kind_children();
					for( set< SFC::LocalVar>::const_iterator itLocalVar2_7b0= localVar2s_7af.begin(); itLocalVar2_7b0!= localVar2s_7af.end(); ++itLocalVar2_7b0)
					{
						SFC::LocalVar currLocalVar2_7b1= *itLocalVar2_7b0;
						set< CyberComposition::Simulink::Subsystem> subSubsystem1s_7b2= currLocalVar1_7ab.sys();
						for( set< CyberComposition::Simulink::Subsystem>::const_iterator itSubSubsystem1s_7b3= subSubsystem1s_7b2.begin(); itSubSubsystem1s_7b3!= subSubsystem1s_7b2.end(); ++itSubSubsystem1s_7b3)
						{
							CyberComposition::Simulink::Subsystem currSubSubsystem1_7b4= *itSubSubsystem1s_7b3;
							set< CyberComposition::Simulink::Subsystem> subSubsystem2s_7b5= currLocalVar2_7b1.sys();
							for( set< CyberComposition::Simulink::Subsystem>::const_iterator itSubSubsystem2s_7b6= subSubsystem2s_7b5.begin(); itSubSubsystem2s_7b6!= subSubsystem2s_7b5.end(); ++itSubSubsystem2s_7b6)
							{
								CyberComposition::Simulink::Subsystem currSubSubsystem2_7b7= *itSubSubsystem2s_7b6;
								SFC::Class class_7b8= currSubSubsystem2_7b7.cls();
								if( !class_7b8)
									continue;
								SFC::Class class_7b9= currSubSubsystem1_7b4.cls();
								if( !class_7b9)
									continue;
								if( class_7b8!= class_7b9)
									continue;
								Match currMatch;
								set< pair<int, Udm::Object> > boundObjs_7bd;
								if( !isValidBound(boundObjs_7bd, class1_79b, true))
									continue;
								currMatch.class1_7be= class1_79b;
								if( !isValidBound(boundObjs_7bd, class2_7a4, true))
									continue;
								currMatch.class2_7bf= class2_7a4;
								if( !isValidBound(boundObjs_7bd, currStruct1_7a8, false))
									continue;
								currMatch.struct1_7c0= currStruct1_7a8;
								if( !isValidBound(boundObjs_7bd, currLocalVar1_7ab, false))
									continue;
								currMatch.localVar1_7c1= currLocalVar1_7ab;
								if( !isValidBound(boundObjs_7bd, currSubSubsystem1_7b4, false))
									continue;
								currMatch.subSubsystem1_7c2= currSubSubsystem1_7b4;
								if( !isValidBound(boundObjs_7bd, class_7b8, false))
									continue;
								currMatch.class_7c3= class_7b8;
								if( !isValidBound(boundObjs_7bd, currSubSubsystem2_7b7, false))
									continue;
								currMatch.subSubsystem2_7c4= currSubSubsystem2_7b7;
								if( !isValidBound(boundObjs_7bd, currStruct2_7ae, false))
									continue;
								currMatch.struct2_7c5= currStruct2_7ae;
								if( !isValidBound(boundObjs_7bd, currLocalVar2_7b1, false))
									continue;
								currMatch.localVar2_7c6= currLocalVar2_7b1;
								bool Gz_guard= isGuardTrue( currMatch.class_7c3, currMatch.class1_7be, currMatch.class2_7bf, currMatch.localVar1_7c1, currMatch.localVar2_7c6, currMatch.struct1_7c0, currMatch.struct2_7c5, currMatch.subSubsystem1_7c2, currMatch.subSubsystem2_7c4);
								if( true== Gz_guard)
									_matches.push_back( currMatch);
							}
						}
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void TransferStructMember_78b::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Class& Class= currMatch.class_7c3;
		SFC::Class& Class1= currMatch.class1_7be;
		SFC::Class& Class2= currMatch.class2_7bf;
		SFC::LocalVar& LocalVar1= currMatch.localVar1_7c1;
		SFC::LocalVar& LocalVar2= currMatch.localVar2_7c6;
		SFC::Struct& Struct1= currMatch.struct1_7c0;
		SFC::Struct& Struct2= currMatch.struct2_7c5;
		CyberComposition::Simulink::Subsystem& SubSubsystem1= currMatch.subSubsystem1_7c2;
		CyberComposition::Simulink::Subsystem& SubSubsystem2= currMatch.subSubsystem2_7c4;
		{
SubSubsystem2.memb() = LocalVar1;
};
		currMatch.localVar1_7c1.sys()+= currMatch.subSubsystem2_7c4;
		outputAppender( currMatch.localVar1_7c1, currMatch.localVar2_7c6);
	}
}

void TransferStructMember_78b::outputAppender( const SFC::LocalVar& localVar1_7d0, const SFC::LocalVar& localVar2_7d2)
{
	_localVar1_792->push_back( localVar1_7d0);
	_localVar2_793->push_back( localVar2_7d2);
}

void TransferParameterMembers_7da::operator()( const Packets_t& class1s_7db, const Packets_t& class2s_7dd, Packets_t& class1s_7df, Packets_t& class2s_7e0)
{
#ifdef PRINT_INFO
	printLog( "TransferParameterMembers_7da" );
#endif
	_class1_7e1= &class1s_7df;
	_class2_7e2= &class2s_7e0;
	_class1_7e1->insert( _class1_7e1->end(), class1s_7db.begin(), class1s_7db.end());
	_class2_7e2->insert( _class2_7e2->end(), class2s_7dd.begin(), class2s_7dd.end());
	if( ( !class1s_7db.empty())&& ( !class2s_7dd.empty()))
		callTransferParameterMember_828( class1s_7db, class2s_7dd);
}

void TransferParameterMembers_7da::callTransferParameterMember_828( const Packets_t& class1s_7e4, const Packets_t& class2s_7e7)
{
	Packets_t localVar1s_7e6;
	Packets_t localVar2s_7e9;
	TransferParameterMember_7e3 transferParameterMember_7e3;
	transferParameterMember_7e3( class1s_7e4, class2s_7e7, localVar1s_7e6, localVar2s_7e9);
	if( ( !localVar1s_7e6.empty())&& ( !localVar2s_7e9.empty()))
		callTransferArgDeclRef_82b( localVar1s_7e6, localVar2s_7e9);
}

void TransferParameterMembers_7da::callTransferArgDeclRef_82b( const Packets_t& localVar1s_75c, const Packets_t& localVar2s_75e)
{
	TransferArgDeclRef_75b transferArgDeclRef_75b;
	transferArgDeclRef_75b( localVar1s_75c, localVar2s_75e);
}

void TransferParameterMember_7e3::operator()( const Packets_t& class1s_7e4, const Packets_t& class2s_7e7, Packets_t& localVar1s_7e6, Packets_t& localVar2s_7e9)
{
#ifdef PRINT_INFO
	printLog( "TransferParameterMember_7e3" );
#endif
	RTTGenerator::Instance()->generateRule(382, "TransferParameterMember");
	_localVar1_7ea= &localVar1s_7e6;
	_localVar2_7eb= &localVar2s_7e9;
	processInputPackets( class1s_7e4, class2s_7e7);
}

bool TransferParameterMember_7e3::isInputUnique( const Udm::Object& class1_7f0, const Udm::Object& class2_7f9)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass1_7f2= _class1_7ec.begin(), itClass2_7fb= _class2_7f5.begin(); itClass1_7f2!= _class1_7ec.end(), itClass2_7fb!= _class2_7f5.end(); ++itClass1_7f2, ++itClass2_7fb)
	{
		if( ( *itClass1_7f2== class1_7f0)&& ( *itClass2_7fb== class2_7f9))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_class1_7ec.push_back( class1_7f0);
		_class2_7f5.push_back( class2_7f9);
	}
	return isUnique;
}

bool TransferParameterMember_7e3::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool TransferParameterMember_7e3::isGuardTrue( SFC::Class& Class1, SFC::Class& Class2, SFC::LocalVar& LocalVar1, SFC::LocalVar& LocalVar2, CyberComposition::Simulink::SF_Parameter& Parameter1, CyberComposition::Simulink::SF_Parameter& Parameter2, SFC::Struct& Struct1, SFC::Struct& Struct2)
{
	bool Gz_guard= false;
	Gz_guard = SFUtils::InstanceEquivalent( Parameter1, Parameter2 );;
	return Gz_guard;
}

void TransferParameterMember_7e3::processInputPackets( const Packets_t& class1s_7e4, const Packets_t& class2s_7e7)
{
	for( Packets_t::const_iterator itClass1_7ed= class1s_7e4.begin(), itClass2_7f6= class2s_7e7.begin(); itClass1_7ed!= class1s_7e4.end(), itClass2_7f6!= class2s_7e7.end(); ++itClass1_7ed, ++itClass2_7f6)
	{
		bool isUnique= isInputUnique( *itClass1_7ed, *itClass2_7f6);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass1_7ed, *itClass2_7f6);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool TransferParameterMember_7e3::patternMatcher( const Udm::Object& class1_7ee, const Udm::Object& class2_7f7)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class1_7ee.type(), SFC::Class::meta))
			continue;
		SFC::Class class1_7f3= SFC::Class::Cast( class1_7ee);
		if( false== Uml::IsDerivedFrom( class2_7f7.type(), SFC::Class::meta))
			continue;
		SFC::Class class2_7fc= SFC::Class::Cast( class2_7f7);
		set< SFC::Struct> struct2s_7fe= class2_7fc.Struct_kind_children();
		for( set< SFC::Struct>::const_iterator itStruct2_7ff= struct2s_7fe.begin(); itStruct2_7ff!= struct2s_7fe.end(); ++itStruct2_7ff)
		{
			SFC::Struct currStruct2_800= *itStruct2_7ff;
			set< SFC::LocalVar> localVar2s_801= currStruct2_800.LocalVar_kind_children();
			for( set< SFC::LocalVar>::const_iterator itLocalVar2_802= localVar2s_801.begin(); itLocalVar2_802!= localVar2s_801.end(); ++itLocalVar2_802)
			{
				SFC::LocalVar currLocalVar2_803= *itLocalVar2_802;
				set< SFC::Struct> struct1s_804= class1_7f3.Struct_kind_children();
				for( set< SFC::Struct>::const_iterator itStruct1_805= struct1s_804.begin(); itStruct1_805!= struct1s_804.end(); ++itStruct1_805)
				{
					SFC::Struct currStruct1_806= *itStruct1_805;
					set< SFC::LocalVar> localVar1s_807= currStruct1_806.LocalVar_kind_children();
					for( set< SFC::LocalVar>::const_iterator itLocalVar1_808= localVar1s_807.begin(); itLocalVar1_808!= localVar1s_807.end(); ++itLocalVar1_808)
					{
						SFC::LocalVar currLocalVar1_809= *itLocalVar1_808;
						set< CyberComposition::Simulink::SF_Parameter> parameter2s_80a= currLocalVar2_803.param();
						for( set< CyberComposition::Simulink::SF_Parameter>::const_iterator itParameter2s_80b= parameter2s_80a.begin(); itParameter2s_80b!= parameter2s_80a.end(); ++itParameter2s_80b)
						{
							CyberComposition::Simulink::SF_Parameter currParameter2_80c= *itParameter2s_80b;
							set< CyberComposition::Simulink::SF_Parameter> parameter1s_80d= currLocalVar1_809.param();
							for( set< CyberComposition::Simulink::SF_Parameter>::const_iterator itParameter1s_80e= parameter1s_80d.begin(); itParameter1s_80e!= parameter1s_80d.end(); ++itParameter1s_80e)
							{
								CyberComposition::Simulink::SF_Parameter currParameter1_80f= *itParameter1s_80e;
								Match currMatch;
								set< pair<int, Udm::Object> > boundObjs_813;
								if( !isValidBound(boundObjs_813, class1_7f3, true))
									continue;
								currMatch.class1_814= class1_7f3;
								if( !isValidBound(boundObjs_813, class2_7fc, true))
									continue;
								currMatch.class2_815= class2_7fc;
								if( !isValidBound(boundObjs_813, currStruct1_806, false))
									continue;
								currMatch.struct1_816= currStruct1_806;
								if( !isValidBound(boundObjs_813, currLocalVar1_809, false))
									continue;
								currMatch.localVar1_817= currLocalVar1_809;
								if( !isValidBound(boundObjs_813, currParameter1_80f, false))
									continue;
								currMatch.parameter1_818= currParameter1_80f;
								if( !isValidBound(boundObjs_813, currParameter2_80c, false))
									continue;
								currMatch.parameter2_819= currParameter2_80c;
								if( !isValidBound(boundObjs_813, currStruct2_800, false))
									continue;
								currMatch.struct2_81a= currStruct2_800;
								if( !isValidBound(boundObjs_813, currLocalVar2_803, false))
									continue;
								currMatch.localVar2_81b= currLocalVar2_803;
								bool Gz_guard= isGuardTrue( currMatch.class1_814, currMatch.class2_815, currMatch.localVar1_817, currMatch.localVar2_81b, currMatch.parameter1_818, currMatch.parameter2_819, currMatch.struct1_816, currMatch.struct2_81a);
								if( true== Gz_guard)
									_matches.push_back( currMatch);
							}
						}
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void TransferParameterMember_7e3::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Class& Class1= currMatch.class1_814;
		SFC::Class& Class2= currMatch.class2_815;
		SFC::LocalVar& LocalVar1= currMatch.localVar1_817;
		SFC::LocalVar& LocalVar2= currMatch.localVar2_81b;
		CyberComposition::Simulink::SF_Parameter& Parameter1= currMatch.parameter1_818;
		CyberComposition::Simulink::SF_Parameter& Parameter2= currMatch.parameter2_819;
		SFC::Struct& Struct1= currMatch.struct1_816;
		SFC::Struct& Struct2= currMatch.struct2_81a;
		{
Parameter2.memb() = LocalVar1;
};
		currMatch.localVar1_817.param()+= currMatch.parameter2_819;
		outputAppender( currMatch.localVar1_817, currMatch.localVar2_81b);
	}
}

void TransferParameterMember_7e3::outputAppender( const SFC::LocalVar& localVar1_824, const SFC::LocalVar& localVar2_826)
{
	_localVar1_7ea->push_back( localVar1_824);
	_localVar2_7eb->push_back( localVar2_826);
}

void TransferMethodCalls_83d::operator()( const Packets_t& class1s_83e, const Packets_t& class2s_840, Packets_t& class1s_842, Packets_t& class2s_843)
{
#ifdef PRINT_INFO
	printLog( "TransferMethodCalls_83d" );
#endif
	_class1_844= &class1s_842;
	_class2_845= &class2s_843;
	_class1_844->insert( _class1_844->end(), class1s_83e.begin(), class1s_83e.end());
	_class2_845->insert( _class2_845->end(), class2s_840.begin(), class2s_840.end());
	if( ( !class1s_83e.empty())&& ( !class2s_840.empty()))
		callGetMethods_8e2( class1s_83e, class2s_840);
}

void TransferMethodCalls_83d::callGetMethods_8e2( const Packets_t& class1s_848, const Packets_t& class2s_84b)
{
	Packets_t method1s_847;
	Packets_t method2s_84a;
	GetMethods_846 getMethods_846;
	getMethods_846( class1s_848, class2s_84b, method1s_847, method2s_84a);
	if( ( !method1s_847.empty())&& ( !method2s_84a.empty()))
		callTransferMethodCalls_8e5( method1s_847, method2s_84a);
}

void TransferMethodCalls_83d::callTransferMethodCalls_8e5( const Packets_t& method1s_878, const Packets_t& method2s_87a)
{
	TransferMethodCalls_877 transferMethodCalls_877;
	transferMethodCalls_877( method1s_878, method2s_87a);
}

void GetMethods_846::operator()( const Packets_t& class1s_848, const Packets_t& class2s_84b, Packets_t& method1s_847, Packets_t& method2s_84a)
{
#ifdef PRINT_INFO
	printLog( "GetMethods_846" );
#endif
	RTTGenerator::Instance()->generateRule(410, "GetMethods");
	_method1_84d= &method1s_847;
	_method2_84e= &method2s_84a;
	processInputPackets( class1s_848, class2s_84b);
}

bool GetMethods_846::isInputUnique( const Udm::Object& class1_853, const Udm::Object& class2_85c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass1_855= _class1_84f.begin(), itClass2_85e= _class2_858.begin(); itClass1_855!= _class1_84f.end(), itClass2_85e!= _class2_858.end(); ++itClass1_855, ++itClass2_85e)
	{
		if( ( *itClass1_855== class1_853)&& ( *itClass2_85e== class2_85c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_class1_84f.push_back( class1_853);
		_class2_858.push_back( class2_85c);
	}
	return isUnique;
}

bool GetMethods_846::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool GetMethods_846::isGuardTrue( SFC::Class& Class1, SFC::Class& Class2, SFC::Function& Method1, SFC::Function& Method2)
{
	bool Gz_guard= false;
	Gz_guard = Method1.statementIndex() == Method2.statementIndex();;
	return Gz_guard;
}

void GetMethods_846::processInputPackets( const Packets_t& class1s_848, const Packets_t& class2s_84b)
{
	for( Packets_t::const_iterator itClass1_850= class1s_848.begin(), itClass2_859= class2s_84b.begin(); itClass1_850!= class1s_848.end(), itClass2_859!= class2s_84b.end(); ++itClass1_850, ++itClass2_859)
	{
		bool isUnique= isInputUnique( *itClass1_850, *itClass2_859);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass1_850, *itClass2_859);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetMethods_846::patternMatcher( const Udm::Object& class1_851, const Udm::Object& class2_85a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class1_851.type(), SFC::Class::meta))
			continue;
		SFC::Class class1_856= SFC::Class::Cast( class1_851);
		if( false== Uml::IsDerivedFrom( class2_85a.type(), SFC::Class::meta))
			continue;
		SFC::Class class2_85f= SFC::Class::Cast( class2_85a);
		set< SFC::Function> method2s_861= class2_85f.Function_kind_children();
		for( set< SFC::Function>::const_iterator itMethod2_862= method2s_861.begin(); itMethod2_862!= method2s_861.end(); ++itMethod2_862)
		{
			SFC::Function currMethod2_863= *itMethod2_862;
			set< SFC::Function> method1s_864= class1_856.Function_kind_children();
			for( set< SFC::Function>::const_iterator itMethod1_865= method1s_864.begin(); itMethod1_865!= method1s_864.end(); ++itMethod1_865)
			{
				SFC::Function currMethod1_866= *itMethod1_865;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_86a;
				if( !isValidBound(boundObjs_86a, class1_856, true))
					continue;
				currMatch.class1_86b= class1_856;
				if( !isValidBound(boundObjs_86a, class2_85f, true))
					continue;
				currMatch.class2_86c= class2_85f;
				if( !isValidBound(boundObjs_86a, currMethod1_866, false))
					continue;
				currMatch.method1_86d= currMethod1_866;
				if( !isValidBound(boundObjs_86a, currMethod2_863, false))
					continue;
				currMatch.method2_86e= currMethod2_863;
				bool Gz_guard= isGuardTrue( currMatch.class1_86b, currMatch.class2_86c, currMatch.method1_86d, currMatch.method2_86e);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetMethods_846::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.method1_86d, currMatch.method2_86e);
	}
}

void GetMethods_846::outputAppender( const SFC::Function& method1_873, const SFC::Function& method2_875)
{
	_method1_84d->push_back( method1_873);
	_method2_84e->push_back( method2_875);
}

void TransferMethodCalls_877::operator()( const Packets_t& method1s_878, const Packets_t& method2s_87a)
{
#ifdef PRINT_INFO
	printLog( "TransferMethodCalls_877" );
#endif
	if( ( !method1s_878.empty())&& ( !method2s_87a.empty()))
		callTransferMethodCallArgs_8dc( method1s_878, method2s_87a);
}

void TransferMethodCalls_877::callTransferMethodCallArgs_8dc( const Packets_t& method1s_89e, const Packets_t& method2s_8a0)
{
	Packets_t method1s_8a2;
	Packets_t method2s_8a3;
	TransferMethodCallArgs_89d transferMethodCallArgs_89d;
	transferMethodCallArgs_89d( method1s_89e, method2s_8a0, method1s_8a2, method2s_8a3);
	if( ( !method1s_8a2.empty())&& ( !method2s_8a3.empty()))
		callTransferMethodCallTarget_8df( method1s_8a2, method2s_8a3);
}

void TransferMethodCalls_877::callTransferMethodCallTarget_8df( const Packets_t& method1s_87d, const Packets_t& method2s_87f)
{
	TransferMethodCallTarget_87c transferMethodCallTarget_87c;
	transferMethodCallTarget_87c( method1s_87d, method2s_87f);
}

void TransferMethodCallTarget_87c::operator()( const Packets_t& method1s_87d, const Packets_t& method2s_87f)
{
#ifdef PRINT_INFO
	printLog( "TransferMethodCallTarget_87c" );
#endif
	RTTGenerator::Instance()->generateRule(420, "TransferMethodCallTarget");
	processInputPackets( method1s_87d, method2s_87f);
}

bool TransferMethodCallTarget_87c::isInputUnique( const Udm::Object& method1_885, const Udm::Object& method2_88e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMethod1_887= _method1_881.begin(), itMethod2_890= _method2_88a.begin(); itMethod1_887!= _method1_881.end(), itMethod2_890!= _method2_88a.end(); ++itMethod1_887, ++itMethod2_890)
	{
		if( ( *itMethod1_887== method1_885)&& ( *itMethod2_890== method2_88e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_method1_881.push_back( method1_885);
		_method2_88a.push_back( method2_88e);
	}
	return isUnique;
}

bool TransferMethodCallTarget_87c::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void TransferMethodCallTarget_87c::processInputPackets( const Packets_t& method1s_87d, const Packets_t& method2s_87f)
{
	for( Packets_t::const_iterator itMethod1_882= method1s_87d.begin(), itMethod2_88b= method2s_87f.begin(); itMethod1_882!= method1s_87d.end(), itMethod2_88b!= method2s_87f.end(); ++itMethod1_882, ++itMethod2_88b)
	{
		bool isUnique= isInputUnique( *itMethod1_882, *itMethod2_88b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMethod1_882, *itMethod2_88b);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool TransferMethodCallTarget_87c::patternMatcher( const Udm::Object& method1_883, const Udm::Object& method2_88c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( method1_883.type(), SFC::Function::meta))
			continue;
		SFC::Function method1_888= SFC::Function::Cast( method1_883);
		if( false== Uml::IsDerivedFrom( method2_88c.type(), SFC::Function::meta))
			continue;
		SFC::Function method2_891= SFC::Function::Cast( method2_88c);
		set< SFC::FunctionCall> methodCall2s_893= method2_891.caller();
		for( set< SFC::FunctionCall>::const_iterator itMethodCall2s_894= methodCall2s_893.begin(); itMethodCall2s_894!= methodCall2s_893.end(); ++itMethodCall2s_894)
		{
			SFC::FunctionCall currMethodCall2_895= *itMethodCall2s_894;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_899;
			if( !isValidBound(boundObjs_899, method1_888, true))
				continue;
			currMatch.method1_89a= method1_888;
			if( !isValidBound(boundObjs_899, method2_891, true))
				continue;
			currMatch.method2_89b= method2_891;
			if( !isValidBound(boundObjs_899, currMethodCall2_895, false))
				continue;
			currMatch.methodCall2_89c= currMethodCall2_895;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void TransferMethodCallTarget_87c::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		currMatch.methodCall2_89c.callee()= currMatch.method1_89a;
	}
}

void TransferMethodCallArgs_89d::operator()( const Packets_t& method1s_89e, const Packets_t& method2s_8a0, Packets_t& method1s_8a2, Packets_t& method2s_8a3)
{
#ifdef PRINT_INFO
	printLog( "TransferMethodCallArgs_89d" );
#endif
	_method1_8a4= &method1s_8a2;
	_method2_8a5= &method2s_8a3;
	if( ( !method1s_89e.empty())&& ( !method2s_8a0.empty()))
		callTransferMethodCallArgs_8d9( method1s_89e, method2s_8a0);
	_method1_8a4->insert( _method1_8a4->end(), method1s_89e.begin(), method1s_89e.end());
	_method2_8a5->insert( _method2_8a5->end(), method2s_8a0.begin(), method2s_8a0.end());
}

void TransferMethodCallArgs_89d::callTransferMethodCallArgs_8d9( const Packets_t& method1s_8a7, const Packets_t& method2s_8a9)
{
	TransferMethodCallArgs_8a6 transferMethodCallArgs_8a6;
	transferMethodCallArgs_8a6( method1s_8a7, method2s_8a9);
}

void TransferMethodCallArgs_8a6::operator()( const Packets_t& method1s_8a7, const Packets_t& method2s_8a9)
{
#ifdef PRINT_INFO
	printLog( "TransferMethodCallArgs_8a6" );
#endif
	RTTGenerator::Instance()->generateRule(431, "TransferMethodCallArgs");
	processInputPackets( method1s_8a7, method2s_8a9);
}

bool TransferMethodCallArgs_8a6::isInputUnique( const Udm::Object& method1_8af, const Udm::Object& method2_8b8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMethod1_8b1= _method1_8ab.begin(), itMethod2_8ba= _method2_8b4.begin(); itMethod1_8b1!= _method1_8ab.end(), itMethod2_8ba!= _method2_8b4.end(); ++itMethod1_8b1, ++itMethod2_8ba)
	{
		if( ( *itMethod1_8b1== method1_8af)&& ( *itMethod2_8ba== method2_8b8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_method1_8ab.push_back( method1_8af);
		_method2_8b4.push_back( method2_8b8);
	}
	return isUnique;
}

bool TransferMethodCallArgs_8a6::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool TransferMethodCallArgs_8a6::isGuardTrue( SFC::Arg& Arg1, SFC::Arg& Arg2, SFC::ArgVal& ArgVal, SFC::Function& Method1, SFC::Function& Method2, SFC::FunctionCall& MethodCall2)
{
	bool Gz_guard= false;
	Gz_guard = Arg1.argIndex() == Arg2.argIndex();;
	return Gz_guard;
}

void TransferMethodCallArgs_8a6::processInputPackets( const Packets_t& method1s_8a7, const Packets_t& method2s_8a9)
{
	for( Packets_t::const_iterator itMethod1_8ac= method1s_8a7.begin(), itMethod2_8b5= method2s_8a9.begin(); itMethod1_8ac!= method1s_8a7.end(), itMethod2_8b5!= method2s_8a9.end(); ++itMethod1_8ac, ++itMethod2_8b5)
	{
		bool isUnique= isInputUnique( *itMethod1_8ac, *itMethod2_8b5);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMethod1_8ac, *itMethod2_8b5);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool TransferMethodCallArgs_8a6::patternMatcher( const Udm::Object& method1_8ad, const Udm::Object& method2_8b6)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( method1_8ad.type(), SFC::Function::meta))
			continue;
		SFC::Function method1_8b2= SFC::Function::Cast( method1_8ad);
		if( false== Uml::IsDerivedFrom( method2_8b6.type(), SFC::Function::meta))
			continue;
		SFC::Function method2_8bb= SFC::Function::Cast( method2_8b6);
		set< SFC::Arg> arg1s_8bd= method1_8b2.Arg_kind_children();
		for( set< SFC::Arg>::const_iterator itArg1_8be= arg1s_8bd.begin(); itArg1_8be!= arg1s_8bd.end(); ++itArg1_8be)
		{
			SFC::Arg currArg1_8bf= *itArg1_8be;
			set< SFC::Arg> arg2s_8c0= method2_8bb.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itArg2_8c1= arg2s_8c0.begin(); itArg2_8c1!= arg2s_8c0.end(); ++itArg2_8c1)
			{
				SFC::Arg currArg2_8c2= *itArg2_8c1;
				set< SFC::ArgVal> argVals_8c3= currArg2_8c2.val();
				for( set< SFC::ArgVal>::const_iterator itArgVals_8c4= argVals_8c3.begin(); itArgVals_8c4!= argVals_8c3.end(); ++itArgVals_8c4)
				{
					SFC::ArgVal currArgVal_8c5= *itArgVals_8c4;
					Udm::Object argValParent_8c6= currArgVal_8c5.container();
					if( false== Uml::IsDerivedFrom( argValParent_8c6.type(), SFC::FunctionCall::meta))
						continue;
					SFC::FunctionCall methodCall2ArgVal_8c7= SFC::FunctionCall::Cast( argValParent_8c6);
					SFC::Function method2_8c8= methodCall2ArgVal_8c7.callee();
					if( !method2_8c8)
						continue;
					if( method2_8bb!= method2_8c8)
						continue;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_8cc;
					if( !isValidBound(boundObjs_8cc, method1_8b2, true))
						continue;
					currMatch.method1_8cd= method1_8b2;
					if( !isValidBound(boundObjs_8cc, method2_8bb, true))
						continue;
					currMatch.method2_8ce= method2_8bb;
					if( !isValidBound(boundObjs_8cc, currArg1_8bf, false))
						continue;
					currMatch.arg1_8cf= currArg1_8bf;
					if( !isValidBound(boundObjs_8cc, methodCall2ArgVal_8c7, false))
						continue;
					currMatch.methodCall2_8d0= methodCall2ArgVal_8c7;
					if( !isValidBound(boundObjs_8cc, currArgVal_8c5, false))
						continue;
					currMatch.argVal_8d1= currArgVal_8c5;
					if( !isValidBound(boundObjs_8cc, currArg2_8c2, false))
						continue;
					currMatch.arg2_8d2= currArg2_8c2;
					bool Gz_guard= isGuardTrue( currMatch.arg1_8cf, currMatch.arg2_8d2, currMatch.argVal_8d1, currMatch.method1_8cd, currMatch.method2_8ce, currMatch.methodCall2_8d0);
					if( true== Gz_guard)
						_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void TransferMethodCallArgs_8a6::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		currMatch.argVal_8d1.arg()+= currMatch.arg1_8cf;
	}
}

void DeleteClass_8e8::operator()( const Packets_t& deleteClasss_8e9)
{
#ifdef PRINT_INFO
	printLog( "DeleteClass_8e8" );
#endif
	if( ( !deleteClasss_8e9.empty()))
		callmarkClass_92a( deleteClasss_8e9);
}

void DeleteClass_8e8::callmarkClass_92a( const Packets_t& classs_8ec)
{
	Packets_t classs_8ee;
	MarkClass_8eb markClass_8eb;
	markClass_8eb( classs_8ec, classs_8ee);
	if( ( !classs_8ee.empty()))
		callnoEquivDst_92c( classs_8ee);
}

void DeleteClass_8e8::callnoEquivDst_92c( const Packets_t& class2s_8ff)
{
	Packets_t class2s_901;
	NoEquivDst_8fe noEquivDst_8fe;
	noEquivDst_8fe( class2s_8ff, class2s_901);
	if( ( !class2s_901.empty()))
		callnoEquivSrc_92e( class2s_901);
}

void DeleteClass_8e8::callnoEquivSrc_92e( const Packets_t& class1s_916)
{
	NoEquivSrc_915 noEquivSrc_915;
	noEquivSrc_915( class1s_916);
}

void MarkClass_8eb::operator()( const Packets_t& classs_8ec, Packets_t& classs_8ee)
{
#ifdef PRINT_INFO
	printLog( "MarkClass_8eb" );
#endif
	RTTGenerator::Instance()->generateRule(446, "markClass");
	_class_8ef= &classs_8ee;
	processInputPackets( classs_8ec);
	forwardInputs( );
}

bool MarkClass_8eb::isInputUnique( const Udm::Object& class_8f4)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass_8f6= _class_8f0.begin(); itClass_8f6!= _class_8f0.end(); ++itClass_8f6)
	{
		if( ( *itClass_8f6== class_8f4))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_class_8f0.push_back( class_8f4);
	return isUnique;
}

bool MarkClass_8eb::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void MarkClass_8eb::processInputPackets( const Packets_t& classs_8ec)
{
	for( Packets_t::const_iterator itClass_8f1= classs_8ec.begin(); itClass_8f1!= classs_8ec.end(); ++itClass_8f1)
	{
		bool isUnique= isInputUnique( *itClass_8f1);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass_8f1);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool MarkClass_8eb::patternMatcher( const Udm::Object& class_8f2)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class_8f2.type(), SFC::Class::meta))
			continue;
		SFC::Class class_8f7= SFC::Class::Cast( class_8f2);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_8fc;
		if( !isValidBound(boundObjs_8fc, class_8f7, true))
			continue;
		currMatch.class_8fd= class_8f7;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void MarkClass_8eb::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Class& Class= currMatch.class_8fd;
		{
Class.statementCount() = -Class.statementCount();
};
	}
}

void MarkClass_8eb::forwardInputs()
{
	*_class_8ef= _class_8f0;
}

void NoEquivDst_8fe::operator()( const Packets_t& class2s_8ff, Packets_t& class2s_901)
{
#ifdef PRINT_INFO
	printLog( "NoEquivDst_8fe" );
#endif
	RTTGenerator::Instance()->generateRule(449, "noEquivDst");
	_class2_902= &class2s_901;
	processInputPackets( class2s_8ff);
	forwardInputs( );
}

bool NoEquivDst_8fe::isInputUnique( const Udm::Object& class2_907)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass2_909= _class2_903.begin(); itClass2_909!= _class2_903.end(); ++itClass2_909)
	{
		if( ( *itClass2_909== class2_907))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_class2_903.push_back( class2_907);
	return isUnique;
}

bool NoEquivDst_8fe::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void NoEquivDst_8fe::processInputPackets( const Packets_t& class2s_8ff)
{
	for( Packets_t::const_iterator itClass2_904= class2s_8ff.begin(); itClass2_904!= class2s_8ff.end(); ++itClass2_904)
	{
		bool isUnique= isInputUnique( *itClass2_904);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass2_904);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool NoEquivDst_8fe::patternMatcher( const Udm::Object& class2_905)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class2_905.type(), SFC::Class::meta))
			continue;
		SFC::Class class2_90a= SFC::Class::Cast( class2_905);
		set< SFC::Class> class1s_90c= class2_90a.equivsrc();
		for( set< SFC::Class>::const_iterator itClass1s_90d= class1s_90c.begin(); itClass1s_90d!= class1s_90c.end(); ++itClass1s_90d)
		{
			SFC::Class currClass1_90e= *itClass1s_90d;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_912;
			if( !isValidBound(boundObjs_912, class2_90a, true))
				continue;
			currMatch.class2_913= class2_90a;
			if( !isValidBound(boundObjs_912, currClass1_90e, false))
				continue;
			currMatch.class1_914= currClass1_90e;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void NoEquivDst_8fe::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		currMatch.class1_914.equivdst()-= currMatch.class2_913;
	}
}

void NoEquivDst_8fe::forwardInputs()
{
	*_class2_902= _class2_903;
}

void NoEquivSrc_915::operator()( const Packets_t& class1s_916)
{
#ifdef PRINT_INFO
	printLog( "NoEquivSrc_915" );
#endif
	RTTGenerator::Instance()->generateRule(453, "noEquivSrc");
	processInputPackets( class1s_916);
}

bool NoEquivSrc_915::isInputUnique( const Udm::Object& class1_91c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass1_91e= _class1_918.begin(); itClass1_91e!= _class1_918.end(); ++itClass1_91e)
	{
		if( ( *itClass1_91e== class1_91c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_class1_918.push_back( class1_91c);
	return isUnique;
}

bool NoEquivSrc_915::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void NoEquivSrc_915::processInputPackets( const Packets_t& class1s_916)
{
	for( Packets_t::const_iterator itClass1_919= class1s_916.begin(); itClass1_919!= class1s_916.end(); ++itClass1_919)
	{
		bool isUnique= isInputUnique( *itClass1_919);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass1_919);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool NoEquivSrc_915::patternMatcher( const Udm::Object& class1_91a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class1_91a.type(), SFC::Class::meta))
			continue;
		SFC::Class class1_91f= SFC::Class::Cast( class1_91a);
		set< SFC::Class> class2s_921= class1_91f.equivdst();
		for( set< SFC::Class>::const_iterator itClass2s_922= class2s_921.begin(); itClass2s_922!= class2s_921.end(); ++itClass2s_922)
		{
			SFC::Class currClass2_923= *itClass2s_922;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_927;
			if( !isValidBound(boundObjs_927, class1_91f, true))
				continue;
			currMatch.class1_928= class1_91f;
			if( !isValidBound(boundObjs_927, currClass2_923, false))
				continue;
			currMatch.class2_929= currClass2_923;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void NoEquivSrc_915::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
	}
}

void TestEquivalence_93d::operator()( const Packets_t& classs_93e, Packets_t& classs_940)
{
#ifdef PRINT_INFO
	printLog( "TestEquivalence_93d" );
#endif
	_class_941= &classs_940;
	for( Packets_t::const_iterator itclass_943= classs_93e.begin(); itclass_943!= classs_93e.end(); ++itclass_943)
	{
		bool isUnique= isInputUnique( *itclass_943);
		if( !isUnique)
			continue;
		Packets_t oneclass_947( 1, *itclass_943);
		executeOne( oneclass_947);
	}
}

void TestEquivalence_93d::executeOne( const Packets_t& classs_93e)
{
	if( ( !classs_93e.empty()))
		callTestDataMembers_bca( classs_93e);
}

bool TestEquivalence_93d::isInputUnique( const Udm::Object& class_944)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itclass_946= _class_942.begin(); itclass_946!= _class_942.end(); ++itclass_946)
	{
		if( ( *itclass_946== class_944))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_class_942.push_back( class_944);
	return isUnique;
}

void TestEquivalence_93d::callTestDataMembers_bca( const Packets_t& classs_94a)
{
	Packets_t classs_94c;
	TestDataMembers_949 testDataMembers_949;
	testDataMembers_949( classs_94a, classs_94c);
	if( ( !classs_94c.empty()))
		callCheckMethods_bcc( classs_94c);
}

void TestEquivalence_93d::callCheckMethods_bcc( const Packets_t& classs_aba)
{
	Packets_t classs_abc;
	CheckMethods_ab9 checkMethods_ab9;
	checkMethods_ab9( classs_aba, classs_abc);
	_class_941->insert( _class_941->end(), classs_abc.begin(), classs_abc.end());
}

void TestDataMembers_949::operator()( const Packets_t& classs_94a, Packets_t& classs_94c)
{
#ifdef PRINT_INFO
	printLog( "TestDataMembers_949" );
#endif
	_class_94d= &classs_94c;
	_class_94d->insert( _class_94d->end(), classs_94a.begin(), classs_94a.end());
	if( ( !classs_94a.empty()))
		callGetMembers_aaf( classs_94a);
}

void TestDataMembers_949::callGetMembers_aaf( const Packets_t& class1s_a87)
{
	Packets_t class1s_a89;
	Packets_t class2s_a8a;
	Packets_t localVar1s_a8b;
	GetMembers_a86 getMembers_a86;
	getMembers_a86( class1s_a87, class1s_a89, class2s_a8a, localVar1s_a8b);
	if( ( !class1s_a89.empty())&& ( !class2s_a8a.empty())&& ( !localVar1s_a8b.empty()))
		callTestMembers_ab1( class1s_a89, class2s_a8a, localVar1s_a8b);
}

void TestDataMembers_949::callTestMembers_ab1( const Packets_t& class1s_97b, const Packets_t& class2s_97d, const Packets_t& members_97f)
{
	Packets_t class1s_981;
	Packets_t class2s_982;
	Packets_t members_983;
	Packets_t class1s_984;
	Packets_t class2s_985;
	Packets_t members_986;
	Packets_t class1s_987;
	Packets_t class2s_988;
	Packets_t members_989;
	TestMembers_97a testMembers_97a;
	testMembers_97a( class1s_97b, class2s_97d, members_97f, class1s_981, class2s_982, members_983, class1s_984, class2s_985, members_986, class1s_987, class2s_988, members_989);
	if( ( !class1s_987.empty())&& ( !class2s_988.empty())&& ( !members_989.empty()))
		callBreakEquivalence_ab5( class1s_987, class2s_988, members_989);
}

void TestDataMembers_949::callBreakEquivalence_ab5( const Packets_t& class1s_94f, const Packets_t& class2s_951, const Packets_t& localVar1s_953)
{
	BreakEquivalence_94e breakEquivalence_94e;
	breakEquivalence_94e( class1s_94f, class2s_951, localVar1s_953);
}

void BreakEquivalence_94e::operator()( const Packets_t& class1s_94f, const Packets_t& class2s_951, const Packets_t& localVar1s_953)
{
#ifdef PRINT_INFO
	printLog( "BreakEquivalence_94e" );
#endif
	RTTGenerator::Instance()->generateRule(463, "BreakEquivalence");
	processInputPackets( class1s_94f, class2s_951, localVar1s_953);
}

bool BreakEquivalence_94e::isInputUnique( const Udm::Object& class1_959, const Udm::Object& class2_962, const Udm::Object& localVar1_96b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass1_95b= _class1_955.begin(), itClass2_964= _class2_95e.begin(), itLocalVar1_96d= _localVar1_967.begin(); itClass1_95b!= _class1_955.end(), itClass2_964!= _class2_95e.end(), itLocalVar1_96d!= _localVar1_967.end(); ++itClass1_95b, ++itClass2_964, ++itLocalVar1_96d)
	{
		if( ( *itClass1_95b== class1_959)&& ( *itClass2_964== class2_962)&& ( *itLocalVar1_96d== localVar1_96b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_class1_955.push_back( class1_959);
		_class2_95e.push_back( class2_962);
		_localVar1_967.push_back( localVar1_96b);
	}
	return isUnique;
}

bool BreakEquivalence_94e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void BreakEquivalence_94e::processInputPackets( const Packets_t& class1s_94f, const Packets_t& class2s_951, const Packets_t& localVar1s_953)
{
	for( Packets_t::const_iterator itClass1_956= class1s_94f.begin(), itClass2_95f= class2s_951.begin(), itLocalVar1_968= localVar1s_953.begin(); itClass1_956!= class1s_94f.end(), itClass2_95f!= class2s_951.end(), itLocalVar1_968!= localVar1s_953.end(); ++itClass1_956, ++itClass2_95f, ++itLocalVar1_968)
	{
		bool isUnique= isInputUnique( *itClass1_956, *itClass2_95f, *itLocalVar1_968);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass1_956, *itClass2_95f, *itLocalVar1_968);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool BreakEquivalence_94e::patternMatcher( const Udm::Object& class1_957, const Udm::Object& class2_960, const Udm::Object& localVar1_969)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class1_957.type(), SFC::Class::meta))
			continue;
		SFC::Class class1_95c= SFC::Class::Cast( class1_957);
		if( false== Uml::IsDerivedFrom( class2_960.type(), SFC::Class::meta))
			continue;
		SFC::Class class2_965= SFC::Class::Cast( class2_960);
		if( false== Uml::IsDerivedFrom( localVar1_969.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar1_96e= SFC::LocalVar::Cast( localVar1_969);
		set< SFC::Class> class2s_970= class1_95c.equivdst();
		for( set< SFC::Class>::const_iterator itClass2s_971= class2s_970.begin(); itClass2s_971!= class2s_970.end(); ++itClass2s_971)
		{
			SFC::Class currClass2_972= *itClass2s_971;
			if( class2_965!= currClass2_972)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_976;
			if( !isValidBound(boundObjs_976, class1_95c, true))
				continue;
			currMatch.class1_977= class1_95c;
			if( !isValidBound(boundObjs_976, class2_965, true))
				continue;
			currMatch.class2_978= class2_965;
			if( !isValidBound(boundObjs_976, localVar1_96e, true))
				continue;
			currMatch.localVar1_979= localVar1_96e;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void BreakEquivalence_94e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		currMatch.class1_977.equivdst()-= currMatch.class2_978;
	}
}

void TestMembers_97a::operator()( const Packets_t& class1s_97b, const Packets_t& class2s_97d, const Packets_t& members_97f, Packets_t& class1s_981, Packets_t& class2s_982, Packets_t& members_983, Packets_t& class1s_984, Packets_t& class2s_985, Packets_t& members_986, Packets_t& class1s_987, Packets_t& class2s_988, Packets_t& members_989)
{
#ifdef PRINT_INFO
	printLog( "TestMembers_97a" );
#endif
	_class1_98a= &class1s_981;
	_class2_98b= &class2s_982;
	_member_98c= &members_983;
	_class1_98d= &class1s_984;
	_class2_98e= &class2s_985;
	_member_98f= &members_986;
	_class1_990= &class1s_987;
	_class2_991= &class2s_988;
	_member_992= &members_989;
	for( Packets_t::const_iterator itclass1_994= class1s_97b.begin(), itclass2_99b= class2s_97d.begin(), itmember_9a2= members_97f.begin(); itclass1_994!= class1s_97b.end(), itclass2_99b!= class2s_97d.end(), itmember_9a2!= members_97f.end(); ++itclass1_994, ++itclass2_99b, ++itmember_9a2)
	{
		bool isUnique= isInputUnique( *itclass1_994, *itclass2_99b, *itmember_9a2);
		if( !isUnique)
			continue;
		Packets_t oneclass1_998( 1, *itclass1_994);
		Packets_t oneclass2_99f( 1, *itclass2_99b);
		Packets_t onemember_9a6( 1, *itmember_9a2);
		executeOne( oneclass1_998, oneclass2_99f, onemember_9a6);
	}
}

void TestMembers_97a::executeOne( const Packets_t& class1s_97b, const Packets_t& class2s_97d, const Packets_t& members_97f)
{
	Packets_t class1s_9ab;
	Packets_t class2s_9ae;
	Packets_t localVar1s_9b1;
	ParameterMemberMatch_9a8 parameterMemberMatch_9a8;
	bool isMatchParameterMemberMatch_9a8= parameterMemberMatch_9a8( class1s_97b, class2s_97d, members_97f, class1s_9ab, class2s_9ae, localVar1s_9b1);
	_class1_98a->insert( _class1_98a->end(), class1s_9ab.begin(), class1s_9ab.end());
	_class2_98b->insert( _class2_98b->end(), class2s_9ae.begin(), class2s_9ae.end());
	_member_98c->insert( _member_98c->end(), localVar1s_9b1.begin(), localVar1s_9b1.end());
	if( isMatchParameterMemberMatch_9a8)
		return;
	Packets_t class1s_9fe;
	Packets_t class2s_a01;
	Packets_t localVar1s_a04;
	StructMemberMatch_9fb structMemberMatch_9fb;
	bool isMatchStructMemberMatch_9fb= structMemberMatch_9fb( class1s_97b, class2s_97d, members_97f, class1s_9fe, class2s_a01, localVar1s_a04);
	_class1_98d->insert( _class1_98d->end(), class1s_9fe.begin(), class1s_9fe.end());
	_class2_98e->insert( _class2_98e->end(), class2s_a01.begin(), class2s_a01.end());
	_member_98f->insert( _member_98f->end(), localVar1s_a04.begin(), localVar1s_a04.end());
	if( isMatchStructMemberMatch_9fb)
		return;
	Packets_t class1s_a51;
	Packets_t class2s_a54;
	Packets_t localVar1s_a57;
	NoMemberMatch_a4e noMemberMatch_a4e;
	bool isMatchNoMemberMatch_a4e= noMemberMatch_a4e( class1s_97b, class2s_97d, members_97f, class1s_a51, class2s_a54, localVar1s_a57);
	_class1_990->insert( _class1_990->end(), class1s_a51.begin(), class1s_a51.end());
	_class2_991->insert( _class2_991->end(), class2s_a54.begin(), class2s_a54.end());
	_member_992->insert( _member_992->end(), localVar1s_a57.begin(), localVar1s_a57.end());
	if( isMatchNoMemberMatch_a4e)
		return;
}

bool TestMembers_97a::isInputUnique( const Udm::Object& class1_995, const Udm::Object& class2_99c, const Udm::Object& member_9a3)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itclass1_997= _class1_993.begin(), itclass2_99e= _class2_99a.begin(), itmember_9a5= _member_9a1.begin(); itclass1_997!= _class1_993.end(), itclass2_99e!= _class2_99a.end(), itmember_9a5!= _member_9a1.end(); ++itclass1_997, ++itclass2_99e, ++itmember_9a5)
	{
		if( ( *itclass1_997== class1_995)&& ( *itclass2_99e== class2_99c)&& ( *itmember_9a5== member_9a3))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_class1_993.push_back( class1_995);
		_class2_99a.push_back( class2_99c);
		_member_9a1.push_back( member_9a3);
	}
	return isUnique;
}

bool ParameterMemberMatch_9a8::operator()( const Packets_t& class1s_9a9, const Packets_t& class2s_9ac, const Packets_t& localVar1s_9af, Packets_t& class1s_9ab, Packets_t& class2s_9ae, Packets_t& localVar1s_9b1)
{
#ifdef PRINT_INFO
	printLog( "ParameterMemberMatch_9a8" );
#endif
	_class1_9b2= &class1s_9ab;
	_class2_9b3= &class2s_9ae;
	_localVar1_9b4= &localVar1s_9b1;
	processInputPackets( class1s_9a9, class2s_9ac, localVar1s_9af);
	if( false== _matches.empty())
		return true;
	return false;
}

bool ParameterMemberMatch_9a8::isInputUnique( const Udm::Object& class1_9b9, const Udm::Object& class2_9c2, const Udm::Object& localVar1_9cb)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass1_9bb= _class1_9b5.begin(), itClass2_9c4= _class2_9be.begin(), itLocalVar1_9cd= _localVar1_9c7.begin(); itClass1_9bb!= _class1_9b5.end(), itClass2_9c4!= _class2_9be.end(), itLocalVar1_9cd!= _localVar1_9c7.end(); ++itClass1_9bb, ++itClass2_9c4, ++itLocalVar1_9cd)
	{
		if( ( *itClass1_9bb== class1_9b9)&& ( *itClass2_9c4== class2_9c2)&& ( *itLocalVar1_9cd== localVar1_9cb))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_class1_9b5.push_back( class1_9b9);
		_class2_9be.push_back( class2_9c2);
		_localVar1_9c7.push_back( localVar1_9cb);
	}
	return isUnique;
}

bool ParameterMemberMatch_9a8::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool ParameterMemberMatch_9a8::isGuardTrue( SFC::Class& Class1, SFC::Class& Class2, SFC::DT& DT, SFC::LocalVar& LocalVar1, SFC::LocalVar& LocalVar2, CyberComposition::Simulink::SF_Parameter& Parameter1, CyberComposition::Simulink::SF_Parameter& Parameter2, SFC::Struct& Struct2)
{
	bool Gz_guard= false;
	return SFUtils::InstanceEquivalent( Parameter1, Parameter2 );;
	return Gz_guard;
}

void ParameterMemberMatch_9a8::processInputPackets( const Packets_t& class1s_9a9, const Packets_t& class2s_9ac, const Packets_t& localVar1s_9af)
{
	for( Packets_t::const_iterator itClass1_9b6= class1s_9a9.begin(), itClass2_9bf= class2s_9ac.begin(), itLocalVar1_9c8= localVar1s_9af.begin(); itClass1_9b6!= class1s_9a9.end(), itClass2_9bf!= class2s_9ac.end(), itLocalVar1_9c8!= localVar1s_9af.end(); ++itClass1_9b6, ++itClass2_9bf, ++itLocalVar1_9c8)
	{
		bool isUnique= isInputUnique( *itClass1_9b6, *itClass2_9bf, *itLocalVar1_9c8);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass1_9b6, *itClass2_9bf, *itLocalVar1_9c8);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.class1_9e5, currMatch.class2_9e6, currMatch.localVar1_9e7);
	}
}

bool ParameterMemberMatch_9a8::patternMatcher( const Udm::Object& class1_9b7, const Udm::Object& class2_9c0, const Udm::Object& localVar1_9c9)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class1_9b7.type(), SFC::Class::meta))
			continue;
		SFC::Class class1_9bc= SFC::Class::Cast( class1_9b7);
		if( false== Uml::IsDerivedFrom( class2_9c0.type(), SFC::Class::meta))
			continue;
		SFC::Class class2_9c5= SFC::Class::Cast( class2_9c0);
		if( false== Uml::IsDerivedFrom( localVar1_9c9.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar1_9ce= SFC::LocalVar::Cast( localVar1_9c9);
		set< SFC::Class> class2s_9d0= class1_9bc.equivdst();
		for( set< SFC::Class>::const_iterator itClass2s_9d1= class2s_9d0.begin(); itClass2s_9d1!= class2s_9d0.end(); ++itClass2s_9d1)
		{
			SFC::Class currClass2_9d2= *itClass2s_9d1;
			if( class2_9c5!= currClass2_9d2)
				continue;
			set< SFC::Struct> struct2s_9d3= class2_9c5.Struct_kind_children();
			for( set< SFC::Struct>::const_iterator itStruct2_9d4= struct2s_9d3.begin(); itStruct2_9d4!= struct2s_9d3.end(); ++itStruct2_9d4)
			{
				SFC::Struct currStruct2_9d5= *itStruct2_9d4;
				set< SFC::LocalVar> localVar2s_9d6= currStruct2_9d5.LocalVar_kind_children();
				for( set< SFC::LocalVar>::const_iterator itLocalVar2_9d7= localVar2s_9d6.begin(); itLocalVar2_9d7!= localVar2s_9d6.end(); ++itLocalVar2_9d7)
				{
					SFC::LocalVar currLocalVar2_9d8= *itLocalVar2_9d7;
					set< CyberComposition::Simulink::SF_Parameter> parameter2s_9d9= currLocalVar2_9d8.param();
					for( set< CyberComposition::Simulink::SF_Parameter>::const_iterator itParameter2s_9da= parameter2s_9d9.begin(); itParameter2s_9da!= parameter2s_9d9.end(); ++itParameter2s_9da)
					{
						CyberComposition::Simulink::SF_Parameter currParameter2_9db= *itParameter2s_9da;
						set< CyberComposition::Simulink::SF_Parameter> parameter1s_9dc= localVar1_9ce.param();
						for( set< CyberComposition::Simulink::SF_Parameter>::const_iterator itParameter1s_9dd= parameter1s_9dc.begin(); itParameter1s_9dd!= parameter1s_9dc.end(); ++itParameter1s_9dd)
						{
							CyberComposition::Simulink::SF_Parameter currParameter1_9de= *itParameter1s_9dd;
							SFC::DT dT_9df= localVar1_9ce.dt();
							if( !dT_9df)
								continue;
							SFC::DT dT_9e0= currLocalVar2_9d8.dt();
							if( !dT_9e0)
								continue;
							if( dT_9df!= dT_9e0)
								continue;
							Match currMatch;
							set< pair<int, Udm::Object> > boundObjs_9e4;
							if( !isValidBound(boundObjs_9e4, class1_9bc, true))
								continue;
							currMatch.class1_9e5= class1_9bc;
							if( !isValidBound(boundObjs_9e4, class2_9c5, true))
								continue;
							currMatch.class2_9e6= class2_9c5;
							if( !isValidBound(boundObjs_9e4, localVar1_9ce, true))
								continue;
							currMatch.localVar1_9e7= localVar1_9ce;
							if( !isValidBound(boundObjs_9e4, currParameter2_9db, false))
								continue;
							currMatch.parameter2_9e8= currParameter2_9db;
							if( !isValidBound(boundObjs_9e4, currStruct2_9d5, false))
								continue;
							currMatch.struct2_9e9= currStruct2_9d5;
							if( !isValidBound(boundObjs_9e4, currLocalVar2_9d8, false))
								continue;
							currMatch.localVar2_9ea= currLocalVar2_9d8;
							if( !isValidBound(boundObjs_9e4, dT_9df, false))
								continue;
							currMatch.dT_9eb= dT_9df;
							if( !isValidBound(boundObjs_9e4, currParameter1_9de, false))
								continue;
							currMatch.parameter1_9ec= currParameter1_9de;
							bool Gz_guard= isGuardTrue( currMatch.class1_9e5, currMatch.class2_9e6, currMatch.dT_9eb, currMatch.localVar1_9e7, currMatch.localVar2_9ea, currMatch.parameter1_9ec, currMatch.parameter2_9e8, currMatch.struct2_9e9);
							if( true== Gz_guard)
								_matches.push_back( currMatch);
						}
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void ParameterMemberMatch_9a8::outputAppender( const SFC::Class& class1_9f5, const SFC::Class& class2_9f7, const SFC::LocalVar& localVar1_9f9)
{
	_class1_9b2->push_back( class1_9f5);
	_class2_9b3->push_back( class2_9f7);
	_localVar1_9b4->push_back( localVar1_9f9);
}

bool StructMemberMatch_9fb::operator()( const Packets_t& class1s_9fc, const Packets_t& class2s_9ff, const Packets_t& localVar1s_a02, Packets_t& class1s_9fe, Packets_t& class2s_a01, Packets_t& localVar1s_a04)
{
#ifdef PRINT_INFO
	printLog( "StructMemberMatch_9fb" );
#endif
	_class1_a05= &class1s_9fe;
	_class2_a06= &class2s_a01;
	_localVar1_a07= &localVar1s_a04;
	processInputPackets( class1s_9fc, class2s_9ff, localVar1s_a02);
	if( false== _matches.empty())
		return true;
	return false;
}

bool StructMemberMatch_9fb::isInputUnique( const Udm::Object& class1_a0c, const Udm::Object& class2_a15, const Udm::Object& localVar1_a1e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass1_a0e= _class1_a08.begin(), itClass2_a17= _class2_a11.begin(), itLocalVar1_a20= _localVar1_a1a.begin(); itClass1_a0e!= _class1_a08.end(), itClass2_a17!= _class2_a11.end(), itLocalVar1_a20!= _localVar1_a1a.end(); ++itClass1_a0e, ++itClass2_a17, ++itLocalVar1_a20)
	{
		if( ( *itClass1_a0e== class1_a0c)&& ( *itClass2_a17== class2_a15)&& ( *itLocalVar1_a20== localVar1_a1e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_class1_a08.push_back( class1_a0c);
		_class2_a11.push_back( class2_a15);
		_localVar1_a1a.push_back( localVar1_a1e);
	}
	return isUnique;
}

bool StructMemberMatch_9fb::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool StructMemberMatch_9fb::isGuardTrue( SFC::Class& Class, SFC::Class& Class1, SFC::Class& Class2, SFC::LocalVar& LocalVar1, SFC::LocalVar& LocalVar2, SFC::Struct& Struct2, CyberComposition::Simulink::Subsystem& Subsystem1, CyberComposition::Simulink::Subsystem& Subsystem2)
{
	bool Gz_guard= false;
	return SFUtils::InstanceCorrespond( Subsystem1, Subsystem2 );;
	return Gz_guard;
}

void StructMemberMatch_9fb::processInputPackets( const Packets_t& class1s_9fc, const Packets_t& class2s_9ff, const Packets_t& localVar1s_a02)
{
	for( Packets_t::const_iterator itClass1_a09= class1s_9fc.begin(), itClass2_a12= class2s_9ff.begin(), itLocalVar1_a1b= localVar1s_a02.begin(); itClass1_a09!= class1s_9fc.end(), itClass2_a12!= class2s_9ff.end(), itLocalVar1_a1b!= localVar1s_a02.end(); ++itClass1_a09, ++itClass2_a12, ++itLocalVar1_a1b)
	{
		bool isUnique= isInputUnique( *itClass1_a09, *itClass2_a12, *itLocalVar1_a1b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass1_a09, *itClass2_a12, *itLocalVar1_a1b);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.class1_a38, currMatch.class2_a39, currMatch.localVar1_a3a);
	}
}

bool StructMemberMatch_9fb::patternMatcher( const Udm::Object& class1_a0a, const Udm::Object& class2_a13, const Udm::Object& localVar1_a1c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class1_a0a.type(), SFC::Class::meta))
			continue;
		SFC::Class class1_a0f= SFC::Class::Cast( class1_a0a);
		if( false== Uml::IsDerivedFrom( class2_a13.type(), SFC::Class::meta))
			continue;
		SFC::Class class2_a18= SFC::Class::Cast( class2_a13);
		if( false== Uml::IsDerivedFrom( localVar1_a1c.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar1_a21= SFC::LocalVar::Cast( localVar1_a1c);
		set< SFC::Class> class2s_a23= class1_a0f.equivdst();
		for( set< SFC::Class>::const_iterator itClass2s_a24= class2s_a23.begin(); itClass2s_a24!= class2s_a23.end(); ++itClass2s_a24)
		{
			SFC::Class currClass2_a25= *itClass2s_a24;
			if( class2_a18!= currClass2_a25)
				continue;
			set< SFC::Struct> struct2s_a26= class2_a18.Struct_kind_children();
			for( set< SFC::Struct>::const_iterator itStruct2_a27= struct2s_a26.begin(); itStruct2_a27!= struct2s_a26.end(); ++itStruct2_a27)
			{
				SFC::Struct currStruct2_a28= *itStruct2_a27;
				set< SFC::LocalVar> localVar2s_a29= currStruct2_a28.LocalVar_kind_children();
				for( set< SFC::LocalVar>::const_iterator itLocalVar2_a2a= localVar2s_a29.begin(); itLocalVar2_a2a!= localVar2s_a29.end(); ++itLocalVar2_a2a)
				{
					SFC::LocalVar currLocalVar2_a2b= *itLocalVar2_a2a;
					set< CyberComposition::Simulink::Subsystem> subsystem2s_a2c= currLocalVar2_a2b.sys();
					for( set< CyberComposition::Simulink::Subsystem>::const_iterator itSubsystem2s_a2d= subsystem2s_a2c.begin(); itSubsystem2s_a2d!= subsystem2s_a2c.end(); ++itSubsystem2s_a2d)
					{
						CyberComposition::Simulink::Subsystem currSubsystem2_a2e= *itSubsystem2s_a2d;
						set< CyberComposition::Simulink::Subsystem> subsystem1s_a2f= localVar1_a21.sys();
						for( set< CyberComposition::Simulink::Subsystem>::const_iterator itSubsystem1s_a30= subsystem1s_a2f.begin(); itSubsystem1s_a30!= subsystem1s_a2f.end(); ++itSubsystem1s_a30)
						{
							CyberComposition::Simulink::Subsystem currSubsystem1_a31= *itSubsystem1s_a30;
							SFC::Class class_a32= currSubsystem2_a2e.cls();
							if( !class_a32)
								continue;
							SFC::Class class_a33= currSubsystem1_a31.cls();
							if( !class_a33)
								continue;
							if( class_a32!= class_a33)
								continue;
							Match currMatch;
							set< pair<int, Udm::Object> > boundObjs_a37;
							if( !isValidBound(boundObjs_a37, class1_a0f, true))
								continue;
							currMatch.class1_a38= class1_a0f;
							if( !isValidBound(boundObjs_a37, class2_a18, true))
								continue;
							currMatch.class2_a39= class2_a18;
							if( !isValidBound(boundObjs_a37, localVar1_a21, true))
								continue;
							currMatch.localVar1_a3a= localVar1_a21;
							if( !isValidBound(boundObjs_a37, currStruct2_a28, false))
								continue;
							currMatch.struct2_a3b= currStruct2_a28;
							if( !isValidBound(boundObjs_a37, currLocalVar2_a2b, false))
								continue;
							currMatch.localVar2_a3c= currLocalVar2_a2b;
							if( !isValidBound(boundObjs_a37, class_a32, false))
								continue;
							currMatch.class_a3d= class_a32;
							if( !isValidBound(boundObjs_a37, currSubsystem1_a31, false))
								continue;
							currMatch.subsystem1_a3e= currSubsystem1_a31;
							if( !isValidBound(boundObjs_a37, currSubsystem2_a2e, false))
								continue;
							currMatch.subsystem2_a3f= currSubsystem2_a2e;
							bool Gz_guard= isGuardTrue( currMatch.class_a3d, currMatch.class1_a38, currMatch.class2_a39, currMatch.localVar1_a3a, currMatch.localVar2_a3c, currMatch.struct2_a3b, currMatch.subsystem1_a3e, currMatch.subsystem2_a3f);
							if( true== Gz_guard)
								_matches.push_back( currMatch);
						}
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void StructMemberMatch_9fb::outputAppender( const SFC::Class& class1_a48, const SFC::Class& class2_a4a, const SFC::LocalVar& localVar1_a4c)
{
	_class1_a05->push_back( class1_a48);
	_class2_a06->push_back( class2_a4a);
	_localVar1_a07->push_back( localVar1_a4c);
}

bool NoMemberMatch_a4e::operator()( const Packets_t& class1s_a4f, const Packets_t& class2s_a52, const Packets_t& localVar1s_a55, Packets_t& class1s_a51, Packets_t& class2s_a54, Packets_t& localVar1s_a57)
{
#ifdef PRINT_INFO
	printLog( "NoMemberMatch_a4e" );
#endif
	_class1_a58= &class1s_a51;
	_class2_a59= &class2s_a54;
	_localVar1_a5a= &localVar1s_a57;
	processInputPackets( class1s_a4f, class2s_a52, localVar1s_a55);
	if( false== _matches.empty())
		return true;
	return false;
}

bool NoMemberMatch_a4e::isInputUnique( const Udm::Object& class1_a5f, const Udm::Object& class2_a68, const Udm::Object& localVar1_a71)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass1_a61= _class1_a5b.begin(), itClass2_a6a= _class2_a64.begin(), itLocalVar1_a73= _localVar1_a6d.begin(); itClass1_a61!= _class1_a5b.end(), itClass2_a6a!= _class2_a64.end(), itLocalVar1_a73!= _localVar1_a6d.end(); ++itClass1_a61, ++itClass2_a6a, ++itLocalVar1_a73)
	{
		if( ( *itClass1_a61== class1_a5f)&& ( *itClass2_a6a== class2_a68)&& ( *itLocalVar1_a73== localVar1_a71))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_class1_a5b.push_back( class1_a5f);
		_class2_a64.push_back( class2_a68);
		_localVar1_a6d.push_back( localVar1_a71);
	}
	return isUnique;
}

bool NoMemberMatch_a4e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void NoMemberMatch_a4e::processInputPackets( const Packets_t& class1s_a4f, const Packets_t& class2s_a52, const Packets_t& localVar1s_a55)
{
	for( Packets_t::const_iterator itClass1_a5c= class1s_a4f.begin(), itClass2_a65= class2s_a52.begin(), itLocalVar1_a6e= localVar1s_a55.begin(); itClass1_a5c!= class1s_a4f.end(), itClass2_a65!= class2s_a52.end(), itLocalVar1_a6e!= localVar1s_a55.end(); ++itClass1_a5c, ++itClass2_a65, ++itLocalVar1_a6e)
	{
		bool isUnique= isInputUnique( *itClass1_a5c, *itClass2_a65, *itLocalVar1_a6e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass1_a5c, *itClass2_a65, *itLocalVar1_a6e);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.class1_a7d, currMatch.class2_a7e, currMatch.localVar1_a7f);
	}
}

bool NoMemberMatch_a4e::patternMatcher( const Udm::Object& class1_a5d, const Udm::Object& class2_a66, const Udm::Object& localVar1_a6f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class1_a5d.type(), SFC::Class::meta))
			continue;
		SFC::Class class1_a62= SFC::Class::Cast( class1_a5d);
		if( false== Uml::IsDerivedFrom( class2_a66.type(), SFC::Class::meta))
			continue;
		SFC::Class class2_a6b= SFC::Class::Cast( class2_a66);
		if( false== Uml::IsDerivedFrom( localVar1_a6f.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar1_a74= SFC::LocalVar::Cast( localVar1_a6f);
		set< SFC::Class> class2s_a76= class1_a62.equivdst();
		for( set< SFC::Class>::const_iterator itClass2s_a77= class2s_a76.begin(); itClass2s_a77!= class2s_a76.end(); ++itClass2s_a77)
		{
			SFC::Class currClass2_a78= *itClass2s_a77;
			if( class2_a6b!= currClass2_a78)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_a7c;
			if( !isValidBound(boundObjs_a7c, class1_a62, true))
				continue;
			currMatch.class1_a7d= class1_a62;
			if( !isValidBound(boundObjs_a7c, class2_a6b, true))
				continue;
			currMatch.class2_a7e= class2_a6b;
			if( !isValidBound(boundObjs_a7c, localVar1_a74, true))
				continue;
			currMatch.localVar1_a7f= localVar1_a74;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void NoMemberMatch_a4e::outputAppender( const SFC::Class& class1_a80, const SFC::Class& class2_a82, const SFC::LocalVar& localVar1_a84)
{
	_class1_a58->push_back( class1_a80);
	_class2_a59->push_back( class2_a82);
	_localVar1_a5a->push_back( localVar1_a84);
}

void GetMembers_a86::operator()( const Packets_t& class1s_a87, Packets_t& class1s_a89, Packets_t& class2s_a8a, Packets_t& localVar1s_a8b)
{
#ifdef PRINT_INFO
	printLog( "GetMembers_a86" );
#endif
	RTTGenerator::Instance()->generateRule(518, "GetMembers");
	_class1_a8c= &class1s_a89;
	_class2_a8d= &class2s_a8a;
	_localVar1_a8e= &localVar1s_a8b;
	processInputPackets( class1s_a87);
}

bool GetMembers_a86::isInputUnique( const Udm::Object& class1_a93)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass1_a95= _class1_a8f.begin(); itClass1_a95!= _class1_a8f.end(); ++itClass1_a95)
	{
		if( ( *itClass1_a95== class1_a93))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_class1_a8f.push_back( class1_a93);
	return isUnique;
}

bool GetMembers_a86::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetMembers_a86::processInputPackets( const Packets_t& class1s_a87)
{
	for( Packets_t::const_iterator itClass1_a90= class1s_a87.begin(); itClass1_a90!= class1s_a87.end(); ++itClass1_a90)
	{
		bool isUnique= isInputUnique( *itClass1_a90);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass1_a90);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetMembers_a86::patternMatcher( const Udm::Object& class1_a91)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class1_a91.type(), SFC::Class::meta))
			continue;
		SFC::Class class1_a96= SFC::Class::Cast( class1_a91);
		set< SFC::Struct> classStruct1s_a98= class1_a96.Struct_kind_children();
		for( set< SFC::Struct>::const_iterator itClassStruct1_a99= classStruct1s_a98.begin(); itClassStruct1_a99!= classStruct1s_a98.end(); ++itClassStruct1_a99)
		{
			SFC::Struct currClassStruct1_a9a= *itClassStruct1_a99;
			set< SFC::LocalVar> localVar1s_a9b= currClassStruct1_a9a.LocalVar_kind_children();
			for( set< SFC::LocalVar>::const_iterator itLocalVar1_a9c= localVar1s_a9b.begin(); itLocalVar1_a9c!= localVar1s_a9b.end(); ++itLocalVar1_a9c)
			{
				SFC::LocalVar currLocalVar1_a9d= *itLocalVar1_a9c;
				set< SFC::Class> class2s_a9e= class1_a96.equivdst();
				for( set< SFC::Class>::const_iterator itClass2s_a9f= class2s_a9e.begin(); itClass2s_a9f!= class2s_a9e.end(); ++itClass2s_a9f)
				{
					SFC::Class currClass2_aa0= *itClass2s_a9f;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_aa4;
					if( !isValidBound(boundObjs_aa4, class1_a96, true))
						continue;
					currMatch.class1_aa5= class1_a96;
					if( !isValidBound(boundObjs_aa4, currClass2_aa0, false))
						continue;
					currMatch.class2_aa6= currClass2_aa0;
					if( !isValidBound(boundObjs_aa4, currLocalVar1_a9d, false))
						continue;
					currMatch.localVar1_aa7= currLocalVar1_a9d;
					if( !isValidBound(boundObjs_aa4, currClassStruct1_a9a, false))
						continue;
					currMatch.classStruct1_aa8= currClassStruct1_a9a;
					_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void GetMembers_a86::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.class1_aa5, currMatch.class2_aa6, currMatch.localVar1_aa7);
	}
}

void GetMembers_a86::outputAppender( const SFC::Class& class1_aa9, const SFC::Class& class2_aab, const SFC::LocalVar& localVar1_aad)
{
	_class1_a8c->push_back( class1_aa9);
	_class2_a8d->push_back( class2_aab);
	_localVar1_a8e->push_back( localVar1_aad);
}

void CheckMethods_ab9::operator()( const Packets_t& classs_aba, Packets_t& classs_abc)
{
#ifdef PRINT_INFO
	printLog( "CheckMethods_ab9" );
#endif
	_class_abd= &classs_abc;
	_class_abd->insert( _class_abd->end(), classs_aba.begin(), classs_aba.end());
	if( ( !classs_aba.empty()))
		callGetMainFunctionArgs_bc0( classs_aba);
}

void CheckMethods_ab9::callGetMainFunctionArgs_bc0( const Packets_t& class1s_abf)
{
	Packets_t class1s_ac1;
	Packets_t class2s_ac2;
	Packets_t args_ac3;
	GetMainFunctionArgs_abe getMainFunctionArgs_abe;
	getMainFunctionArgs_abe( class1s_abf, class1s_ac1, class2s_ac2, args_ac3);
	if( ( !class1s_ac1.empty())&& ( !class2s_ac2.empty())&& ( !args_ac3.empty()))
		callTestArgs_bc2( class1s_ac1, class2s_ac2, args_ac3);
}

void CheckMethods_ab9::callTestArgs_bc2( const Packets_t& class1s_b18, const Packets_t& class2s_b1a, const Packets_t& args_b1c)
{
	Packets_t class1s_b1e;
	Packets_t class2s_b1f;
	Packets_t args_b20;
	Packets_t class1s_b21;
	Packets_t class2s_b22;
	Packets_t args_b23;
	TestArgs_b17 testArgs_b17;
	testArgs_b17( class1s_b18, class2s_b1a, args_b1c, class1s_b1e, class2s_b1f, args_b20, class1s_b21, class2s_b22, args_b23);
	if( ( !class1s_b21.empty())&& ( !class2s_b22.empty())&& ( !args_b23.empty()))
		callBreakEquivalence_bc6( class1s_b21, class2s_b22, args_b23);
}

void CheckMethods_ab9::callBreakEquivalence_bc6( const Packets_t& class1s_aec, const Packets_t& class2s_aee, const Packets_t& args_af0)
{
	BreakEquivalence_aeb breakEquivalence_aeb;
	breakEquivalence_aeb( class1s_aec, class2s_aee, args_af0);
}

void GetMainFunctionArgs_abe::operator()( const Packets_t& class1s_abf, Packets_t& class1s_ac1, Packets_t& class2s_ac2, Packets_t& args_ac3)
{
#ifdef PRINT_INFO
	printLog( "GetMainFunctionArgs_abe" );
#endif
	RTTGenerator::Instance()->generateRule(529, "GetMainFunctionArgs");
	_class1_ac4= &class1s_ac1;
	_class2_ac5= &class2s_ac2;
	_arg_ac6= &args_ac3;
	processInputPackets( class1s_abf);
}

bool GetMainFunctionArgs_abe::isInputUnique( const Udm::Object& class1_acb)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass1_acd= _class1_ac7.begin(); itClass1_acd!= _class1_ac7.end(); ++itClass1_acd)
	{
		if( ( *itClass1_acd== class1_acb))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_class1_ac7.push_back( class1_acb);
	return isUnique;
}

bool GetMainFunctionArgs_abe::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool GetMainFunctionArgs_abe::isGuardTrue( SFC::Arg& Arg, SFC::Class& Class1, SFC::Class& Class2, SFC::Function& MainFunction1)
{
	bool Gz_guard= false;
	std::string functionName = MainFunction1.name();
return
 functionName.substr( functionName.size() - 5 ) == "_main" &&
 static_cast< __int64 >( Arg.argIndex() ) != 0
;;
	return Gz_guard;
}

void GetMainFunctionArgs_abe::processInputPackets( const Packets_t& class1s_abf)
{
	for( Packets_t::const_iterator itClass1_ac8= class1s_abf.begin(); itClass1_ac8!= class1s_abf.end(); ++itClass1_ac8)
	{
		bool isUnique= isInputUnique( *itClass1_ac8);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass1_ac8);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetMainFunctionArgs_abe::patternMatcher( const Udm::Object& class1_ac9)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class1_ac9.type(), SFC::Class::meta))
			continue;
		SFC::Class class1_ace= SFC::Class::Cast( class1_ac9);
		set< SFC::Function> mainFunction1s_ad0= class1_ace.Function_kind_children();
		for( set< SFC::Function>::const_iterator itMainFunction1_ad1= mainFunction1s_ad0.begin(); itMainFunction1_ad1!= mainFunction1s_ad0.end(); ++itMainFunction1_ad1)
		{
			SFC::Function currMainFunction1_ad2= *itMainFunction1_ad1;
			set< SFC::Arg> args_ad3= currMainFunction1_ad2.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itArg_ad4= args_ad3.begin(); itArg_ad4!= args_ad3.end(); ++itArg_ad4)
			{
				SFC::Arg currArg_ad5= *itArg_ad4;
				set< SFC::Class> class2s_ad6= class1_ace.equivdst();
				for( set< SFC::Class>::const_iterator itClass2s_ad7= class2s_ad6.begin(); itClass2s_ad7!= class2s_ad6.end(); ++itClass2s_ad7)
				{
					SFC::Class currClass2_ad8= *itClass2s_ad7;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_adc;
					if( !isValidBound(boundObjs_adc, class1_ace, true))
						continue;
					currMatch.class1_add= class1_ace;
					if( !isValidBound(boundObjs_adc, currClass2_ad8, false))
						continue;
					currMatch.class2_ade= currClass2_ad8;
					if( !isValidBound(boundObjs_adc, currArg_ad5, false))
						continue;
					currMatch.arg_adf= currArg_ad5;
					if( !isValidBound(boundObjs_adc, currMainFunction1_ad2, false))
						continue;
					currMatch.mainFunction1_ae0= currMainFunction1_ad2;
					bool Gz_guard= isGuardTrue( currMatch.arg_adf, currMatch.class1_add, currMatch.class2_ade, currMatch.mainFunction1_ae0);
					if( true== Gz_guard)
						_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void GetMainFunctionArgs_abe::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.class1_add, currMatch.class2_ade, currMatch.arg_adf);
	}
}

void GetMainFunctionArgs_abe::outputAppender( const SFC::Class& class1_ae5, const SFC::Class& class2_ae7, const SFC::Arg& arg_ae9)
{
	_class1_ac4->push_back( class1_ae5);
	_class2_ac5->push_back( class2_ae7);
	_arg_ac6->push_back( arg_ae9);
}

void BreakEquivalence_aeb::operator()( const Packets_t& class1s_aec, const Packets_t& class2s_aee, const Packets_t& args_af0)
{
#ifdef PRINT_INFO
	printLog( "BreakEquivalence_aeb" );
#endif
	RTTGenerator::Instance()->generateRule(537, "BreakEquivalence");
	processInputPackets( class1s_aec, class2s_aee, args_af0);
}

bool BreakEquivalence_aeb::isInputUnique( const Udm::Object& class1_af6, const Udm::Object& class2_aff, const Udm::Object& arg_b08)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass1_af8= _class1_af2.begin(), itClass2_b01= _class2_afb.begin(), itArg_b0a= _arg_b04.begin(); itClass1_af8!= _class1_af2.end(), itClass2_b01!= _class2_afb.end(), itArg_b0a!= _arg_b04.end(); ++itClass1_af8, ++itClass2_b01, ++itArg_b0a)
	{
		if( ( *itClass1_af8== class1_af6)&& ( *itClass2_b01== class2_aff)&& ( *itArg_b0a== arg_b08))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_class1_af2.push_back( class1_af6);
		_class2_afb.push_back( class2_aff);
		_arg_b04.push_back( arg_b08);
	}
	return isUnique;
}

bool BreakEquivalence_aeb::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void BreakEquivalence_aeb::processInputPackets( const Packets_t& class1s_aec, const Packets_t& class2s_aee, const Packets_t& args_af0)
{
	for( Packets_t::const_iterator itClass1_af3= class1s_aec.begin(), itClass2_afc= class2s_aee.begin(), itArg_b05= args_af0.begin(); itClass1_af3!= class1s_aec.end(), itClass2_afc!= class2s_aee.end(), itArg_b05!= args_af0.end(); ++itClass1_af3, ++itClass2_afc, ++itArg_b05)
	{
		bool isUnique= isInputUnique( *itClass1_af3, *itClass2_afc, *itArg_b05);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass1_af3, *itClass2_afc, *itArg_b05);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool BreakEquivalence_aeb::patternMatcher( const Udm::Object& class1_af4, const Udm::Object& class2_afd, const Udm::Object& arg_b06)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class1_af4.type(), SFC::Class::meta))
			continue;
		SFC::Class class1_af9= SFC::Class::Cast( class1_af4);
		if( false== Uml::IsDerivedFrom( class2_afd.type(), SFC::Class::meta))
			continue;
		SFC::Class class2_b02= SFC::Class::Cast( class2_afd);
		if( false== Uml::IsDerivedFrom( arg_b06.type(), SFC::Arg::meta))
			continue;
		SFC::Arg arg_b0b= SFC::Arg::Cast( arg_b06);
		set< SFC::Class> class2s_b0d= class1_af9.equivdst();
		for( set< SFC::Class>::const_iterator itClass2s_b0e= class2s_b0d.begin(); itClass2s_b0e!= class2s_b0d.end(); ++itClass2s_b0e)
		{
			SFC::Class currClass2_b0f= *itClass2s_b0e;
			if( class2_b02!= currClass2_b0f)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_b13;
			if( !isValidBound(boundObjs_b13, class1_af9, true))
				continue;
			currMatch.class1_b14= class1_af9;
			if( !isValidBound(boundObjs_b13, class2_b02, true))
				continue;
			currMatch.class2_b15= class2_b02;
			if( !isValidBound(boundObjs_b13, arg_b0b, true))
				continue;
			currMatch.arg_b16= arg_b0b;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void BreakEquivalence_aeb::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		currMatch.class1_b14.equivdst()-= currMatch.class2_b15;
	}
}

void TestArgs_b17::operator()( const Packets_t& class1s_b18, const Packets_t& class2s_b1a, const Packets_t& args_b1c, Packets_t& class1s_b1e, Packets_t& class2s_b1f, Packets_t& args_b20, Packets_t& class1s_b21, Packets_t& class2s_b22, Packets_t& args_b23)
{
#ifdef PRINT_INFO
	printLog( "TestArgs_b17" );
#endif
	_class1_b24= &class1s_b1e;
	_class2_b25= &class2s_b1f;
	_arg_b26= &args_b20;
	_class1_b27= &class1s_b21;
	_class2_b28= &class2s_b22;
	_arg_b29= &args_b23;
	for( Packets_t::const_iterator itclass1_b2b= class1s_b18.begin(), itclass2_b32= class2s_b1a.begin(), itarg_b39= args_b1c.begin(); itclass1_b2b!= class1s_b18.end(), itclass2_b32!= class2s_b1a.end(), itarg_b39!= args_b1c.end(); ++itclass1_b2b, ++itclass2_b32, ++itarg_b39)
	{
		bool isUnique= isInputUnique( *itclass1_b2b, *itclass2_b32, *itarg_b39);
		if( !isUnique)
			continue;
		Packets_t oneclass1_b2f( 1, *itclass1_b2b);
		Packets_t oneclass2_b36( 1, *itclass2_b32);
		Packets_t onearg_b3d( 1, *itarg_b39);
		executeOne( oneclass1_b2f, oneclass2_b36, onearg_b3d);
	}
}

void TestArgs_b17::executeOne( const Packets_t& class1s_b18, const Packets_t& class2s_b1a, const Packets_t& args_b1c)
{
	Packets_t class1s_b42;
	Packets_t class2s_b45;
	Packets_t arg1s_b48;
	ArgsMatch_b3f argsMatch_b3f;
	bool isMatchArgsMatch_b3f= argsMatch_b3f( class1s_b18, class2s_b1a, args_b1c, class1s_b42, class2s_b45, arg1s_b48);
	_class1_b24->insert( _class1_b24->end(), class1s_b42.begin(), class1s_b42.end());
	_class2_b25->insert( _class2_b25->end(), class2s_b45.begin(), class2s_b45.end());
	_arg_b26->insert( _arg_b26->end(), arg1s_b48.begin(), arg1s_b48.end());
	if( isMatchArgsMatch_b3f)
		return;
	Packets_t class1s_b8b;
	Packets_t class2s_b8e;
	Packets_t arg1s_b91;
	NoArgMatch_b88 noArgMatch_b88;
	bool isMatchNoArgMatch_b88= noArgMatch_b88( class1s_b18, class2s_b1a, args_b1c, class1s_b8b, class2s_b8e, arg1s_b91);
	_class1_b27->insert( _class1_b27->end(), class1s_b8b.begin(), class1s_b8b.end());
	_class2_b28->insert( _class2_b28->end(), class2s_b8e.begin(), class2s_b8e.end());
	_arg_b29->insert( _arg_b29->end(), arg1s_b91.begin(), arg1s_b91.end());
	if( isMatchNoArgMatch_b88)
		return;
}

bool TestArgs_b17::isInputUnique( const Udm::Object& class1_b2c, const Udm::Object& class2_b33, const Udm::Object& arg_b3a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itclass1_b2e= _class1_b2a.begin(), itclass2_b35= _class2_b31.begin(), itarg_b3c= _arg_b38.begin(); itclass1_b2e!= _class1_b2a.end(), itclass2_b35!= _class2_b31.end(), itarg_b3c!= _arg_b38.end(); ++itclass1_b2e, ++itclass2_b35, ++itarg_b3c)
	{
		if( ( *itclass1_b2e== class1_b2c)&& ( *itclass2_b35== class2_b33)&& ( *itarg_b3c== arg_b3a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_class1_b2a.push_back( class1_b2c);
		_class2_b31.push_back( class2_b33);
		_arg_b38.push_back( arg_b3a);
	}
	return isUnique;
}

bool ArgsMatch_b3f::operator()( const Packets_t& class1s_b40, const Packets_t& class2s_b43, const Packets_t& arg1s_b46, Packets_t& class1s_b42, Packets_t& class2s_b45, Packets_t& arg1s_b48)
{
#ifdef PRINT_INFO
	printLog( "ArgsMatch_b3f" );
#endif
	_class1_b49= &class1s_b42;
	_class2_b4a= &class2s_b45;
	_arg1_b4b= &arg1s_b48;
	processInputPackets( class1s_b40, class2s_b43, arg1s_b46);
	if( false== _matches.empty())
		return true;
	return false;
}

bool ArgsMatch_b3f::isInputUnique( const Udm::Object& class1_b50, const Udm::Object& class2_b59, const Udm::Object& arg1_b62)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass1_b52= _class1_b4c.begin(), itClass2_b5b= _class2_b55.begin(), itArg1_b64= _arg1_b5e.begin(); itClass1_b52!= _class1_b4c.end(), itClass2_b5b!= _class2_b55.end(), itArg1_b64!= _arg1_b5e.end(); ++itClass1_b52, ++itClass2_b5b, ++itArg1_b64)
	{
		if( ( *itClass1_b52== class1_b50)&& ( *itClass2_b5b== class2_b59)&& ( *itArg1_b64== arg1_b62))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_class1_b4c.push_back( class1_b50);
		_class2_b55.push_back( class2_b59);
		_arg1_b5e.push_back( arg1_b62);
	}
	return isUnique;
}

bool ArgsMatch_b3f::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool ArgsMatch_b3f::isGuardTrue( SFC::Arg& Arg1, SFC::Arg& Arg2, SFC::Class& Class1, SFC::Class& Class2, SFC::DT& DT, SFC::Function& MainFunction2)
{
	bool Gz_guard= false;
	std::string functionName = MainFunction2.name();

return
 functionName.substr( functionName.size() - 5 ) == "_main" &&
 Arg1.ptr() == Arg2.ptr() &&
 Arg1.argIndex() == Arg2.argIndex()
;;
	return Gz_guard;
}

void ArgsMatch_b3f::processInputPackets( const Packets_t& class1s_b40, const Packets_t& class2s_b43, const Packets_t& arg1s_b46)
{
	for( Packets_t::const_iterator itClass1_b4d= class1s_b40.begin(), itClass2_b56= class2s_b43.begin(), itArg1_b5f= arg1s_b46.begin(); itClass1_b4d!= class1s_b40.end(), itClass2_b56!= class2s_b43.end(), itArg1_b5f!= arg1s_b46.end(); ++itClass1_b4d, ++itClass2_b56, ++itArg1_b5f)
	{
		bool isUnique= isInputUnique( *itClass1_b4d, *itClass2_b56, *itArg1_b5f);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass1_b4d, *itClass2_b56, *itArg1_b5f);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.class1_b76, currMatch.class2_b77, currMatch.arg1_b78);
	}
}

bool ArgsMatch_b3f::patternMatcher( const Udm::Object& class1_b4e, const Udm::Object& class2_b57, const Udm::Object& arg1_b60)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class1_b4e.type(), SFC::Class::meta))
			continue;
		SFC::Class class1_b53= SFC::Class::Cast( class1_b4e);
		if( false== Uml::IsDerivedFrom( class2_b57.type(), SFC::Class::meta))
			continue;
		SFC::Class class2_b5c= SFC::Class::Cast( class2_b57);
		if( false== Uml::IsDerivedFrom( arg1_b60.type(), SFC::Arg::meta))
			continue;
		SFC::Arg arg1_b65= SFC::Arg::Cast( arg1_b60);
		set< SFC::Class> class2s_b67= class1_b53.equivdst();
		for( set< SFC::Class>::const_iterator itClass2s_b68= class2s_b67.begin(); itClass2s_b68!= class2s_b67.end(); ++itClass2s_b68)
		{
			SFC::Class currClass2_b69= *itClass2s_b68;
			if( class2_b5c!= currClass2_b69)
				continue;
			set< SFC::Function> mainFunction2s_b6a= class2_b5c.Function_kind_children();
			for( set< SFC::Function>::const_iterator itMainFunction2_b6b= mainFunction2s_b6a.begin(); itMainFunction2_b6b!= mainFunction2s_b6a.end(); ++itMainFunction2_b6b)
			{
				SFC::Function currMainFunction2_b6c= *itMainFunction2_b6b;
				set< SFC::Arg> arg2s_b6d= currMainFunction2_b6c.Arg_kind_children();
				for( set< SFC::Arg>::const_iterator itArg2_b6e= arg2s_b6d.begin(); itArg2_b6e!= arg2s_b6d.end(); ++itArg2_b6e)
				{
					SFC::Arg currArg2_b6f= *itArg2_b6e;
					SFC::DT dT_b70= arg1_b65.dt();
					if( !dT_b70)
						continue;
					SFC::DT dT_b71= currArg2_b6f.dt();
					if( !dT_b71)
						continue;
					if( dT_b70!= dT_b71)
						continue;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_b75;
					if( !isValidBound(boundObjs_b75, class1_b53, true))
						continue;
					currMatch.class1_b76= class1_b53;
					if( !isValidBound(boundObjs_b75, class2_b5c, true))
						continue;
					currMatch.class2_b77= class2_b5c;
					if( !isValidBound(boundObjs_b75, arg1_b65, true))
						continue;
					currMatch.arg1_b78= arg1_b65;
					if( !isValidBound(boundObjs_b75, currArg2_b6f, false))
						continue;
					currMatch.arg2_b79= currArg2_b6f;
					if( !isValidBound(boundObjs_b75, currMainFunction2_b6c, false))
						continue;
					currMatch.mainFunction2_b7a= currMainFunction2_b6c;
					if( !isValidBound(boundObjs_b75, dT_b70, false))
						continue;
					currMatch.dT_b7b= dT_b70;
					bool Gz_guard= isGuardTrue( currMatch.arg1_b78, currMatch.arg2_b79, currMatch.class1_b76, currMatch.class2_b77, currMatch.dT_b7b, currMatch.mainFunction2_b7a);
					if( true== Gz_guard)
						_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void ArgsMatch_b3f::outputAppender( const SFC::Class& class1_b82, const SFC::Class& class2_b84, const SFC::Arg& arg1_b86)
{
	_class1_b49->push_back( class1_b82);
	_class2_b4a->push_back( class2_b84);
	_arg1_b4b->push_back( arg1_b86);
}

bool NoArgMatch_b88::operator()( const Packets_t& class1s_b89, const Packets_t& class2s_b8c, const Packets_t& arg1s_b8f, Packets_t& class1s_b8b, Packets_t& class2s_b8e, Packets_t& arg1s_b91)
{
#ifdef PRINT_INFO
	printLog( "NoArgMatch_b88" );
#endif
	_class1_b92= &class1s_b8b;
	_class2_b93= &class2s_b8e;
	_arg1_b94= &arg1s_b91;
	processInputPackets( class1s_b89, class2s_b8c, arg1s_b8f);
	if( false== _matches.empty())
		return true;
	return false;
}

bool NoArgMatch_b88::isInputUnique( const Udm::Object& class1_b99, const Udm::Object& class2_ba2, const Udm::Object& arg1_bab)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass1_b9b= _class1_b95.begin(), itClass2_ba4= _class2_b9e.begin(), itArg1_bad= _arg1_ba7.begin(); itClass1_b9b!= _class1_b95.end(), itClass2_ba4!= _class2_b9e.end(), itArg1_bad!= _arg1_ba7.end(); ++itClass1_b9b, ++itClass2_ba4, ++itArg1_bad)
	{
		if( ( *itClass1_b9b== class1_b99)&& ( *itClass2_ba4== class2_ba2)&& ( *itArg1_bad== arg1_bab))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_class1_b95.push_back( class1_b99);
		_class2_b9e.push_back( class2_ba2);
		_arg1_ba7.push_back( arg1_bab);
	}
	return isUnique;
}

bool NoArgMatch_b88::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void NoArgMatch_b88::processInputPackets( const Packets_t& class1s_b89, const Packets_t& class2s_b8c, const Packets_t& arg1s_b8f)
{
	for( Packets_t::const_iterator itClass1_b96= class1s_b89.begin(), itClass2_b9f= class2s_b8c.begin(), itArg1_ba8= arg1s_b8f.begin(); itClass1_b96!= class1s_b89.end(), itClass2_b9f!= class2s_b8c.end(), itArg1_ba8!= arg1s_b8f.end(); ++itClass1_b96, ++itClass2_b9f, ++itArg1_ba8)
	{
		bool isUnique= isInputUnique( *itClass1_b96, *itClass2_b9f, *itArg1_ba8);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass1_b96, *itClass2_b9f, *itArg1_ba8);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.class1_bb7, currMatch.class2_bb8, currMatch.arg1_bb9);
	}
}

bool NoArgMatch_b88::patternMatcher( const Udm::Object& class1_b97, const Udm::Object& class2_ba0, const Udm::Object& arg1_ba9)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class1_b97.type(), SFC::Class::meta))
			continue;
		SFC::Class class1_b9c= SFC::Class::Cast( class1_b97);
		if( false== Uml::IsDerivedFrom( class2_ba0.type(), SFC::Class::meta))
			continue;
		SFC::Class class2_ba5= SFC::Class::Cast( class2_ba0);
		if( false== Uml::IsDerivedFrom( arg1_ba9.type(), SFC::Arg::meta))
			continue;
		SFC::Arg arg1_bae= SFC::Arg::Cast( arg1_ba9);
		set< SFC::Class> class2s_bb0= class1_b9c.equivdst();
		for( set< SFC::Class>::const_iterator itClass2s_bb1= class2s_bb0.begin(); itClass2s_bb1!= class2s_bb0.end(); ++itClass2s_bb1)
		{
			SFC::Class currClass2_bb2= *itClass2s_bb1;
			if( class2_ba5!= currClass2_bb2)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_bb6;
			if( !isValidBound(boundObjs_bb6, class1_b9c, true))
				continue;
			currMatch.class1_bb7= class1_b9c;
			if( !isValidBound(boundObjs_bb6, class2_ba5, true))
				continue;
			currMatch.class2_bb8= class2_ba5;
			if( !isValidBound(boundObjs_bb6, arg1_bae, true))
				continue;
			currMatch.arg1_bb9= arg1_bae;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void NoArgMatch_b88::outputAppender( const SFC::Class& class1_bba, const SFC::Class& class2_bbc, const SFC::Arg& arg1_bbe)
{
	_class1_b92->push_back( class1_bba);
	_class2_b93->push_back( class2_bbc);
	_arg1_b94->push_back( arg1_bbe);
}

void GetNextLevelClasses_bd2::operator()( const Packets_t& childClasss_bd3, Packets_t& parentClasss_bd5)
{
#ifdef PRINT_INFO
	printLog( "GetNextLevelClasses_bd2" );
#endif
	RTTGenerator::Instance()->generateRule(569, "GetNextLevelClasses");
	_parentClass_bd6= &parentClasss_bd5;
	processInputPackets( childClasss_bd3);
}

bool GetNextLevelClasses_bd2::isInputUnique( const Udm::Object& childClass_bdb)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itChildClass_bdd= _childClass_bd7.begin(); itChildClass_bdd!= _childClass_bd7.end(); ++itChildClass_bdd)
	{
		if( ( *itChildClass_bdd== childClass_bdb))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_childClass_bd7.push_back( childClass_bdb);
	return isUnique;
}

bool GetNextLevelClasses_bd2::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetNextLevelClasses_bd2::processInputPackets( const Packets_t& childClasss_bd3)
{
	for( Packets_t::const_iterator itChildClass_bd8= childClasss_bd3.begin(); itChildClass_bd8!= childClasss_bd3.end(); ++itChildClass_bd8)
	{
		bool isUnique= isInputUnique( *itChildClass_bd8);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itChildClass_bd8);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetNextLevelClasses_bd2::patternMatcher( const Udm::Object& childClass_bd9)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( childClass_bd9.type(), SFC::Class::meta))
			continue;
		SFC::Class childClass_bde= SFC::Class::Cast( childClass_bd9);
		set< SFC::Struct> childStructs_be0= childClass_bde.Struct_kind_children();
		for( set< SFC::Struct>::const_iterator itChildStruct_be1= childStructs_be0.begin(); itChildStruct_be1!= childStructs_be0.end(); ++itChildStruct_be1)
		{
			SFC::Struct currChildStruct_be2= *itChildStruct_be1;
			set< SFC::TypedEntity> members_be3= currChildStruct_be2.te();
			for( set< SFC::TypedEntity>::const_iterator itMembers_be4= members_be3.begin(); itMembers_be4!= members_be3.end(); ++itMembers_be4)
			{
				if( false== Uml::IsDerivedFrom( (*itMembers_be4).type(), SFC::LocalVar::meta))
					continue;
				SFC::LocalVar currMember_be5= SFC::LocalVar::Cast( *itMembers_be4);
				Udm::Object memberParent_be6= currMember_be5.container();
				if( false== Uml::IsDerivedFrom( memberParent_be6.type(), SFC::Struct::meta))
					continue;
				SFC::Struct parentStructMember_be7= SFC::Struct::Cast( memberParent_be6);
				Udm::Object parentStructParent_be8= parentStructMember_be7.container();
				if( false== Uml::IsDerivedFrom( parentStructParent_be8.type(), SFC::Class::meta))
					continue;
				SFC::Class parentClassParentStruct_be9= SFC::Class::Cast( parentStructParent_be8);
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_bed;
				if( !isValidBound(boundObjs_bed, childClass_bde, true))
					continue;
				currMatch.childClass_bee= childClass_bde;
				if( !isValidBound(boundObjs_bed, parentClassParentStruct_be9, false))
					continue;
				currMatch.parentClass_bef= parentClassParentStruct_be9;
				if( !isValidBound(boundObjs_bed, currMember_be5, false))
					continue;
				currMatch.member_bf0= currMember_be5;
				if( !isValidBound(boundObjs_bed, currChildStruct_be2, false))
					continue;
				currMatch.childStruct_bf1= currChildStruct_be2;
				if( !isValidBound(boundObjs_bed, parentStructMember_be7, false))
					continue;
				currMatch.parentStruct_bf2= parentStructMember_be7;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetNextLevelClasses_bd2::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.parentClass_bef);
	}
}

void GetNextLevelClasses_bd2::outputAppender( const SFC::Class& parentClass_bf3)
{
	_parentClass_bd6->push_back( parentClass_bf3);
}

void ClassFilter_bf5::operator()( const Packets_t& classs_bf6, Packets_t& classs_bf8)
{
#ifdef PRINT_INFO
	printLog( "ClassFilter_bf5" );
#endif
	_class_bf9= &classs_bf8;
	if( ( !classs_bf6.empty()))
		callSimpleStructFilter_c85( classs_bf6);
}

void ClassFilter_bf5::callSimpleStructFilter_c85( const Packets_t& classs_bfb)
{
	Packets_t classs_bfd;
	Packets_t classs_bfe;
	Packets_t classs_bff;
	Packets_t classs_c00;
	SimpleStructFilter_bfa simpleStructFilter_bfa;
	simpleStructFilter_bfa( classs_bfb, classs_bfd, classs_bfe, classs_bff, classs_c00);
	_class_bf9->insert( _class_bf9->end(), classs_c00.begin(), classs_c00.end());
}

void SimpleStructFilter_bfa::operator()( const Packets_t& classs_bfb, Packets_t& classs_bfd, Packets_t& classs_bfe, Packets_t& classs_bff, Packets_t& classs_c00)
{
#ifdef PRINT_INFO
	printLog( "SimpleStructFilter_bfa" );
#endif
	_class_c01= &classs_bfd;
	_class_c02= &classs_bfe;
	_class_c03= &classs_bff;
	_class_c04= &classs_c00;
	for( Packets_t::const_iterator itclass_c06= classs_bfb.begin(); itclass_c06!= classs_bfb.end(); ++itclass_c06)
	{
		bool isUnique= isInputUnique( *itclass_c06);
		if( !isUnique)
			continue;
		Packets_t oneclass_c0a( 1, *itclass_c06);
		executeOne( oneclass_c0a);
	}
}

void SimpleStructFilter_bfa::executeOne( const Packets_t& classs_bfb)
{
	Packets_t classs_c0f;
	Marked_c0c marked_c0c;
	bool isMatchMarked_c0c= marked_c0c( classs_bfb, classs_c0f);
	_class_c01->insert( _class_c01->end(), classs_c0f.begin(), classs_c0f.end());
	Packets_t classs_c25;
	ComplexStruct1_c22 complexStruct1_c22;
	bool isMatchComplexStruct1_c22= complexStruct1_c22( classs_bfb, classs_c25);
	_class_c02->insert( _class_c02->end(), classs_c25.begin(), classs_c25.end());
	if( isMatchComplexStruct1_c22)
		return;
	Packets_t classs_c4c;
	ComplexStruct2_c49 complexStruct2_c49;
	bool isMatchComplexStruct2_c49= complexStruct2_c49( classs_bfb, classs_c4c);
	_class_c03->insert( _class_c03->end(), classs_c4c.begin(), classs_c4c.end());
	if( isMatchComplexStruct2_c49)
		return;
	Packets_t classs_c73;
	SimpleStruct_c70 simpleStruct_c70;
	bool isMatchSimpleStruct_c70= simpleStruct_c70( classs_bfb, classs_c73);
	_class_c04->insert( _class_c04->end(), classs_c73.begin(), classs_c73.end());
	if( isMatchSimpleStruct_c70)
		return;
}

bool SimpleStructFilter_bfa::isInputUnique( const Udm::Object& class_c07)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itclass_c09= _class_c05.begin(); itclass_c09!= _class_c05.end(); ++itclass_c09)
	{
		if( ( *itclass_c09== class_c07))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_class_c05.push_back( class_c07);
	return isUnique;
}

bool Marked_c0c::operator()( const Packets_t& classs_c0d, Packets_t& classs_c0f)
{
#ifdef PRINT_INFO
	printLog( "Marked_c0c" );
#endif
	_class_c10= &classs_c0f;
	processInputPackets( classs_c0d);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Marked_c0c::isInputUnique( const Udm::Object& class_c15)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass_c17= _class_c11.begin(); itClass_c17!= _class_c11.end(); ++itClass_c17)
	{
		if( ( *itClass_c17== class_c15))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_class_c11.push_back( class_c15);
	return isUnique;
}

bool Marked_c0c::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool Marked_c0c::isGuardTrue( SFC::Class& Class)
{
	bool Gz_guard= false;
	return Class.statementCount() < 0;;
	return Gz_guard;
}

void Marked_c0c::processInputPackets( const Packets_t& classs_c0d)
{
	for( Packets_t::const_iterator itClass_c12= classs_c0d.begin(); itClass_c12!= classs_c0d.end(); ++itClass_c12)
	{
		bool isUnique= isInputUnique( *itClass_c12);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass_c12);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.class_c1e);
	}
}

bool Marked_c0c::patternMatcher( const Udm::Object& class_c13)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class_c13.type(), SFC::Class::meta))
			continue;
		SFC::Class class_c18= SFC::Class::Cast( class_c13);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_c1d;
		if( !isValidBound(boundObjs_c1d, class_c18, true))
			continue;
		currMatch.class_c1e= class_c18;
		bool Gz_guard= isGuardTrue( currMatch.class_c1e);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Marked_c0c::outputAppender( const SFC::Class& class_c20)
{
	_class_c10->push_back( class_c20);
}

bool ComplexStruct1_c22::operator()( const Packets_t& classs_c23, Packets_t& classs_c25)
{
#ifdef PRINT_INFO
	printLog( "ComplexStruct1_c22" );
#endif
	_class_c26= &classs_c25;
	processInputPackets( classs_c23);
	if( false== _matches.empty())
		return true;
	return false;
}

bool ComplexStruct1_c22::isInputUnique( const Udm::Object& class_c2b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass_c2d= _class_c27.begin(); itClass_c2d!= _class_c27.end(); ++itClass_c2d)
	{
		if( ( *itClass_c2d== class_c2b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_class_c27.push_back( class_c2b);
	return isUnique;
}

bool ComplexStruct1_c22::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void ComplexStruct1_c22::processInputPackets( const Packets_t& classs_c23)
{
	for( Packets_t::const_iterator itClass_c28= classs_c23.begin(); itClass_c28!= classs_c23.end(); ++itClass_c28)
	{
		bool isUnique= isInputUnique( *itClass_c28);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass_c28);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.class_c41);
	}
}

bool ComplexStruct1_c22::patternMatcher( const Udm::Object& class_c29)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class_c29.type(), SFC::Class::meta))
			continue;
		SFC::Class class_c2e= SFC::Class::Cast( class_c29);
		set< SFC::Struct> parentStructs_c30= class_c2e.Struct_kind_children();
		for( set< SFC::Struct>::const_iterator itParentStruct_c31= parentStructs_c30.begin(); itParentStruct_c31!= parentStructs_c30.end(); ++itParentStruct_c31)
		{
			SFC::Struct currParentStruct_c32= *itParentStruct_c31;
			set< SFC::LocalVar> localVars_c33= currParentStruct_c32.LocalVar_kind_children();
			for( set< SFC::LocalVar>::const_iterator itLocalVar_c34= localVars_c33.begin(); itLocalVar_c34!= localVars_c33.end(); ++itLocalVar_c34)
			{
				SFC::LocalVar currLocalVar_c35= *itLocalVar_c34;
				SFC::DT childStruct_c36= currLocalVar_c35.dt();
				if(!childStruct_c36 || false== Uml::IsDerivedFrom( childStruct_c36.type(), SFC::Struct::meta))
					continue;
				SFC::Struct childStruct_c37= SFC::Struct::Cast( childStruct_c36);
				if( !childStruct_c37)
					continue;
				Udm::Object childStructParent_c38= childStruct_c37.container();
				if( false== Uml::IsDerivedFrom( childStructParent_c38.type(), SFC::Class::meta))
					continue;
				SFC::Class childClassChildStruct_c39= SFC::Class::Cast( childStructParent_c38);
				set< SFC::Class> equivClasss_c3a= childClassChildStruct_c39.equivdst();
				for( set< SFC::Class>::const_iterator itEquivClasss_c3b= equivClasss_c3a.begin(); itEquivClasss_c3b!= equivClasss_c3a.end(); ++itEquivClasss_c3b)
				{
					SFC::Class currEquivClass_c3c= *itEquivClasss_c3b;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_c40;
					if( !isValidBound(boundObjs_c40, class_c2e, true))
						continue;
					currMatch.class_c41= class_c2e;
					if( !isValidBound(boundObjs_c40, childClassChildStruct_c39, false))
						continue;
					currMatch.childClass_c42= childClassChildStruct_c39;
					if( !isValidBound(boundObjs_c40, currEquivClass_c3c, false))
						continue;
					currMatch.equivClass_c43= currEquivClass_c3c;
					if( !isValidBound(boundObjs_c40, currParentStruct_c32, false))
						continue;
					currMatch.parentStruct_c44= currParentStruct_c32;
					if( !isValidBound(boundObjs_c40, currLocalVar_c35, false))
						continue;
					currMatch.localVar_c45= currLocalVar_c35;
					if( !isValidBound(boundObjs_c40, childStruct_c37, false))
						continue;
					currMatch.childStruct_c46= childStruct_c37;
					_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void ComplexStruct1_c22::outputAppender( const SFC::Class& class_c47)
{
	_class_c26->push_back( class_c47);
}

bool ComplexStruct2_c49::operator()( const Packets_t& classs_c4a, Packets_t& classs_c4c)
{
#ifdef PRINT_INFO
	printLog( "ComplexStruct2_c49" );
#endif
	_class_c4d= &classs_c4c;
	processInputPackets( classs_c4a);
	if( false== _matches.empty())
		return true;
	return false;
}

bool ComplexStruct2_c49::isInputUnique( const Udm::Object& class_c52)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass_c54= _class_c4e.begin(); itClass_c54!= _class_c4e.end(); ++itClass_c54)
	{
		if( ( *itClass_c54== class_c52))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_class_c4e.push_back( class_c52);
	return isUnique;
}

bool ComplexStruct2_c49::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void ComplexStruct2_c49::processInputPackets( const Packets_t& classs_c4a)
{
	for( Packets_t::const_iterator itClass_c4f= classs_c4a.begin(); itClass_c4f!= classs_c4a.end(); ++itClass_c4f)
	{
		bool isUnique= isInputUnique( *itClass_c4f);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass_c4f);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.class_c68);
	}
}

bool ComplexStruct2_c49::patternMatcher( const Udm::Object& class_c50)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class_c50.type(), SFC::Class::meta))
			continue;
		SFC::Class class_c55= SFC::Class::Cast( class_c50);
		set< SFC::Struct> parentStructs_c57= class_c55.Struct_kind_children();
		for( set< SFC::Struct>::const_iterator itParentStruct_c58= parentStructs_c57.begin(); itParentStruct_c58!= parentStructs_c57.end(); ++itParentStruct_c58)
		{
			SFC::Struct currParentStruct_c59= *itParentStruct_c58;
			set< SFC::LocalVar> localVars_c5a= currParentStruct_c59.LocalVar_kind_children();
			for( set< SFC::LocalVar>::const_iterator itLocalVar_c5b= localVars_c5a.begin(); itLocalVar_c5b!= localVars_c5a.end(); ++itLocalVar_c5b)
			{
				SFC::LocalVar currLocalVar_c5c= *itLocalVar_c5b;
				SFC::DT childStruct_c5d= currLocalVar_c5c.dt();
				if(!childStruct_c5d || false== Uml::IsDerivedFrom( childStruct_c5d.type(), SFC::Struct::meta))
					continue;
				SFC::Struct childStruct_c5e= SFC::Struct::Cast( childStruct_c5d);
				if( !childStruct_c5e)
					continue;
				Udm::Object childStructParent_c5f= childStruct_c5e.container();
				if( false== Uml::IsDerivedFrom( childStructParent_c5f.type(), SFC::Class::meta))
					continue;
				SFC::Class childClassChildStruct_c60= SFC::Class::Cast( childStructParent_c5f);
				set< SFC::Class> equivClasss_c61= childClassChildStruct_c60.equivsrc();
				for( set< SFC::Class>::const_iterator itEquivClasss_c62= equivClasss_c61.begin(); itEquivClasss_c62!= equivClasss_c61.end(); ++itEquivClasss_c62)
				{
					SFC::Class currEquivClass_c63= *itEquivClasss_c62;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_c67;
					if( !isValidBound(boundObjs_c67, class_c55, true))
						continue;
					currMatch.class_c68= class_c55;
					if( !isValidBound(boundObjs_c67, currParentStruct_c59, false))
						continue;
					currMatch.parentStruct_c69= currParentStruct_c59;
					if( !isValidBound(boundObjs_c67, childClassChildStruct_c60, false))
						continue;
					currMatch.childClass_c6a= childClassChildStruct_c60;
					if( !isValidBound(boundObjs_c67, currEquivClass_c63, false))
						continue;
					currMatch.equivClass_c6b= currEquivClass_c63;
					if( !isValidBound(boundObjs_c67, currLocalVar_c5c, false))
						continue;
					currMatch.localVar_c6c= currLocalVar_c5c;
					if( !isValidBound(boundObjs_c67, childStruct_c5e, false))
						continue;
					currMatch.childStruct_c6d= childStruct_c5e;
					_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void ComplexStruct2_c49::outputAppender( const SFC::Class& class_c6e)
{
	_class_c4d->push_back( class_c6e);
}

bool SimpleStruct_c70::operator()( const Packets_t& classs_c71, Packets_t& classs_c73)
{
#ifdef PRINT_INFO
	printLog( "SimpleStruct_c70" );
#endif
	_class_c74= &classs_c73;
	processInputPackets( classs_c71);
	if( false== _matches.empty())
		return true;
	return false;
}

bool SimpleStruct_c70::isInputUnique( const Udm::Object& class_c79)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass_c7b= _class_c75.begin(); itClass_c7b!= _class_c75.end(); ++itClass_c7b)
	{
		if( ( *itClass_c7b== class_c79))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_class_c75.push_back( class_c79);
	return isUnique;
}

bool SimpleStruct_c70::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void SimpleStruct_c70::processInputPackets( const Packets_t& classs_c71)
{
	for( Packets_t::const_iterator itClass_c76= classs_c71.begin(); itClass_c76!= classs_c71.end(); ++itClass_c76)
	{
		bool isUnique= isInputUnique( *itClass_c76);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass_c76);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.class_c82);
	}
}

bool SimpleStruct_c70::patternMatcher( const Udm::Object& class_c77)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class_c77.type(), SFC::Class::meta))
			continue;
		SFC::Class class_c7c= SFC::Class::Cast( class_c77);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_c81;
		if( !isValidBound(boundObjs_c81, class_c7c, true))
			continue;
		currMatch.class_c82= class_c7c;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void SimpleStruct_c70::outputAppender( const SFC::Class& class_c83)
{
	_class_c74->push_back( class_c83);
}

void ElimRedundantClasses_c95::operator()( const Packets_t& projects_c96, Packets_t& projects_c98)
{
#ifdef PRINT_INFO
	printLog( "ElimRedundantClasses_c95" );
#endif
	_project_c99= &projects_c98;
	_project_c99->insert( _project_c99->end(), projects_c96.begin(), projects_c96.end());
	if( ( !projects_c96.empty()))
		callGetClasses_cea( projects_c96);
}

void ElimRedundantClasses_c95::callGetClasses_cea( const Packets_t& projects_c9c)
{
	Packets_t classs_c9b;
	GetClasses_c9a getClasses_c9a;
	getClasses_c9a( projects_c9c, classs_c9b);
	if( ( !classs_c9b.empty()))
		callRedundancyTest_cec( classs_c9b);
}

void ElimRedundantClasses_c95::callRedundancyTest_cec( const Packets_t& classs_cb8)
{
	Packets_t classs_cba;
	RedundancyTest_cb7 redundancyTest_cb7;
	redundancyTest_cb7( classs_cb8, classs_cba);
	if( ( !classs_cba.empty()))
		callDeleteClass_cee( classs_cba);
}

void ElimRedundantClasses_c95::callDeleteClass_cee( const Packets_t& classs_cda)
{
	DeleteClass_cd9 deleteClass_cd9;
	deleteClass_cd9( classs_cda);
}

void GetClasses_c9a::operator()( const Packets_t& projects_c9c, Packets_t& classs_c9b)
{
#ifdef PRINT_INFO
	printLog( "GetClasses_c9a" );
#endif
	RTTGenerator::Instance()->generateRule(619, "GetClasses");
	_class_c9e= &classs_c9b;
	processInputPackets( projects_c9c);
}

bool GetClasses_c9a::isInputUnique( const Udm::Object& project_ca3)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itProject_ca5= _project_c9f.begin(); itProject_ca5!= _project_c9f.end(); ++itProject_ca5)
	{
		if( ( *itProject_ca5== project_ca3))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_project_c9f.push_back( project_ca3);
	return isUnique;
}

bool GetClasses_c9a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetClasses_c9a::processInputPackets( const Packets_t& projects_c9c)
{
	for( Packets_t::const_iterator itProject_ca0= projects_c9c.begin(); itProject_ca0!= projects_c9c.end(); ++itProject_ca0)
	{
		bool isUnique= isInputUnique( *itProject_ca0);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itProject_ca0);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetClasses_c9a::patternMatcher( const Udm::Object& project_ca1)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( project_ca1.type(), SFC::Project::meta))
			continue;
		SFC::Project project_ca6= SFC::Project::Cast( project_ca1);
		set< SFC::Program> programs_ca8= project_ca6.Program_kind_children();
		for( set< SFC::Program>::const_iterator itProgram_ca9= programs_ca8.begin(); itProgram_ca9!= programs_ca8.end(); ++itProgram_ca9)
		{
			SFC::Program currProgram_caa= *itProgram_ca9;
			set< SFC::Class> classs_cab= currProgram_caa.Class_kind_children();
			for( set< SFC::Class>::const_iterator itClass_cac= classs_cab.begin(); itClass_cac!= classs_cab.end(); ++itClass_cac)
			{
				SFC::Class currClass_cad= *itClass_cac;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_cb1;
				if( !isValidBound(boundObjs_cb1, project_ca6, true))
					continue;
				currMatch.project_cb2= project_ca6;
				if( !isValidBound(boundObjs_cb1, currProgram_caa, false))
					continue;
				currMatch.program_cb3= currProgram_caa;
				if( !isValidBound(boundObjs_cb1, currClass_cad, false))
					continue;
				currMatch.class_cb4= currClass_cad;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetClasses_c9a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.class_cb4);
	}
}

void GetClasses_c9a::outputAppender( const SFC::Class& class_cb5)
{
	_class_c9e->push_back( class_cb5);
}

void RedundancyTest_cb7::operator()( const Packets_t& classs_cb8, Packets_t& classs_cba)
{
#ifdef PRINT_INFO
	printLog( "RedundancyTest_cb7" );
#endif
	_class_cbb= &classs_cba;
	for( Packets_t::const_iterator itclass_cbd= classs_cb8.begin(); itclass_cbd!= classs_cb8.end(); ++itclass_cbd)
	{
		bool isUnique= isInputUnique( *itclass_cbd);
		if( !isUnique)
			continue;
		Packets_t oneclass_cc1( 1, *itclass_cbd);
		executeOne( oneclass_cc1);
	}
}

void RedundancyTest_cb7::executeOne( const Packets_t& classs_cb8)
{
	Packets_t classs_cc6;
	NegStatementCount_cc3 negStatementCount_cc3;
	bool isMatchNegStatementCount_cc3= negStatementCount_cc3( classs_cb8, classs_cc6);
	_class_cbb->insert( _class_cbb->end(), classs_cc6.begin(), classs_cc6.end());
	if( isMatchNegStatementCount_cc3)
		return;
}

bool RedundancyTest_cb7::isInputUnique( const Udm::Object& class_cbe)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itclass_cc0= _class_cbc.begin(); itclass_cc0!= _class_cbc.end(); ++itclass_cc0)
	{
		if( ( *itclass_cc0== class_cbe))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_class_cbc.push_back( class_cbe);
	return isUnique;
}

bool NegStatementCount_cc3::operator()( const Packets_t& classs_cc4, Packets_t& classs_cc6)
{
#ifdef PRINT_INFO
	printLog( "NegStatementCount_cc3" );
#endif
	_class_cc7= &classs_cc6;
	processInputPackets( classs_cc4);
	if( false== _matches.empty())
		return true;
	return false;
}

bool NegStatementCount_cc3::isInputUnique( const Udm::Object& class_ccc)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass_cce= _class_cc8.begin(); itClass_cce!= _class_cc8.end(); ++itClass_cce)
	{
		if( ( *itClass_cce== class_ccc))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_class_cc8.push_back( class_ccc);
	return isUnique;
}

bool NegStatementCount_cc3::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool NegStatementCount_cc3::isGuardTrue( SFC::Class& Class)
{
	bool Gz_guard= false;
	return Class.statementCount() < 0;;
	return Gz_guard;
}

void NegStatementCount_cc3::processInputPackets( const Packets_t& classs_cc4)
{
	for( Packets_t::const_iterator itClass_cc9= classs_cc4.begin(); itClass_cc9!= classs_cc4.end(); ++itClass_cc9)
	{
		bool isUnique= isInputUnique( *itClass_cc9);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass_cc9);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.class_cd5);
	}
}

bool NegStatementCount_cc3::patternMatcher( const Udm::Object& class_cca)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class_cca.type(), SFC::Class::meta))
			continue;
		SFC::Class class_ccf= SFC::Class::Cast( class_cca);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_cd4;
		if( !isValidBound(boundObjs_cd4, class_ccf, true))
			continue;
		currMatch.class_cd5= class_ccf;
		bool Gz_guard= isGuardTrue( currMatch.class_cd5);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void NegStatementCount_cc3::outputAppender( const SFC::Class& class_cd7)
{
	_class_cc7->push_back( class_cd7);
}

void DeleteClass_cd9::operator()( const Packets_t& classs_cda)
{
#ifdef PRINT_INFO
	printLog( "DeleteClass_cd9" );
#endif
	RTTGenerator::Instance()->generateRule(630, "DeleteClass");
	processInputPackets( classs_cda);
}

bool DeleteClass_cd9::isInputUnique( const Udm::Object& class_ce0)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass_ce2= _class_cdc.begin(); itClass_ce2!= _class_cdc.end(); ++itClass_ce2)
	{
		if( ( *itClass_ce2== class_ce0))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_class_cdc.push_back( class_ce0);
	return isUnique;
}

bool DeleteClass_cd9::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void DeleteClass_cd9::processInputPackets( const Packets_t& classs_cda)
{
	for( Packets_t::const_iterator itClass_cdd= classs_cda.begin(); itClass_cdd!= classs_cda.end(); ++itClass_cdd)
	{
		bool isUnique= isInputUnique( *itClass_cdd);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass_cdd);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool DeleteClass_cd9::patternMatcher( const Udm::Object& class_cde)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class_cde.type(), SFC::Class::meta))
			continue;
		SFC::Class class_ce3= SFC::Class::Cast( class_cde);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_ce8;
		if( !isValidBound(boundObjs_ce8, class_ce3, true))
			continue;
		currMatch.class_ce9= class_ce3;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void DeleteClass_cd9::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		if( currMatch.class_ce9)
			currMatch.class_ce9.DeleteObject();
	}
}

void Constructors_cf4::operator()( const Packets_t& dataflows_cf5, const Packets_t& projects_cf7, Packets_t& dataflows_cf9, Packets_t& projects_cfa)
{
#ifdef PRINT_INFO
	printLog( "Constructors_cf4" );
#endif
	_dataflow_cfb= &dataflows_cf9;
	_project_cfc= &projects_cfa;
	_dataflow_cfb->insert( _dataflow_cfb->end(), dataflows_cf5.begin(), dataflows_cf5.end());
	_project_cfc->insert( _project_cfc->end(), projects_cf7.begin(), projects_cf7.end());
	if( ( !dataflows_cf5.empty()))
		callGetSubsystems_1179( dataflows_cf5);
}

void Constructors_cf4::callGetSubsystems_1179( const Packets_t& comptypes_115a)
{
	Packets_t subsystems_115c;
	GetSubsystems_1159 getSubsystems_1159;
	getSubsystems_1159( comptypes_115a, subsystems_115c);
	if( ( !subsystems_115c.empty()))
		callMakeAllConstructors_117b( subsystems_115c);
}

void Constructors_cf4::callMakeAllConstructors_117b( const Packets_t& subsystems_cfe)
{
	MakeAllConstructors_cfd makeAllConstructors_cfd;
	makeAllConstructors_cfd( subsystems_cfe);
}

void MakeAllConstructors_cfd::operator()( const Packets_t& subsystems_cfe)
{
#ifdef PRINT_INFO
	printLog( "MakeAllConstructors_cfd" );
#endif
	if( ( !subsystems_cfe.empty()))
		callSubsystemFilter_114f( subsystems_cfe);
}

void MakeAllConstructors_cfd::callSubsystemFilter_114f( const Packets_t& systems_10d2)
{
	Packets_t chartsystems_10d4;
	Packets_t sFchartsystems_10d5;
	Packets_t systems_10d6;
	SubsystemFilter_10d1 subsystemFilter_10d1;
	subsystemFilter_10d1( systems_10d2, chartsystems_10d4, sFchartsystems_10d5, systems_10d6);
	if( ( !chartsystems_10d4.empty()))
		callMakeChartConstructor_1151( chartsystems_10d4);
	if( ( !systems_10d6.empty()))
		callMakeConstructors_1153( systems_10d6);
	if( ( !sFchartsystems_10d5.empty()))
		callMakeSFChartConstructor_1155( sFchartsystems_10d5);
}

void MakeAllConstructors_cfd::callMakeChartConstructor_1151( const Packets_t& systems_d01)
{
	MakeChartConstructor_d00 makeChartConstructor_d00;
	makeChartConstructor_d00( systems_d01);
}

void MakeAllConstructors_cfd::callMakeConstructors_1153( const Packets_t& systems_d5b)
{
	Packets_t systems_d5d;
	MakeConstructors_d5a makeConstructors_d5a;
	makeConstructors_d5a( systems_d5b, systems_d5d);
	if( ( !systems_d5d.empty()))
		callGetSubSubsystems_1157( systems_d5d);
}

void MakeAllConstructors_cfd::callMakeSFChartConstructor_1155( const Packets_t& systems_1089)
{
	MakeSFChartConstructor_1088 makeSFChartConstructor_1088;
	makeSFChartConstructor_1088( systems_1089);
}

void MakeAllConstructors_cfd::callGetSubSubsystems_1157( const Packets_t& systems_10b2)
{
	Packets_t subsystems_10b4;
	GetSubSubsystems_10b1 getSubSubsystems_10b1;
	getSubSubsystems_10b1( systems_10b2, subsystems_10b4);
	if( ( !subsystems_10b4.empty()))
		callSubsystemFilter_114f( subsystems_10b4);
}

void MakeChartConstructor_d00::operator()( const Packets_t& systems_d01)
{
#ifdef PRINT_INFO
	printLog( "MakeChartConstructor_d00" );
#endif
	if( ( !systems_d01.empty()))
		callCreateInitFunction_d55( systems_d01);
}

void MakeChartConstructor_d00::callCreateInitFunction_d55( const Packets_t& subsystems_d04)
{
	Packets_t subsystems_d06;
	Packets_t initFunctions_d07;
	CreateInitFunction_d03 createInitFunction_d03;
	createInitFunction_d03( subsystems_d04, subsystems_d06, initFunctions_d07);
	if( ( !subsystems_d06.empty())&& ( !initFunctions_d07.empty()))
		callinitSubSubsystem_d57( subsystems_d06, initFunctions_d07);
}

void MakeChartConstructor_d00::callinitSubSubsystem_d57( const Packets_t& subsystems_d25, const Packets_t& initFunctions_d27)
{
	InitSubSubsystem_d24 initSubSubsystem_d24;
	initSubSubsystem_d24( subsystems_d25, initFunctions_d27);
}

void CreateInitFunction_d03::operator()( const Packets_t& subsystems_d04, Packets_t& subsystems_d06, Packets_t& initFunctions_d07)
{
#ifdef PRINT_INFO
	printLog( "CreateInitFunction_d03" );
#endif
	RTTGenerator::Instance()->generateRule(641, "CreateInitFunction");
	_subsystem_d08= &subsystems_d06;
	_initFunction_d09= &initFunctions_d07;
	processInputPackets( subsystems_d04);
}

bool CreateInitFunction_d03::isInputUnique( const Udm::Object& subsystem_d0e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_d10= _subsystem_d0a.begin(); itSubsystem_d10!= _subsystem_d0a.end(); ++itSubsystem_d10)
	{
		if( ( *itSubsystem_d10== subsystem_d0e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_subsystem_d0a.push_back( subsystem_d0e);
	return isUnique;
}

bool CreateInitFunction_d03::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateInitFunction_d03::processInputPackets( const Packets_t& subsystems_d04)
{
	for( Packets_t::const_iterator itSubsystem_d0b= subsystems_d04.begin(); itSubsystem_d0b!= subsystems_d04.end(); ++itSubsystem_d0b)
	{
		bool isUnique= isInputUnique( *itSubsystem_d0b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_d0b);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateInitFunction_d03::patternMatcher( const Udm::Object& subsystem_d0c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_d0c.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_d11= CyberComposition::Simulink::Subsystem::Cast( subsystem_d0c);
		SFC::Class class_d13= subsystem_d11.cls();
		if( !class_d13)
			continue;
		set< SFC::Struct> structs_d14= class_d13.Struct_kind_children();
		for( set< SFC::Struct>::const_iterator itStruct_d15= structs_d14.begin(); itStruct_d15!= structs_d14.end(); ++itStruct_d15)
		{
			SFC::Struct currStruct_d16= *itStruct_d15;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_d1a;
			if( !isValidBound(boundObjs_d1a, subsystem_d11, true))
				continue;
			currMatch.subsystem_d1b= subsystem_d11;
			if( !isValidBound(boundObjs_d1a, class_d13, false))
				continue;
			currMatch.class_d1c= class_d13;
			if( !isValidBound(boundObjs_d1a, currStruct_d16, false))
				continue;
			currMatch.struct_d1d= currStruct_d16;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateInitFunction_d03::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function newInitFunction_d1e= SFC::Function::Create( currMatch.class_d1c, SFC::Class::meta_stmnt);
		SFC::Arg newArg_d1f= SFC::Arg::Create( newInitFunction_d1e);
		SFC::Arg& Arg= newArg_d1f;
		SFC::Class& Class= currMatch.class_d1c;
		SFC::Function& InitFunction= newInitFunction_d1e;
		SFC::Struct& Struct= currMatch.struct_d1d;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_d1b;
		{
__int64 statementCount = Class.statementCount();
InitFunction.statementIndex() = statementCount++;
Class.statementCount() = statementCount;

InitFunction.name() = static_cast< std::string >( Subsystem.name() ) +  "_init";
InitFunction.argCount() = 1;
InitFunction.statementCount() = -1;
};
		{
Arg.name() = "context";
Arg.ptr() = true;
Arg.argIndex() = 0;
};
		newArg_d1f.dt()= currMatch.struct_d1d;
		newInitFunction_d1e.sysinit()= currMatch.subsystem_d1b;
		outputAppender( currMatch.subsystem_d1b, newInitFunction_d1e);
	}
}

void CreateInitFunction_d03::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_d20, const SFC::Function& initFunction_d22)
{
	_subsystem_d08->push_back( subsystem_d20);
	_initFunction_d09->push_back( initFunction_d22);
}

void InitSubSubsystem_d24::operator()( const Packets_t& subsystems_d25, const Packets_t& initFunctions_d27)
{
#ifdef PRINT_INFO
	printLog( "InitSubSubsystem_d24" );
#endif
	RTTGenerator::Instance()->generateRule(864, "initSubSubsystem");
	processInputPackets( subsystems_d25, initFunctions_d27);
}

bool InitSubSubsystem_d24::isInputUnique( const Udm::Object& subsystem_d2d, const Udm::Object& initFunction_d36)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_d2f= _subsystem_d29.begin(), itInitFunction_d38= _initFunction_d32.begin(); itSubsystem_d2f!= _subsystem_d29.end(), itInitFunction_d38!= _initFunction_d32.end(); ++itSubsystem_d2f, ++itInitFunction_d38)
	{
		if( ( *itSubsystem_d2f== subsystem_d2d)&& ( *itInitFunction_d38== initFunction_d36))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_d29.push_back( subsystem_d2d);
		_initFunction_d32.push_back( initFunction_d36);
	}
	return isUnique;
}

bool InitSubSubsystem_d24::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void InitSubSubsystem_d24::processInputPackets( const Packets_t& subsystems_d25, const Packets_t& initFunctions_d27)
{
	for( Packets_t::const_iterator itSubsystem_d2a= subsystems_d25.begin(), itInitFunction_d33= initFunctions_d27.begin(); itSubsystem_d2a!= subsystems_d25.end(), itInitFunction_d33!= initFunctions_d27.end(); ++itSubsystem_d2a, ++itInitFunction_d33)
	{
		bool isUnique= isInputUnique( *itSubsystem_d2a, *itInitFunction_d33);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_d2a, *itInitFunction_d33);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InitSubSubsystem_d24::patternMatcher( const Udm::Object& subsystem_d2b, const Udm::Object& initFunction_d34)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_d2b.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_d30= CyberComposition::Simulink::Subsystem::Cast( subsystem_d2b);
		if( false== Uml::IsDerivedFrom( initFunction_d34.type(), SFC::Function::meta))
			continue;
		SFC::Function initFunction_d39= SFC::Function::Cast( initFunction_d34);
		set< SFC::Arg> args_d3b= initFunction_d39.Arg_kind_children();
		for( set< SFC::Arg>::const_iterator itArg_d3c= args_d3b.begin(); itArg_d3c!= args_d3b.end(); ++itArg_d3c)
		{
			SFC::Arg currArg_d3d= *itArg_d3c;
			Udm::Object subsystemParent_d3e= subsystem_d30.container();
			if( false== Uml::IsDerivedFrom( subsystemParent_d3e.type(), CyberComposition::Simulink::Subsystem::meta))
				continue;
			CyberComposition::Simulink::Subsystem superSubsystemSubsystem_d3f= CyberComposition::Simulink::Subsystem::Cast( subsystemParent_d3e);
			SFC::LocalVar localVar_d40= subsystem_d30.memb();
			if( !localVar_d40)
				continue;
			SFC::Function superInitFunction_d41= superSubsystemSubsystem_d3f.init();
			if( !superInitFunction_d41)
				continue;
			set< SFC::Arg> superArgs_d42= superInitFunction_d41.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itSuperArg_d43= superArgs_d42.begin(); itSuperArg_d43!= superArgs_d42.end(); ++itSuperArg_d43)
			{
				SFC::Arg currSuperArg_d44= *itSuperArg_d43;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_d48;
				if( !isValidBound(boundObjs_d48, subsystem_d30, true))
					continue;
				currMatch.subsystem_d49= subsystem_d30;
				if( !isValidBound(boundObjs_d48, initFunction_d39, true))
					continue;
				currMatch.initFunction_d4a= initFunction_d39;
				if( !isValidBound(boundObjs_d48, localVar_d40, false))
					continue;
				currMatch.localVar_d4b= localVar_d40;
				if( !isValidBound(boundObjs_d48, currSuperArg_d44, false))
					continue;
				currMatch.superArg_d4c= currSuperArg_d44;
				if( !isValidBound(boundObjs_d48, superInitFunction_d41, false))
					continue;
				currMatch.superInitFunction_d4d= superInitFunction_d41;
				if( !isValidBound(boundObjs_d48, superSubsystemSubsystem_d3f, false))
					continue;
				currMatch.superSubsystem_d4e= superSubsystemSubsystem_d3f;
				if( !isValidBound(boundObjs_d48, currArg_d3d, false))
					continue;
				currMatch.arg_d4f= currArg_d3d;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void InitSubSubsystem_d24::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::FunctionCall newFunctionCall_d50= SFC::FunctionCall::Create( currMatch.superInitFunction_d4d, SFC::Function::meta_stmnt);
		SFC::ArgVal newArgVal_d51= SFC::ArgVal::Create( newFunctionCall_d50);
		SFC::BinaryExprs newBinaryExprs_d52= SFC::BinaryExprs::Create( newArgVal_d51, SFC::ArgVal::meta_argexpr);
		SFC::ArgDeclRef newArgDeclRef_d53= SFC::ArgDeclRef::Create( newBinaryExprs_d52, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newDeclRef_d54= SFC::ArgDeclRef::Create( newBinaryExprs_d52, SFC::BinaryExprs::meta_rightexpr);
		SFC::Arg& Arg= currMatch.arg_d4f;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_d53;
		SFC::ArgVal& ArgVal= newArgVal_d51;
		SFC::BinaryExprs& BinaryExprs= newBinaryExprs_d52;
		SFC::ArgDeclRef& DeclRef= newDeclRef_d54;
		SFC::FunctionCall& FunctionCall= newFunctionCall_d50;
		SFC::Function& InitFunction= currMatch.initFunction_d4a;
		SFC::LocalVar& LocalVar= currMatch.localVar_d4b;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_d49;
		SFC::Arg& SuperArg= currMatch.superArg_d4c;
		SFC::Function& SuperInitFunction= currMatch.superInitFunction_d4d;
		CyberComposition::Simulink::Subsystem& SuperSubsystem= currMatch.superSubsystem_d4e;
		{
__int64 statementCount = SuperInitFunction.statementCount();
FunctionCall.statementIndex() = statementCount++;
SuperInitFunction.statementCount() = statementCount;

FunctionCall.argCount() = 1;
};
		{
ArgVal.argIndex() = Arg.argIndex();
};
		{
BinaryExprs.op() = ".";
};
		newArgDeclRef_d53.argdecl()= currMatch.superArg_d4c;
		newDeclRef_d54.argdecl()= currMatch.localVar_d4b;
		newFunctionCall_d50.callee()= currMatch.initFunction_d4a;
		newArgVal_d51.arg()+= currMatch.arg_d4f;
	}
}

void MakeConstructors_d5a::operator()( const Packets_t& systems_d5b, Packets_t& systems_d5d)
{
#ifdef PRINT_INFO
	printLog( "MakeConstructors_d5a" );
#endif
	_system_d5e= &systems_d5d;
	if( ( !systems_d5b.empty()))
		callCreateInitFunction_107f( systems_d5b);
	_system_d5e->insert( _system_d5e->end(), systems_d5b.begin(), systems_d5b.end());
}

void MakeConstructors_d5a::callCreateInitFunction_107f( const Packets_t& subsystems_105b)
{
	Packets_t subsystems_105d;
	Packets_t initFunctions_105e;
	Packets_t structs_105f;
	CreateInitFunction_105a createInitFunction_105a;
	createInitFunction_105a( subsystems_105b, subsystems_105d, initFunctions_105e, structs_105f);
	if( ( !subsystems_105d.empty())&& ( !initFunctions_105e.empty())&& ( !structs_105f.empty()))
		callinitParameters_1081( subsystems_105d, initFunctions_105e, structs_105f);
}

void MakeConstructors_d5a::callinitParameters_1081( const Packets_t& systems_d60, const Packets_t& initFunctions_d62, const Packets_t& classStructs_d64)
{
	Packets_t systems_d66;
	Packets_t initFunctions_d67;
	InitParameters_d5f initParameters_d5f;
	initParameters_d5f( systems_d60, initFunctions_d62, classStructs_d64, systems_d66, initFunctions_d67);
	if( ( !systems_d66.empty())&& ( !initFunctions_d67.empty()))
		callinitSubSubsystem_1085( systems_d66, initFunctions_d67);
}

void MakeConstructors_d5a::callinitSubSubsystem_1085( const Packets_t& subsystems_d25, const Packets_t& initFunctions_d27)
{
	InitSubSubsystem_d24 initSubSubsystem_d24;
	initSubSubsystem_d24( subsystems_d25, initFunctions_d27);
}

void InitParameters_d5f::operator()( const Packets_t& systems_d60, const Packets_t& initFunctions_d62, const Packets_t& classStructs_d64, Packets_t& systems_d66, Packets_t& initFunctions_d67)
{
#ifdef PRINT_INFO
	printLog( "InitParameters_d5f" );
#endif
	_system_d68= &systems_d66;
	_initFunction_d69= &initFunctions_d67;
	if( ( !systems_d60.empty())&& ( !initFunctions_d62.empty())&& ( !classStructs_d64.empty()))
		callinitDirectParameters_104a( systems_d60, initFunctions_d62, classStructs_d64);
	_system_d68->insert( _system_d68->end(), systems_d60.begin(), systems_d60.end());
	_initFunction_d69->insert( _initFunction_d69->end(), initFunctions_d62.begin(), initFunctions_d62.end());
}

void InitParameters_d5f::callinitDirectParameters_104a( const Packets_t& systems_1006, const Packets_t& initFunctions_1008, const Packets_t& classStructs_100a)
{
	Packets_t systems_100c;
	Packets_t initFunctions_100d;
	Packets_t classStructs_100e;
	InitDirectParameters_1005 initDirectParameters_1005;
	initDirectParameters_1005( systems_1006, initFunctions_1008, classStructs_100a, systems_100c, initFunctions_100d, classStructs_100e);
	if( ( !systems_100c.empty())&& ( !initFunctions_100d.empty())&& ( !classStructs_100e.empty()))
		callinitPrimitiveParameters_104e( systems_100c, initFunctions_100d, classStructs_100e);
}

void InitParameters_d5f::callinitPrimitiveParameters_104e( const Packets_t& systems_db7, const Packets_t& initFunctions_db9, const Packets_t& classStructs_dbb)
{
	Packets_t systems_dbd;
	Packets_t initFunctions_dbe;
	Packets_t classStructs_dbf;
	InitPrimitiveParameters_db6 initPrimitiveParameters_db6;
	initPrimitiveParameters_db6( systems_db7, initFunctions_db9, classStructs_dbb, systems_dbd, initFunctions_dbe, classStructs_dbf);
	if( ( !systems_dbd.empty())&& ( !initFunctions_dbe.empty())&& ( !classStructs_dbf.empty()))
		callinitPrimPseudoParams_1052( systems_dbd, initFunctions_dbe, classStructs_dbf);
}

void InitParameters_d5f::callinitPrimPseudoParams_1052( const Packets_t& systems_d6b, const Packets_t& initFunctions_d6d, const Packets_t& classStructs_d6f)
{
	Packets_t systems_d71;
	Packets_t initFunctions_d72;
	Packets_t classStructs_d73;
	InitPrimPseudoParams_d6a initPrimPseudoParams_d6a;
	initPrimPseudoParams_d6a( systems_d6b, initFunctions_d6d, classStructs_d6f, systems_d71, initFunctions_d72, classStructs_d73);
	if( ( !systems_d71.empty())&& ( !initFunctions_d72.empty())&& ( !classStructs_d73.empty()))
		callInitTriggerVars_1056( systems_d71, initFunctions_d72, classStructs_d73);
}

void InitParameters_d5f::callInitTriggerVars_1056( const Packets_t& systems_f49, const Packets_t& initFunctions_f4b, const Packets_t& classStructs_f4d)
{
	InitTriggerVars_f48 initTriggerVars_f48;
	initTriggerVars_f48( systems_f49, initFunctions_f4b, classStructs_f4d);
}

void InitPrimPseudoParams_d6a::operator()( const Packets_t& systems_d6b, const Packets_t& initFunctions_d6d, const Packets_t& classStructs_d6f, Packets_t& systems_d71, Packets_t& initFunctions_d72, Packets_t& classStructs_d73)
{
#ifdef PRINT_INFO
	printLog( "InitPrimPseudoParams_d6a" );
#endif
	_system_d74= &systems_d71;
	_initFunction_d75= &initFunctions_d72;
	_classStruct_d76= &classStructs_d73;
	_system_d74->insert( _system_d74->end(), systems_d6b.begin(), systems_d6b.end());
	_initFunction_d75->insert( _initFunction_d75->end(), initFunctions_d6d.begin(), initFunctions_d6d.end());
	_classStruct_d76->insert( _classStruct_d76->end(), classStructs_d6f.begin(), classStructs_d6f.end());
	if( ( !systems_d6b.empty())&& ( !initFunctions_d6d.empty())&& ( !classStructs_d6f.empty()))
		callinitPrimPseudoParam_db2( systems_d6b, initFunctions_d6d, classStructs_d6f);
}

void InitPrimPseudoParams_d6a::callinitPrimPseudoParam_db2( const Packets_t& subsystem1s_d78, const Packets_t& initFunctions_d7a, const Packets_t& classStructs_d7c)
{
	InitPrimPseudoParam_d77 initPrimPseudoParam_d77;
	initPrimPseudoParam_d77( subsystem1s_d78, initFunctions_d7a, classStructs_d7c);
}

void InitPrimPseudoParam_d77::operator()( const Packets_t& subsystem1s_d78, const Packets_t& initFunctions_d7a, const Packets_t& classStructs_d7c)
{
#ifdef PRINT_INFO
	printLog( "InitPrimPseudoParam_d77" );
#endif
	RTTGenerator::Instance()->generateRule(671, "initPrimPseudoParam");
	processInputPackets( subsystem1s_d78, initFunctions_d7a, classStructs_d7c);
}

bool InitPrimPseudoParam_d77::isInputUnique( const Udm::Object& subsystem1_d82, const Udm::Object& initFunction_d8b, const Udm::Object& classStruct_d94)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem1_d84= _subsystem1_d7e.begin(), itInitFunction_d8d= _initFunction_d87.begin(), itClassStruct_d96= _classStruct_d90.begin(); itSubsystem1_d84!= _subsystem1_d7e.end(), itInitFunction_d8d!= _initFunction_d87.end(), itClassStruct_d96!= _classStruct_d90.end(); ++itSubsystem1_d84, ++itInitFunction_d8d, ++itClassStruct_d96)
	{
		if( ( *itSubsystem1_d84== subsystem1_d82)&& ( *itInitFunction_d8d== initFunction_d8b)&& ( *itClassStruct_d96== classStruct_d94))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem1_d7e.push_back( subsystem1_d82);
		_initFunction_d87.push_back( initFunction_d8b);
		_classStruct_d90.push_back( classStruct_d94);
	}
	return isUnique;
}

bool InitPrimPseudoParam_d77::isGuardTrue( SFC::Struct& ClassStruct, SFC::Function& InitFunction, SFC::LocalVar& LocalVar, CyberComposition::Simulink::SF_Parameter& Parameter, CyberComposition::Simulink::Primitive& Primitive, CyberComposition::Simulink::Subsystem& Subsystem1, CyberComposition::Simulink::Subsystem& Subsystem2)
{
	bool Gz_guard= false;
	return Subsystem1 == Subsystem2;;
	return Gz_guard;
}

void InitPrimPseudoParam_d77::processInputPackets( const Packets_t& subsystem1s_d78, const Packets_t& initFunctions_d7a, const Packets_t& classStructs_d7c)
{
	for( Packets_t::const_iterator itSubsystem1_d7f= subsystem1s_d78.begin(), itInitFunction_d88= initFunctions_d7a.begin(), itClassStruct_d91= classStructs_d7c.begin(); itSubsystem1_d7f!= subsystem1s_d78.end(), itInitFunction_d88!= initFunctions_d7a.end(), itClassStruct_d91!= classStructs_d7c.end(); ++itSubsystem1_d7f, ++itInitFunction_d88, ++itClassStruct_d91)
	{
		bool isUnique= isInputUnique( *itSubsystem1_d7f, *itInitFunction_d88, *itClassStruct_d91);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem1_d7f, *itInitFunction_d88, *itClassStruct_d91);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InitPrimPseudoParam_d77::patternMatcher( const Udm::Object& subsystem1_d80, const Udm::Object& initFunction_d89, const Udm::Object& classStruct_d92)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem1_d80.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem1_d85= CyberComposition::Simulink::Subsystem::Cast( subsystem1_d80);
		if( false== Uml::IsDerivedFrom( initFunction_d89.type(), SFC::Function::meta))
			continue;
		SFC::Function initFunction_d8e= SFC::Function::Cast( initFunction_d89);
		if( false== Uml::IsDerivedFrom( classStruct_d92.type(), SFC::Struct::meta))
			continue;
		SFC::Struct classStruct_d97= SFC::Struct::Cast( classStruct_d92);
		set< SFC::LocalVar> localVars_d99= classStruct_d97.pmemb();
		for( set< SFC::LocalVar>::const_iterator itLocalVars_d9a= localVars_d99.begin(); itLocalVars_d9a!= localVars_d99.end(); ++itLocalVars_d9a)
		{
			SFC::LocalVar currLocalVar_d9b= *itLocalVars_d9a;
			set< CyberComposition::Simulink::SF_Parameter> parameters_d9c= currLocalVar_d9b.param();
			for( set< CyberComposition::Simulink::SF_Parameter>::const_iterator itParameters_d9d= parameters_d9c.begin(); itParameters_d9d!= parameters_d9c.end(); ++itParameters_d9d)
			{
				CyberComposition::Simulink::SF_Parameter currParameter_d9e= *itParameters_d9d;
				Udm::Object parameterParent_d9f= currParameter_d9e.container();
				if( false== Uml::IsDerivedFrom( parameterParent_d9f.type(), CyberComposition::Simulink::Primitive::meta))
					continue;
				CyberComposition::Simulink::Primitive primitiveParameter_da0= CyberComposition::Simulink::Primitive::Cast( parameterParent_d9f);
				Udm::Object primitiveParent_da1= primitiveParameter_da0.container();
				if( false== Uml::IsDerivedFrom( primitiveParent_da1.type(), CyberComposition::Simulink::Subsystem::meta))
					continue;
				CyberComposition::Simulink::Subsystem subsystem2Primitive_da2= CyberComposition::Simulink::Subsystem::Cast( primitiveParent_da1);
				Match currMatch;
				currMatch.subsystem1_da4= subsystem1_d85;
				currMatch.initFunction_da5= initFunction_d8e;
				currMatch.classStruct_da6= classStruct_d97;
				currMatch.subsystem2_da7= subsystem2Primitive_da2;
				currMatch.primitive_da8= primitiveParameter_da0;
				currMatch.parameter_da9= currParameter_d9e;
				currMatch.localVar_daa= currLocalVar_d9b;
				bool Gz_guard= isGuardTrue( currMatch.classStruct_da6, currMatch.initFunction_da5, currMatch.localVar_daa, currMatch.parameter_da9, currMatch.primitive_da8, currMatch.subsystem1_da4, currMatch.subsystem2_da7);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void InitPrimPseudoParam_d77::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Struct& ClassStruct= currMatch.classStruct_da6;
		SFC::Function& InitFunction= currMatch.initFunction_da5;
		SFC::LocalVar& LocalVar= currMatch.localVar_daa;
		CyberComposition::Simulink::SF_Parameter& Parameter= currMatch.parameter_da9;
		CyberComposition::Simulink::Primitive& Primitive= currMatch.primitive_da8;
		CyberComposition::Simulink::Subsystem& Subsystem1= currMatch.subsystem1_da4;
		CyberComposition::Simulink::Subsystem& Subsystem2= currMatch.subsystem2_da7;
		{
SFUtils::InitParameter( InitFunction, Parameter, LocalVar );
};
	}
}

void InitPrimitiveParameters_db6::operator()( const Packets_t& systems_db7, const Packets_t& initFunctions_db9, const Packets_t& classStructs_dbb, Packets_t& systems_dbd, Packets_t& initFunctions_dbe, Packets_t& classStructs_dbf)
{
#ifdef PRINT_INFO
	printLog( "InitPrimitiveParameters_db6" );
#endif
	_system_dc0= &systems_dbd;
	_initFunction_dc1= &initFunctions_dbe;
	_classStruct_dc2= &classStructs_dbf;
	if( ( !systems_db7.empty())&& ( !initFunctions_db9.empty())&& ( !classStructs_dbb.empty()))
		callGetStructMembers_f38( systems_db7, initFunctions_db9, classStructs_dbb);
	_system_dc0->insert( _system_dc0->end(), systems_db7.begin(), systems_db7.end());
	_initFunction_dc1->insert( _initFunction_dc1->end(), initFunctions_db9.begin(), initFunctions_db9.end());
	_classStruct_dc2->insert( _classStruct_dc2->end(), classStructs_dbb.begin(), classStructs_dbb.end());
}

void InitPrimitiveParameters_db6::callGetStructMembers_f38( const Packets_t& subsystems_ded, const Packets_t& initFunctions_df0, const Packets_t& classStructs_df3)
{
	Packets_t subsystems_def;
	Packets_t initFunctions_df2;
	Packets_t localVars_df5;
	GetStructMembers_dec getStructMembers_dec;
	getStructMembers_dec( subsystems_ded, initFunctions_df0, classStructs_df3, subsystems_def, initFunctions_df2, localVars_df5);
	if( ( !subsystems_def.empty())&& ( !initFunctions_df2.empty())&& ( !localVars_df5.empty()))
		callTest_f3c( subsystems_def, initFunctions_df2, localVars_df5);
}

void InitPrimitiveParameters_db6::callTest_f3c( const Packets_t& systems_e26, const Packets_t& initFunctions_e28, const Packets_t& members_e2a)
{
	Packets_t systems_e2c;
	Packets_t initFunctions_e2d;
	Packets_t classStructs_e2e;
	Packets_t systems_e2f;
	Packets_t initFunctions_e30;
	Packets_t classStructs_e31;
	Packets_t systems_e32;
	Packets_t initFunctions_e33;
	Packets_t classStructs_e34;
	Test_e25 test_e25;
	test_e25( systems_e26, initFunctions_e28, members_e2a, systems_e2c, initFunctions_e2d, classStructs_e2e, systems_e2f, initFunctions_e30, classStructs_e31, systems_e32, initFunctions_e33, classStructs_e34);
	if( ( !systems_e32.empty())&& ( !initFunctions_e33.empty())&& ( !classStructs_e34.empty()))
		callzeroPrimitiveParameter_f40( systems_e32, initFunctions_e33, classStructs_e34);
	if( ( !systems_e2c.empty())&& ( !initFunctions_e2d.empty())&& ( !classStructs_e2e.empty()))
		callinitPrimitiveParameter_f44( systems_e2c, initFunctions_e2d, classStructs_e2e);
}

void InitPrimitiveParameters_db6::callzeroPrimitiveParameter_f40( const Packets_t& subsystems_dc4, const Packets_t& initFunctions_dc6, const Packets_t& localVars_dc8)
{
	ZeroPrimitiveParameter_dc3 zeroPrimitiveParameter_dc3;
	zeroPrimitiveParameter_dc3( subsystems_dc4, initFunctions_dc6, localVars_dc8);
}

void InitPrimitiveParameters_db6::callinitPrimitiveParameter_f44( const Packets_t& subsystem1s_f03, const Packets_t& initFunctions_f05, const Packets_t& localVars_f07)
{
	InitPrimitiveParameter_f02 initPrimitiveParameter_f02;
	initPrimitiveParameter_f02( subsystem1s_f03, initFunctions_f05, localVars_f07);
}

void ZeroPrimitiveParameter_dc3::operator()( const Packets_t& subsystems_dc4, const Packets_t& initFunctions_dc6, const Packets_t& localVars_dc8)
{
#ifdef PRINT_INFO
	printLog( "ZeroPrimitiveParameter_dc3" );
#endif
	RTTGenerator::Instance()->generateRule(691, "zeroPrimitiveParameter");
	processInputPackets( subsystems_dc4, initFunctions_dc6, localVars_dc8);
}

bool ZeroPrimitiveParameter_dc3::isInputUnique( const Udm::Object& subsystem_dce, const Udm::Object& initFunction_dd7, const Udm::Object& localVar_de0)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_dd0= _subsystem_dca.begin(), itInitFunction_dd9= _initFunction_dd3.begin(), itLocalVar_de2= _localVar_ddc.begin(); itSubsystem_dd0!= _subsystem_dca.end(), itInitFunction_dd9!= _initFunction_dd3.end(), itLocalVar_de2!= _localVar_ddc.end(); ++itSubsystem_dd0, ++itInitFunction_dd9, ++itLocalVar_de2)
	{
		if( ( *itSubsystem_dd0== subsystem_dce)&& ( *itInitFunction_dd9== initFunction_dd7)&& ( *itLocalVar_de2== localVar_de0))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_dca.push_back( subsystem_dce);
		_initFunction_dd3.push_back( initFunction_dd7);
		_localVar_ddc.push_back( localVar_de0);
	}
	return isUnique;
}

bool ZeroPrimitiveParameter_dc3::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void ZeroPrimitiveParameter_dc3::processInputPackets( const Packets_t& subsystems_dc4, const Packets_t& initFunctions_dc6, const Packets_t& localVars_dc8)
{
	for( Packets_t::const_iterator itSubsystem_dcb= subsystems_dc4.begin(), itInitFunction_dd4= initFunctions_dc6.begin(), itLocalVar_ddd= localVars_dc8.begin(); itSubsystem_dcb!= subsystems_dc4.end(), itInitFunction_dd4!= initFunctions_dc6.end(), itLocalVar_ddd!= localVars_dc8.end(); ++itSubsystem_dcb, ++itInitFunction_dd4, ++itLocalVar_ddd)
	{
		bool isUnique= isInputUnique( *itSubsystem_dcb, *itInitFunction_dd4, *itLocalVar_ddd);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_dcb, *itInitFunction_dd4, *itLocalVar_ddd);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ZeroPrimitiveParameter_dc3::patternMatcher( const Udm::Object& subsystem_dcc, const Udm::Object& initFunction_dd5, const Udm::Object& localVar_dde)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_dcc.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_dd1= CyberComposition::Simulink::Subsystem::Cast( subsystem_dcc);
		if( false== Uml::IsDerivedFrom( initFunction_dd5.type(), SFC::Function::meta))
			continue;
		SFC::Function initFunction_dda= SFC::Function::Cast( initFunction_dd5);
		if( false== Uml::IsDerivedFrom( localVar_dde.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_de3= SFC::LocalVar::Cast( localVar_dde);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_de8;
		if( !isValidBound(boundObjs_de8, subsystem_dd1, true))
			continue;
		currMatch.subsystem_de9= subsystem_dd1;
		if( !isValidBound(boundObjs_de8, initFunction_dda, true))
			continue;
		currMatch.initFunction_dea= initFunction_dda;
		if( !isValidBound(boundObjs_de8, localVar_de3, true))
			continue;
		currMatch.localVar_deb= localVar_de3;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void ZeroPrimitiveParameter_dc3::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function& InitFunction= currMatch.initFunction_dea;
		SFC::LocalVar& LocalVar= currMatch.localVar_deb;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_de9;
		{
SFUtils::InitParameter( InitFunction, LocalVar );
};
	}
}

void GetStructMembers_dec::operator()( const Packets_t& subsystems_ded, const Packets_t& initFunctions_df0, const Packets_t& classStructs_df3, Packets_t& subsystems_def, Packets_t& initFunctions_df2, Packets_t& localVars_df5)
{
#ifdef PRINT_INFO
	printLog( "GetStructMembers_dec" );
#endif
	RTTGenerator::Instance()->generateRule(696, "GetStructMembers");
	_subsystem_df6= &subsystems_def;
	_initFunction_df7= &initFunctions_df2;
	_localVar_df8= &localVars_df5;
	processInputPackets( subsystems_ded, initFunctions_df0, classStructs_df3);
}

bool GetStructMembers_dec::isInputUnique( const Udm::Object& subsystem_dfd, const Udm::Object& initFunction_e06, const Udm::Object& classStruct_e0f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_dff= _subsystem_df9.begin(), itInitFunction_e08= _initFunction_e02.begin(), itClassStruct_e11= _classStruct_e0b.begin(); itSubsystem_dff!= _subsystem_df9.end(), itInitFunction_e08!= _initFunction_e02.end(), itClassStruct_e11!= _classStruct_e0b.end(); ++itSubsystem_dff, ++itInitFunction_e08, ++itClassStruct_e11)
	{
		if( ( *itSubsystem_dff== subsystem_dfd)&& ( *itInitFunction_e08== initFunction_e06)&& ( *itClassStruct_e11== classStruct_e0f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_df9.push_back( subsystem_dfd);
		_initFunction_e02.push_back( initFunction_e06);
		_classStruct_e0b.push_back( classStruct_e0f);
	}
	return isUnique;
}

bool GetStructMembers_dec::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetStructMembers_dec::processInputPackets( const Packets_t& subsystems_ded, const Packets_t& initFunctions_df0, const Packets_t& classStructs_df3)
{
	for( Packets_t::const_iterator itSubsystem_dfa= subsystems_ded.begin(), itInitFunction_e03= initFunctions_df0.begin(), itClassStruct_e0c= classStructs_df3.begin(); itSubsystem_dfa!= subsystems_ded.end(), itInitFunction_e03!= initFunctions_df0.end(), itClassStruct_e0c!= classStructs_df3.end(); ++itSubsystem_dfa, ++itInitFunction_e03, ++itClassStruct_e0c)
	{
		bool isUnique= isInputUnique( *itSubsystem_dfa, *itInitFunction_e03, *itClassStruct_e0c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_dfa, *itInitFunction_e03, *itClassStruct_e0c);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetStructMembers_dec::patternMatcher( const Udm::Object& subsystem_dfb, const Udm::Object& initFunction_e04, const Udm::Object& classStruct_e0d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_dfb.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_e00= CyberComposition::Simulink::Subsystem::Cast( subsystem_dfb);
		if( false== Uml::IsDerivedFrom( initFunction_e04.type(), SFC::Function::meta))
			continue;
		SFC::Function initFunction_e09= SFC::Function::Cast( initFunction_e04);
		if( false== Uml::IsDerivedFrom( classStruct_e0d.type(), SFC::Struct::meta))
			continue;
		SFC::Struct classStruct_e12= SFC::Struct::Cast( classStruct_e0d);
		set< SFC::LocalVar> localVars_e14= classStruct_e12.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itLocalVar_e15= localVars_e14.begin(); itLocalVar_e15!= localVars_e14.end(); ++itLocalVar_e15)
		{
			SFC::LocalVar currLocalVar_e16= *itLocalVar_e15;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_e1a;
			if( !isValidBound(boundObjs_e1a, subsystem_e00, true))
				continue;
			currMatch.subsystem_e1b= subsystem_e00;
			if( !isValidBound(boundObjs_e1a, initFunction_e09, true))
				continue;
			currMatch.initFunction_e1c= initFunction_e09;
			if( !isValidBound(boundObjs_e1a, classStruct_e12, true))
				continue;
			currMatch.classStruct_e1d= classStruct_e12;
			if( !isValidBound(boundObjs_e1a, currLocalVar_e16, false))
				continue;
			currMatch.localVar_e1e= currLocalVar_e16;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetStructMembers_dec::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_e1b, currMatch.initFunction_e1c, currMatch.localVar_e1e);
	}
}

void GetStructMembers_dec::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_e1f, const SFC::Function& initFunction_e21, const SFC::LocalVar& localVar_e23)
{
	_subsystem_df6->push_back( subsystem_e1f);
	_initFunction_df7->push_back( initFunction_e21);
	_localVar_df8->push_back( localVar_e23);
}

void Test_e25::operator()( const Packets_t& systems_e26, const Packets_t& initFunctions_e28, const Packets_t& members_e2a, Packets_t& systems_e2c, Packets_t& initFunctions_e2d, Packets_t& classStructs_e2e, Packets_t& systems_e2f, Packets_t& initFunctions_e30, Packets_t& classStructs_e31, Packets_t& systems_e32, Packets_t& initFunctions_e33, Packets_t& classStructs_e34)
{
#ifdef PRINT_INFO
	printLog( "Test_e25" );
#endif
	_system_e35= &systems_e2c;
	_initFunction_e36= &initFunctions_e2d;
	_classStruct_e37= &classStructs_e2e;
	_system_e38= &systems_e2f;
	_initFunction_e39= &initFunctions_e30;
	_classStruct_e3a= &classStructs_e31;
	_system_e3b= &systems_e32;
	_initFunction_e3c= &initFunctions_e33;
	_classStruct_e3d= &classStructs_e34;
	for( Packets_t::const_iterator itsystem_e3f= systems_e26.begin(), itinitFunction_e46= initFunctions_e28.begin(), itmember_e4d= members_e2a.begin(); itsystem_e3f!= systems_e26.end(), itinitFunction_e46!= initFunctions_e28.end(), itmember_e4d!= members_e2a.end(); ++itsystem_e3f, ++itinitFunction_e46, ++itmember_e4d)
	{
		bool isUnique= isInputUnique( *itsystem_e3f, *itinitFunction_e46, *itmember_e4d);
		if( !isUnique)
			continue;
		Packets_t onesystem_e43( 1, *itsystem_e3f);
		Packets_t oneinitFunction_e4a( 1, *itinitFunction_e46);
		Packets_t onemember_e51( 1, *itmember_e4d);
		executeOne( onesystem_e43, oneinitFunction_e4a, onemember_e51);
	}
}

void Test_e25::executeOne( const Packets_t& systems_e26, const Packets_t& initFunctions_e28, const Packets_t& members_e2a)
{
	Packets_t subsystem1s_e56;
	Packets_t initFunctions_e59;
	Packets_t localVars_e5c;
	MemberHasParameter_e53 memberHasParameter_e53;
	bool isMatchMemberHasParameter_e53= memberHasParameter_e53( systems_e26, initFunctions_e28, members_e2a, subsystem1s_e56, initFunctions_e59, localVars_e5c);
	_system_e35->insert( _system_e35->end(), subsystem1s_e56.begin(), subsystem1s_e56.end());
	_initFunction_e36->insert( _initFunction_e36->end(), initFunctions_e59.begin(), initFunctions_e59.end());
	_classStruct_e37->insert( _classStruct_e37->end(), localVars_e5c.begin(), localVars_e5c.end());
	if( isMatchMemberHasParameter_e53)
		return;
	Packets_t subsystems_e98;
	Packets_t initFunctions_e9b;
	Packets_t localVars_e9e;
	StructMember_e95 structMember_e95;
	bool isMatchStructMember_e95= structMember_e95( systems_e26, initFunctions_e28, members_e2a, subsystems_e98, initFunctions_e9b, localVars_e9e);
	_system_e38->insert( _system_e38->end(), subsystems_e98.begin(), subsystems_e98.end());
	_initFunction_e39->insert( _initFunction_e39->end(), initFunctions_e9b.begin(), initFunctions_e9b.end());
	_classStruct_e3a->insert( _classStruct_e3a->end(), localVars_e9e.begin(), localVars_e9e.end());
	if( isMatchStructMember_e95)
		return;
	Packets_t subsystems_ed0;
	Packets_t initFunctions_ed3;
	Packets_t localVars_ed6;
	MemberNoParameter_ecd memberNoParameter_ecd;
	bool isMatchMemberNoParameter_ecd= memberNoParameter_ecd( systems_e26, initFunctions_e28, members_e2a, subsystems_ed0, initFunctions_ed3, localVars_ed6);
	_system_e3b->insert( _system_e3b->end(), subsystems_ed0.begin(), subsystems_ed0.end());
	_initFunction_e3c->insert( _initFunction_e3c->end(), initFunctions_ed3.begin(), initFunctions_ed3.end());
	_classStruct_e3d->insert( _classStruct_e3d->end(), localVars_ed6.begin(), localVars_ed6.end());
	if( isMatchMemberNoParameter_ecd)
		return;
}

bool Test_e25::isInputUnique( const Udm::Object& system_e40, const Udm::Object& initFunction_e47, const Udm::Object& member_e4e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itsystem_e42= _system_e3e.begin(), itinitFunction_e49= _initFunction_e45.begin(), itmember_e50= _member_e4c.begin(); itsystem_e42!= _system_e3e.end(), itinitFunction_e49!= _initFunction_e45.end(), itmember_e50!= _member_e4c.end(); ++itsystem_e42, ++itinitFunction_e49, ++itmember_e50)
	{
		if( ( *itsystem_e42== system_e40)&& ( *itinitFunction_e49== initFunction_e47)&& ( *itmember_e50== member_e4e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_system_e3e.push_back( system_e40);
		_initFunction_e45.push_back( initFunction_e47);
		_member_e4c.push_back( member_e4e);
	}
	return isUnique;
}

bool MemberHasParameter_e53::operator()( const Packets_t& subsystem1s_e54, const Packets_t& initFunctions_e57, const Packets_t& localVars_e5a, Packets_t& subsystem1s_e56, Packets_t& initFunctions_e59, Packets_t& localVars_e5c)
{
#ifdef PRINT_INFO
	printLog( "MemberHasParameter_e53" );
#endif
	_subsystem1_e5d= &subsystem1s_e56;
	_initFunction_e5e= &initFunctions_e59;
	_localVar_e5f= &localVars_e5c;
	processInputPackets( subsystem1s_e54, initFunctions_e57, localVars_e5a);
	if( false== _matches.empty())
		return true;
	return false;
}

bool MemberHasParameter_e53::isInputUnique( const Udm::Object& subsystem1_e64, const Udm::Object& initFunction_e6d, const Udm::Object& localVar_e76)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem1_e66= _subsystem1_e60.begin(), itInitFunction_e6f= _initFunction_e69.begin(), itLocalVar_e78= _localVar_e72.begin(); itSubsystem1_e66!= _subsystem1_e60.end(), itInitFunction_e6f!= _initFunction_e69.end(), itLocalVar_e78!= _localVar_e72.end(); ++itSubsystem1_e66, ++itInitFunction_e6f, ++itLocalVar_e78)
	{
		if( ( *itSubsystem1_e66== subsystem1_e64)&& ( *itInitFunction_e6f== initFunction_e6d)&& ( *itLocalVar_e78== localVar_e76))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem1_e60.push_back( subsystem1_e64);
		_initFunction_e69.push_back( initFunction_e6d);
		_localVar_e72.push_back( localVar_e76);
	}
	return isUnique;
}

bool MemberHasParameter_e53::isGuardTrue( SFC::Function& InitFunction, SFC::LocalVar& LocalVar, CyberComposition::Simulink::SF_Parameter& Parameter, CyberComposition::Simulink::Primitive& Primitive, CyberComposition::Simulink::Subsystem& Subsystem1, CyberComposition::Simulink::Subsystem& Subsystem2)
{
	bool Gz_guard= false;
	return (Subsystem1 == Subsystem2);;
	return Gz_guard;
}

void MemberHasParameter_e53::processInputPackets( const Packets_t& subsystem1s_e54, const Packets_t& initFunctions_e57, const Packets_t& localVars_e5a)
{
	for( Packets_t::const_iterator itSubsystem1_e61= subsystem1s_e54.begin(), itInitFunction_e6a= initFunctions_e57.begin(), itLocalVar_e73= localVars_e5a.begin(); itSubsystem1_e61!= subsystem1s_e54.end(), itInitFunction_e6a!= initFunctions_e57.end(), itLocalVar_e73!= localVars_e5a.end(); ++itSubsystem1_e61, ++itInitFunction_e6a, ++itLocalVar_e73)
	{
		bool isUnique= isInputUnique( *itSubsystem1_e61, *itInitFunction_e6a, *itLocalVar_e73);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem1_e61, *itInitFunction_e6a, *itLocalVar_e73);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem1_e83, currMatch.initFunction_e84, currMatch.localVar_e85);
	}
}

bool MemberHasParameter_e53::patternMatcher( const Udm::Object& subsystem1_e62, const Udm::Object& initFunction_e6b, const Udm::Object& localVar_e74)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem1_e62.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem1_e67= CyberComposition::Simulink::Subsystem::Cast( subsystem1_e62);
		if( false== Uml::IsDerivedFrom( initFunction_e6b.type(), SFC::Function::meta))
			continue;
		SFC::Function initFunction_e70= SFC::Function::Cast( initFunction_e6b);
		if( false== Uml::IsDerivedFrom( localVar_e74.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_e79= SFC::LocalVar::Cast( localVar_e74);
		set< CyberComposition::Simulink::SF_Parameter> parameters_e7b= localVar_e79.param();
		for( set< CyberComposition::Simulink::SF_Parameter>::const_iterator itParameters_e7c= parameters_e7b.begin(); itParameters_e7c!= parameters_e7b.end(); ++itParameters_e7c)
		{
			CyberComposition::Simulink::SF_Parameter currParameter_e7d= *itParameters_e7c;
			Udm::Object parameterParent_e7e= currParameter_e7d.container();
			if( false== Uml::IsDerivedFrom( parameterParent_e7e.type(), CyberComposition::Simulink::Primitive::meta))
				continue;
			CyberComposition::Simulink::Primitive primitiveParameter_e7f= CyberComposition::Simulink::Primitive::Cast( parameterParent_e7e);
			Udm::Object primitiveParent_e80= primitiveParameter_e7f.container();
			if( false== Uml::IsDerivedFrom( primitiveParent_e80.type(), CyberComposition::Simulink::Subsystem::meta))
				continue;
			CyberComposition::Simulink::Subsystem subsystem2Primitive_e81= CyberComposition::Simulink::Subsystem::Cast( primitiveParent_e80);
			Match currMatch;
			currMatch.subsystem1_e83= subsystem1_e67;
			currMatch.initFunction_e84= initFunction_e70;
			currMatch.localVar_e85= localVar_e79;
			currMatch.subsystem2_e86= subsystem2Primitive_e81;
			currMatch.primitive_e87= primitiveParameter_e7f;
			currMatch.parameter_e88= currParameter_e7d;
			bool Gz_guard= isGuardTrue( currMatch.initFunction_e84, currMatch.localVar_e85, currMatch.parameter_e88, currMatch.primitive_e87, currMatch.subsystem1_e83, currMatch.subsystem2_e86);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void MemberHasParameter_e53::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem1_e8f, const SFC::Function& initFunction_e91, const SFC::LocalVar& localVar_e93)
{
	_subsystem1_e5d->push_back( subsystem1_e8f);
	_initFunction_e5e->push_back( initFunction_e91);
	_localVar_e5f->push_back( localVar_e93);
}

bool StructMember_e95::operator()( const Packets_t& subsystems_e96, const Packets_t& initFunctions_e99, const Packets_t& localVars_e9c, Packets_t& subsystems_e98, Packets_t& initFunctions_e9b, Packets_t& localVars_e9e)
{
#ifdef PRINT_INFO
	printLog( "StructMember_e95" );
#endif
	_subsystem_e9f= &subsystems_e98;
	_initFunction_ea0= &initFunctions_e9b;
	_localVar_ea1= &localVars_e9e;
	processInputPackets( subsystems_e96, initFunctions_e99, localVars_e9c);
	if( false== _matches.empty())
		return true;
	return false;
}

bool StructMember_e95::isInputUnique( const Udm::Object& subsystem_ea6, const Udm::Object& initFunction_eaf, const Udm::Object& localVar_eb8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_ea8= _subsystem_ea2.begin(), itInitFunction_eb1= _initFunction_eab.begin(), itLocalVar_eba= _localVar_eb4.begin(); itSubsystem_ea8!= _subsystem_ea2.end(), itInitFunction_eb1!= _initFunction_eab.end(), itLocalVar_eba!= _localVar_eb4.end(); ++itSubsystem_ea8, ++itInitFunction_eb1, ++itLocalVar_eba)
	{
		if( ( *itSubsystem_ea8== subsystem_ea6)&& ( *itInitFunction_eb1== initFunction_eaf)&& ( *itLocalVar_eba== localVar_eb8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_ea2.push_back( subsystem_ea6);
		_initFunction_eab.push_back( initFunction_eaf);
		_localVar_eb4.push_back( localVar_eb8);
	}
	return isUnique;
}

bool StructMember_e95::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void StructMember_e95::processInputPackets( const Packets_t& subsystems_e96, const Packets_t& initFunctions_e99, const Packets_t& localVars_e9c)
{
	for( Packets_t::const_iterator itSubsystem_ea3= subsystems_e96.begin(), itInitFunction_eac= initFunctions_e99.begin(), itLocalVar_eb5= localVars_e9c.begin(); itSubsystem_ea3!= subsystems_e96.end(), itInitFunction_eac!= initFunctions_e99.end(), itLocalVar_eb5!= localVars_e9c.end(); ++itSubsystem_ea3, ++itInitFunction_eac, ++itLocalVar_eb5)
	{
		bool isUnique= isInputUnique( *itSubsystem_ea3, *itInitFunction_eac, *itLocalVar_eb5);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_ea3, *itInitFunction_eac, *itLocalVar_eb5);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_ec3, currMatch.initFunction_ec4, currMatch.localVar_ec5);
	}
}

bool StructMember_e95::patternMatcher( const Udm::Object& subsystem_ea4, const Udm::Object& initFunction_ead, const Udm::Object& localVar_eb6)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_ea4.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_ea9= CyberComposition::Simulink::Subsystem::Cast( subsystem_ea4);
		if( false== Uml::IsDerivedFrom( initFunction_ead.type(), SFC::Function::meta))
			continue;
		SFC::Function initFunction_eb2= SFC::Function::Cast( initFunction_ead);
		if( false== Uml::IsDerivedFrom( localVar_eb6.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_ebb= SFC::LocalVar::Cast( localVar_eb6);
		SFC::DT struct_ebd= localVar_ebb.dt();
		if( !struct_ebd || false== Uml::IsDerivedFrom( struct_ebd.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_ebe= SFC::Struct::Cast( struct_ebd);
		if( !struct_ebe)
			continue;
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_ec2;
		if( !isValidBound(boundObjs_ec2, subsystem_ea9, true))
			continue;
		currMatch.subsystem_ec3= subsystem_ea9;
		if( !isValidBound(boundObjs_ec2, initFunction_eb2, true))
			continue;
		currMatch.initFunction_ec4= initFunction_eb2;
		if( !isValidBound(boundObjs_ec2, localVar_ebb, true))
			continue;
		currMatch.localVar_ec5= localVar_ebb;
		if( !isValidBound(boundObjs_ec2, struct_ebe, false))
			continue;
		currMatch.struct_ec6= struct_ebe;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void StructMember_e95::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_ec7, const SFC::Function& initFunction_ec9, const SFC::LocalVar& localVar_ecb)
{
	_subsystem_e9f->push_back( subsystem_ec7);
	_initFunction_ea0->push_back( initFunction_ec9);
	_localVar_ea1->push_back( localVar_ecb);
}

bool MemberNoParameter_ecd::operator()( const Packets_t& subsystems_ece, const Packets_t& initFunctions_ed1, const Packets_t& localVars_ed4, Packets_t& subsystems_ed0, Packets_t& initFunctions_ed3, Packets_t& localVars_ed6)
{
#ifdef PRINT_INFO
	printLog( "MemberNoParameter_ecd" );
#endif
	_subsystem_ed7= &subsystems_ed0;
	_initFunction_ed8= &initFunctions_ed3;
	_localVar_ed9= &localVars_ed6;
	processInputPackets( subsystems_ece, initFunctions_ed1, localVars_ed4);
	if( false== _matches.empty())
		return true;
	return false;
}

bool MemberNoParameter_ecd::isInputUnique( const Udm::Object& subsystem_ede, const Udm::Object& initFunction_ee7, const Udm::Object& localVar_ef0)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_ee0= _subsystem_eda.begin(), itInitFunction_ee9= _initFunction_ee3.begin(), itLocalVar_ef2= _localVar_eec.begin(); itSubsystem_ee0!= _subsystem_eda.end(), itInitFunction_ee9!= _initFunction_ee3.end(), itLocalVar_ef2!= _localVar_eec.end(); ++itSubsystem_ee0, ++itInitFunction_ee9, ++itLocalVar_ef2)
	{
		if( ( *itSubsystem_ee0== subsystem_ede)&& ( *itInitFunction_ee9== initFunction_ee7)&& ( *itLocalVar_ef2== localVar_ef0))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_eda.push_back( subsystem_ede);
		_initFunction_ee3.push_back( initFunction_ee7);
		_localVar_eec.push_back( localVar_ef0);
	}
	return isUnique;
}

bool MemberNoParameter_ecd::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void MemberNoParameter_ecd::processInputPackets( const Packets_t& subsystems_ece, const Packets_t& initFunctions_ed1, const Packets_t& localVars_ed4)
{
	for( Packets_t::const_iterator itSubsystem_edb= subsystems_ece.begin(), itInitFunction_ee4= initFunctions_ed1.begin(), itLocalVar_eed= localVars_ed4.begin(); itSubsystem_edb!= subsystems_ece.end(), itInitFunction_ee4!= initFunctions_ed1.end(), itLocalVar_eed!= localVars_ed4.end(); ++itSubsystem_edb, ++itInitFunction_ee4, ++itLocalVar_eed)
	{
		bool isUnique= isInputUnique( *itSubsystem_edb, *itInitFunction_ee4, *itLocalVar_eed);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_edb, *itInitFunction_ee4, *itLocalVar_eed);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_ef9, currMatch.initFunction_efa, currMatch.localVar_efb);
	}
}

bool MemberNoParameter_ecd::patternMatcher( const Udm::Object& subsystem_edc, const Udm::Object& initFunction_ee5, const Udm::Object& localVar_eee)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_edc.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_ee1= CyberComposition::Simulink::Subsystem::Cast( subsystem_edc);
		if( false== Uml::IsDerivedFrom( initFunction_ee5.type(), SFC::Function::meta))
			continue;
		SFC::Function initFunction_eea= SFC::Function::Cast( initFunction_ee5);
		if( false== Uml::IsDerivedFrom( localVar_eee.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_ef3= SFC::LocalVar::Cast( localVar_eee);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_ef8;
		if( !isValidBound(boundObjs_ef8, subsystem_ee1, true))
			continue;
		currMatch.subsystem_ef9= subsystem_ee1;
		if( !isValidBound(boundObjs_ef8, initFunction_eea, true))
			continue;
		currMatch.initFunction_efa= initFunction_eea;
		if( !isValidBound(boundObjs_ef8, localVar_ef3, true))
			continue;
		currMatch.localVar_efb= localVar_ef3;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void MemberNoParameter_ecd::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_efc, const SFC::Function& initFunction_efe, const SFC::LocalVar& localVar_f00)
{
	_subsystem_ed7->push_back( subsystem_efc);
	_initFunction_ed8->push_back( initFunction_efe);
	_localVar_ed9->push_back( localVar_f00);
}

void InitPrimitiveParameter_f02::operator()( const Packets_t& subsystem1s_f03, const Packets_t& initFunctions_f05, const Packets_t& localVars_f07)
{
#ifdef PRINT_INFO
	printLog( "InitPrimitiveParameter_f02" );
#endif
	RTTGenerator::Instance()->generateRule(735, "initPrimitiveParameter");
	processInputPackets( subsystem1s_f03, initFunctions_f05, localVars_f07);
}

bool InitPrimitiveParameter_f02::isInputUnique( const Udm::Object& subsystem1_f0d, const Udm::Object& initFunction_f16, const Udm::Object& localVar_f1f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem1_f0f= _subsystem1_f09.begin(), itInitFunction_f18= _initFunction_f12.begin(), itLocalVar_f21= _localVar_f1b.begin(); itSubsystem1_f0f!= _subsystem1_f09.end(), itInitFunction_f18!= _initFunction_f12.end(), itLocalVar_f21!= _localVar_f1b.end(); ++itSubsystem1_f0f, ++itInitFunction_f18, ++itLocalVar_f21)
	{
		if( ( *itSubsystem1_f0f== subsystem1_f0d)&& ( *itInitFunction_f18== initFunction_f16)&& ( *itLocalVar_f21== localVar_f1f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem1_f09.push_back( subsystem1_f0d);
		_initFunction_f12.push_back( initFunction_f16);
		_localVar_f1b.push_back( localVar_f1f);
	}
	return isUnique;
}

bool InitPrimitiveParameter_f02::isGuardTrue( SFC::Function& InitFunction, SFC::LocalVar& LocalVar, CyberComposition::Simulink::SF_Parameter& Parameter, CyberComposition::Simulink::Primitive& Primitive, CyberComposition::Simulink::Subsystem& Subsystem1, CyberComposition::Simulink::Subsystem& Subsystem2)
{
	bool Gz_guard= false;
	return (Subsystem1 == Subsystem2);;
	return Gz_guard;
}

void InitPrimitiveParameter_f02::processInputPackets( const Packets_t& subsystem1s_f03, const Packets_t& initFunctions_f05, const Packets_t& localVars_f07)
{
	for( Packets_t::const_iterator itSubsystem1_f0a= subsystem1s_f03.begin(), itInitFunction_f13= initFunctions_f05.begin(), itLocalVar_f1c= localVars_f07.begin(); itSubsystem1_f0a!= subsystem1s_f03.end(), itInitFunction_f13!= initFunctions_f05.end(), itLocalVar_f1c!= localVars_f07.end(); ++itSubsystem1_f0a, ++itInitFunction_f13, ++itLocalVar_f1c)
	{
		bool isUnique= isInputUnique( *itSubsystem1_f0a, *itInitFunction_f13, *itLocalVar_f1c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem1_f0a, *itInitFunction_f13, *itLocalVar_f1c);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InitPrimitiveParameter_f02::patternMatcher( const Udm::Object& subsystem1_f0b, const Udm::Object& initFunction_f14, const Udm::Object& localVar_f1d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem1_f0b.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem1_f10= CyberComposition::Simulink::Subsystem::Cast( subsystem1_f0b);
		if( false== Uml::IsDerivedFrom( initFunction_f14.type(), SFC::Function::meta))
			continue;
		SFC::Function initFunction_f19= SFC::Function::Cast( initFunction_f14);
		if( false== Uml::IsDerivedFrom( localVar_f1d.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_f22= SFC::LocalVar::Cast( localVar_f1d);
		set< CyberComposition::Simulink::SF_Parameter> parameters_f24= localVar_f22.param();
		for( set< CyberComposition::Simulink::SF_Parameter>::const_iterator itParameters_f25= parameters_f24.begin(); itParameters_f25!= parameters_f24.end(); ++itParameters_f25)
		{
			CyberComposition::Simulink::SF_Parameter currParameter_f26= *itParameters_f25;
			Udm::Object parameterParent_f27= currParameter_f26.container();
			if( false== Uml::IsDerivedFrom( parameterParent_f27.type(), CyberComposition::Simulink::Primitive::meta))
				continue;
			CyberComposition::Simulink::Primitive primitiveParameter_f28= CyberComposition::Simulink::Primitive::Cast( parameterParent_f27);
			Udm::Object primitiveParent_f29= primitiveParameter_f28.container();
			if( false== Uml::IsDerivedFrom( primitiveParent_f29.type(), CyberComposition::Simulink::Subsystem::meta))
				continue;
			CyberComposition::Simulink::Subsystem subsystem2Primitive_f2a= CyberComposition::Simulink::Subsystem::Cast( primitiveParent_f29);
			Match currMatch;
			currMatch.subsystem1_f2c= subsystem1_f10;
			currMatch.initFunction_f2d= initFunction_f19;
			currMatch.localVar_f2e= localVar_f22;
			currMatch.subsystem2_f2f= subsystem2Primitive_f2a;
			currMatch.primitive_f30= primitiveParameter_f28;
			currMatch.parameter_f31= currParameter_f26;
			bool Gz_guard= isGuardTrue( currMatch.initFunction_f2d, currMatch.localVar_f2e, currMatch.parameter_f31, currMatch.primitive_f30, currMatch.subsystem1_f2c, currMatch.subsystem2_f2f);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void InitPrimitiveParameter_f02::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function& InitFunction= currMatch.initFunction_f2d;
		SFC::LocalVar& LocalVar= currMatch.localVar_f2e;
		CyberComposition::Simulink::SF_Parameter& Parameter= currMatch.parameter_f31;
		CyberComposition::Simulink::Primitive& Primitive= currMatch.primitive_f30;
		CyberComposition::Simulink::Subsystem& Subsystem1= currMatch.subsystem1_f2c;
		CyberComposition::Simulink::Subsystem& Subsystem2= currMatch.subsystem2_f2f;
		{
SFUtils::InitParameter( InitFunction, Parameter, LocalVar );
};
	}
}

void InitTriggerVars_f48::operator()( const Packets_t& systems_f49, const Packets_t& initFunctions_f4b, const Packets_t& classStructs_f4d)
{
#ifdef PRINT_INFO
	printLog( "InitTriggerVars_f48" );
#endif
	if( ( !systems_f49.empty())&& ( !initFunctions_f4b.empty())&& ( !classStructs_f4d.empty()))
		callInitMatrixTrigger_ffd( systems_f49, initFunctions_f4b, classStructs_f4d);
}

void InitTriggerVars_f48::callInitMatrixTrigger_ffd( const Packets_t& systems_fa4, const Packets_t& initFunctions_fa6, const Packets_t& classStructs_fa8)
{
	Packets_t outs_faa;
	Packets_t initFunctions_fab;
	Packets_t classStructs_fac;
	InitMatrixTrigger_fa3 initMatrixTrigger_fa3;
	initMatrixTrigger_fa3( systems_fa4, initFunctions_fa6, classStructs_fa8, outs_faa, initFunctions_fab, classStructs_fac);
	if( ( !outs_faa.empty())&& ( !initFunctions_fab.empty())&& ( !classStructs_fac.empty()))
		callInitStructTrigger_1001( outs_faa, initFunctions_fab, classStructs_fac);
}

void InitTriggerVars_f48::callInitStructTrigger_1001( const Packets_t& systems_f50, const Packets_t& initFunctions_f52, const Packets_t& classStructs_f54)
{
	InitStructTrigger_f4f initStructTrigger_f4f;
	initStructTrigger_f4f( systems_f50, initFunctions_f52, classStructs_f54);
}

void InitStructTrigger_f4f::operator()( const Packets_t& systems_f50, const Packets_t& initFunctions_f52, const Packets_t& classStructs_f54)
{
#ifdef PRINT_INFO
	printLog( "InitStructTrigger_f4f" );
#endif
	if( ( !systems_f50.empty())&& ( !initFunctions_f52.empty())&& ( !classStructs_f54.empty()))
		callInitStructTrigger_f9f( systems_f50, initFunctions_f52, classStructs_f54);
}

void InitStructTrigger_f4f::callInitStructTrigger_f9f( const Packets_t& subsystems_f57, const Packets_t& initFunctions_f59, const Packets_t& classStructs_f5b)
{
	InitStructTrigger_f56 initStructTrigger_f56;
	initStructTrigger_f56( subsystems_f57, initFunctions_f59, classStructs_f5b);
}

void InitStructTrigger_f56::operator()( const Packets_t& subsystems_f57, const Packets_t& initFunctions_f59, const Packets_t& classStructs_f5b)
{
#ifdef PRINT_INFO
	printLog( "InitStructTrigger_f56" );
#endif
	RTTGenerator::Instance()->generateRule(754, "InitStructTrigger");
	processInputPackets( subsystems_f57, initFunctions_f59, classStructs_f5b);
}

bool InitStructTrigger_f56::isInputUnique( const Udm::Object& subsystem_f61, const Udm::Object& initFunction_f6a, const Udm::Object& classStruct_f73)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_f63= _subsystem_f5d.begin(), itInitFunction_f6c= _initFunction_f66.begin(), itClassStruct_f75= _classStruct_f6f.begin(); itSubsystem_f63!= _subsystem_f5d.end(), itInitFunction_f6c!= _initFunction_f66.end(), itClassStruct_f75!= _classStruct_f6f.end(); ++itSubsystem_f63, ++itInitFunction_f6c, ++itClassStruct_f75)
	{
		if( ( *itSubsystem_f63== subsystem_f61)&& ( *itInitFunction_f6c== initFunction_f6a)&& ( *itClassStruct_f75== classStruct_f73))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_f5d.push_back( subsystem_f61);
		_initFunction_f66.push_back( initFunction_f6a);
		_classStruct_f6f.push_back( classStruct_f73);
	}
	return isUnique;
}

bool InitStructTrigger_f56::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void InitStructTrigger_f56::processInputPackets( const Packets_t& subsystems_f57, const Packets_t& initFunctions_f59, const Packets_t& classStructs_f5b)
{
	for( Packets_t::const_iterator itSubsystem_f5e= subsystems_f57.begin(), itInitFunction_f67= initFunctions_f59.begin(), itClassStruct_f70= classStructs_f5b.begin(); itSubsystem_f5e!= subsystems_f57.end(), itInitFunction_f67!= initFunctions_f59.end(), itClassStruct_f70!= classStructs_f5b.end(); ++itSubsystem_f5e, ++itInitFunction_f67, ++itClassStruct_f70)
	{
		bool isUnique= isInputUnique( *itSubsystem_f5e, *itInitFunction_f67, *itClassStruct_f70);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_f5e, *itInitFunction_f67, *itClassStruct_f70);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InitStructTrigger_f56::patternMatcher( const Udm::Object& subsystem_f5f, const Udm::Object& initFunction_f68, const Udm::Object& classStruct_f71)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_f5f.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_f64= CyberComposition::Simulink::Subsystem::Cast( subsystem_f5f);
		if( false== Uml::IsDerivedFrom( initFunction_f68.type(), SFC::Function::meta))
			continue;
		SFC::Function initFunction_f6d= SFC::Function::Cast( initFunction_f68);
		if( false== Uml::IsDerivedFrom( classStruct_f71.type(), SFC::Struct::meta))
			continue;
		SFC::Struct classStruct_f76= SFC::Struct::Cast( classStruct_f71);
		set< SFC::LocalVar> localVars_f78= classStruct_f76.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itLocalVar_f79= localVars_f78.begin(); itLocalVar_f79!= localVars_f78.end(); ++itLocalVar_f79)
		{
			SFC::LocalVar currLocalVar_f7a= *itLocalVar_f79;
			set< CyberComposition::Simulink::TriggerPort> triggerPorts_f7b= subsystem_f64.TriggerPort_kind_children();
			for( set< CyberComposition::Simulink::TriggerPort>::const_iterator itTriggerPort_f7c= triggerPorts_f7b.begin(); itTriggerPort_f7c!= triggerPorts_f7b.end(); ++itTriggerPort_f7c)
			{
				CyberComposition::Simulink::TriggerPort currTriggerPort_f7d= *itTriggerPort_f7c;
				set< CyberComposition::Simulink::TriggerPort> triggerPorts_f7e= currLocalVar_f7a.trig();
				for( set< CyberComposition::Simulink::TriggerPort>::const_iterator itTriggerPorts_f7f= triggerPorts_f7e.begin(); itTriggerPorts_f7f!= triggerPorts_f7e.end(); ++itTriggerPorts_f7f)
				{
					CyberComposition::Simulink::TriggerPort currTriggerPort_f80= *itTriggerPorts_f7f;
					if( currTriggerPort_f7d!= currTriggerPort_f80)
						continue;
					set< SFC::Arg> args_f81= initFunction_f6d.Arg_kind_children();
					for( set< SFC::Arg>::const_iterator itArg_f82= args_f81.begin(); itArg_f82!= args_f81.end(); ++itArg_f82)
					{
						SFC::Arg currArg_f83= *itArg_f82;
						SFC::DT classStruct_f84= currArg_f83.dt();
						if( !classStruct_f84 || false== Uml::IsDerivedFrom( classStruct_f84.type(), SFC::Struct::meta))
							continue;
						SFC::Struct classStruct_f85= SFC::Struct::Cast( classStruct_f84);
						if( !classStruct_f85)
							continue;
						if( classStruct_f76!= classStruct_f85)
							continue;
						SFC::DT struct_f86= currLocalVar_f7a.dt();
						if(!struct_f86 || false== Uml::IsDerivedFrom( struct_f86.type(), SFC::Struct::meta))
							continue;
						SFC::Struct struct_f87= SFC::Struct::Cast( struct_f86);
						if( !struct_f87)
							continue;
						set< SFC::LocalVar> members_f88= struct_f87.LocalVar_kind_children();
						for( set< SFC::LocalVar>::const_iterator itMember_f89= members_f88.begin(); itMember_f89!= members_f88.end(); ++itMember_f89)
						{
							SFC::LocalVar currMember_f8a= *itMember_f89;
							Match currMatch;
							set< pair<int, Udm::Object> > boundObjs_f8e;
							if( !isValidBound(boundObjs_f8e, subsystem_f64, true))
								continue;
							currMatch.subsystem_f8f= subsystem_f64;
							if( !isValidBound(boundObjs_f8e, initFunction_f6d, true))
								continue;
							currMatch.initFunction_f90= initFunction_f6d;
							if( !isValidBound(boundObjs_f8e, classStruct_f76, true))
								continue;
							currMatch.classStruct_f91= classStruct_f76;
							if( !isValidBound(boundObjs_f8e, currTriggerPort_f7d, false))
								continue;
							currMatch.triggerPort_f92= currTriggerPort_f7d;
							if( !isValidBound(boundObjs_f8e, currArg_f83, false))
								continue;
							currMatch.arg_f93= currArg_f83;
							if( !isValidBound(boundObjs_f8e, currMember_f8a, false))
								continue;
							currMatch.member_f94= currMember_f8a;
							if( !isValidBound(boundObjs_f8e, currLocalVar_f7a, false))
								continue;
							currMatch.localVar_f95= currLocalVar_f7a;
							if( !isValidBound(boundObjs_f8e, struct_f87, false))
								continue;
							currMatch.struct_f96= struct_f87;
							_matches.push_back( currMatch);
						}
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void InitStructTrigger_f56::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newUserCode_f97= SFC::UserCode::Create( currMatch.initFunction_f90, SFC::Function::meta_stmnt);
		SFC::BinaryExprs newAssign_f98= SFC::BinaryExprs::Create( newUserCode_f97, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newDot2_f99= SFC::BinaryExprs::Create( newAssign_f98, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef3_f9a= SFC::ArgDeclRef::Create( newDot2_f99, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newDot_f9b= SFC::BinaryExprs::Create( newDot2_f99, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef_f9c= SFC::ArgDeclRef::Create( newDot_f9b, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_f9d= SFC::ArgDeclRef::Create( newDot_f9b, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newZero_f9e= SFC::Int::Create( newAssign_f98, SFC::BinaryExprs::meta_rightexpr);
		SFC::Arg& Arg= currMatch.arg_f93;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_f9c;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_f9d;
		SFC::ArgDeclRef& ArgDeclRef3= newArgDeclRef3_f9a;
		SFC::BinaryExprs& Assign= newAssign_f98;
		SFC::Struct& ClassStruct= currMatch.classStruct_f91;
		SFC::BinaryExprs& Dot= newDot_f9b;
		SFC::BinaryExprs& Dot2= newDot2_f99;
		SFC::Function& InitFunction= currMatch.initFunction_f90;
		SFC::LocalVar& LocalVar= currMatch.localVar_f95;
		SFC::LocalVar& Member= currMatch.member_f94;
		SFC::Struct& Struct= currMatch.struct_f96;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_f8f;
		CyberComposition::Simulink::TriggerPort& TriggerPort= currMatch.triggerPort_f92;
		SFC::UserCode& UserCode= newUserCode_f97;
		SFC::Int& Zero= newZero_f9e;
		{
__int64 statementCount = InitFunction.statementCount();
UserCode.statementIndex() = statementCount++;
InitFunction.statementCount() = statementCount;
};
		{
Dot2.op() = ".";
};
		{
Dot.op() = ".";
};
		{
Assign.op() = "=";
};
		{
Zero.val() = 0;
};
		newArgDeclRef3_f9a.argdecl()= currMatch.member_f94;
		newArgDeclRef_f9c.argdecl()= currMatch.arg_f93;
		newArgDeclRef2_f9d.argdecl()= currMatch.localVar_f95;
	}
}

void InitMatrixTrigger_fa3::operator()( const Packets_t& systems_fa4, const Packets_t& initFunctions_fa6, const Packets_t& classStructs_fa8, Packets_t& outs_faa, Packets_t& initFunctions_fab, Packets_t& classStructs_fac)
{
#ifdef PRINT_INFO
	printLog( "InitMatrixTrigger_fa3" );
#endif
	_out_fad= &outs_faa;
	_initFunction_fae= &initFunctions_fab;
	_classStruct_faf= &classStructs_fac;
	if( ( !systems_fa4.empty())&& ( !initFunctions_fa6.empty())&& ( !classStructs_fa8.empty()))
		callInitMatrixTrigger_ff9( systems_fa4, initFunctions_fa6, classStructs_fa8);
	_out_fad->insert( _out_fad->end(), systems_fa4.begin(), systems_fa4.end());
	_initFunction_fae->insert( _initFunction_fae->end(), initFunctions_fa6.begin(), initFunctions_fa6.end());
	_classStruct_faf->insert( _classStruct_faf->end(), classStructs_fa8.begin(), classStructs_fa8.end());
}

void InitMatrixTrigger_fa3::callInitMatrixTrigger_ff9( const Packets_t& subsystems_fb1, const Packets_t& initFunctions_fb3, const Packets_t& classStructs_fb5)
{
	InitMatrixTrigger_fb0 initMatrixTrigger_fb0;
	initMatrixTrigger_fb0( subsystems_fb1, initFunctions_fb3, classStructs_fb5);
}

void InitMatrixTrigger_fb0::operator()( const Packets_t& subsystems_fb1, const Packets_t& initFunctions_fb3, const Packets_t& classStructs_fb5)
{
#ifdef PRINT_INFO
	printLog( "InitMatrixTrigger_fb0" );
#endif
	RTTGenerator::Instance()->generateRule(801, "InitMatrixTrigger");
	processInputPackets( subsystems_fb1, initFunctions_fb3, classStructs_fb5);
}

bool InitMatrixTrigger_fb0::isInputUnique( const Udm::Object& subsystem_fbb, const Udm::Object& initFunction_fc4, const Udm::Object& classStruct_fcd)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_fbd= _subsystem_fb7.begin(), itInitFunction_fc6= _initFunction_fc0.begin(), itClassStruct_fcf= _classStruct_fc9.begin(); itSubsystem_fbd!= _subsystem_fb7.end(), itInitFunction_fc6!= _initFunction_fc0.end(), itClassStruct_fcf!= _classStruct_fc9.end(); ++itSubsystem_fbd, ++itInitFunction_fc6, ++itClassStruct_fcf)
	{
		if( ( *itSubsystem_fbd== subsystem_fbb)&& ( *itInitFunction_fc6== initFunction_fc4)&& ( *itClassStruct_fcf== classStruct_fcd))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_fb7.push_back( subsystem_fbb);
		_initFunction_fc0.push_back( initFunction_fc4);
		_classStruct_fc9.push_back( classStruct_fcd);
	}
	return isUnique;
}

bool InitMatrixTrigger_fb0::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool InitMatrixTrigger_fb0::isGuardTrue( SFC::Arg& Arg, SFC::Struct& ClassStruct, SFC::DT& DT, SFC::Function& InitFunction, SFC::LocalVar& LocalVar, CyberComposition::Simulink::Subsystem& Subsystem, CyberComposition::Simulink::TriggerPort& TriggerPort)
{
	bool Gz_guard= false;
	Gz_guard = DT.type() != SFC::Struct::meta;;
	return Gz_guard;
}

void InitMatrixTrigger_fb0::processInputPackets( const Packets_t& subsystems_fb1, const Packets_t& initFunctions_fb3, const Packets_t& classStructs_fb5)
{
	for( Packets_t::const_iterator itSubsystem_fb8= subsystems_fb1.begin(), itInitFunction_fc1= initFunctions_fb3.begin(), itClassStruct_fca= classStructs_fb5.begin(); itSubsystem_fb8!= subsystems_fb1.end(), itInitFunction_fc1!= initFunctions_fb3.end(), itClassStruct_fca!= classStructs_fb5.end(); ++itSubsystem_fb8, ++itInitFunction_fc1, ++itClassStruct_fca)
	{
		bool isUnique= isInputUnique( *itSubsystem_fb8, *itInitFunction_fc1, *itClassStruct_fca);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_fb8, *itInitFunction_fc1, *itClassStruct_fca);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InitMatrixTrigger_fb0::patternMatcher( const Udm::Object& subsystem_fb9, const Udm::Object& initFunction_fc2, const Udm::Object& classStruct_fcb)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_fb9.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_fbe= CyberComposition::Simulink::Subsystem::Cast( subsystem_fb9);
		if( false== Uml::IsDerivedFrom( initFunction_fc2.type(), SFC::Function::meta))
			continue;
		SFC::Function initFunction_fc7= SFC::Function::Cast( initFunction_fc2);
		if( false== Uml::IsDerivedFrom( classStruct_fcb.type(), SFC::Struct::meta))
			continue;
		SFC::Struct classStruct_fd0= SFC::Struct::Cast( classStruct_fcb);
		set< SFC::Arg> args_fd2= initFunction_fc7.Arg_kind_children();
		for( set< SFC::Arg>::const_iterator itArg_fd3= args_fd2.begin(); itArg_fd3!= args_fd2.end(); ++itArg_fd3)
		{
			SFC::Arg currArg_fd4= *itArg_fd3;
			SFC::DT classStruct_fd5= currArg_fd4.dt();
			if( !classStruct_fd5 || false== Uml::IsDerivedFrom( classStruct_fd5.type(), SFC::Struct::meta))
				continue;
			SFC::Struct classStruct_fd6= SFC::Struct::Cast( classStruct_fd5);
			if( !classStruct_fd6)
				continue;
			if( classStruct_fd0!= classStruct_fd6)
				continue;
			set< CyberComposition::Simulink::TriggerPort> triggerPorts_fd7= subsystem_fbe.TriggerPort_kind_children();
			for( set< CyberComposition::Simulink::TriggerPort>::const_iterator itTriggerPort_fd8= triggerPorts_fd7.begin(); itTriggerPort_fd8!= triggerPorts_fd7.end(); ++itTriggerPort_fd8)
			{
				CyberComposition::Simulink::TriggerPort currTriggerPort_fd9= *itTriggerPort_fd8;
				set< SFC::LocalVar> localVars_fda= classStruct_fd0.LocalVar_kind_children();
				for( set< SFC::LocalVar>::const_iterator itLocalVar_fdb= localVars_fda.begin(); itLocalVar_fdb!= localVars_fda.end(); ++itLocalVar_fdb)
				{
					SFC::LocalVar currLocalVar_fdc= *itLocalVar_fdb;
					set< CyberComposition::Simulink::TriggerPort> triggerPorts_fdd= currLocalVar_fdc.trig();
					for( set< CyberComposition::Simulink::TriggerPort>::const_iterator itTriggerPorts_fde= triggerPorts_fdd.begin(); itTriggerPorts_fde!= triggerPorts_fdd.end(); ++itTriggerPorts_fde)
					{
						CyberComposition::Simulink::TriggerPort currTriggerPort_fdf= *itTriggerPorts_fde;
						if( currTriggerPort_fd9!= currTriggerPort_fdf)
							continue;
						SFC::DT dT_fe0= currLocalVar_fdc.dt();
						if( !dT_fe0)
							continue;
						Match currMatch;
						set< pair<int, Udm::Object> > boundObjs_fe4;
						if( !isValidBound(boundObjs_fe4, subsystem_fbe, true))
							continue;
						currMatch.subsystem_fe5= subsystem_fbe;
						if( !isValidBound(boundObjs_fe4, initFunction_fc7, true))
							continue;
						currMatch.initFunction_fe6= initFunction_fc7;
						if( !isValidBound(boundObjs_fe4, classStruct_fd0, true))
							continue;
						currMatch.classStruct_fe7= classStruct_fd0;
						if( !isValidBound(boundObjs_fe4, currTriggerPort_fd9, false))
							continue;
						currMatch.triggerPort_fe8= currTriggerPort_fd9;
						if( !isValidBound(boundObjs_fe4, currArg_fd4, false))
							continue;
						currMatch.arg_fe9= currArg_fd4;
						if( !isValidBound(boundObjs_fe4, currLocalVar_fdc, false))
							continue;
						currMatch.localVar_fea= currLocalVar_fdc;
						if( !isValidBound(boundObjs_fe4, dT_fe0, false))
							continue;
						currMatch.dT_feb= dT_fe0;
						bool Gz_guard= isGuardTrue( currMatch.arg_fe9, currMatch.classStruct_fe7, currMatch.dT_feb, currMatch.initFunction_fe6, currMatch.localVar_fea, currMatch.subsystem_fe5, currMatch.triggerPort_fe8);
						if( true== Gz_guard)
							_matches.push_back( currMatch);
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void InitMatrixTrigger_fb0::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newUserCode_ff3= SFC::UserCode::Create( currMatch.initFunction_fe6, SFC::Function::meta_stmnt);
		SFC::BinaryExprs newAssign_ff4= SFC::BinaryExprs::Create( newUserCode_ff3, SFC::UserCode::meta_codeexpr);
		SFC::Int newZero_ff5= SFC::Int::Create( newAssign_ff4, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newDot_ff6= SFC::BinaryExprs::Create( newAssign_ff4, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_ff7= SFC::ArgDeclRef::Create( newDot_ff6, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_ff8= SFC::ArgDeclRef::Create( newDot_ff6, SFC::BinaryExprs::meta_leftexpr);
		SFC::Arg& Arg= currMatch.arg_fe9;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_ff8;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_ff7;
		SFC::BinaryExprs& Assign= newAssign_ff4;
		SFC::Struct& ClassStruct= currMatch.classStruct_fe7;
		SFC::DT& DT= currMatch.dT_feb;
		SFC::BinaryExprs& Dot= newDot_ff6;
		SFC::Function& InitFunction= currMatch.initFunction_fe6;
		SFC::LocalVar& LocalVar= currMatch.localVar_fea;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_fe5;
		CyberComposition::Simulink::TriggerPort& TriggerPort= currMatch.triggerPort_fe8;
		SFC::UserCode& UserCode= newUserCode_ff3;
		SFC::Int& Zero= newZero_ff5;
		{
__int64 statementCount = InitFunction.statementCount();
UserCode.statementIndex() = statementCount++;
InitFunction.statementCount() = statementCount;
};
		{
Zero.val() = 0;
};
		{
Assign.op() = "=";
};
		{
Dot.op() = ".";
};
		newArgDeclRef2_ff7.argdecl()= currMatch.localVar_fea;
		newArgDeclRef_ff8.argdecl()= currMatch.arg_fe9;
	}
}

void InitDirectParameters_1005::operator()( const Packets_t& systems_1006, const Packets_t& initFunctions_1008, const Packets_t& classStructs_100a, Packets_t& systems_100c, Packets_t& initFunctions_100d, Packets_t& classStructs_100e)
{
#ifdef PRINT_INFO
	printLog( "InitDirectParameters_1005" );
#endif
	_system_100f= &systems_100c;
	_initFunction_1010= &initFunctions_100d;
	_classStruct_1011= &classStructs_100e;
	if( ( !systems_1006.empty())&& ( !initFunctions_1008.empty())&& ( !classStructs_100a.empty()))
		callinitDirectParameter_1046( systems_1006, initFunctions_1008, classStructs_100a);
	_system_100f->insert( _system_100f->end(), systems_1006.begin(), systems_1006.end());
	_initFunction_1010->insert( _initFunction_1010->end(), initFunctions_1008.begin(), initFunctions_1008.end());
	_classStruct_1011->insert( _classStruct_1011->end(), classStructs_100a.begin(), classStructs_100a.end());
}

void InitDirectParameters_1005::callinitDirectParameter_1046( const Packets_t& subsystems_1013, const Packets_t& initFunctions_1015, const Packets_t& classStructs_1017)
{
	InitDirectParameter_1012 initDirectParameter_1012;
	initDirectParameter_1012( subsystems_1013, initFunctions_1015, classStructs_1017);
}

void InitDirectParameter_1012::operator()( const Packets_t& subsystems_1013, const Packets_t& initFunctions_1015, const Packets_t& classStructs_1017)
{
#ifdef PRINT_INFO
	printLog( "InitDirectParameter_1012" );
#endif
	RTTGenerator::Instance()->generateRule(840, "initDirectParameter");
	processInputPackets( subsystems_1013, initFunctions_1015, classStructs_1017);
}

bool InitDirectParameter_1012::isInputUnique( const Udm::Object& subsystem_101d, const Udm::Object& initFunction_1026, const Udm::Object& classStruct_102f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_101f= _subsystem_1019.begin(), itInitFunction_1028= _initFunction_1022.begin(), itClassStruct_1031= _classStruct_102b.begin(); itSubsystem_101f!= _subsystem_1019.end(), itInitFunction_1028!= _initFunction_1022.end(), itClassStruct_1031!= _classStruct_102b.end(); ++itSubsystem_101f, ++itInitFunction_1028, ++itClassStruct_1031)
	{
		if( ( *itSubsystem_101f== subsystem_101d)&& ( *itInitFunction_1028== initFunction_1026)&& ( *itClassStruct_1031== classStruct_102f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1019.push_back( subsystem_101d);
		_initFunction_1022.push_back( initFunction_1026);
		_classStruct_102b.push_back( classStruct_102f);
	}
	return isUnique;
}

bool InitDirectParameter_1012::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void InitDirectParameter_1012::processInputPackets( const Packets_t& subsystems_1013, const Packets_t& initFunctions_1015, const Packets_t& classStructs_1017)
{
	for( Packets_t::const_iterator itSubsystem_101a= subsystems_1013.begin(), itInitFunction_1023= initFunctions_1015.begin(), itClassStruct_102c= classStructs_1017.begin(); itSubsystem_101a!= subsystems_1013.end(), itInitFunction_1023!= initFunctions_1015.end(), itClassStruct_102c!= classStructs_1017.end(); ++itSubsystem_101a, ++itInitFunction_1023, ++itClassStruct_102c)
	{
		bool isUnique= isInputUnique( *itSubsystem_101a, *itInitFunction_1023, *itClassStruct_102c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_101a, *itInitFunction_1023, *itClassStruct_102c);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InitDirectParameter_1012::patternMatcher( const Udm::Object& subsystem_101b, const Udm::Object& initFunction_1024, const Udm::Object& classStruct_102d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_101b.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1020= CyberComposition::Simulink::Subsystem::Cast( subsystem_101b);
		if( false== Uml::IsDerivedFrom( initFunction_1024.type(), SFC::Function::meta))
			continue;
		SFC::Function initFunction_1029= SFC::Function::Cast( initFunction_1024);
		if( false== Uml::IsDerivedFrom( classStruct_102d.type(), SFC::Struct::meta))
			continue;
		SFC::Struct classStruct_1032= SFC::Struct::Cast( classStruct_102d);
		set< CyberComposition::Simulink::SF_Parameter> parameters_1034= subsystem_1020.SF_Parameter_kind_children();
		for( set< CyberComposition::Simulink::SF_Parameter>::const_iterator itParameter_1035= parameters_1034.begin(); itParameter_1035!= parameters_1034.end(); ++itParameter_1035)
		{
			CyberComposition::Simulink::SF_Parameter currParameter_1036= *itParameter_1035;
			set< SFC::LocalVar> localVars_1037= classStruct_1032.LocalVar_kind_children();
			for( set< SFC::LocalVar>::const_iterator itLocalVar_1038= localVars_1037.begin(); itLocalVar_1038!= localVars_1037.end(); ++itLocalVar_1038)
			{
				SFC::LocalVar currLocalVar_1039= *itLocalVar_1038;
				set< CyberComposition::Simulink::SF_Parameter> parameters_103a= currLocalVar_1039.param();
				for( set< CyberComposition::Simulink::SF_Parameter>::const_iterator itParameters_103b= parameters_103a.begin(); itParameters_103b!= parameters_103a.end(); ++itParameters_103b)
				{
					CyberComposition::Simulink::SF_Parameter currParameter_103c= *itParameters_103b;
					if( currParameter_1036!= currParameter_103c)
						continue;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_1040;
					if( !isValidBound(boundObjs_1040, subsystem_1020, true))
						continue;
					currMatch.subsystem_1041= subsystem_1020;
					if( !isValidBound(boundObjs_1040, initFunction_1029, true))
						continue;
					currMatch.initFunction_1042= initFunction_1029;
					if( !isValidBound(boundObjs_1040, classStruct_1032, true))
						continue;
					currMatch.classStruct_1043= classStruct_1032;
					if( !isValidBound(boundObjs_1040, currParameter_1036, false))
						continue;
					currMatch.parameter_1044= currParameter_1036;
					if( !isValidBound(boundObjs_1040, currLocalVar_1039, false))
						continue;
					currMatch.localVar_1045= currLocalVar_1039;
					_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void InitDirectParameter_1012::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Struct& ClassStruct= currMatch.classStruct_1043;
		SFC::Function& InitFunction= currMatch.initFunction_1042;
		SFC::LocalVar& LocalVar= currMatch.localVar_1045;
		CyberComposition::Simulink::SF_Parameter& Parameter= currMatch.parameter_1044;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_1041;
		{
SFUtils::InitParameter( InitFunction, Parameter, LocalVar );
};
	}
}

void CreateInitFunction_105a::operator()( const Packets_t& subsystems_105b, Packets_t& subsystems_105d, Packets_t& initFunctions_105e, Packets_t& structs_105f)
{
#ifdef PRINT_INFO
	printLog( "CreateInitFunction_105a" );
#endif
	RTTGenerator::Instance()->generateRule(850, "CreateInitFunction");
	_subsystem_1060= &subsystems_105d;
	_initFunction_1061= &initFunctions_105e;
	_struct_1062= &structs_105f;
	processInputPackets( subsystems_105b);
}

bool CreateInitFunction_105a::isInputUnique( const Udm::Object& subsystem_1067)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1069= _subsystem_1063.begin(); itSubsystem_1069!= _subsystem_1063.end(); ++itSubsystem_1069)
	{
		if( ( *itSubsystem_1069== subsystem_1067))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_subsystem_1063.push_back( subsystem_1067);
	return isUnique;
}

bool CreateInitFunction_105a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateInitFunction_105a::processInputPackets( const Packets_t& subsystems_105b)
{
	for( Packets_t::const_iterator itSubsystem_1064= subsystems_105b.begin(); itSubsystem_1064!= subsystems_105b.end(); ++itSubsystem_1064)
	{
		bool isUnique= isInputUnique( *itSubsystem_1064);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1064);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateInitFunction_105a::patternMatcher( const Udm::Object& subsystem_1065)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1065.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_106a= CyberComposition::Simulink::Subsystem::Cast( subsystem_1065);
		SFC::Class class_106c= subsystem_106a.cls();
		if( !class_106c)
			continue;
		set< SFC::Struct> structs_106d= class_106c.Struct_kind_children();
		for( set< SFC::Struct>::const_iterator itStruct_106e= structs_106d.begin(); itStruct_106e!= structs_106d.end(); ++itStruct_106e)
		{
			SFC::Struct currStruct_106f= *itStruct_106e;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1073;
			if( !isValidBound(boundObjs_1073, subsystem_106a, true))
				continue;
			currMatch.subsystem_1074= subsystem_106a;
			if( !isValidBound(boundObjs_1073, class_106c, false))
				continue;
			currMatch.class_1075= class_106c;
			if( !isValidBound(boundObjs_1073, currStruct_106f, false))
				continue;
			currMatch.struct_1076= currStruct_106f;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateInitFunction_105a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function newInitFunction_1077= SFC::Function::Create( currMatch.class_1075, SFC::Class::meta_stmnt);
		SFC::Arg newArg_1078= SFC::Arg::Create( newInitFunction_1077);
		SFC::Arg& Arg= newArg_1078;
		SFC::Class& Class= currMatch.class_1075;
		SFC::Function& InitFunction= newInitFunction_1077;
		SFC::Struct& Struct= currMatch.struct_1076;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_1074;
		{
Arg.name() = "context";
Arg.ptr() = true;
Arg.argIndex() = 0;
};
		{
__int64 statementCount = Class.statementCount();
InitFunction.statementIndex() = statementCount++;
Class.statementCount() = statementCount;

InitFunction.name() = static_cast< std::string >( Subsystem.name() ) + "_" + boost::lexical_cast< std::string >( Subsystem.uniqueId() )+  "_init";
InitFunction.argCount() = 1;
};
		newInitFunction_1077.sysinit()= currMatch.subsystem_1074;
		newArg_1078.dt()= currMatch.struct_1076;
		outputAppender( currMatch.subsystem_1074, newInitFunction_1077, currMatch.struct_1076);
	}
}

void CreateInitFunction_105a::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_1079, const SFC::Function& initFunction_107b, const SFC::Struct& struct_107d)
{
	_subsystem_1060->push_back( subsystem_1079);
	_initFunction_1061->push_back( initFunction_107b);
	_struct_1062->push_back( struct_107d);
}

void MakeSFChartConstructor_1088::operator()( const Packets_t& systems_1089)
{
#ifdef PRINT_INFO
	printLog( "MakeSFChartConstructor_1088" );
#endif
	if( ( !systems_1089.empty()))
		callCreateInitFunction_10ac( systems_1089);
}

void MakeSFChartConstructor_1088::callCreateInitFunction_10ac( const Packets_t& subsystems_108c)
{
	Packets_t subsystems_108e;
	Packets_t initFunctions_108f;
	CreateInitFunction_108b createInitFunction_108b;
	createInitFunction_108b( subsystems_108c, subsystems_108e, initFunctions_108f);
	if( ( !subsystems_108e.empty())&& ( !initFunctions_108f.empty()))
		callinitSubSubsystem_10ae( subsystems_108e, initFunctions_108f);
}

void MakeSFChartConstructor_1088::callinitSubSubsystem_10ae( const Packets_t& subsystems_d25, const Packets_t& initFunctions_d27)
{
	InitSubSubsystem_d24 initSubSubsystem_d24;
	initSubSubsystem_d24( subsystems_d25, initFunctions_d27);
}

void CreateInitFunction_108b::operator()( const Packets_t& subsystems_108c, Packets_t& subsystems_108e, Packets_t& initFunctions_108f)
{
#ifdef PRINT_INFO
	printLog( "CreateInitFunction_108b" );
#endif
	RTTGenerator::Instance()->generateRule(896, "CreateInitFunction");
	_subsystem_1090= &subsystems_108e;
	_initFunction_1091= &initFunctions_108f;
	processInputPackets( subsystems_108c);
}

bool CreateInitFunction_108b::isInputUnique( const Udm::Object& subsystem_1096)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1098= _subsystem_1092.begin(); itSubsystem_1098!= _subsystem_1092.end(); ++itSubsystem_1098)
	{
		if( ( *itSubsystem_1098== subsystem_1096))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_subsystem_1092.push_back( subsystem_1096);
	return isUnique;
}

bool CreateInitFunction_108b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateInitFunction_108b::processInputPackets( const Packets_t& subsystems_108c)
{
	for( Packets_t::const_iterator itSubsystem_1093= subsystems_108c.begin(); itSubsystem_1093!= subsystems_108c.end(); ++itSubsystem_1093)
	{
		bool isUnique= isInputUnique( *itSubsystem_1093);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1093);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateInitFunction_108b::patternMatcher( const Udm::Object& subsystem_1094)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1094.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1099= CyberComposition::Simulink::Subsystem::Cast( subsystem_1094);
		SFC::Class class_109b= subsystem_1099.cls();
		if( !class_109b)
			continue;
		set< SFC::Struct> structs_109c= class_109b.Struct_kind_children();
		for( set< SFC::Struct>::const_iterator itStruct_109d= structs_109c.begin(); itStruct_109d!= structs_109c.end(); ++itStruct_109d)
		{
			SFC::Struct currStruct_109e= *itStruct_109d;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_10a2;
			if( !isValidBound(boundObjs_10a2, subsystem_1099, true))
				continue;
			currMatch.subsystem_10a3= subsystem_1099;
			if( !isValidBound(boundObjs_10a2, class_109b, false))
				continue;
			currMatch.class_10a4= class_109b;
			if( !isValidBound(boundObjs_10a2, currStruct_109e, false))
				continue;
			currMatch.struct_10a5= currStruct_109e;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateInitFunction_108b::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function newInitFunction_10a6= SFC::Function::Create( currMatch.class_10a4, SFC::Class::meta_stmnt);
		SFC::Arg newArg_10a7= SFC::Arg::Create( newInitFunction_10a6);
		SFC::Arg& Arg= newArg_10a7;
		SFC::Class& Class= currMatch.class_10a4;
		SFC::Function& InitFunction= newInitFunction_10a6;
		SFC::Struct& Struct= currMatch.struct_10a5;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_10a3;
		{
__int64 statementCount = Class.statementCount();
InitFunction.statementIndex() = statementCount++;
Class.statementCount() = statementCount;

InitFunction.name() = static_cast< std::string >( Subsystem.name() ) +  "_init";
InitFunction.argCount() = 1;
InitFunction.statementCount() = -1;
};
		{
Arg.name() = "context";
Arg.ptr() = true;
Arg.argIndex() = 0;
};
		newInitFunction_10a6.sysinit()= currMatch.subsystem_10a3;
		newArg_10a7.dt()= currMatch.struct_10a5;
		outputAppender( currMatch.subsystem_10a3, newInitFunction_10a6);
	}
}

void CreateInitFunction_108b::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_10a8, const SFC::Function& initFunction_10aa)
{
	_subsystem_1090->push_back( subsystem_10a8);
	_initFunction_1091->push_back( initFunction_10aa);
}

void GetSubSubsystems_10b1::operator()( const Packets_t& systems_10b2, Packets_t& subsystems_10b4)
{
#ifdef PRINT_INFO
	printLog( "GetSubSubsystems_10b1" );
#endif
	_subsystem_10b5= &subsystems_10b4;
	if( ( !systems_10b2.empty()))
		callGetSubSubsystems_10cf( systems_10b2);
}

void GetSubSubsystems_10b1::callGetSubSubsystems_10cf( const Packets_t& subsystems_10b7)
{
	Packets_t subSubsystems_10b9;
	GetSubSubsystems_10b6 getSubSubsystems_10b6;
	getSubSubsystems_10b6( subsystems_10b7, subSubsystems_10b9);
	_subsystem_10b5->insert( _subsystem_10b5->end(), subSubsystems_10b9.begin(), subSubsystems_10b9.end());
}

void GetSubSubsystems_10b6::operator()( const Packets_t& subsystems_10b7, Packets_t& subSubsystems_10b9)
{
#ifdef PRINT_INFO
	printLog( "GetSubSubsystems_10b6" );
#endif
	RTTGenerator::Instance()->generateRule(1937, "GetSubSubsystems");
	_subSubsystem_10ba= &subSubsystems_10b9;
	processInputPackets( subsystems_10b7);
}

bool GetSubSubsystems_10b6::isInputUnique( const Udm::Object& subsystem_10bf)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_10c1= _subsystem_10bb.begin(); itSubsystem_10c1!= _subsystem_10bb.end(); ++itSubsystem_10c1)
	{
		if( ( *itSubsystem_10c1== subsystem_10bf))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_subsystem_10bb.push_back( subsystem_10bf);
	return isUnique;
}

bool GetSubSubsystems_10b6::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetSubSubsystems_10b6::processInputPackets( const Packets_t& subsystems_10b7)
{
	for( Packets_t::const_iterator itSubsystem_10bc= subsystems_10b7.begin(); itSubsystem_10bc!= subsystems_10b7.end(); ++itSubsystem_10bc)
	{
		bool isUnique= isInputUnique( *itSubsystem_10bc);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_10bc);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetSubSubsystems_10b6::patternMatcher( const Udm::Object& subsystem_10bd)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_10bd.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_10c2= CyberComposition::Simulink::Subsystem::Cast( subsystem_10bd);
		set< CyberComposition::Simulink::Subsystem> subSubsystems_10c4= subsystem_10c2.Subsystem_kind_children();
		for( set< CyberComposition::Simulink::Subsystem>::const_iterator itSubSubsystem_10c5= subSubsystems_10c4.begin(); itSubSubsystem_10c5!= subSubsystems_10c4.end(); ++itSubSubsystem_10c5)
		{
			CyberComposition::Simulink::Subsystem currSubSubsystem_10c6= *itSubSubsystem_10c5;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_10ca;
			if( !isValidBound(boundObjs_10ca, subsystem_10c2, true))
				continue;
			currMatch.subsystem_10cb= subsystem_10c2;
			if( !isValidBound(boundObjs_10ca, currSubSubsystem_10c6, false))
				continue;
			currMatch.subSubsystem_10cc= currSubSubsystem_10c6;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetSubSubsystems_10b6::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subSubsystem_10cc);
	}
}

void GetSubSubsystems_10b6::outputAppender( const CyberComposition::Simulink::Subsystem& subSubsystem_10cd)
{
	_subSubsystem_10ba->push_back( subSubsystem_10cd);
}

void SubsystemFilter_10d1::operator()( const Packets_t& systems_10d2, Packets_t& chartsystems_10d4, Packets_t& sFchartsystems_10d5, Packets_t& systems_10d6)
{
#ifdef PRINT_INFO
	printLog( "SubsystemFilter_10d1" );
#endif
	_chartsystem_10d7= &chartsystems_10d4;
	_sFchartsystem_10d8= &sFchartsystems_10d5;
	_system_10d9= &systems_10d6;
	if( ( !systems_10d2.empty()))
		callSubsystemFilter_114d( systems_10d2);
}

void SubsystemFilter_10d1::callSubsystemFilter_114d( const Packets_t& systems_10db)
{
	Packets_t systems_10dd;
	Packets_t systems_10de;
	Packets_t systems_10df;
	Packets_t systems_10e0;
	SubsystemFilter_10da subsystemFilter_10da;
	subsystemFilter_10da( systems_10db, systems_10dd, systems_10de, systems_10df, systems_10e0);
	_chartsystem_10d7->insert( _chartsystem_10d7->end(), systems_10dd.begin(), systems_10dd.end());
	_sFchartsystem_10d8->insert( _sFchartsystem_10d8->end(), systems_10de.begin(), systems_10de.end());
	_system_10d9->insert( _system_10d9->end(), systems_10df.begin(), systems_10df.end());
	_system_10d9->insert( _system_10d9->end(), systems_10e0.begin(), systems_10e0.end());
}

void SubsystemFilter_10da::operator()( const Packets_t& systems_10db, Packets_t& systems_10dd, Packets_t& systems_10de, Packets_t& systems_10df, Packets_t& systems_10e0)
{
#ifdef PRINT_INFO
	printLog( "SubsystemFilter_10da" );
#endif
	_system_10e1= &systems_10dd;
	_system_10e2= &systems_10de;
	_system_10e3= &systems_10df;
	_system_10e4= &systems_10e0;
	for( Packets_t::const_iterator itsystem_10e6= systems_10db.begin(); itsystem_10e6!= systems_10db.end(); ++itsystem_10e6)
	{
		bool isUnique= isInputUnique( *itsystem_10e6);
		if( !isUnique)
			continue;
		Packets_t onesystem_10ea( 1, *itsystem_10e6);
		executeOne( onesystem_10ea);
	}
}

void SubsystemFilter_10da::executeOne( const Packets_t& systems_10db)
{
	Packets_t subsystems_10ef;
	IsStateChart_10ec isStateChart_10ec;
	bool isMatchIsStateChart_10ec= isStateChart_10ec( systems_10db, subsystems_10ef);
	_system_10e1->insert( _system_10e1->end(), subsystems_10ef.begin(), subsystems_10ef.end());
	if( isMatchIsStateChart_10ec)
		return;
	Packets_t subsystems_110c;
	IsSFStateChart_1109 isSFStateChart_1109;
	bool isMatchIsSFStateChart_1109= isSFStateChart_1109( systems_10db, subsystems_110c);
	_system_10e2->insert( _system_10e2->end(), subsystems_110c.begin(), subsystems_110c.end());
	if( isMatchIsSFStateChart_1109)
		return;
	Packets_t subsystems_1125;
	IsInstance_1122 isInstance_1122;
	bool isMatchIsInstance_1122= isInstance_1122( systems_10db, subsystems_1125);
	_system_10e3->insert( _system_10e3->end(), subsystems_1125.begin(), subsystems_1125.end());
	if( isMatchIsInstance_1122)
		return;
	Packets_t subsystems_113b;
	Otherwise_1138 otherwise_1138;
	bool isMatchOtherwise_1138= otherwise_1138( systems_10db, subsystems_113b);
	_system_10e4->insert( _system_10e4->end(), subsystems_113b.begin(), subsystems_113b.end());
	if( isMatchOtherwise_1138)
		return;
}

bool SubsystemFilter_10da::isInputUnique( const Udm::Object& system_10e7)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itsystem_10e9= _system_10e5.begin(); itsystem_10e9!= _system_10e5.end(); ++itsystem_10e9)
	{
		if( ( *itsystem_10e9== system_10e7))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_system_10e5.push_back( system_10e7);
	return isUnique;
}

bool IsStateChart_10ec::operator()( const Packets_t& subsystems_10ed, Packets_t& subsystems_10ef)
{
#ifdef PRINT_INFO
	printLog( "IsStateChart_10ec" );
#endif
	_subsystem_10f0= &subsystems_10ef;
	processInputPackets( subsystems_10ed);
	if( false== _matches.empty())
		return true;
	return false;
}

bool IsStateChart_10ec::isInputUnique( const Udm::Object& subsystem_10f5)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_10f7= _subsystem_10f1.begin(); itSubsystem_10f7!= _subsystem_10f1.end(); ++itSubsystem_10f7)
	{
		if( ( *itSubsystem_10f7== subsystem_10f5))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_subsystem_10f1.push_back( subsystem_10f5);
	return isUnique;
}

bool IsStateChart_10ec::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void IsStateChart_10ec::processInputPackets( const Packets_t& subsystems_10ed)
{
	for( Packets_t::const_iterator itSubsystem_10f2= subsystems_10ed.begin(); itSubsystem_10f2!= subsystems_10ed.end(); ++itSubsystem_10f2)
	{
		bool isUnique= isInputUnique( *itSubsystem_10f2);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_10f2);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_1104);
	}
}

bool IsStateChart_10ec::patternMatcher( const Udm::Object& subsystem_10f3)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_10f3.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_10f8= CyberComposition::Simulink::Subsystem::Cast( subsystem_10f3);
		set< CyberComposition::Simulink::Primitive> primitives_10fa= subsystem_10f8.Primitive_kind_children();
		for( set< CyberComposition::Simulink::Primitive>::const_iterator itPrimitive_10fb= primitives_10fa.begin(); itPrimitive_10fb!= primitives_10fa.end(); ++itPrimitive_10fb)
		{
			CyberComposition::Simulink::Primitive currPrimitive_10fc= *itPrimitive_10fb;
			set< CyberComposition::Simulink::State> states_10fd= currPrimitive_10fc.State_kind_children();
			for( set< CyberComposition::Simulink::State>::const_iterator itState_10fe= states_10fd.begin(); itState_10fe!= states_10fd.end(); ++itState_10fe)
			{
				CyberComposition::Simulink::State currState_10ff= *itState_10fe;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_1103;
				if( !isValidBound(boundObjs_1103, subsystem_10f8, true))
					continue;
				currMatch.subsystem_1104= subsystem_10f8;
				if( !isValidBound(boundObjs_1103, currPrimitive_10fc, false))
					continue;
				currMatch.primitive_1105= currPrimitive_10fc;
				if( !isValidBound(boundObjs_1103, currState_10ff, false))
					continue;
				currMatch.state_1106= currState_10ff;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void IsStateChart_10ec::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_1107)
{
	_subsystem_10f0->push_back( subsystem_1107);
}

bool IsSFStateChart_1109::operator()( const Packets_t& subsystems_110a, Packets_t& subsystems_110c)
{
#ifdef PRINT_INFO
	printLog( "IsSFStateChart_1109" );
#endif
	_subsystem_110d= &subsystems_110c;
	processInputPackets( subsystems_110a);
	if( false== _matches.empty())
		return true;
	return false;
}

bool IsSFStateChart_1109::isInputUnique( const Udm::Object& subsystem_1112)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1114= _subsystem_110e.begin(); itSubsystem_1114!= _subsystem_110e.end(); ++itSubsystem_1114)
	{
		if( ( *itSubsystem_1114== subsystem_1112))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_subsystem_110e.push_back( subsystem_1112);
	return isUnique;
}

bool IsSFStateChart_1109::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void IsSFStateChart_1109::processInputPackets( const Packets_t& subsystems_110a)
{
	for( Packets_t::const_iterator itSubsystem_110f= subsystems_110a.begin(); itSubsystem_110f!= subsystems_110a.end(); ++itSubsystem_110f)
	{
		bool isUnique= isInputUnique( *itSubsystem_110f);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_110f);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_111e);
	}
}

bool IsSFStateChart_1109::patternMatcher( const Udm::Object& subsystem_1110)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1110.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1115= CyberComposition::Simulink::Subsystem::Cast( subsystem_1110);
		set< CyberComposition::Simulink::SFState> sFStates_1117= subsystem_1115.SFState_kind_children();
		for( set< CyberComposition::Simulink::SFState>::const_iterator itSFState_1118= sFStates_1117.begin(); itSFState_1118!= sFStates_1117.end(); ++itSFState_1118)
		{
			CyberComposition::Simulink::SFState currSFState_1119= *itSFState_1118;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_111d;
			if( !isValidBound(boundObjs_111d, subsystem_1115, true))
				continue;
			currMatch.subsystem_111e= subsystem_1115;
			if( !isValidBound(boundObjs_111d, currSFState_1119, false))
				continue;
			currMatch.sFState_111f= currSFState_1119;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void IsSFStateChart_1109::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_1120)
{
	_subsystem_110d->push_back( subsystem_1120);
}

bool IsInstance_1122::operator()( const Packets_t& subsystems_1123, Packets_t& subsystems_1125)
{
#ifdef PRINT_INFO
	printLog( "IsInstance_1122" );
#endif
	_subsystem_1126= &subsystems_1125;
	processInputPackets( subsystems_1123);
	if( false== _matches.empty())
		return true;
	return false;
}

bool IsInstance_1122::isInputUnique( const Udm::Object& subsystem_112b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_112d= _subsystem_1127.begin(); itSubsystem_112d!= _subsystem_1127.end(); ++itSubsystem_112d)
	{
		if( ( *itSubsystem_112d== subsystem_112b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_subsystem_1127.push_back( subsystem_112b);
	return isUnique;
}

bool IsInstance_1122::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool IsInstance_1122::isGuardTrue( CyberComposition::Simulink::Subsystem& Subsystem)
{
	bool Gz_guard= false;
	Gz_guard = Subsystem.isInstance();;
	return Gz_guard;
}

void IsInstance_1122::processInputPackets( const Packets_t& subsystems_1123)
{
	for( Packets_t::const_iterator itSubsystem_1128= subsystems_1123.begin(); itSubsystem_1128!= subsystems_1123.end(); ++itSubsystem_1128)
	{
		bool isUnique= isInputUnique( *itSubsystem_1128);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1128);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_1134);
	}
}

bool IsInstance_1122::patternMatcher( const Udm::Object& subsystem_1129)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1129.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_112e= CyberComposition::Simulink::Subsystem::Cast( subsystem_1129);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1133;
		if( !isValidBound(boundObjs_1133, subsystem_112e, true))
			continue;
		currMatch.subsystem_1134= subsystem_112e;
		bool Gz_guard= isGuardTrue( currMatch.subsystem_1134);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void IsInstance_1122::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_1136)
{
	_subsystem_1126->push_back( subsystem_1136);
}

bool Otherwise_1138::operator()( const Packets_t& subsystems_1139, Packets_t& subsystems_113b)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_1138" );
#endif
	_subsystem_113c= &subsystems_113b;
	processInputPackets( subsystems_1139);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_1138::isInputUnique( const Udm::Object& subsystem_1141)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1143= _subsystem_113d.begin(); itSubsystem_1143!= _subsystem_113d.end(); ++itSubsystem_1143)
	{
		if( ( *itSubsystem_1143== subsystem_1141))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_subsystem_113d.push_back( subsystem_1141);
	return isUnique;
}

bool Otherwise_1138::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_1138::processInputPackets( const Packets_t& subsystems_1139)
{
	for( Packets_t::const_iterator itSubsystem_113e= subsystems_1139.begin(); itSubsystem_113e!= subsystems_1139.end(); ++itSubsystem_113e)
	{
		bool isUnique= isInputUnique( *itSubsystem_113e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_113e);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_114a);
	}
}

bool Otherwise_1138::patternMatcher( const Udm::Object& subsystem_113f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_113f.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1144= CyberComposition::Simulink::Subsystem::Cast( subsystem_113f);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1149;
		if( !isValidBound(boundObjs_1149, subsystem_1144, true))
			continue;
		currMatch.subsystem_114a= subsystem_1144;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_1138::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_114b)
{
	_subsystem_113c->push_back( subsystem_114b);
}

void GetSubsystems_1159::operator()( const Packets_t& comptypes_115a, Packets_t& subsystems_115c)
{
#ifdef PRINT_INFO
	printLog( "GetSubsystems_1159" );
#endif
	_subsystem_115d= &subsystems_115c;
	if( ( !comptypes_115a.empty()))
		callGetSubSystems_1177( comptypes_115a);
}

void GetSubsystems_1159::callGetSubSystems_1177( const Packets_t& dataflows_115f)
{
	Packets_t subsystems_1161;
	GetSubSystems_115e getSubSystems_115e;
	getSubSystems_115e( dataflows_115f, subsystems_1161);
	_subsystem_115d->insert( _subsystem_115d->end(), subsystems_1161.begin(), subsystems_1161.end());
}

void GetSubSystems_115e::operator()( const Packets_t& dataflows_115f, Packets_t& subsystems_1161)
{
#ifdef PRINT_INFO
	printLog( "GetSubSystems_115e" );
#endif
	RTTGenerator::Instance()->generateRule(4986, "GetSubSystems");
	_subsystem_1162= &subsystems_1161;
	processInputPackets( dataflows_115f);
}

bool GetSubSystems_115e::isInputUnique( const Udm::Object& dataflow_1167)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itDataflow_1169= _dataflow_1163.begin(); itDataflow_1169!= _dataflow_1163.end(); ++itDataflow_1169)
	{
		if( ( *itDataflow_1169== dataflow_1167))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_dataflow_1163.push_back( dataflow_1167);
	return isUnique;
}

bool GetSubSystems_115e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetSubSystems_115e::processInputPackets( const Packets_t& dataflows_115f)
{
	for( Packets_t::const_iterator itDataflow_1164= dataflows_115f.begin(); itDataflow_1164!= dataflows_115f.end(); ++itDataflow_1164)
	{
		bool isUnique= isInputUnique( *itDataflow_1164);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itDataflow_1164);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetSubSystems_115e::patternMatcher( const Udm::Object& dataflow_1165)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( dataflow_1165.type(), CyberComposition::SimulinkWrapper::meta))
			continue;
		CyberComposition::SimulinkWrapper dataflow_116a= CyberComposition::SimulinkWrapper::Cast( dataflow_1165);
		set< CyberComposition::Simulink::Subsystem> subsystems_116c= dataflow_116a.Simulink_Subsystem_kind_children();
		for( set< CyberComposition::Simulink::Subsystem>::const_iterator itSubsystem_116d= subsystems_116c.begin(); itSubsystem_116d!= subsystems_116c.end(); ++itSubsystem_116d)
		{
			CyberComposition::Simulink::Subsystem currSubsystem_116e= *itSubsystem_116d;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1172;
			if( !isValidBound(boundObjs_1172, dataflow_116a, true))
				continue;
			currMatch.dataflow_1173= dataflow_116a;
			if( !isValidBound(boundObjs_1172, currSubsystem_116e, false))
				continue;
			currMatch.subsystem_1174= currSubsystem_116e;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetSubSystems_115e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_1174);
	}
}

void GetSubSystems_115e::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_1175)
{
	_subsystem_1162->push_back( subsystem_1175);
}

void MakeClasses_117d::operator()( const Packets_t& dataflows_117e, const Packets_t& projects_1180, Packets_t& dataflows_1182, Packets_t& projects_1183)
{
#ifdef PRINT_INFO
	printLog( "MakeClasses_117d" );
#endif
	_dataflow_1184= &dataflows_1182;
	_project_1185= &projects_1183;
	_dataflow_1184->insert( _dataflow_1184->end(), dataflows_117e.begin(), dataflows_117e.end());
	_project_1185->insert( _project_1185->end(), projects_1180.begin(), projects_1180.end());
	if( ( !dataflows_117e.empty())&& ( !projects_1180.empty()))
		callGetBlocks_5323( dataflows_117e, projects_1180);
}

void MakeClasses_117d::callGetBlocks_5323( const Packets_t& comptypes_52ef, const Packets_t& projects_52f1)
{
	Packets_t subsystems_52f3;
	Packets_t projects_52f4;
	GetBlocks_52ee getBlocks_52ee;
	getBlocks_52ee( comptypes_52ef, projects_52f1, subsystems_52f3, projects_52f4);
	if( ( !subsystems_52f3.empty())&& ( !projects_52f4.empty()))
		callCreateAllPrograms_5326( subsystems_52f3, projects_52f4);
}

void MakeClasses_117d::callCreateAllPrograms_5326( const Packets_t& subsystems_1187, const Packets_t& projects_1189)
{
	CreateAllPrograms_1186 createAllPrograms_1186;
	createAllPrograms_1186( subsystems_1187, projects_1189);
}

void CreateAllPrograms_1186::operator()( const Packets_t& subsystems_1187, const Packets_t& projects_1189)
{
#ifdef PRINT_INFO
	printLog( "CreateAllPrograms_1186" );
#endif
	if( ( !subsystems_1187.empty())&& ( !projects_1189.empty()))
		callCreateProgramsTopLevel_52e2( subsystems_1187, projects_1189);
}

void CreateAllPrograms_1186::callCreateProgramsTopLevel_52e2( const Packets_t& systems_1c43, const Packets_t& projects_1c45)
{
	Packets_t systems_1c47;
	Packets_t programs_1c48;
	CreateProgramsTopLevel_1c42 createProgramsTopLevel_1c42;
	createProgramsTopLevel_1c42( systems_1c43, projects_1c45, systems_1c47, programs_1c48);
	if( ( !systems_1c47.empty())&& ( !programs_1c48.empty()))
		callCreateClasses_52e5( systems_1c47, programs_1c48);
}

void CreateAllPrograms_1186::callCreateClasses_52e5( const Packets_t& systems_1739, const Packets_t& programs_173b)
{
	Packets_t systems_173d;
	CreateClasses_1738 createClasses_1738;
	createClasses_1738( systems_1739, programs_173b, systems_173d);
	if( ( !systems_173d.empty()))
		callCreateFunctionsAndArgs_52e8( systems_173d);
}

void CreateAllPrograms_1186::callCreateFunctionsAndArgs_52e8( const Packets_t& systems_118c)
{
	Packets_t systems_118e;
	CreateFunctionsAndArgs_118b createFunctionsAndArgs_118b;
	createFunctionsAndArgs_118b( systems_118c, systems_118e);
	if( ( !systems_118e.empty()))
		callCreateFunctionLocalVars_52ea( systems_118e);
}

void CreateAllPrograms_1186::callCreateFunctionLocalVars_52ea( const Packets_t& systems_18ec)
{
	Packets_t systems_18ee;
	CreateFunctionLocalVars_18eb createFunctionLocalVars_18eb;
	createFunctionLocalVars_18eb( systems_18ec, systems_18ee);
	if( ( !systems_18ee.empty()))
		callCreateSigFlowsR_52ec( systems_18ee);
}

void CreateAllPrograms_1186::callCreateSigFlowsR_52ec( const Packets_t& systems_1cef)
{
	CreateSigFlowsR_1cee createSigFlowsR_1cee;
	createSigFlowsR_1cee( systems_1cef);
}

void CreateFunctionsAndArgs_118b::operator()( const Packets_t& systems_118c, Packets_t& systems_118e)
{
#ifdef PRINT_INFO
	printLog( "CreateFunctionsAndArgs_118b" );
#endif
	_system_118f= &systems_118e;
	_system_118f->insert( _system_118f->end(), systems_118c.begin(), systems_118c.end());
	if( ( !systems_118c.empty()))
		callSubsystemFilter_1725( systems_118c);
}

void CreateFunctionsAndArgs_118b::callSubsystemFilter_1725( const Packets_t& systems_10d2)
{
	Packets_t chartsystems_10d4;
	Packets_t sFchartsystems_10d5;
	Packets_t systems_10d6;
	SubsystemFilter_10d1 subsystemFilter_10d1;
	subsystemFilter_10d1( systems_10d2, chartsystems_10d4, sFchartsystems_10d5, systems_10d6);
	if( ( !chartsystems_10d4.empty()))
		callCreateChartFunction_1727( chartsystems_10d4);
	if( ( !systems_10d6.empty()))
		callCreateFunctions_1729( systems_10d6);
	if( ( !sFchartsystems_10d5.empty()))
		callCreateSFChartFunction_172b( sFchartsystems_10d5);
}

void CreateFunctionsAndArgs_118b::callCreateChartFunction_1727( const Packets_t& subsystems_12dc)
{
	Packets_t states_12db;
	Packets_t mains_12de;
	CreateChartFunction_12da createChartFunction_12da;
	createChartFunction_12da( subsystems_12dc, states_12db, mains_12de);
	if( ( !states_12db.empty())&& ( !mains_12de.empty()))
		callMakeChartArguments_172d( states_12db, mains_12de);
}

void CreateFunctionsAndArgs_118b::callCreateFunctions_1729( const Packets_t& subsystems_1596)
{
	Packets_t subsystems_1598;
	Packets_t mains_1599;
	CreateFunctions_1595 createFunctions_1595;
	createFunctions_1595( subsystems_1596, subsystems_1598, mains_1599);
	if( ( !subsystems_1598.empty())&& ( !mains_1599.empty()))
		callMakeArguments_1730( subsystems_1598, mains_1599);
}

void CreateFunctionsAndArgs_118b::callCreateSFChartFunction_172b( const Packets_t& subsystems_1702)
{
	Packets_t states_1701;
	Packets_t mains_1704;
	CreateSFChartFunction_1700 createSFChartFunction_1700;
	createSFChartFunction_1700( subsystems_1702, states_1701, mains_1704);
	if( ( !states_1701.empty())&& ( !mains_1704.empty()))
		callMakeSFChartArguments_1733( states_1701, mains_1704);
}

void CreateFunctionsAndArgs_118b::callMakeChartArguments_172d( const Packets_t& states_1191, const Packets_t& functions_1193)
{
	MakeChartArguments_1190 makeChartArguments_1190;
	makeChartArguments_1190( states_1191, functions_1193);
}

void CreateFunctionsAndArgs_118b::callMakeArguments_1730( const Packets_t& systems_1304, const Packets_t& functions_1306)
{
	Packets_t systems_1308;
	MakeArguments_1303 makeArguments_1303;
	makeArguments_1303( systems_1304, functions_1306, systems_1308);
	if( ( !systems_1308.empty()))
		callGetSubSubsystems_1736( systems_1308);
}

void CreateFunctionsAndArgs_118b::callMakeSFChartArguments_1733( const Packets_t& states_15b7, const Packets_t& functions_15b9)
{
	MakeSFChartArguments_15b6 makeSFChartArguments_15b6;
	makeSFChartArguments_15b6( states_15b7, functions_15b9);
}

void CreateFunctionsAndArgs_118b::callGetSubSubsystems_1736( const Packets_t& systems_10b2)
{
	Packets_t subsystems_10b4;
	GetSubSubsystems_10b1 getSubSubsystems_10b1;
	getSubSubsystems_10b1( systems_10b2, subsystems_10b4);
	if( ( !subsystems_10b4.empty()))
		callSubsystemFilter_1725( subsystems_10b4);
}

void MakeChartArguments_1190::operator()( const Packets_t& states_1191, const Packets_t& functions_1193)
{
#ifdef PRINT_INFO
	printLog( "MakeChartArguments_1190" );
#endif
	if( ( !states_1191.empty())&& ( !functions_1193.empty()))
		callDataInput_12ce( states_1191, functions_1193);
}

void MakeChartArguments_1190::callDataInput_12ce( const Packets_t& states_1288, const Packets_t& functions_128a)
{
	Packets_t states_128c;
	Packets_t functions_128d;
	DataInput_1287 dataInput_1287;
	dataInput_1287( states_1288, functions_128a, states_128c, functions_128d);
	if( ( !states_128c.empty())&& ( !functions_128d.empty()))
		callEventInput_12d1( states_128c, functions_128d);
}

void MakeChartArguments_1190::callEventInput_12d1( const Packets_t& states_1241, const Packets_t& functions_1243)
{
	Packets_t states_1245;
	Packets_t functions_1246;
	EventInput_1240 eventInput_1240;
	eventInput_1240( states_1241, functions_1243, states_1245, functions_1246);
	if( ( !states_1245.empty())&& ( !functions_1246.empty()))
		callDataOutput_12d4( states_1245, functions_1246);
}

void MakeChartArguments_1190::callDataOutput_12d4( const Packets_t& states_11fa, const Packets_t& functions_11fc)
{
	Packets_t states_11fe;
	Packets_t functions_11ff;
	DataOutput_11f9 dataOutput_11f9;
	dataOutput_11f9( states_11fa, functions_11fc, states_11fe, functions_11ff);
	if( ( !states_11fe.empty())&& ( !functions_11ff.empty()))
		callEventOutput_12d7( states_11fe, functions_11ff);
}

void MakeChartArguments_1190::callEventOutput_12d7( const Packets_t& states_1196, const Packets_t& functions_1198)
{
	EventOutput_1195 eventOutput_1195;
	eventOutput_1195( states_1196, functions_1198);
}

void EventOutput_1195::operator()( const Packets_t& states_1196, const Packets_t& functions_1198)
{
#ifdef PRINT_INFO
	printLog( "EventOutput_1195" );
#endif
	if( ( !states_1196.empty())&& ( !functions_1198.empty()))
		callEventOutput_11f3( states_1196, functions_1198);
}

void EventOutput_1195::callEventOutput_11f3( const Packets_t& states_119b, const Packets_t& mains_119e)
{
	Packets_t args_119d;
	Packets_t mains_11a0;
	EventOutput_119a eventOutput_119a;
	eventOutput_119a( states_119b, mains_119e, args_119d, mains_11a0);
	if( ( !args_119d.empty())&& ( !mains_11a0.empty()))
		callUpdateArgCount_11f6( args_119d, mains_11a0);
}

void EventOutput_1195::callUpdateArgCount_11f6( const Packets_t& args_11d4, const Packets_t& mains_11d6)
{
	UpdateArgCount_11d3 updateArgCount_11d3;
	updateArgCount_11d3( args_11d4, mains_11d6);
}

void EventOutput_119a::operator()( const Packets_t& states_119b, const Packets_t& mains_119e, Packets_t& args_119d, Packets_t& mains_11a0)
{
#ifdef PRINT_INFO
	printLog( "EventOutput_119a" );
#endif
	RTTGenerator::Instance()->generateRule(927, "EventOutput");
	_arg_11a1= &args_119d;
	_main_11a2= &mains_11a0;
	processInputPackets( states_119b, mains_119e);
}

bool EventOutput_119a::isInputUnique( const Udm::Object& state_11a7, const Udm::Object& main_11b0)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_11a9= _state_11a3.begin(), itMain_11b2= _main_11ac.begin(); itState_11a9!= _state_11a3.end(), itMain_11b2!= _main_11ac.end(); ++itState_11a9, ++itMain_11b2)
	{
		if( ( *itState_11a9== state_11a7)&& ( *itMain_11b2== main_11b0))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_11a3.push_back( state_11a7);
		_main_11ac.push_back( main_11b0);
	}
	return isUnique;
}

bool EventOutput_119a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool EventOutput_119a::isGuardTrue( SFC::DT& DT, CyberComposition::Simulink::Event& Event, SFC::Function& Main, CyberComposition::Simulink::State& State, CyberComposition::Simulink::TypeBaseRef& TypeBaseRef, CyberComposition::Simulink::TypeStruct& TypeStruct)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( Event.Scope() ) == "OUTPUT_EVENT";;
	return Gz_guard;
}

void EventOutput_119a::processInputPackets( const Packets_t& states_119b, const Packets_t& mains_119e)
{
	for( Packets_t::const_iterator itState_11a4= states_119b.begin(), itMain_11ad= mains_119e.begin(); itState_11a4!= states_119b.end(), itMain_11ad!= mains_119e.end(); ++itState_11a4, ++itMain_11ad)
	{
		bool isUnique= isInputUnique( *itState_11a4, *itMain_11ad);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_11a4, *itMain_11ad);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool EventOutput_119a::patternMatcher( const Udm::Object& state_11a5, const Udm::Object& main_11ae)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_11a5.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_11aa= CyberComposition::Simulink::State::Cast( state_11a5);
		if( false== Uml::IsDerivedFrom( main_11ae.type(), SFC::Function::meta))
			continue;
		SFC::Function main_11b3= SFC::Function::Cast( main_11ae);
		set< CyberComposition::Simulink::Event> events_11b5= state_11aa.Event_kind_children();
		for( set< CyberComposition::Simulink::Event>::const_iterator itEvent_11b6= events_11b5.begin(); itEvent_11b6!= events_11b5.end(); ++itEvent_11b6)
		{
			CyberComposition::Simulink::Event currEvent_11b7= *itEvent_11b6;
			set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_11b8= currEvent_11b7.TypeBaseRef_kind_children();
			for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_11b9= typeBaseRefs_11b8.begin(); itTypeBaseRef_11b9!= typeBaseRefs_11b8.end(); ++itTypeBaseRef_11b9)
			{
				CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_11ba= *itTypeBaseRef_11b9;
				CyberComposition::Simulink::SF_TypeBase typeStruct_11bb= currTypeBaseRef_11ba.ref();
				if( false== Uml::IsDerivedFrom( typeStruct_11bb.type(), CyberComposition::Simulink::TypeStruct::meta))
					continue;
				CyberComposition::Simulink::TypeStruct typeStruct_11bc= CyberComposition::Simulink::TypeStruct::Cast( typeStruct_11bb);
				if( !typeStruct_11bc)
					continue;
				SFC::DT dT_11bd= typeStruct_11bc.dt();
				if( !dT_11bd)
					continue;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_11c1;
				if( !isValidBound(boundObjs_11c1, state_11aa, true))
					continue;
				currMatch.state_11c2= state_11aa;
				if( !isValidBound(boundObjs_11c1, main_11b3, true))
					continue;
				currMatch.main_11c3= main_11b3;
				if( !isValidBound(boundObjs_11c1, typeStruct_11bc, false))
					continue;
				currMatch.typeStruct_11c4= typeStruct_11bc;
				if( !isValidBound(boundObjs_11c1, dT_11bd, false))
					continue;
				currMatch.dT_11c5= dT_11bd;
				if( !isValidBound(boundObjs_11c1, currEvent_11b7, false))
					continue;
				currMatch.event_11c6= currEvent_11b7;
				if( !isValidBound(boundObjs_11c1, currTypeBaseRef_11ba, false))
					continue;
				currMatch.typeBaseRef_11c7= currTypeBaseRef_11ba;
				bool Gz_guard= isGuardTrue( currMatch.dT_11c5, currMatch.event_11c6, currMatch.main_11c3, currMatch.state_11c2, currMatch.typeBaseRef_11c7, currMatch.typeStruct_11c4);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void EventOutput_119a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg newArg_11ce= SFC::Arg::Create( currMatch.main_11c3);
		SFC::Arg& Arg= newArg_11ce;
		SFC::DT& DT= currMatch.dT_11c5;
		CyberComposition::Simulink::Event& Event= currMatch.event_11c6;
		SFC::Function& Main= currMatch.main_11c3;
		CyberComposition::Simulink::State& State= currMatch.state_11c2;
		CyberComposition::Simulink::TypeBaseRef& TypeBaseRef= currMatch.typeBaseRef_11c7;
		CyberComposition::Simulink::TypeStruct& TypeStruct= currMatch.typeStruct_11c4;
		{
__int64 argIndex = static_cast< __int64 >( Main.argCount() ) + static_cast< __int64 >( Event.Port() ) - 1;
Arg.argIndex() = argIndex;
Arg.ptr() = true;

Arg.name() = static_cast< std::string >( Event.name() ) + "_" + boost::lexical_cast< std::string >( argIndex );
};
		newArg_11ce.dt()= currMatch.dT_11c5;
		outputAppender( newArg_11ce, currMatch.main_11c3);
	}
}

void EventOutput_119a::outputAppender( const SFC::Arg& arg_11cf, const SFC::Function& main_11d1)
{
	_arg_11a1->push_back( arg_11cf);
	_main_11a2->push_back( main_11d1);
}

void UpdateArgCount_11d3::operator()( const Packets_t& args_11d4, const Packets_t& mains_11d6)
{
#ifdef PRINT_INFO
	printLog( "UpdateArgCount_11d3" );
#endif
	RTTGenerator::Instance()->generateRule(1002, "UpdateArgCount");
	processInputPackets( args_11d4, mains_11d6);
}

bool UpdateArgCount_11d3::isInputUnique( const Udm::Object& arg_11dc, const Udm::Object& main_11e5)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArg_11de= _arg_11d8.begin(), itMain_11e7= _main_11e1.begin(); itArg_11de!= _arg_11d8.end(), itMain_11e7!= _main_11e1.end(); ++itArg_11de, ++itMain_11e7)
	{
		if( ( *itArg_11de== arg_11dc)&& ( *itMain_11e7== main_11e5))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_arg_11d8.push_back( arg_11dc);
		_main_11e1.push_back( main_11e5);
	}
	return isUnique;
}

bool UpdateArgCount_11d3::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void UpdateArgCount_11d3::processInputPackets( const Packets_t& args_11d4, const Packets_t& mains_11d6)
{
	for( Packets_t::const_iterator itArg_11d9= args_11d4.begin(), itMain_11e2= mains_11d6.begin(); itArg_11d9!= args_11d4.end(), itMain_11e2!= mains_11d6.end(); ++itArg_11d9, ++itMain_11e2)
	{
		bool isUnique= isInputUnique( *itArg_11d9, *itMain_11e2);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArg_11d9, *itMain_11e2);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool UpdateArgCount_11d3::patternMatcher( const Udm::Object& arg_11da, const Udm::Object& main_11e3)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( arg_11da.type(), SFC::Arg::meta))
			continue;
		SFC::Arg arg_11df= SFC::Arg::Cast( arg_11da);
		if( false== Uml::IsDerivedFrom( main_11e3.type(), SFC::Function::meta))
			continue;
		SFC::Function main_11e8= SFC::Function::Cast( main_11e3);
		set< SFC::Arg> args_11ea= main_11e8.Arg_kind_children();
		for( set< SFC::Arg>::const_iterator itArg_11eb= args_11ea.begin(); itArg_11eb!= args_11ea.end(); ++itArg_11eb)
		{
			SFC::Arg currArg_11ec= *itArg_11eb;
			if( arg_11df!= currArg_11ec)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_11f0;
			if( !isValidBound(boundObjs_11f0, arg_11df, true))
				continue;
			currMatch.arg_11f1= arg_11df;
			if( !isValidBound(boundObjs_11f0, main_11e8, true))
				continue;
			currMatch.main_11f2= main_11e8;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void UpdateArgCount_11d3::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg& Arg= currMatch.arg_11f1;
		SFC::Function& Main= currMatch.main_11f2;
		{
Main.argCount() = static_cast< __int64 >( Main.argCount() ) + 1;
};
	}
}

void DataOutput_11f9::operator()( const Packets_t& states_11fa, const Packets_t& functions_11fc, Packets_t& states_11fe, Packets_t& functions_11ff)
{
#ifdef PRINT_INFO
	printLog( "DataOutput_11f9" );
#endif
	_state_1200= &states_11fe;
	_function_1201= &functions_11ff;
	_state_1200->insert( _state_1200->end(), states_11fa.begin(), states_11fa.end());
	_function_1201->insert( _function_1201->end(), functions_11fc.begin(), functions_11fc.end());
	if( ( !states_11fa.empty())&& ( !functions_11fc.empty()))
		callDataOutput_123a( states_11fa, functions_11fc);
}

void DataOutput_11f9::callDataOutput_123a( const Packets_t& states_1203, const Packets_t& mains_1206)
{
	Packets_t args_1205;
	Packets_t mains_1208;
	DataOutput_1202 dataOutput_1202;
	dataOutput_1202( states_1203, mains_1206, args_1205, mains_1208);
	if( ( !args_1205.empty())&& ( !mains_1208.empty()))
		callUpdateArgCount_123d( args_1205, mains_1208);
}

void DataOutput_11f9::callUpdateArgCount_123d( const Packets_t& args_11d4, const Packets_t& mains_11d6)
{
	UpdateArgCount_11d3 updateArgCount_11d3;
	updateArgCount_11d3( args_11d4, mains_11d6);
}

void DataOutput_1202::operator()( const Packets_t& states_1203, const Packets_t& mains_1206, Packets_t& args_1205, Packets_t& mains_1208)
{
#ifdef PRINT_INFO
	printLog( "DataOutput_1202" );
#endif
	RTTGenerator::Instance()->generateRule(947, "DataOutput");
	_arg_1209= &args_1205;
	_main_120a= &mains_1208;
	processInputPackets( states_1203, mains_1206);
}

bool DataOutput_1202::isInputUnique( const Udm::Object& state_120f, const Udm::Object& main_1218)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1211= _state_120b.begin(), itMain_121a= _main_1214.begin(); itState_1211!= _state_120b.end(), itMain_121a!= _main_1214.end(); ++itState_1211, ++itMain_121a)
	{
		if( ( *itState_1211== state_120f)&& ( *itMain_121a== main_1218))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_120b.push_back( state_120f);
		_main_1214.push_back( main_1218);
	}
	return isUnique;
}

bool DataOutput_1202::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool DataOutput_1202::isGuardTrue( SFC::DT& DT, CyberComposition::Simulink::Data& Data, SFC::Function& Main, CyberComposition::Simulink::State& State, CyberComposition::Simulink::SF_TypeBase& TypeBase, CyberComposition::Simulink::TypeBaseRef& TypeBaseRef)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( Data.Scope() ) == "OUTPUT_DATA";;
	return Gz_guard;
}

void DataOutput_1202::processInputPackets( const Packets_t& states_1203, const Packets_t& mains_1206)
{
	for( Packets_t::const_iterator itState_120c= states_1203.begin(), itMain_1215= mains_1206.begin(); itState_120c!= states_1203.end(), itMain_1215!= mains_1206.end(); ++itState_120c, ++itMain_1215)
	{
		bool isUnique= isInputUnique( *itState_120c, *itMain_1215);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_120c, *itMain_1215);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool DataOutput_1202::patternMatcher( const Udm::Object& state_120d, const Udm::Object& main_1216)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_120d.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1212= CyberComposition::Simulink::State::Cast( state_120d);
		if( false== Uml::IsDerivedFrom( main_1216.type(), SFC::Function::meta))
			continue;
		SFC::Function main_121b= SFC::Function::Cast( main_1216);
		set< CyberComposition::Simulink::Data> datas_121d= state_1212.Data_kind_children();
		for( set< CyberComposition::Simulink::Data>::const_iterator itData_121e= datas_121d.begin(); itData_121e!= datas_121d.end(); ++itData_121e)
		{
			CyberComposition::Simulink::Data currData_121f= *itData_121e;
			set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_1220= currData_121f.TypeBaseRef_kind_children();
			for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_1221= typeBaseRefs_1220.begin(); itTypeBaseRef_1221!= typeBaseRefs_1220.end(); ++itTypeBaseRef_1221)
			{
				CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_1222= *itTypeBaseRef_1221;
				CyberComposition::Simulink::SF_TypeBase typeBase_1223= currTypeBaseRef_1222.ref();
				if( !typeBase_1223)
					continue;
				SFC::DT dT_1224= typeBase_1223.dt();
				if( !dT_1224)
					continue;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_1228;
				if( !isValidBound(boundObjs_1228, state_1212, true))
					continue;
				currMatch.state_1229= state_1212;
				if( !isValidBound(boundObjs_1228, main_121b, true))
					continue;
				currMatch.main_122a= main_121b;
				if( !isValidBound(boundObjs_1228, typeBase_1223, false))
					continue;
				currMatch.typeBase_122b= typeBase_1223;
				if( !isValidBound(boundObjs_1228, dT_1224, false))
					continue;
				currMatch.dT_122c= dT_1224;
				if( !isValidBound(boundObjs_1228, currData_121f, false))
					continue;
				currMatch.data_122d= currData_121f;
				if( !isValidBound(boundObjs_1228, currTypeBaseRef_1222, false))
					continue;
				currMatch.typeBaseRef_122e= currTypeBaseRef_1222;
				bool Gz_guard= isGuardTrue( currMatch.dT_122c, currMatch.data_122d, currMatch.main_122a, currMatch.state_1229, currMatch.typeBase_122b, currMatch.typeBaseRef_122e);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void DataOutput_1202::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg newArg_1235= SFC::Arg::Create( currMatch.main_122a);
		SFC::Arg& Arg= newArg_1235;
		SFC::DT& DT= currMatch.dT_122c;
		CyberComposition::Simulink::Data& Data= currMatch.data_122d;
		SFC::Function& Main= currMatch.main_122a;
		CyberComposition::Simulink::State& State= currMatch.state_1229;
		CyberComposition::Simulink::SF_TypeBase& TypeBase= currMatch.typeBase_122b;
		CyberComposition::Simulink::TypeBaseRef& TypeBaseRef= currMatch.typeBaseRef_122e;
		{
__int64 argIndex = static_cast< __int64 >( Main.argCount() ) + static_cast< __int64 >( Data.Port() ) - 1;
Arg.argIndex() = argIndex;
Arg.ptr() = true;

Arg.name() = static_cast< std::string >( Data.Name() ) + "_" + boost::lexical_cast< std::string >( argIndex );
};
		newArg_1235.dt()= currMatch.dT_122c;
		outputAppender( newArg_1235, currMatch.main_122a);
	}
}

void DataOutput_1202::outputAppender( const SFC::Arg& arg_1236, const SFC::Function& main_1238)
{
	_arg_1209->push_back( arg_1236);
	_main_120a->push_back( main_1238);
}

void EventInput_1240::operator()( const Packets_t& states_1241, const Packets_t& functions_1243, Packets_t& states_1245, Packets_t& functions_1246)
{
#ifdef PRINT_INFO
	printLog( "EventInput_1240" );
#endif
	_state_1247= &states_1245;
	_function_1248= &functions_1246;
	_state_1247->insert( _state_1247->end(), states_1241.begin(), states_1241.end());
	_function_1248->insert( _function_1248->end(), functions_1243.begin(), functions_1243.end());
	if( ( !states_1241.empty())&& ( !functions_1243.empty()))
		callEventInput_1281( states_1241, functions_1243);
}

void EventInput_1240::callEventInput_1281( const Packets_t& states_124a, const Packets_t& mains_124d)
{
	Packets_t args_124c;
	Packets_t mains_124f;
	EventInput_1249 eventInput_1249;
	eventInput_1249( states_124a, mains_124d, args_124c, mains_124f);
	if( ( !args_124c.empty())&& ( !mains_124f.empty()))
		callUpdateArgCount_1284( args_124c, mains_124f);
}

void EventInput_1240::callUpdateArgCount_1284( const Packets_t& args_11d4, const Packets_t& mains_11d6)
{
	UpdateArgCount_11d3 updateArgCount_11d3;
	updateArgCount_11d3( args_11d4, mains_11d6);
}

void EventInput_1249::operator()( const Packets_t& states_124a, const Packets_t& mains_124d, Packets_t& args_124c, Packets_t& mains_124f)
{
#ifdef PRINT_INFO
	printLog( "EventInput_1249" );
#endif
	RTTGenerator::Instance()->generateRule(967, "EventInput");
	_arg_1250= &args_124c;
	_main_1251= &mains_124f;
	processInputPackets( states_124a, mains_124d);
}

bool EventInput_1249::isInputUnique( const Udm::Object& state_1256, const Udm::Object& main_125f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1258= _state_1252.begin(), itMain_1261= _main_125b.begin(); itState_1258!= _state_1252.end(), itMain_1261!= _main_125b.end(); ++itState_1258, ++itMain_1261)
	{
		if( ( *itState_1258== state_1256)&& ( *itMain_1261== main_125f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1252.push_back( state_1256);
		_main_125b.push_back( main_125f);
	}
	return isUnique;
}

bool EventInput_1249::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool EventInput_1249::isGuardTrue( SFC::DT& DT, CyberComposition::Simulink::Event& Event, SFC::Function& Main, CyberComposition::Simulink::State& State, CyberComposition::Simulink::SF_TypeBase& TypeBase, CyberComposition::Simulink::TypeBaseRef& TypeBaseRef)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( Event.Scope() ) == "INPUT_EVENT";;
	return Gz_guard;
}

void EventInput_1249::processInputPackets( const Packets_t& states_124a, const Packets_t& mains_124d)
{
	for( Packets_t::const_iterator itState_1253= states_124a.begin(), itMain_125c= mains_124d.begin(); itState_1253!= states_124a.end(), itMain_125c!= mains_124d.end(); ++itState_1253, ++itMain_125c)
	{
		bool isUnique= isInputUnique( *itState_1253, *itMain_125c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1253, *itMain_125c);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool EventInput_1249::patternMatcher( const Udm::Object& state_1254, const Udm::Object& main_125d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1254.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_1259= CyberComposition::Simulink::State::Cast( state_1254);
		if( false== Uml::IsDerivedFrom( main_125d.type(), SFC::Function::meta))
			continue;
		SFC::Function main_1262= SFC::Function::Cast( main_125d);
		set< CyberComposition::Simulink::Event> events_1264= state_1259.Event_kind_children();
		for( set< CyberComposition::Simulink::Event>::const_iterator itEvent_1265= events_1264.begin(); itEvent_1265!= events_1264.end(); ++itEvent_1265)
		{
			CyberComposition::Simulink::Event currEvent_1266= *itEvent_1265;
			set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_1267= currEvent_1266.TypeBaseRef_kind_children();
			for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_1268= typeBaseRefs_1267.begin(); itTypeBaseRef_1268!= typeBaseRefs_1267.end(); ++itTypeBaseRef_1268)
			{
				CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_1269= *itTypeBaseRef_1268;
				CyberComposition::Simulink::SF_TypeBase typeBase_126a= currTypeBaseRef_1269.ref();
				if( !typeBase_126a)
					continue;
				SFC::DT dT_126b= typeBase_126a.dt();
				if( !dT_126b)
					continue;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_126f;
				if( !isValidBound(boundObjs_126f, state_1259, true))
					continue;
				currMatch.state_1270= state_1259;
				if( !isValidBound(boundObjs_126f, main_1262, true))
					continue;
				currMatch.main_1271= main_1262;
				if( !isValidBound(boundObjs_126f, typeBase_126a, false))
					continue;
				currMatch.typeBase_1272= typeBase_126a;
				if( !isValidBound(boundObjs_126f, dT_126b, false))
					continue;
				currMatch.dT_1273= dT_126b;
				if( !isValidBound(boundObjs_126f, currEvent_1266, false))
					continue;
				currMatch.event_1274= currEvent_1266;
				if( !isValidBound(boundObjs_126f, currTypeBaseRef_1269, false))
					continue;
				currMatch.typeBaseRef_1275= currTypeBaseRef_1269;
				bool Gz_guard= isGuardTrue( currMatch.dT_1273, currMatch.event_1274, currMatch.main_1271, currMatch.state_1270, currMatch.typeBase_1272, currMatch.typeBaseRef_1275);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void EventInput_1249::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg newArg_127c= SFC::Arg::Create( currMatch.main_1271);
		SFC::Arg& Arg= newArg_127c;
		SFC::DT& DT= currMatch.dT_1273;
		CyberComposition::Simulink::Event& Event= currMatch.event_1274;
		SFC::Function& Main= currMatch.main_1271;
		CyberComposition::Simulink::State& State= currMatch.state_1270;
		CyberComposition::Simulink::SF_TypeBase& TypeBase= currMatch.typeBase_1272;
		CyberComposition::Simulink::TypeBaseRef& TypeBaseRef= currMatch.typeBaseRef_1275;
		{
__int64 argIndex = static_cast< __int64 >( Main.argCount() ) + static_cast< __int64 >( Event.Port() ) - 1;
Arg.argIndex() = argIndex;

Arg.name() = static_cast< std::string >( Event.Name() ) + "_" + boost::lexical_cast< std::string >( argIndex );
};
		newArg_127c.dt()= currMatch.dT_1273;
		outputAppender( newArg_127c, currMatch.main_1271);
	}
}

void EventInput_1249::outputAppender( const SFC::Arg& arg_127d, const SFC::Function& main_127f)
{
	_arg_1250->push_back( arg_127d);
	_main_1251->push_back( main_127f);
}

void DataInput_1287::operator()( const Packets_t& states_1288, const Packets_t& functions_128a, Packets_t& states_128c, Packets_t& functions_128d)
{
#ifdef PRINT_INFO
	printLog( "DataInput_1287" );
#endif
	_state_128e= &states_128c;
	_function_128f= &functions_128d;
	_state_128e->insert( _state_128e->end(), states_1288.begin(), states_1288.end());
	_function_128f->insert( _function_128f->end(), functions_128a.begin(), functions_128a.end());
	if( ( !states_1288.empty())&& ( !functions_128a.empty()))
		callDataInput_12c8( states_1288, functions_128a);
}

void DataInput_1287::callDataInput_12c8( const Packets_t& states_1291, const Packets_t& mains_1294)
{
	Packets_t args_1293;
	Packets_t mains_1296;
	DataInput_1290 dataInput_1290;
	dataInput_1290( states_1291, mains_1294, args_1293, mains_1296);
	if( ( !args_1293.empty())&& ( !mains_1296.empty()))
		callUpdateArgCount_12cb( args_1293, mains_1296);
}

void DataInput_1287::callUpdateArgCount_12cb( const Packets_t& args_11d4, const Packets_t& mains_11d6)
{
	UpdateArgCount_11d3 updateArgCount_11d3;
	updateArgCount_11d3( args_11d4, mains_11d6);
}

void DataInput_1290::operator()( const Packets_t& states_1291, const Packets_t& mains_1294, Packets_t& args_1293, Packets_t& mains_1296)
{
#ifdef PRINT_INFO
	printLog( "DataInput_1290" );
#endif
	RTTGenerator::Instance()->generateRule(987, "DataInput");
	_arg_1297= &args_1293;
	_main_1298= &mains_1296;
	processInputPackets( states_1291, mains_1294);
}

bool DataInput_1290::isInputUnique( const Udm::Object& state_129d, const Udm::Object& main_12a6)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_129f= _state_1299.begin(), itMain_12a8= _main_12a2.begin(); itState_129f!= _state_1299.end(), itMain_12a8!= _main_12a2.end(); ++itState_129f, ++itMain_12a8)
	{
		if( ( *itState_129f== state_129d)&& ( *itMain_12a8== main_12a6))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1299.push_back( state_129d);
		_main_12a2.push_back( main_12a6);
	}
	return isUnique;
}

bool DataInput_1290::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool DataInput_1290::isGuardTrue( SFC::DT& DT, CyberComposition::Simulink::Data& Data, SFC::Function& Main, CyberComposition::Simulink::State& State, CyberComposition::Simulink::SF_TypeBase& TypeBase, CyberComposition::Simulink::TypeBaseRef& TypeBaseRef)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( Data.Scope() ) == "INPUT_DATA";;
	return Gz_guard;
}

void DataInput_1290::processInputPackets( const Packets_t& states_1291, const Packets_t& mains_1294)
{
	for( Packets_t::const_iterator itState_129a= states_1291.begin(), itMain_12a3= mains_1294.begin(); itState_129a!= states_1291.end(), itMain_12a3!= mains_1294.end(); ++itState_129a, ++itMain_12a3)
	{
		bool isUnique= isInputUnique( *itState_129a, *itMain_12a3);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_129a, *itMain_12a3);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool DataInput_1290::patternMatcher( const Udm::Object& state_129b, const Udm::Object& main_12a4)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_129b.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_12a0= CyberComposition::Simulink::State::Cast( state_129b);
		if( false== Uml::IsDerivedFrom( main_12a4.type(), SFC::Function::meta))
			continue;
		SFC::Function main_12a9= SFC::Function::Cast( main_12a4);
		set< CyberComposition::Simulink::Data> datas_12ab= state_12a0.Data_kind_children();
		for( set< CyberComposition::Simulink::Data>::const_iterator itData_12ac= datas_12ab.begin(); itData_12ac!= datas_12ab.end(); ++itData_12ac)
		{
			CyberComposition::Simulink::Data currData_12ad= *itData_12ac;
			set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_12ae= currData_12ad.TypeBaseRef_kind_children();
			for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_12af= typeBaseRefs_12ae.begin(); itTypeBaseRef_12af!= typeBaseRefs_12ae.end(); ++itTypeBaseRef_12af)
			{
				CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_12b0= *itTypeBaseRef_12af;
				CyberComposition::Simulink::SF_TypeBase typeBase_12b1= currTypeBaseRef_12b0.ref();
				if( !typeBase_12b1)
					continue;
				SFC::DT dT_12b2= typeBase_12b1.dt();
				if( !dT_12b2)
					continue;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_12b6;
				if( !isValidBound(boundObjs_12b6, state_12a0, true))
					continue;
				currMatch.state_12b7= state_12a0;
				if( !isValidBound(boundObjs_12b6, main_12a9, true))
					continue;
				currMatch.main_12b8= main_12a9;
				if( !isValidBound(boundObjs_12b6, typeBase_12b1, false))
					continue;
				currMatch.typeBase_12b9= typeBase_12b1;
				if( !isValidBound(boundObjs_12b6, dT_12b2, false))
					continue;
				currMatch.dT_12ba= dT_12b2;
				if( !isValidBound(boundObjs_12b6, currData_12ad, false))
					continue;
				currMatch.data_12bb= currData_12ad;
				if( !isValidBound(boundObjs_12b6, currTypeBaseRef_12b0, false))
					continue;
				currMatch.typeBaseRef_12bc= currTypeBaseRef_12b0;
				bool Gz_guard= isGuardTrue( currMatch.dT_12ba, currMatch.data_12bb, currMatch.main_12b8, currMatch.state_12b7, currMatch.typeBase_12b9, currMatch.typeBaseRef_12bc);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void DataInput_1290::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg newArg_12c3= SFC::Arg::Create( currMatch.main_12b8);
		SFC::Arg& Arg= newArg_12c3;
		SFC::DT& DT= currMatch.dT_12ba;
		CyberComposition::Simulink::Data& Data= currMatch.data_12bb;
		SFC::Function& Main= currMatch.main_12b8;
		CyberComposition::Simulink::State& State= currMatch.state_12b7;
		CyberComposition::Simulink::SF_TypeBase& TypeBase= currMatch.typeBase_12b9;
		CyberComposition::Simulink::TypeBaseRef& TypeBaseRef= currMatch.typeBaseRef_12bc;
		{
__int64 argIndex = static_cast< __int64 >( Main.argCount() ) + static_cast< __int64 >( Data.Port() ) - 1;
Arg.argIndex() = argIndex;

Arg.name() = static_cast< std::string >( Data.Name() ) + "_" + boost::lexical_cast< std::string >( argIndex );
};
		newArg_12c3.dt()= currMatch.dT_12ba;
		outputAppender( newArg_12c3, currMatch.main_12b8);
	}
}

void DataInput_1290::outputAppender( const SFC::Arg& arg_12c4, const SFC::Function& main_12c6)
{
	_arg_1297->push_back( arg_12c4);
	_main_1298->push_back( main_12c6);
}

void CreateChartFunction_12da::operator()( const Packets_t& subsystems_12dc, Packets_t& states_12db, Packets_t& mains_12de)
{
#ifdef PRINT_INFO
	printLog( "CreateChartFunction_12da" );
#endif
	RTTGenerator::Instance()->generateRule(1007, "CreateChartFunction");
	_state_12df= &states_12db;
	_main_12e0= &mains_12de;
	processInputPackets( subsystems_12dc);
}

bool CreateChartFunction_12da::isInputUnique( const Udm::Object& subsystem_12e5)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_12e7= _subsystem_12e1.begin(); itSubsystem_12e7!= _subsystem_12e1.end(); ++itSubsystem_12e7)
	{
		if( ( *itSubsystem_12e7== subsystem_12e5))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_subsystem_12e1.push_back( subsystem_12e5);
	return isUnique;
}

bool CreateChartFunction_12da::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateChartFunction_12da::processInputPackets( const Packets_t& subsystems_12dc)
{
	for( Packets_t::const_iterator itSubsystem_12e2= subsystems_12dc.begin(); itSubsystem_12e2!= subsystems_12dc.end(); ++itSubsystem_12e2)
	{
		bool isUnique= isInputUnique( *itSubsystem_12e2);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_12e2);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateChartFunction_12da::patternMatcher( const Udm::Object& subsystem_12e3)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_12e3.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_12e8= CyberComposition::Simulink::Subsystem::Cast( subsystem_12e3);
		set< CyberComposition::Simulink::Primitive> primitives_12ea= subsystem_12e8.Primitive_kind_children();
		for( set< CyberComposition::Simulink::Primitive>::const_iterator itPrimitive_12eb= primitives_12ea.begin(); itPrimitive_12eb!= primitives_12ea.end(); ++itPrimitive_12eb)
		{
			CyberComposition::Simulink::Primitive currPrimitive_12ec= *itPrimitive_12eb;
			set< CyberComposition::Simulink::State> states_12ed= currPrimitive_12ec.State_kind_children();
			for( set< CyberComposition::Simulink::State>::const_iterator itState_12ee= states_12ed.begin(); itState_12ee!= states_12ed.end(); ++itState_12ee)
			{
				CyberComposition::Simulink::State currState_12ef= *itState_12ee;
				SFC::Class class_12f0= subsystem_12e8.cls();
				if( !class_12f0)
					continue;
				set< SFC::Struct> structs_12f1= class_12f0.Struct_kind_children();
				for( set< SFC::Struct>::const_iterator itStruct_12f2= structs_12f1.begin(); itStruct_12f2!= structs_12f1.end(); ++itStruct_12f2)
				{
					SFC::Struct currStruct_12f3= *itStruct_12f2;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_12f7;
					if( !isValidBound(boundObjs_12f7, subsystem_12e8, true))
						continue;
					currMatch.subsystem_12f8= subsystem_12e8;
					if( !isValidBound(boundObjs_12f7, currPrimitive_12ec, false))
						continue;
					currMatch.primitive_12f9= currPrimitive_12ec;
					if( !isValidBound(boundObjs_12f7, currState_12ef, false))
						continue;
					currMatch.state_12fa= currState_12ef;
					if( !isValidBound(boundObjs_12f7, class_12f0, false))
						continue;
					currMatch.class_12fb= class_12f0;
					if( !isValidBound(boundObjs_12f7, currStruct_12f3, false))
						continue;
					currMatch.struct_12fc= currStruct_12f3;
					_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void CreateChartFunction_12da::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function newMain_12fd= SFC::Function::Create( currMatch.class_12fb, SFC::Class::meta_stmnt);
		SFC::Arg newArg_12fe= SFC::Arg::Create( newMain_12fd);
		SFC::Arg& Arg= newArg_12fe;
		SFC::Class& Class= currMatch.class_12fb;
		SFC::Function& Main= newMain_12fd;
		CyberComposition::Simulink::Primitive& Primitive= currMatch.primitive_12f9;
		CyberComposition::Simulink::State& State= currMatch.state_12fa;
		SFC::Struct& Struct= currMatch.struct_12fc;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_12f8;
		{
Main.statementCount() = -1;
};
		{
__int64 argCount = Main.argCount();
Arg.argIndex() = argCount++;
Main.argCount() = argCount;

Arg.name() = "context";
Arg.ptr() = true;
};
		{
__int64 statementCount = Class.statementCount();
Main.statementIndex() = statementCount++;
Class.statementCount() = statementCount;
};
		{
Main.name() = static_cast< std::string >( Subsystem.name() ) + "_main";
};
		newArg_12fe.dt()= currMatch.struct_12fc;
		newMain_12fd.sysmain()+= currMatch.subsystem_12f8;
		outputAppender( currMatch.state_12fa, newMain_12fd);
	}
}

void CreateChartFunction_12da::outputAppender( const CyberComposition::Simulink::State& state_12ff, const SFC::Function& main_1301)
{
	_state_12df->push_back( state_12ff);
	_main_12e0->push_back( main_1301);
}

void MakeArguments_1303::operator()( const Packets_t& systems_1304, const Packets_t& functions_1306, Packets_t& systems_1308)
{
#ifdef PRINT_INFO
	printLog( "MakeArguments_1303" );
#endif
	_system_1309= &systems_1308;
	if( ( !systems_1304.empty())&& ( !functions_1306.empty()))
		callTrigs_1586( systems_1304, functions_1306);
}

void MakeArguments_1303::callTrigs_1586( const Packets_t& systems_1466, const Packets_t& functions_1468)
{
	Packets_t systems_146a;
	Packets_t functions_146b;
	Trigs_1465 trigs_1465;
	trigs_1465( systems_1466, functions_1468, systems_146a, functions_146b);
	if( ( !systems_146a.empty())&& ( !functions_146b.empty()))
		callActions_1589( systems_146a, functions_146b);
}

void MakeArguments_1303::callActions_1589( const Packets_t& systems_130b, const Packets_t& functions_130d)
{
	Packets_t systems_130f;
	Packets_t functions_1310;
	Actions_130a actions_130a;
	actions_130a( systems_130b, functions_130d, systems_130f, functions_1310);
	if( ( !systems_130f.empty())&& ( !functions_1310.empty()))
		callInputs_158c( systems_130f, functions_1310);
}

void MakeArguments_1303::callInputs_158c( const Packets_t& systems_149f, const Packets_t& functions_14a1)
{
	Packets_t systems_14a3;
	Packets_t functions_14a4;
	Inputs_149e inputs_149e;
	inputs_149e( systems_149f, functions_14a1, systems_14a3, functions_14a4);
	if( ( !systems_14a3.empty())&& ( !functions_14a4.empty()))
		callOutputs_158f( systems_14a3, functions_14a4);
}

void MakeArguments_1303::callOutputs_158f( const Packets_t& systems_1513, const Packets_t& functions_1515)
{
	Packets_t systems_1517;
	Packets_t functions_1518;
	Outputs_1512 outputs_1512;
	outputs_1512( systems_1513, functions_1515, systems_1517, functions_1518);
	if( ( !systems_1517.empty())&& ( !functions_1518.empty()))
		callZeroUnconOutputs_1592( systems_1517, functions_1518);
}

void MakeArguments_1303::callZeroUnconOutputs_1592( const Packets_t& systems_1371, const Packets_t& functions_1373)
{
	Packets_t systems_1375;
	ZeroUnconOutputs_1370 zeroUnconOutputs_1370;
	zeroUnconOutputs_1370( systems_1371, functions_1373, systems_1375);
	_system_1309->insert( _system_1309->end(), systems_1375.begin(), systems_1375.end());
}

void Actions_130a::operator()( const Packets_t& systems_130b, const Packets_t& functions_130d, Packets_t& systems_130f, Packets_t& functions_1310)
{
#ifdef PRINT_INFO
	printLog( "Actions_130a" );
#endif
	_system_1311= &systems_130f;
	_function_1312= &functions_1310;
	_system_1311->insert( _system_1311->end(), systems_130b.begin(), systems_130b.end());
	_function_1312->insert( _function_1312->end(), functions_130d.begin(), functions_130d.end());
	if( ( !systems_130b.empty())&& ( !functions_130d.empty()))
		callCreateTriggerPortArgs_136a( systems_130b, functions_130d);
}

void Actions_130a::callCreateTriggerPortArgs_136a( const Packets_t& subsystems_1314, const Packets_t& mains_1318)
{
	Packets_t actionPorts_1316;
	Packets_t args_1317;
	CreateTriggerPortArgs_1313 createTriggerPortArgs_1313;
	createTriggerPortArgs_1313( subsystems_1314, mains_1318, actionPorts_1316, args_1317);
	if( ( !actionPorts_1316.empty())&& ( !args_1317.empty()))
		callAssignType_136d( actionPorts_1316, args_1317);
}

void Actions_130a::callAssignType_136d( const Packets_t& ports_133e, const Packets_t& argvars_1340)
{
	AssignType_133d assignType_133d;
	assignType_133d( ports_133e, argvars_1340);
}

void CreateTriggerPortArgs_1313::operator()( const Packets_t& subsystems_1314, const Packets_t& mains_1318, Packets_t& actionPorts_1316, Packets_t& args_1317)
{
#ifdef PRINT_INFO
	printLog( "CreateTriggerPortArgs_1313" );
#endif
	RTTGenerator::Instance()->generateRule(1036, "CreateTriggerPortArgs");
	_actionPort_131a= &actionPorts_1316;
	_arg_131b= &args_1317;
	processInputPackets( subsystems_1314, mains_1318);
}

bool CreateTriggerPortArgs_1313::isInputUnique( const Udm::Object& subsystem_1320, const Udm::Object& main_1329)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1322= _subsystem_131c.begin(), itMain_132b= _main_1325.begin(); itSubsystem_1322!= _subsystem_131c.end(), itMain_132b!= _main_1325.end(); ++itSubsystem_1322, ++itMain_132b)
	{
		if( ( *itSubsystem_1322== subsystem_1320)&& ( *itMain_132b== main_1329))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_131c.push_back( subsystem_1320);
		_main_1325.push_back( main_1329);
	}
	return isUnique;
}

bool CreateTriggerPortArgs_1313::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateTriggerPortArgs_1313::processInputPackets( const Packets_t& subsystems_1314, const Packets_t& mains_1318)
{
	for( Packets_t::const_iterator itSubsystem_131d= subsystems_1314.begin(), itMain_1326= mains_1318.begin(); itSubsystem_131d!= subsystems_1314.end(), itMain_1326!= mains_1318.end(); ++itSubsystem_131d, ++itMain_1326)
	{
		bool isUnique= isInputUnique( *itSubsystem_131d, *itMain_1326);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_131d, *itMain_1326);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateTriggerPortArgs_1313::patternMatcher( const Udm::Object& subsystem_131e, const Udm::Object& main_1327)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_131e.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1323= CyberComposition::Simulink::Subsystem::Cast( subsystem_131e);
		if( false== Uml::IsDerivedFrom( main_1327.type(), SFC::Function::meta))
			continue;
		SFC::Function main_132c= SFC::Function::Cast( main_1327);
		set< CyberComposition::Simulink::EnablePort> actionPorts_132e= subsystem_1323.EnablePort_kind_children();
		for( set< CyberComposition::Simulink::EnablePort>::const_iterator itActionPort_132f= actionPorts_132e.begin(); itActionPort_132f!= actionPorts_132e.end(); ++itActionPort_132f)
		{
			CyberComposition::Simulink::EnablePort currActionPort_1330= *itActionPort_132f;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1334;
			if( !isValidBound(boundObjs_1334, subsystem_1323, true))
				continue;
			currMatch.subsystem_1335= subsystem_1323;
			if( !isValidBound(boundObjs_1334, main_132c, true))
				continue;
			currMatch.main_1336= main_132c;
			if( !isValidBound(boundObjs_1334, currActionPort_1330, false))
				continue;
			currMatch.actionPort_1337= currActionPort_1330;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateTriggerPortArgs_1313::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg newArg_1338= SFC::Arg::Create( currMatch.main_1336);
		CyberComposition::Simulink::EnablePort& ActionPort= currMatch.actionPort_1337;
		SFC::Arg& Arg= newArg_1338;
		SFC::Function& Main= currMatch.main_1336;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_1335;
		{
__int64 argCount = Main.argCount();
Arg.argIndex() = argCount++;
Main.argCount() = argCount;

Arg.name() = "action_" + boost::lexical_cast< std::string >( argCount - 1 );
Arg.type() = "int";
};
		newArg_1338.port()+= currMatch.actionPort_1337;
		outputAppender( currMatch.actionPort_1337, newArg_1338);
	}
}

void CreateTriggerPortArgs_1313::outputAppender( const CyberComposition::Simulink::EnablePort& actionPort_1339, const SFC::Arg& arg_133b)
{
	_actionPort_131a->push_back( actionPort_1339);
	_arg_131b->push_back( arg_133b);
}

void AssignType_133d::operator()( const Packets_t& ports_133e, const Packets_t& argvars_1340)
{
#ifdef PRINT_INFO
	printLog( "AssignType_133d" );
#endif
	if( ( !ports_133e.empty())&& ( !argvars_1340.empty()))
		callAssignType_1367( ports_133e, argvars_1340);
}

void AssignType_133d::callAssignType_1367( const Packets_t& ports_1343, const Packets_t& argvars_1345)
{
	AssignType_1342 assignType_1342;
	assignType_1342( ports_1343, argvars_1345);
}

void AssignType_1342::operator()( const Packets_t& ports_1343, const Packets_t& argvars_1345)
{
#ifdef PRINT_INFO
	printLog( "AssignType_1342" );
#endif
	RTTGenerator::Instance()->generateRule(1969, "AssignType");
	processInputPackets( ports_1343, argvars_1345);
}

bool AssignType_1342::isInputUnique( const Udm::Object& port_134b, const Udm::Object& argvar_1354)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itPort_134d= _port_1347.begin(), itargvar_1356= _argvar_1350.begin(); itPort_134d!= _port_1347.end(), itargvar_1356!= _argvar_1350.end(); ++itPort_134d, ++itargvar_1356)
	{
		if( ( *itPort_134d== port_134b)&& ( *itargvar_1356== argvar_1354))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_port_1347.push_back( port_134b);
		_argvar_1350.push_back( argvar_1354);
	}
	return isUnique;
}

bool AssignType_1342::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void AssignType_1342::processInputPackets( const Packets_t& ports_1343, const Packets_t& argvars_1345)
{
	for( Packets_t::const_iterator itPort_1348= ports_1343.begin(), itargvar_1351= argvars_1345.begin(); itPort_1348!= ports_1343.end(), itargvar_1351!= argvars_1345.end(); ++itPort_1348, ++itargvar_1351)
	{
		bool isUnique= isInputUnique( *itPort_1348, *itargvar_1351);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itPort_1348, *itargvar_1351);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AssignType_1342::patternMatcher( const Udm::Object& port_1349, const Udm::Object& argvar_1352)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( port_1349.type(), CyberComposition::Simulink::SF_Port::meta))
			continue;
		CyberComposition::Simulink::SF_Port port_134e= CyberComposition::Simulink::SF_Port::Cast( port_1349);
		if( false== Uml::IsDerivedFrom( argvar_1352.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argvar_1357= SFC::ArgDeclBase::Cast( argvar_1352);
		set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_1359= port_134e.TypeBaseRef_kind_children();
		for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_135a= typeBaseRefs_1359.begin(); itTypeBaseRef_135a!= typeBaseRefs_1359.end(); ++itTypeBaseRef_135a)
		{
			CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_135b= *itTypeBaseRef_135a;
			CyberComposition::Simulink::SF_TypeBase typeBase_135c= currTypeBaseRef_135b.ref();
			if( !typeBase_135c)
				continue;
			SFC::DT dT_135d= typeBase_135c.dt();
			if( !dT_135d)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1361;
			if( !isValidBound(boundObjs_1361, port_134e, true))
				continue;
			currMatch.port_1362= port_134e;
			if( !isValidBound(boundObjs_1361, argvar_1357, true))
				continue;
			currMatch.argvar_1363= argvar_1357;
			if( !isValidBound(boundObjs_1361, currTypeBaseRef_135b, false))
				continue;
			currMatch.typeBaseRef_1364= currTypeBaseRef_135b;
			if( !isValidBound(boundObjs_1361, typeBase_135c, false))
				continue;
			currMatch.typeBase_1365= typeBase_135c;
			if( !isValidBound(boundObjs_1361, dT_135d, false))
				continue;
			currMatch.dT_1366= dT_135d;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void AssignType_1342::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		currMatch.argvar_1363.dt()= currMatch.dT_1366;
	}
}

void ZeroUnconOutputs_1370::operator()( const Packets_t& systems_1371, const Packets_t& functions_1373, Packets_t& systems_1375)
{
#ifdef PRINT_INFO
	printLog( "ZeroUnconOutputs_1370" );
#endif
	_system_1376= &systems_1375;
	if( ( !systems_1371.empty())&& ( !functions_1373.empty()))
		callGetOutputPorts_145c( systems_1371, functions_1373);
	_system_1376->insert( _system_1376->end(), systems_1371.begin(), systems_1371.end());
}

void ZeroUnconOutputs_1370::callGetOutputPorts_145c( const Packets_t& subsystems_1399, const Packets_t& mains_139c)
{
	Packets_t outPorts_139b;
	Packets_t mains_139e;
	GetOutputPorts_1398 getOutputPorts_1398;
	getOutputPorts_1398( subsystems_1399, mains_139c, outPorts_139b, mains_139e);
	if( ( !outPorts_139b.empty())&& ( !mains_139e.empty()))
		callOutPortConnected_145f( outPorts_139b, mains_139e);
}

void ZeroUnconOutputs_1370::callOutPortConnected_145f( const Packets_t& outps_13c2, const Packets_t& functions_13c4)
{
	Packets_t outps_13c6;
	Packets_t functions_13c7;
	Packets_t outps_13c8;
	Packets_t functions_13c9;
	Packets_t outps_13ca;
	Packets_t functions_13cb;
	OutPortConnected_13c1 outPortConnected_13c1;
	outPortConnected_13c1( outps_13c2, functions_13c4, outps_13c6, functions_13c7, outps_13c8, functions_13c9, outps_13ca, functions_13cb);
	if( ( !outps_13ca.empty())&& ( !functions_13cb.empty()))
		callZeroOutPort_1462( outps_13ca, functions_13cb);
}

void ZeroUnconOutputs_1370::callZeroOutPort_1462( const Packets_t& outPorts_1378, const Packets_t& mains_137a)
{
	ZeroOutPort_1377 zeroOutPort_1377;
	zeroOutPort_1377( outPorts_1378, mains_137a);
}

void ZeroOutPort_1377::operator()( const Packets_t& outPorts_1378, const Packets_t& mains_137a)
{
#ifdef PRINT_INFO
	printLog( "ZeroOutPort_1377" );
#endif
	RTTGenerator::Instance()->generateRule(1049, "ZeroOutPort");
	processInputPackets( outPorts_1378, mains_137a);
}

bool ZeroOutPort_1377::isInputUnique( const Udm::Object& outPort_1380, const Udm::Object& main_1389)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itOutPort_1382= _outPort_137c.begin(), itMain_138b= _main_1385.begin(); itOutPort_1382!= _outPort_137c.end(), itMain_138b!= _main_1385.end(); ++itOutPort_1382, ++itMain_138b)
	{
		if( ( *itOutPort_1382== outPort_1380)&& ( *itMain_138b== main_1389))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_outPort_137c.push_back( outPort_1380);
		_main_1385.push_back( main_1389);
	}
	return isUnique;
}

bool ZeroOutPort_1377::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void ZeroOutPort_1377::processInputPackets( const Packets_t& outPorts_1378, const Packets_t& mains_137a)
{
	for( Packets_t::const_iterator itOutPort_137d= outPorts_1378.begin(), itMain_1386= mains_137a.begin(); itOutPort_137d!= outPorts_1378.end(), itMain_1386!= mains_137a.end(); ++itOutPort_137d, ++itMain_1386)
	{
		bool isUnique= isInputUnique( *itOutPort_137d, *itMain_1386);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itOutPort_137d, *itMain_1386);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ZeroOutPort_1377::patternMatcher( const Udm::Object& outPort_137e, const Udm::Object& main_1387)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( outPort_137e.type(), CyberComposition::Simulink::OutPort::meta))
			continue;
		CyberComposition::Simulink::OutPort outPort_1383= CyberComposition::Simulink::OutPort::Cast( outPort_137e);
		if( false== Uml::IsDerivedFrom( main_1387.type(), SFC::Function::meta))
			continue;
		SFC::Function main_138c= SFC::Function::Cast( main_1387);
		set< SFC::Arg> args_138e= outPort_1383.arg();
		for( set< SFC::Arg>::const_iterator itArgs_138f= args_138e.begin(); itArgs_138f!= args_138e.end(); ++itArgs_138f)
		{
			SFC::Arg currArg_1390= *itArgs_138f;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1394;
			if( !isValidBound(boundObjs_1394, outPort_1383, true))
				continue;
			currMatch.outPort_1395= outPort_1383;
			if( !isValidBound(boundObjs_1394, main_138c, true))
				continue;
			currMatch.main_1396= main_138c;
			if( !isValidBound(boundObjs_1394, currArg_1390, false))
				continue;
			currMatch.arg_1397= currArg_1390;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void ZeroOutPort_1377::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg& Arg= currMatch.arg_1397;
		SFC::Function& Main= currMatch.main_1396;
		CyberComposition::Simulink::OutPort& OutPort= currMatch.outPort_1395;
		{
SFUtils::ZeroInit( Main, Arg );
};
	}
}

void GetOutputPorts_1398::operator()( const Packets_t& subsystems_1399, const Packets_t& mains_139c, Packets_t& outPorts_139b, Packets_t& mains_139e)
{
#ifdef PRINT_INFO
	printLog( "GetOutputPorts_1398" );
#endif
	RTTGenerator::Instance()->generateRule(1055, "GetOutputPorts");
	_outPort_139f= &outPorts_139b;
	_main_13a0= &mains_139e;
	processInputPackets( subsystems_1399, mains_139c);
}

bool GetOutputPorts_1398::isInputUnique( const Udm::Object& subsystem_13a5, const Udm::Object& main_13ae)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_13a7= _subsystem_13a1.begin(), itMain_13b0= _main_13aa.begin(); itSubsystem_13a7!= _subsystem_13a1.end(), itMain_13b0!= _main_13aa.end(); ++itSubsystem_13a7, ++itMain_13b0)
	{
		if( ( *itSubsystem_13a7== subsystem_13a5)&& ( *itMain_13b0== main_13ae))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_13a1.push_back( subsystem_13a5);
		_main_13aa.push_back( main_13ae);
	}
	return isUnique;
}

bool GetOutputPorts_1398::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetOutputPorts_1398::processInputPackets( const Packets_t& subsystems_1399, const Packets_t& mains_139c)
{
	for( Packets_t::const_iterator itSubsystem_13a2= subsystems_1399.begin(), itMain_13ab= mains_139c.begin(); itSubsystem_13a2!= subsystems_1399.end(), itMain_13ab!= mains_139c.end(); ++itSubsystem_13a2, ++itMain_13ab)
	{
		bool isUnique= isInputUnique( *itSubsystem_13a2, *itMain_13ab);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_13a2, *itMain_13ab);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetOutputPorts_1398::patternMatcher( const Udm::Object& subsystem_13a3, const Udm::Object& main_13ac)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_13a3.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_13a8= CyberComposition::Simulink::Subsystem::Cast( subsystem_13a3);
		if( false== Uml::IsDerivedFrom( main_13ac.type(), SFC::Function::meta))
			continue;
		SFC::Function main_13b1= SFC::Function::Cast( main_13ac);
		set< CyberComposition::Simulink::OutPort> outPorts_13b3= subsystem_13a8.OutPort_kind_children();
		for( set< CyberComposition::Simulink::OutPort>::const_iterator itOutPort_13b4= outPorts_13b3.begin(); itOutPort_13b4!= outPorts_13b3.end(); ++itOutPort_13b4)
		{
			CyberComposition::Simulink::OutPort currOutPort_13b5= *itOutPort_13b4;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_13b9;
			if( !isValidBound(boundObjs_13b9, subsystem_13a8, true))
				continue;
			currMatch.subsystem_13ba= subsystem_13a8;
			if( !isValidBound(boundObjs_13b9, main_13b1, true))
				continue;
			currMatch.main_13bb= main_13b1;
			if( !isValidBound(boundObjs_13b9, currOutPort_13b5, false))
				continue;
			currMatch.outPort_13bc= currOutPort_13b5;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetOutputPorts_1398::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.outPort_13bc, currMatch.main_13bb);
	}
}

void GetOutputPorts_1398::outputAppender( const CyberComposition::Simulink::OutPort& outPort_13bd, const SFC::Function& main_13bf)
{
	_outPort_139f->push_back( outPort_13bd);
	_main_13a0->push_back( main_13bf);
}

void OutPortConnected_13c1::operator()( const Packets_t& outps_13c2, const Packets_t& functions_13c4, Packets_t& outps_13c6, Packets_t& functions_13c7, Packets_t& outps_13c8, Packets_t& functions_13c9, Packets_t& outps_13ca, Packets_t& functions_13cb)
{
#ifdef PRINT_INFO
	printLog( "OutPortConnected_13c1" );
#endif
	_outp_13cc= &outps_13c6;
	_function_13cd= &functions_13c7;
	_outp_13ce= &outps_13c8;
	_function_13cf= &functions_13c9;
	_outp_13d0= &outps_13ca;
	_function_13d1= &functions_13cb;
	for( Packets_t::const_iterator itoutp_13d3= outps_13c2.begin(), itfunction_13da= functions_13c4.begin(); itoutp_13d3!= outps_13c2.end(), itfunction_13da!= functions_13c4.end(); ++itoutp_13d3, ++itfunction_13da)
	{
		bool isUnique= isInputUnique( *itoutp_13d3, *itfunction_13da);
		if( !isUnique)
			continue;
		Packets_t oneoutp_13d7( 1, *itoutp_13d3);
		Packets_t onefunction_13de( 1, *itfunction_13da);
		executeOne( oneoutp_13d7, onefunction_13de);
	}
}

void OutPortConnected_13c1::executeOne( const Packets_t& outps_13c2, const Packets_t& functions_13c4)
{
	Packets_t outPorts_13e3;
	Packets_t mains_13e6;
	Connected_line_13e0 connected_line_13e0;
	bool isMatchConnected_line_13e0= connected_line_13e0( outps_13c2, functions_13c4, outPorts_13e3, mains_13e6);
	_outp_13cc->insert( _outp_13cc->end(), outPorts_13e3.begin(), outPorts_13e3.end());
	_function_13cd->insert( _function_13cd->end(), mains_13e6.begin(), mains_13e6.end());
	if( isMatchConnected_line_13e0)
		return;
	Packets_t outPorts_140e;
	Packets_t mains_1411;
	Connected_ConnToSFStates_140b connected_ConnToSFStates_140b;
	bool isMatchConnected_ConnToSFStates_140b= connected_ConnToSFStates_140b( outps_13c2, functions_13c4, outPorts_140e, mains_1411);
	_outp_13ce->insert( _outp_13ce->end(), outPorts_140e.begin(), outPorts_140e.end());
	_function_13cf->insert( _function_13cf->end(), mains_1411.begin(), mains_1411.end());
	if( isMatchConnected_ConnToSFStates_140b)
		return;
	Packets_t outPorts_143a;
	Packets_t mains_143d;
	Otherwise_1437 otherwise_1437;
	bool isMatchOtherwise_1437= otherwise_1437( outps_13c2, functions_13c4, outPorts_143a, mains_143d);
	_outp_13d0->insert( _outp_13d0->end(), outPorts_143a.begin(), outPorts_143a.end());
	_function_13d1->insert( _function_13d1->end(), mains_143d.begin(), mains_143d.end());
	if( isMatchOtherwise_1437)
		return;
}

bool OutPortConnected_13c1::isInputUnique( const Udm::Object& outp_13d4, const Udm::Object& function_13db)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itoutp_13d6= _outp_13d2.begin(), itfunction_13dd= _function_13d9.begin(); itoutp_13d6!= _outp_13d2.end(), itfunction_13dd!= _function_13d9.end(); ++itoutp_13d6, ++itfunction_13dd)
	{
		if( ( *itoutp_13d6== outp_13d4)&& ( *itfunction_13dd== function_13db))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_outp_13d2.push_back( outp_13d4);
		_function_13d9.push_back( function_13db);
	}
	return isUnique;
}

bool Connected_line_13e0::operator()( const Packets_t& outPorts_13e1, const Packets_t& mains_13e4, Packets_t& outPorts_13e3, Packets_t& mains_13e6)
{
#ifdef PRINT_INFO
	printLog( "Connected_line_13e0" );
#endif
	_outPort_13e7= &outPorts_13e3;
	_main_13e8= &mains_13e6;
	processInputPackets( outPorts_13e1, mains_13e4);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Connected_line_13e0::isInputUnique( const Udm::Object& outPort_13ed, const Udm::Object& main_13f6)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itOutPort_13ef= _outPort_13e9.begin(), itMain_13f8= _main_13f2.begin(); itOutPort_13ef!= _outPort_13e9.end(), itMain_13f8!= _main_13f2.end(); ++itOutPort_13ef, ++itMain_13f8)
	{
		if( ( *itOutPort_13ef== outPort_13ed)&& ( *itMain_13f8== main_13f6))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_outPort_13e9.push_back( outPort_13ed);
		_main_13f2.push_back( main_13f6);
	}
	return isUnique;
}

bool Connected_line_13e0::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Connected_line_13e0::processInputPackets( const Packets_t& outPorts_13e1, const Packets_t& mains_13e4)
{
	for( Packets_t::const_iterator itOutPort_13ea= outPorts_13e1.begin(), itMain_13f3= mains_13e4.begin(); itOutPort_13ea!= outPorts_13e1.end(), itMain_13f3!= mains_13e4.end(); ++itOutPort_13ea, ++itMain_13f3)
	{
		bool isUnique= isInputUnique( *itOutPort_13ea, *itMain_13f3);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itOutPort_13ea, *itMain_13f3);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.outPort_1403, currMatch.main_1404);
	}
}

bool Connected_line_13e0::patternMatcher( const Udm::Object& outPort_13eb, const Udm::Object& main_13f4)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( outPort_13eb.type(), CyberComposition::Simulink::OutPort::meta))
			continue;
		CyberComposition::Simulink::OutPort outPort_13f0= CyberComposition::Simulink::OutPort::Cast( outPort_13eb);
		if( false== Uml::IsDerivedFrom( main_13f4.type(), SFC::Function::meta))
			continue;
		SFC::Function main_13f9= SFC::Function::Cast( main_13f4);
		set< CyberComposition::Simulink::Line> lines_13fb= outPort_13f0.srcLine();
		for( set< CyberComposition::Simulink::Line>::const_iterator itLines_13fc= lines_13fb.begin(); itLines_13fc!= lines_13fb.end(); ++itLines_13fc)
		{
			CyberComposition::Simulink::Line currLine_13fd= *itLines_13fc;
			CyberComposition::Simulink::SF_Port port_13fe= currLine_13fd.srcLine_end();
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1402;
			if( !isValidBound(boundObjs_1402, outPort_13f0, true))
				continue;
			currMatch.outPort_1403= outPort_13f0;
			if( !isValidBound(boundObjs_1402, main_13f9, true))
				continue;
			currMatch.main_1404= main_13f9;
			if( !isValidBound(boundObjs_1402, currLine_13fd, false))
				continue;
			currMatch.line_1405= currLine_13fd;
			if( !isValidBound(boundObjs_1402, port_13fe, false))
				continue;
			currMatch.port_1406= port_13fe;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void Connected_line_13e0::outputAppender( const CyberComposition::Simulink::OutPort& outPort_1407, const SFC::Function& main_1409)
{
	_outPort_13e7->push_back( outPort_1407);
	_main_13e8->push_back( main_1409);
}

bool Connected_ConnToSFStates_140b::operator()( const Packets_t& outPorts_140c, const Packets_t& mains_140f, Packets_t& outPorts_140e, Packets_t& mains_1411)
{
#ifdef PRINT_INFO
	printLog( "Connected_ConnToSFStates_140b" );
#endif
	_outPort_1412= &outPorts_140e;
	_main_1413= &mains_1411;
	processInputPackets( outPorts_140c, mains_140f);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Connected_ConnToSFStates_140b::isInputUnique( const Udm::Object& outPort_1418, const Udm::Object& main_1421)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itOutPort_141a= _outPort_1414.begin(), itMain_1423= _main_141d.begin(); itOutPort_141a!= _outPort_1414.end(), itMain_1423!= _main_141d.end(); ++itOutPort_141a, ++itMain_1423)
	{
		if( ( *itOutPort_141a== outPort_1418)&& ( *itMain_1423== main_1421))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_outPort_1414.push_back( outPort_1418);
		_main_141d.push_back( main_1421);
	}
	return isUnique;
}

bool Connected_ConnToSFStates_140b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Connected_ConnToSFStates_140b::processInputPackets( const Packets_t& outPorts_140c, const Packets_t& mains_140f)
{
	for( Packets_t::const_iterator itOutPort_1415= outPorts_140c.begin(), itMain_141e= mains_140f.begin(); itOutPort_1415!= outPorts_140c.end(), itMain_141e!= mains_140f.end(); ++itOutPort_1415, ++itMain_141e)
	{
		bool isUnique= isInputUnique( *itOutPort_1415, *itMain_141e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itOutPort_1415, *itMain_141e);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.outPort_142f, currMatch.main_1430);
	}
}

bool Connected_ConnToSFStates_140b::patternMatcher( const Udm::Object& outPort_1416, const Udm::Object& main_141f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( outPort_1416.type(), CyberComposition::Simulink::OutPort::meta))
			continue;
		CyberComposition::Simulink::OutPort outPort_141b= CyberComposition::Simulink::OutPort::Cast( outPort_1416);
		if( false== Uml::IsDerivedFrom( main_141f.type(), SFC::Function::meta))
			continue;
		SFC::Function main_1424= SFC::Function::Cast( main_141f);
		set< CyberComposition::Simulink::ConnToSFStates> connToSFStatess_1426= outPort_141b.srcConnToSFStates();
		for( set< CyberComposition::Simulink::ConnToSFStates>::const_iterator itConnToSFStatess_1427= connToSFStatess_1426.begin(); itConnToSFStatess_1427!= connToSFStatess_1426.end(); ++itConnToSFStatess_1427)
		{
			CyberComposition::Simulink::ConnToSFStates currConnToSFStates_1428= *itConnToSFStatess_1427;
			CyberComposition::ConnToSFStates_Members_Base sFStateDE_1429= currConnToSFStates_1428.srcConnToSFStates_end();
			if( false== Uml::IsDerivedFrom( sFStateDE_1429.type(), CyberComposition::Simulink::SFStateDE::meta))
				continue;
			CyberComposition::Simulink::SFStateDE currSFStateDE_142a= CyberComposition::Simulink::SFStateDE::Cast( sFStateDE_1429);
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_142e;
			if( !isValidBound(boundObjs_142e, outPort_141b, true))
				continue;
			currMatch.outPort_142f= outPort_141b;
			if( !isValidBound(boundObjs_142e, main_1424, true))
				continue;
			currMatch.main_1430= main_1424;
			if( !isValidBound(boundObjs_142e, currConnToSFStates_1428, false))
				continue;
			currMatch.connToSFStates_1431= currConnToSFStates_1428;
			if( !isValidBound(boundObjs_142e, currSFStateDE_142a, false))
				continue;
			currMatch.sFStateDE_1432= currSFStateDE_142a;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void Connected_ConnToSFStates_140b::outputAppender( const CyberComposition::Simulink::OutPort& outPort_1433, const SFC::Function& main_1435)
{
	_outPort_1412->push_back( outPort_1433);
	_main_1413->push_back( main_1435);
}

bool Otherwise_1437::operator()( const Packets_t& outPorts_1438, const Packets_t& mains_143b, Packets_t& outPorts_143a, Packets_t& mains_143d)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_1437" );
#endif
	_outPort_143e= &outPorts_143a;
	_main_143f= &mains_143d;
	processInputPackets( outPorts_1438, mains_143b);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_1437::isInputUnique( const Udm::Object& outPort_1444, const Udm::Object& main_144d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itOutPort_1446= _outPort_1440.begin(), itMain_144f= _main_1449.begin(); itOutPort_1446!= _outPort_1440.end(), itMain_144f!= _main_1449.end(); ++itOutPort_1446, ++itMain_144f)
	{
		if( ( *itOutPort_1446== outPort_1444)&& ( *itMain_144f== main_144d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_outPort_1440.push_back( outPort_1444);
		_main_1449.push_back( main_144d);
	}
	return isUnique;
}

bool Otherwise_1437::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_1437::processInputPackets( const Packets_t& outPorts_1438, const Packets_t& mains_143b)
{
	for( Packets_t::const_iterator itOutPort_1441= outPorts_1438.begin(), itMain_144a= mains_143b.begin(); itOutPort_1441!= outPorts_1438.end(), itMain_144a!= mains_143b.end(); ++itOutPort_1441, ++itMain_144a)
	{
		bool isUnique= isInputUnique( *itOutPort_1441, *itMain_144a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itOutPort_1441, *itMain_144a);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.outPort_1456, currMatch.main_1457);
	}
}

bool Otherwise_1437::patternMatcher( const Udm::Object& outPort_1442, const Udm::Object& main_144b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( outPort_1442.type(), CyberComposition::Simulink::OutPort::meta))
			continue;
		CyberComposition::Simulink::OutPort outPort_1447= CyberComposition::Simulink::OutPort::Cast( outPort_1442);
		if( false== Uml::IsDerivedFrom( main_144b.type(), SFC::Function::meta))
			continue;
		SFC::Function main_1450= SFC::Function::Cast( main_144b);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1455;
		if( !isValidBound(boundObjs_1455, outPort_1447, true))
			continue;
		currMatch.outPort_1456= outPort_1447;
		if( !isValidBound(boundObjs_1455, main_1450, true))
			continue;
		currMatch.main_1457= main_1450;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_1437::outputAppender( const CyberComposition::Simulink::OutPort& outPort_1458, const SFC::Function& main_145a)
{
	_outPort_143e->push_back( outPort_1458);
	_main_143f->push_back( main_145a);
}

void Trigs_1465::operator()( const Packets_t& systems_1466, const Packets_t& functions_1468, Packets_t& systems_146a, Packets_t& functions_146b)
{
#ifdef PRINT_INFO
	printLog( "Trigs_1465" );
#endif
	_system_146c= &systems_146a;
	_function_146d= &functions_146b;
	if( ( !systems_1466.empty())&& ( !functions_1468.empty()))
		callCreateTriggerPortArgs_1498( systems_1466, functions_1468);
	_system_146c->insert( _system_146c->end(), systems_1466.begin(), systems_1466.end());
	_function_146d->insert( _function_146d->end(), functions_1468.begin(), functions_1468.end());
}

void Trigs_1465::callCreateTriggerPortArgs_1498( const Packets_t& subsystems_146f, const Packets_t& mains_1473)
{
	Packets_t triggerPorts_1471;
	Packets_t args_1472;
	CreateTriggerPortArgs_146e createTriggerPortArgs_146e;
	createTriggerPortArgs_146e( subsystems_146f, mains_1473, triggerPorts_1471, args_1472);
	if( ( !triggerPorts_1471.empty())&& ( !args_1472.empty()))
		callAssignType_149b( triggerPorts_1471, args_1472);
}

void Trigs_1465::callAssignType_149b( const Packets_t& ports_133e, const Packets_t& argvars_1340)
{
	AssignType_133d assignType_133d;
	assignType_133d( ports_133e, argvars_1340);
}

void CreateTriggerPortArgs_146e::operator()( const Packets_t& subsystems_146f, const Packets_t& mains_1473, Packets_t& triggerPorts_1471, Packets_t& args_1472)
{
#ifdef PRINT_INFO
	printLog( "CreateTriggerPortArgs_146e" );
#endif
	RTTGenerator::Instance()->generateRule(1091, "CreateTriggerPortArgs");
	_triggerPort_1475= &triggerPorts_1471;
	_arg_1476= &args_1472;
	processInputPackets( subsystems_146f, mains_1473);
}

bool CreateTriggerPortArgs_146e::isInputUnique( const Udm::Object& subsystem_147b, const Udm::Object& main_1484)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_147d= _subsystem_1477.begin(), itMain_1486= _main_1480.begin(); itSubsystem_147d!= _subsystem_1477.end(), itMain_1486!= _main_1480.end(); ++itSubsystem_147d, ++itMain_1486)
	{
		if( ( *itSubsystem_147d== subsystem_147b)&& ( *itMain_1486== main_1484))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1477.push_back( subsystem_147b);
		_main_1480.push_back( main_1484);
	}
	return isUnique;
}

bool CreateTriggerPortArgs_146e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateTriggerPortArgs_146e::processInputPackets( const Packets_t& subsystems_146f, const Packets_t& mains_1473)
{
	for( Packets_t::const_iterator itSubsystem_1478= subsystems_146f.begin(), itMain_1481= mains_1473.begin(); itSubsystem_1478!= subsystems_146f.end(), itMain_1481!= mains_1473.end(); ++itSubsystem_1478, ++itMain_1481)
	{
		bool isUnique= isInputUnique( *itSubsystem_1478, *itMain_1481);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1478, *itMain_1481);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateTriggerPortArgs_146e::patternMatcher( const Udm::Object& subsystem_1479, const Udm::Object& main_1482)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1479.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_147e= CyberComposition::Simulink::Subsystem::Cast( subsystem_1479);
		if( false== Uml::IsDerivedFrom( main_1482.type(), SFC::Function::meta))
			continue;
		SFC::Function main_1487= SFC::Function::Cast( main_1482);
		set< CyberComposition::Simulink::TriggerPort> triggerPorts_1489= subsystem_147e.TriggerPort_kind_children();
		for( set< CyberComposition::Simulink::TriggerPort>::const_iterator itTriggerPort_148a= triggerPorts_1489.begin(); itTriggerPort_148a!= triggerPorts_1489.end(); ++itTriggerPort_148a)
		{
			CyberComposition::Simulink::TriggerPort currTriggerPort_148b= *itTriggerPort_148a;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_148f;
			if( !isValidBound(boundObjs_148f, subsystem_147e, true))
				continue;
			currMatch.subsystem_1490= subsystem_147e;
			if( !isValidBound(boundObjs_148f, main_1487, true))
				continue;
			currMatch.main_1491= main_1487;
			if( !isValidBound(boundObjs_148f, currTriggerPort_148b, false))
				continue;
			currMatch.triggerPort_1492= currTriggerPort_148b;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateTriggerPortArgs_146e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg newArg_1493= SFC::Arg::Create( currMatch.main_1491);
		SFC::Arg& Arg= newArg_1493;
		SFC::Function& Main= currMatch.main_1491;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_1490;
		CyberComposition::Simulink::TriggerPort& TriggerPort= currMatch.triggerPort_1492;
		{
__int64 argCount = Main.argCount();
Arg.argIndex() = argCount++;
Main.argCount() = argCount;

Arg.name() = static_cast< std::string >( TriggerPort.name() ) + "_" + boost::lexical_cast< std::string >( argCount - 1 );
Arg.type() = "double";
};
		newArg_1493.port()+= currMatch.triggerPort_1492;
		outputAppender( currMatch.triggerPort_1492, newArg_1493);
	}
}

void CreateTriggerPortArgs_146e::outputAppender( const CyberComposition::Simulink::TriggerPort& triggerPort_1494, const SFC::Arg& arg_1496)
{
	_triggerPort_1475->push_back( triggerPort_1494);
	_arg_1476->push_back( arg_1496);
}

void Inputs_149e::operator()( const Packets_t& systems_149f, const Packets_t& functions_14a1, Packets_t& systems_14a3, Packets_t& functions_14a4)
{
#ifdef PRINT_INFO
	printLog( "Inputs_149e" );
#endif
	_system_14a5= &systems_14a3;
	_function_14a6= &functions_14a4;
	_system_14a5->insert( _system_14a5->end(), systems_149f.begin(), systems_149f.end());
	_function_14a6->insert( _function_14a6->end(), functions_14a1.begin(), functions_14a1.end());
	if( ( !systems_149f.empty())&& ( !functions_14a1.empty()))
		callCreateInputPortArgs_1508( systems_149f, functions_14a1);
}

void Inputs_149e::callCreateInputPortArgs_1508( const Packets_t& subsystems_14a9, const Packets_t& mains_14ac)
{
	Packets_t inputPorts_14a8;
	Packets_t args_14ab;
	Packets_t mains_14ae;
	CreateInputPortArgs_14a7 createInputPortArgs_14a7;
	createInputPortArgs_14a7( subsystems_14a9, mains_14ac, inputPorts_14a8, args_14ab, mains_14ae);
	if( ( !inputPorts_14a8.empty())&& ( !args_14ab.empty())&& ( !mains_14ae.empty()))
		callUpdateArgCount_150b( inputPorts_14a8, args_14ab, mains_14ae);
}

void Inputs_149e::callUpdateArgCount_150b( const Packets_t& inputPorts_14d6, const Packets_t& args_14d9, const Packets_t& mains_14dc)
{
	Packets_t inputPorts_14d8;
	Packets_t args_14db;
	UpdateArgCount_14d5 updateArgCount_14d5;
	updateArgCount_14d5( inputPorts_14d6, args_14d9, mains_14dc, inputPorts_14d8, args_14db);
	if( ( !inputPorts_14d8.empty())&& ( !args_14db.empty()))
		callAssignType_150f( inputPorts_14d8, args_14db);
}

void Inputs_149e::callAssignType_150f( const Packets_t& ports_133e, const Packets_t& argvars_1340)
{
	AssignType_133d assignType_133d;
	assignType_133d( ports_133e, argvars_1340);
}

void CreateInputPortArgs_14a7::operator()( const Packets_t& subsystems_14a9, const Packets_t& mains_14ac, Packets_t& inputPorts_14a8, Packets_t& args_14ab, Packets_t& mains_14ae)
{
#ifdef PRINT_INFO
	printLog( "CreateInputPortArgs_14a7" );
#endif
	RTTGenerator::Instance()->generateRule(1105, "CreateInputPortArgs");
	_inputPort_14af= &inputPorts_14a8;
	_arg_14b0= &args_14ab;
	_main_14b1= &mains_14ae;
	processInputPackets( subsystems_14a9, mains_14ac);
}

bool CreateInputPortArgs_14a7::isInputUnique( const Udm::Object& subsystem_14b6, const Udm::Object& main_14bf)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_14b8= _subsystem_14b2.begin(), itMain_14c1= _main_14bb.begin(); itSubsystem_14b8!= _subsystem_14b2.end(), itMain_14c1!= _main_14bb.end(); ++itSubsystem_14b8, ++itMain_14c1)
	{
		if( ( *itSubsystem_14b8== subsystem_14b6)&& ( *itMain_14c1== main_14bf))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_14b2.push_back( subsystem_14b6);
		_main_14bb.push_back( main_14bf);
	}
	return isUnique;
}

bool CreateInputPortArgs_14a7::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateInputPortArgs_14a7::processInputPackets( const Packets_t& subsystems_14a9, const Packets_t& mains_14ac)
{
	for( Packets_t::const_iterator itSubsystem_14b3= subsystems_14a9.begin(), itMain_14bc= mains_14ac.begin(); itSubsystem_14b3!= subsystems_14a9.end(), itMain_14bc!= mains_14ac.end(); ++itSubsystem_14b3, ++itMain_14bc)
	{
		bool isUnique= isInputUnique( *itSubsystem_14b3, *itMain_14bc);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_14b3, *itMain_14bc);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateInputPortArgs_14a7::patternMatcher( const Udm::Object& subsystem_14b4, const Udm::Object& main_14bd)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_14b4.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_14b9= CyberComposition::Simulink::Subsystem::Cast( subsystem_14b4);
		if( false== Uml::IsDerivedFrom( main_14bd.type(), SFC::Function::meta))
			continue;
		SFC::Function main_14c2= SFC::Function::Cast( main_14bd);
		set< CyberComposition::Simulink::InputPort> inputPorts_14c4= subsystem_14b9.InputPort_kind_children();
		for( set< CyberComposition::Simulink::InputPort>::const_iterator itInputPort_14c5= inputPorts_14c4.begin(); itInputPort_14c5!= inputPorts_14c4.end(); ++itInputPort_14c5)
		{
			CyberComposition::Simulink::InputPort currInputPort_14c6= *itInputPort_14c5;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_14ca;
			if( !isValidBound(boundObjs_14ca, subsystem_14b9, true))
				continue;
			currMatch.subsystem_14cb= subsystem_14b9;
			if( !isValidBound(boundObjs_14ca, main_14c2, true))
				continue;
			currMatch.main_14cc= main_14c2;
			if( !isValidBound(boundObjs_14ca, currInputPort_14c6, false))
				continue;
			currMatch.inputPort_14cd= currInputPort_14c6;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateInputPortArgs_14a7::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg newArg_14ce= SFC::Arg::Create( currMatch.main_14cc);
		SFC::Arg& Arg= newArg_14ce;
		CyberComposition::Simulink::InputPort& InputPort= currMatch.inputPort_14cd;
		SFC::Function& Main= currMatch.main_14cc;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_14cb;
		{
__int64 argIndex = static_cast< __int64 >( Main.argCount() ) + static_cast< __int64 >( InputPort.Number() );
Arg.argIndex() = argIndex;

Arg.name() = static_cast< std::string >( InputPort.name() ) + "_" + boost::lexical_cast< std::string >( argIndex );
Arg.type() = "double";
};
		newArg_14ce.port()+= currMatch.inputPort_14cd;
		outputAppender( currMatch.inputPort_14cd, newArg_14ce, currMatch.main_14cc);
	}
}

void CreateInputPortArgs_14a7::outputAppender( const CyberComposition::Simulink::InputPort& inputPort_14cf, const SFC::Arg& arg_14d1, const SFC::Function& main_14d3)
{
	_inputPort_14af->push_back( inputPort_14cf);
	_arg_14b0->push_back( arg_14d1);
	_main_14b1->push_back( main_14d3);
}

void UpdateArgCount_14d5::operator()( const Packets_t& inputPorts_14d6, const Packets_t& args_14d9, const Packets_t& mains_14dc, Packets_t& inputPorts_14d8, Packets_t& args_14db)
{
#ifdef PRINT_INFO
	printLog( "UpdateArgCount_14d5" );
#endif
	RTTGenerator::Instance()->generateRule(1114, "UpdateArgCount");
	_inputPort_14de= &inputPorts_14d8;
	_arg_14df= &args_14db;
	processInputPackets( inputPorts_14d6, args_14d9, mains_14dc);
	forwardInputs( );
}

bool UpdateArgCount_14d5::isInputUnique( const Udm::Object& inputPort_14e4, const Udm::Object& arg_14ed, const Udm::Object& main_14f6)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itInputPort_14e6= _inputPort_14e0.begin(), itArg_14ef= _arg_14e9.begin(), itMain_14f8= _main_14f2.begin(); itInputPort_14e6!= _inputPort_14e0.end(), itArg_14ef!= _arg_14e9.end(), itMain_14f8!= _main_14f2.end(); ++itInputPort_14e6, ++itArg_14ef, ++itMain_14f8)
	{
		if( ( *itInputPort_14e6== inputPort_14e4)&& ( *itArg_14ef== arg_14ed)&& ( *itMain_14f8== main_14f6))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_inputPort_14e0.push_back( inputPort_14e4);
		_arg_14e9.push_back( arg_14ed);
		_main_14f2.push_back( main_14f6);
	}
	return isUnique;
}

bool UpdateArgCount_14d5::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void UpdateArgCount_14d5::processInputPackets( const Packets_t& inputPorts_14d6, const Packets_t& args_14d9, const Packets_t& mains_14dc)
{
	for( Packets_t::const_iterator itInputPort_14e1= inputPorts_14d6.begin(), itArg_14ea= args_14d9.begin(), itMain_14f3= mains_14dc.begin(); itInputPort_14e1!= inputPorts_14d6.end(), itArg_14ea!= args_14d9.end(), itMain_14f3!= mains_14dc.end(); ++itInputPort_14e1, ++itArg_14ea, ++itMain_14f3)
	{
		bool isUnique= isInputUnique( *itInputPort_14e1, *itArg_14ea, *itMain_14f3);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itInputPort_14e1, *itArg_14ea, *itMain_14f3);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool UpdateArgCount_14d5::patternMatcher( const Udm::Object& inputPort_14e2, const Udm::Object& arg_14eb, const Udm::Object& main_14f4)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( inputPort_14e2.type(), CyberComposition::Simulink::InputPort::meta))
			continue;
		CyberComposition::Simulink::InputPort inputPort_14e7= CyberComposition::Simulink::InputPort::Cast( inputPort_14e2);
		if( false== Uml::IsDerivedFrom( arg_14eb.type(), SFC::Arg::meta))
			continue;
		SFC::Arg arg_14f0= SFC::Arg::Cast( arg_14eb);
		if( false== Uml::IsDerivedFrom( main_14f4.type(), SFC::Function::meta))
			continue;
		SFC::Function main_14f9= SFC::Function::Cast( main_14f4);
		set< SFC::Arg> args_14fb= main_14f9.Arg_kind_children();
		for( set< SFC::Arg>::const_iterator itArg_14fc= args_14fb.begin(); itArg_14fc!= args_14fb.end(); ++itArg_14fc)
		{
			SFC::Arg currArg_14fd= *itArg_14fc;
			if( arg_14f0!= currArg_14fd)
				continue;
			set< CyberComposition::Simulink::SF_Port> inputPorts_14fe= arg_14f0.port();
			for( set< CyberComposition::Simulink::SF_Port>::const_iterator itInputPorts_14ff= inputPorts_14fe.begin(); itInputPorts_14ff!= inputPorts_14fe.end(); ++itInputPorts_14ff)
			{
				if( false== Uml::IsDerivedFrom( (*itInputPorts_14ff).type(), CyberComposition::Simulink::InputPort::meta))
					continue;
				CyberComposition::Simulink::InputPort currInputPort_1500= CyberComposition::Simulink::InputPort::Cast( *itInputPorts_14ff);
				if( inputPort_14e7!= currInputPort_1500)
					continue;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_1504;
				if( !isValidBound(boundObjs_1504, inputPort_14e7, true))
					continue;
				currMatch.inputPort_1505= inputPort_14e7;
				if( !isValidBound(boundObjs_1504, arg_14f0, true))
					continue;
				currMatch.arg_1506= arg_14f0;
				if( !isValidBound(boundObjs_1504, main_14f9, true))
					continue;
				currMatch.main_1507= main_14f9;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void UpdateArgCount_14d5::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg& Arg= currMatch.arg_1506;
		CyberComposition::Simulink::InputPort& InputPort= currMatch.inputPort_1505;
		SFC::Function& Main= currMatch.main_1507;
		{
Main.argCount() = static_cast< __int64 >( Main.argCount() ) + 1;
};
	}
}

void UpdateArgCount_14d5::forwardInputs()
{
	*_inputPort_14de= _inputPort_14e0;
	*_arg_14df= _arg_14e9;
}

void Outputs_1512::operator()( const Packets_t& systems_1513, const Packets_t& functions_1515, Packets_t& systems_1517, Packets_t& functions_1518)
{
#ifdef PRINT_INFO
	printLog( "Outputs_1512" );
#endif
	_system_1519= &systems_1517;
	_function_151a= &functions_1518;
	_system_1519->insert( _system_1519->end(), systems_1513.begin(), systems_1513.end());
	_function_151a->insert( _function_151a->end(), functions_1515.begin(), functions_1515.end());
	if( ( !systems_1513.empty())&& ( !functions_1515.empty()))
		callCreateOutputPortArgs_157c( systems_1513, functions_1515);
}

void Outputs_1512::callCreateOutputPortArgs_157c( const Packets_t& subsystems_151d, const Packets_t& mains_1520)
{
	Packets_t outputPorts_151c;
	Packets_t args_151f;
	Packets_t mains_1522;
	CreateOutputPortArgs_151b createOutputPortArgs_151b;
	createOutputPortArgs_151b( subsystems_151d, mains_1520, outputPorts_151c, args_151f, mains_1522);
	if( ( !outputPorts_151c.empty())&& ( !args_151f.empty())&& ( !mains_1522.empty()))
		callMainArgCount_157f( outputPorts_151c, args_151f, mains_1522);
}

void Outputs_1512::callMainArgCount_157f( const Packets_t& outputPorts_154a, const Packets_t& args_154d, const Packets_t& mains_1550)
{
	Packets_t outputPorts_154c;
	Packets_t args_154f;
	MainArgCount_1549 mainArgCount_1549;
	mainArgCount_1549( outputPorts_154a, args_154d, mains_1550, outputPorts_154c, args_154f);
	if( ( !outputPorts_154c.empty())&& ( !args_154f.empty()))
		callAssignType_1583( outputPorts_154c, args_154f);
}

void Outputs_1512::callAssignType_1583( const Packets_t& ports_133e, const Packets_t& argvars_1340)
{
	AssignType_133d assignType_133d;
	assignType_133d( ports_133e, argvars_1340);
}

void CreateOutputPortArgs_151b::operator()( const Packets_t& subsystems_151d, const Packets_t& mains_1520, Packets_t& outputPorts_151c, Packets_t& args_151f, Packets_t& mains_1522)
{
#ifdef PRINT_INFO
	printLog( "CreateOutputPortArgs_151b" );
#endif
	RTTGenerator::Instance()->generateRule(1126, "CreateOutputPortArgs");
	_outputPort_1523= &outputPorts_151c;
	_arg_1524= &args_151f;
	_main_1525= &mains_1522;
	processInputPackets( subsystems_151d, mains_1520);
}

bool CreateOutputPortArgs_151b::isInputUnique( const Udm::Object& subsystem_152a, const Udm::Object& main_1533)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_152c= _subsystem_1526.begin(), itMain_1535= _main_152f.begin(); itSubsystem_152c!= _subsystem_1526.end(), itMain_1535!= _main_152f.end(); ++itSubsystem_152c, ++itMain_1535)
	{
		if( ( *itSubsystem_152c== subsystem_152a)&& ( *itMain_1535== main_1533))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1526.push_back( subsystem_152a);
		_main_152f.push_back( main_1533);
	}
	return isUnique;
}

bool CreateOutputPortArgs_151b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateOutputPortArgs_151b::processInputPackets( const Packets_t& subsystems_151d, const Packets_t& mains_1520)
{
	for( Packets_t::const_iterator itSubsystem_1527= subsystems_151d.begin(), itMain_1530= mains_1520.begin(); itSubsystem_1527!= subsystems_151d.end(), itMain_1530!= mains_1520.end(); ++itSubsystem_1527, ++itMain_1530)
	{
		bool isUnique= isInputUnique( *itSubsystem_1527, *itMain_1530);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1527, *itMain_1530);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateOutputPortArgs_151b::patternMatcher( const Udm::Object& subsystem_1528, const Udm::Object& main_1531)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1528.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_152d= CyberComposition::Simulink::Subsystem::Cast( subsystem_1528);
		if( false== Uml::IsDerivedFrom( main_1531.type(), SFC::Function::meta))
			continue;
		SFC::Function main_1536= SFC::Function::Cast( main_1531);
		set< CyberComposition::Simulink::OutputPort> outputPorts_1538= subsystem_152d.OutputPort_kind_children();
		for( set< CyberComposition::Simulink::OutputPort>::const_iterator itOutputPort_1539= outputPorts_1538.begin(); itOutputPort_1539!= outputPorts_1538.end(); ++itOutputPort_1539)
		{
			CyberComposition::Simulink::OutputPort currOutputPort_153a= *itOutputPort_1539;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_153e;
			if( !isValidBound(boundObjs_153e, subsystem_152d, true))
				continue;
			currMatch.subsystem_153f= subsystem_152d;
			if( !isValidBound(boundObjs_153e, main_1536, true))
				continue;
			currMatch.main_1540= main_1536;
			if( !isValidBound(boundObjs_153e, currOutputPort_153a, false))
				continue;
			currMatch.outputPort_1541= currOutputPort_153a;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateOutputPortArgs_151b::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg newArg_1542= SFC::Arg::Create( currMatch.main_1540);
		SFC::Arg& Arg= newArg_1542;
		SFC::Function& Main= currMatch.main_1540;
		CyberComposition::Simulink::OutputPort& OutputPort= currMatch.outputPort_1541;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_153f;
		{
__int64 argIndex = static_cast< __int64 >( Main.argCount() ) + static_cast< __int64 >( OutputPort.Number() );
Arg.argIndex() = argIndex;

Arg.name() = static_cast< std::string >( OutputPort.name() ) + "_" + boost::lexical_cast< std::string >( argIndex );
Arg.type() = "double";
Arg.ptr() = true;
};
		newArg_1542.port()+= currMatch.outputPort_1541;
		outputAppender( currMatch.outputPort_1541, newArg_1542, currMatch.main_1540);
	}
}

void CreateOutputPortArgs_151b::outputAppender( const CyberComposition::Simulink::OutputPort& outputPort_1543, const SFC::Arg& arg_1545, const SFC::Function& main_1547)
{
	_outputPort_1523->push_back( outputPort_1543);
	_arg_1524->push_back( arg_1545);
	_main_1525->push_back( main_1547);
}

void MainArgCount_1549::operator()( const Packets_t& outputPorts_154a, const Packets_t& args_154d, const Packets_t& mains_1550, Packets_t& outputPorts_154c, Packets_t& args_154f)
{
#ifdef PRINT_INFO
	printLog( "MainArgCount_1549" );
#endif
	RTTGenerator::Instance()->generateRule(1135, "MainArgCount");
	_outputPort_1552= &outputPorts_154c;
	_arg_1553= &args_154f;
	processInputPackets( outputPorts_154a, args_154d, mains_1550);
	forwardInputs( );
}

bool MainArgCount_1549::isInputUnique( const Udm::Object& outputPort_1558, const Udm::Object& arg_1561, const Udm::Object& main_156a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itOutputPort_155a= _outputPort_1554.begin(), itArg_1563= _arg_155d.begin(), itMain_156c= _main_1566.begin(); itOutputPort_155a!= _outputPort_1554.end(), itArg_1563!= _arg_155d.end(), itMain_156c!= _main_1566.end(); ++itOutputPort_155a, ++itArg_1563, ++itMain_156c)
	{
		if( ( *itOutputPort_155a== outputPort_1558)&& ( *itArg_1563== arg_1561)&& ( *itMain_156c== main_156a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_outputPort_1554.push_back( outputPort_1558);
		_arg_155d.push_back( arg_1561);
		_main_1566.push_back( main_156a);
	}
	return isUnique;
}

bool MainArgCount_1549::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void MainArgCount_1549::processInputPackets( const Packets_t& outputPorts_154a, const Packets_t& args_154d, const Packets_t& mains_1550)
{
	for( Packets_t::const_iterator itOutputPort_1555= outputPorts_154a.begin(), itArg_155e= args_154d.begin(), itMain_1567= mains_1550.begin(); itOutputPort_1555!= outputPorts_154a.end(), itArg_155e!= args_154d.end(), itMain_1567!= mains_1550.end(); ++itOutputPort_1555, ++itArg_155e, ++itMain_1567)
	{
		bool isUnique= isInputUnique( *itOutputPort_1555, *itArg_155e, *itMain_1567);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itOutputPort_1555, *itArg_155e, *itMain_1567);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool MainArgCount_1549::patternMatcher( const Udm::Object& outputPort_1556, const Udm::Object& arg_155f, const Udm::Object& main_1568)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( outputPort_1556.type(), CyberComposition::Simulink::OutputPort::meta))
			continue;
		CyberComposition::Simulink::OutputPort outputPort_155b= CyberComposition::Simulink::OutputPort::Cast( outputPort_1556);
		if( false== Uml::IsDerivedFrom( arg_155f.type(), SFC::Arg::meta))
			continue;
		SFC::Arg arg_1564= SFC::Arg::Cast( arg_155f);
		if( false== Uml::IsDerivedFrom( main_1568.type(), SFC::Function::meta))
			continue;
		SFC::Function main_156d= SFC::Function::Cast( main_1568);
		set< SFC::Arg> args_156f= main_156d.Arg_kind_children();
		for( set< SFC::Arg>::const_iterator itArg_1570= args_156f.begin(); itArg_1570!= args_156f.end(); ++itArg_1570)
		{
			SFC::Arg currArg_1571= *itArg_1570;
			if( arg_1564!= currArg_1571)
				continue;
			set< CyberComposition::Simulink::SF_Port> outputPorts_1572= arg_1564.port();
			for( set< CyberComposition::Simulink::SF_Port>::const_iterator itOutputPorts_1573= outputPorts_1572.begin(); itOutputPorts_1573!= outputPorts_1572.end(); ++itOutputPorts_1573)
			{
				if( false== Uml::IsDerivedFrom( (*itOutputPorts_1573).type(), CyberComposition::Simulink::OutputPort::meta))
					continue;
				CyberComposition::Simulink::OutputPort currOutputPort_1574= CyberComposition::Simulink::OutputPort::Cast( *itOutputPorts_1573);
				if( outputPort_155b!= currOutputPort_1574)
					continue;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_1578;
				if( !isValidBound(boundObjs_1578, outputPort_155b, true))
					continue;
				currMatch.outputPort_1579= outputPort_155b;
				if( !isValidBound(boundObjs_1578, arg_1564, true))
					continue;
				currMatch.arg_157a= arg_1564;
				if( !isValidBound(boundObjs_1578, main_156d, true))
					continue;
				currMatch.main_157b= main_156d;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void MainArgCount_1549::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg& Arg= currMatch.arg_157a;
		SFC::Function& Main= currMatch.main_157b;
		CyberComposition::Simulink::OutputPort& OutputPort= currMatch.outputPort_1579;
		{
Main.argCount() = static_cast< __int64 >( Main.argCount() ) + 1;
};
	}
}

void MainArgCount_1549::forwardInputs()
{
	*_outputPort_1552= _outputPort_1554;
	*_arg_1553= _arg_155d;
}

void CreateFunctions_1595::operator()( const Packets_t& subsystems_1596, Packets_t& subsystems_1598, Packets_t& mains_1599)
{
#ifdef PRINT_INFO
	printLog( "CreateFunctions_1595" );
#endif
	RTTGenerator::Instance()->generateRule(1142, "CreateFunctions");
	_subsystem_159a= &subsystems_1598;
	_main_159b= &mains_1599;
	processInputPackets( subsystems_1596);
}

bool CreateFunctions_1595::isInputUnique( const Udm::Object& subsystem_15a0)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_15a2= _subsystem_159c.begin(); itSubsystem_15a2!= _subsystem_159c.end(); ++itSubsystem_15a2)
	{
		if( ( *itSubsystem_15a2== subsystem_15a0))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_subsystem_159c.push_back( subsystem_15a0);
	return isUnique;
}

bool CreateFunctions_1595::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateFunctions_1595::processInputPackets( const Packets_t& subsystems_1596)
{
	for( Packets_t::const_iterator itSubsystem_159d= subsystems_1596.begin(); itSubsystem_159d!= subsystems_1596.end(); ++itSubsystem_159d)
	{
		bool isUnique= isInputUnique( *itSubsystem_159d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_159d);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateFunctions_1595::patternMatcher( const Udm::Object& subsystem_159e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_159e.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_15a3= CyberComposition::Simulink::Subsystem::Cast( subsystem_159e);
		SFC::Class class_15a5= subsystem_15a3.cls();
		if( !class_15a5)
			continue;
		set< SFC::Struct> structs_15a6= class_15a5.Struct_kind_children();
		for( set< SFC::Struct>::const_iterator itStruct_15a7= structs_15a6.begin(); itStruct_15a7!= structs_15a6.end(); ++itStruct_15a7)
		{
			SFC::Struct currStruct_15a8= *itStruct_15a7;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_15ac;
			if( !isValidBound(boundObjs_15ac, subsystem_15a3, true))
				continue;
			currMatch.subsystem_15ad= subsystem_15a3;
			if( !isValidBound(boundObjs_15ac, class_15a5, false))
				continue;
			currMatch.class_15ae= class_15a5;
			if( !isValidBound(boundObjs_15ac, currStruct_15a8, false))
				continue;
			currMatch.struct_15af= currStruct_15a8;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateFunctions_1595::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function newMain_15b0= SFC::Function::Create( currMatch.class_15ae, SFC::Class::meta_stmnt);
		SFC::Arg newArg_15b1= SFC::Arg::Create( newMain_15b0);
		SFC::Arg& Arg= newArg_15b1;
		SFC::Class& Class= currMatch.class_15ae;
		SFC::Function& Main= newMain_15b0;
		SFC::Struct& Struct= currMatch.struct_15af;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_15ad;
		{
Main.name() = static_cast< std::string >( Subsystem.name() ) + "_" + boost::lexical_cast< std::string >( Subsystem.uniqueId() ) + "_main";
};
		{
__int64 statementCount = Class.statementCount();
Main.statementIndex() = statementCount++;
Class.statementCount() = statementCount;
};
		{
__int64 argCount = Main.argCount();
Arg.argIndex() = argCount++;
Main.argCount() = argCount;

Arg.name() = "context";
Arg.ptr() = true;
};
		newMain_15b0.sysmain()+= currMatch.subsystem_15ad;
		newArg_15b1.dt()= currMatch.struct_15af;
		outputAppender( currMatch.subsystem_15ad, newMain_15b0);
	}
}

void CreateFunctions_1595::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_15b2, const SFC::Function& main_15b4)
{
	_subsystem_159a->push_back( subsystem_15b2);
	_main_159b->push_back( main_15b4);
}

void MakeSFChartArguments_15b6::operator()( const Packets_t& states_15b7, const Packets_t& functions_15b9)
{
#ifdef PRINT_INFO
	printLog( "MakeSFChartArguments_15b6" );
#endif
	if( ( !states_15b7.empty())&& ( !functions_15b9.empty()))
		callDataInput_16f4( states_15b7, functions_15b9);
}

void MakeSFChartArguments_15b6::callDataInput_16f4( const Packets_t& states_15bc, const Packets_t& functions_15be)
{
	Packets_t states_15c0;
	Packets_t functions_15c1;
	DataInput_15bb dataInput_15bb;
	dataInput_15bb( states_15bc, functions_15be, states_15c0, functions_15c1);
	if( ( !states_15c0.empty())&& ( !functions_15c1.empty()))
		callEventInput_16f7( states_15c0, functions_15c1);
}

void MakeSFChartArguments_15b6::callEventInput_16f7( const Packets_t& states_1623, const Packets_t& functions_1625)
{
	Packets_t states_1627;
	Packets_t functions_1628;
	EventInput_1622 eventInput_1622;
	eventInput_1622( states_1623, functions_1625, states_1627, functions_1628);
	if( ( !states_1627.empty())&& ( !functions_1628.empty()))
		callDataOutput_16fa( states_1627, functions_1628);
}

void MakeSFChartArguments_15b6::callDataOutput_16fa( const Packets_t& states_166a, const Packets_t& functions_166c)
{
	Packets_t states_166e;
	Packets_t functions_166f;
	DataOutput_1669 dataOutput_1669;
	dataOutput_1669( states_166a, functions_166c, states_166e, functions_166f);
	if( ( !states_166e.empty())&& ( !functions_166f.empty()))
		callEventOutput_16fd( states_166e, functions_166f);
}

void MakeSFChartArguments_15b6::callEventOutput_16fd( const Packets_t& states_16b1, const Packets_t& functions_16b3)
{
	EventOutput_16b0 eventOutput_16b0;
	eventOutput_16b0( states_16b1, functions_16b3);
}

void DataInput_15bb::operator()( const Packets_t& states_15bc, const Packets_t& functions_15be, Packets_t& states_15c0, Packets_t& functions_15c1)
{
#ifdef PRINT_INFO
	printLog( "DataInput_15bb" );
#endif
	_state_15c2= &states_15c0;
	_function_15c3= &functions_15c1;
	if( ( !states_15bc.empty())&& ( !functions_15be.empty()))
		callDataInput_161c( states_15bc, functions_15be);
	_state_15c2->insert( _state_15c2->end(), states_15bc.begin(), states_15bc.end());
	_function_15c3->insert( _function_15c3->end(), functions_15be.begin(), functions_15be.end());
}

void DataInput_15bb::callDataInput_161c( const Packets_t& states_15e5, const Packets_t& mains_15e8)
{
	Packets_t args_15e7;
	Packets_t mains_15ea;
	DataInput_15e4 dataInput_15e4;
	dataInput_15e4( states_15e5, mains_15e8, args_15e7, mains_15ea);
	if( ( !args_15e7.empty())&& ( !mains_15ea.empty()))
		callUpdateArgCount_161f( args_15e7, mains_15ea);
}

void DataInput_15bb::callUpdateArgCount_161f( const Packets_t& args_15c5, const Packets_t& mains_15c7)
{
	UpdateArgCount_15c4 updateArgCount_15c4;
	updateArgCount_15c4( args_15c5, mains_15c7);
}

void UpdateArgCount_15c4::operator()( const Packets_t& args_15c5, const Packets_t& mains_15c7)
{
#ifdef PRINT_INFO
	printLog( "UpdateArgCount_15c4" );
#endif
	RTTGenerator::Instance()->generateRule(1165, "UpdateArgCount");
	processInputPackets( args_15c5, mains_15c7);
}

bool UpdateArgCount_15c4::isInputUnique( const Udm::Object& arg_15cd, const Udm::Object& main_15d6)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArg_15cf= _arg_15c9.begin(), itMain_15d8= _main_15d2.begin(); itArg_15cf!= _arg_15c9.end(), itMain_15d8!= _main_15d2.end(); ++itArg_15cf, ++itMain_15d8)
	{
		if( ( *itArg_15cf== arg_15cd)&& ( *itMain_15d8== main_15d6))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_arg_15c9.push_back( arg_15cd);
		_main_15d2.push_back( main_15d6);
	}
	return isUnique;
}

bool UpdateArgCount_15c4::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void UpdateArgCount_15c4::processInputPackets( const Packets_t& args_15c5, const Packets_t& mains_15c7)
{
	for( Packets_t::const_iterator itArg_15ca= args_15c5.begin(), itMain_15d3= mains_15c7.begin(); itArg_15ca!= args_15c5.end(), itMain_15d3!= mains_15c7.end(); ++itArg_15ca, ++itMain_15d3)
	{
		bool isUnique= isInputUnique( *itArg_15ca, *itMain_15d3);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArg_15ca, *itMain_15d3);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool UpdateArgCount_15c4::patternMatcher( const Udm::Object& arg_15cb, const Udm::Object& main_15d4)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( arg_15cb.type(), SFC::Arg::meta))
			continue;
		SFC::Arg arg_15d0= SFC::Arg::Cast( arg_15cb);
		if( false== Uml::IsDerivedFrom( main_15d4.type(), SFC::Function::meta))
			continue;
		SFC::Function main_15d9= SFC::Function::Cast( main_15d4);
		set< SFC::Arg> args_15db= main_15d9.Arg_kind_children();
		for( set< SFC::Arg>::const_iterator itArg_15dc= args_15db.begin(); itArg_15dc!= args_15db.end(); ++itArg_15dc)
		{
			SFC::Arg currArg_15dd= *itArg_15dc;
			if( arg_15d0!= currArg_15dd)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_15e1;
			if( !isValidBound(boundObjs_15e1, arg_15d0, true))
				continue;
			currMatch.arg_15e2= arg_15d0;
			if( !isValidBound(boundObjs_15e1, main_15d9, true))
				continue;
			currMatch.main_15e3= main_15d9;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void UpdateArgCount_15c4::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg& Arg= currMatch.arg_15e2;
		SFC::Function& Main= currMatch.main_15e3;
		{
Main.argCount() = static_cast< __int64 >( Main.argCount() ) + 1;
};
	}
}

void DataInput_15e4::operator()( const Packets_t& states_15e5, const Packets_t& mains_15e8, Packets_t& args_15e7, Packets_t& mains_15ea)
{
#ifdef PRINT_INFO
	printLog( "DataInput_15e4" );
#endif
	RTTGenerator::Instance()->generateRule(1170, "DataInput");
	_arg_15eb= &args_15e7;
	_main_15ec= &mains_15ea;
	processInputPackets( states_15e5, mains_15e8);
}

bool DataInput_15e4::isInputUnique( const Udm::Object& state_15f1, const Udm::Object& main_15fa)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_15f3= _state_15ed.begin(), itMain_15fc= _main_15f6.begin(); itState_15f3!= _state_15ed.end(), itMain_15fc!= _main_15f6.end(); ++itState_15f3, ++itMain_15fc)
	{
		if( ( *itState_15f3== state_15f1)&& ( *itMain_15fc== main_15fa))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_15ed.push_back( state_15f1);
		_main_15f6.push_back( main_15fa);
	}
	return isUnique;
}

bool DataInput_15e4::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool DataInput_15e4::isGuardTrue( SFC::DT& DT, CyberComposition::Simulink::SFData& Data, SFC::Function& Main, CyberComposition::Simulink::SFState& State, CyberComposition::Simulink::SF_TypeBase& TypeBase, CyberComposition::Simulink::TypeBaseRef& TypeBaseRef)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( Data.Scope() ) == "INPUT_DATA";;
	return Gz_guard;
}

void DataInput_15e4::processInputPackets( const Packets_t& states_15e5, const Packets_t& mains_15e8)
{
	for( Packets_t::const_iterator itState_15ee= states_15e5.begin(), itMain_15f7= mains_15e8.begin(); itState_15ee!= states_15e5.end(), itMain_15f7!= mains_15e8.end(); ++itState_15ee, ++itMain_15f7)
	{
		bool isUnique= isInputUnique( *itState_15ee, *itMain_15f7);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_15ee, *itMain_15f7);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool DataInput_15e4::patternMatcher( const Udm::Object& state_15ef, const Udm::Object& main_15f8)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_15ef.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState state_15f4= CyberComposition::Simulink::SFState::Cast( state_15ef);
		if( false== Uml::IsDerivedFrom( main_15f8.type(), SFC::Function::meta))
			continue;
		SFC::Function main_15fd= SFC::Function::Cast( main_15f8);
		set< CyberComposition::Simulink::SFData> datas_15ff= state_15f4.SFData_kind_children();
		for( set< CyberComposition::Simulink::SFData>::const_iterator itData_1600= datas_15ff.begin(); itData_1600!= datas_15ff.end(); ++itData_1600)
		{
			CyberComposition::Simulink::SFData currData_1601= *itData_1600;
			set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_1602= currData_1601.TypeBaseRef_kind_children();
			for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_1603= typeBaseRefs_1602.begin(); itTypeBaseRef_1603!= typeBaseRefs_1602.end(); ++itTypeBaseRef_1603)
			{
				CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_1604= *itTypeBaseRef_1603;
				CyberComposition::Simulink::SF_TypeBase typeBase_1605= currTypeBaseRef_1604.ref();
				if( !typeBase_1605)
					continue;
				SFC::DT dT_1606= typeBase_1605.dt();
				if( !dT_1606)
					continue;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_160a;
				if( !isValidBound(boundObjs_160a, state_15f4, true))
					continue;
				currMatch.state_160b= state_15f4;
				if( !isValidBound(boundObjs_160a, main_15fd, true))
					continue;
				currMatch.main_160c= main_15fd;
				if( !isValidBound(boundObjs_160a, typeBase_1605, false))
					continue;
				currMatch.typeBase_160d= typeBase_1605;
				if( !isValidBound(boundObjs_160a, dT_1606, false))
					continue;
				currMatch.dT_160e= dT_1606;
				if( !isValidBound(boundObjs_160a, currData_1601, false))
					continue;
				currMatch.data_160f= currData_1601;
				if( !isValidBound(boundObjs_160a, currTypeBaseRef_1604, false))
					continue;
				currMatch.typeBaseRef_1610= currTypeBaseRef_1604;
				bool Gz_guard= isGuardTrue( currMatch.dT_160e, currMatch.data_160f, currMatch.main_160c, currMatch.state_160b, currMatch.typeBase_160d, currMatch.typeBaseRef_1610);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void DataInput_15e4::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg newArg_1617= SFC::Arg::Create( currMatch.main_160c);
		SFC::Arg& Arg= newArg_1617;
		SFC::DT& DT= currMatch.dT_160e;
		CyberComposition::Simulink::SFData& Data= currMatch.data_160f;
		SFC::Function& Main= currMatch.main_160c;
		CyberComposition::Simulink::SFState& State= currMatch.state_160b;
		CyberComposition::Simulink::SF_TypeBase& TypeBase= currMatch.typeBase_160d;
		CyberComposition::Simulink::TypeBaseRef& TypeBaseRef= currMatch.typeBaseRef_1610;
		{
__int64 argIndex = static_cast< __int64 >( Main.argCount() ) + static_cast< __int64 >( Data.Port() ) - 1;
Arg.argIndex() = argIndex;
Arg.name() = static_cast< std::string >( Data.Name() ) + "_" + boost::lexical_cast< std::string >( argIndex );
};
		newArg_1617.dt()= currMatch.dT_160e;
		outputAppender( newArg_1617, currMatch.main_160c);
	}
}

void DataInput_15e4::outputAppender( const SFC::Arg& arg_1618, const SFC::Function& main_161a)
{
	_arg_15eb->push_back( arg_1618);
	_main_15ec->push_back( main_161a);
}

void EventInput_1622::operator()( const Packets_t& states_1623, const Packets_t& functions_1625, Packets_t& states_1627, Packets_t& functions_1628)
{
#ifdef PRINT_INFO
	printLog( "EventInput_1622" );
#endif
	_state_1629= &states_1627;
	_function_162a= &functions_1628;
	if( ( !states_1623.empty())&& ( !functions_1625.empty()))
		callEventInput_1663( states_1623, functions_1625);
	_state_1629->insert( _state_1629->end(), states_1623.begin(), states_1623.end());
	_function_162a->insert( _function_162a->end(), functions_1625.begin(), functions_1625.end());
}

void EventInput_1622::callEventInput_1663( const Packets_t& states_162c, const Packets_t& mains_162f)
{
	Packets_t args_162e;
	Packets_t mains_1631;
	EventInput_162b eventInput_162b;
	eventInput_162b( states_162c, mains_162f, args_162e, mains_1631);
	if( ( !args_162e.empty())&& ( !mains_1631.empty()))
		callUpdateArgCount_1666( args_162e, mains_1631);
}

void EventInput_1622::callUpdateArgCount_1666( const Packets_t& args_15c5, const Packets_t& mains_15c7)
{
	UpdateArgCount_15c4 updateArgCount_15c4;
	updateArgCount_15c4( args_15c5, mains_15c7);
}

void EventInput_162b::operator()( const Packets_t& states_162c, const Packets_t& mains_162f, Packets_t& args_162e, Packets_t& mains_1631)
{
#ifdef PRINT_INFO
	printLog( "EventInput_162b" );
#endif
	RTTGenerator::Instance()->generateRule(1190, "EventInput");
	_arg_1632= &args_162e;
	_main_1633= &mains_1631;
	processInputPackets( states_162c, mains_162f);
}

bool EventInput_162b::isInputUnique( const Udm::Object& state_1638, const Udm::Object& main_1641)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_163a= _state_1634.begin(), itMain_1643= _main_163d.begin(); itState_163a!= _state_1634.end(), itMain_1643!= _main_163d.end(); ++itState_163a, ++itMain_1643)
	{
		if( ( *itState_163a== state_1638)&& ( *itMain_1643== main_1641))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_1634.push_back( state_1638);
		_main_163d.push_back( main_1641);
	}
	return isUnique;
}

bool EventInput_162b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool EventInput_162b::isGuardTrue( SFC::DT& DT, CyberComposition::Simulink::SFEvent& Event, SFC::Function& Main, CyberComposition::Simulink::SFState& State, CyberComposition::Simulink::SF_TypeBase& TypeBase, CyberComposition::Simulink::TypeBaseRef& TypeBaseRef)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( Event.Scope() ) == "INPUT_EVENT";;
	return Gz_guard;
}

void EventInput_162b::processInputPackets( const Packets_t& states_162c, const Packets_t& mains_162f)
{
	for( Packets_t::const_iterator itState_1635= states_162c.begin(), itMain_163e= mains_162f.begin(); itState_1635!= states_162c.end(), itMain_163e!= mains_162f.end(); ++itState_1635, ++itMain_163e)
	{
		bool isUnique= isInputUnique( *itState_1635, *itMain_163e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_1635, *itMain_163e);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool EventInput_162b::patternMatcher( const Udm::Object& state_1636, const Udm::Object& main_163f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_1636.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState state_163b= CyberComposition::Simulink::SFState::Cast( state_1636);
		if( false== Uml::IsDerivedFrom( main_163f.type(), SFC::Function::meta))
			continue;
		SFC::Function main_1644= SFC::Function::Cast( main_163f);
		set< CyberComposition::Simulink::SFEvent> events_1646= state_163b.SFEvent_kind_children();
		for( set< CyberComposition::Simulink::SFEvent>::const_iterator itEvent_1647= events_1646.begin(); itEvent_1647!= events_1646.end(); ++itEvent_1647)
		{
			CyberComposition::Simulink::SFEvent currEvent_1648= *itEvent_1647;
			set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_1649= currEvent_1648.TypeBaseRef_kind_children();
			for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_164a= typeBaseRefs_1649.begin(); itTypeBaseRef_164a!= typeBaseRefs_1649.end(); ++itTypeBaseRef_164a)
			{
				CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_164b= *itTypeBaseRef_164a;
				CyberComposition::Simulink::SF_TypeBase typeBase_164c= currTypeBaseRef_164b.ref();
				if( !typeBase_164c)
					continue;
				SFC::DT dT_164d= typeBase_164c.dt();
				if( !dT_164d)
					continue;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_1651;
				if( !isValidBound(boundObjs_1651, state_163b, true))
					continue;
				currMatch.state_1652= state_163b;
				if( !isValidBound(boundObjs_1651, main_1644, true))
					continue;
				currMatch.main_1653= main_1644;
				if( !isValidBound(boundObjs_1651, typeBase_164c, false))
					continue;
				currMatch.typeBase_1654= typeBase_164c;
				if( !isValidBound(boundObjs_1651, dT_164d, false))
					continue;
				currMatch.dT_1655= dT_164d;
				if( !isValidBound(boundObjs_1651, currEvent_1648, false))
					continue;
				currMatch.event_1656= currEvent_1648;
				if( !isValidBound(boundObjs_1651, currTypeBaseRef_164b, false))
					continue;
				currMatch.typeBaseRef_1657= currTypeBaseRef_164b;
				bool Gz_guard= isGuardTrue( currMatch.dT_1655, currMatch.event_1656, currMatch.main_1653, currMatch.state_1652, currMatch.typeBase_1654, currMatch.typeBaseRef_1657);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void EventInput_162b::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg newArg_165e= SFC::Arg::Create( currMatch.main_1653);
		SFC::Arg& Arg= newArg_165e;
		SFC::DT& DT= currMatch.dT_1655;
		CyberComposition::Simulink::SFEvent& Event= currMatch.event_1656;
		SFC::Function& Main= currMatch.main_1653;
		CyberComposition::Simulink::SFState& State= currMatch.state_1652;
		CyberComposition::Simulink::SF_TypeBase& TypeBase= currMatch.typeBase_1654;
		CyberComposition::Simulink::TypeBaseRef& TypeBaseRef= currMatch.typeBaseRef_1657;
		{
__int64 argIndex = static_cast< __int64 >( Main.argCount() ) + static_cast< __int64 >( Event.Port() ) - 1;
Arg.argIndex() = argIndex;

Arg.name() = static_cast< std::string >( Event.Name() ) + "_" + boost::lexical_cast< std::string >( argIndex );
};
		newArg_165e.dt()= currMatch.dT_1655;
		outputAppender( newArg_165e, currMatch.main_1653);
	}
}

void EventInput_162b::outputAppender( const SFC::Arg& arg_165f, const SFC::Function& main_1661)
{
	_arg_1632->push_back( arg_165f);
	_main_1633->push_back( main_1661);
}

void DataOutput_1669::operator()( const Packets_t& states_166a, const Packets_t& functions_166c, Packets_t& states_166e, Packets_t& functions_166f)
{
#ifdef PRINT_INFO
	printLog( "DataOutput_1669" );
#endif
	_state_1670= &states_166e;
	_function_1671= &functions_166f;
	if( ( !states_166a.empty())&& ( !functions_166c.empty()))
		callDataOutput_16aa( states_166a, functions_166c);
	_state_1670->insert( _state_1670->end(), states_166a.begin(), states_166a.end());
	_function_1671->insert( _function_1671->end(), functions_166c.begin(), functions_166c.end());
}

void DataOutput_1669::callDataOutput_16aa( const Packets_t& states_1673, const Packets_t& mains_1676)
{
	Packets_t args_1675;
	Packets_t mains_1678;
	DataOutput_1672 dataOutput_1672;
	dataOutput_1672( states_1673, mains_1676, args_1675, mains_1678);
	if( ( !args_1675.empty())&& ( !mains_1678.empty()))
		callUpdateArgCount_16ad( args_1675, mains_1678);
}

void DataOutput_1669::callUpdateArgCount_16ad( const Packets_t& args_15c5, const Packets_t& mains_15c7)
{
	UpdateArgCount_15c4 updateArgCount_15c4;
	updateArgCount_15c4( args_15c5, mains_15c7);
}

void DataOutput_1672::operator()( const Packets_t& states_1673, const Packets_t& mains_1676, Packets_t& args_1675, Packets_t& mains_1678)
{
#ifdef PRINT_INFO
	printLog( "DataOutput_1672" );
#endif
	RTTGenerator::Instance()->generateRule(1210, "DataOutput");
	_arg_1679= &args_1675;
	_main_167a= &mains_1678;
	processInputPackets( states_1673, mains_1676);
}

bool DataOutput_1672::isInputUnique( const Udm::Object& state_167f, const Udm::Object& main_1688)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_1681= _state_167b.begin(), itMain_168a= _main_1684.begin(); itState_1681!= _state_167b.end(), itMain_168a!= _main_1684.end(); ++itState_1681, ++itMain_168a)
	{
		if( ( *itState_1681== state_167f)&& ( *itMain_168a== main_1688))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_167b.push_back( state_167f);
		_main_1684.push_back( main_1688);
	}
	return isUnique;
}

bool DataOutput_1672::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool DataOutput_1672::isGuardTrue( SFC::DT& DT, CyberComposition::Simulink::SFData& Data, SFC::Function& Main, CyberComposition::Simulink::SFState& State, CyberComposition::Simulink::SF_TypeBase& TypeBase, CyberComposition::Simulink::TypeBaseRef& TypeBaseRef)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( Data.Scope() ) == "OUTPUT_DATA";;
	return Gz_guard;
}

void DataOutput_1672::processInputPackets( const Packets_t& states_1673, const Packets_t& mains_1676)
{
	for( Packets_t::const_iterator itState_167c= states_1673.begin(), itMain_1685= mains_1676.begin(); itState_167c!= states_1673.end(), itMain_1685!= mains_1676.end(); ++itState_167c, ++itMain_1685)
	{
		bool isUnique= isInputUnique( *itState_167c, *itMain_1685);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_167c, *itMain_1685);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool DataOutput_1672::patternMatcher( const Udm::Object& state_167d, const Udm::Object& main_1686)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_167d.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState state_1682= CyberComposition::Simulink::SFState::Cast( state_167d);
		if( false== Uml::IsDerivedFrom( main_1686.type(), SFC::Function::meta))
			continue;
		SFC::Function main_168b= SFC::Function::Cast( main_1686);
		set< CyberComposition::Simulink::SFData> datas_168d= state_1682.SFData_kind_children();
		for( set< CyberComposition::Simulink::SFData>::const_iterator itData_168e= datas_168d.begin(); itData_168e!= datas_168d.end(); ++itData_168e)
		{
			CyberComposition::Simulink::SFData currData_168f= *itData_168e;
			set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_1690= currData_168f.TypeBaseRef_kind_children();
			for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_1691= typeBaseRefs_1690.begin(); itTypeBaseRef_1691!= typeBaseRefs_1690.end(); ++itTypeBaseRef_1691)
			{
				CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_1692= *itTypeBaseRef_1691;
				CyberComposition::Simulink::SF_TypeBase typeBase_1693= currTypeBaseRef_1692.ref();
				if( !typeBase_1693)
					continue;
				SFC::DT dT_1694= typeBase_1693.dt();
				if( !dT_1694)
					continue;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_1698;
				if( !isValidBound(boundObjs_1698, state_1682, true))
					continue;
				currMatch.state_1699= state_1682;
				if( !isValidBound(boundObjs_1698, main_168b, true))
					continue;
				currMatch.main_169a= main_168b;
				if( !isValidBound(boundObjs_1698, typeBase_1693, false))
					continue;
				currMatch.typeBase_169b= typeBase_1693;
				if( !isValidBound(boundObjs_1698, dT_1694, false))
					continue;
				currMatch.dT_169c= dT_1694;
				if( !isValidBound(boundObjs_1698, currData_168f, false))
					continue;
				currMatch.data_169d= currData_168f;
				if( !isValidBound(boundObjs_1698, currTypeBaseRef_1692, false))
					continue;
				currMatch.typeBaseRef_169e= currTypeBaseRef_1692;
				bool Gz_guard= isGuardTrue( currMatch.dT_169c, currMatch.data_169d, currMatch.main_169a, currMatch.state_1699, currMatch.typeBase_169b, currMatch.typeBaseRef_169e);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void DataOutput_1672::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg newArg_16a5= SFC::Arg::Create( currMatch.main_169a);
		SFC::Arg& Arg= newArg_16a5;
		SFC::DT& DT= currMatch.dT_169c;
		CyberComposition::Simulink::SFData& Data= currMatch.data_169d;
		SFC::Function& Main= currMatch.main_169a;
		CyberComposition::Simulink::SFState& State= currMatch.state_1699;
		CyberComposition::Simulink::SF_TypeBase& TypeBase= currMatch.typeBase_169b;
		CyberComposition::Simulink::TypeBaseRef& TypeBaseRef= currMatch.typeBaseRef_169e;
		{
__int64 argIndex = static_cast< __int64 >( Main.argCount() ) + static_cast< __int64 >( Data.Port() ) - 1;
Arg.argIndex() = argIndex;
Arg.ptr() = true;

Arg.name() = static_cast< std::string >( Data.Name() ) + "_" + boost::lexical_cast< std::string >( argIndex );
};
		newArg_16a5.dt()= currMatch.dT_169c;
		outputAppender( newArg_16a5, currMatch.main_169a);
	}
}

void DataOutput_1672::outputAppender( const SFC::Arg& arg_16a6, const SFC::Function& main_16a8)
{
	_arg_1679->push_back( arg_16a6);
	_main_167a->push_back( main_16a8);
}

void EventOutput_16b0::operator()( const Packets_t& states_16b1, const Packets_t& functions_16b3)
{
#ifdef PRINT_INFO
	printLog( "EventOutput_16b0" );
#endif
	if( ( !states_16b1.empty())&& ( !functions_16b3.empty()))
		callEventOutput_16ee( states_16b1, functions_16b3);
}

void EventOutput_16b0::callEventOutput_16ee( const Packets_t& states_16b6, const Packets_t& mains_16b9)
{
	Packets_t args_16b8;
	Packets_t mains_16bb;
	EventOutput_16b5 eventOutput_16b5;
	eventOutput_16b5( states_16b6, mains_16b9, args_16b8, mains_16bb);
	if( ( !args_16b8.empty())&& ( !mains_16bb.empty()))
		callUpdateArgCount_16f1( args_16b8, mains_16bb);
}

void EventOutput_16b0::callUpdateArgCount_16f1( const Packets_t& args_15c5, const Packets_t& mains_15c7)
{
	UpdateArgCount_15c4 updateArgCount_15c4;
	updateArgCount_15c4( args_15c5, mains_15c7);
}

void EventOutput_16b5::operator()( const Packets_t& states_16b6, const Packets_t& mains_16b9, Packets_t& args_16b8, Packets_t& mains_16bb)
{
#ifdef PRINT_INFO
	printLog( "EventOutput_16b5" );
#endif
	RTTGenerator::Instance()->generateRule(1228, "EventOutput");
	_arg_16bc= &args_16b8;
	_main_16bd= &mains_16bb;
	processInputPackets( states_16b6, mains_16b9);
}

bool EventOutput_16b5::isInputUnique( const Udm::Object& state_16c2, const Udm::Object& main_16cb)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itState_16c4= _state_16be.begin(), itMain_16cd= _main_16c7.begin(); itState_16c4!= _state_16be.end(), itMain_16cd!= _main_16c7.end(); ++itState_16c4, ++itMain_16cd)
	{
		if( ( *itState_16c4== state_16c2)&& ( *itMain_16cd== main_16cb))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_state_16be.push_back( state_16c2);
		_main_16c7.push_back( main_16cb);
	}
	return isUnique;
}

bool EventOutput_16b5::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool EventOutput_16b5::isGuardTrue( SFC::DT& DT, CyberComposition::Simulink::SFEvent& Event, SFC::Function& Main, CyberComposition::Simulink::SFState& State, CyberComposition::Simulink::TypeBaseRef& TypeBaseRef, CyberComposition::Simulink::TypeStruct& TypeStruct)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( Event.Scope() ) == "OUTPUT_EVENT";;
	return Gz_guard;
}

void EventOutput_16b5::processInputPackets( const Packets_t& states_16b6, const Packets_t& mains_16b9)
{
	for( Packets_t::const_iterator itState_16bf= states_16b6.begin(), itMain_16c8= mains_16b9.begin(); itState_16bf!= states_16b6.end(), itMain_16c8!= mains_16b9.end(); ++itState_16bf, ++itMain_16c8)
	{
		bool isUnique= isInputUnique( *itState_16bf, *itMain_16c8);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itState_16bf, *itMain_16c8);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool EventOutput_16b5::patternMatcher( const Udm::Object& state_16c0, const Udm::Object& main_16c9)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( state_16c0.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState state_16c5= CyberComposition::Simulink::SFState::Cast( state_16c0);
		if( false== Uml::IsDerivedFrom( main_16c9.type(), SFC::Function::meta))
			continue;
		SFC::Function main_16ce= SFC::Function::Cast( main_16c9);
		set< CyberComposition::Simulink::SFEvent> events_16d0= state_16c5.SFEvent_kind_children();
		for( set< CyberComposition::Simulink::SFEvent>::const_iterator itEvent_16d1= events_16d0.begin(); itEvent_16d1!= events_16d0.end(); ++itEvent_16d1)
		{
			CyberComposition::Simulink::SFEvent currEvent_16d2= *itEvent_16d1;
			set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_16d3= currEvent_16d2.TypeBaseRef_kind_children();
			for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_16d4= typeBaseRefs_16d3.begin(); itTypeBaseRef_16d4!= typeBaseRefs_16d3.end(); ++itTypeBaseRef_16d4)
			{
				CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_16d5= *itTypeBaseRef_16d4;
				CyberComposition::Simulink::SF_TypeBase typeStruct_16d6= currTypeBaseRef_16d5.ref();
				if( false== Uml::IsDerivedFrom( typeStruct_16d6.type(), CyberComposition::Simulink::TypeStruct::meta))
					continue;
				CyberComposition::Simulink::TypeStruct typeStruct_16d7= CyberComposition::Simulink::TypeStruct::Cast( typeStruct_16d6);
				if( !typeStruct_16d7)
					continue;
				SFC::DT dT_16d8= typeStruct_16d7.dt();
				if( !dT_16d8)
					continue;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_16dc;
				if( !isValidBound(boundObjs_16dc, state_16c5, true))
					continue;
				currMatch.state_16dd= state_16c5;
				if( !isValidBound(boundObjs_16dc, main_16ce, true))
					continue;
				currMatch.main_16de= main_16ce;
				if( !isValidBound(boundObjs_16dc, typeStruct_16d7, false))
					continue;
				currMatch.typeStruct_16df= typeStruct_16d7;
				if( !isValidBound(boundObjs_16dc, dT_16d8, false))
					continue;
				currMatch.dT_16e0= dT_16d8;
				if( !isValidBound(boundObjs_16dc, currEvent_16d2, false))
					continue;
				currMatch.event_16e1= currEvent_16d2;
				if( !isValidBound(boundObjs_16dc, currTypeBaseRef_16d5, false))
					continue;
				currMatch.typeBaseRef_16e2= currTypeBaseRef_16d5;
				bool Gz_guard= isGuardTrue( currMatch.dT_16e0, currMatch.event_16e1, currMatch.main_16de, currMatch.state_16dd, currMatch.typeBaseRef_16e2, currMatch.typeStruct_16df);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void EventOutput_16b5::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg newArg_16e9= SFC::Arg::Create( currMatch.main_16de);
		SFC::Arg& Arg= newArg_16e9;
		SFC::DT& DT= currMatch.dT_16e0;
		CyberComposition::Simulink::SFEvent& Event= currMatch.event_16e1;
		SFC::Function& Main= currMatch.main_16de;
		CyberComposition::Simulink::SFState& State= currMatch.state_16dd;
		CyberComposition::Simulink::TypeBaseRef& TypeBaseRef= currMatch.typeBaseRef_16e2;
		CyberComposition::Simulink::TypeStruct& TypeStruct= currMatch.typeStruct_16df;
		{
__int64 argIndex = static_cast< __int64 >( Main.argCount() ) + static_cast< __int64 >( Event.Port() ) - 1;
Arg.argIndex() = argIndex;
Arg.ptr() = true;

Arg.name() = static_cast< std::string >( Event.name() ) + "_" + boost::lexical_cast< std::string >( argIndex );
};
		newArg_16e9.dt()= currMatch.dT_16e0;
		outputAppender( newArg_16e9, currMatch.main_16de);
	}
}

void EventOutput_16b5::outputAppender( const SFC::Arg& arg_16ea, const SFC::Function& main_16ec)
{
	_arg_16bc->push_back( arg_16ea);
	_main_16bd->push_back( main_16ec);
}

void CreateSFChartFunction_1700::operator()( const Packets_t& subsystems_1702, Packets_t& states_1701, Packets_t& mains_1704)
{
#ifdef PRINT_INFO
	printLog( "CreateSFChartFunction_1700" );
#endif
	RTTGenerator::Instance()->generateRule(1243, "CreateSFChartFunction");
	_state_1705= &states_1701;
	_main_1706= &mains_1704;
	processInputPackets( subsystems_1702);
}

bool CreateSFChartFunction_1700::isInputUnique( const Udm::Object& subsystem_170b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_170d= _subsystem_1707.begin(); itSubsystem_170d!= _subsystem_1707.end(); ++itSubsystem_170d)
	{
		if( ( *itSubsystem_170d== subsystem_170b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_subsystem_1707.push_back( subsystem_170b);
	return isUnique;
}

bool CreateSFChartFunction_1700::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateSFChartFunction_1700::processInputPackets( const Packets_t& subsystems_1702)
{
	for( Packets_t::const_iterator itSubsystem_1708= subsystems_1702.begin(); itSubsystem_1708!= subsystems_1702.end(); ++itSubsystem_1708)
	{
		bool isUnique= isInputUnique( *itSubsystem_1708);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1708);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateSFChartFunction_1700::patternMatcher( const Udm::Object& subsystem_1709)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1709.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_170e= CyberComposition::Simulink::Subsystem::Cast( subsystem_1709);
		set< CyberComposition::Simulink::SFState> states_1710= subsystem_170e.SFState_kind_children();
		for( set< CyberComposition::Simulink::SFState>::const_iterator itState_1711= states_1710.begin(); itState_1711!= states_1710.end(); ++itState_1711)
		{
			CyberComposition::Simulink::SFState currState_1712= *itState_1711;
			SFC::Class class_1713= subsystem_170e.cls();
			if( !class_1713)
				continue;
			set< SFC::Struct> structs_1714= class_1713.Struct_kind_children();
			for( set< SFC::Struct>::const_iterator itStruct_1715= structs_1714.begin(); itStruct_1715!= structs_1714.end(); ++itStruct_1715)
			{
				SFC::Struct currStruct_1716= *itStruct_1715;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_171a;
				if( !isValidBound(boundObjs_171a, subsystem_170e, true))
					continue;
				currMatch.subsystem_171b= subsystem_170e;
				if( !isValidBound(boundObjs_171a, currState_1712, false))
					continue;
				currMatch.state_171c= currState_1712;
				if( !isValidBound(boundObjs_171a, class_1713, false))
					continue;
				currMatch.class_171d= class_1713;
				if( !isValidBound(boundObjs_171a, currStruct_1716, false))
					continue;
				currMatch.struct_171e= currStruct_1716;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void CreateSFChartFunction_1700::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function newMain_171f= SFC::Function::Create( currMatch.class_171d, SFC::Class::meta_stmnt);
		SFC::Arg newArg_1720= SFC::Arg::Create( newMain_171f);
		SFC::Arg& Arg= newArg_1720;
		SFC::Class& Class= currMatch.class_171d;
		SFC::Function& Main= newMain_171f;
		CyberComposition::Simulink::SFState& State= currMatch.state_171c;
		SFC::Struct& Struct= currMatch.struct_171e;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_171b;
		{
Main.statementCount() = -1;
};
		{
__int64 statementCount = Class.statementCount();
Main.statementIndex() = statementCount++;
Class.statementCount() = statementCount;
};
		{
Main.name() = static_cast< std::string >( State.name() ) + "_main";
};
		{
__int64 argCount = Main.argCount();
Arg.argIndex() = argCount++;
Main.argCount() = argCount;
Arg.name() = "context";
Arg.ptr() = true;
};
		newArg_1720.dt()= currMatch.struct_171e;
		newMain_171f.sysmain()+= currMatch.subsystem_171b;
		outputAppender( currMatch.state_171c, newMain_171f);
	}
}

void CreateSFChartFunction_1700::outputAppender( const CyberComposition::Simulink::SFState& state_1721, const SFC::Function& main_1723)
{
	_state_1705->push_back( state_1721);
	_main_1706->push_back( main_1723);
}

void CreateClasses_1738::operator()( const Packets_t& systems_1739, const Packets_t& programs_173b, Packets_t& systems_173d)
{
#ifdef PRINT_INFO
	printLog( "CreateClasses_1738" );
#endif
	_system_173e= &systems_173d;
	if( ( !systems_1739.empty())&& ( !programs_173b.empty()))
		callCopyClass_18d8( systems_1739, programs_173b);
	_system_173e->insert( _system_173e->end(), systems_1739.begin(), systems_1739.end());
}

void CreateClasses_1738::callCopyClass_18d8( const Packets_t& systems_1876, const Packets_t& programs_1878)
{
	Packets_t systems_187a;
	Packets_t programs_187b;
	CopyClass_1875 copyClass_1875;
	copyClass_1875( systems_1876, programs_1878, systems_187a, programs_187b);
	if( ( !systems_187a.empty())&& ( !programs_187b.empty()))
		callGetSubSubsystems_18db( systems_187a, programs_187b);
}

void CreateClasses_1738::callGetSubSubsystems_18db( const Packets_t& subsystems_1740, const Packets_t& programs_1743)
{
	Packets_t subSubsystems_1742;
	Packets_t programs_1745;
	GetSubSubsystems_173f getSubSubsystems_173f;
	getSubSubsystems_173f( subsystems_1740, programs_1743, subSubsystems_1742, programs_1745);
	if( ( !subSubsystems_1742.empty())&& ( !programs_1745.empty()))
		callSubsystemFilter_18de( subSubsystems_1742, programs_1745);
}

void CreateClasses_1738::callSubsystemFilter_18de( const Packets_t& systems_17ab, const Packets_t& programs_17ad)
{
	Packets_t systems_17af;
	Packets_t programs_17b0;
	Packets_t systems_17b1;
	Packets_t programs_17b2;
	Packets_t systems_17b3;
	Packets_t sFStates_17b4;
	Packets_t programs_17b5;
	Packets_t systems_17b6;
	Packets_t programs_17b7;
	SubsystemFilter_17aa subsystemFilter_17aa;
	subsystemFilter_17aa( systems_17ab, programs_17ad, systems_17af, programs_17b0, systems_17b1, programs_17b2, systems_17b3, sFStates_17b4, programs_17b5, systems_17b6, programs_17b7);
	if( ( !systems_17af.empty())&& ( !programs_17b0.empty()))
		callGetSubSubsystems_18db( systems_17af, programs_17b0);
	if( ( !systems_17b1.empty())&& ( !programs_17b2.empty()))
		callCreateChartClass_18e1( systems_17b1, programs_17b2);
	if( ( !systems_17b6.empty())&& ( !programs_17b7.empty()))
		callCreateClass_18e4( systems_17b6, programs_17b7);
	if( ( !systems_17b3.empty())&& ( !sFStates_17b4.empty())&& ( !programs_17b5.empty()))
		callCreateSFChartClass_18e7( systems_17b3, sFStates_17b4, programs_17b5);
}

void CreateClasses_1738::callCreateChartClass_18e1( const Packets_t& subsystems_1769, const Packets_t& programs_176b)
{
	CreateChartClass_1768 createChartClass_1768;
	createChartClass_1768( subsystems_1769, programs_176b);
}

void CreateClasses_1738::callCreateClass_18e4( const Packets_t& subsystems_1788, const Packets_t& programs_178b)
{
	Packets_t subsystems_178a;
	Packets_t programs_178d;
	CreateClass_1787 createClass_1787;
	createClass_1787( subsystems_1788, programs_178b, subsystems_178a, programs_178d);
	if( ( !subsystems_178a.empty())&& ( !programs_178d.empty()))
		callCopyClass_18d8( subsystems_178a, programs_178d);
}

void CreateClasses_1738::callCreateSFChartClass_18e7( const Packets_t& subsystems_18ae, const Packets_t& sFStates_18b0, const Packets_t& programs_18b2)
{
	CreateSFChartClass_18ad createSFChartClass_18ad;
	createSFChartClass_18ad( subsystems_18ae, sFStates_18b0, programs_18b2);
}

void GetSubSubsystems_173f::operator()( const Packets_t& subsystems_1740, const Packets_t& programs_1743, Packets_t& subSubsystems_1742, Packets_t& programs_1745)
{
#ifdef PRINT_INFO
	printLog( "GetSubSubsystems_173f" );
#endif
	RTTGenerator::Instance()->generateRule(1265, "GetSubSubsystems");
	_subSubsystem_1746= &subSubsystems_1742;
	_program_1747= &programs_1745;
	processInputPackets( subsystems_1740, programs_1743);
}

bool GetSubSubsystems_173f::isInputUnique( const Udm::Object& subsystem_174c, const Udm::Object& program_1755)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_174e= _subsystem_1748.begin(), itProgram_1757= _program_1751.begin(); itSubsystem_174e!= _subsystem_1748.end(), itProgram_1757!= _program_1751.end(); ++itSubsystem_174e, ++itProgram_1757)
	{
		if( ( *itSubsystem_174e== subsystem_174c)&& ( *itProgram_1757== program_1755))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1748.push_back( subsystem_174c);
		_program_1751.push_back( program_1755);
	}
	return isUnique;
}

bool GetSubSubsystems_173f::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetSubSubsystems_173f::processInputPackets( const Packets_t& subsystems_1740, const Packets_t& programs_1743)
{
	for( Packets_t::const_iterator itSubsystem_1749= subsystems_1740.begin(), itProgram_1752= programs_1743.begin(); itSubsystem_1749!= subsystems_1740.end(), itProgram_1752!= programs_1743.end(); ++itSubsystem_1749, ++itProgram_1752)
	{
		bool isUnique= isInputUnique( *itSubsystem_1749, *itProgram_1752);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1749, *itProgram_1752);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetSubSubsystems_173f::patternMatcher( const Udm::Object& subsystem_174a, const Udm::Object& program_1753)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_174a.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_174f= CyberComposition::Simulink::Subsystem::Cast( subsystem_174a);
		if( false== Uml::IsDerivedFrom( program_1753.type(), SFC::Program::meta))
			continue;
		SFC::Program program_1758= SFC::Program::Cast( program_1753);
		set< CyberComposition::Simulink::Subsystem> subSubsystems_175a= subsystem_174f.Subsystem_kind_children();
		for( set< CyberComposition::Simulink::Subsystem>::const_iterator itSubSubsystem_175b= subSubsystems_175a.begin(); itSubSubsystem_175b!= subSubsystems_175a.end(); ++itSubSubsystem_175b)
		{
			CyberComposition::Simulink::Subsystem currSubSubsystem_175c= *itSubSubsystem_175b;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1760;
			if( !isValidBound(boundObjs_1760, subsystem_174f, true))
				continue;
			currMatch.subsystem_1761= subsystem_174f;
			if( !isValidBound(boundObjs_1760, program_1758, true))
				continue;
			currMatch.program_1762= program_1758;
			if( !isValidBound(boundObjs_1760, currSubSubsystem_175c, false))
				continue;
			currMatch.subSubsystem_1763= currSubSubsystem_175c;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetSubSubsystems_173f::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subSubsystem_1763, currMatch.program_1762);
	}
}

void GetSubSubsystems_173f::outputAppender( const CyberComposition::Simulink::Subsystem& subSubsystem_1764, const SFC::Program& program_1766)
{
	_subSubsystem_1746->push_back( subSubsystem_1764);
	_program_1747->push_back( program_1766);
}

void CreateChartClass_1768::operator()( const Packets_t& subsystems_1769, const Packets_t& programs_176b)
{
#ifdef PRINT_INFO
	printLog( "CreateChartClass_1768" );
#endif
	RTTGenerator::Instance()->generateRule(1270, "CreateChartClass");
	processInputPackets( subsystems_1769, programs_176b);
}

bool CreateChartClass_1768::isInputUnique( const Udm::Object& subsystem_1771, const Udm::Object& program_177a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1773= _subsystem_176d.begin(), itProgram_177c= _program_1776.begin(); itSubsystem_1773!= _subsystem_176d.end(), itProgram_177c!= _program_1776.end(); ++itSubsystem_1773, ++itProgram_177c)
	{
		if( ( *itSubsystem_1773== subsystem_1771)&& ( *itProgram_177c== program_177a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_176d.push_back( subsystem_1771);
		_program_1776.push_back( program_177a);
	}
	return isUnique;
}

bool CreateChartClass_1768::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateChartClass_1768::processInputPackets( const Packets_t& subsystems_1769, const Packets_t& programs_176b)
{
	for( Packets_t::const_iterator itSubsystem_176e= subsystems_1769.begin(), itProgram_1777= programs_176b.begin(); itSubsystem_176e!= subsystems_1769.end(), itProgram_1777!= programs_176b.end(); ++itSubsystem_176e, ++itProgram_1777)
	{
		bool isUnique= isInputUnique( *itSubsystem_176e, *itProgram_1777);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_176e, *itProgram_1777);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateChartClass_1768::patternMatcher( const Udm::Object& subsystem_176f, const Udm::Object& program_1778)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_176f.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1774= CyberComposition::Simulink::Subsystem::Cast( subsystem_176f);
		if( false== Uml::IsDerivedFrom( program_1778.type(), SFC::Program::meta))
			continue;
		SFC::Program program_177d= SFC::Program::Cast( program_1778);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1782;
		if( !isValidBound(boundObjs_1782, subsystem_1774, true))
			continue;
		currMatch.subsystem_1783= subsystem_1774;
		if( !isValidBound(boundObjs_1782, program_177d, true))
			continue;
		currMatch.program_1784= program_177d;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateChartClass_1768::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Class newClass_1785= SFC::Class::Create( currMatch.program_1784, SFC::Program::meta_stmnt);
		SFC::Struct newStruct_1786= SFC::Struct::Create( newClass_1785, SFC::Class::meta_stmnt);
		SFC::Class& Class= newClass_1785;
		SFC::Program& Program= currMatch.program_1784;
		SFC::Struct& Struct= newStruct_1786;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_1783;
		{
Struct.memberCount() = -1;
};
		{
__int64 statementCount = Program.statementCount();
Class.statementIndex() = statementCount++;
Program.statementCount() = statementCount;
};
		{
typedef std::set< Udm::Object > ObjectSet;

ObjectSet objectSet = SFUtils::getAllInstanceEquivalent( Subsystem );
objectSet.erase( Subsystem );

for( ObjectSet::iterator obsItr = objectSet.begin() ; obsItr != objectSet.end() ; (void)++obsItr ) {
  CyberComposition::Simulink::Subsystem::Cast( *obsItr ).cls() = Class;
}
};
		{
std::string name = Subsystem.name();

Class.name() = name;
Struct.name() = name + "_context";
};
		{
__int64 statementCount = Class.statementCount();
Struct.statementIndex() = statementCount++;
Class.statementCount() = statementCount;
};
		currMatch.subsystem_1783.cls()= newClass_1785;
	}
}

void CreateClass_1787::operator()( const Packets_t& subsystems_1788, const Packets_t& programs_178b, Packets_t& subsystems_178a, Packets_t& programs_178d)
{
#ifdef PRINT_INFO
	printLog( "CreateClass_1787" );
#endif
	RTTGenerator::Instance()->generateRule(1283, "CreateClass");
	_subsystem_178e= &subsystems_178a;
	_program_178f= &programs_178d;
	processInputPackets( subsystems_1788, programs_178b);
	forwardInputs( );
}

bool CreateClass_1787::isInputUnique( const Udm::Object& subsystem_1794, const Udm::Object& program_179d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1796= _subsystem_1790.begin(), itProgram_179f= _program_1799.begin(); itSubsystem_1796!= _subsystem_1790.end(), itProgram_179f!= _program_1799.end(); ++itSubsystem_1796, ++itProgram_179f)
	{
		if( ( *itSubsystem_1796== subsystem_1794)&& ( *itProgram_179f== program_179d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1790.push_back( subsystem_1794);
		_program_1799.push_back( program_179d);
	}
	return isUnique;
}

bool CreateClass_1787::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateClass_1787::processInputPackets( const Packets_t& subsystems_1788, const Packets_t& programs_178b)
{
	for( Packets_t::const_iterator itSubsystem_1791= subsystems_1788.begin(), itProgram_179a= programs_178b.begin(); itSubsystem_1791!= subsystems_1788.end(), itProgram_179a!= programs_178b.end(); ++itSubsystem_1791, ++itProgram_179a)
	{
		bool isUnique= isInputUnique( *itSubsystem_1791, *itProgram_179a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1791, *itProgram_179a);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateClass_1787::patternMatcher( const Udm::Object& subsystem_1792, const Udm::Object& program_179b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1792.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1797= CyberComposition::Simulink::Subsystem::Cast( subsystem_1792);
		if( false== Uml::IsDerivedFrom( program_179b.type(), SFC::Program::meta))
			continue;
		SFC::Program program_17a0= SFC::Program::Cast( program_179b);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_17a5;
		if( !isValidBound(boundObjs_17a5, subsystem_1797, true))
			continue;
		currMatch.subsystem_17a6= subsystem_1797;
		if( !isValidBound(boundObjs_17a5, program_17a0, true))
			continue;
		currMatch.program_17a7= program_17a0;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateClass_1787::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Class newClass_17a8= SFC::Class::Create( currMatch.program_17a7, SFC::Program::meta_stmnt);
		SFC::Struct newStruct_17a9= SFC::Struct::Create( newClass_17a8, SFC::Class::meta_stmnt);
		SFC::Class& Class= newClass_17a8;
		SFC::Program& Program= currMatch.program_17a7;
		SFC::Struct& Struct= newStruct_17a9;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_17a6;
		{
__int64 statementCount = Class.statementCount();
Struct.statementIndex() = statementCount++;
Class.statementCount() = statementCount;
};
		{
std::string name = static_cast< std::string >( Subsystem.name() ) + "_" + boost::lexical_cast< std::string >( Subsystem.uniqueId() );
Class.name() = name + "_class";
Class.annotation() = Subsystem.Description();
Struct.name() = name + "_context";
};
		{
typedef std::set< Udm::Object > ObjectSet;

ObjectSet objectSet = SFUtils::getAllInstanceEquivalent( Subsystem );
objectSet.erase( Subsystem );

for( ObjectSet::iterator obsItr = objectSet.begin() ; obsItr != objectSet.end() ; (void)++obsItr ) {
  CyberComposition::Simulink::Subsystem::Cast( *obsItr ).cls() = Class;
}
};
		{
__int64 statementCount = Program.statementCount();
Class.statementIndex() = statementCount++;
Program.statementCount() = statementCount;
};
		currMatch.subsystem_17a6.cls()= newClass_17a8;
	}
}

void CreateClass_1787::forwardInputs()
{
	*_subsystem_178e= _subsystem_1790;
	*_program_178f= _program_1799;
}

void SubsystemFilter_17aa::operator()( const Packets_t& systems_17ab, const Packets_t& programs_17ad, Packets_t& systems_17af, Packets_t& programs_17b0, Packets_t& systems_17b1, Packets_t& programs_17b2, Packets_t& systems_17b3, Packets_t& sFStates_17b4, Packets_t& programs_17b5, Packets_t& systems_17b6, Packets_t& programs_17b7)
{
#ifdef PRINT_INFO
	printLog( "SubsystemFilter_17aa" );
#endif
	_system_17b8= &systems_17af;
	_program_17b9= &programs_17b0;
	_system_17ba= &systems_17b1;
	_program_17bb= &programs_17b2;
	_system_17bc= &systems_17b3;
	_sFState_17bd= &sFStates_17b4;
	_program_17be= &programs_17b5;
	_system_17bf= &systems_17b6;
	_program_17c0= &programs_17b7;
	for( Packets_t::const_iterator itsystem_17c2= systems_17ab.begin(), itprogram_17c9= programs_17ad.begin(); itsystem_17c2!= systems_17ab.end(), itprogram_17c9!= programs_17ad.end(); ++itsystem_17c2, ++itprogram_17c9)
	{
		bool isUnique= isInputUnique( *itsystem_17c2, *itprogram_17c9);
		if( !isUnique)
			continue;
		Packets_t onesystem_17c6( 1, *itsystem_17c2);
		Packets_t oneprogram_17cd( 1, *itprogram_17c9);
		executeOne( onesystem_17c6, oneprogram_17cd);
	}
}

void SubsystemFilter_17aa::executeOne( const Packets_t& systems_17ab, const Packets_t& programs_17ad)
{
	Packets_t subsystems_17d2;
	Packets_t programs_17d5;
	HasClass_17cf hasClass_17cf;
	bool isMatchHasClass_17cf= hasClass_17cf( systems_17ab, programs_17ad, subsystems_17d2, programs_17d5);
	_system_17b8->insert( _system_17b8->end(), subsystems_17d2.begin(), subsystems_17d2.end());
	_program_17b9->insert( _program_17b9->end(), programs_17d5.begin(), programs_17d5.end());
	if( isMatchHasClass_17cf)
		return;
	Packets_t subsystems_17f9;
	Packets_t programs_17fc;
	IsStateChart_17f6 isStateChart_17f6;
	bool isMatchIsStateChart_17f6= isStateChart_17f6( systems_17ab, programs_17ad, subsystems_17f9, programs_17fc);
	_system_17ba->insert( _system_17ba->end(), subsystems_17f9.begin(), subsystems_17f9.end());
	_program_17bb->insert( _program_17bb->end(), programs_17fc.begin(), programs_17fc.end());
	if( isMatchIsStateChart_17f6)
		return;
	Packets_t subsystems_1826;
	Packets_t sFStates_1827;
	Packets_t programs_182a;
	IsSFStateChart_1823 isSFStateChart_1823;
	bool isMatchIsSFStateChart_1823= isSFStateChart_1823( systems_17ab, programs_17ad, subsystems_1826, sFStates_1827, programs_182a);
	_system_17bc->insert( _system_17bc->end(), subsystems_1826.begin(), subsystems_1826.end());
	_sFState_17bd->insert( _sFState_17bd->end(), sFStates_1827.begin(), sFStates_1827.end());
	_program_17be->insert( _program_17be->end(), programs_182a.begin(), programs_182a.end());
	if( isMatchIsSFStateChart_1823)
		return;
	Packets_t subsystems_1853;
	Packets_t programs_1856;
	Otherwise_1850 otherwise_1850;
	bool isMatchOtherwise_1850= otherwise_1850( systems_17ab, programs_17ad, subsystems_1853, programs_1856);
	_system_17bf->insert( _system_17bf->end(), subsystems_1853.begin(), subsystems_1853.end());
	_program_17c0->insert( _program_17c0->end(), programs_1856.begin(), programs_1856.end());
	if( isMatchOtherwise_1850)
		return;
}

bool SubsystemFilter_17aa::isInputUnique( const Udm::Object& system_17c3, const Udm::Object& program_17ca)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itsystem_17c5= _system_17c1.begin(), itprogram_17cc= _program_17c8.begin(); itsystem_17c5!= _system_17c1.end(), itprogram_17cc!= _program_17c8.end(); ++itsystem_17c5, ++itprogram_17cc)
	{
		if( ( *itsystem_17c5== system_17c3)&& ( *itprogram_17cc== program_17ca))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_system_17c1.push_back( system_17c3);
		_program_17c8.push_back( program_17ca);
	}
	return isUnique;
}

bool HasClass_17cf::operator()( const Packets_t& subsystems_17d0, const Packets_t& programs_17d3, Packets_t& subsystems_17d2, Packets_t& programs_17d5)
{
#ifdef PRINT_INFO
	printLog( "HasClass_17cf" );
#endif
	_subsystem_17d6= &subsystems_17d2;
	_program_17d7= &programs_17d5;
	processInputPackets( subsystems_17d0, programs_17d3);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasClass_17cf::isInputUnique( const Udm::Object& subsystem_17dc, const Udm::Object& program_17e5)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_17de= _subsystem_17d8.begin(), itProgram_17e7= _program_17e1.begin(); itSubsystem_17de!= _subsystem_17d8.end(), itProgram_17e7!= _program_17e1.end(); ++itSubsystem_17de, ++itProgram_17e7)
	{
		if( ( *itSubsystem_17de== subsystem_17dc)&& ( *itProgram_17e7== program_17e5))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_17d8.push_back( subsystem_17dc);
		_program_17e1.push_back( program_17e5);
	}
	return isUnique;
}

bool HasClass_17cf::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void HasClass_17cf::processInputPackets( const Packets_t& subsystems_17d0, const Packets_t& programs_17d3)
{
	for( Packets_t::const_iterator itSubsystem_17d9= subsystems_17d0.begin(), itProgram_17e2= programs_17d3.begin(); itSubsystem_17d9!= subsystems_17d0.end(), itProgram_17e2!= programs_17d3.end(); ++itSubsystem_17d9, ++itProgram_17e2)
	{
		bool isUnique= isInputUnique( *itSubsystem_17d9, *itProgram_17e2);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_17d9, *itProgram_17e2);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_17ef, currMatch.program_17f0);
	}
}

bool HasClass_17cf::patternMatcher( const Udm::Object& subsystem_17da, const Udm::Object& program_17e3)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_17da.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_17df= CyberComposition::Simulink::Subsystem::Cast( subsystem_17da);
		if( false== Uml::IsDerivedFrom( program_17e3.type(), SFC::Program::meta))
			continue;
		SFC::Program program_17e8= SFC::Program::Cast( program_17e3);
		SFC::Class class_17ea= subsystem_17df.cls();
		if( !class_17ea)
			continue;
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_17ee;
		if( !isValidBound(boundObjs_17ee, subsystem_17df, true))
			continue;
		currMatch.subsystem_17ef= subsystem_17df;
		if( !isValidBound(boundObjs_17ee, program_17e8, true))
			continue;
		currMatch.program_17f0= program_17e8;
		if( !isValidBound(boundObjs_17ee, class_17ea, false))
			continue;
		currMatch.class_17f1= class_17ea;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void HasClass_17cf::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_17f2, const SFC::Program& program_17f4)
{
	_subsystem_17d6->push_back( subsystem_17f2);
	_program_17d7->push_back( program_17f4);
}

bool IsStateChart_17f6::operator()( const Packets_t& subsystems_17f7, const Packets_t& programs_17fa, Packets_t& subsystems_17f9, Packets_t& programs_17fc)
{
#ifdef PRINT_INFO
	printLog( "IsStateChart_17f6" );
#endif
	_subsystem_17fd= &subsystems_17f9;
	_program_17fe= &programs_17fc;
	processInputPackets( subsystems_17f7, programs_17fa);
	if( false== _matches.empty())
		return true;
	return false;
}

bool IsStateChart_17f6::isInputUnique( const Udm::Object& subsystem_1803, const Udm::Object& program_180c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1805= _subsystem_17ff.begin(), itProgram_180e= _program_1808.begin(); itSubsystem_1805!= _subsystem_17ff.end(), itProgram_180e!= _program_1808.end(); ++itSubsystem_1805, ++itProgram_180e)
	{
		if( ( *itSubsystem_1805== subsystem_1803)&& ( *itProgram_180e== program_180c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_17ff.push_back( subsystem_1803);
		_program_1808.push_back( program_180c);
	}
	return isUnique;
}

bool IsStateChart_17f6::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void IsStateChart_17f6::processInputPackets( const Packets_t& subsystems_17f7, const Packets_t& programs_17fa)
{
	for( Packets_t::const_iterator itSubsystem_1800= subsystems_17f7.begin(), itProgram_1809= programs_17fa.begin(); itSubsystem_1800!= subsystems_17f7.end(), itProgram_1809!= programs_17fa.end(); ++itSubsystem_1800, ++itProgram_1809)
	{
		bool isUnique= isInputUnique( *itSubsystem_1800, *itProgram_1809);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1800, *itProgram_1809);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_181b, currMatch.program_181c);
	}
}

bool IsStateChart_17f6::patternMatcher( const Udm::Object& subsystem_1801, const Udm::Object& program_180a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1801.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1806= CyberComposition::Simulink::Subsystem::Cast( subsystem_1801);
		if( false== Uml::IsDerivedFrom( program_180a.type(), SFC::Program::meta))
			continue;
		SFC::Program program_180f= SFC::Program::Cast( program_180a);
		set< CyberComposition::Simulink::Primitive> primitives_1811= subsystem_1806.Primitive_kind_children();
		for( set< CyberComposition::Simulink::Primitive>::const_iterator itPrimitive_1812= primitives_1811.begin(); itPrimitive_1812!= primitives_1811.end(); ++itPrimitive_1812)
		{
			CyberComposition::Simulink::Primitive currPrimitive_1813= *itPrimitive_1812;
			set< CyberComposition::Simulink::State> states_1814= currPrimitive_1813.State_kind_children();
			for( set< CyberComposition::Simulink::State>::const_iterator itState_1815= states_1814.begin(); itState_1815!= states_1814.end(); ++itState_1815)
			{
				CyberComposition::Simulink::State currState_1816= *itState_1815;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_181a;
				if( !isValidBound(boundObjs_181a, subsystem_1806, true))
					continue;
				currMatch.subsystem_181b= subsystem_1806;
				if( !isValidBound(boundObjs_181a, program_180f, true))
					continue;
				currMatch.program_181c= program_180f;
				if( !isValidBound(boundObjs_181a, currPrimitive_1813, false))
					continue;
				currMatch.primitive_181d= currPrimitive_1813;
				if( !isValidBound(boundObjs_181a, currState_1816, false))
					continue;
				currMatch.state_181e= currState_1816;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void IsStateChart_17f6::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_181f, const SFC::Program& program_1821)
{
	_subsystem_17fd->push_back( subsystem_181f);
	_program_17fe->push_back( program_1821);
}

bool IsSFStateChart_1823::operator()( const Packets_t& subsystems_1824, const Packets_t& programs_1828, Packets_t& subsystems_1826, Packets_t& sFStates_1827, Packets_t& programs_182a)
{
#ifdef PRINT_INFO
	printLog( "IsSFStateChart_1823" );
#endif
	_subsystem_182b= &subsystems_1826;
	_sFState_182c= &sFStates_1827;
	_program_182d= &programs_182a;
	processInputPackets( subsystems_1824, programs_1828);
	if( false== _matches.empty())
		return true;
	return false;
}

bool IsSFStateChart_1823::isInputUnique( const Udm::Object& subsystem_1832, const Udm::Object& program_183b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1834= _subsystem_182e.begin(), itProgram_183d= _program_1837.begin(); itSubsystem_1834!= _subsystem_182e.end(), itProgram_183d!= _program_1837.end(); ++itSubsystem_1834, ++itProgram_183d)
	{
		if( ( *itSubsystem_1834== subsystem_1832)&& ( *itProgram_183d== program_183b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_182e.push_back( subsystem_1832);
		_program_1837.push_back( program_183b);
	}
	return isUnique;
}

bool IsSFStateChart_1823::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void IsSFStateChart_1823::processInputPackets( const Packets_t& subsystems_1824, const Packets_t& programs_1828)
{
	for( Packets_t::const_iterator itSubsystem_182f= subsystems_1824.begin(), itProgram_1838= programs_1828.begin(); itSubsystem_182f!= subsystems_1824.end(), itProgram_1838!= programs_1828.end(); ++itSubsystem_182f, ++itProgram_1838)
	{
		bool isUnique= isInputUnique( *itSubsystem_182f, *itProgram_1838);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_182f, *itProgram_1838);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_1847, currMatch.sFState_1849, currMatch.program_1848);
	}
}

bool IsSFStateChart_1823::patternMatcher( const Udm::Object& subsystem_1830, const Udm::Object& program_1839)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1830.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1835= CyberComposition::Simulink::Subsystem::Cast( subsystem_1830);
		if( false== Uml::IsDerivedFrom( program_1839.type(), SFC::Program::meta))
			continue;
		SFC::Program program_183e= SFC::Program::Cast( program_1839);
		set< CyberComposition::Simulink::SFState> sFStates_1840= subsystem_1835.SFState_kind_children();
		for( set< CyberComposition::Simulink::SFState>::const_iterator itSFState_1841= sFStates_1840.begin(); itSFState_1841!= sFStates_1840.end(); ++itSFState_1841)
		{
			CyberComposition::Simulink::SFState currSFState_1842= *itSFState_1841;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1846;
			if( !isValidBound(boundObjs_1846, subsystem_1835, true))
				continue;
			currMatch.subsystem_1847= subsystem_1835;
			if( !isValidBound(boundObjs_1846, program_183e, true))
				continue;
			currMatch.program_1848= program_183e;
			if( !isValidBound(boundObjs_1846, currSFState_1842, false))
				continue;
			currMatch.sFState_1849= currSFState_1842;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void IsSFStateChart_1823::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_184a, const CyberComposition::Simulink::SFState& sFState_184c, const SFC::Program& program_184e)
{
	_subsystem_182b->push_back( subsystem_184a);
	_sFState_182c->push_back( sFState_184c);
	_program_182d->push_back( program_184e);
}

bool Otherwise_1850::operator()( const Packets_t& subsystems_1851, const Packets_t& programs_1854, Packets_t& subsystems_1853, Packets_t& programs_1856)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_1850" );
#endif
	_subsystem_1857= &subsystems_1853;
	_program_1858= &programs_1856;
	processInputPackets( subsystems_1851, programs_1854);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_1850::isInputUnique( const Udm::Object& subsystem_185d, const Udm::Object& program_1866)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_185f= _subsystem_1859.begin(), itProgram_1868= _program_1862.begin(); itSubsystem_185f!= _subsystem_1859.end(), itProgram_1868!= _program_1862.end(); ++itSubsystem_185f, ++itProgram_1868)
	{
		if( ( *itSubsystem_185f== subsystem_185d)&& ( *itProgram_1868== program_1866))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1859.push_back( subsystem_185d);
		_program_1862.push_back( program_1866);
	}
	return isUnique;
}

bool Otherwise_1850::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_1850::processInputPackets( const Packets_t& subsystems_1851, const Packets_t& programs_1854)
{
	for( Packets_t::const_iterator itSubsystem_185a= subsystems_1851.begin(), itProgram_1863= programs_1854.begin(); itSubsystem_185a!= subsystems_1851.end(), itProgram_1863!= programs_1854.end(); ++itSubsystem_185a, ++itProgram_1863)
	{
		bool isUnique= isInputUnique( *itSubsystem_185a, *itProgram_1863);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_185a, *itProgram_1863);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_186f, currMatch.program_1870);
	}
}

bool Otherwise_1850::patternMatcher( const Udm::Object& subsystem_185b, const Udm::Object& program_1864)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_185b.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1860= CyberComposition::Simulink::Subsystem::Cast( subsystem_185b);
		if( false== Uml::IsDerivedFrom( program_1864.type(), SFC::Program::meta))
			continue;
		SFC::Program program_1869= SFC::Program::Cast( program_1864);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_186e;
		if( !isValidBound(boundObjs_186e, subsystem_1860, true))
			continue;
		currMatch.subsystem_186f= subsystem_1860;
		if( !isValidBound(boundObjs_186e, program_1869, true))
			continue;
		currMatch.program_1870= program_1869;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_1850::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_1871, const SFC::Program& program_1873)
{
	_subsystem_1857->push_back( subsystem_1871);
	_program_1858->push_back( program_1873);
}

void CopyClass_1875::operator()( const Packets_t& systems_1876, const Packets_t& programs_1878, Packets_t& systems_187a, Packets_t& programs_187b)
{
#ifdef PRINT_INFO
	printLog( "CopyClass_1875" );
#endif
	_system_187c= &systems_187a;
	_program_187d= &programs_187b;
	_system_187c->insert( _system_187c->end(), systems_1876.begin(), systems_1876.end());
	_program_187d->insert( _program_187d->end(), programs_1878.begin(), programs_1878.end());
	if( ( !systems_1876.empty())&& ( !programs_1878.empty()))
		callCopyClass_18aa( systems_1876, programs_1878);
}

void CopyClass_1875::callCopyClass_18aa( const Packets_t& subsystems_187f, const Packets_t& programs_1881)
{
	CopyClass_187e copyClass_187e;
	copyClass_187e( subsystems_187f, programs_1881);
}

void CopyClass_187e::operator()( const Packets_t& subsystems_187f, const Packets_t& programs_1881)
{
#ifdef PRINT_INFO
	printLog( "CopyClass_187e" );
#endif
	RTTGenerator::Instance()->generateRule(1332, "CopyClass");
	processInputPackets( subsystems_187f, programs_1881);
}

bool CopyClass_187e::isInputUnique( const Udm::Object& subsystem_1887, const Udm::Object& program_1890)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1889= _subsystem_1883.begin(), itProgram_1892= _program_188c.begin(); itSubsystem_1889!= _subsystem_1883.end(), itProgram_1892!= _program_188c.end(); ++itSubsystem_1889, ++itProgram_1892)
	{
		if( ( *itSubsystem_1889== subsystem_1887)&& ( *itProgram_1892== program_1890))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1883.push_back( subsystem_1887);
		_program_188c.push_back( program_1890);
	}
	return isUnique;
}

bool CopyClass_187e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool CopyClass_187e::isGuardTrue( SFC::Class& Class, CyberComposition::Simulink::Subsystem& InstanceSubsystem, SFC::Program& Program, CyberComposition::Simulink::Subsystem& Subsystem)
{
	bool Gz_guard= false;
	Gz_guard = Subsystem.uniqueId() != InstanceSubsystem.uniqueId();;
	return Gz_guard;
}

void CopyClass_187e::processInputPackets( const Packets_t& subsystems_187f, const Packets_t& programs_1881)
{
	for( Packets_t::const_iterator itSubsystem_1884= subsystems_187f.begin(), itProgram_188d= programs_1881.begin(); itSubsystem_1884!= subsystems_187f.end(), itProgram_188d!= programs_1881.end(); ++itSubsystem_1884, ++itProgram_188d)
	{
		bool isUnique= isInputUnique( *itSubsystem_1884, *itProgram_188d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1884, *itProgram_188d);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CopyClass_187e::patternMatcher( const Udm::Object& subsystem_1885, const Udm::Object& program_188e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1885.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_188a= CyberComposition::Simulink::Subsystem::Cast( subsystem_1885);
		if( false== Uml::IsDerivedFrom( program_188e.type(), SFC::Program::meta))
			continue;
		SFC::Program program_1893= SFC::Program::Cast( program_188e);
		set< SFC::Class> classs_1895= program_1893.Class_kind_children();
		for( set< SFC::Class>::const_iterator itClass_1896= classs_1895.begin(); itClass_1896!= classs_1895.end(); ++itClass_1896)
		{
			SFC::Class currClass_1897= *itClass_1896;
			SFC::Class class_1898= subsystem_188a.cls();
			if( !class_1898)
				continue;
			if( currClass_1897!= class_1898)
				continue;
			set< CyberComposition::Simulink::Subsystem> instanceSubsystems_1899= currClass_1897.obj();
			for( set< CyberComposition::Simulink::Subsystem>::const_iterator itInstanceSubsystems_189a= instanceSubsystems_1899.begin(); itInstanceSubsystems_189a!= instanceSubsystems_1899.end(); ++itInstanceSubsystems_189a)
			{
				CyberComposition::Simulink::Subsystem currInstanceSubsystem_189b= *itInstanceSubsystems_189a;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_189f;
				if( !isValidBound(boundObjs_189f, subsystem_188a, true))
					continue;
				currMatch.subsystem_18a0= subsystem_188a;
				if( !isValidBound(boundObjs_189f, program_1893, true))
					continue;
				currMatch.program_18a1= program_1893;
				if( !isValidBound(boundObjs_189f, currClass_1897, false))
					continue;
				currMatch.class_18a2= currClass_1897;
				if( !isValidBound(boundObjs_189f, currInstanceSubsystem_189b, false))
					continue;
				currMatch.instanceSubsystem_18a3= currInstanceSubsystem_189b;
				bool Gz_guard= isGuardTrue( currMatch.class_18a2, currMatch.instanceSubsystem_18a3, currMatch.program_18a1, currMatch.subsystem_18a0);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void CopyClass_187e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Class newInstanceClass_18a8= SFC::Class::Create( currMatch.program_18a1, SFC::Program::meta_stmnt);
		SFC::Struct newInstanceStruct_18a9= SFC::Struct::Create( newInstanceClass_18a8, SFC::Class::meta_stmnt);
		SFC::Class& Class= currMatch.class_18a2;
		SFC::Class& InstanceClass= newInstanceClass_18a8;
		SFC::Struct& InstanceStruct= newInstanceStruct_18a9;
		CyberComposition::Simulink::Subsystem& InstanceSubsystem= currMatch.instanceSubsystem_18a3;
		SFC::Program& Program= currMatch.program_18a1;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_18a0;
		{
__int64 statementCount = Program.statementCount();
InstanceClass.statementIndex() = statementCount++;
Program.statementCount() = statementCount;
};
		{
std::string name = static_cast< std::string >( InstanceSubsystem.name() ) + "_" + boost::lexical_cast< std::string >( InstanceClass.uniqueId() );
InstanceClass.name() = name+ "_class";
InstanceClass.annotation() = InstanceSubsystem.Description();
InstanceStruct.name() = name + "_context";
};
		{
__int64 statementCount = InstanceClass.statementCount();
InstanceStruct.statementIndex() = statementCount++;
InstanceClass.statementCount() = statementCount;
};
		currMatch.instanceSubsystem_18a3.cls()= newInstanceClass_18a8;
	}
}

void CreateSFChartClass_18ad::operator()( const Packets_t& subsystems_18ae, const Packets_t& sFStates_18b0, const Packets_t& programs_18b2)
{
#ifdef PRINT_INFO
	printLog( "CreateSFChartClass_18ad" );
#endif
	RTTGenerator::Instance()->generateRule(1348, "CreateSFChartClass");
	processInputPackets( subsystems_18ae, sFStates_18b0, programs_18b2);
}

bool CreateSFChartClass_18ad::isInputUnique( const Udm::Object& subsystem_18b8, const Udm::Object& sFState_18c1, const Udm::Object& program_18ca)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_18ba= _subsystem_18b4.begin(), itSFState_18c3= _sFState_18bd.begin(), itProgram_18cc= _program_18c6.begin(); itSubsystem_18ba!= _subsystem_18b4.end(), itSFState_18c3!= _sFState_18bd.end(), itProgram_18cc!= _program_18c6.end(); ++itSubsystem_18ba, ++itSFState_18c3, ++itProgram_18cc)
	{
		if( ( *itSubsystem_18ba== subsystem_18b8)&& ( *itSFState_18c3== sFState_18c1)&& ( *itProgram_18cc== program_18ca))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_18b4.push_back( subsystem_18b8);
		_sFState_18bd.push_back( sFState_18c1);
		_program_18c6.push_back( program_18ca);
	}
	return isUnique;
}

bool CreateSFChartClass_18ad::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateSFChartClass_18ad::processInputPackets( const Packets_t& subsystems_18ae, const Packets_t& sFStates_18b0, const Packets_t& programs_18b2)
{
	for( Packets_t::const_iterator itSubsystem_18b5= subsystems_18ae.begin(), itSFState_18be= sFStates_18b0.begin(), itProgram_18c7= programs_18b2.begin(); itSubsystem_18b5!= subsystems_18ae.end(), itSFState_18be!= sFStates_18b0.end(), itProgram_18c7!= programs_18b2.end(); ++itSubsystem_18b5, ++itSFState_18be, ++itProgram_18c7)
	{
		bool isUnique= isInputUnique( *itSubsystem_18b5, *itSFState_18be, *itProgram_18c7);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_18b5, *itSFState_18be, *itProgram_18c7);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateSFChartClass_18ad::patternMatcher( const Udm::Object& subsystem_18b6, const Udm::Object& sFState_18bf, const Udm::Object& program_18c8)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_18b6.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_18bb= CyberComposition::Simulink::Subsystem::Cast( subsystem_18b6);
		if( false== Uml::IsDerivedFrom( sFState_18bf.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState sFState_18c4= CyberComposition::Simulink::SFState::Cast( sFState_18bf);
		if( false== Uml::IsDerivedFrom( program_18c8.type(), SFC::Program::meta))
			continue;
		SFC::Program program_18cd= SFC::Program::Cast( program_18c8);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_18d2;
		if( !isValidBound(boundObjs_18d2, subsystem_18bb, true))
			continue;
		currMatch.subsystem_18d3= subsystem_18bb;
		if( !isValidBound(boundObjs_18d2, sFState_18c4, true))
			continue;
		currMatch.sFState_18d4= sFState_18c4;
		if( !isValidBound(boundObjs_18d2, program_18cd, true))
			continue;
		currMatch.program_18d5= program_18cd;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateSFChartClass_18ad::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Class newClass_18d6= SFC::Class::Create( currMatch.program_18d5, SFC::Program::meta_stmnt);
		SFC::Struct newStruct_18d7= SFC::Struct::Create( newClass_18d6, SFC::Class::meta_stmnt);
		SFC::Class& Class= newClass_18d6;
		SFC::Program& Program= currMatch.program_18d5;
		CyberComposition::Simulink::SFState& SFState= currMatch.sFState_18d4;
		SFC::Struct& Struct= newStruct_18d7;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_18d3;
		{
__int64 statementCount = Class.statementCount();
Struct.statementIndex() = statementCount++;
Class.statementCount() = statementCount;
};
		{
__int64 statementCount = Program.statementCount();
Class.statementIndex() = statementCount++;
Program.statementCount() = statementCount;
};
		{
Struct.memberCount() = -1;
};
		{
std::string name = SFState.name();

Class.name() = name;
Struct.name() = name + "_context";
};
		{
typedef std::set< Udm::Object > ObjectSet;

ObjectSet objectSet = SFUtils::getAllInstanceEquivalent( Subsystem );
objectSet.erase( Subsystem );

for( ObjectSet::iterator obsItr = objectSet.begin() ; obsItr != objectSet.end() ; (void)++obsItr ) {
  CyberComposition::Simulink::Subsystem::Cast( *obsItr ).cls() = Class;
}
};
		currMatch.subsystem_18d3.cls()= newClass_18d6;
	}
}

void CreateFunctionLocalVars_18eb::operator()( const Packets_t& systems_18ec, Packets_t& systems_18ee)
{
#ifdef PRINT_INFO
	printLog( "CreateFunctionLocalVars_18eb" );
#endif
	_system_18ef= &systems_18ee;
	_system_18ef->insert( _system_18ef->end(), systems_18ec.begin(), systems_18ec.end());
	if( ( !systems_18ec.empty()))
		callSubsystemFilter_1c36( systems_18ec);
}

void CreateFunctionLocalVars_18eb::callSubsystemFilter_1c36( const Packets_t& systems_10d2)
{
	Packets_t chartsystems_10d4;
	Packets_t sFchartsystems_10d5;
	Packets_t systems_10d6;
	SubsystemFilter_10d1 subsystemFilter_10d1;
	subsystemFilter_10d1( systems_10d2, chartsystems_10d4, sFchartsystems_10d5, systems_10d6);
	if( ( !systems_10d6.empty()))
		callGetFunctions_1c38( systems_10d6);
}

void CreateFunctionLocalVars_18eb::callGetFunctions_1c38( const Packets_t& systems_1c13)
{
	Packets_t systems_1c15;
	Packets_t systemFunctions_1c16;
	GetFunctions_1c12 getFunctions_1c12;
	getFunctions_1c12( systems_1c13, systems_1c15, systemFunctions_1c16);
	if( ( !systems_1c15.empty())&& ( !systemFunctions_1c16.empty()))
		callCreateOutPortLVs_1c3a( systems_1c15, systemFunctions_1c16);
}

void CreateFunctionLocalVars_18eb::callCreateOutPortLVs_1c3a( const Packets_t& systems_1a66, const Packets_t& systemFunctions_1a68)
{
	Packets_t systems_1a6a;
	Packets_t systemFunctions_1a6b;
	CreateOutPortLVs_1a65 createOutPortLVs_1a65;
	createOutPortLVs_1a65( systems_1a66, systemFunctions_1a68, systems_1a6a, systemFunctions_1a6b);
	if( ( !systems_1a6a.empty())&& ( !systemFunctions_1a6b.empty()))
		callCreateInPortLVs_1c3d( systems_1a6a, systemFunctions_1a6b);
}

void CreateFunctionLocalVars_18eb::callCreateInPortLVs_1c3d( const Packets_t& systems_18f1, const Packets_t& systemFunctions_18f3)
{
	Packets_t systems_18f5;
	CreateInPortLVs_18f0 createInPortLVs_18f0;
	createInPortLVs_18f0( systems_18f1, systemFunctions_18f3, systems_18f5);
	if( ( !systems_18f5.empty()))
		callGetSubSubsystems_1c40( systems_18f5);
}

void CreateFunctionLocalVars_18eb::callGetSubSubsystems_1c40( const Packets_t& systems_10b2)
{
	Packets_t subsystems_10b4;
	GetSubSubsystems_10b1 getSubSubsystems_10b1;
	getSubSubsystems_10b1( systems_10b2, subsystems_10b4);
	if( ( !subsystems_10b4.empty()))
		callSubsystemFilter_1c36( subsystems_10b4);
}

void CreateInPortLVs_18f0::operator()( const Packets_t& systems_18f1, const Packets_t& systemFunctions_18f3, Packets_t& systems_18f5)
{
#ifdef PRINT_INFO
	printLog( "CreateInPortLVs_18f0" );
#endif
	_system_18f6= &systems_18f5;
	if( ( !systems_18f1.empty())&& ( !systemFunctions_18f3.empty()))
		callGetChildInPorts_1a55( systems_18f1, systemFunctions_18f3);
	_system_18f6->insert( _system_18f6->end(), systems_18f1.begin(), systems_18f1.end());
}

void CreateInPortLVs_18f0::callGetChildInPorts_1a55( const Packets_t& subsystems_1a29, const Packets_t& mains_1a2c)
{
	Packets_t inPorts_1a2b;
	Packets_t mains_1a2e;
	GetChildInPorts_1a28 getChildInPorts_1a28;
	getChildInPorts_1a28( subsystems_1a29, mains_1a2c, inPorts_1a2b, mains_1a2e);
	if( ( !inPorts_1a2b.empty())&& ( !mains_1a2e.empty()))
		callInPortFilter_1a58( inPorts_1a2b, mains_1a2e);
}

void CreateInPortLVs_18f0::callInPortFilter_1a58( const Packets_t& inPorts_1979, const Packets_t& systemFunctions_197b)
{
	Packets_t inPorts_197d;
	Packets_t systemFunctions_197e;
	Packets_t inPorts_197f;
	Packets_t systemFunctions_1980;
	Packets_t inPorts_1981;
	Packets_t systemFunctions_1982;
	InPortFilter_1978 inPortFilter_1978;
	inPortFilter_1978( inPorts_1979, systemFunctions_197b, inPorts_197d, systemFunctions_197e, inPorts_197f, systemFunctions_1980, inPorts_1981, systemFunctions_1982);
	if( ( !inPorts_197f.empty()))
		callGetLocalVars_1a5b( inPorts_197f);
	if( ( !inPorts_197d.empty()))
		callGetInArgs_1a5d( inPorts_197d);
	if( ( !inPorts_1981.empty())&& ( !systemFunctions_1982.empty()))
		callCreateLocalVars_1a5f( inPorts_1981, systemFunctions_1982);
}

void CreateInPortLVs_18f0::callGetLocalVars_1a5b( const Packets_t& inPorts_1915)
{
	GetLocalVars_1914 getLocalVars_1914;
	getLocalVars_1914( inPorts_1915);
}

void CreateInPortLVs_18f0::callGetInArgs_1a5d( const Packets_t& inPorts_192f)
{
	GetInArgs_192e getInArgs_192e;
	getInArgs_192e( inPorts_192f);
}

void CreateInPortLVs_18f0::callCreateLocalVars_1a5f( const Packets_t& inPorts_194c, const Packets_t& mains_194e)
{
	Packets_t localVars_194b;
	Packets_t mains_1950;
	CreateLocalVars_194a createLocalVars_194a;
	createLocalVars_194a( inPorts_194c, mains_194e, localVars_194b, mains_1950);
	if( ( !localVars_194b.empty())&& ( !mains_1950.empty()))
		callZeroInitLocalVars_1a62( localVars_194b, mains_1950);
}

void CreateInPortLVs_18f0::callZeroInitLocalVars_1a62( const Packets_t& localVars_18f8, const Packets_t& mains_18fa)
{
	ZeroInitLocalVars_18f7 zeroInitLocalVars_18f7;
	zeroInitLocalVars_18f7( localVars_18f8, mains_18fa);
}

void ZeroInitLocalVars_18f7::operator()( const Packets_t& localVars_18f8, const Packets_t& mains_18fa)
{
#ifdef PRINT_INFO
	printLog( "ZeroInitLocalVars_18f7" );
#endif
	RTTGenerator::Instance()->generateRule(1369, "ZeroInitLocalVars");
	processInputPackets( localVars_18f8, mains_18fa);
}

bool ZeroInitLocalVars_18f7::isInputUnique( const Udm::Object& localVar_1900, const Udm::Object& main_1909)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itLocalVar_1902= _localVar_18fc.begin(), itMain_190b= _main_1905.begin(); itLocalVar_1902!= _localVar_18fc.end(), itMain_190b!= _main_1905.end(); ++itLocalVar_1902, ++itMain_190b)
	{
		if( ( *itLocalVar_1902== localVar_1900)&& ( *itMain_190b== main_1909))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_localVar_18fc.push_back( localVar_1900);
		_main_1905.push_back( main_1909);
	}
	return isUnique;
}

bool ZeroInitLocalVars_18f7::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void ZeroInitLocalVars_18f7::processInputPackets( const Packets_t& localVars_18f8, const Packets_t& mains_18fa)
{
	for( Packets_t::const_iterator itLocalVar_18fd= localVars_18f8.begin(), itMain_1906= mains_18fa.begin(); itLocalVar_18fd!= localVars_18f8.end(), itMain_1906!= mains_18fa.end(); ++itLocalVar_18fd, ++itMain_1906)
	{
		bool isUnique= isInputUnique( *itLocalVar_18fd, *itMain_1906);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itLocalVar_18fd, *itMain_1906);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ZeroInitLocalVars_18f7::patternMatcher( const Udm::Object& localVar_18fe, const Udm::Object& main_1907)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( localVar_18fe.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_1903= SFC::LocalVar::Cast( localVar_18fe);
		if( false== Uml::IsDerivedFrom( main_1907.type(), SFC::Function::meta))
			continue;
		SFC::Function main_190c= SFC::Function::Cast( main_1907);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1911;
		if( !isValidBound(boundObjs_1911, localVar_1903, true))
			continue;
		currMatch.localVar_1912= localVar_1903;
		if( !isValidBound(boundObjs_1911, main_190c, true))
			continue;
		currMatch.main_1913= main_190c;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void ZeroInitLocalVars_18f7::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar& LocalVar= currMatch.localVar_1912;
		SFC::Function& Main= currMatch.main_1913;
		{
SFUtils::ZeroInit( Main, LocalVar );
};
	}
}

void GetLocalVars_1914::operator()( const Packets_t& inPorts_1915)
{
#ifdef PRINT_INFO
	printLog( "GetLocalVars_1914" );
#endif
	RTTGenerator::Instance()->generateRule(1373, "GetLocalVars");
	processInputPackets( inPorts_1915);
}

bool GetLocalVars_1914::isInputUnique( const Udm::Object& inPort_191b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itInPort_191d= _inPort_1917.begin(); itInPort_191d!= _inPort_1917.end(); ++itInPort_191d)
	{
		if( ( *itInPort_191d== inPort_191b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_inPort_1917.push_back( inPort_191b);
	return isUnique;
}

bool GetLocalVars_1914::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetLocalVars_1914::processInputPackets( const Packets_t& inPorts_1915)
{
	for( Packets_t::const_iterator itInPort_1918= inPorts_1915.begin(); itInPort_1918!= inPorts_1915.end(); ++itInPort_1918)
	{
		bool isUnique= isInputUnique( *itInPort_1918);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itInPort_1918);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetLocalVars_1914::patternMatcher( const Udm::Object& inPort_1919)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( inPort_1919.type(), CyberComposition::Simulink::InPort::meta))
			continue;
		CyberComposition::Simulink::InPort inPort_191e= CyberComposition::Simulink::InPort::Cast( inPort_1919);
		set< CyberComposition::Simulink::Line> lines_1920= inPort_191e.srcLine();
		for( set< CyberComposition::Simulink::Line>::const_iterator itLines_1921= lines_1920.begin(); itLines_1921!= lines_1920.end(); ++itLines_1921)
		{
			CyberComposition::Simulink::Line currLine_1922= *itLines_1921;
			CyberComposition::Simulink::SF_Port outPort_1923= currLine_1922.srcLine_end();
			if( false== Uml::IsDerivedFrom( outPort_1923.type(), CyberComposition::Simulink::OutPort::meta))
				continue;
			CyberComposition::Simulink::OutPort currOutPort_1924= CyberComposition::Simulink::OutPort::Cast( outPort_1923);
			SFC::ArgDeclBase argDeclBase_1925= currOutPort_1924.argdecl();
			if( !argDeclBase_1925)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1929;
			if( !isValidBound(boundObjs_1929, inPort_191e, true))
				continue;
			currMatch.inPort_192a= inPort_191e;
			if( !isValidBound(boundObjs_1929, argDeclBase_1925, false))
				continue;
			currMatch.argDeclBase_192b= argDeclBase_1925;
			if( !isValidBound(boundObjs_1929, currOutPort_1924, false))
				continue;
			currMatch.outPort_192c= currOutPort_1924;
			if( !isValidBound(boundObjs_1929, currLine_1922, false))
				continue;
			currMatch.line_192d= currLine_1922;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetLocalVars_1914::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		currMatch.inPort_192a.argdecl()= currMatch.argDeclBase_192b;
	}
}

void GetInArgs_192e::operator()( const Packets_t& inPorts_192f)
{
#ifdef PRINT_INFO
	printLog( "GetInArgs_192e" );
#endif
	RTTGenerator::Instance()->generateRule(1382, "GetInArgs");
	processInputPackets( inPorts_192f);
}

bool GetInArgs_192e::isInputUnique( const Udm::Object& inPort_1935)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itInPort_1937= _inPort_1931.begin(); itInPort_1937!= _inPort_1931.end(); ++itInPort_1937)
	{
		if( ( *itInPort_1937== inPort_1935))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_inPort_1931.push_back( inPort_1935);
	return isUnique;
}

bool GetInArgs_192e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetInArgs_192e::processInputPackets( const Packets_t& inPorts_192f)
{
	for( Packets_t::const_iterator itInPort_1932= inPorts_192f.begin(); itInPort_1932!= inPorts_192f.end(); ++itInPort_1932)
	{
		bool isUnique= isInputUnique( *itInPort_1932);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itInPort_1932);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetInArgs_192e::patternMatcher( const Udm::Object& inPort_1933)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( inPort_1933.type(), CyberComposition::Simulink::InPort::meta))
			continue;
		CyberComposition::Simulink::InPort inPort_1938= CyberComposition::Simulink::InPort::Cast( inPort_1933);
		set< CyberComposition::Simulink::Line> lines_193a= inPort_1938.srcLine();
		for( set< CyberComposition::Simulink::Line>::const_iterator itLines_193b= lines_193a.begin(); itLines_193b!= lines_193a.end(); ++itLines_193b)
		{
			CyberComposition::Simulink::Line currLine_193c= *itLines_193b;
			CyberComposition::Simulink::SF_Port subsystemInPort_193d= currLine_193c.srcLine_end();
			if( false== Uml::IsDerivedFrom( subsystemInPort_193d.type(), CyberComposition::Simulink::InPort::meta))
				continue;
			CyberComposition::Simulink::InPort currSubsystemInPort_193e= CyberComposition::Simulink::InPort::Cast( subsystemInPort_193d);
			set< SFC::Arg> args_193f= currSubsystemInPort_193e.arg();
			for( set< SFC::Arg>::const_iterator itArgs_1940= args_193f.begin(); itArgs_1940!= args_193f.end(); ++itArgs_1940)
			{
				SFC::Arg currArg_1941= *itArgs_1940;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_1945;
				if( !isValidBound(boundObjs_1945, inPort_1938, true))
					continue;
				currMatch.inPort_1946= inPort_1938;
				if( !isValidBound(boundObjs_1945, currArg_1941, false))
					continue;
				currMatch.arg_1947= currArg_1941;
				if( !isValidBound(boundObjs_1945, currSubsystemInPort_193e, false))
					continue;
				currMatch.subsystemInPort_1948= currSubsystemInPort_193e;
				if( !isValidBound(boundObjs_1945, currLine_193c, false))
					continue;
				currMatch.line_1949= currLine_193c;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetInArgs_192e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		currMatch.inPort_1946.argdecl()= currMatch.arg_1947;
	}
}

void CreateLocalVars_194a::operator()( const Packets_t& inPorts_194c, const Packets_t& mains_194e, Packets_t& localVars_194b, Packets_t& mains_1950)
{
#ifdef PRINT_INFO
	printLog( "CreateLocalVars_194a" );
#endif
	RTTGenerator::Instance()->generateRule(1391, "CreateLocalVars");
	_localVar_1951= &localVars_194b;
	_main_1952= &mains_1950;
	processInputPackets( inPorts_194c, mains_194e);
}

bool CreateLocalVars_194a::isInputUnique( const Udm::Object& inPort_1957, const Udm::Object& main_1960)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itInPort_1959= _inPort_1953.begin(), itMain_1962= _main_195c.begin(); itInPort_1959!= _inPort_1953.end(), itMain_1962!= _main_195c.end(); ++itInPort_1959, ++itMain_1962)
	{
		if( ( *itInPort_1959== inPort_1957)&& ( *itMain_1962== main_1960))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_inPort_1953.push_back( inPort_1957);
		_main_195c.push_back( main_1960);
	}
	return isUnique;
}

bool CreateLocalVars_194a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateLocalVars_194a::processInputPackets( const Packets_t& inPorts_194c, const Packets_t& mains_194e)
{
	for( Packets_t::const_iterator itInPort_1954= inPorts_194c.begin(), itMain_195d= mains_194e.begin(); itInPort_1954!= inPorts_194c.end(), itMain_195d!= mains_194e.end(); ++itInPort_1954, ++itMain_195d)
	{
		bool isUnique= isInputUnique( *itInPort_1954, *itMain_195d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itInPort_1954, *itMain_195d);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateLocalVars_194a::patternMatcher( const Udm::Object& inPort_1955, const Udm::Object& main_195e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( inPort_1955.type(), CyberComposition::Simulink::InPort::meta))
			continue;
		CyberComposition::Simulink::InPort inPort_195a= CyberComposition::Simulink::InPort::Cast( inPort_1955);
		if( false== Uml::IsDerivedFrom( main_195e.type(), SFC::Function::meta))
			continue;
		SFC::Function main_1963= SFC::Function::Cast( main_195e);
		set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_1965= inPort_195a.TypeBaseRef_kind_children();
		for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_1966= typeBaseRefs_1965.begin(); itTypeBaseRef_1966!= typeBaseRefs_1965.end(); ++itTypeBaseRef_1966)
		{
			CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_1967= *itTypeBaseRef_1966;
			CyberComposition::Simulink::SF_TypeBase typeBase_1968= currTypeBaseRef_1967.ref();
			if( !typeBase_1968)
				continue;
			SFC::DT dT_1969= typeBase_1968.dt();
			if( !dT_1969)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_196d;
			if( !isValidBound(boundObjs_196d, inPort_195a, true))
				continue;
			currMatch.inPort_196e= inPort_195a;
			if( !isValidBound(boundObjs_196d, main_1963, true))
				continue;
			currMatch.main_196f= main_1963;
			if( !isValidBound(boundObjs_196d, currTypeBaseRef_1967, false))
				continue;
			currMatch.typeBaseRef_1970= currTypeBaseRef_1967;
			if( !isValidBound(boundObjs_196d, dT_1969, false))
				continue;
			currMatch.dT_1971= dT_1969;
			if( !isValidBound(boundObjs_196d, typeBase_1968, false))
				continue;
			currMatch.typeBase_1972= typeBase_1968;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateLocalVars_194a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newLocalVar_1973= SFC::LocalVar::Create( currMatch.main_196f);
		SFC::DT& DT= currMatch.dT_1971;
		CyberComposition::Simulink::InPort& InPort= currMatch.inPort_196e;
		SFC::LocalVar& LocalVar= newLocalVar_1973;
		SFC::Function& Main= currMatch.main_196f;
		CyberComposition::Simulink::SF_TypeBase& TypeBase= currMatch.typeBase_1972;
		CyberComposition::Simulink::TypeBaseRef& TypeBaseRef= currMatch.typeBaseRef_1970;
		{
__int64 statementCount = Main.statementCount();

LocalVar.name() = (  boost::format( "sig_%1%" ) % statementCount  ).str();
LocalVar.type() = "double";
LocalVar.statementIndex() = statementCount++;

Main.statementCount() = statementCount;
};
		currMatch.inPort_196e.argdecl()= newLocalVar_1973;
		newLocalVar_1973.dt()= currMatch.dT_1971;
		outputAppender( newLocalVar_1973, currMatch.main_196f);
	}
}

void CreateLocalVars_194a::outputAppender( const SFC::LocalVar& localVar_1974, const SFC::Function& main_1976)
{
	_localVar_1951->push_back( localVar_1974);
	_main_1952->push_back( main_1976);
}

void InPortFilter_1978::operator()( const Packets_t& inPorts_1979, const Packets_t& systemFunctions_197b, Packets_t& inPorts_197d, Packets_t& systemFunctions_197e, Packets_t& inPorts_197f, Packets_t& systemFunctions_1980, Packets_t& inPorts_1981, Packets_t& systemFunctions_1982)
{
#ifdef PRINT_INFO
	printLog( "InPortFilter_1978" );
#endif
	_inPort_1983= &inPorts_197d;
	_systemFunction_1984= &systemFunctions_197e;
	_inPort_1985= &inPorts_197f;
	_systemFunction_1986= &systemFunctions_1980;
	_inPort_1987= &inPorts_1981;
	_systemFunction_1988= &systemFunctions_1982;
	if( ( !inPorts_1979.empty())&& ( !systemFunctions_197b.empty()))
		callInPortTest_1a25( inPorts_1979, systemFunctions_197b);
}

void InPortFilter_1978::callInPortTest_1a25( const Packets_t& inPorts_198a, const Packets_t& systemFunctions_198c)
{
	Packets_t inPorts_198e;
	Packets_t systemFunctions_198f;
	Packets_t inPorts_1990;
	Packets_t systemFunctions_1991;
	Packets_t inPorts_1992;
	Packets_t systemFunctions_1993;
	InPortTest_1989 inPortTest_1989;
	inPortTest_1989( inPorts_198a, systemFunctions_198c, inPorts_198e, systemFunctions_198f, inPorts_1990, systemFunctions_1991, inPorts_1992, systemFunctions_1993);
	_inPort_1983->insert( _inPort_1983->end(), inPorts_198e.begin(), inPorts_198e.end());
	_systemFunction_1984->insert( _systemFunction_1984->end(), systemFunctions_198f.begin(), systemFunctions_198f.end());
	_inPort_1985->insert( _inPort_1985->end(), inPorts_1990.begin(), inPorts_1990.end());
	_systemFunction_1986->insert( _systemFunction_1986->end(), systemFunctions_1991.begin(), systemFunctions_1991.end());
	_inPort_1987->insert( _inPort_1987->end(), inPorts_1992.begin(), inPorts_1992.end());
	_systemFunction_1988->insert( _systemFunction_1988->end(), systemFunctions_1993.begin(), systemFunctions_1993.end());
}

void InPortTest_1989::operator()( const Packets_t& inPorts_198a, const Packets_t& systemFunctions_198c, Packets_t& inPorts_198e, Packets_t& systemFunctions_198f, Packets_t& inPorts_1990, Packets_t& systemFunctions_1991, Packets_t& inPorts_1992, Packets_t& systemFunctions_1993)
{
#ifdef PRINT_INFO
	printLog( "InPortTest_1989" );
#endif
	_inPort_1994= &inPorts_198e;
	_systemFunction_1995= &systemFunctions_198f;
	_inPort_1996= &inPorts_1990;
	_systemFunction_1997= &systemFunctions_1991;
	_inPort_1998= &inPorts_1992;
	_systemFunction_1999= &systemFunctions_1993;
	for( Packets_t::const_iterator itinPort_199b= inPorts_198a.begin(), itsystemFunction_19a2= systemFunctions_198c.begin(); itinPort_199b!= inPorts_198a.end(), itsystemFunction_19a2!= systemFunctions_198c.end(); ++itinPort_199b, ++itsystemFunction_19a2)
	{
		bool isUnique= isInputUnique( *itinPort_199b, *itsystemFunction_19a2);
		if( !isUnique)
			continue;
		Packets_t oneinPort_199f( 1, *itinPort_199b);
		Packets_t onesystemFunction_19a6( 1, *itsystemFunction_19a2);
		executeOne( oneinPort_199f, onesystemFunction_19a6);
	}
}

void InPortTest_1989::executeOne( const Packets_t& inPorts_198a, const Packets_t& systemFunctions_198c)
{
	Packets_t inPorts_19ab;
	Packets_t mains_19ae;
	InPort2InPort_19a8 inPort2InPort_19a8;
	bool isMatchInPort2InPort_19a8= inPort2InPort_19a8( inPorts_198a, systemFunctions_198c, inPorts_19ab, mains_19ae);
	_inPort_1994->insert( _inPort_1994->end(), inPorts_19ab.begin(), inPorts_19ab.end());
	_systemFunction_1995->insert( _systemFunction_1995->end(), mains_19ae.begin(), mains_19ae.end());
	if( isMatchInPort2InPort_19a8)
		return;
	Packets_t inPorts_19d7;
	Packets_t mains_19da;
	OutPort2InPort_19d4 outPort2InPort_19d4;
	bool isMatchOutPort2InPort_19d4= outPort2InPort_19d4( inPorts_198a, systemFunctions_198c, inPorts_19d7, mains_19da);
	_inPort_1996->insert( _inPort_1996->end(), inPorts_19d7.begin(), inPorts_19d7.end());
	_systemFunction_1997->insert( _systemFunction_1997->end(), mains_19da.begin(), mains_19da.end());
	if( isMatchOutPort2InPort_19d4)
		return;
	Packets_t inPorts_1a03;
	Packets_t mains_1a06;
	Otherwise_1a00 otherwise_1a00;
	bool isMatchOtherwise_1a00= otherwise_1a00( inPorts_198a, systemFunctions_198c, inPorts_1a03, mains_1a06);
	_inPort_1998->insert( _inPort_1998->end(), inPorts_1a03.begin(), inPorts_1a03.end());
	_systemFunction_1999->insert( _systemFunction_1999->end(), mains_1a06.begin(), mains_1a06.end());
	if( isMatchOtherwise_1a00)
		return;
}

bool InPortTest_1989::isInputUnique( const Udm::Object& inPort_199c, const Udm::Object& systemFunction_19a3)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itinPort_199e= _inPort_199a.begin(), itsystemFunction_19a5= _systemFunction_19a1.begin(); itinPort_199e!= _inPort_199a.end(), itsystemFunction_19a5!= _systemFunction_19a1.end(); ++itinPort_199e, ++itsystemFunction_19a5)
	{
		if( ( *itinPort_199e== inPort_199c)&& ( *itsystemFunction_19a5== systemFunction_19a3))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_inPort_199a.push_back( inPort_199c);
		_systemFunction_19a1.push_back( systemFunction_19a3);
	}
	return isUnique;
}

bool InPort2InPort_19a8::operator()( const Packets_t& inPorts_19a9, const Packets_t& mains_19ac, Packets_t& inPorts_19ab, Packets_t& mains_19ae)
{
#ifdef PRINT_INFO
	printLog( "InPort2InPort_19a8" );
#endif
	_inPort_19af= &inPorts_19ab;
	_main_19b0= &mains_19ae;
	processInputPackets( inPorts_19a9, mains_19ac);
	if( false== _matches.empty())
		return true;
	return false;
}

bool InPort2InPort_19a8::isInputUnique( const Udm::Object& inPort_19b5, const Udm::Object& main_19be)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itInPort_19b7= _inPort_19b1.begin(), itMain_19c0= _main_19ba.begin(); itInPort_19b7!= _inPort_19b1.end(), itMain_19c0!= _main_19ba.end(); ++itInPort_19b7, ++itMain_19c0)
	{
		if( ( *itInPort_19b7== inPort_19b5)&& ( *itMain_19c0== main_19be))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_inPort_19b1.push_back( inPort_19b5);
		_main_19ba.push_back( main_19be);
	}
	return isUnique;
}

bool InPort2InPort_19a8::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void InPort2InPort_19a8::processInputPackets( const Packets_t& inPorts_19a9, const Packets_t& mains_19ac)
{
	for( Packets_t::const_iterator itInPort_19b2= inPorts_19a9.begin(), itMain_19bb= mains_19ac.begin(); itInPort_19b2!= inPorts_19a9.end(), itMain_19bb!= mains_19ac.end(); ++itInPort_19b2, ++itMain_19bb)
	{
		bool isUnique= isInputUnique( *itInPort_19b2, *itMain_19bb);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itInPort_19b2, *itMain_19bb);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.inPort_19cc, currMatch.main_19cd);
	}
}

bool InPort2InPort_19a8::patternMatcher( const Udm::Object& inPort_19b3, const Udm::Object& main_19bc)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( inPort_19b3.type(), CyberComposition::Simulink::InPort::meta))
			continue;
		CyberComposition::Simulink::InPort inPort_19b8= CyberComposition::Simulink::InPort::Cast( inPort_19b3);
		if( false== Uml::IsDerivedFrom( main_19bc.type(), SFC::Function::meta))
			continue;
		SFC::Function main_19c1= SFC::Function::Cast( main_19bc);
		set< CyberComposition::Simulink::Line> lines_19c3= inPort_19b8.srcLine();
		for( set< CyberComposition::Simulink::Line>::const_iterator itLines_19c4= lines_19c3.begin(); itLines_19c4!= lines_19c3.end(); ++itLines_19c4)
		{
			CyberComposition::Simulink::Line currLine_19c5= *itLines_19c4;
			CyberComposition::Simulink::SF_Port subsystemInPort_19c6= currLine_19c5.srcLine_end();
			if( false== Uml::IsDerivedFrom( subsystemInPort_19c6.type(), CyberComposition::Simulink::InPort::meta))
				continue;
			CyberComposition::Simulink::InPort currSubsystemInPort_19c7= CyberComposition::Simulink::InPort::Cast( subsystemInPort_19c6);
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_19cb;
			if( !isValidBound(boundObjs_19cb, inPort_19b8, true))
				continue;
			currMatch.inPort_19cc= inPort_19b8;
			if( !isValidBound(boundObjs_19cb, main_19c1, true))
				continue;
			currMatch.main_19cd= main_19c1;
			if( !isValidBound(boundObjs_19cb, currSubsystemInPort_19c7, false))
				continue;
			currMatch.subsystemInPort_19ce= currSubsystemInPort_19c7;
			if( !isValidBound(boundObjs_19cb, currLine_19c5, false))
				continue;
			currMatch.line_19cf= currLine_19c5;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void InPort2InPort_19a8::outputAppender( const CyberComposition::Simulink::InPort& inPort_19d0, const SFC::Function& main_19d2)
{
	_inPort_19af->push_back( inPort_19d0);
	_main_19b0->push_back( main_19d2);
}

bool OutPort2InPort_19d4::operator()( const Packets_t& inPorts_19d5, const Packets_t& mains_19d8, Packets_t& inPorts_19d7, Packets_t& mains_19da)
{
#ifdef PRINT_INFO
	printLog( "OutPort2InPort_19d4" );
#endif
	_inPort_19db= &inPorts_19d7;
	_main_19dc= &mains_19da;
	processInputPackets( inPorts_19d5, mains_19d8);
	if( false== _matches.empty())
		return true;
	return false;
}

bool OutPort2InPort_19d4::isInputUnique( const Udm::Object& inPort_19e1, const Udm::Object& main_19ea)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itInPort_19e3= _inPort_19dd.begin(), itMain_19ec= _main_19e6.begin(); itInPort_19e3!= _inPort_19dd.end(), itMain_19ec!= _main_19e6.end(); ++itInPort_19e3, ++itMain_19ec)
	{
		if( ( *itInPort_19e3== inPort_19e1)&& ( *itMain_19ec== main_19ea))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_inPort_19dd.push_back( inPort_19e1);
		_main_19e6.push_back( main_19ea);
	}
	return isUnique;
}

bool OutPort2InPort_19d4::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void OutPort2InPort_19d4::processInputPackets( const Packets_t& inPorts_19d5, const Packets_t& mains_19d8)
{
	for( Packets_t::const_iterator itInPort_19de= inPorts_19d5.begin(), itMain_19e7= mains_19d8.begin(); itInPort_19de!= inPorts_19d5.end(), itMain_19e7!= mains_19d8.end(); ++itInPort_19de, ++itMain_19e7)
	{
		bool isUnique= isInputUnique( *itInPort_19de, *itMain_19e7);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itInPort_19de, *itMain_19e7);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.inPort_19f8, currMatch.main_19f9);
	}
}

bool OutPort2InPort_19d4::patternMatcher( const Udm::Object& inPort_19df, const Udm::Object& main_19e8)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( inPort_19df.type(), CyberComposition::Simulink::InPort::meta))
			continue;
		CyberComposition::Simulink::InPort inPort_19e4= CyberComposition::Simulink::InPort::Cast( inPort_19df);
		if( false== Uml::IsDerivedFrom( main_19e8.type(), SFC::Function::meta))
			continue;
		SFC::Function main_19ed= SFC::Function::Cast( main_19e8);
		set< CyberComposition::Simulink::Line> lines_19ef= inPort_19e4.srcLine();
		for( set< CyberComposition::Simulink::Line>::const_iterator itLines_19f0= lines_19ef.begin(); itLines_19f0!= lines_19ef.end(); ++itLines_19f0)
		{
			CyberComposition::Simulink::Line currLine_19f1= *itLines_19f0;
			CyberComposition::Simulink::SF_Port outPort_19f2= currLine_19f1.srcLine_end();
			if( false== Uml::IsDerivedFrom( outPort_19f2.type(), CyberComposition::Simulink::OutPort::meta))
				continue;
			CyberComposition::Simulink::OutPort currOutPort_19f3= CyberComposition::Simulink::OutPort::Cast( outPort_19f2);
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_19f7;
			if( !isValidBound(boundObjs_19f7, inPort_19e4, true))
				continue;
			currMatch.inPort_19f8= inPort_19e4;
			if( !isValidBound(boundObjs_19f7, main_19ed, true))
				continue;
			currMatch.main_19f9= main_19ed;
			if( !isValidBound(boundObjs_19f7, currOutPort_19f3, false))
				continue;
			currMatch.outPort_19fa= currOutPort_19f3;
			if( !isValidBound(boundObjs_19f7, currLine_19f1, false))
				continue;
			currMatch.line_19fb= currLine_19f1;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void OutPort2InPort_19d4::outputAppender( const CyberComposition::Simulink::InPort& inPort_19fc, const SFC::Function& main_19fe)
{
	_inPort_19db->push_back( inPort_19fc);
	_main_19dc->push_back( main_19fe);
}

bool Otherwise_1a00::operator()( const Packets_t& inPorts_1a01, const Packets_t& mains_1a04, Packets_t& inPorts_1a03, Packets_t& mains_1a06)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_1a00" );
#endif
	_inPort_1a07= &inPorts_1a03;
	_main_1a08= &mains_1a06;
	processInputPackets( inPorts_1a01, mains_1a04);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_1a00::isInputUnique( const Udm::Object& inPort_1a0d, const Udm::Object& main_1a16)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itInPort_1a0f= _inPort_1a09.begin(), itMain_1a18= _main_1a12.begin(); itInPort_1a0f!= _inPort_1a09.end(), itMain_1a18!= _main_1a12.end(); ++itInPort_1a0f, ++itMain_1a18)
	{
		if( ( *itInPort_1a0f== inPort_1a0d)&& ( *itMain_1a18== main_1a16))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_inPort_1a09.push_back( inPort_1a0d);
		_main_1a12.push_back( main_1a16);
	}
	return isUnique;
}

bool Otherwise_1a00::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_1a00::processInputPackets( const Packets_t& inPorts_1a01, const Packets_t& mains_1a04)
{
	for( Packets_t::const_iterator itInPort_1a0a= inPorts_1a01.begin(), itMain_1a13= mains_1a04.begin(); itInPort_1a0a!= inPorts_1a01.end(), itMain_1a13!= mains_1a04.end(); ++itInPort_1a0a, ++itMain_1a13)
	{
		bool isUnique= isInputUnique( *itInPort_1a0a, *itMain_1a13);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itInPort_1a0a, *itMain_1a13);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.inPort_1a1f, currMatch.main_1a20);
	}
}

bool Otherwise_1a00::patternMatcher( const Udm::Object& inPort_1a0b, const Udm::Object& main_1a14)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( inPort_1a0b.type(), CyberComposition::Simulink::InPort::meta))
			continue;
		CyberComposition::Simulink::InPort inPort_1a10= CyberComposition::Simulink::InPort::Cast( inPort_1a0b);
		if( false== Uml::IsDerivedFrom( main_1a14.type(), SFC::Function::meta))
			continue;
		SFC::Function main_1a19= SFC::Function::Cast( main_1a14);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1a1e;
		if( !isValidBound(boundObjs_1a1e, inPort_1a10, true))
			continue;
		currMatch.inPort_1a1f= inPort_1a10;
		if( !isValidBound(boundObjs_1a1e, main_1a19, true))
			continue;
		currMatch.main_1a20= main_1a19;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_1a00::outputAppender( const CyberComposition::Simulink::InPort& inPort_1a21, const SFC::Function& main_1a23)
{
	_inPort_1a07->push_back( inPort_1a21);
	_main_1a08->push_back( main_1a23);
}

void GetChildInPorts_1a28::operator()( const Packets_t& subsystems_1a29, const Packets_t& mains_1a2c, Packets_t& inPorts_1a2b, Packets_t& mains_1a2e)
{
#ifdef PRINT_INFO
	printLog( "GetChildInPorts_1a28" );
#endif
	RTTGenerator::Instance()->generateRule(1440, "GetChildInPorts");
	_inPort_1a2f= &inPorts_1a2b;
	_main_1a30= &mains_1a2e;
	processInputPackets( subsystems_1a29, mains_1a2c);
}

bool GetChildInPorts_1a28::isInputUnique( const Udm::Object& subsystem_1a35, const Udm::Object& main_1a3e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1a37= _subsystem_1a31.begin(), itMain_1a40= _main_1a3a.begin(); itSubsystem_1a37!= _subsystem_1a31.end(), itMain_1a40!= _main_1a3a.end(); ++itSubsystem_1a37, ++itMain_1a40)
	{
		if( ( *itSubsystem_1a37== subsystem_1a35)&& ( *itMain_1a40== main_1a3e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1a31.push_back( subsystem_1a35);
		_main_1a3a.push_back( main_1a3e);
	}
	return isUnique;
}

bool GetChildInPorts_1a28::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetChildInPorts_1a28::processInputPackets( const Packets_t& subsystems_1a29, const Packets_t& mains_1a2c)
{
	for( Packets_t::const_iterator itSubsystem_1a32= subsystems_1a29.begin(), itMain_1a3b= mains_1a2c.begin(); itSubsystem_1a32!= subsystems_1a29.end(), itMain_1a3b!= mains_1a2c.end(); ++itSubsystem_1a32, ++itMain_1a3b)
	{
		bool isUnique= isInputUnique( *itSubsystem_1a32, *itMain_1a3b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1a32, *itMain_1a3b);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetChildInPorts_1a28::patternMatcher( const Udm::Object& subsystem_1a33, const Udm::Object& main_1a3c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1a33.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1a38= CyberComposition::Simulink::Subsystem::Cast( subsystem_1a33);
		if( false== Uml::IsDerivedFrom( main_1a3c.type(), SFC::Function::meta))
			continue;
		SFC::Function main_1a41= SFC::Function::Cast( main_1a3c);
		set< CyberComposition::Simulink::Block> blocks_1a43= subsystem_1a38.Block_kind_children();
		for( set< CyberComposition::Simulink::Block>::const_iterator itBlock_1a44= blocks_1a43.begin(); itBlock_1a44!= blocks_1a43.end(); ++itBlock_1a44)
		{
			CyberComposition::Simulink::Block currBlock_1a45= *itBlock_1a44;
			set< CyberComposition::Simulink::InPort> inPorts_1a46= currBlock_1a45.InPort_kind_children();
			for( set< CyberComposition::Simulink::InPort>::const_iterator itInPort_1a47= inPorts_1a46.begin(); itInPort_1a47!= inPorts_1a46.end(); ++itInPort_1a47)
			{
				CyberComposition::Simulink::InPort currInPort_1a48= *itInPort_1a47;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_1a4c;
				if( !isValidBound(boundObjs_1a4c, subsystem_1a38, true))
					continue;
				currMatch.subsystem_1a4d= subsystem_1a38;
				if( !isValidBound(boundObjs_1a4c, main_1a41, true))
					continue;
				currMatch.main_1a4e= main_1a41;
				if( !isValidBound(boundObjs_1a4c, currBlock_1a45, false))
					continue;
				currMatch.block_1a4f= currBlock_1a45;
				if( !isValidBound(boundObjs_1a4c, currInPort_1a48, false))
					continue;
				currMatch.inPort_1a50= currInPort_1a48;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetChildInPorts_1a28::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.inPort_1a50, currMatch.main_1a4e);
	}
}

void GetChildInPorts_1a28::outputAppender( const CyberComposition::Simulink::InPort& inPort_1a51, const SFC::Function& main_1a53)
{
	_inPort_1a2f->push_back( inPort_1a51);
	_main_1a30->push_back( main_1a53);
}

void CreateOutPortLVs_1a65::operator()( const Packets_t& systems_1a66, const Packets_t& systemFunctions_1a68, Packets_t& systems_1a6a, Packets_t& systemFunctions_1a6b)
{
#ifdef PRINT_INFO
	printLog( "CreateOutPortLVs_1a65" );
#endif
	_system_1a6c= &systems_1a6a;
	_systemFunction_1a6d= &systemFunctions_1a6b;
	_system_1a6c->insert( _system_1a6c->end(), systems_1a66.begin(), systems_1a66.end());
	_systemFunction_1a6d->insert( _systemFunction_1a6d->end(), systemFunctions_1a68.begin(), systemFunctions_1a68.end());
	if( ( !systems_1a66.empty())&& ( !systemFunctions_1a68.empty()))
		callGetChildOutPorts_1c04( systems_1a66, systemFunctions_1a68);
}

void CreateOutPortLVs_1a65::callGetChildOutPorts_1c04( const Packets_t& subsystems_1b5c, const Packets_t& mains_1b5f)
{
	Packets_t outPorts_1b5e;
	Packets_t mains_1b61;
	GetChildOutPorts_1b5b getChildOutPorts_1b5b;
	getChildOutPorts_1b5b( subsystems_1b5c, mains_1b5f, outPorts_1b5e, mains_1b61);
	if( ( !outPorts_1b5e.empty())&& ( !mains_1b61.empty()))
		callOutPortFilter_1c07( outPorts_1b5e, mains_1b61);
}

void CreateOutPortLVs_1a65::callOutPortFilter_1c07( const Packets_t& outPorts_1b89, const Packets_t& systemFunctions_1b8b)
{
	Packets_t outPorts_1b8d;
	Packets_t systemFunctions_1b8e;
	Packets_t outPorts_1b8f;
	Packets_t systemFunctions_1b90;
	OutPortFilter_1b88 outPortFilter_1b88;
	outPortFilter_1b88( outPorts_1b89, systemFunctions_1b8b, outPorts_1b8d, systemFunctions_1b8e, outPorts_1b8f, systemFunctions_1b90);
	if( ( !outPorts_1b8d.empty()))
		callGetOutArgs_1c0a( outPorts_1b8d);
	if( ( !outPorts_1b8f.empty())&& ( !systemFunctions_1b90.empty()))
		callCreateLocalVars_1c0c( outPorts_1b8f, systemFunctions_1b90);
}

void CreateOutPortLVs_1a65::callGetOutArgs_1c0a( const Packets_t& outPorts_1a70)
{
	Packets_t subsystemOutPorts_1a6f;
	Packets_t outPorts_1a72;
	GetOutArgs_1a6e getOutArgs_1a6e;
	getOutArgs_1a6e( outPorts_1a70, subsystemOutPorts_1a6f, outPorts_1a72);
	if( ( !subsystemOutPorts_1a6f.empty())&& ( !outPorts_1a72.empty()))
		callBindToArg_1c0f( subsystemOutPorts_1a6f, outPorts_1a72);
}

void CreateOutPortLVs_1a65::callCreateLocalVars_1c0c( const Packets_t& outPorts_1b36, const Packets_t& mains_1b38)
{
	CreateLocalVars_1b35 createLocalVars_1b35;
	createLocalVars_1b35( outPorts_1b36, mains_1b38);
}

void CreateOutPortLVs_1a65::callBindToArg_1c0f( const Packets_t& systemOutPorts_1a8f, const Packets_t& outPorts_1a91)
{
	BindToArg_1a8e bindToArg_1a8e;
	bindToArg_1a8e( systemOutPorts_1a8f, outPorts_1a91);
}

void GetOutArgs_1a6e::operator()( const Packets_t& outPorts_1a70, Packets_t& subsystemOutPorts_1a6f, Packets_t& outPorts_1a72)
{
#ifdef PRINT_INFO
	printLog( "GetOutArgs_1a6e" );
#endif
	RTTGenerator::Instance()->generateRule(1452, "GetOutArgs");
	_subsystemOutPort_1a73= &subsystemOutPorts_1a6f;
	_outPort_1a74= &outPorts_1a72;
	processInputPackets( outPorts_1a70);
	sortOutputs( );
}

bool GetOutArgs_1a6e::isInputUnique( const Udm::Object& outPort_1a79)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itOutPort_1a7b= _outPort_1a75.begin(); itOutPort_1a7b!= _outPort_1a75.end(); ++itOutPort_1a7b)
	{
		if( ( *itOutPort_1a7b== outPort_1a79))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_outPort_1a75.push_back( outPort_1a79);
	return isUnique;
}

bool GetOutArgs_1a6e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetOutArgs_1a6e::processInputPackets( const Packets_t& outPorts_1a70)
{
	for( Packets_t::const_iterator itOutPort_1a76= outPorts_1a70.begin(); itOutPort_1a76!= outPorts_1a70.end(); ++itOutPort_1a76)
	{
		bool isUnique= isInputUnique( *itOutPort_1a76);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itOutPort_1a76);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetOutArgs_1a6e::patternMatcher( const Udm::Object& outPort_1a77)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( outPort_1a77.type(), CyberComposition::Simulink::OutPort::meta))
			continue;
		CyberComposition::Simulink::OutPort outPort_1a7c= CyberComposition::Simulink::OutPort::Cast( outPort_1a77);
		set< CyberComposition::Simulink::Line> lines_1a7e= outPort_1a7c.dstLine();
		for( set< CyberComposition::Simulink::Line>::const_iterator itLines_1a7f= lines_1a7e.begin(); itLines_1a7f!= lines_1a7e.end(); ++itLines_1a7f)
		{
			CyberComposition::Simulink::Line currLine_1a80= *itLines_1a7f;
			CyberComposition::Simulink::SF_Port subsystemOutPort_1a81= currLine_1a80.dstLine_end();
			if( false== Uml::IsDerivedFrom( subsystemOutPort_1a81.type(), CyberComposition::Simulink::OutPort::meta))
				continue;
			CyberComposition::Simulink::OutPort currSubsystemOutPort_1a82= CyberComposition::Simulink::OutPort::Cast( subsystemOutPort_1a81);
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1a86;
			if( !isValidBound(boundObjs_1a86, outPort_1a7c, true))
				continue;
			currMatch.outPort_1a87= outPort_1a7c;
			if( !isValidBound(boundObjs_1a86, currSubsystemOutPort_1a82, false))
				continue;
			currMatch.subsystemOutPort_1a88= currSubsystemOutPort_1a82;
			if( !isValidBound(boundObjs_1a86, currLine_1a80, false))
				continue;
			currMatch.line_1a89= currLine_1a80;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetOutArgs_1a6e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystemOutPort_1a88, currMatch.outPort_1a87);
	}
}

void GetOutArgs_1a6e::outputAppender( const CyberComposition::Simulink::OutPort& subsystemOutPort_1a8a, const CyberComposition::Simulink::OutPort& outPort_1a8c)
{
	_subsystemOutPort_1a73->push_back( subsystemOutPort_1a8a);
	_outPort_1a74->push_back( outPort_1a8c);
}

void GetOutArgs_1a6e::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::OutPort, std::pointer_to_binary_function< const CyberComposition::Simulink::OutPort&, const CyberComposition::Simulink::OutPort&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::OutPort&, const CyberComposition::Simulink::OutPort&, bool> ptr_UniqueIdSort( UniqueIdSort< CyberComposition::Simulink::OutPort>);
	SortedSet_t sortedSet( ptr_UniqueIdSort);
	std::vector< int> permutationVector( _subsystemOutPort_1a73->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _subsystemOutPort_1a73->begin(); it!= _subsystemOutPort_1a73->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::OutPort::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _subsystemOutPort_1a73->begin());
	// order rest of the containers
	permutate( permutationVector, *_outPort_1a74);
}

void BindToArg_1a8e::operator()( const Packets_t& systemOutPorts_1a8f, const Packets_t& outPorts_1a91)
{
#ifdef PRINT_INFO
	printLog( "BindToArg_1a8e" );
#endif
	for( Packets_t::const_iterator itsystemOutPort_1a94= systemOutPorts_1a8f.begin(), itoutPort_1a9b= outPorts_1a91.begin(); itsystemOutPort_1a94!= systemOutPorts_1a8f.end(), itoutPort_1a9b!= outPorts_1a91.end(); ++itsystemOutPort_1a94, ++itoutPort_1a9b)
	{
		bool isUnique= isInputUnique( *itsystemOutPort_1a94, *itoutPort_1a9b);
		if( !isUnique)
			continue;
		Packets_t onesystemOutPort_1a98( 1, *itsystemOutPort_1a94);
		Packets_t oneoutPort_1a9f( 1, *itoutPort_1a9b);
		executeOne( onesystemOutPort_1a98, oneoutPort_1a9f);
	}
}

void BindToArg_1a8e::executeOne( const Packets_t& systemOutPorts_1a8f, const Packets_t& outPorts_1a91)
{
	if( ( !systemOutPorts_1a8f.empty())&& ( !outPorts_1a91.empty()))
		callOutputArgTest_1b2f( systemOutPorts_1a8f, outPorts_1a91);
}

bool BindToArg_1a8e::isInputUnique( const Udm::Object& systemOutPort_1a95, const Udm::Object& outPort_1a9c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itsystemOutPort_1a97= _systemOutPort_1a93.begin(), itoutPort_1a9e= _outPort_1a9a.begin(); itsystemOutPort_1a97!= _systemOutPort_1a93.end(), itoutPort_1a9e!= _outPort_1a9a.end(); ++itsystemOutPort_1a97, ++itoutPort_1a9e)
	{
		if( ( *itsystemOutPort_1a97== systemOutPort_1a95)&& ( *itoutPort_1a9e== outPort_1a9c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_systemOutPort_1a93.push_back( systemOutPort_1a95);
		_outPort_1a9a.push_back( outPort_1a9c);
	}
	return isUnique;
}

void BindToArg_1a8e::callOutputArgTest_1b2f( const Packets_t& systemOutPorts_1ac9, const Packets_t& outPorts_1acb)
{
	Packets_t systemOutPorts_1acd;
	Packets_t outPorts_1ace;
	Packets_t systemOutPorts_1acf;
	Packets_t outPorts_1ad0;
	OutputArgTest_1ac8 outputArgTest_1ac8;
	outputArgTest_1ac8( systemOutPorts_1ac9, outPorts_1acb, systemOutPorts_1acd, outPorts_1ace, systemOutPorts_1acf, outPorts_1ad0);
	if( ( !systemOutPorts_1acf.empty())&& ( !outPorts_1ad0.empty()))
		callBindToArg_1b32( systemOutPorts_1acf, outPorts_1ad0);
}

void BindToArg_1a8e::callBindToArg_1b32( const Packets_t& subsystemOutPorts_1aa2, const Packets_t& outPorts_1aa4)
{
	BindToArg_1aa1 bindToArg_1aa1;
	bindToArg_1aa1( subsystemOutPorts_1aa2, outPorts_1aa4);
}

void BindToArg_1aa1::operator()( const Packets_t& subsystemOutPorts_1aa2, const Packets_t& outPorts_1aa4)
{
#ifdef PRINT_INFO
	printLog( "BindToArg_1aa1" );
#endif
	RTTGenerator::Instance()->generateRule(1461, "BindToArg");
	processInputPackets( subsystemOutPorts_1aa2, outPorts_1aa4);
}

bool BindToArg_1aa1::isInputUnique( const Udm::Object& subsystemOutPort_1aaa, const Udm::Object& outPort_1ab3)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystemOutPort_1aac= _subsystemOutPort_1aa6.begin(), itOutPort_1ab5= _outPort_1aaf.begin(); itSubsystemOutPort_1aac!= _subsystemOutPort_1aa6.end(), itOutPort_1ab5!= _outPort_1aaf.end(); ++itSubsystemOutPort_1aac, ++itOutPort_1ab5)
	{
		if( ( *itSubsystemOutPort_1aac== subsystemOutPort_1aaa)&& ( *itOutPort_1ab5== outPort_1ab3))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystemOutPort_1aa6.push_back( subsystemOutPort_1aaa);
		_outPort_1aaf.push_back( outPort_1ab3);
	}
	return isUnique;
}

bool BindToArg_1aa1::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void BindToArg_1aa1::processInputPackets( const Packets_t& subsystemOutPorts_1aa2, const Packets_t& outPorts_1aa4)
{
	for( Packets_t::const_iterator itSubsystemOutPort_1aa7= subsystemOutPorts_1aa2.begin(), itOutPort_1ab0= outPorts_1aa4.begin(); itSubsystemOutPort_1aa7!= subsystemOutPorts_1aa2.end(), itOutPort_1ab0!= outPorts_1aa4.end(); ++itSubsystemOutPort_1aa7, ++itOutPort_1ab0)
	{
		bool isUnique= isInputUnique( *itSubsystemOutPort_1aa7, *itOutPort_1ab0);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystemOutPort_1aa7, *itOutPort_1ab0);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool BindToArg_1aa1::patternMatcher( const Udm::Object& subsystemOutPort_1aa8, const Udm::Object& outPort_1ab1)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystemOutPort_1aa8.type(), CyberComposition::Simulink::OutPort::meta))
			continue;
		CyberComposition::Simulink::OutPort subsystemOutPort_1aad= CyberComposition::Simulink::OutPort::Cast( subsystemOutPort_1aa8);
		if( false== Uml::IsDerivedFrom( outPort_1ab1.type(), CyberComposition::Simulink::OutPort::meta))
			continue;
		CyberComposition::Simulink::OutPort outPort_1ab6= CyberComposition::Simulink::OutPort::Cast( outPort_1ab1);
		set< SFC::Arg> args_1ab8= subsystemOutPort_1aad.arg();
		for( set< SFC::Arg>::const_iterator itArgs_1ab9= args_1ab8.begin(); itArgs_1ab9!= args_1ab8.end(); ++itArgs_1ab9)
		{
			SFC::Arg currArg_1aba= *itArgs_1ab9;
			set< CyberComposition::Simulink::Line> lines_1abb= outPort_1ab6.dstLine();
			for( set< CyberComposition::Simulink::Line>::const_iterator itLines_1abc= lines_1abb.begin(); itLines_1abc!= lines_1abb.end(); ++itLines_1abc)
			{
				CyberComposition::Simulink::Line currLine_1abd= *itLines_1abc;
				CyberComposition::Simulink::SF_Port subsystemOutPort_1abe= currLine_1abd.dstLine_end();
				if( false== Uml::IsDerivedFrom( subsystemOutPort_1abe.type(), CyberComposition::Simulink::OutPort::meta))
					continue;
				CyberComposition::Simulink::OutPort currSubsystemOutPort_1abf= CyberComposition::Simulink::OutPort::Cast( subsystemOutPort_1abe);
				if( subsystemOutPort_1aad!= currSubsystemOutPort_1abf)
					continue;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_1ac3;
				if( !isValidBound(boundObjs_1ac3, subsystemOutPort_1aad, true))
					continue;
				currMatch.subsystemOutPort_1ac4= subsystemOutPort_1aad;
				if( !isValidBound(boundObjs_1ac3, outPort_1ab6, true))
					continue;
				currMatch.outPort_1ac5= outPort_1ab6;
				if( !isValidBound(boundObjs_1ac3, currArg_1aba, false))
					continue;
				currMatch.arg_1ac6= currArg_1aba;
				if( !isValidBound(boundObjs_1ac3, currLine_1abd, false))
					continue;
				currMatch.line_1ac7= currLine_1abd;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void BindToArg_1aa1::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		currMatch.outPort_1ac5.argdecl()= currMatch.arg_1ac6;
	}
}

void OutputArgTest_1ac8::operator()( const Packets_t& systemOutPorts_1ac9, const Packets_t& outPorts_1acb, Packets_t& systemOutPorts_1acd, Packets_t& outPorts_1ace, Packets_t& systemOutPorts_1acf, Packets_t& outPorts_1ad0)
{
#ifdef PRINT_INFO
	printLog( "OutputArgTest_1ac8" );
#endif
	_systemOutPort_1ad1= &systemOutPorts_1acd;
	_outPort_1ad2= &outPorts_1ace;
	_systemOutPort_1ad3= &systemOutPorts_1acf;
	_outPort_1ad4= &outPorts_1ad0;
	for( Packets_t::const_iterator itsystemOutPort_1ad6= systemOutPorts_1ac9.begin(), itoutPort_1add= outPorts_1acb.begin(); itsystemOutPort_1ad6!= systemOutPorts_1ac9.end(), itoutPort_1add!= outPorts_1acb.end(); ++itsystemOutPort_1ad6, ++itoutPort_1add)
	{
		bool isUnique= isInputUnique( *itsystemOutPort_1ad6, *itoutPort_1add);
		if( !isUnique)
			continue;
		Packets_t onesystemOutPort_1ada( 1, *itsystemOutPort_1ad6);
		Packets_t oneoutPort_1ae1( 1, *itoutPort_1add);
		executeOne( onesystemOutPort_1ada, oneoutPort_1ae1);
	}
}

void OutputArgTest_1ac8::executeOne( const Packets_t& systemOutPorts_1ac9, const Packets_t& outPorts_1acb)
{
	Packets_t subsystemOutPorts_1ae6;
	Packets_t outPorts_1ae9;
	OutPortArg_1ae3 outPortArg_1ae3;
	bool isMatchOutPortArg_1ae3= outPortArg_1ae3( systemOutPorts_1ac9, outPorts_1acb, subsystemOutPorts_1ae6, outPorts_1ae9);
	_systemOutPort_1ad1->insert( _systemOutPort_1ad1->end(), subsystemOutPorts_1ae6.begin(), subsystemOutPorts_1ae6.end());
	_outPort_1ad2->insert( _outPort_1ad2->end(), outPorts_1ae9.begin(), outPorts_1ae9.end());
	if( isMatchOutPortArg_1ae3)
		return;
	Packets_t subsystemOutPorts_1b0d;
	Packets_t outPorts_1b10;
	Otherwise_1b0a otherwise_1b0a;
	bool isMatchOtherwise_1b0a= otherwise_1b0a( systemOutPorts_1ac9, outPorts_1acb, subsystemOutPorts_1b0d, outPorts_1b10);
	_systemOutPort_1ad3->insert( _systemOutPort_1ad3->end(), subsystemOutPorts_1b0d.begin(), subsystemOutPorts_1b0d.end());
	_outPort_1ad4->insert( _outPort_1ad4->end(), outPorts_1b10.begin(), outPorts_1b10.end());
	if( isMatchOtherwise_1b0a)
		return;
}

bool OutputArgTest_1ac8::isInputUnique( const Udm::Object& systemOutPort_1ad7, const Udm::Object& outPort_1ade)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itsystemOutPort_1ad9= _systemOutPort_1ad5.begin(), itoutPort_1ae0= _outPort_1adc.begin(); itsystemOutPort_1ad9!= _systemOutPort_1ad5.end(), itoutPort_1ae0!= _outPort_1adc.end(); ++itsystemOutPort_1ad9, ++itoutPort_1ae0)
	{
		if( ( *itsystemOutPort_1ad9== systemOutPort_1ad7)&& ( *itoutPort_1ae0== outPort_1ade))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_systemOutPort_1ad5.push_back( systemOutPort_1ad7);
		_outPort_1adc.push_back( outPort_1ade);
	}
	return isUnique;
}

bool OutPortArg_1ae3::operator()( const Packets_t& subsystemOutPorts_1ae4, const Packets_t& outPorts_1ae7, Packets_t& subsystemOutPorts_1ae6, Packets_t& outPorts_1ae9)
{
#ifdef PRINT_INFO
	printLog( "OutPortArg_1ae3" );
#endif
	_subsystemOutPort_1aea= &subsystemOutPorts_1ae6;
	_outPort_1aeb= &outPorts_1ae9;
	processInputPackets( subsystemOutPorts_1ae4, outPorts_1ae7);
	if( false== _matches.empty())
		return true;
	return false;
}

bool OutPortArg_1ae3::isInputUnique( const Udm::Object& subsystemOutPort_1af0, const Udm::Object& outPort_1af9)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystemOutPort_1af2= _subsystemOutPort_1aec.begin(), itOutPort_1afb= _outPort_1af5.begin(); itSubsystemOutPort_1af2!= _subsystemOutPort_1aec.end(), itOutPort_1afb!= _outPort_1af5.end(); ++itSubsystemOutPort_1af2, ++itOutPort_1afb)
	{
		if( ( *itSubsystemOutPort_1af2== subsystemOutPort_1af0)&& ( *itOutPort_1afb== outPort_1af9))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystemOutPort_1aec.push_back( subsystemOutPort_1af0);
		_outPort_1af5.push_back( outPort_1af9);
	}
	return isUnique;
}

bool OutPortArg_1ae3::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void OutPortArg_1ae3::processInputPackets( const Packets_t& subsystemOutPorts_1ae4, const Packets_t& outPorts_1ae7)
{
	for( Packets_t::const_iterator itSubsystemOutPort_1aed= subsystemOutPorts_1ae4.begin(), itOutPort_1af6= outPorts_1ae7.begin(); itSubsystemOutPort_1aed!= subsystemOutPorts_1ae4.end(), itOutPort_1af6!= outPorts_1ae7.end(); ++itSubsystemOutPort_1aed, ++itOutPort_1af6)
	{
		bool isUnique= isInputUnique( *itSubsystemOutPort_1aed, *itOutPort_1af6);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystemOutPort_1aed, *itOutPort_1af6);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystemOutPort_1b03, currMatch.outPort_1b04);
	}
}

bool OutPortArg_1ae3::patternMatcher( const Udm::Object& subsystemOutPort_1aee, const Udm::Object& outPort_1af7)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystemOutPort_1aee.type(), CyberComposition::Simulink::OutPort::meta))
			continue;
		CyberComposition::Simulink::OutPort subsystemOutPort_1af3= CyberComposition::Simulink::OutPort::Cast( subsystemOutPort_1aee);
		if( false== Uml::IsDerivedFrom( outPort_1af7.type(), CyberComposition::Simulink::OutPort::meta))
			continue;
		CyberComposition::Simulink::OutPort outPort_1afc= CyberComposition::Simulink::OutPort::Cast( outPort_1af7);
		SFC::ArgDeclBase argDeclBase_1afe= outPort_1afc.argdecl();
		if( !argDeclBase_1afe)
			continue;
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1b02;
		if( !isValidBound(boundObjs_1b02, subsystemOutPort_1af3, true))
			continue;
		currMatch.subsystemOutPort_1b03= subsystemOutPort_1af3;
		if( !isValidBound(boundObjs_1b02, outPort_1afc, true))
			continue;
		currMatch.outPort_1b04= outPort_1afc;
		if( !isValidBound(boundObjs_1b02, argDeclBase_1afe, false))
			continue;
		currMatch.argDeclBase_1b05= argDeclBase_1afe;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void OutPortArg_1ae3::outputAppender( const CyberComposition::Simulink::OutPort& subsystemOutPort_1b06, const CyberComposition::Simulink::OutPort& outPort_1b08)
{
	_subsystemOutPort_1aea->push_back( subsystemOutPort_1b06);
	_outPort_1aeb->push_back( outPort_1b08);
}

bool Otherwise_1b0a::operator()( const Packets_t& subsystemOutPorts_1b0b, const Packets_t& outPorts_1b0e, Packets_t& subsystemOutPorts_1b0d, Packets_t& outPorts_1b10)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_1b0a" );
#endif
	_subsystemOutPort_1b11= &subsystemOutPorts_1b0d;
	_outPort_1b12= &outPorts_1b10;
	processInputPackets( subsystemOutPorts_1b0b, outPorts_1b0e);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_1b0a::isInputUnique( const Udm::Object& subsystemOutPort_1b17, const Udm::Object& outPort_1b20)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystemOutPort_1b19= _subsystemOutPort_1b13.begin(), itOutPort_1b22= _outPort_1b1c.begin(); itSubsystemOutPort_1b19!= _subsystemOutPort_1b13.end(), itOutPort_1b22!= _outPort_1b1c.end(); ++itSubsystemOutPort_1b19, ++itOutPort_1b22)
	{
		if( ( *itSubsystemOutPort_1b19== subsystemOutPort_1b17)&& ( *itOutPort_1b22== outPort_1b20))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystemOutPort_1b13.push_back( subsystemOutPort_1b17);
		_outPort_1b1c.push_back( outPort_1b20);
	}
	return isUnique;
}

bool Otherwise_1b0a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_1b0a::processInputPackets( const Packets_t& subsystemOutPorts_1b0b, const Packets_t& outPorts_1b0e)
{
	for( Packets_t::const_iterator itSubsystemOutPort_1b14= subsystemOutPorts_1b0b.begin(), itOutPort_1b1d= outPorts_1b0e.begin(); itSubsystemOutPort_1b14!= subsystemOutPorts_1b0b.end(), itOutPort_1b1d!= outPorts_1b0e.end(); ++itSubsystemOutPort_1b14, ++itOutPort_1b1d)
	{
		bool isUnique= isInputUnique( *itSubsystemOutPort_1b14, *itOutPort_1b1d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystemOutPort_1b14, *itOutPort_1b1d);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystemOutPort_1b29, currMatch.outPort_1b2a);
	}
}

bool Otherwise_1b0a::patternMatcher( const Udm::Object& subsystemOutPort_1b15, const Udm::Object& outPort_1b1e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystemOutPort_1b15.type(), CyberComposition::Simulink::OutPort::meta))
			continue;
		CyberComposition::Simulink::OutPort subsystemOutPort_1b1a= CyberComposition::Simulink::OutPort::Cast( subsystemOutPort_1b15);
		if( false== Uml::IsDerivedFrom( outPort_1b1e.type(), CyberComposition::Simulink::OutPort::meta))
			continue;
		CyberComposition::Simulink::OutPort outPort_1b23= CyberComposition::Simulink::OutPort::Cast( outPort_1b1e);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1b28;
		if( !isValidBound(boundObjs_1b28, subsystemOutPort_1b1a, true))
			continue;
		currMatch.subsystemOutPort_1b29= subsystemOutPort_1b1a;
		if( !isValidBound(boundObjs_1b28, outPort_1b23, true))
			continue;
		currMatch.outPort_1b2a= outPort_1b23;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_1b0a::outputAppender( const CyberComposition::Simulink::OutPort& subsystemOutPort_1b2b, const CyberComposition::Simulink::OutPort& outPort_1b2d)
{
	_subsystemOutPort_1b11->push_back( subsystemOutPort_1b2b);
	_outPort_1b12->push_back( outPort_1b2d);
}

void CreateLocalVars_1b35::operator()( const Packets_t& outPorts_1b36, const Packets_t& mains_1b38)
{
#ifdef PRINT_INFO
	printLog( "CreateLocalVars_1b35" );
#endif
	RTTGenerator::Instance()->generateRule(1485, "CreateLocalVars");
	processInputPackets( outPorts_1b36, mains_1b38);
}

bool CreateLocalVars_1b35::isInputUnique( const Udm::Object& outPort_1b3e, const Udm::Object& main_1b47)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itOutPort_1b40= _outPort_1b3a.begin(), itMain_1b49= _main_1b43.begin(); itOutPort_1b40!= _outPort_1b3a.end(), itMain_1b49!= _main_1b43.end(); ++itOutPort_1b40, ++itMain_1b49)
	{
		if( ( *itOutPort_1b40== outPort_1b3e)&& ( *itMain_1b49== main_1b47))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_outPort_1b3a.push_back( outPort_1b3e);
		_main_1b43.push_back( main_1b47);
	}
	return isUnique;
}

bool CreateLocalVars_1b35::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateLocalVars_1b35::processInputPackets( const Packets_t& outPorts_1b36, const Packets_t& mains_1b38)
{
	for( Packets_t::const_iterator itOutPort_1b3b= outPorts_1b36.begin(), itMain_1b44= mains_1b38.begin(); itOutPort_1b3b!= outPorts_1b36.end(), itMain_1b44!= mains_1b38.end(); ++itOutPort_1b3b, ++itMain_1b44)
	{
		bool isUnique= isInputUnique( *itOutPort_1b3b, *itMain_1b44);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itOutPort_1b3b, *itMain_1b44);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateLocalVars_1b35::patternMatcher( const Udm::Object& outPort_1b3c, const Udm::Object& main_1b45)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( outPort_1b3c.type(), CyberComposition::Simulink::OutPort::meta))
			continue;
		CyberComposition::Simulink::OutPort outPort_1b41= CyberComposition::Simulink::OutPort::Cast( outPort_1b3c);
		if( false== Uml::IsDerivedFrom( main_1b45.type(), SFC::Function::meta))
			continue;
		SFC::Function main_1b4a= SFC::Function::Cast( main_1b45);
		set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_1b4c= outPort_1b41.TypeBaseRef_kind_children();
		for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_1b4d= typeBaseRefs_1b4c.begin(); itTypeBaseRef_1b4d!= typeBaseRefs_1b4c.end(); ++itTypeBaseRef_1b4d)
		{
			CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_1b4e= *itTypeBaseRef_1b4d;
			CyberComposition::Simulink::SF_TypeBase typeBase_1b4f= currTypeBaseRef_1b4e.ref();
			if( !typeBase_1b4f)
				continue;
			SFC::DT dT_1b50= typeBase_1b4f.dt();
			if( !dT_1b50)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1b54;
			if( !isValidBound(boundObjs_1b54, outPort_1b41, true))
				continue;
			currMatch.outPort_1b55= outPort_1b41;
			if( !isValidBound(boundObjs_1b54, main_1b4a, true))
				continue;
			currMatch.main_1b56= main_1b4a;
			if( !isValidBound(boundObjs_1b54, currTypeBaseRef_1b4e, false))
				continue;
			currMatch.typeBaseRef_1b57= currTypeBaseRef_1b4e;
			if( !isValidBound(boundObjs_1b54, typeBase_1b4f, false))
				continue;
			currMatch.typeBase_1b58= typeBase_1b4f;
			if( !isValidBound(boundObjs_1b54, dT_1b50, false))
				continue;
			currMatch.dT_1b59= dT_1b50;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateLocalVars_1b35::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newLocalVar_1b5a= SFC::LocalVar::Create( currMatch.main_1b56);
		SFC::DT& DT= currMatch.dT_1b59;
		SFC::LocalVar& LocalVar= newLocalVar_1b5a;
		SFC::Function& Main= currMatch.main_1b56;
		CyberComposition::Simulink::OutPort& OutPort= currMatch.outPort_1b55;
		CyberComposition::Simulink::SF_TypeBase& TypeBase= currMatch.typeBase_1b58;
		CyberComposition::Simulink::TypeBaseRef& TypeBaseRef= currMatch.typeBaseRef_1b57;
		{
__int64 statementCount = Main.statementCount();

LocalVar.name() = (  boost::format( "sig_%1%" ) % statementCount  ).str();
LocalVar.type() = "double";
LocalVar.statementIndex() = statementCount++;

Main.statementCount() = statementCount;
};
		newLocalVar_1b5a.dt()= currMatch.dT_1b59;
		currMatch.outPort_1b55.argdecl()= newLocalVar_1b5a;
	}
}

void GetChildOutPorts_1b5b::operator()( const Packets_t& subsystems_1b5c, const Packets_t& mains_1b5f, Packets_t& outPorts_1b5e, Packets_t& mains_1b61)
{
#ifdef PRINT_INFO
	printLog( "GetChildOutPorts_1b5b" );
#endif
	RTTGenerator::Instance()->generateRule(1499, "GetChildOutPorts");
	_outPort_1b62= &outPorts_1b5e;
	_main_1b63= &mains_1b61;
	processInputPackets( subsystems_1b5c, mains_1b5f);
}

bool GetChildOutPorts_1b5b::isInputUnique( const Udm::Object& subsystem_1b68, const Udm::Object& main_1b71)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1b6a= _subsystem_1b64.begin(), itMain_1b73= _main_1b6d.begin(); itSubsystem_1b6a!= _subsystem_1b64.end(), itMain_1b73!= _main_1b6d.end(); ++itSubsystem_1b6a, ++itMain_1b73)
	{
		if( ( *itSubsystem_1b6a== subsystem_1b68)&& ( *itMain_1b73== main_1b71))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1b64.push_back( subsystem_1b68);
		_main_1b6d.push_back( main_1b71);
	}
	return isUnique;
}

bool GetChildOutPorts_1b5b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetChildOutPorts_1b5b::processInputPackets( const Packets_t& subsystems_1b5c, const Packets_t& mains_1b5f)
{
	for( Packets_t::const_iterator itSubsystem_1b65= subsystems_1b5c.begin(), itMain_1b6e= mains_1b5f.begin(); itSubsystem_1b65!= subsystems_1b5c.end(), itMain_1b6e!= mains_1b5f.end(); ++itSubsystem_1b65, ++itMain_1b6e)
	{
		bool isUnique= isInputUnique( *itSubsystem_1b65, *itMain_1b6e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1b65, *itMain_1b6e);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetChildOutPorts_1b5b::patternMatcher( const Udm::Object& subsystem_1b66, const Udm::Object& main_1b6f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1b66.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1b6b= CyberComposition::Simulink::Subsystem::Cast( subsystem_1b66);
		if( false== Uml::IsDerivedFrom( main_1b6f.type(), SFC::Function::meta))
			continue;
		SFC::Function main_1b74= SFC::Function::Cast( main_1b6f);
		set< CyberComposition::Simulink::Block> blocks_1b76= subsystem_1b6b.Block_kind_children();
		for( set< CyberComposition::Simulink::Block>::const_iterator itBlock_1b77= blocks_1b76.begin(); itBlock_1b77!= blocks_1b76.end(); ++itBlock_1b77)
		{
			CyberComposition::Simulink::Block currBlock_1b78= *itBlock_1b77;
			set< CyberComposition::Simulink::OutPort> outPorts_1b79= currBlock_1b78.OutPort_kind_children();
			for( set< CyberComposition::Simulink::OutPort>::const_iterator itOutPort_1b7a= outPorts_1b79.begin(); itOutPort_1b7a!= outPorts_1b79.end(); ++itOutPort_1b7a)
			{
				CyberComposition::Simulink::OutPort currOutPort_1b7b= *itOutPort_1b7a;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_1b7f;
				if( !isValidBound(boundObjs_1b7f, subsystem_1b6b, true))
					continue;
				currMatch.subsystem_1b80= subsystem_1b6b;
				if( !isValidBound(boundObjs_1b7f, main_1b74, true))
					continue;
				currMatch.main_1b81= main_1b74;
				if( !isValidBound(boundObjs_1b7f, currBlock_1b78, false))
					continue;
				currMatch.block_1b82= currBlock_1b78;
				if( !isValidBound(boundObjs_1b7f, currOutPort_1b7b, false))
					continue;
				currMatch.outPort_1b83= currOutPort_1b7b;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetChildOutPorts_1b5b::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.outPort_1b83, currMatch.main_1b81);
	}
}

void GetChildOutPorts_1b5b::outputAppender( const CyberComposition::Simulink::OutPort& outPort_1b84, const SFC::Function& main_1b86)
{
	_outPort_1b62->push_back( outPort_1b84);
	_main_1b63->push_back( main_1b86);
}

void OutPortFilter_1b88::operator()( const Packets_t& outPorts_1b89, const Packets_t& systemFunctions_1b8b, Packets_t& outPorts_1b8d, Packets_t& systemFunctions_1b8e, Packets_t& outPorts_1b8f, Packets_t& systemFunctions_1b90)
{
#ifdef PRINT_INFO
	printLog( "OutPortFilter_1b88" );
#endif
	_outPort_1b91= &outPorts_1b8d;
	_systemFunction_1b92= &systemFunctions_1b8e;
	_outPort_1b93= &outPorts_1b8f;
	_systemFunction_1b94= &systemFunctions_1b90;
	if( ( !outPorts_1b89.empty())&& ( !systemFunctions_1b8b.empty()))
		callOutPortTest_1c01( outPorts_1b89, systemFunctions_1b8b);
}

void OutPortFilter_1b88::callOutPortTest_1c01( const Packets_t& outPorts_1b96, const Packets_t& systemFunctions_1b98)
{
	Packets_t outPorts_1b9a;
	Packets_t systemFunctions_1b9b;
	Packets_t outPorts_1b9c;
	Packets_t systemFunctions_1b9d;
	OutPortTest_1b95 outPortTest_1b95;
	outPortTest_1b95( outPorts_1b96, systemFunctions_1b98, outPorts_1b9a, systemFunctions_1b9b, outPorts_1b9c, systemFunctions_1b9d);
	_outPort_1b91->insert( _outPort_1b91->end(), outPorts_1b9a.begin(), outPorts_1b9a.end());
	_systemFunction_1b92->insert( _systemFunction_1b92->end(), systemFunctions_1b9b.begin(), systemFunctions_1b9b.end());
	_outPort_1b93->insert( _outPort_1b93->end(), outPorts_1b9c.begin(), outPorts_1b9c.end());
	_systemFunction_1b94->insert( _systemFunction_1b94->end(), systemFunctions_1b9d.begin(), systemFunctions_1b9d.end());
}

void OutPortTest_1b95::operator()( const Packets_t& outPorts_1b96, const Packets_t& systemFunctions_1b98, Packets_t& outPorts_1b9a, Packets_t& systemFunctions_1b9b, Packets_t& outPorts_1b9c, Packets_t& systemFunctions_1b9d)
{
#ifdef PRINT_INFO
	printLog( "OutPortTest_1b95" );
#endif
	_outPort_1b9e= &outPorts_1b9a;
	_systemFunction_1b9f= &systemFunctions_1b9b;
	_outPort_1ba0= &outPorts_1b9c;
	_systemFunction_1ba1= &systemFunctions_1b9d;
	for( Packets_t::const_iterator itoutPort_1ba3= outPorts_1b96.begin(), itsystemFunction_1baa= systemFunctions_1b98.begin(); itoutPort_1ba3!= outPorts_1b96.end(), itsystemFunction_1baa!= systemFunctions_1b98.end(); ++itoutPort_1ba3, ++itsystemFunction_1baa)
	{
		bool isUnique= isInputUnique( *itoutPort_1ba3, *itsystemFunction_1baa);
		if( !isUnique)
			continue;
		Packets_t oneoutPort_1ba7( 1, *itoutPort_1ba3);
		Packets_t onesystemFunction_1bae( 1, *itsystemFunction_1baa);
		executeOne( oneoutPort_1ba7, onesystemFunction_1bae);
	}
}

void OutPortTest_1b95::executeOne( const Packets_t& outPorts_1b96, const Packets_t& systemFunctions_1b98)
{
	Packets_t outPorts_1bb3;
	Packets_t mains_1bb6;
	OutPort2OutPort_1bb0 outPort2OutPort_1bb0;
	bool isMatchOutPort2OutPort_1bb0= outPort2OutPort_1bb0( outPorts_1b96, systemFunctions_1b98, outPorts_1bb3, mains_1bb6);
	_outPort_1b9e->insert( _outPort_1b9e->end(), outPorts_1bb3.begin(), outPorts_1bb3.end());
	_systemFunction_1b9f->insert( _systemFunction_1b9f->end(), mains_1bb6.begin(), mains_1bb6.end());
	if( isMatchOutPort2OutPort_1bb0)
		return;
	Packets_t outPorts_1bdf;
	Packets_t mains_1be2;
	Otherwise_1bdc otherwise_1bdc;
	bool isMatchOtherwise_1bdc= otherwise_1bdc( outPorts_1b96, systemFunctions_1b98, outPorts_1bdf, mains_1be2);
	_outPort_1ba0->insert( _outPort_1ba0->end(), outPorts_1bdf.begin(), outPorts_1bdf.end());
	_systemFunction_1ba1->insert( _systemFunction_1ba1->end(), mains_1be2.begin(), mains_1be2.end());
	if( isMatchOtherwise_1bdc)
		return;
}

bool OutPortTest_1b95::isInputUnique( const Udm::Object& outPort_1ba4, const Udm::Object& systemFunction_1bab)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itoutPort_1ba6= _outPort_1ba2.begin(), itsystemFunction_1bad= _systemFunction_1ba9.begin(); itoutPort_1ba6!= _outPort_1ba2.end(), itsystemFunction_1bad!= _systemFunction_1ba9.end(); ++itoutPort_1ba6, ++itsystemFunction_1bad)
	{
		if( ( *itoutPort_1ba6== outPort_1ba4)&& ( *itsystemFunction_1bad== systemFunction_1bab))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_outPort_1ba2.push_back( outPort_1ba4);
		_systemFunction_1ba9.push_back( systemFunction_1bab);
	}
	return isUnique;
}

bool OutPort2OutPort_1bb0::operator()( const Packets_t& outPorts_1bb1, const Packets_t& mains_1bb4, Packets_t& outPorts_1bb3, Packets_t& mains_1bb6)
{
#ifdef PRINT_INFO
	printLog( "OutPort2OutPort_1bb0" );
#endif
	_outPort_1bb7= &outPorts_1bb3;
	_main_1bb8= &mains_1bb6;
	processInputPackets( outPorts_1bb1, mains_1bb4);
	if( false== _matches.empty())
		return true;
	return false;
}

bool OutPort2OutPort_1bb0::isInputUnique( const Udm::Object& outPort_1bbd, const Udm::Object& main_1bc6)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itOutPort_1bbf= _outPort_1bb9.begin(), itMain_1bc8= _main_1bc2.begin(); itOutPort_1bbf!= _outPort_1bb9.end(), itMain_1bc8!= _main_1bc2.end(); ++itOutPort_1bbf, ++itMain_1bc8)
	{
		if( ( *itOutPort_1bbf== outPort_1bbd)&& ( *itMain_1bc8== main_1bc6))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_outPort_1bb9.push_back( outPort_1bbd);
		_main_1bc2.push_back( main_1bc6);
	}
	return isUnique;
}

bool OutPort2OutPort_1bb0::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void OutPort2OutPort_1bb0::processInputPackets( const Packets_t& outPorts_1bb1, const Packets_t& mains_1bb4)
{
	for( Packets_t::const_iterator itOutPort_1bba= outPorts_1bb1.begin(), itMain_1bc3= mains_1bb4.begin(); itOutPort_1bba!= outPorts_1bb1.end(), itMain_1bc3!= mains_1bb4.end(); ++itOutPort_1bba, ++itMain_1bc3)
	{
		bool isUnique= isInputUnique( *itOutPort_1bba, *itMain_1bc3);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itOutPort_1bba, *itMain_1bc3);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.outPort_1bd4, currMatch.main_1bd5);
	}
}

bool OutPort2OutPort_1bb0::patternMatcher( const Udm::Object& outPort_1bbb, const Udm::Object& main_1bc4)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( outPort_1bbb.type(), CyberComposition::Simulink::OutPort::meta))
			continue;
		CyberComposition::Simulink::OutPort outPort_1bc0= CyberComposition::Simulink::OutPort::Cast( outPort_1bbb);
		if( false== Uml::IsDerivedFrom( main_1bc4.type(), SFC::Function::meta))
			continue;
		SFC::Function main_1bc9= SFC::Function::Cast( main_1bc4);
		set< CyberComposition::Simulink::Line> lines_1bcb= outPort_1bc0.dstLine();
		for( set< CyberComposition::Simulink::Line>::const_iterator itLines_1bcc= lines_1bcb.begin(); itLines_1bcc!= lines_1bcb.end(); ++itLines_1bcc)
		{
			CyberComposition::Simulink::Line currLine_1bcd= *itLines_1bcc;
			CyberComposition::Simulink::SF_Port subsystemOutPort_1bce= currLine_1bcd.dstLine_end();
			if( false== Uml::IsDerivedFrom( subsystemOutPort_1bce.type(), CyberComposition::Simulink::OutPort::meta))
				continue;
			CyberComposition::Simulink::OutPort currSubsystemOutPort_1bcf= CyberComposition::Simulink::OutPort::Cast( subsystemOutPort_1bce);
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1bd3;
			if( !isValidBound(boundObjs_1bd3, outPort_1bc0, true))
				continue;
			currMatch.outPort_1bd4= outPort_1bc0;
			if( !isValidBound(boundObjs_1bd3, main_1bc9, true))
				continue;
			currMatch.main_1bd5= main_1bc9;
			if( !isValidBound(boundObjs_1bd3, currSubsystemOutPort_1bcf, false))
				continue;
			currMatch.subsystemOutPort_1bd6= currSubsystemOutPort_1bcf;
			if( !isValidBound(boundObjs_1bd3, currLine_1bcd, false))
				continue;
			currMatch.line_1bd7= currLine_1bcd;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void OutPort2OutPort_1bb0::outputAppender( const CyberComposition::Simulink::OutPort& outPort_1bd8, const SFC::Function& main_1bda)
{
	_outPort_1bb7->push_back( outPort_1bd8);
	_main_1bb8->push_back( main_1bda);
}

bool Otherwise_1bdc::operator()( const Packets_t& outPorts_1bdd, const Packets_t& mains_1be0, Packets_t& outPorts_1bdf, Packets_t& mains_1be2)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_1bdc" );
#endif
	_outPort_1be3= &outPorts_1bdf;
	_main_1be4= &mains_1be2;
	processInputPackets( outPorts_1bdd, mains_1be0);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_1bdc::isInputUnique( const Udm::Object& outPort_1be9, const Udm::Object& main_1bf2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itOutPort_1beb= _outPort_1be5.begin(), itMain_1bf4= _main_1bee.begin(); itOutPort_1beb!= _outPort_1be5.end(), itMain_1bf4!= _main_1bee.end(); ++itOutPort_1beb, ++itMain_1bf4)
	{
		if( ( *itOutPort_1beb== outPort_1be9)&& ( *itMain_1bf4== main_1bf2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_outPort_1be5.push_back( outPort_1be9);
		_main_1bee.push_back( main_1bf2);
	}
	return isUnique;
}

bool Otherwise_1bdc::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_1bdc::processInputPackets( const Packets_t& outPorts_1bdd, const Packets_t& mains_1be0)
{
	for( Packets_t::const_iterator itOutPort_1be6= outPorts_1bdd.begin(), itMain_1bef= mains_1be0.begin(); itOutPort_1be6!= outPorts_1bdd.end(), itMain_1bef!= mains_1be0.end(); ++itOutPort_1be6, ++itMain_1bef)
	{
		bool isUnique= isInputUnique( *itOutPort_1be6, *itMain_1bef);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itOutPort_1be6, *itMain_1bef);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.outPort_1bfb, currMatch.main_1bfc);
	}
}

bool Otherwise_1bdc::patternMatcher( const Udm::Object& outPort_1be7, const Udm::Object& main_1bf0)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( outPort_1be7.type(), CyberComposition::Simulink::OutPort::meta))
			continue;
		CyberComposition::Simulink::OutPort outPort_1bec= CyberComposition::Simulink::OutPort::Cast( outPort_1be7);
		if( false== Uml::IsDerivedFrom( main_1bf0.type(), SFC::Function::meta))
			continue;
		SFC::Function main_1bf5= SFC::Function::Cast( main_1bf0);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1bfa;
		if( !isValidBound(boundObjs_1bfa, outPort_1bec, true))
			continue;
		currMatch.outPort_1bfb= outPort_1bec;
		if( !isValidBound(boundObjs_1bfa, main_1bf5, true))
			continue;
		currMatch.main_1bfc= main_1bf5;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_1bdc::outputAppender( const CyberComposition::Simulink::OutPort& outPort_1bfd, const SFC::Function& main_1bff)
{
	_outPort_1be3->push_back( outPort_1bfd);
	_main_1be4->push_back( main_1bff);
}

void GetFunctions_1c12::operator()( const Packets_t& systems_1c13, Packets_t& systems_1c15, Packets_t& systemFunctions_1c16)
{
#ifdef PRINT_INFO
	printLog( "GetFunctions_1c12" );
#endif
	_system_1c17= &systems_1c15;
	_systemFunction_1c18= &systemFunctions_1c16;
	if( ( !systems_1c13.empty()))
		callGetFunctions_1c34( systems_1c13);
}

void GetFunctions_1c12::callGetFunctions_1c34( const Packets_t& subsystems_1c1a)
{
	Packets_t subsystems_1c1c;
	Packets_t mains_1c1d;
	GetFunctions_1c19 getFunctions_1c19;
	getFunctions_1c19( subsystems_1c1a, subsystems_1c1c, mains_1c1d);
	_system_1c17->insert( _system_1c17->end(), subsystems_1c1c.begin(), subsystems_1c1c.end());
	_systemFunction_1c18->insert( _systemFunction_1c18->end(), mains_1c1d.begin(), mains_1c1d.end());
}

void GetFunctions_1c19::operator()( const Packets_t& subsystems_1c1a, Packets_t& subsystems_1c1c, Packets_t& mains_1c1d)
{
#ifdef PRINT_INFO
	printLog( "GetFunctions_1c19" );
#endif
	RTTGenerator::Instance()->generateRule(4680, "GetFunctions");
	_subsystem_1c1e= &subsystems_1c1c;
	_main_1c1f= &mains_1c1d;
	processInputPackets( subsystems_1c1a);
}

bool GetFunctions_1c19::isInputUnique( const Udm::Object& subsystem_1c24)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1c26= _subsystem_1c20.begin(); itSubsystem_1c26!= _subsystem_1c20.end(); ++itSubsystem_1c26)
	{
		if( ( *itSubsystem_1c26== subsystem_1c24))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_subsystem_1c20.push_back( subsystem_1c24);
	return isUnique;
}

bool GetFunctions_1c19::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetFunctions_1c19::processInputPackets( const Packets_t& subsystems_1c1a)
{
	for( Packets_t::const_iterator itSubsystem_1c21= subsystems_1c1a.begin(); itSubsystem_1c21!= subsystems_1c1a.end(); ++itSubsystem_1c21)
	{
		bool isUnique= isInputUnique( *itSubsystem_1c21);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1c21);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetFunctions_1c19::patternMatcher( const Udm::Object& subsystem_1c22)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1c22.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1c27= CyberComposition::Simulink::Subsystem::Cast( subsystem_1c22);
		SFC::Function main_1c29= subsystem_1c27.main();
		if( !main_1c29)
			continue;
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1c2d;
		if( !isValidBound(boundObjs_1c2d, subsystem_1c27, true))
			continue;
		currMatch.subsystem_1c2e= subsystem_1c27;
		if( !isValidBound(boundObjs_1c2d, main_1c29, false))
			continue;
		currMatch.main_1c2f= main_1c29;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void GetFunctions_1c19::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_1c2e, currMatch.main_1c2f);
	}
}

void GetFunctions_1c19::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_1c30, const SFC::Function& main_1c32)
{
	_subsystem_1c1e->push_back( subsystem_1c30);
	_main_1c1f->push_back( main_1c32);
}

void CreateProgramsTopLevel_1c42::operator()( const Packets_t& systems_1c43, const Packets_t& projects_1c45, Packets_t& systems_1c47, Packets_t& programs_1c48)
{
#ifdef PRINT_INFO
	printLog( "CreateProgramsTopLevel_1c42" );
#endif
	_system_1c49= &systems_1c47;
	_program_1c4a= &programs_1c48;
	for( Packets_t::const_iterator itsystem_1c4c= systems_1c43.begin(), itproject_1c53= projects_1c45.begin(); itsystem_1c4c!= systems_1c43.end(), itproject_1c53!= projects_1c45.end(); ++itsystem_1c4c, ++itproject_1c53)
	{
		bool isUnique= isInputUnique( *itsystem_1c4c, *itproject_1c53);
		if( !isUnique)
			continue;
		Packets_t onesystem_1c50( 1, *itsystem_1c4c);
		Packets_t oneproject_1c57( 1, *itproject_1c53);
		executeOne( onesystem_1c50, oneproject_1c57);
	}
}

void CreateProgramsTopLevel_1c42::executeOne( const Packets_t& systems_1c43, const Packets_t& projects_1c45)
{
	if( ( !systems_1c43.empty())&& ( !projects_1c45.empty()))
		callHasClassFilter_1ce8( systems_1c43, projects_1c45);
}

bool CreateProgramsTopLevel_1c42::isInputUnique( const Udm::Object& system_1c4d, const Udm::Object& project_1c54)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itsystem_1c4f= _system_1c4b.begin(), itproject_1c56= _project_1c52.begin(); itsystem_1c4f!= _system_1c4b.end(), itproject_1c56!= _project_1c52.end(); ++itsystem_1c4f, ++itproject_1c56)
	{
		if( ( *itsystem_1c4f== system_1c4d)&& ( *itproject_1c56== project_1c54))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_system_1c4b.push_back( system_1c4d);
		_project_1c52.push_back( project_1c54);
	}
	return isUnique;
}

void CreateProgramsTopLevel_1c42::callHasClassFilter_1ce8( const Packets_t& systems_1c5a, const Packets_t& projects_1c5c)
{
	Packets_t systems_1c5e;
	Packets_t projects_1c5f;
	Packets_t systems_1c60;
	Packets_t projects_1c61;
	HasClassFilter_1c59 hasClassFilter_1c59;
	hasClassFilter_1c59( systems_1c5a, projects_1c5c, systems_1c5e, projects_1c5f, systems_1c60, projects_1c61);
	if( ( !systems_1c60.empty())&& ( !projects_1c61.empty()))
		callCreateProgramClass_1ceb( systems_1c60, projects_1c61);
}

void CreateProgramsTopLevel_1c42::callCreateProgramClass_1ceb( const Packets_t& subsystems_1cc1, const Packets_t& projects_1cc5)
{
	Packets_t subsystems_1cc3;
	Packets_t programs_1cc4;
	CreateProgramClass_1cc0 createProgramClass_1cc0;
	createProgramClass_1cc0( subsystems_1cc1, projects_1cc5, subsystems_1cc3, programs_1cc4);
	_system_1c49->insert( _system_1c49->end(), subsystems_1cc3.begin(), subsystems_1cc3.end());
	_program_1c4a->insert( _program_1c4a->end(), programs_1cc4.begin(), programs_1cc4.end());
}

void HasClassFilter_1c59::operator()( const Packets_t& systems_1c5a, const Packets_t& projects_1c5c, Packets_t& systems_1c5e, Packets_t& projects_1c5f, Packets_t& systems_1c60, Packets_t& projects_1c61)
{
#ifdef PRINT_INFO
	printLog( "HasClassFilter_1c59" );
#endif
	_system_1c62= &systems_1c5e;
	_project_1c63= &projects_1c5f;
	_system_1c64= &systems_1c60;
	_project_1c65= &projects_1c61;
	for( Packets_t::const_iterator itsystem_1c67= systems_1c5a.begin(), itproject_1c6e= projects_1c5c.begin(); itsystem_1c67!= systems_1c5a.end(), itproject_1c6e!= projects_1c5c.end(); ++itsystem_1c67, ++itproject_1c6e)
	{
		bool isUnique= isInputUnique( *itsystem_1c67, *itproject_1c6e);
		if( !isUnique)
			continue;
		Packets_t onesystem_1c6b( 1, *itsystem_1c67);
		Packets_t oneproject_1c72( 1, *itproject_1c6e);
		executeOne( onesystem_1c6b, oneproject_1c72);
	}
}

void HasClassFilter_1c59::executeOne( const Packets_t& systems_1c5a, const Packets_t& projects_1c5c)
{
	Packets_t subsystems_1c77;
	Packets_t projects_1c7a;
	SubsystemHasClass_1c74 subsystemHasClass_1c74;
	bool isMatchSubsystemHasClass_1c74= subsystemHasClass_1c74( systems_1c5a, projects_1c5c, subsystems_1c77, projects_1c7a);
	_system_1c62->insert( _system_1c62->end(), subsystems_1c77.begin(), subsystems_1c77.end());
	_project_1c63->insert( _project_1c63->end(), projects_1c7a.begin(), projects_1c7a.end());
	if( isMatchSubsystemHasClass_1c74)
		return;
	Packets_t subsystems_1c9e;
	Packets_t projects_1ca1;
	NoClass_1c9b noClass_1c9b;
	bool isMatchNoClass_1c9b= noClass_1c9b( systems_1c5a, projects_1c5c, subsystems_1c9e, projects_1ca1);
	_system_1c64->insert( _system_1c64->end(), subsystems_1c9e.begin(), subsystems_1c9e.end());
	_project_1c65->insert( _project_1c65->end(), projects_1ca1.begin(), projects_1ca1.end());
	if( isMatchNoClass_1c9b)
		return;
}

bool HasClassFilter_1c59::isInputUnique( const Udm::Object& system_1c68, const Udm::Object& project_1c6f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itsystem_1c6a= _system_1c66.begin(), itproject_1c71= _project_1c6d.begin(); itsystem_1c6a!= _system_1c66.end(), itproject_1c71!= _project_1c6d.end(); ++itsystem_1c6a, ++itproject_1c71)
	{
		if( ( *itsystem_1c6a== system_1c68)&& ( *itproject_1c71== project_1c6f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_system_1c66.push_back( system_1c68);
		_project_1c6d.push_back( project_1c6f);
	}
	return isUnique;
}

bool SubsystemHasClass_1c74::operator()( const Packets_t& subsystems_1c75, const Packets_t& projects_1c78, Packets_t& subsystems_1c77, Packets_t& projects_1c7a)
{
#ifdef PRINT_INFO
	printLog( "SubsystemHasClass_1c74" );
#endif
	_subsystem_1c7b= &subsystems_1c77;
	_project_1c7c= &projects_1c7a;
	processInputPackets( subsystems_1c75, projects_1c78);
	if( false== _matches.empty())
		return true;
	return false;
}

bool SubsystemHasClass_1c74::isInputUnique( const Udm::Object& subsystem_1c81, const Udm::Object& project_1c8a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1c83= _subsystem_1c7d.begin(), itProject_1c8c= _project_1c86.begin(); itSubsystem_1c83!= _subsystem_1c7d.end(), itProject_1c8c!= _project_1c86.end(); ++itSubsystem_1c83, ++itProject_1c8c)
	{
		if( ( *itSubsystem_1c83== subsystem_1c81)&& ( *itProject_1c8c== project_1c8a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1c7d.push_back( subsystem_1c81);
		_project_1c86.push_back( project_1c8a);
	}
	return isUnique;
}

bool SubsystemHasClass_1c74::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void SubsystemHasClass_1c74::processInputPackets( const Packets_t& subsystems_1c75, const Packets_t& projects_1c78)
{
	for( Packets_t::const_iterator itSubsystem_1c7e= subsystems_1c75.begin(), itProject_1c87= projects_1c78.begin(); itSubsystem_1c7e!= subsystems_1c75.end(), itProject_1c87!= projects_1c78.end(); ++itSubsystem_1c7e, ++itProject_1c87)
	{
		bool isUnique= isInputUnique( *itSubsystem_1c7e, *itProject_1c87);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1c7e, *itProject_1c87);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_1c94, currMatch.project_1c95);
	}
}

bool SubsystemHasClass_1c74::patternMatcher( const Udm::Object& subsystem_1c7f, const Udm::Object& project_1c88)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1c7f.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1c84= CyberComposition::Simulink::Subsystem::Cast( subsystem_1c7f);
		if( false== Uml::IsDerivedFrom( project_1c88.type(), SFC::Project::meta))
			continue;
		SFC::Project project_1c8d= SFC::Project::Cast( project_1c88);
		SFC::Class class_1c8f= subsystem_1c84.cls();
		if( !class_1c8f)
			continue;
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1c93;
		if( !isValidBound(boundObjs_1c93, subsystem_1c84, true))
			continue;
		currMatch.subsystem_1c94= subsystem_1c84;
		if( !isValidBound(boundObjs_1c93, project_1c8d, true))
			continue;
		currMatch.project_1c95= project_1c8d;
		if( !isValidBound(boundObjs_1c93, class_1c8f, false))
			continue;
		currMatch.class_1c96= class_1c8f;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void SubsystemHasClass_1c74::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_1c97, const SFC::Project& project_1c99)
{
	_subsystem_1c7b->push_back( subsystem_1c97);
	_project_1c7c->push_back( project_1c99);
}

bool NoClass_1c9b::operator()( const Packets_t& subsystems_1c9c, const Packets_t& projects_1c9f, Packets_t& subsystems_1c9e, Packets_t& projects_1ca1)
{
#ifdef PRINT_INFO
	printLog( "NoClass_1c9b" );
#endif
	_subsystem_1ca2= &subsystems_1c9e;
	_project_1ca3= &projects_1ca1;
	processInputPackets( subsystems_1c9c, projects_1c9f);
	if( false== _matches.empty())
		return true;
	return false;
}

bool NoClass_1c9b::isInputUnique( const Udm::Object& subsystem_1ca8, const Udm::Object& project_1cb1)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1caa= _subsystem_1ca4.begin(), itProject_1cb3= _project_1cad.begin(); itSubsystem_1caa!= _subsystem_1ca4.end(), itProject_1cb3!= _project_1cad.end(); ++itSubsystem_1caa, ++itProject_1cb3)
	{
		if( ( *itSubsystem_1caa== subsystem_1ca8)&& ( *itProject_1cb3== project_1cb1))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1ca4.push_back( subsystem_1ca8);
		_project_1cad.push_back( project_1cb1);
	}
	return isUnique;
}

bool NoClass_1c9b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void NoClass_1c9b::processInputPackets( const Packets_t& subsystems_1c9c, const Packets_t& projects_1c9f)
{
	for( Packets_t::const_iterator itSubsystem_1ca5= subsystems_1c9c.begin(), itProject_1cae= projects_1c9f.begin(); itSubsystem_1ca5!= subsystems_1c9c.end(), itProject_1cae!= projects_1c9f.end(); ++itSubsystem_1ca5, ++itProject_1cae)
	{
		bool isUnique= isInputUnique( *itSubsystem_1ca5, *itProject_1cae);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1ca5, *itProject_1cae);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_1cba, currMatch.project_1cbb);
	}
}

bool NoClass_1c9b::patternMatcher( const Udm::Object& subsystem_1ca6, const Udm::Object& project_1caf)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1ca6.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1cab= CyberComposition::Simulink::Subsystem::Cast( subsystem_1ca6);
		if( false== Uml::IsDerivedFrom( project_1caf.type(), SFC::Project::meta))
			continue;
		SFC::Project project_1cb4= SFC::Project::Cast( project_1caf);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1cb9;
		if( !isValidBound(boundObjs_1cb9, subsystem_1cab, true))
			continue;
		currMatch.subsystem_1cba= subsystem_1cab;
		if( !isValidBound(boundObjs_1cb9, project_1cb4, true))
			continue;
		currMatch.project_1cbb= project_1cb4;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void NoClass_1c9b::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_1cbc, const SFC::Project& project_1cbe)
{
	_subsystem_1ca2->push_back( subsystem_1cbc);
	_project_1ca3->push_back( project_1cbe);
}

void CreateProgramClass_1cc0::operator()( const Packets_t& subsystems_1cc1, const Packets_t& projects_1cc5, Packets_t& subsystems_1cc3, Packets_t& programs_1cc4)
{
#ifdef PRINT_INFO
	printLog( "CreateProgramClass_1cc0" );
#endif
	RTTGenerator::Instance()->generateRule(1550, "CreateProgramClass");
	_subsystem_1cc7= &subsystems_1cc3;
	_program_1cc8= &programs_1cc4;
	processInputPackets( subsystems_1cc1, projects_1cc5);
}

bool CreateProgramClass_1cc0::isInputUnique( const Udm::Object& subsystem_1ccd, const Udm::Object& project_1cd6)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1ccf= _subsystem_1cc9.begin(), itProject_1cd8= _project_1cd2.begin(); itSubsystem_1ccf!= _subsystem_1cc9.end(), itProject_1cd8!= _project_1cd2.end(); ++itSubsystem_1ccf, ++itProject_1cd8)
	{
		if( ( *itSubsystem_1ccf== subsystem_1ccd)&& ( *itProject_1cd8== project_1cd6))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1cc9.push_back( subsystem_1ccd);
		_project_1cd2.push_back( project_1cd6);
	}
	return isUnique;
}

bool CreateProgramClass_1cc0::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateProgramClass_1cc0::processInputPackets( const Packets_t& subsystems_1cc1, const Packets_t& projects_1cc5)
{
	for( Packets_t::const_iterator itSubsystem_1cca= subsystems_1cc1.begin(), itProject_1cd3= projects_1cc5.begin(); itSubsystem_1cca!= subsystems_1cc1.end(), itProject_1cd3!= projects_1cc5.end(); ++itSubsystem_1cca, ++itProject_1cd3)
	{
		bool isUnique= isInputUnique( *itSubsystem_1cca, *itProject_1cd3);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1cca, *itProject_1cd3);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateProgramClass_1cc0::patternMatcher( const Udm::Object& subsystem_1ccb, const Udm::Object& project_1cd4)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1ccb.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1cd0= CyberComposition::Simulink::Subsystem::Cast( subsystem_1ccb);
		if( false== Uml::IsDerivedFrom( project_1cd4.type(), SFC::Project::meta))
			continue;
		SFC::Project project_1cd9= SFC::Project::Cast( project_1cd4);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1cde;
		if( !isValidBound(boundObjs_1cde, subsystem_1cd0, true))
			continue;
		currMatch.subsystem_1cdf= subsystem_1cd0;
		if( !isValidBound(boundObjs_1cde, project_1cd9, true))
			continue;
		currMatch.project_1ce0= project_1cd9;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateProgramClass_1cc0::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Program newProgram_1ce1= SFC::Program::Create( currMatch.project_1ce0, SFC::Project::meta_stmnt);
		SFC::Class newClass_1ce2= SFC::Class::Create( newProgram_1ce1, SFC::Program::meta_stmnt);
		SFC::Struct newStruct_1ce3= SFC::Struct::Create( newClass_1ce2, SFC::Class::meta_stmnt);
		SFC::Class& Class= newClass_1ce2;
		SFC::Program& Program= newProgram_1ce1;
		SFC::Project& Project= currMatch.project_1ce0;
		SFC::Struct& Struct= newStruct_1ce3;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_1cdf;
		{
std::string subsystemName = Subsystem.name();
Program.filename() = subsystemName + "_sl";

std::string name = subsystemName + "_" + boost::lexical_cast< std::string >( Subsystem.uniqueId() );
Class.name() = name + "_class";
Struct.name() = name + "_context";
};
		{
__int64 statementCount = Class.statementCount();
Struct.statementIndex() = statementCount++;
Class.statementCount() = statementCount;
};
		{
__int64 statementCount = Program.statementCount();
Class.statementIndex() = statementCount++;
Program.statementCount() = statementCount;
};
		{
typedef std::set< Udm::Object > ObjectSet;

ObjectSet objectSet = SFUtils::getAllInstanceEquivalent( Subsystem );
objectSet.erase( Subsystem );

for( ObjectSet::iterator obsItr = objectSet.begin() ; obsItr != objectSet.end() ; (void)++obsItr ) {
    CyberComposition::Simulink::Subsystem::Cast( *obsItr ).cls() = Class;
}
};
		{
__int64 statementCount = Project.statementCount();
Program.statementIndex() = statementCount++;
Project.statementCount() = statementCount;
};
		currMatch.subsystem_1cdf.cls()= newClass_1ce2;
		outputAppender( currMatch.subsystem_1cdf, newProgram_1ce1);
	}
}

void CreateProgramClass_1cc0::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_1ce4, const SFC::Program& program_1ce6)
{
	_subsystem_1cc7->push_back( subsystem_1ce4);
	_program_1cc8->push_back( program_1ce6);
}

void CreateSigFlowsR_1cee::operator()( const Packets_t& systems_1cef)
{
#ifdef PRINT_INFO
	printLog( "CreateSigFlowsR_1cee" );
#endif
	if( ( !systems_1cef.empty()))
		callSubsystemFilter_52d9( systems_1cef);
}

void CreateSigFlowsR_1cee::callSubsystemFilter_52d9( const Packets_t& systems_10d2)
{
	Packets_t chartsystems_10d4;
	Packets_t sFchartsystems_10d5;
	Packets_t systems_10d6;
	SubsystemFilter_10d1 subsystemFilter_10d1;
	subsystemFilter_10d1( systems_10d2, chartsystems_10d4, sFchartsystems_10d5, systems_10d6);
	if( ( !systems_10d6.empty()))
		callGetFunctions_52db( systems_10d6);
}

void CreateSigFlowsR_1cee::callGetFunctions_52db( const Packets_t& systems_1c13)
{
	Packets_t systems_1c15;
	Packets_t systemFunctions_1c16;
	GetFunctions_1c12 getFunctions_1c12;
	getFunctions_1c12( systems_1c13, systems_1c15, systemFunctions_1c16);
	if( ( !systems_1c15.empty())&& ( !systemFunctions_1c16.empty()))
		callCreateTSB_52dd( systems_1c15, systemFunctions_1c16);
}

void CreateSigFlowsR_1cee::callCreateTSB_52dd( const Packets_t& systems_1cf2, const Packets_t& systemFunctions_1cf4)
{
	Packets_t systems_1cf6;
	CreateTSB_1cf1 createTSB_1cf1;
	createTSB_1cf1( systems_1cf2, systemFunctions_1cf4, systems_1cf6);
	if( ( !systems_1cf6.empty()))
		callGetSubSubsystems_52e0( systems_1cf6);
}

void CreateSigFlowsR_1cee::callGetSubSubsystems_52e0( const Packets_t& systems_10b2)
{
	Packets_t subsystems_10b4;
	GetSubSubsystems_10b1 getSubSubsystems_10b1;
	getSubSubsystems_10b1( systems_10b2, subsystems_10b4);
	if( ( !subsystems_10b4.empty()))
		callSubsystemFilter_52d9( subsystems_10b4);
}

void CreateTSB_1cf1::operator()( const Packets_t& systems_1cf2, const Packets_t& systemFunctions_1cf4, Packets_t& systems_1cf6)
{
#ifdef PRINT_INFO
	printLog( "CreateTSB_1cf1" );
#endif
	_system_1cf7= &systems_1cf6;
	if( ( !systems_1cf2.empty())&& ( !systemFunctions_1cf4.empty()))
		callPassThroughs_52c9( systems_1cf2, systemFunctions_1cf4);
	_system_1cf7->insert( _system_1cf7->end(), systems_1cf2.begin(), systems_1cf2.end());
}

void CreateTSB_1cf1::callPassThroughs_52c9( const Packets_t& systems_1cf9, const Packets_t& systemFunctions_1cfb)
{
	Packets_t systems_1cfd;
	Packets_t systemFunctions_1cfe;
	PassThroughs_1cf8 passThroughs_1cf8;
	passThroughs_1cf8( systems_1cf9, systemFunctions_1cfb, systems_1cfd, systemFunctions_1cfe);
	if( ( !systems_1cfd.empty())&& ( !systemFunctions_1cfe.empty()))
		callDoTopologicalSort_52cc( systems_1cfd, systemFunctions_1cfe);
}

void CreateTSB_1cf1::callDoTopologicalSort_52cc( const Packets_t& subsystems_1d65, const Packets_t& mains_1d68)
{
	Packets_t subsystems_1d67;
	Packets_t mains_1d6a;
	DoTopologicalSort_1d64 doTopologicalSort_1d64;
	doTopologicalSort_1d64( subsystems_1d65, mains_1d68, subsystems_1d67, mains_1d6a);
	if( ( !subsystems_1d67.empty())&& ( !mains_1d6a.empty()))
		callCreatePreDelayExec_52cf( subsystems_1d67, mains_1d6a);
}

void CreateTSB_1cf1::callCreatePreDelayExec_52cf( const Packets_t& systems_1d86, const Packets_t& systemFunctions_1d88)
{
	Packets_t systems_1d8a;
	Packets_t systemFunctions_1d8b;
	CreatePreDelayExec_1d85 createPreDelayExec_1d85;
	createPreDelayExec_1d85( systems_1d86, systemFunctions_1d88, systems_1d8a, systemFunctions_1d8b);
	if( ( !systems_1d8a.empty())&& ( !systemFunctions_1d8b.empty()))
		callGetSortedBlocks_52d2( systems_1d8a, systemFunctions_1d8b);
}

void CreateTSB_1cf1::callGetSortedBlocks_52d2( const Packets_t& subsystems_1d38, const Packets_t& mains_1d3c)
{
	Packets_t subsystems_1d3a;
	Packets_t childBlockss_1d3b;
	Packets_t mains_1d3e;
	GetSortedBlocks_1d37 getSortedBlocks_1d37;
	getSortedBlocks_1d37( subsystems_1d38, mains_1d3c, subsystems_1d3a, childBlockss_1d3b, mains_1d3e);
	if( ( !subsystems_1d3a.empty())&& ( !childBlockss_1d3b.empty())&& ( !mains_1d3e.empty()))
		callCreateBlockExecution_52d5( subsystems_1d3a, childBlockss_1d3b, mains_1d3e);
}

void CreateTSB_1cf1::callCreateBlockExecution_52d5( const Packets_t& systems_1de3, const Packets_t& childBlockss_1de5, const Packets_t& systemFunctions_1de7)
{
	Packets_t systems_1de9;
	Packets_t systemFunctions_1dea;
	CreateBlockExecution_1de2 createBlockExecution_1de2;
	createBlockExecution_1de2( systems_1de3, childBlockss_1de5, systemFunctions_1de7, systems_1de9, systemFunctions_1dea);
}

void PassThroughs_1cf8::operator()( const Packets_t& systems_1cf9, const Packets_t& systemFunctions_1cfb, Packets_t& systems_1cfd, Packets_t& systemFunctions_1cfe)
{
#ifdef PRINT_INFO
	printLog( "PassThroughs_1cf8" );
#endif
	_system_1cff= &systems_1cfd;
	_systemFunction_1d00= &systemFunctions_1cfe;
	if( ( !systems_1cf9.empty())&& ( !systemFunctions_1cfb.empty()))
		callPassThroughs_1d34( systems_1cf9, systemFunctions_1cfb);
	_system_1cff->insert( _system_1cff->end(), systems_1cf9.begin(), systems_1cf9.end());
	_systemFunction_1d00->insert( _systemFunction_1d00->end(), systemFunctions_1cfb.begin(), systemFunctions_1cfb.end());
}

void PassThroughs_1cf8::callPassThroughs_1d34( const Packets_t& subsystems_1d02, const Packets_t& mains_1d04)
{
	PassThroughs_1d01 passThroughs_1d01;
	passThroughs_1d01( subsystems_1d02, mains_1d04);
}

void PassThroughs_1d01::operator()( const Packets_t& subsystems_1d02, const Packets_t& mains_1d04)
{
#ifdef PRINT_INFO
	printLog( "PassThroughs_1d01" );
#endif
	RTTGenerator::Instance()->generateRule(1576, "PassThroughs");
	processInputPackets( subsystems_1d02, mains_1d04);
}

bool PassThroughs_1d01::isInputUnique( const Udm::Object& subsystem_1d0a, const Udm::Object& main_1d13)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1d0c= _subsystem_1d06.begin(), itMain_1d15= _main_1d0f.begin(); itSubsystem_1d0c!= _subsystem_1d06.end(), itMain_1d15!= _main_1d0f.end(); ++itSubsystem_1d0c, ++itMain_1d15)
	{
		if( ( *itSubsystem_1d0c== subsystem_1d0a)&& ( *itMain_1d15== main_1d13))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1d06.push_back( subsystem_1d0a);
		_main_1d0f.push_back( main_1d13);
	}
	return isUnique;
}

bool PassThroughs_1d01::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void PassThroughs_1d01::processInputPackets( const Packets_t& subsystems_1d02, const Packets_t& mains_1d04)
{
	for( Packets_t::const_iterator itSubsystem_1d07= subsystems_1d02.begin(), itMain_1d10= mains_1d04.begin(); itSubsystem_1d07!= subsystems_1d02.end(), itMain_1d10!= mains_1d04.end(); ++itSubsystem_1d07, ++itMain_1d10)
	{
		bool isUnique= isInputUnique( *itSubsystem_1d07, *itMain_1d10);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1d07, *itMain_1d10);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool PassThroughs_1d01::patternMatcher( const Udm::Object& subsystem_1d08, const Udm::Object& main_1d11)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1d08.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1d0d= CyberComposition::Simulink::Subsystem::Cast( subsystem_1d08);
		if( false== Uml::IsDerivedFrom( main_1d11.type(), SFC::Function::meta))
			continue;
		SFC::Function main_1d16= SFC::Function::Cast( main_1d11);
		set< CyberComposition::Simulink::OutPort> outPorts_1d18= subsystem_1d0d.OutPort_kind_children();
		for( set< CyberComposition::Simulink::OutPort>::const_iterator itOutPort_1d19= outPorts_1d18.begin(); itOutPort_1d19!= outPorts_1d18.end(); ++itOutPort_1d19)
		{
			CyberComposition::Simulink::OutPort currOutPort_1d1a= *itOutPort_1d19;
			set< CyberComposition::Simulink::InPort> inPorts_1d1b= subsystem_1d0d.InPort_kind_children();
			for( set< CyberComposition::Simulink::InPort>::const_iterator itInPort_1d1c= inPorts_1d1b.begin(); itInPort_1d1c!= inPorts_1d1b.end(); ++itInPort_1d1c)
			{
				CyberComposition::Simulink::InPort currInPort_1d1d= *itInPort_1d1c;
				set< SFC::Arg> outArgs_1d1e= currOutPort_1d1a.arg();
				for( set< SFC::Arg>::const_iterator itOutArgs_1d1f= outArgs_1d1e.begin(); itOutArgs_1d1f!= outArgs_1d1e.end(); ++itOutArgs_1d1f)
				{
					SFC::Arg currOutArg_1d20= *itOutArgs_1d1f;
					set< SFC::Arg> inArgs_1d21= currInPort_1d1d.arg();
					for( set< SFC::Arg>::const_iterator itInArgs_1d22= inArgs_1d21.begin(); itInArgs_1d22!= inArgs_1d21.end(); ++itInArgs_1d22)
					{
						SFC::Arg currInArg_1d23= *itInArgs_1d22;
						set< CyberComposition::Simulink::Line> lines_1d24= currInPort_1d1d.dstLine();
						for( set< CyberComposition::Simulink::Line>::const_iterator itLines_1d25= lines_1d24.begin(); itLines_1d25!= lines_1d24.end(); ++itLines_1d25)
						{
							CyberComposition::Simulink::Line currLine_1d26= *itLines_1d25;
							CyberComposition::Simulink::SF_Port outPort_1d27= currLine_1d26.dstLine_end();
							if( false== Uml::IsDerivedFrom( outPort_1d27.type(), CyberComposition::Simulink::OutPort::meta))
								continue;
							CyberComposition::Simulink::OutPort currOutPort_1d28= CyberComposition::Simulink::OutPort::Cast( outPort_1d27);
							if( currOutPort_1d1a!= currOutPort_1d28)
								continue;
							Match currMatch;
							set< pair<int, Udm::Object> > boundObjs_1d2c;
							if( !isValidBound(boundObjs_1d2c, subsystem_1d0d, true))
								continue;
							currMatch.subsystem_1d2d= subsystem_1d0d;
							if( !isValidBound(boundObjs_1d2c, main_1d16, true))
								continue;
							currMatch.main_1d2e= main_1d16;
							if( !isValidBound(boundObjs_1d2c, currLine_1d26, false))
								continue;
							currMatch.line_1d2f= currLine_1d26;
							if( !isValidBound(boundObjs_1d2c, currInPort_1d1d, false))
								continue;
							currMatch.inPort_1d30= currInPort_1d1d;
							if( !isValidBound(boundObjs_1d2c, currOutPort_1d1a, false))
								continue;
							currMatch.outPort_1d31= currOutPort_1d1a;
							if( !isValidBound(boundObjs_1d2c, currOutArg_1d20, false))
								continue;
							currMatch.outArg_1d32= currOutArg_1d20;
							if( !isValidBound(boundObjs_1d2c, currInArg_1d23, false))
								continue;
							currMatch.inArg_1d33= currInArg_1d23;
							_matches.push_back( currMatch);
						}
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void PassThroughs_1d01::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg& InArg= currMatch.inArg_1d33;
		CyberComposition::Simulink::InPort& InPort= currMatch.inPort_1d30;
		CyberComposition::Simulink::Line& Line= currMatch.line_1d2f;
		SFC::Function& Main= currMatch.main_1d2e;
		SFC::Arg& OutArg= currMatch.outArg_1d32;
		CyberComposition::Simulink::OutPort& OutPort= currMatch.outPort_1d31;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_1d2d;
		{
SFUtils::Assignment( Main, OutArg, InArg );
};
	}
}

void GetSortedBlocks_1d37::operator()( const Packets_t& subsystems_1d38, const Packets_t& mains_1d3c, Packets_t& subsystems_1d3a, Packets_t& childBlockss_1d3b, Packets_t& mains_1d3e)
{
#ifdef PRINT_INFO
	printLog( "GetSortedBlocks_1d37" );
#endif
	RTTGenerator::Instance()->generateRule(1591, "GetSortedBlocks");
	_subsystem_1d3f= &subsystems_1d3a;
	_childBlocks_1d40= &childBlockss_1d3b;
	_main_1d41= &mains_1d3e;
	processInputPackets( subsystems_1d38, mains_1d3c);
	sortOutputs( );
}

bool GetSortedBlocks_1d37::isInputUnique( const Udm::Object& subsystem_1d46, const Udm::Object& main_1d4f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1d48= _subsystem_1d42.begin(), itMain_1d51= _main_1d4b.begin(); itSubsystem_1d48!= _subsystem_1d42.end(), itMain_1d51!= _main_1d4b.end(); ++itSubsystem_1d48, ++itMain_1d51)
	{
		if( ( *itSubsystem_1d48== subsystem_1d46)&& ( *itMain_1d51== main_1d4f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1d42.push_back( subsystem_1d46);
		_main_1d4b.push_back( main_1d4f);
	}
	return isUnique;
}

bool GetSortedBlocks_1d37::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetSortedBlocks_1d37::processInputPackets( const Packets_t& subsystems_1d38, const Packets_t& mains_1d3c)
{
	for( Packets_t::const_iterator itSubsystem_1d43= subsystems_1d38.begin(), itMain_1d4c= mains_1d3c.begin(); itSubsystem_1d43!= subsystems_1d38.end(), itMain_1d4c!= mains_1d3c.end(); ++itSubsystem_1d43, ++itMain_1d4c)
	{
		bool isUnique= isInputUnique( *itSubsystem_1d43, *itMain_1d4c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1d43, *itMain_1d4c);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetSortedBlocks_1d37::patternMatcher( const Udm::Object& subsystem_1d44, const Udm::Object& main_1d4d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1d44.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1d49= CyberComposition::Simulink::Subsystem::Cast( subsystem_1d44);
		if( false== Uml::IsDerivedFrom( main_1d4d.type(), SFC::Function::meta))
			continue;
		SFC::Function main_1d52= SFC::Function::Cast( main_1d4d);
		set< CyberComposition::Simulink::Block> childBlockss_1d54= subsystem_1d49.Block_kind_children();
		for( set< CyberComposition::Simulink::Block>::const_iterator itChildBlocks_1d55= childBlockss_1d54.begin(); itChildBlocks_1d55!= childBlockss_1d54.end(); ++itChildBlocks_1d55)
		{
			CyberComposition::Simulink::Block currChildBlocks_1d56= *itChildBlocks_1d55;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1d5a;
			if( !isValidBound(boundObjs_1d5a, subsystem_1d49, true))
				continue;
			currMatch.subsystem_1d5b= subsystem_1d49;
			if( !isValidBound(boundObjs_1d5a, main_1d52, true))
				continue;
			currMatch.main_1d5c= main_1d52;
			if( !isValidBound(boundObjs_1d5a, currChildBlocks_1d56, false))
				continue;
			currMatch.childBlocks_1d5d= currChildBlocks_1d56;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetSortedBlocks_1d37::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_1d5b, currMatch.childBlocks_1d5d, currMatch.main_1d5c);
	}
}

void GetSortedBlocks_1d37::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_1d5e, const CyberComposition::Simulink::Block& childBlocks_1d60, const SFC::Function& main_1d62)
{
	_subsystem_1d3f->push_back( subsystem_1d5e);
	_childBlocks_1d40->push_back( childBlocks_1d60);
	_main_1d41->push_back( main_1d62);
}

void GetSortedBlocks_1d37::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::Block, std::pointer_to_binary_function< const CyberComposition::Simulink::Block&, const CyberComposition::Simulink::Block&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::Block&, const CyberComposition::Simulink::Block&, bool> ptr_TopologicalSort( TopologicalSort< CyberComposition::Simulink::Block>);
	SortedSet_t sortedSet( ptr_TopologicalSort);
	std::vector< int> permutationVector( _childBlocks_1d40->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _childBlocks_1d40->begin(); it!= _childBlocks_1d40->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::Block::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _childBlocks_1d40->begin());
	// order rest of the containers
	permutate( permutationVector, *_subsystem_1d3f);
	permutate( permutationVector, *_main_1d41);
}

void DoTopologicalSort_1d64::operator()( const Packets_t& subsystems_1d65, const Packets_t& mains_1d68, Packets_t& subsystems_1d67, Packets_t& mains_1d6a)
{
#ifdef PRINT_INFO
	printLog( "DoTopologicalSort_1d64" );
#endif
	RTTGenerator::Instance()->generateRule(1596, "DoTopologicalSort");
	_subsystem_1d6b= &subsystems_1d67;
	_main_1d6c= &mains_1d6a;
	processInputPackets( subsystems_1d65, mains_1d68);
	forwardInputs( );
}

bool DoTopologicalSort_1d64::isInputUnique( const Udm::Object& subsystem_1d71, const Udm::Object& main_1d7a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1d73= _subsystem_1d6d.begin(), itMain_1d7c= _main_1d76.begin(); itSubsystem_1d73!= _subsystem_1d6d.end(), itMain_1d7c!= _main_1d76.end(); ++itSubsystem_1d73, ++itMain_1d7c)
	{
		if( ( *itSubsystem_1d73== subsystem_1d71)&& ( *itMain_1d7c== main_1d7a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1d6d.push_back( subsystem_1d71);
		_main_1d76.push_back( main_1d7a);
	}
	return isUnique;
}

bool DoTopologicalSort_1d64::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void DoTopologicalSort_1d64::processInputPackets( const Packets_t& subsystems_1d65, const Packets_t& mains_1d68)
{
	for( Packets_t::const_iterator itSubsystem_1d6e= subsystems_1d65.begin(), itMain_1d77= mains_1d68.begin(); itSubsystem_1d6e!= subsystems_1d65.end(), itMain_1d77!= mains_1d68.end(); ++itSubsystem_1d6e, ++itMain_1d77)
	{
		bool isUnique= isInputUnique( *itSubsystem_1d6e, *itMain_1d77);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1d6e, *itMain_1d77);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool DoTopologicalSort_1d64::patternMatcher( const Udm::Object& subsystem_1d6f, const Udm::Object& main_1d78)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1d6f.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1d74= CyberComposition::Simulink::Subsystem::Cast( subsystem_1d6f);
		if( false== Uml::IsDerivedFrom( main_1d78.type(), SFC::Function::meta))
			continue;
		SFC::Function main_1d7d= SFC::Function::Cast( main_1d78);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1d82;
		if( !isValidBound(boundObjs_1d82, subsystem_1d74, true))
			continue;
		currMatch.subsystem_1d83= subsystem_1d74;
		if( !isValidBound(boundObjs_1d82, main_1d7d, true))
			continue;
		currMatch.main_1d84= main_1d7d;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void DoTopologicalSort_1d64::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function& Main= currMatch.main_1d84;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_1d83;
		{
SFUtils::DoTopologicalSort(Subsystem);
};
	}
}

void DoTopologicalSort_1d64::forwardInputs()
{
	*_subsystem_1d6b= _subsystem_1d6d;
	*_main_1d6c= _main_1d76;
}

void CreatePreDelayExec_1d85::operator()( const Packets_t& systems_1d86, const Packets_t& systemFunctions_1d88, Packets_t& systems_1d8a, Packets_t& systemFunctions_1d8b)
{
#ifdef PRINT_INFO
	printLog( "CreatePreDelayExec_1d85" );
#endif
	_system_1d8c= &systems_1d8a;
	_systemFunction_1d8d= &systemFunctions_1d8b;
	_system_1d8c->insert( _system_1d8c->end(), systems_1d86.begin(), systems_1d86.end());
	_systemFunction_1d8d->insert( _systemFunction_1d8d->end(), systemFunctions_1d88.begin(), systemFunctions_1d88.end());
	if( ( !systems_1d86.empty())&& ( !systemFunctions_1d88.empty()))
		callGetDelayBlocks_52bf( systems_1d86, systemFunctions_1d88);
}

void CreatePreDelayExec_1d85::callGetDelayBlocks_52bf( const Packets_t& subsystems_1d8f, const Packets_t& mains_1d93)
{
	Packets_t subsystems_1d91;
	Packets_t childBlockss_1d92;
	Packets_t mains_1d95;
	GetDelayBlocks_1d8e getDelayBlocks_1d8e;
	getDelayBlocks_1d8e( subsystems_1d8f, mains_1d93, subsystems_1d91, childBlockss_1d92, mains_1d95);
	if( ( !subsystems_1d91.empty())&& ( !childBlockss_1d92.empty())&& ( !mains_1d95.empty()))
		callCreateBlockExecution_52c2( subsystems_1d91, childBlockss_1d92, mains_1d95);
}

void CreatePreDelayExec_1d85::callCreateBlockExecution_52c2( const Packets_t& systems_1de3, const Packets_t& childBlockss_1de5, const Packets_t& systemFunctions_1de7)
{
	Packets_t systems_1de9;
	Packets_t systemFunctions_1dea;
	CreateBlockExecution_1de2 createBlockExecution_1de2;
	createBlockExecution_1de2( systems_1de3, childBlockss_1de5, systemFunctions_1de7, systems_1de9, systemFunctions_1dea);
	if( ( !systems_1de9.empty())&& ( !systemFunctions_1dea.empty()))
		callResetDelayBlockType_52c6( systems_1de9, systemFunctions_1dea);
}

void CreatePreDelayExec_1d85::callResetDelayBlockType_52c6( const Packets_t& subsystems_1dbf, const Packets_t& mains_1dc1)
{
	ResetDelayBlockType_1dbe resetDelayBlockType_1dbe;
	resetDelayBlockType_1dbe( subsystems_1dbf, mains_1dc1);
}

void GetDelayBlocks_1d8e::operator()( const Packets_t& subsystems_1d8f, const Packets_t& mains_1d93, Packets_t& subsystems_1d91, Packets_t& childBlockss_1d92, Packets_t& mains_1d95)
{
#ifdef PRINT_INFO
	printLog( "GetDelayBlocks_1d8e" );
#endif
	RTTGenerator::Instance()->generateRule(1605, "GetDelayBlocks");
	_subsystem_1d96= &subsystems_1d91;
	_childBlocks_1d97= &childBlockss_1d92;
	_main_1d98= &mains_1d95;
	processInputPackets( subsystems_1d8f, mains_1d93);
}

bool GetDelayBlocks_1d8e::isInputUnique( const Udm::Object& subsystem_1d9d, const Udm::Object& main_1da6)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1d9f= _subsystem_1d99.begin(), itMain_1da8= _main_1da2.begin(); itSubsystem_1d9f!= _subsystem_1d99.end(), itMain_1da8!= _main_1da2.end(); ++itSubsystem_1d9f, ++itMain_1da8)
	{
		if( ( *itSubsystem_1d9f== subsystem_1d9d)&& ( *itMain_1da8== main_1da6))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1d99.push_back( subsystem_1d9d);
		_main_1da2.push_back( main_1da6);
	}
	return isUnique;
}

bool GetDelayBlocks_1d8e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool GetDelayBlocks_1d8e::isGuardTrue( CyberComposition::Simulink::Primitive& ChildBlocks, SFC::Function& Main, CyberComposition::Simulink::Subsystem& Subsystem)
{
	bool Gz_guard= false;
	Gz_guard = false;
std::string bt = ChildBlocks.BlockType();
if (bt.compare("UnitDelay") == 0)
   Gz_guard = true;;
	return Gz_guard;
}

void GetDelayBlocks_1d8e::processInputPackets( const Packets_t& subsystems_1d8f, const Packets_t& mains_1d93)
{
	for( Packets_t::const_iterator itSubsystem_1d9a= subsystems_1d8f.begin(), itMain_1da3= mains_1d93.begin(); itSubsystem_1d9a!= subsystems_1d8f.end(), itMain_1da3!= mains_1d93.end(); ++itSubsystem_1d9a, ++itMain_1da3)
	{
		bool isUnique= isInputUnique( *itSubsystem_1d9a, *itMain_1da3);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1d9a, *itMain_1da3);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetDelayBlocks_1d8e::patternMatcher( const Udm::Object& subsystem_1d9b, const Udm::Object& main_1da4)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1d9b.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1da0= CyberComposition::Simulink::Subsystem::Cast( subsystem_1d9b);
		if( false== Uml::IsDerivedFrom( main_1da4.type(), SFC::Function::meta))
			continue;
		SFC::Function main_1da9= SFC::Function::Cast( main_1da4);
		set< CyberComposition::Simulink::Primitive> childBlockss_1dab= subsystem_1da0.Primitive_kind_children();
		for( set< CyberComposition::Simulink::Primitive>::const_iterator itChildBlocks_1dac= childBlockss_1dab.begin(); itChildBlocks_1dac!= childBlockss_1dab.end(); ++itChildBlocks_1dac)
		{
			CyberComposition::Simulink::Primitive currChildBlocks_1dad= *itChildBlocks_1dac;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1db1;
			if( !isValidBound(boundObjs_1db1, subsystem_1da0, true))
				continue;
			currMatch.subsystem_1db2= subsystem_1da0;
			if( !isValidBound(boundObjs_1db1, main_1da9, true))
				continue;
			currMatch.main_1db3= main_1da9;
			if( !isValidBound(boundObjs_1db1, currChildBlocks_1dad, false))
				continue;
			currMatch.childBlocks_1db4= currChildBlocks_1dad;
			bool Gz_guard= isGuardTrue( currMatch.childBlocks_1db4, currMatch.main_1db3, currMatch.subsystem_1db2);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetDelayBlocks_1d8e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		CyberComposition::Simulink::Primitive& ChildBlocks= currMatch.childBlocks_1db4;
		SFC::Function& Main= currMatch.main_1db3;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_1db2;
		{
std::string bt = ChildBlocks.BlockType();
ChildBlocks.BlockType() = bt + "Pre";
};
		outputAppender( currMatch.subsystem_1db2, currMatch.childBlocks_1db4, currMatch.main_1db3);
	}
}

void GetDelayBlocks_1d8e::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_1db8, const CyberComposition::Simulink::Primitive& childBlocks_1dba, const SFC::Function& main_1dbc)
{
	_subsystem_1d96->push_back( subsystem_1db8);
	_childBlocks_1d97->push_back( childBlocks_1dba);
	_main_1d98->push_back( main_1dbc);
}

void ResetDelayBlockType_1dbe::operator()( const Packets_t& subsystems_1dbf, const Packets_t& mains_1dc1)
{
#ifdef PRINT_INFO
	printLog( "ResetDelayBlockType_1dbe" );
#endif
	RTTGenerator::Instance()->generateRule(1611, "ResetDelayBlockType");
	processInputPackets( subsystems_1dbf, mains_1dc1);
}

bool ResetDelayBlockType_1dbe::isInputUnique( const Udm::Object& subsystem_1dc7, const Udm::Object& main_1dd0)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1dc9= _subsystem_1dc3.begin(), itMain_1dd2= _main_1dcc.begin(); itSubsystem_1dc9!= _subsystem_1dc3.end(), itMain_1dd2!= _main_1dcc.end(); ++itSubsystem_1dc9, ++itMain_1dd2)
	{
		if( ( *itSubsystem_1dc9== subsystem_1dc7)&& ( *itMain_1dd2== main_1dd0))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1dc3.push_back( subsystem_1dc7);
		_main_1dcc.push_back( main_1dd0);
	}
	return isUnique;
}

bool ResetDelayBlockType_1dbe::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool ResetDelayBlockType_1dbe::isGuardTrue( CyberComposition::Simulink::Primitive& ChildBlocks, SFC::Function& Main, CyberComposition::Simulink::Subsystem& Subsystem)
{
	bool Gz_guard= false;
	Gz_guard = false;
std::string bt = ChildBlocks.BlockType();
if (bt.compare("UnitDelayPre") == 0)
   Gz_guard = true;;
	return Gz_guard;
}

void ResetDelayBlockType_1dbe::processInputPackets( const Packets_t& subsystems_1dbf, const Packets_t& mains_1dc1)
{
	for( Packets_t::const_iterator itSubsystem_1dc4= subsystems_1dbf.begin(), itMain_1dcd= mains_1dc1.begin(); itSubsystem_1dc4!= subsystems_1dbf.end(), itMain_1dcd!= mains_1dc1.end(); ++itSubsystem_1dc4, ++itMain_1dcd)
	{
		bool isUnique= isInputUnique( *itSubsystem_1dc4, *itMain_1dcd);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1dc4, *itMain_1dcd);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ResetDelayBlockType_1dbe::patternMatcher( const Udm::Object& subsystem_1dc5, const Udm::Object& main_1dce)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1dc5.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1dca= CyberComposition::Simulink::Subsystem::Cast( subsystem_1dc5);
		if( false== Uml::IsDerivedFrom( main_1dce.type(), SFC::Function::meta))
			continue;
		SFC::Function main_1dd3= SFC::Function::Cast( main_1dce);
		set< CyberComposition::Simulink::Primitive> childBlockss_1dd5= subsystem_1dca.Primitive_kind_children();
		for( set< CyberComposition::Simulink::Primitive>::const_iterator itChildBlocks_1dd6= childBlockss_1dd5.begin(); itChildBlocks_1dd6!= childBlockss_1dd5.end(); ++itChildBlocks_1dd6)
		{
			CyberComposition::Simulink::Primitive currChildBlocks_1dd7= *itChildBlocks_1dd6;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1ddb;
			if( !isValidBound(boundObjs_1ddb, subsystem_1dca, true))
				continue;
			currMatch.subsystem_1ddc= subsystem_1dca;
			if( !isValidBound(boundObjs_1ddb, main_1dd3, true))
				continue;
			currMatch.main_1ddd= main_1dd3;
			if( !isValidBound(boundObjs_1ddb, currChildBlocks_1dd7, false))
				continue;
			currMatch.childBlocks_1dde= currChildBlocks_1dd7;
			bool Gz_guard= isGuardTrue( currMatch.childBlocks_1dde, currMatch.main_1ddd, currMatch.subsystem_1ddc);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void ResetDelayBlockType_1dbe::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		CyberComposition::Simulink::Primitive& ChildBlocks= currMatch.childBlocks_1dde;
		SFC::Function& Main= currMatch.main_1ddd;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_1ddc;
		{
std::string bt = ChildBlocks.BlockType();
/* erase "Pre" */
bt.erase( bt.find("Pre"), std::string::npos );
printLog( bt );
ChildBlocks.BlockType() = bt;

};
	}
}

void CreateBlockExecution_1de2::operator()( const Packets_t& systems_1de3, const Packets_t& childBlockss_1de5, const Packets_t& systemFunctions_1de7, Packets_t& systems_1de9, Packets_t& systemFunctions_1dea)
{
#ifdef PRINT_INFO
	printLog( "CreateBlockExecution_1de2" );
#endif
	_system_1deb= &systems_1de9;
	_systemFunction_1dec= &systemFunctions_1dea;
	for( Packets_t::const_iterator itsystem_1dee= systems_1de3.begin(), itchildBlocks_1df5= childBlockss_1de5.begin(), itsystemFunction_1dfc= systemFunctions_1de7.begin(); itsystem_1dee!= systems_1de3.end(), itchildBlocks_1df5!= childBlockss_1de5.end(), itsystemFunction_1dfc!= systemFunctions_1de7.end(); ++itsystem_1dee, ++itchildBlocks_1df5, ++itsystemFunction_1dfc)
	{
		bool isUnique= isInputUnique( *itsystem_1dee, *itchildBlocks_1df5, *itsystemFunction_1dfc);
		if( !isUnique)
			continue;
		Packets_t onesystem_1df2( 1, *itsystem_1dee);
		Packets_t onechildBlocks_1df9( 1, *itchildBlocks_1df5);
		Packets_t onesystemFunction_1e00( 1, *itsystemFunction_1dfc);
		executeOne( onesystem_1df2, onechildBlocks_1df9, onesystemFunction_1e00);
	}
}

void CreateBlockExecution_1de2::executeOne( const Packets_t& systems_1de3, const Packets_t& childBlockss_1de5, const Packets_t& systemFunctions_1de7)
{
	if( ( !systems_1de3.empty())&& ( !childBlockss_1de5.empty())&& ( !systemFunctions_1de7.empty()))
		callTestChildBlock_52ac( systems_1de3, childBlockss_1de5, systemFunctions_1de7);
	_system_1deb->insert( _system_1deb->end(), systems_1de3.begin(), systems_1de3.end());
	_systemFunction_1dec->insert( _systemFunction_1dec->end(), systemFunctions_1de7.begin(), systemFunctions_1de7.end());
}

bool CreateBlockExecution_1de2::isInputUnique( const Udm::Object& system_1def, const Udm::Object& childBlocks_1df6, const Udm::Object& systemFunction_1dfd)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itsystem_1df1= _system_1ded.begin(), itchildBlocks_1df8= _childBlocks_1df4.begin(), itsystemFunction_1dff= _systemFunction_1dfb.begin(); itsystem_1df1!= _system_1ded.end(), itchildBlocks_1df8!= _childBlocks_1df4.end(), itsystemFunction_1dff!= _systemFunction_1dfb.end(); ++itsystem_1df1, ++itchildBlocks_1df8, ++itsystemFunction_1dff)
	{
		if( ( *itsystem_1df1== system_1def)&& ( *itchildBlocks_1df8== childBlocks_1df6)&& ( *itsystemFunction_1dff== systemFunction_1dfd))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_system_1ded.push_back( system_1def);
		_childBlocks_1df4.push_back( childBlocks_1df6);
		_systemFunction_1dfb.push_back( systemFunction_1dfd);
	}
	return isUnique;
}

void CreateBlockExecution_1de2::callTestChildBlock_52ac( const Packets_t& systems_1e03, const Packets_t& childBlocks_1e05, const Packets_t& systemFunctions_1e07)
{
	Packets_t systems_1e09;
	Packets_t childCharts_1e0a;
	Packets_t systemFunctions_1e0b;
	Packets_t systems_1e0c;
	Packets_t childCharts_1e0d;
	Packets_t systemFunctions_1e0e;
	Packets_t systems_1e0f;
	Packets_t childSubsystems_1e10;
	Packets_t systemFunctions_1e11;
	Packets_t systems_1e12;
	Packets_t childBlocks_1e13;
	Packets_t systemFunctions_1e14;
	TestChildBlock_1e02 testChildBlock_1e02;
	testChildBlock_1e02( systems_1e03, childBlocks_1e05, systemFunctions_1e07, systems_1e09, childCharts_1e0a, systemFunctions_1e0b, systems_1e0c, childCharts_1e0d, systemFunctions_1e0e, systems_1e0f, childSubsystems_1e10, systemFunctions_1e11, systems_1e12, childBlocks_1e13, systemFunctions_1e14);
	if( ( !childBlocks_1e13.empty())&& ( !systemFunctions_1e14.empty()))
		callPrimitiveChildBlock_52b0( childBlocks_1e13, systemFunctions_1e14);
	if( ( !systems_1e0f.empty())&& ( !childSubsystems_1e10.empty())&& ( !systemFunctions_1e11.empty()))
		callSubsystemChildBlock_52b3( systems_1e0f, childSubsystems_1e10, systemFunctions_1e11);
	if( ( !systems_1e09.empty())&& ( !childCharts_1e0a.empty())&& ( !systemFunctions_1e0b.empty()))
		callChartChildBlock_52b7( systems_1e09, childCharts_1e0a, systemFunctions_1e0b);
	if( ( !systems_1e0c.empty())&& ( !childCharts_1e0d.empty())&& ( !systemFunctions_1e0e.empty()))
		callSFChartChildBlock_52bb( systems_1e0c, childCharts_1e0d, systemFunctions_1e0e);
}

void CreateBlockExecution_1de2::callPrimitiveChildBlock_52b0( const Packets_t& childPrimitives_2e03, const Packets_t& systemFunctions_2e05)
{
	PrimitiveChildBlock_2e02 primitiveChildBlock_2e02;
	primitiveChildBlock_2e02( childPrimitives_2e03, systemFunctions_2e05);
}

void CreateBlockExecution_1de2::callSubsystemChildBlock_52b3( const Packets_t& systems_1f17, const Packets_t& childSubsystems_1f19, const Packets_t& systemFunctions_1f1b)
{
	SubsystemChildBlock_1f16 subsystemChildBlock_1f16;
	subsystemChildBlock_1f16( systems_1f17, childSubsystems_1f19, systemFunctions_1f1b);
}

void CreateBlockExecution_1de2::callChartChildBlock_52b7( const Packets_t& systems_305d, const Packets_t& childCharts_305f, const Packets_t& systemFunctions_3061)
{
	ChartChildBlock_305c chartChildBlock_305c;
	chartChildBlock_305c( systems_305d, childCharts_305f, systemFunctions_3061);
}

void CreateBlockExecution_1de2::callSFChartChildBlock_52bb( const Packets_t& systems_4187, const Packets_t& childCharts_4189, const Packets_t& systemFunctions_418b)
{
	SFChartChildBlock_4186 sFChartChildBlock_4186;
	sFChartChildBlock_4186( systems_4187, childCharts_4189, systemFunctions_418b);
}

void TestChildBlock_1e02::operator()( const Packets_t& systems_1e03, const Packets_t& childBlocks_1e05, const Packets_t& systemFunctions_1e07, Packets_t& systems_1e09, Packets_t& childCharts_1e0a, Packets_t& systemFunctions_1e0b, Packets_t& systems_1e0c, Packets_t& childCharts_1e0d, Packets_t& systemFunctions_1e0e, Packets_t& systems_1e0f, Packets_t& childSubsystems_1e10, Packets_t& systemFunctions_1e11, Packets_t& systems_1e12, Packets_t& childBlocks_1e13, Packets_t& systemFunctions_1e14)
{
#ifdef PRINT_INFO
	printLog( "TestChildBlock_1e02" );
#endif
	_system_1e15= &systems_1e09;
	_childChart_1e16= &childCharts_1e0a;
	_systemFunction_1e17= &systemFunctions_1e0b;
	_system_1e18= &systems_1e0c;
	_childChart_1e19= &childCharts_1e0d;
	_systemFunction_1e1a= &systemFunctions_1e0e;
	_system_1e1b= &systems_1e0f;
	_childSubsystem_1e1c= &childSubsystems_1e10;
	_systemFunction_1e1d= &systemFunctions_1e11;
	_system_1e1e= &systems_1e12;
	_childBlock_1e1f= &childBlocks_1e13;
	_systemFunction_1e20= &systemFunctions_1e14;
	for( Packets_t::const_iterator itsystem_1e22= systems_1e03.begin(), itchildBlock_1e29= childBlocks_1e05.begin(), itsystemFunction_1e30= systemFunctions_1e07.begin(); itsystem_1e22!= systems_1e03.end(), itchildBlock_1e29!= childBlocks_1e05.end(), itsystemFunction_1e30!= systemFunctions_1e07.end(); ++itsystem_1e22, ++itchildBlock_1e29, ++itsystemFunction_1e30)
	{
		bool isUnique= isInputUnique( *itsystem_1e22, *itchildBlock_1e29, *itsystemFunction_1e30);
		if( !isUnique)
			continue;
		Packets_t onesystem_1e26( 1, *itsystem_1e22);
		Packets_t onechildBlock_1e2d( 1, *itchildBlock_1e29);
		Packets_t onesystemFunction_1e34( 1, *itsystemFunction_1e30);
		executeOne( onesystem_1e26, onechildBlock_1e2d, onesystemFunction_1e34);
	}
}

void TestChildBlock_1e02::executeOne( const Packets_t& systems_1e03, const Packets_t& childBlocks_1e05, const Packets_t& systemFunctions_1e07)
{
	Packets_t subsystems_1e39;
	Packets_t blocks_1e3c;
	Packets_t mains_1e3f;
	IsChart_1e36 isChart_1e36;
	bool isMatchIsChart_1e36= isChart_1e36( systems_1e03, childBlocks_1e05, systemFunctions_1e07, subsystems_1e39, blocks_1e3c, mains_1e3f);
	_system_1e15->insert( _system_1e15->end(), subsystems_1e39.begin(), subsystems_1e39.end());
	_childChart_1e16->insert( _childChart_1e16->end(), blocks_1e3c.begin(), blocks_1e3c.end());
	_systemFunction_1e17->insert( _systemFunction_1e17->end(), mains_1e3f.begin(), mains_1e3f.end());
	if( isMatchIsChart_1e36)
		return;
	Packets_t subsystems_1e76;
	Packets_t blocks_1e79;
	Packets_t mains_1e7c;
	IsSFChart_1e73 isSFChart_1e73;
	bool isMatchIsSFChart_1e73= isSFChart_1e73( systems_1e03, childBlocks_1e05, systemFunctions_1e07, subsystems_1e76, blocks_1e79, mains_1e7c);
	_system_1e18->insert( _system_1e18->end(), subsystems_1e76.begin(), subsystems_1e76.end());
	_childChart_1e19->insert( _childChart_1e19->end(), blocks_1e79.begin(), blocks_1e79.end());
	_systemFunction_1e1a->insert( _systemFunction_1e1a->end(), mains_1e7c.begin(), mains_1e7c.end());
	if( isMatchIsSFChart_1e73)
		return;
	Packets_t subsystems_1eaf;
	Packets_t blocks_1eb2;
	Packets_t mains_1eb5;
	IsSubsystem_1eac isSubsystem_1eac;
	bool isMatchIsSubsystem_1eac= isSubsystem_1eac( systems_1e03, childBlocks_1e05, systemFunctions_1e07, subsystems_1eaf, blocks_1eb2, mains_1eb5);
	_system_1e1b->insert( _system_1e1b->end(), subsystems_1eaf.begin(), subsystems_1eaf.end());
	_childSubsystem_1e1c->insert( _childSubsystem_1e1c->end(), blocks_1eb2.begin(), blocks_1eb2.end());
	_systemFunction_1e1d->insert( _systemFunction_1e1d->end(), mains_1eb5.begin(), mains_1eb5.end());
	if( isMatchIsSubsystem_1eac)
		return;
	Packets_t subsystems_1ee4;
	Packets_t blocks_1ee7;
	Packets_t mains_1eea;
	Otherwise_1ee1 otherwise_1ee1;
	bool isMatchOtherwise_1ee1= otherwise_1ee1( systems_1e03, childBlocks_1e05, systemFunctions_1e07, subsystems_1ee4, blocks_1ee7, mains_1eea);
	_system_1e1e->insert( _system_1e1e->end(), subsystems_1ee4.begin(), subsystems_1ee4.end());
	_childBlock_1e1f->insert( _childBlock_1e1f->end(), blocks_1ee7.begin(), blocks_1ee7.end());
	_systemFunction_1e20->insert( _systemFunction_1e20->end(), mains_1eea.begin(), mains_1eea.end());
}

bool TestChildBlock_1e02::isInputUnique( const Udm::Object& system_1e23, const Udm::Object& childBlock_1e2a, const Udm::Object& systemFunction_1e31)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itsystem_1e25= _system_1e21.begin(), itchildBlock_1e2c= _childBlock_1e28.begin(), itsystemFunction_1e33= _systemFunction_1e2f.begin(); itsystem_1e25!= _system_1e21.end(), itchildBlock_1e2c!= _childBlock_1e28.end(), itsystemFunction_1e33!= _systemFunction_1e2f.end(); ++itsystem_1e25, ++itchildBlock_1e2c, ++itsystemFunction_1e33)
	{
		if( ( *itsystem_1e25== system_1e23)&& ( *itchildBlock_1e2c== childBlock_1e2a)&& ( *itsystemFunction_1e33== systemFunction_1e31))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_system_1e21.push_back( system_1e23);
		_childBlock_1e28.push_back( childBlock_1e2a);
		_systemFunction_1e2f.push_back( systemFunction_1e31);
	}
	return isUnique;
}

bool IsChart_1e36::operator()( const Packets_t& subsystems_1e37, const Packets_t& blocks_1e3a, const Packets_t& mains_1e3d, Packets_t& subsystems_1e39, Packets_t& blocks_1e3c, Packets_t& mains_1e3f)
{
#ifdef PRINT_INFO
	printLog( "IsChart_1e36" );
#endif
	_subsystem_1e40= &subsystems_1e39;
	_block_1e41= &blocks_1e3c;
	_main_1e42= &mains_1e3f;
	processInputPackets( subsystems_1e37, blocks_1e3a, mains_1e3d);
	if( false== _matches.empty())
		return true;
	return false;
}

bool IsChart_1e36::isInputUnique( const Udm::Object& subsystem_1e47, const Udm::Object& block_1e50, const Udm::Object& main_1e59)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1e49= _subsystem_1e43.begin(), itBlock_1e52= _block_1e4c.begin(), itMain_1e5b= _main_1e55.begin(); itSubsystem_1e49!= _subsystem_1e43.end(), itBlock_1e52!= _block_1e4c.end(), itMain_1e5b!= _main_1e55.end(); ++itSubsystem_1e49, ++itBlock_1e52, ++itMain_1e5b)
	{
		if( ( *itSubsystem_1e49== subsystem_1e47)&& ( *itBlock_1e52== block_1e50)&& ( *itMain_1e5b== main_1e59))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1e43.push_back( subsystem_1e47);
		_block_1e4c.push_back( block_1e50);
		_main_1e55.push_back( main_1e59);
	}
	return isUnique;
}

bool IsChart_1e36::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void IsChart_1e36::processInputPackets( const Packets_t& subsystems_1e37, const Packets_t& blocks_1e3a, const Packets_t& mains_1e3d)
{
	for( Packets_t::const_iterator itSubsystem_1e44= subsystems_1e37.begin(), itBlock_1e4d= blocks_1e3a.begin(), itMain_1e56= mains_1e3d.begin(); itSubsystem_1e44!= subsystems_1e37.end(), itBlock_1e4d!= blocks_1e3a.end(), itMain_1e56!= mains_1e3d.end(); ++itSubsystem_1e44, ++itBlock_1e4d, ++itMain_1e56)
	{
		bool isUnique= isInputUnique( *itSubsystem_1e44, *itBlock_1e4d, *itMain_1e56);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1e44, *itBlock_1e4d, *itMain_1e56);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_1e68, currMatch.block_1e69, currMatch.main_1e6a);
	}
}

bool IsChart_1e36::patternMatcher( const Udm::Object& subsystem_1e45, const Udm::Object& block_1e4e, const Udm::Object& main_1e57)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1e45.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1e4a= CyberComposition::Simulink::Subsystem::Cast( subsystem_1e45);
		if( false== Uml::IsDerivedFrom( block_1e4e.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem block_1e53= CyberComposition::Simulink::Subsystem::Cast( block_1e4e);
		if( false== Uml::IsDerivedFrom( main_1e57.type(), SFC::Function::meta))
			continue;
		SFC::Function main_1e5c= SFC::Function::Cast( main_1e57);
		set< CyberComposition::Simulink::Primitive> primitives_1e5e= block_1e53.Primitive_kind_children();
		for( set< CyberComposition::Simulink::Primitive>::const_iterator itPrimitive_1e5f= primitives_1e5e.begin(); itPrimitive_1e5f!= primitives_1e5e.end(); ++itPrimitive_1e5f)
		{
			CyberComposition::Simulink::Primitive currPrimitive_1e60= *itPrimitive_1e5f;
			set< CyberComposition::Simulink::State> states_1e61= currPrimitive_1e60.State_kind_children();
			for( set< CyberComposition::Simulink::State>::const_iterator itState_1e62= states_1e61.begin(); itState_1e62!= states_1e61.end(); ++itState_1e62)
			{
				CyberComposition::Simulink::State currState_1e63= *itState_1e62;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_1e67;
				if( !isValidBound(boundObjs_1e67, subsystem_1e4a, true))
					continue;
				currMatch.subsystem_1e68= subsystem_1e4a;
				if( !isValidBound(boundObjs_1e67, block_1e53, true))
					continue;
				currMatch.block_1e69= block_1e53;
				if( !isValidBound(boundObjs_1e67, main_1e5c, true))
					continue;
				currMatch.main_1e6a= main_1e5c;
				if( !isValidBound(boundObjs_1e67, currPrimitive_1e60, false))
					continue;
				currMatch.primitive_1e6b= currPrimitive_1e60;
				if( !isValidBound(boundObjs_1e67, currState_1e63, false))
					continue;
				currMatch.state_1e6c= currState_1e63;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void IsChart_1e36::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_1e6d, const CyberComposition::Simulink::Subsystem& block_1e6f, const SFC::Function& main_1e71)
{
	_subsystem_1e40->push_back( subsystem_1e6d);
	_block_1e41->push_back( block_1e6f);
	_main_1e42->push_back( main_1e71);
}

bool IsSFChart_1e73::operator()( const Packets_t& subsystems_1e74, const Packets_t& blocks_1e77, const Packets_t& mains_1e7a, Packets_t& subsystems_1e76, Packets_t& blocks_1e79, Packets_t& mains_1e7c)
{
#ifdef PRINT_INFO
	printLog( "IsSFChart_1e73" );
#endif
	_subsystem_1e7d= &subsystems_1e76;
	_block_1e7e= &blocks_1e79;
	_main_1e7f= &mains_1e7c;
	processInputPackets( subsystems_1e74, blocks_1e77, mains_1e7a);
	if( false== _matches.empty())
		return true;
	return false;
}

bool IsSFChart_1e73::isInputUnique( const Udm::Object& subsystem_1e84, const Udm::Object& block_1e8d, const Udm::Object& main_1e96)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1e86= _subsystem_1e80.begin(), itBlock_1e8f= _block_1e89.begin(), itMain_1e98= _main_1e92.begin(); itSubsystem_1e86!= _subsystem_1e80.end(), itBlock_1e8f!= _block_1e89.end(), itMain_1e98!= _main_1e92.end(); ++itSubsystem_1e86, ++itBlock_1e8f, ++itMain_1e98)
	{
		if( ( *itSubsystem_1e86== subsystem_1e84)&& ( *itBlock_1e8f== block_1e8d)&& ( *itMain_1e98== main_1e96))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1e80.push_back( subsystem_1e84);
		_block_1e89.push_back( block_1e8d);
		_main_1e92.push_back( main_1e96);
	}
	return isUnique;
}

bool IsSFChart_1e73::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void IsSFChart_1e73::processInputPackets( const Packets_t& subsystems_1e74, const Packets_t& blocks_1e77, const Packets_t& mains_1e7a)
{
	for( Packets_t::const_iterator itSubsystem_1e81= subsystems_1e74.begin(), itBlock_1e8a= blocks_1e77.begin(), itMain_1e93= mains_1e7a.begin(); itSubsystem_1e81!= subsystems_1e74.end(), itBlock_1e8a!= blocks_1e77.end(), itMain_1e93!= mains_1e7a.end(); ++itSubsystem_1e81, ++itBlock_1e8a, ++itMain_1e93)
	{
		bool isUnique= isInputUnique( *itSubsystem_1e81, *itBlock_1e8a, *itMain_1e93);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1e81, *itBlock_1e8a, *itMain_1e93);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_1ea2, currMatch.block_1ea3, currMatch.main_1ea4);
	}
}

bool IsSFChart_1e73::patternMatcher( const Udm::Object& subsystem_1e82, const Udm::Object& block_1e8b, const Udm::Object& main_1e94)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1e82.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1e87= CyberComposition::Simulink::Subsystem::Cast( subsystem_1e82);
		if( false== Uml::IsDerivedFrom( block_1e8b.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem block_1e90= CyberComposition::Simulink::Subsystem::Cast( block_1e8b);
		if( false== Uml::IsDerivedFrom( main_1e94.type(), SFC::Function::meta))
			continue;
		SFC::Function main_1e99= SFC::Function::Cast( main_1e94);
		set< CyberComposition::Simulink::SFState> states_1e9b= block_1e90.SFState_kind_children();
		for( set< CyberComposition::Simulink::SFState>::const_iterator itState_1e9c= states_1e9b.begin(); itState_1e9c!= states_1e9b.end(); ++itState_1e9c)
		{
			CyberComposition::Simulink::SFState currState_1e9d= *itState_1e9c;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1ea1;
			if( !isValidBound(boundObjs_1ea1, subsystem_1e87, true))
				continue;
			currMatch.subsystem_1ea2= subsystem_1e87;
			if( !isValidBound(boundObjs_1ea1, block_1e90, true))
				continue;
			currMatch.block_1ea3= block_1e90;
			if( !isValidBound(boundObjs_1ea1, main_1e99, true))
				continue;
			currMatch.main_1ea4= main_1e99;
			if( !isValidBound(boundObjs_1ea1, currState_1e9d, false))
				continue;
			currMatch.state_1ea5= currState_1e9d;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void IsSFChart_1e73::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_1ea6, const CyberComposition::Simulink::Subsystem& block_1ea8, const SFC::Function& main_1eaa)
{
	_subsystem_1e7d->push_back( subsystem_1ea6);
	_block_1e7e->push_back( block_1ea8);
	_main_1e7f->push_back( main_1eaa);
}

bool IsSubsystem_1eac::operator()( const Packets_t& subsystems_1ead, const Packets_t& blocks_1eb0, const Packets_t& mains_1eb3, Packets_t& subsystems_1eaf, Packets_t& blocks_1eb2, Packets_t& mains_1eb5)
{
#ifdef PRINT_INFO
	printLog( "IsSubsystem_1eac" );
#endif
	_subsystem_1eb6= &subsystems_1eaf;
	_block_1eb7= &blocks_1eb2;
	_main_1eb8= &mains_1eb5;
	processInputPackets( subsystems_1ead, blocks_1eb0, mains_1eb3);
	if( false== _matches.empty())
		return true;
	return false;
}

bool IsSubsystem_1eac::isInputUnique( const Udm::Object& subsystem_1ebd, const Udm::Object& block_1ec6, const Udm::Object& main_1ecf)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1ebf= _subsystem_1eb9.begin(), itBlock_1ec8= _block_1ec2.begin(), itMain_1ed1= _main_1ecb.begin(); itSubsystem_1ebf!= _subsystem_1eb9.end(), itBlock_1ec8!= _block_1ec2.end(), itMain_1ed1!= _main_1ecb.end(); ++itSubsystem_1ebf, ++itBlock_1ec8, ++itMain_1ed1)
	{
		if( ( *itSubsystem_1ebf== subsystem_1ebd)&& ( *itBlock_1ec8== block_1ec6)&& ( *itMain_1ed1== main_1ecf))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1eb9.push_back( subsystem_1ebd);
		_block_1ec2.push_back( block_1ec6);
		_main_1ecb.push_back( main_1ecf);
	}
	return isUnique;
}

bool IsSubsystem_1eac::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void IsSubsystem_1eac::processInputPackets( const Packets_t& subsystems_1ead, const Packets_t& blocks_1eb0, const Packets_t& mains_1eb3)
{
	for( Packets_t::const_iterator itSubsystem_1eba= subsystems_1ead.begin(), itBlock_1ec3= blocks_1eb0.begin(), itMain_1ecc= mains_1eb3.begin(); itSubsystem_1eba!= subsystems_1ead.end(), itBlock_1ec3!= blocks_1eb0.end(), itMain_1ecc!= mains_1eb3.end(); ++itSubsystem_1eba, ++itBlock_1ec3, ++itMain_1ecc)
	{
		bool isUnique= isInputUnique( *itSubsystem_1eba, *itBlock_1ec3, *itMain_1ecc);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1eba, *itBlock_1ec3, *itMain_1ecc);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_1ed8, currMatch.block_1ed9, currMatch.main_1eda);
	}
}

bool IsSubsystem_1eac::patternMatcher( const Udm::Object& subsystem_1ebb, const Udm::Object& block_1ec4, const Udm::Object& main_1ecd)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1ebb.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1ec0= CyberComposition::Simulink::Subsystem::Cast( subsystem_1ebb);
		if( false== Uml::IsDerivedFrom( block_1ec4.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem block_1ec9= CyberComposition::Simulink::Subsystem::Cast( block_1ec4);
		if( false== Uml::IsDerivedFrom( main_1ecd.type(), SFC::Function::meta))
			continue;
		SFC::Function main_1ed2= SFC::Function::Cast( main_1ecd);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1ed7;
		if( !isValidBound(boundObjs_1ed7, subsystem_1ec0, true))
			continue;
		currMatch.subsystem_1ed8= subsystem_1ec0;
		if( !isValidBound(boundObjs_1ed7, block_1ec9, true))
			continue;
		currMatch.block_1ed9= block_1ec9;
		if( !isValidBound(boundObjs_1ed7, main_1ed2, true))
			continue;
		currMatch.main_1eda= main_1ed2;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void IsSubsystem_1eac::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_1edb, const CyberComposition::Simulink::Subsystem& block_1edd, const SFC::Function& main_1edf)
{
	_subsystem_1eb6->push_back( subsystem_1edb);
	_block_1eb7->push_back( block_1edd);
	_main_1eb8->push_back( main_1edf);
}

bool Otherwise_1ee1::operator()( const Packets_t& subsystems_1ee2, const Packets_t& blocks_1ee5, const Packets_t& mains_1ee8, Packets_t& subsystems_1ee4, Packets_t& blocks_1ee7, Packets_t& mains_1eea)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_1ee1" );
#endif
	_subsystem_1eeb= &subsystems_1ee4;
	_block_1eec= &blocks_1ee7;
	_main_1eed= &mains_1eea;
	processInputPackets( subsystems_1ee2, blocks_1ee5, mains_1ee8);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_1ee1::isInputUnique( const Udm::Object& subsystem_1ef2, const Udm::Object& block_1efb, const Udm::Object& main_1f04)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1ef4= _subsystem_1eee.begin(), itBlock_1efd= _block_1ef7.begin(), itMain_1f06= _main_1f00.begin(); itSubsystem_1ef4!= _subsystem_1eee.end(), itBlock_1efd!= _block_1ef7.end(), itMain_1f06!= _main_1f00.end(); ++itSubsystem_1ef4, ++itBlock_1efd, ++itMain_1f06)
	{
		if( ( *itSubsystem_1ef4== subsystem_1ef2)&& ( *itBlock_1efd== block_1efb)&& ( *itMain_1f06== main_1f04))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1eee.push_back( subsystem_1ef2);
		_block_1ef7.push_back( block_1efb);
		_main_1f00.push_back( main_1f04);
	}
	return isUnique;
}

bool Otherwise_1ee1::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_1ee1::processInputPackets( const Packets_t& subsystems_1ee2, const Packets_t& blocks_1ee5, const Packets_t& mains_1ee8)
{
	for( Packets_t::const_iterator itSubsystem_1eef= subsystems_1ee2.begin(), itBlock_1ef8= blocks_1ee5.begin(), itMain_1f01= mains_1ee8.begin(); itSubsystem_1eef!= subsystems_1ee2.end(), itBlock_1ef8!= blocks_1ee5.end(), itMain_1f01!= mains_1ee8.end(); ++itSubsystem_1eef, ++itBlock_1ef8, ++itMain_1f01)
	{
		bool isUnique= isInputUnique( *itSubsystem_1eef, *itBlock_1ef8, *itMain_1f01);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1eef, *itBlock_1ef8, *itMain_1f01);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_1f0d, currMatch.block_1f0e, currMatch.main_1f0f);
	}
}

bool Otherwise_1ee1::patternMatcher( const Udm::Object& subsystem_1ef0, const Udm::Object& block_1ef9, const Udm::Object& main_1f02)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1ef0.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1ef5= CyberComposition::Simulink::Subsystem::Cast( subsystem_1ef0);
		if( false== Uml::IsDerivedFrom( block_1ef9.type(), CyberComposition::Simulink::Block::meta))
			continue;
		CyberComposition::Simulink::Block block_1efe= CyberComposition::Simulink::Block::Cast( block_1ef9);
		if( false== Uml::IsDerivedFrom( main_1f02.type(), SFC::Function::meta))
			continue;
		SFC::Function main_1f07= SFC::Function::Cast( main_1f02);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_1f0c;
		if( !isValidBound(boundObjs_1f0c, subsystem_1ef5, true))
			continue;
		currMatch.subsystem_1f0d= subsystem_1ef5;
		if( !isValidBound(boundObjs_1f0c, block_1efe, true))
			continue;
		currMatch.block_1f0e= block_1efe;
		if( !isValidBound(boundObjs_1f0c, main_1f07, true))
			continue;
		currMatch.main_1f0f= main_1f07;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_1ee1::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_1f10, const CyberComposition::Simulink::Block& block_1f12, const SFC::Function& main_1f14)
{
	_subsystem_1eeb->push_back( subsystem_1f10);
	_block_1eec->push_back( block_1f12);
	_main_1eed->push_back( main_1f14);
}

void SubsystemChildBlock_1f16::operator()( const Packets_t& systems_1f17, const Packets_t& childSubsystems_1f19, const Packets_t& systemFunctions_1f1b)
{
#ifdef PRINT_INFO
	printLog( "SubsystemChildBlock_1f16" );
#endif
	if( ( !systems_1f17.empty())&& ( !childSubsystems_1f19.empty())&& ( !systemFunctions_1f1b.empty()))
		callMakeTrigger_2df2( systems_1f17, childSubsystems_1f19, systemFunctions_1f1b);
}

void SubsystemChildBlock_1f16::callMakeTrigger_2df2( const Packets_t& systems_1fa0, const Packets_t& childSubsystems_1fa2, const Packets_t& systemFunctions_1fa4)
{
	Packets_t systems_1fa6;
	Packets_t childSubsystems_1fa7;
	Packets_t compoundStatements_1fa8;
	MakeTrigger_1f9f makeTrigger_1f9f;
	makeTrigger_1f9f( systems_1fa0, childSubsystems_1fa2, systemFunctions_1fa4, systems_1fa6, childSubsystems_1fa7, compoundStatements_1fa8);
	if( ( !systems_1fa6.empty())&& ( !childSubsystems_1fa7.empty())&& ( !compoundStatements_1fa8.empty()))
		callCreateMethodCall_2df6( systems_1fa6, childSubsystems_1fa7, compoundStatements_1fa8);
}

void SubsystemChildBlock_1f16::callCreateMethodCall_2df6( const Packets_t& subsystems_1f1e, const Packets_t& blocks_1f22, const Packets_t& mains_1f25)
{
	Packets_t subsystems_1f20;
	Packets_t functions_1f21;
	Packets_t methodCalls_1f24;
	CreateMethodCall_1f1d createMethodCall_1f1d;
	createMethodCall_1f1d( subsystems_1f1e, blocks_1f22, mains_1f25, subsystems_1f20, functions_1f21, methodCalls_1f24);
	if( ( !subsystems_1f20.empty())&& ( !functions_1f21.empty())&& ( !methodCalls_1f24.empty()))
		callCreateFunctionCallArgs_2dfa( subsystems_1f20, functions_1f21, methodCalls_1f24);
}

void SubsystemChildBlock_1f16::callCreateFunctionCallArgs_2dfa( const Packets_t& subsystems_1f62, const Packets_t& functions_1f65, const Packets_t& methodCalls_1f68)
{
	Packets_t subsystems_1f64;
	Packets_t ports_1f67;
	Packets_t argVals_1f6a;
	CreateFunctionCallArgs_1f61 createFunctionCallArgs_1f61;
	createFunctionCallArgs_1f61( subsystems_1f62, functions_1f65, methodCalls_1f68, subsystems_1f64, ports_1f67, argVals_1f6a);
	if( ( !subsystems_1f64.empty())&& ( !ports_1f67.empty())&& ( !argVals_1f6a.empty()))
		callMakeArgDeclRef_2dfe( subsystems_1f64, ports_1f67, argVals_1f6a);
}

void SubsystemChildBlock_1f16::callMakeArgDeclRef_2dfe( const Packets_t& systems_2cf6, const Packets_t& argPorts_2cf8, const Packets_t& argVals_2cfa)
{
	MakeArgDeclRef_2cf5 makeArgDeclRef_2cf5;
	makeArgDeclRef_2cf5( systems_2cf6, argPorts_2cf8, argVals_2cfa);
}

void CreateMethodCall_1f1d::operator()( const Packets_t& subsystems_1f1e, const Packets_t& blocks_1f22, const Packets_t& mains_1f25, Packets_t& subsystems_1f20, Packets_t& functions_1f21, Packets_t& methodCalls_1f24)
{
#ifdef PRINT_INFO
	printLog( "CreateMethodCall_1f1d" );
#endif
	RTTGenerator::Instance()->generateRule(2027, "CreateMethodCall");
	_subsystem_1f27= &subsystems_1f20;
	_function_1f28= &functions_1f21;
	_methodCall_1f29= &methodCalls_1f24;
	processInputPackets( subsystems_1f1e, blocks_1f22, mains_1f25);
}

bool CreateMethodCall_1f1d::isInputUnique( const Udm::Object& subsystem_1f2e, const Udm::Object& block_1f37, const Udm::Object& main_1f40)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1f30= _subsystem_1f2a.begin(), itBlock_1f39= _block_1f33.begin(), itMain_1f42= _main_1f3c.begin(); itSubsystem_1f30!= _subsystem_1f2a.end(), itBlock_1f39!= _block_1f33.end(), itMain_1f42!= _main_1f3c.end(); ++itSubsystem_1f30, ++itBlock_1f39, ++itMain_1f42)
	{
		if( ( *itSubsystem_1f30== subsystem_1f2e)&& ( *itBlock_1f39== block_1f37)&& ( *itMain_1f42== main_1f40))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1f2a.push_back( subsystem_1f2e);
		_block_1f33.push_back( block_1f37);
		_main_1f3c.push_back( main_1f40);
	}
	return isUnique;
}

bool CreateMethodCall_1f1d::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateMethodCall_1f1d::processInputPackets( const Packets_t& subsystems_1f1e, const Packets_t& blocks_1f22, const Packets_t& mains_1f25)
{
	for( Packets_t::const_iterator itSubsystem_1f2b= subsystems_1f1e.begin(), itBlock_1f34= blocks_1f22.begin(), itMain_1f3d= mains_1f25.begin(); itSubsystem_1f2b!= subsystems_1f1e.end(), itBlock_1f34!= blocks_1f22.end(), itMain_1f3d!= mains_1f25.end(); ++itSubsystem_1f2b, ++itBlock_1f34, ++itMain_1f3d)
	{
		bool isUnique= isInputUnique( *itSubsystem_1f2b, *itBlock_1f34, *itMain_1f3d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1f2b, *itBlock_1f34, *itMain_1f3d);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateMethodCall_1f1d::patternMatcher( const Udm::Object& subsystem_1f2c, const Udm::Object& block_1f35, const Udm::Object& main_1f3e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1f2c.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1f31= CyberComposition::Simulink::Subsystem::Cast( subsystem_1f2c);
		if( false== Uml::IsDerivedFrom( block_1f35.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem block_1f3a= CyberComposition::Simulink::Subsystem::Cast( block_1f35);
		if( false== Uml::IsDerivedFrom( main_1f3e.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement main_1f43= SFC::CompoundStatement::Cast( main_1f3e);
		SFC::Function function_1f45= block_1f3a.main();
		if( !function_1f45)
			continue;
		set< SFC::Arg> args_1f46= function_1f45.Arg_kind_children();
		for( set< SFC::Arg>::const_iterator itArg_1f47= args_1f46.begin(); itArg_1f47!= args_1f46.end(); ++itArg_1f47)
		{
			SFC::Arg currArg_1f48= *itArg_1f47;
			SFC::DT struct_1f49= currArg_1f48.dt();
			if(!struct_1f49 || false== Uml::IsDerivedFrom( struct_1f49.type(), SFC::Struct::meta))
				continue;
			SFC::Struct struct_1f4a= SFC::Struct::Cast( struct_1f49);
			if( !struct_1f4a)
				continue;
			Udm::Object structParent_1f4b= struct_1f4a.container();
			if( false== Uml::IsDerivedFrom( structParent_1f4b.type(), SFC::Class::meta))
				continue;
			SFC::Class classStruct_1f4c= SFC::Class::Cast( structParent_1f4b);
			SFC::Class class_1f4d= block_1f3a.cls();
			if( !class_1f4d)
				continue;
			if( classStruct_1f4c!= class_1f4d)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_1f51;
			if( !isValidBound(boundObjs_1f51, subsystem_1f31, true))
				continue;
			currMatch.subsystem_1f52= subsystem_1f31;
			if( !isValidBound(boundObjs_1f51, block_1f3a, true))
				continue;
			currMatch.block_1f53= block_1f3a;
			if( !isValidBound(boundObjs_1f51, main_1f43, true))
				continue;
			currMatch.main_1f54= main_1f43;
			if( !isValidBound(boundObjs_1f51, function_1f45, false))
				continue;
			currMatch.function_1f55= function_1f45;
			if( !isValidBound(boundObjs_1f51, classStruct_1f4c, false))
				continue;
			currMatch.class_1f56= classStruct_1f4c;
			if( !isValidBound(boundObjs_1f51, currArg_1f48, false))
				continue;
			currMatch.arg_1f57= currArg_1f48;
			if( !isValidBound(boundObjs_1f51, struct_1f4a, false))
				continue;
			currMatch.struct_1f58= struct_1f4a;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateMethodCall_1f1d::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::FunctionCall newMethodCall_1f59= SFC::FunctionCall::Create( currMatch.main_1f54, SFC::CompoundStatement::meta_stmnt);
		SFC::ArgVal newArgVal_1f5a= SFC::ArgVal::Create( newMethodCall_1f59);
		SFC::Arg& Arg= currMatch.arg_1f57;
		SFC::ArgVal& ArgVal= newArgVal_1f5a;
		CyberComposition::Simulink::Subsystem& Block= currMatch.block_1f53;
		SFC::Class& Class= currMatch.class_1f56;
		SFC::Function& Function= currMatch.function_1f55;
		SFC::CompoundStatement& Main= currMatch.main_1f54;
		SFC::FunctionCall& MethodCall= newMethodCall_1f59;
		SFC::Struct& Struct= currMatch.struct_1f58;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_1f52;
		{
__int64 sc = Main.statementCount();
MethodCall.statementIndex() = sc++;
Main.statementCount() = sc;
};
		{
MethodCall.argCount() = Function.argCount();
};
		{
ArgVal.argIndex() = static_cast< __int64 >( Arg.argIndex() );
};
		newMethodCall_1f59.callee()= currMatch.function_1f55;
		newMethodCall_1f59.obj()= currMatch.block_1f53;
		newArgVal_1f5a.arg()+= currMatch.arg_1f57;
		outputAppender( currMatch.subsystem_1f52, currMatch.function_1f55, newMethodCall_1f59);
	}
}

void CreateMethodCall_1f1d::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_1f5b, const SFC::Function& function_1f5d, const SFC::FunctionCall& methodCall_1f5f)
{
	_subsystem_1f27->push_back( subsystem_1f5b);
	_function_1f28->push_back( function_1f5d);
	_methodCall_1f29->push_back( methodCall_1f5f);
}

void CreateFunctionCallArgs_1f61::operator()( const Packets_t& subsystems_1f62, const Packets_t& functions_1f65, const Packets_t& methodCalls_1f68, Packets_t& subsystems_1f64, Packets_t& ports_1f67, Packets_t& argVals_1f6a)
{
#ifdef PRINT_INFO
	printLog( "CreateFunctionCallArgs_1f61" );
#endif
	RTTGenerator::Instance()->generateRule(2050, "CreateFunctionCallArgs");
	_subsystem_1f6b= &subsystems_1f64;
	_port_1f6c= &ports_1f67;
	_argVal_1f6d= &argVals_1f6a;
	processInputPackets( subsystems_1f62, functions_1f65, methodCalls_1f68);
}

bool CreateFunctionCallArgs_1f61::isInputUnique( const Udm::Object& subsystem_1f72, const Udm::Object& function_1f7b, const Udm::Object& methodCall_1f84)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1f74= _subsystem_1f6e.begin(), itFunction_1f7d= _function_1f77.begin(), itMethodCall_1f86= _methodCall_1f80.begin(); itSubsystem_1f74!= _subsystem_1f6e.end(), itFunction_1f7d!= _function_1f77.end(), itMethodCall_1f86!= _methodCall_1f80.end(); ++itSubsystem_1f74, ++itFunction_1f7d, ++itMethodCall_1f86)
	{
		if( ( *itSubsystem_1f74== subsystem_1f72)&& ( *itFunction_1f7d== function_1f7b)&& ( *itMethodCall_1f86== methodCall_1f84))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1f6e.push_back( subsystem_1f72);
		_function_1f77.push_back( function_1f7b);
		_methodCall_1f80.push_back( methodCall_1f84);
	}
	return isUnique;
}

bool CreateFunctionCallArgs_1f61::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateFunctionCallArgs_1f61::processInputPackets( const Packets_t& subsystems_1f62, const Packets_t& functions_1f65, const Packets_t& methodCalls_1f68)
{
	for( Packets_t::const_iterator itSubsystem_1f6f= subsystems_1f62.begin(), itFunction_1f78= functions_1f65.begin(), itMethodCall_1f81= methodCalls_1f68.begin(); itSubsystem_1f6f!= subsystems_1f62.end(), itFunction_1f78!= functions_1f65.end(), itMethodCall_1f81!= methodCalls_1f68.end(); ++itSubsystem_1f6f, ++itFunction_1f78, ++itMethodCall_1f81)
	{
		bool isUnique= isInputUnique( *itSubsystem_1f6f, *itFunction_1f78, *itMethodCall_1f81);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1f6f, *itFunction_1f78, *itMethodCall_1f81);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateFunctionCallArgs_1f61::patternMatcher( const Udm::Object& subsystem_1f70, const Udm::Object& function_1f79, const Udm::Object& methodCall_1f82)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1f70.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1f75= CyberComposition::Simulink::Subsystem::Cast( subsystem_1f70);
		if( false== Uml::IsDerivedFrom( function_1f79.type(), SFC::Function::meta))
			continue;
		SFC::Function function_1f7e= SFC::Function::Cast( function_1f79);
		if( false== Uml::IsDerivedFrom( methodCall_1f82.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall methodCall_1f87= SFC::FunctionCall::Cast( methodCall_1f82);
		set< SFC::Arg> args_1f89= function_1f7e.Arg_kind_children();
		for( set< SFC::Arg>::const_iterator itArg_1f8a= args_1f89.begin(); itArg_1f8a!= args_1f89.end(); ++itArg_1f8a)
		{
			SFC::Arg currArg_1f8b= *itArg_1f8a;
			set< CyberComposition::Simulink::SF_Port> ports_1f8c= currArg_1f8b.port();
			for( set< CyberComposition::Simulink::SF_Port>::const_iterator itPorts_1f8d= ports_1f8c.begin(); itPorts_1f8d!= ports_1f8c.end(); ++itPorts_1f8d)
			{
				CyberComposition::Simulink::SF_Port currPort_1f8e= *itPorts_1f8d;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_1f92;
				if( !isValidBound(boundObjs_1f92, subsystem_1f75, true))
					continue;
				currMatch.subsystem_1f93= subsystem_1f75;
				if( !isValidBound(boundObjs_1f92, function_1f7e, true))
					continue;
				currMatch.function_1f94= function_1f7e;
				if( !isValidBound(boundObjs_1f92, methodCall_1f87, true))
					continue;
				currMatch.methodCall_1f95= methodCall_1f87;
				if( !isValidBound(boundObjs_1f92, currArg_1f8b, false))
					continue;
				currMatch.arg_1f96= currArg_1f8b;
				if( !isValidBound(boundObjs_1f92, currPort_1f8e, false))
					continue;
				currMatch.port_1f97= currPort_1f8e;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void CreateFunctionCallArgs_1f61::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ArgVal newArgVal_1f98= SFC::ArgVal::Create( currMatch.methodCall_1f95);
		SFC::Arg& Arg= currMatch.arg_1f96;
		SFC::ArgVal& ArgVal= newArgVal_1f98;
		SFC::Function& Function= currMatch.function_1f94;
		SFC::FunctionCall& MethodCall= currMatch.methodCall_1f95;
		CyberComposition::Simulink::SF_Port& Port= currMatch.port_1f97;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_1f93;
		{
ArgVal.argIndex() = Arg.argIndex();
};
		newArgVal_1f98.arg()+= currMatch.arg_1f96;
		outputAppender( currMatch.subsystem_1f93, currMatch.port_1f97, newArgVal_1f98);
	}
}

void CreateFunctionCallArgs_1f61::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_1f99, const CyberComposition::Simulink::SF_Port& port_1f9b, const SFC::ArgVal& argVal_1f9d)
{
	_subsystem_1f6b->push_back( subsystem_1f99);
	_port_1f6c->push_back( port_1f9b);
	_argVal_1f6d->push_back( argVal_1f9d);
}

void MakeTrigger_1f9f::operator()( const Packets_t& systems_1fa0, const Packets_t& childSubsystems_1fa2, const Packets_t& systemFunctions_1fa4, Packets_t& systems_1fa6, Packets_t& childSubsystems_1fa7, Packets_t& compoundStatements_1fa8)
{
#ifdef PRINT_INFO
	printLog( "MakeTrigger_1f9f" );
#endif
	_system_1fa9= &systems_1fa6;
	_childSubsystem_1faa= &childSubsystems_1fa7;
	_compoundStatement_1fab= &compoundStatements_1fa8;
	if( ( !systems_1fa0.empty())&& ( !childSubsystems_1fa2.empty())&& ( !systemFunctions_1fa4.empty()))
		callIsTriggered_2ce9( systems_1fa0, childSubsystems_1fa2, systemFunctions_1fa4);
}

void MakeTrigger_1f9f::callIsTriggered_2ce9( const Packets_t& systems_1fad, const Packets_t& childSubsystems_1faf, const Packets_t& systemFunctions_1fb1)
{
	Packets_t systems_1fb3;
	Packets_t childSubsystems_1fb4;
	Packets_t systemFunctions_1fb5;
	Packets_t systems_1fb6;
	Packets_t childSubsystems_1fb7;
	Packets_t systemFunctions_1fb8;
	Packets_t systems_1fb9;
	Packets_t childSubsystems_1fba;
	Packets_t systemFunctions_1fbb;
	IsTriggered_1fac isTriggered_1fac;
	isTriggered_1fac( systems_1fad, childSubsystems_1faf, systemFunctions_1fb1, systems_1fb3, childSubsystems_1fb4, systemFunctions_1fb5, systems_1fb6, childSubsystems_1fb7, systemFunctions_1fb8, systems_1fb9, childSubsystems_1fba, systemFunctions_1fbb);
	if( ( !systems_1fb3.empty())&& ( !childSubsystems_1fb4.empty())&& ( !systemFunctions_1fb5.empty()))
		callCreateTriggering_2ced( systems_1fb3, childSubsystems_1fb4, systemFunctions_1fb5);
	_system_1fa9->insert( _system_1fa9->end(), systems_1fb9.begin(), systems_1fb9.end());
	_childSubsystem_1faa->insert( _childSubsystem_1faa->end(), childSubsystems_1fba.begin(), childSubsystems_1fba.end());
	_compoundStatement_1fab->insert( _compoundStatement_1fab->end(), systemFunctions_1fbb.begin(), systemFunctions_1fbb.end());
	if( ( !systems_1fb6.empty())&& ( !childSubsystems_1fb7.empty())&& ( !systemFunctions_1fb8.empty()))
		callCreateAction_2cf1( systems_1fb6, childSubsystems_1fb7, systemFunctions_1fb8);
}

void MakeTrigger_1f9f::callCreateTriggering_2ced( const Packets_t& systems_2082, const Packets_t& childSubsystems_2084, const Packets_t& systemFunctions_2086)
{
	Packets_t systems_2088;
	Packets_t childSubsystems_2089;
	Packets_t conditionalBlocks_208a;
	CreateTriggering_2081 createTriggering_2081;
	createTriggering_2081( systems_2082, childSubsystems_2084, systemFunctions_2086, systems_2088, childSubsystems_2089, conditionalBlocks_208a);
	_system_1fa9->insert( _system_1fa9->end(), systems_2088.begin(), systems_2088.end());
	_childSubsystem_1faa->insert( _childSubsystem_1faa->end(), childSubsystems_2089.begin(), childSubsystems_2089.end());
	_compoundStatement_1fab->insert( _compoundStatement_1fab->end(), conditionalBlocks_208a.begin(), conditionalBlocks_208a.end());
}

void MakeTrigger_1f9f::callCreateAction_2cf1( const Packets_t& subsystems_2caa, const Packets_t& blocks_2cad, const Packets_t& functions_2cb0)
{
	Packets_t subsystems_2cac;
	Packets_t blocks_2caf;
	Packets_t conditionalBlocks_2cb2;
	CreateAction_2ca9 createAction_2ca9;
	createAction_2ca9( subsystems_2caa, blocks_2cad, functions_2cb0, subsystems_2cac, blocks_2caf, conditionalBlocks_2cb2);
	_system_1fa9->insert( _system_1fa9->end(), subsystems_2cac.begin(), subsystems_2cac.end());
	_childSubsystem_1faa->insert( _childSubsystem_1faa->end(), blocks_2caf.begin(), blocks_2caf.end());
	_compoundStatement_1fab->insert( _compoundStatement_1fab->end(), conditionalBlocks_2cb2.begin(), conditionalBlocks_2cb2.end());
}

void IsTriggered_1fac::operator()( const Packets_t& systems_1fad, const Packets_t& childSubsystems_1faf, const Packets_t& systemFunctions_1fb1, Packets_t& systems_1fb3, Packets_t& childSubsystems_1fb4, Packets_t& systemFunctions_1fb5, Packets_t& systems_1fb6, Packets_t& childSubsystems_1fb7, Packets_t& systemFunctions_1fb8, Packets_t& systems_1fb9, Packets_t& childSubsystems_1fba, Packets_t& systemFunctions_1fbb)
{
#ifdef PRINT_INFO
	printLog( "IsTriggered_1fac" );
#endif
	_system_1fbc= &systems_1fb3;
	_childSubsystem_1fbd= &childSubsystems_1fb4;
	_systemFunction_1fbe= &systemFunctions_1fb5;
	_system_1fbf= &systems_1fb6;
	_childSubsystem_1fc0= &childSubsystems_1fb7;
	_systemFunction_1fc1= &systemFunctions_1fb8;
	_system_1fc2= &systems_1fb9;
	_childSubsystem_1fc3= &childSubsystems_1fba;
	_systemFunction_1fc4= &systemFunctions_1fbb;
	for( Packets_t::const_iterator itsystem_1fc6= systems_1fad.begin(), itchildSubsystem_1fcd= childSubsystems_1faf.begin(), itsystemFunction_1fd4= systemFunctions_1fb1.begin(); itsystem_1fc6!= systems_1fad.end(), itchildSubsystem_1fcd!= childSubsystems_1faf.end(), itsystemFunction_1fd4!= systemFunctions_1fb1.end(); ++itsystem_1fc6, ++itchildSubsystem_1fcd, ++itsystemFunction_1fd4)
	{
		bool isUnique= isInputUnique( *itsystem_1fc6, *itchildSubsystem_1fcd, *itsystemFunction_1fd4);
		if( !isUnique)
			continue;
		Packets_t onesystem_1fca( 1, *itsystem_1fc6);
		Packets_t onechildSubsystem_1fd1( 1, *itchildSubsystem_1fcd);
		Packets_t onesystemFunction_1fd8( 1, *itsystemFunction_1fd4);
		executeOne( onesystem_1fca, onechildSubsystem_1fd1, onesystemFunction_1fd8);
	}
}

void IsTriggered_1fac::executeOne( const Packets_t& systems_1fad, const Packets_t& childSubsystems_1faf, const Packets_t& systemFunctions_1fb1)
{
	Packets_t subsystems_1fdd;
	Packets_t blocks_1fe0;
	Packets_t mains_1fe3;
	HasTriggers_1fda hasTriggers_1fda;
	bool isMatchHasTriggers_1fda= hasTriggers_1fda( systems_1fad, childSubsystems_1faf, systemFunctions_1fb1, subsystems_1fdd, blocks_1fe0, mains_1fe3);
	_system_1fbc->insert( _system_1fbc->end(), subsystems_1fdd.begin(), subsystems_1fdd.end());
	_childSubsystem_1fbd->insert( _childSubsystem_1fbd->end(), blocks_1fe0.begin(), blocks_1fe0.end());
	_systemFunction_1fbe->insert( _systemFunction_1fbe->end(), mains_1fe3.begin(), mains_1fe3.end());
	if( isMatchHasTriggers_1fda)
		return;
	Packets_t subsystems_2016;
	Packets_t blocks_2019;
	Packets_t mains_201c;
	HasActionPort_2013 hasActionPort_2013;
	bool isMatchHasActionPort_2013= hasActionPort_2013( systems_1fad, childSubsystems_1faf, systemFunctions_1fb1, subsystems_2016, blocks_2019, mains_201c);
	_system_1fbf->insert( _system_1fbf->end(), subsystems_2016.begin(), subsystems_2016.end());
	_childSubsystem_1fc0->insert( _childSubsystem_1fc0->end(), blocks_2019.begin(), blocks_2019.end());
	_systemFunction_1fc1->insert( _systemFunction_1fc1->end(), mains_201c.begin(), mains_201c.end());
	if( isMatchHasActionPort_2013)
		return;
	Packets_t subsystems_204f;
	Packets_t blocks_2052;
	Packets_t mains_2055;
	Otherwise_204c otherwise_204c;
	bool isMatchOtherwise_204c= otherwise_204c( systems_1fad, childSubsystems_1faf, systemFunctions_1fb1, subsystems_204f, blocks_2052, mains_2055);
	_system_1fc2->insert( _system_1fc2->end(), subsystems_204f.begin(), subsystems_204f.end());
	_childSubsystem_1fc3->insert( _childSubsystem_1fc3->end(), blocks_2052.begin(), blocks_2052.end());
	_systemFunction_1fc4->insert( _systemFunction_1fc4->end(), mains_2055.begin(), mains_2055.end());
	if( isMatchOtherwise_204c)
		return;
}

bool IsTriggered_1fac::isInputUnique( const Udm::Object& system_1fc7, const Udm::Object& childSubsystem_1fce, const Udm::Object& systemFunction_1fd5)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itsystem_1fc9= _system_1fc5.begin(), itchildSubsystem_1fd0= _childSubsystem_1fcc.begin(), itsystemFunction_1fd7= _systemFunction_1fd3.begin(); itsystem_1fc9!= _system_1fc5.end(), itchildSubsystem_1fd0!= _childSubsystem_1fcc.end(), itsystemFunction_1fd7!= _systemFunction_1fd3.end(); ++itsystem_1fc9, ++itchildSubsystem_1fd0, ++itsystemFunction_1fd7)
	{
		if( ( *itsystem_1fc9== system_1fc7)&& ( *itchildSubsystem_1fd0== childSubsystem_1fce)&& ( *itsystemFunction_1fd7== systemFunction_1fd5))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_system_1fc5.push_back( system_1fc7);
		_childSubsystem_1fcc.push_back( childSubsystem_1fce);
		_systemFunction_1fd3.push_back( systemFunction_1fd5);
	}
	return isUnique;
}

bool HasTriggers_1fda::operator()( const Packets_t& subsystems_1fdb, const Packets_t& blocks_1fde, const Packets_t& mains_1fe1, Packets_t& subsystems_1fdd, Packets_t& blocks_1fe0, Packets_t& mains_1fe3)
{
#ifdef PRINT_INFO
	printLog( "HasTriggers_1fda" );
#endif
	_subsystem_1fe4= &subsystems_1fdd;
	_block_1fe5= &blocks_1fe0;
	_main_1fe6= &mains_1fe3;
	processInputPackets( subsystems_1fdb, blocks_1fde, mains_1fe1);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasTriggers_1fda::isInputUnique( const Udm::Object& subsystem_1feb, const Udm::Object& block_1ff4, const Udm::Object& main_1ffd)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_1fed= _subsystem_1fe7.begin(), itBlock_1ff6= _block_1ff0.begin(), itMain_1fff= _main_1ff9.begin(); itSubsystem_1fed!= _subsystem_1fe7.end(), itBlock_1ff6!= _block_1ff0.end(), itMain_1fff!= _main_1ff9.end(); ++itSubsystem_1fed, ++itBlock_1ff6, ++itMain_1fff)
	{
		if( ( *itSubsystem_1fed== subsystem_1feb)&& ( *itBlock_1ff6== block_1ff4)&& ( *itMain_1fff== main_1ffd))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_1fe7.push_back( subsystem_1feb);
		_block_1ff0.push_back( block_1ff4);
		_main_1ff9.push_back( main_1ffd);
	}
	return isUnique;
}

bool HasTriggers_1fda::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void HasTriggers_1fda::processInputPackets( const Packets_t& subsystems_1fdb, const Packets_t& blocks_1fde, const Packets_t& mains_1fe1)
{
	for( Packets_t::const_iterator itSubsystem_1fe8= subsystems_1fdb.begin(), itBlock_1ff1= blocks_1fde.begin(), itMain_1ffa= mains_1fe1.begin(); itSubsystem_1fe8!= subsystems_1fdb.end(), itBlock_1ff1!= blocks_1fde.end(), itMain_1ffa!= mains_1fe1.end(); ++itSubsystem_1fe8, ++itBlock_1ff1, ++itMain_1ffa)
	{
		bool isUnique= isInputUnique( *itSubsystem_1fe8, *itBlock_1ff1, *itMain_1ffa);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_1fe8, *itBlock_1ff1, *itMain_1ffa);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_2009, currMatch.block_200a, currMatch.main_200b);
	}
}

bool HasTriggers_1fda::patternMatcher( const Udm::Object& subsystem_1fe9, const Udm::Object& block_1ff2, const Udm::Object& main_1ffb)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_1fe9.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_1fee= CyberComposition::Simulink::Subsystem::Cast( subsystem_1fe9);
		if( false== Uml::IsDerivedFrom( block_1ff2.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem block_1ff7= CyberComposition::Simulink::Subsystem::Cast( block_1ff2);
		if( false== Uml::IsDerivedFrom( main_1ffb.type(), SFC::Function::meta))
			continue;
		SFC::Function main_2000= SFC::Function::Cast( main_1ffb);
		set< CyberComposition::Simulink::TriggerPort> triggerPorts_2002= block_1ff7.TriggerPort_kind_children();
		for( set< CyberComposition::Simulink::TriggerPort>::const_iterator itTriggerPort_2003= triggerPorts_2002.begin(); itTriggerPort_2003!= triggerPorts_2002.end(); ++itTriggerPort_2003)
		{
			CyberComposition::Simulink::TriggerPort currTriggerPort_2004= *itTriggerPort_2003;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2008;
			if( !isValidBound(boundObjs_2008, subsystem_1fee, true))
				continue;
			currMatch.subsystem_2009= subsystem_1fee;
			if( !isValidBound(boundObjs_2008, block_1ff7, true))
				continue;
			currMatch.block_200a= block_1ff7;
			if( !isValidBound(boundObjs_2008, main_2000, true))
				continue;
			currMatch.main_200b= main_2000;
			if( !isValidBound(boundObjs_2008, currTriggerPort_2004, false))
				continue;
			currMatch.triggerPort_200c= currTriggerPort_2004;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void HasTriggers_1fda::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_200d, const CyberComposition::Simulink::Subsystem& block_200f, const SFC::Function& main_2011)
{
	_subsystem_1fe4->push_back( subsystem_200d);
	_block_1fe5->push_back( block_200f);
	_main_1fe6->push_back( main_2011);
}

bool HasActionPort_2013::operator()( const Packets_t& subsystems_2014, const Packets_t& blocks_2017, const Packets_t& mains_201a, Packets_t& subsystems_2016, Packets_t& blocks_2019, Packets_t& mains_201c)
{
#ifdef PRINT_INFO
	printLog( "HasActionPort_2013" );
#endif
	_subsystem_201d= &subsystems_2016;
	_block_201e= &blocks_2019;
	_main_201f= &mains_201c;
	processInputPackets( subsystems_2014, blocks_2017, mains_201a);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasActionPort_2013::isInputUnique( const Udm::Object& subsystem_2024, const Udm::Object& block_202d, const Udm::Object& main_2036)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_2026= _subsystem_2020.begin(), itBlock_202f= _block_2029.begin(), itMain_2038= _main_2032.begin(); itSubsystem_2026!= _subsystem_2020.end(), itBlock_202f!= _block_2029.end(), itMain_2038!= _main_2032.end(); ++itSubsystem_2026, ++itBlock_202f, ++itMain_2038)
	{
		if( ( *itSubsystem_2026== subsystem_2024)&& ( *itBlock_202f== block_202d)&& ( *itMain_2038== main_2036))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_2020.push_back( subsystem_2024);
		_block_2029.push_back( block_202d);
		_main_2032.push_back( main_2036);
	}
	return isUnique;
}

bool HasActionPort_2013::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void HasActionPort_2013::processInputPackets( const Packets_t& subsystems_2014, const Packets_t& blocks_2017, const Packets_t& mains_201a)
{
	for( Packets_t::const_iterator itSubsystem_2021= subsystems_2014.begin(), itBlock_202a= blocks_2017.begin(), itMain_2033= mains_201a.begin(); itSubsystem_2021!= subsystems_2014.end(), itBlock_202a!= blocks_2017.end(), itMain_2033!= mains_201a.end(); ++itSubsystem_2021, ++itBlock_202a, ++itMain_2033)
	{
		bool isUnique= isInputUnique( *itSubsystem_2021, *itBlock_202a, *itMain_2033);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_2021, *itBlock_202a, *itMain_2033);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_2042, currMatch.block_2043, currMatch.main_2044);
	}
}

bool HasActionPort_2013::patternMatcher( const Udm::Object& subsystem_2022, const Udm::Object& block_202b, const Udm::Object& main_2034)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_2022.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_2027= CyberComposition::Simulink::Subsystem::Cast( subsystem_2022);
		if( false== Uml::IsDerivedFrom( block_202b.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem block_2030= CyberComposition::Simulink::Subsystem::Cast( block_202b);
		if( false== Uml::IsDerivedFrom( main_2034.type(), SFC::Function::meta))
			continue;
		SFC::Function main_2039= SFC::Function::Cast( main_2034);
		set< CyberComposition::Simulink::EnablePort> actionPorts_203b= block_2030.EnablePort_kind_children();
		for( set< CyberComposition::Simulink::EnablePort>::const_iterator itActionPort_203c= actionPorts_203b.begin(); itActionPort_203c!= actionPorts_203b.end(); ++itActionPort_203c)
		{
			CyberComposition::Simulink::EnablePort currActionPort_203d= *itActionPort_203c;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2041;
			if( !isValidBound(boundObjs_2041, subsystem_2027, true))
				continue;
			currMatch.subsystem_2042= subsystem_2027;
			if( !isValidBound(boundObjs_2041, block_2030, true))
				continue;
			currMatch.block_2043= block_2030;
			if( !isValidBound(boundObjs_2041, main_2039, true))
				continue;
			currMatch.main_2044= main_2039;
			if( !isValidBound(boundObjs_2041, currActionPort_203d, false))
				continue;
			currMatch.actionPort_2045= currActionPort_203d;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void HasActionPort_2013::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_2046, const CyberComposition::Simulink::Subsystem& block_2048, const SFC::Function& main_204a)
{
	_subsystem_201d->push_back( subsystem_2046);
	_block_201e->push_back( block_2048);
	_main_201f->push_back( main_204a);
}

bool Otherwise_204c::operator()( const Packets_t& subsystems_204d, const Packets_t& blocks_2050, const Packets_t& mains_2053, Packets_t& subsystems_204f, Packets_t& blocks_2052, Packets_t& mains_2055)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_204c" );
#endif
	_subsystem_2056= &subsystems_204f;
	_block_2057= &blocks_2052;
	_main_2058= &mains_2055;
	processInputPackets( subsystems_204d, blocks_2050, mains_2053);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_204c::isInputUnique( const Udm::Object& subsystem_205d, const Udm::Object& block_2066, const Udm::Object& main_206f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_205f= _subsystem_2059.begin(), itBlock_2068= _block_2062.begin(), itMain_2071= _main_206b.begin(); itSubsystem_205f!= _subsystem_2059.end(), itBlock_2068!= _block_2062.end(), itMain_2071!= _main_206b.end(); ++itSubsystem_205f, ++itBlock_2068, ++itMain_2071)
	{
		if( ( *itSubsystem_205f== subsystem_205d)&& ( *itBlock_2068== block_2066)&& ( *itMain_2071== main_206f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_2059.push_back( subsystem_205d);
		_block_2062.push_back( block_2066);
		_main_206b.push_back( main_206f);
	}
	return isUnique;
}

bool Otherwise_204c::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_204c::processInputPackets( const Packets_t& subsystems_204d, const Packets_t& blocks_2050, const Packets_t& mains_2053)
{
	for( Packets_t::const_iterator itSubsystem_205a= subsystems_204d.begin(), itBlock_2063= blocks_2050.begin(), itMain_206c= mains_2053.begin(); itSubsystem_205a!= subsystems_204d.end(), itBlock_2063!= blocks_2050.end(), itMain_206c!= mains_2053.end(); ++itSubsystem_205a, ++itBlock_2063, ++itMain_206c)
	{
		bool isUnique= isInputUnique( *itSubsystem_205a, *itBlock_2063, *itMain_206c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_205a, *itBlock_2063, *itMain_206c);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_2078, currMatch.block_2079, currMatch.main_207a);
	}
}

bool Otherwise_204c::patternMatcher( const Udm::Object& subsystem_205b, const Udm::Object& block_2064, const Udm::Object& main_206d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_205b.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_2060= CyberComposition::Simulink::Subsystem::Cast( subsystem_205b);
		if( false== Uml::IsDerivedFrom( block_2064.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem block_2069= CyberComposition::Simulink::Subsystem::Cast( block_2064);
		if( false== Uml::IsDerivedFrom( main_206d.type(), SFC::Function::meta))
			continue;
		SFC::Function main_2072= SFC::Function::Cast( main_206d);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2077;
		if( !isValidBound(boundObjs_2077, subsystem_2060, true))
			continue;
		currMatch.subsystem_2078= subsystem_2060;
		if( !isValidBound(boundObjs_2077, block_2069, true))
			continue;
		currMatch.block_2079= block_2069;
		if( !isValidBound(boundObjs_2077, main_2072, true))
			continue;
		currMatch.main_207a= main_2072;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_204c::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_207b, const CyberComposition::Simulink::Subsystem& block_207d, const SFC::Function& main_207f)
{
	_subsystem_2056->push_back( subsystem_207b);
	_block_2057->push_back( block_207d);
	_main_2058->push_back( main_207f);
}

void CreateTriggering_2081::operator()( const Packets_t& systems_2082, const Packets_t& childSubsystems_2084, const Packets_t& systemFunctions_2086, Packets_t& systems_2088, Packets_t& childSubsystems_2089, Packets_t& conditionalBlocks_208a)
{
#ifdef PRINT_INFO
	printLog( "CreateTriggering_2081" );
#endif
	_system_208b= &systems_2088;
	_childSubsystem_208c= &childSubsystems_2089;
	_conditionalBlock_208d= &conditionalBlocks_208a;
	if( ( !systems_2082.empty())&& ( !childSubsystems_2084.empty())&& ( !systemFunctions_2086.empty()))
		callGetTriggerPort_2c9b( systems_2082, childSubsystems_2084, systemFunctions_2086);
}

void CreateTriggering_2081::callGetTriggerPort_2c9b( const Packets_t& subsystems_20d0, const Packets_t& blocks_20d3, const Packets_t& mains_20d6)
{
	Packets_t subsystems_20d2;
	Packets_t triggerPorts_20d5;
	Packets_t mains_20d8;
	GetTriggerPort_20cf getTriggerPort_20cf;
	getTriggerPort_20cf( subsystems_20d0, blocks_20d3, mains_20d6, subsystems_20d2, triggerPorts_20d5, mains_20d8);
	if( ( !subsystems_20d2.empty())&& ( !triggerPorts_20d5.empty())&& ( !mains_20d8.empty()))
		callAssignCondVal_2c9f( subsystems_20d2, triggerPorts_20d5, mains_20d8);
}

void CreateTriggering_2081::callAssignCondVal_2c9f( const Packets_t& subsystems_208f, const Packets_t& triggerPorts_2092, const Packets_t& functions_2097)
{
	Packets_t subsystems_2091;
	Packets_t triggerPorts_2094;
	Packets_t argDeclBases_2095;
	Packets_t dTs_2096;
	Packets_t functions_2099;
	AssignCondVal_208e assignCondVal_208e;
	assignCondVal_208e( subsystems_208f, triggerPorts_2092, functions_2097, subsystems_2091, triggerPorts_2094, argDeclBases_2095, dTs_2096, functions_2099);
	if( ( !subsystems_2091.empty())&& ( !triggerPorts_2094.empty())&& ( !argDeclBases_2095.empty())&& ( !dTs_2096.empty())&& ( !functions_2099.empty()))
		callMakeTrigger_2ca3( subsystems_2091, triggerPorts_2094, argDeclBases_2095, dTs_2096, functions_2099);
}

void CreateTriggering_2081::callMakeTrigger_2ca3( const Packets_t& systems_2109, const Packets_t& childSubsystemTriggers_210b, const Packets_t& argdecls_210d, const Packets_t& dts_210f, const Packets_t& functions_2111)
{
	Packets_t systems_2113;
	Packets_t childSubsystems_2114;
	Packets_t conditionals_2115;
	MakeTrigger_2108 makeTrigger_2108;
	makeTrigger_2108( systems_2109, childSubsystemTriggers_210b, argdecls_210d, dts_210f, functions_2111, systems_2113, childSubsystems_2114, conditionals_2115);
	_system_208b->insert( _system_208b->end(), systems_2113.begin(), systems_2113.end());
	_childSubsystem_208c->insert( _childSubsystem_208c->end(), childSubsystems_2114.begin(), childSubsystems_2114.end());
	_conditionalBlock_208d->insert( _conditionalBlock_208d->end(), conditionals_2115.begin(), conditionals_2115.end());
}

void AssignCondVal_208e::operator()( const Packets_t& subsystems_208f, const Packets_t& triggerPorts_2092, const Packets_t& functions_2097, Packets_t& subsystems_2091, Packets_t& triggerPorts_2094, Packets_t& argDeclBases_2095, Packets_t& dTs_2096, Packets_t& functions_2099)
{
#ifdef PRINT_INFO
	printLog( "AssignCondVal_208e" );
#endif
	RTTGenerator::Instance()->generateRule(2105, "AssignCondVal");
	_subsystem_209a= &subsystems_2091;
	_triggerPort_209b= &triggerPorts_2094;
	_argDeclBase_209c= &argDeclBases_2095;
	_dT_209d= &dTs_2096;
	_function_209e= &functions_2099;
	processInputPackets( subsystems_208f, triggerPorts_2092, functions_2097);
}

bool AssignCondVal_208e::isInputUnique( const Udm::Object& subsystem_20a3, const Udm::Object& triggerPort_20ac, const Udm::Object& function_20b5)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_20a5= _subsystem_209f.begin(), itTriggerPort_20ae= _triggerPort_20a8.begin(), itFunction_20b7= _function_20b1.begin(); itSubsystem_20a5!= _subsystem_209f.end(), itTriggerPort_20ae!= _triggerPort_20a8.end(), itFunction_20b7!= _function_20b1.end(); ++itSubsystem_20a5, ++itTriggerPort_20ae, ++itFunction_20b7)
	{
		if( ( *itSubsystem_20a5== subsystem_20a3)&& ( *itTriggerPort_20ae== triggerPort_20ac)&& ( *itFunction_20b7== function_20b5))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_209f.push_back( subsystem_20a3);
		_triggerPort_20a8.push_back( triggerPort_20ac);
		_function_20b1.push_back( function_20b5);
	}
	return isUnique;
}

bool AssignCondVal_208e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void AssignCondVal_208e::processInputPackets( const Packets_t& subsystems_208f, const Packets_t& triggerPorts_2092, const Packets_t& functions_2097)
{
	for( Packets_t::const_iterator itSubsystem_20a0= subsystems_208f.begin(), itTriggerPort_20a9= triggerPorts_2092.begin(), itFunction_20b2= functions_2097.begin(); itSubsystem_20a0!= subsystems_208f.end(), itTriggerPort_20a9!= triggerPorts_2092.end(), itFunction_20b2!= functions_2097.end(); ++itSubsystem_20a0, ++itTriggerPort_20a9, ++itFunction_20b2)
	{
		bool isUnique= isInputUnique( *itSubsystem_20a0, *itTriggerPort_20a9, *itFunction_20b2);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_20a0, *itTriggerPort_20a9, *itFunction_20b2);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AssignCondVal_208e::patternMatcher( const Udm::Object& subsystem_20a1, const Udm::Object& triggerPort_20aa, const Udm::Object& function_20b3)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_20a1.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_20a6= CyberComposition::Simulink::Subsystem::Cast( subsystem_20a1);
		if( false== Uml::IsDerivedFrom( triggerPort_20aa.type(), CyberComposition::Simulink::SF_Port::meta))
			continue;
		CyberComposition::Simulink::SF_Port triggerPort_20af= CyberComposition::Simulink::SF_Port::Cast( triggerPort_20aa);
		if( false== Uml::IsDerivedFrom( function_20b3.type(), SFC::Function::meta))
			continue;
		SFC::Function function_20b8= SFC::Function::Cast( function_20b3);
		SFC::ArgDeclBase argDeclBase_20ba= triggerPort_20af.argdecl();
		if( !argDeclBase_20ba)
			continue;
		SFC::DT dT_20bb= argDeclBase_20ba.dt();
		if( !dT_20bb)
			continue;
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_20bf;
		if( !isValidBound(boundObjs_20bf, subsystem_20a6, true))
			continue;
		currMatch.subsystem_20c0= subsystem_20a6;
		if( !isValidBound(boundObjs_20bf, triggerPort_20af, true))
			continue;
		currMatch.triggerPort_20c1= triggerPort_20af;
		if( !isValidBound(boundObjs_20bf, function_20b8, true))
			continue;
		currMatch.function_20c2= function_20b8;
		if( !isValidBound(boundObjs_20bf, argDeclBase_20ba, false))
			continue;
		currMatch.argDeclBase_20c3= argDeclBase_20ba;
		if( !isValidBound(boundObjs_20bf, dT_20bb, false))
			continue;
		currMatch.dT_20c4= dT_20bb;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void AssignCondVal_208e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_20c0, currMatch.triggerPort_20c1, currMatch.argDeclBase_20c3, currMatch.dT_20c4, currMatch.function_20c2);
	}
}

void AssignCondVal_208e::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_20c5, const CyberComposition::Simulink::SF_Port& triggerPort_20c7, const SFC::ArgDeclBase& argDeclBase_20c9, const SFC::DT& dT_20cb, const SFC::Function& function_20cd)
{
	_subsystem_209a->push_back( subsystem_20c5);
	_triggerPort_209b->push_back( triggerPort_20c7);
	_argDeclBase_209c->push_back( argDeclBase_20c9);
	_dT_209d->push_back( dT_20cb);
	_function_209e->push_back( function_20cd);
}

void GetTriggerPort_20cf::operator()( const Packets_t& subsystems_20d0, const Packets_t& blocks_20d3, const Packets_t& mains_20d6, Packets_t& subsystems_20d2, Packets_t& triggerPorts_20d5, Packets_t& mains_20d8)
{
#ifdef PRINT_INFO
	printLog( "GetTriggerPort_20cf" );
#endif
	RTTGenerator::Instance()->generateRule(2113, "GetTriggerPort");
	_subsystem_20d9= &subsystems_20d2;
	_triggerPort_20da= &triggerPorts_20d5;
	_main_20db= &mains_20d8;
	processInputPackets( subsystems_20d0, blocks_20d3, mains_20d6);
}

bool GetTriggerPort_20cf::isInputUnique( const Udm::Object& subsystem_20e0, const Udm::Object& block_20e9, const Udm::Object& main_20f2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_20e2= _subsystem_20dc.begin(), itBlock_20eb= _block_20e5.begin(), itMain_20f4= _main_20ee.begin(); itSubsystem_20e2!= _subsystem_20dc.end(), itBlock_20eb!= _block_20e5.end(), itMain_20f4!= _main_20ee.end(); ++itSubsystem_20e2, ++itBlock_20eb, ++itMain_20f4)
	{
		if( ( *itSubsystem_20e2== subsystem_20e0)&& ( *itBlock_20eb== block_20e9)&& ( *itMain_20f4== main_20f2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_20dc.push_back( subsystem_20e0);
		_block_20e5.push_back( block_20e9);
		_main_20ee.push_back( main_20f2);
	}
	return isUnique;
}

bool GetTriggerPort_20cf::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetTriggerPort_20cf::processInputPackets( const Packets_t& subsystems_20d0, const Packets_t& blocks_20d3, const Packets_t& mains_20d6)
{
	for( Packets_t::const_iterator itSubsystem_20dd= subsystems_20d0.begin(), itBlock_20e6= blocks_20d3.begin(), itMain_20ef= mains_20d6.begin(); itSubsystem_20dd!= subsystems_20d0.end(), itBlock_20e6!= blocks_20d3.end(), itMain_20ef!= mains_20d6.end(); ++itSubsystem_20dd, ++itBlock_20e6, ++itMain_20ef)
	{
		bool isUnique= isInputUnique( *itSubsystem_20dd, *itBlock_20e6, *itMain_20ef);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_20dd, *itBlock_20e6, *itMain_20ef);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetTriggerPort_20cf::patternMatcher( const Udm::Object& subsystem_20de, const Udm::Object& block_20e7, const Udm::Object& main_20f0)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_20de.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_20e3= CyberComposition::Simulink::Subsystem::Cast( subsystem_20de);
		if( false== Uml::IsDerivedFrom( block_20e7.type(), CyberComposition::Simulink::Block::meta))
			continue;
		CyberComposition::Simulink::Block block_20ec= CyberComposition::Simulink::Block::Cast( block_20e7);
		if( false== Uml::IsDerivedFrom( main_20f0.type(), SFC::Function::meta))
			continue;
		SFC::Function main_20f5= SFC::Function::Cast( main_20f0);
		set< CyberComposition::Simulink::TriggerPort> triggerPorts_20f7= block_20ec.TriggerPort_kind_children();
		for( set< CyberComposition::Simulink::TriggerPort>::const_iterator itTriggerPort_20f8= triggerPorts_20f7.begin(); itTriggerPort_20f8!= triggerPorts_20f7.end(); ++itTriggerPort_20f8)
		{
			CyberComposition::Simulink::TriggerPort currTriggerPort_20f9= *itTriggerPort_20f8;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_20fd;
			if( !isValidBound(boundObjs_20fd, subsystem_20e3, true))
				continue;
			currMatch.subsystem_20fe= subsystem_20e3;
			if( !isValidBound(boundObjs_20fd, block_20ec, true))
				continue;
			currMatch.block_20ff= block_20ec;
			if( !isValidBound(boundObjs_20fd, main_20f5, true))
				continue;
			currMatch.main_2100= main_20f5;
			if( !isValidBound(boundObjs_20fd, currTriggerPort_20f9, false))
				continue;
			currMatch.triggerPort_2101= currTriggerPort_20f9;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetTriggerPort_20cf::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_20fe, currMatch.triggerPort_2101, currMatch.main_2100);
	}
}

void GetTriggerPort_20cf::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_2102, const CyberComposition::Simulink::TriggerPort& triggerPort_2104, const SFC::Function& main_2106)
{
	_subsystem_20d9->push_back( subsystem_2102);
	_triggerPort_20da->push_back( triggerPort_2104);
	_main_20db->push_back( main_2106);
}

void MakeTrigger_2108::operator()( const Packets_t& systems_2109, const Packets_t& childSubsystemTriggers_210b, const Packets_t& argdecls_210d, const Packets_t& dts_210f, const Packets_t& functions_2111, Packets_t& systems_2113, Packets_t& childSubsystems_2114, Packets_t& conditionals_2115)
{
#ifdef PRINT_INFO
	printLog( "MakeTrigger_2108" );
#endif
	_system_2116= &systems_2113;
	_childSubsystem_2117= &childSubsystems_2114;
	_conditional_2118= &conditionals_2115;
	if( ( !systems_2109.empty())&& ( !childSubsystemTriggers_210b.empty())&& ( !argdecls_210d.empty())&& ( !dts_210f.empty())&& ( !functions_2111.empty()))
		callAddStateVar_2c7f( systems_2109, childSubsystemTriggers_210b, argdecls_210d, dts_210f, functions_2111);
}

void MakeTrigger_2108::callAddStateVar_2c7f( const Packets_t& subsystems_2900, const Packets_t& triggerPorts_2903, const Packets_t& argDeclBases_2906, const Packets_t& dTs_290a, const Packets_t& functions_290e)
{
	Packets_t subsystems_2902;
	Packets_t triggerPorts_2905;
	Packets_t argDeclBases_2908;
	Packets_t localVars_2909;
	Packets_t dTs_290c;
	Packets_t args_290d;
	Packets_t functions_2910;
	AddStateVar_28ff addStateVar_28ff;
	addStateVar_28ff( subsystems_2900, triggerPorts_2903, argDeclBases_2906, dTs_290a, functions_290e, subsystems_2902, triggerPorts_2905, argDeclBases_2908, localVars_2909, dTs_290c, args_290d, functions_2910);
	if( ( !subsystems_2902.empty())&& ( !triggerPorts_2905.empty())&& ( !argDeclBases_2908.empty())&& ( !dTs_290c.empty())&& ( !localVars_2909.empty())&& ( !args_290d.empty())&& ( !functions_2910.empty()))
		callAddTriggerVars_2c85( subsystems_2902, triggerPorts_2905, argDeclBases_2908, dTs_290c, localVars_2909, args_290d, functions_2910);
}

void MakeTrigger_2108::callAddTriggerVars_2c85( const Packets_t& systems_211a, const Packets_t& triggers_211c, const Packets_t& argdecls_211e, const Packets_t& dts_2120, const Packets_t& oldvals_2122, const Packets_t& contexts_2124, const Packets_t& functions_2126)
{
	Packets_t systems_2128;
	Packets_t triggers_2129;
	Packets_t argdecls_212a;
	Packets_t dts_212b;
	Packets_t oldvals_212c;
	Packets_t contexts_212d;
	Packets_t functions_212e;
	AddTriggerVars_2119 addTriggerVars_2119;
	addTriggerVars_2119( systems_211a, triggers_211c, argdecls_211e, dts_2120, oldvals_2122, contexts_2124, functions_2126, systems_2128, triggers_2129, argdecls_212a, dts_212b, oldvals_212c, contexts_212d, functions_212e);
	if( ( !systems_2128.empty())&& ( !triggers_2129.empty())&& ( !argdecls_212a.empty())&& ( !dts_212b.empty())&& ( !oldvals_212c.empty())&& ( !contexts_212d.empty())&& ( !functions_212e.empty()))
		callSaveState_2c8d( systems_2128, triggers_2129, argdecls_212a, dts_212b, oldvals_212c, contexts_212d, functions_212e);
}

void MakeTrigger_2108::callSaveState_2c8d( const Packets_t& systems_2814, const Packets_t& triggers_2816, const Packets_t& argdecls_2818, const Packets_t& dts_281a, const Packets_t& oldvals_281c, const Packets_t& contexts_281e, const Packets_t& functions_2820)
{
	Packets_t systems_2822;
	Packets_t triggers_2823;
	Packets_t dts_2824;
	Packets_t oldvals_2825;
	Packets_t functions_2826;
	SaveState_2813 saveState_2813;
	saveState_2813( systems_2814, triggers_2816, argdecls_2818, dts_281a, oldvals_281c, contexts_281e, functions_2820, systems_2822, triggers_2823, dts_2824, oldvals_2825, functions_2826);
	if( ( !systems_2822.empty())&& ( !triggers_2823.empty())&& ( !dts_2824.empty())&& ( !oldvals_2825.empty())&& ( !functions_2826.empty()))
		callMakeCondition_2c95( systems_2822, triggers_2823, dts_2824, oldvals_2825, functions_2826);
}

void MakeTrigger_2108::callMakeCondition_2c95( const Packets_t& systems_296b, const Packets_t& triggers_296d, const Packets_t& dts_296f, const Packets_t& oldvals_2971, const Packets_t& functions_2973)
{
	Packets_t systems_2975;
	Packets_t childSubsystems_2976;
	Packets_t conditionals_2977;
	MakeCondition_296a makeCondition_296a;
	makeCondition_296a( systems_296b, triggers_296d, dts_296f, oldvals_2971, functions_2973, systems_2975, childSubsystems_2976, conditionals_2977);
	_system_2116->insert( _system_2116->end(), systems_2975.begin(), systems_2975.end());
	_childSubsystem_2117->insert( _childSubsystem_2117->end(), childSubsystems_2976.begin(), childSubsystems_2976.end());
	_conditional_2118->insert( _conditional_2118->end(), conditionals_2977.begin(), conditionals_2977.end());
}

void AddTriggerVars_2119::operator()( const Packets_t& systems_211a, const Packets_t& triggers_211c, const Packets_t& argdecls_211e, const Packets_t& dts_2120, const Packets_t& oldvals_2122, const Packets_t& contexts_2124, const Packets_t& functions_2126, Packets_t& systems_2128, Packets_t& triggers_2129, Packets_t& argdecls_212a, Packets_t& dts_212b, Packets_t& oldvals_212c, Packets_t& contexts_212d, Packets_t& functions_212e)
{
#ifdef PRINT_INFO
	printLog( "AddTriggerVars_2119" );
#endif
	_system_212f= &systems_2128;
	_trigger_2130= &triggers_2129;
	_argdecl_2131= &argdecls_212a;
	_dt_2132= &dts_212b;
	_oldval_2133= &oldvals_212c;
	_context_2134= &contexts_212d;
	_function_2135= &functions_212e;
	_system_212f->insert( _system_212f->end(), systems_211a.begin(), systems_211a.end());
	_trigger_2130->insert( _trigger_2130->end(), triggers_211c.begin(), triggers_211c.end());
	_argdecl_2131->insert( _argdecl_2131->end(), argdecls_211e.begin(), argdecls_211e.end());
	_dt_2132->insert( _dt_2132->end(), dts_2120.begin(), dts_2120.end());
	_oldval_2133->insert( _oldval_2133->end(), oldvals_2122.begin(), oldvals_2122.end());
	_context_2134->insert( _context_2134->end(), contexts_2124.begin(), contexts_2124.end());
	_function_2135->insert( _function_2135->end(), functions_2126.begin(), functions_2126.end());
	if( ( !triggers_211c.empty())&& ( !argdecls_211e.empty())&& ( !dts_2120.empty())&& ( !oldvals_2122.empty())&& ( !contexts_2124.empty())&& ( !functions_2126.empty()))
		callAddMatrixTriggerVars_2805( triggers_211c, argdecls_211e, dts_2120, oldvals_2122, contexts_2124, functions_2126);
}

void AddTriggerVars_2119::callAddMatrixTriggerVars_2805( const Packets_t& triggers_2137, const Packets_t& argdecls_2139, const Packets_t& dts_213b, const Packets_t& oldvals_213d, const Packets_t& contexts_213f, const Packets_t& functions_2141)
{
	Packets_t triggers_2143;
	Packets_t argdecls_2144;
	Packets_t dts_2145;
	Packets_t oldvals_2146;
	Packets_t contexts_2147;
	Packets_t functions_2148;
	AddMatrixTriggerVars_2136 addMatrixTriggerVars_2136;
	addMatrixTriggerVars_2136( triggers_2137, argdecls_2139, dts_213b, oldvals_213d, contexts_213f, functions_2141, triggers_2143, argdecls_2144, dts_2145, oldvals_2146, contexts_2147, functions_2148);
	if( ( !triggers_2143.empty())&& ( !argdecls_2144.empty())&& ( !dts_2145.empty())&& ( !oldvals_2146.empty())&& ( !contexts_2147.empty())&& ( !functions_2148.empty()))
		callAddStructTriggerVars_280c( triggers_2143, argdecls_2144, dts_2145, oldvals_2146, contexts_2147, functions_2148);
}

void AddTriggerVars_2119::callAddStructTriggerVars_280c( const Packets_t& triggers_245e, const Packets_t& argdecls_2460, const Packets_t& dts_2462, const Packets_t& oldvals_2464, const Packets_t& contexts_2466, const Packets_t& functions_2468)
{
	AddStructTriggerVars_245d addStructTriggerVars_245d;
	addStructTriggerVars_245d( triggers_245e, argdecls_2460, dts_2462, oldvals_2464, contexts_2466, functions_2468);
}

void AddMatrixTriggerVars_2136::operator()( const Packets_t& triggers_2137, const Packets_t& argdecls_2139, const Packets_t& dts_213b, const Packets_t& oldvals_213d, const Packets_t& contexts_213f, const Packets_t& functions_2141, Packets_t& triggers_2143, Packets_t& argdecls_2144, Packets_t& dts_2145, Packets_t& oldvals_2146, Packets_t& contexts_2147, Packets_t& functions_2148)
{
#ifdef PRINT_INFO
	printLog( "AddMatrixTriggerVars_2136" );
#endif
	_trigger_2149= &triggers_2143;
	_argdecl_214a= &argdecls_2144;
	_dt_214b= &dts_2145;
	_oldval_214c= &oldvals_2146;
	_context_214d= &contexts_2147;
	_function_214e= &functions_2148;
	if( ( !triggers_2137.empty())&& ( !argdecls_2139.empty())&& ( !dts_213b.empty())&& ( !oldvals_213d.empty())&& ( !contexts_213f.empty())&& ( !functions_2141.empty()))
		callAddTriggerVar_2430( triggers_2137, argdecls_2139, dts_213b, oldvals_213d, contexts_213f, functions_2141);
	_trigger_2149->insert( _trigger_2149->end(), triggers_2137.begin(), triggers_2137.end());
	_argdecl_214a->insert( _argdecl_214a->end(), argdecls_2139.begin(), argdecls_2139.end());
	_dt_214b->insert( _dt_214b->end(), dts_213b.begin(), dts_213b.end());
	_oldval_214c->insert( _oldval_214c->end(), oldvals_213d.begin(), oldvals_213d.end());
	_context_214d->insert( _context_214d->end(), contexts_213f.begin(), contexts_213f.end());
	_function_214e->insert( _function_214e->end(), functions_2141.begin(), functions_2141.end());
}

void AddMatrixTriggerVars_2136::callAddTriggerVar_2430( const Packets_t& triggerPorts_23c5, const Packets_t& argDeclBases_23c8, const Packets_t& dTs_23cb, const Packets_t& localVars_23cd, const Packets_t& contexts_23d0, const Packets_t& functions_23d4)
{
	Packets_t triggerPorts_23c7;
	Packets_t argDeclBases_23ca;
	Packets_t localVars_23cf;
	Packets_t contexts_23d2;
	Packets_t triggerVars_23d3;
	Packets_t functions_23d6;
	AddTriggerVar_23c4 addTriggerVar_23c4;
	addTriggerVar_23c4( triggerPorts_23c5, argDeclBases_23c8, dTs_23cb, localVars_23cd, contexts_23d0, functions_23d4, triggerPorts_23c7, argDeclBases_23ca, localVars_23cf, contexts_23d2, triggerVars_23d3, functions_23d6);
	if( ( !triggerPorts_23c7.empty())&& ( !argDeclBases_23ca.empty())&& ( !localVars_23cf.empty())&& ( !contexts_23d2.empty())&& ( !triggerVars_23d3.empty())&& ( !functions_23d6.empty()))
		callStartAssignment_2437( triggerPorts_23c7, argDeclBases_23ca, localVars_23cf, contexts_23d2, triggerVars_23d3, functions_23d6);
}

void AddMatrixTriggerVars_2136::callStartAssignment_2437( const Packets_t& triggerPorts_2360, const Packets_t& argDeclBases_2363, const Packets_t& oldvals_2366, const Packets_t& contexts_2369, const Packets_t& triggerVars_236c, const Packets_t& functions_236e)
{
	Packets_t triggerPorts_2362;
	Packets_t argDeclBases_2365;
	Packets_t oldvals_2368;
	Packets_t contexts_236b;
	Packets_t unaryExprss_2370;
	StartAssignment_235f startAssignment_235f;
	startAssignment_235f( triggerPorts_2360, argDeclBases_2363, oldvals_2366, contexts_2369, triggerVars_236c, functions_236e, triggerPorts_2362, argDeclBases_2365, oldvals_2368, contexts_236b, unaryExprss_2370);
	if( ( !triggerPorts_2362.empty())&& ( !argDeclBases_2365.empty())&& ( !oldvals_2368.empty())&& ( !contexts_236b.empty())&& ( !unaryExprss_2370.empty()))
		callEdgeTest_243e( triggerPorts_2362, argDeclBases_2365, oldvals_2368, contexts_236b, unaryExprss_2370);
}

void AddMatrixTriggerVars_2136::callEdgeTest_243e( const Packets_t& triggers_2218, const Packets_t& argdecls_221a, const Packets_t& oldvals_221c, const Packets_t& contexts_221e, const Packets_t& initexprs_2220)
{
	Packets_t argdecls_2222;
	Packets_t oldvals_2223;
	Packets_t contexts_2224;
	Packets_t initexprs_2225;
	Packets_t argdecls_2226;
	Packets_t oldvals_2227;
	Packets_t contexts_2228;
	Packets_t initexprs_2229;
	Packets_t argdecls_222a;
	Packets_t oldvals_222b;
	Packets_t contexts_222c;
	Packets_t initexprs_222d;
	EdgeTest_2217 edgeTest_2217;
	edgeTest_2217( triggers_2218, argdecls_221a, oldvals_221c, contexts_221e, initexprs_2220, argdecls_2222, oldvals_2223, contexts_2224, initexprs_2225, argdecls_2226, oldvals_2227, contexts_2228, initexprs_2229, argdecls_222a, oldvals_222b, contexts_222c, initexprs_222d);
	if( ( !argdecls_222a.empty())&& ( !oldvals_222b.empty())&& ( !contexts_222c.empty())&& ( !initexprs_222d.empty()))
		callEitherEdge_2444( argdecls_222a, oldvals_222b, contexts_222c, initexprs_222d);
	if( ( !argdecls_2226.empty())&& ( !oldvals_2227.empty())&& ( !contexts_2228.empty())&& ( !initexprs_2229.empty()))
		callFallingEdge_2449( argdecls_2226, oldvals_2227, contexts_2228, initexprs_2229);
	if( ( !argdecls_2222.empty())&& ( !oldvals_2223.empty())&& ( !contexts_2224.empty())&& ( !initexprs_2225.empty()))
		callRisingEdge_244e( argdecls_2222, oldvals_2223, contexts_2224, initexprs_2225);
}

void AddMatrixTriggerVars_2136::callEitherEdge_2444( const Packets_t& argDeclBases_2150, const Packets_t& localVars_2153, const Packets_t& contexts_2156, const Packets_t& unaryExprss_2159)
{
	Packets_t argDeclBases_2152;
	Packets_t localVars_2155;
	Packets_t contexts_2158;
	Packets_t leftUnaryExprss_215b;
	Packets_t rightUnaryExprss_215c;
	EitherEdge_214f eitherEdge_214f;
	eitherEdge_214f( argDeclBases_2150, localVars_2153, contexts_2156, unaryExprss_2159, argDeclBases_2152, localVars_2155, contexts_2158, leftUnaryExprss_215b, rightUnaryExprss_215c);
	if( ( !argDeclBases_2152.empty())&& ( !localVars_2155.empty())&& ( !contexts_2158.empty())&& ( !rightUnaryExprss_215c.empty()))
		callFallingEdge_2453( argDeclBases_2152, localVars_2155, contexts_2158, rightUnaryExprss_215c);
	if( ( !argDeclBases_2152.empty())&& ( !localVars_2155.empty())&& ( !contexts_2158.empty())&& ( !leftUnaryExprss_215b.empty()))
		callRisingEdge_2458( argDeclBases_2152, localVars_2155, contexts_2158, leftUnaryExprss_215b);
}

void AddMatrixTriggerVars_2136::callFallingEdge_2449( const Packets_t& argDeclBases_219c, const Packets_t& localVars_219e, const Packets_t& contexts_21a0, const Packets_t& unaryExprss_21a2)
{
	FallingEdge_219b fallingEdge_219b;
	fallingEdge_219b( argDeclBases_219c, localVars_219e, contexts_21a0, unaryExprss_21a2);
}

void AddMatrixTriggerVars_2136::callRisingEdge_244e( const Packets_t& argDeclBases_21da, const Packets_t& localVars_21dc, const Packets_t& contexts_21de, const Packets_t& unaryExprss_21e0)
{
	RisingEdge_21d9 risingEdge_21d9;
	risingEdge_21d9( argDeclBases_21da, localVars_21dc, contexts_21de, unaryExprss_21e0);
}

void AddMatrixTriggerVars_2136::callFallingEdge_2453( const Packets_t& argDeclBases_219c, const Packets_t& localVars_219e, const Packets_t& contexts_21a0, const Packets_t& unaryExprss_21a2)
{
	FallingEdge_219b fallingEdge_219b;
	fallingEdge_219b( argDeclBases_219c, localVars_219e, contexts_21a0, unaryExprss_21a2);
}

void AddMatrixTriggerVars_2136::callRisingEdge_2458( const Packets_t& argDeclBases_21da, const Packets_t& localVars_21dc, const Packets_t& contexts_21de, const Packets_t& unaryExprss_21e0)
{
	RisingEdge_21d9 risingEdge_21d9;
	risingEdge_21d9( argDeclBases_21da, localVars_21dc, contexts_21de, unaryExprss_21e0);
}

void EitherEdge_214f::operator()( const Packets_t& argDeclBases_2150, const Packets_t& localVars_2153, const Packets_t& contexts_2156, const Packets_t& unaryExprss_2159, Packets_t& argDeclBases_2152, Packets_t& localVars_2155, Packets_t& contexts_2158, Packets_t& leftUnaryExprss_215b, Packets_t& rightUnaryExprss_215c)
{
#ifdef PRINT_INFO
	printLog( "EitherEdge_214f" );
#endif
	RTTGenerator::Instance()->generateRule(2156, "EitherEdge");
	_argDeclBase_215d= &argDeclBases_2152;
	_localVar_215e= &localVars_2155;
	_context_215f= &contexts_2158;
	_leftUnaryExprs_2160= &leftUnaryExprss_215b;
	_rightUnaryExprs_2161= &rightUnaryExprss_215c;
	processInputPackets( argDeclBases_2150, localVars_2153, contexts_2156, unaryExprss_2159);
}

bool EitherEdge_214f::isInputUnique( const Udm::Object& argDeclBase_2166, const Udm::Object& localVar_216f, const Udm::Object& context_2178, const Udm::Object& unaryExprs_2181)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_2168= _argDeclBase_2162.begin(), itLocalVar_2171= _localVar_216b.begin(), itContext_217a= _context_2174.begin(), itUnaryExprs_2183= _unaryExprs_217d.begin(); itArgDeclBase_2168!= _argDeclBase_2162.end(), itLocalVar_2171!= _localVar_216b.end(), itContext_217a!= _context_2174.end(), itUnaryExprs_2183!= _unaryExprs_217d.end(); ++itArgDeclBase_2168, ++itLocalVar_2171, ++itContext_217a, ++itUnaryExprs_2183)
	{
		if( ( *itArgDeclBase_2168== argDeclBase_2166)&& ( *itLocalVar_2171== localVar_216f)&& ( *itContext_217a== context_2178)&& ( *itUnaryExprs_2183== unaryExprs_2181))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_2162.push_back( argDeclBase_2166);
		_localVar_216b.push_back( localVar_216f);
		_context_2174.push_back( context_2178);
		_unaryExprs_217d.push_back( unaryExprs_2181);
	}
	return isUnique;
}

bool EitherEdge_214f::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void EitherEdge_214f::processInputPackets( const Packets_t& argDeclBases_2150, const Packets_t& localVars_2153, const Packets_t& contexts_2156, const Packets_t& unaryExprss_2159)
{
	for( Packets_t::const_iterator itArgDeclBase_2163= argDeclBases_2150.begin(), itLocalVar_216c= localVars_2153.begin(), itContext_2175= contexts_2156.begin(), itUnaryExprs_217e= unaryExprss_2159.begin(); itArgDeclBase_2163!= argDeclBases_2150.end(), itLocalVar_216c!= localVars_2153.end(), itContext_2175!= contexts_2156.end(), itUnaryExprs_217e!= unaryExprss_2159.end(); ++itArgDeclBase_2163, ++itLocalVar_216c, ++itContext_2175, ++itUnaryExprs_217e)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_2163, *itLocalVar_216c, *itContext_2175, *itUnaryExprs_217e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_2163, *itLocalVar_216c, *itContext_2175, *itUnaryExprs_217e);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool EitherEdge_214f::patternMatcher( const Udm::Object& argDeclBase_2164, const Udm::Object& localVar_216d, const Udm::Object& context_2176, const Udm::Object& unaryExprs_217f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_2164.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_2169= SFC::ArgDeclBase::Cast( argDeclBase_2164);
		if( false== Uml::IsDerivedFrom( localVar_216d.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_2172= SFC::LocalVar::Cast( localVar_216d);
		if( false== Uml::IsDerivedFrom( context_2176.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_217b= SFC::Arg::Cast( context_2176);
		if( false== Uml::IsDerivedFrom( unaryExprs_217f.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_2184= SFC::UnaryExprs::Cast( unaryExprs_217f);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2189;
		if( !isValidBound(boundObjs_2189, argDeclBase_2169, true))
			continue;
		currMatch.argDeclBase_218a= argDeclBase_2169;
		if( !isValidBound(boundObjs_2189, localVar_2172, true))
			continue;
		currMatch.localVar_218b= localVar_2172;
		if( !isValidBound(boundObjs_2189, context_217b, true))
			continue;
		currMatch.context_218c= context_217b;
		if( !isValidBound(boundObjs_2189, unaryExprs_2184, true))
			continue;
		currMatch.unaryExprs_218d= unaryExprs_2184;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void EitherEdge_214f::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newOr_218e= SFC::BinaryExprs::Create( currMatch.unaryExprs_218d, SFC::UnaryExprs::meta_subexpr);
		SFC::UnaryExprs newRightUnaryExprs_218f= SFC::UnaryExprs::Create( newOr_218e, SFC::BinaryExprs::meta_rightexpr);
		SFC::UnaryExprs newLeftUnaryExprs_2190= SFC::UnaryExprs::Create( newOr_218e, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_218a;
		SFC::Arg& Context= currMatch.context_218c;
		SFC::UnaryExprs& LeftUnaryExprs= newLeftUnaryExprs_2190;
		SFC::LocalVar& LocalVar= currMatch.localVar_218b;
		SFC::BinaryExprs& Or= newOr_218e;
		SFC::UnaryExprs& RightUnaryExprs= newRightUnaryExprs_218f;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_218d;
		{
RightUnaryExprs.op() = "";
};
		{
LeftUnaryExprs.op() = "";
};
		{
Or.op() = "||";
};
		outputAppender( currMatch.argDeclBase_218a, currMatch.localVar_218b, currMatch.context_218c, newLeftUnaryExprs_2190, newRightUnaryExprs_218f);
	}
}

void EitherEdge_214f::outputAppender( const SFC::ArgDeclBase& argDeclBase_2191, const SFC::LocalVar& localVar_2193, const SFC::Arg& context_2195, const SFC::UnaryExprs& leftUnaryExprs_2197, const SFC::UnaryExprs& rightUnaryExprs_2199)
{
	_argDeclBase_215d->push_back( argDeclBase_2191);
	_localVar_215e->push_back( localVar_2193);
	_context_215f->push_back( context_2195);
	_leftUnaryExprs_2160->push_back( leftUnaryExprs_2197);
	_rightUnaryExprs_2161->push_back( rightUnaryExprs_2199);
}

void FallingEdge_219b::operator()( const Packets_t& argDeclBases_219c, const Packets_t& localVars_219e, const Packets_t& contexts_21a0, const Packets_t& unaryExprss_21a2)
{
#ifdef PRINT_INFO
	printLog( "FallingEdge_219b" );
#endif
	RTTGenerator::Instance()->generateRule(2170, "FallingEdge");
	processInputPackets( argDeclBases_219c, localVars_219e, contexts_21a0, unaryExprss_21a2);
}

bool FallingEdge_219b::isInputUnique( const Udm::Object& argDeclBase_21a8, const Udm::Object& localVar_21b1, const Udm::Object& context_21ba, const Udm::Object& unaryExprs_21c3)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_21aa= _argDeclBase_21a4.begin(), itLocalVar_21b3= _localVar_21ad.begin(), itContext_21bc= _context_21b6.begin(), itUnaryExprs_21c5= _unaryExprs_21bf.begin(); itArgDeclBase_21aa!= _argDeclBase_21a4.end(), itLocalVar_21b3!= _localVar_21ad.end(), itContext_21bc!= _context_21b6.end(), itUnaryExprs_21c5!= _unaryExprs_21bf.end(); ++itArgDeclBase_21aa, ++itLocalVar_21b3, ++itContext_21bc, ++itUnaryExprs_21c5)
	{
		if( ( *itArgDeclBase_21aa== argDeclBase_21a8)&& ( *itLocalVar_21b3== localVar_21b1)&& ( *itContext_21bc== context_21ba)&& ( *itUnaryExprs_21c5== unaryExprs_21c3))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_21a4.push_back( argDeclBase_21a8);
		_localVar_21ad.push_back( localVar_21b1);
		_context_21b6.push_back( context_21ba);
		_unaryExprs_21bf.push_back( unaryExprs_21c3);
	}
	return isUnique;
}

bool FallingEdge_219b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void FallingEdge_219b::processInputPackets( const Packets_t& argDeclBases_219c, const Packets_t& localVars_219e, const Packets_t& contexts_21a0, const Packets_t& unaryExprss_21a2)
{
	for( Packets_t::const_iterator itArgDeclBase_21a5= argDeclBases_219c.begin(), itLocalVar_21ae= localVars_219e.begin(), itContext_21b7= contexts_21a0.begin(), itUnaryExprs_21c0= unaryExprss_21a2.begin(); itArgDeclBase_21a5!= argDeclBases_219c.end(), itLocalVar_21ae!= localVars_219e.end(), itContext_21b7!= contexts_21a0.end(), itUnaryExprs_21c0!= unaryExprss_21a2.end(); ++itArgDeclBase_21a5, ++itLocalVar_21ae, ++itContext_21b7, ++itUnaryExprs_21c0)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_21a5, *itLocalVar_21ae, *itContext_21b7, *itUnaryExprs_21c0);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_21a5, *itLocalVar_21ae, *itContext_21b7, *itUnaryExprs_21c0);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool FallingEdge_219b::patternMatcher( const Udm::Object& argDeclBase_21a6, const Udm::Object& localVar_21af, const Udm::Object& context_21b8, const Udm::Object& unaryExprs_21c1)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_21a6.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_21ab= SFC::ArgDeclBase::Cast( argDeclBase_21a6);
		if( false== Uml::IsDerivedFrom( localVar_21af.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_21b4= SFC::LocalVar::Cast( localVar_21af);
		if( false== Uml::IsDerivedFrom( context_21b8.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_21bd= SFC::Arg::Cast( context_21b8);
		if( false== Uml::IsDerivedFrom( unaryExprs_21c1.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_21c6= SFC::UnaryExprs::Cast( unaryExprs_21c1);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_21cb;
		if( !isValidBound(boundObjs_21cb, argDeclBase_21ab, true))
			continue;
		currMatch.argDeclBase_21cc= argDeclBase_21ab;
		if( !isValidBound(boundObjs_21cb, localVar_21b4, true))
			continue;
		currMatch.localVar_21cd= localVar_21b4;
		if( !isValidBound(boundObjs_21cb, context_21bd, true))
			continue;
		currMatch.context_21ce= context_21bd;
		if( !isValidBound(boundObjs_21cb, unaryExprs_21c6, true))
			continue;
		currMatch.unaryExprs_21cf= unaryExprs_21c6;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void FallingEdge_219b::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newAnd_21d0= SFC::BinaryExprs::Create( currMatch.unaryExprs_21cf, SFC::UnaryExprs::meta_subexpr);
		SFC::BinaryExprs newGreaterThan_21d1= SFC::BinaryExprs::Create( newAnd_21d0, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newZero_21d2= SFC::Int::Create( newGreaterThan_21d1, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newDot_21d3= SFC::BinaryExprs::Create( newGreaterThan_21d1, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_21d4= SFC::ArgDeclRef::Create( newDot_21d3, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef3_21d5= SFC::ArgDeclRef::Create( newDot_21d3, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newLessThan_21d6= SFC::BinaryExprs::Create( newAnd_21d0, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_21d7= SFC::ArgDeclRef::Create( newLessThan_21d6, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newZero2_21d8= SFC::Int::Create( newLessThan_21d6, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs& And= newAnd_21d0;
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_21cc;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_21d7;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_21d4;
		SFC::ArgDeclRef& ArgDeclRef3= newArgDeclRef3_21d5;
		SFC::Arg& Context= currMatch.context_21ce;
		SFC::BinaryExprs& Dot= newDot_21d3;
		SFC::BinaryExprs& GreaterThan= newGreaterThan_21d1;
		SFC::BinaryExprs& LessThan= newLessThan_21d6;
		SFC::LocalVar& LocalVar= currMatch.localVar_21cd;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_21cf;
		SFC::Int& Zero= newZero_21d2;
		SFC::Int& Zero2= newZero2_21d8;
		{
GreaterThan.op() = ">=";
};
		{
LessThan.op() = "<";
};
		{
And.op() = "&&";
};
		{
Dot.op() = ".";
};
		{
Zero.val() = 0;
};
		{
Zero2.val() = 0;
};
		newArgDeclRef_21d7.argdecl()= currMatch.argDeclBase_21cc;
		newArgDeclRef3_21d5.argdecl()= currMatch.context_21ce;
		newArgDeclRef2_21d4.argdecl()= currMatch.localVar_21cd;
	}
}

void RisingEdge_21d9::operator()( const Packets_t& argDeclBases_21da, const Packets_t& localVars_21dc, const Packets_t& contexts_21de, const Packets_t& unaryExprss_21e0)
{
#ifdef PRINT_INFO
	printLog( "RisingEdge_21d9" );
#endif
	RTTGenerator::Instance()->generateRule(2202, "RisingEdge");
	processInputPackets( argDeclBases_21da, localVars_21dc, contexts_21de, unaryExprss_21e0);
}

bool RisingEdge_21d9::isInputUnique( const Udm::Object& argDeclBase_21e6, const Udm::Object& localVar_21ef, const Udm::Object& context_21f8, const Udm::Object& unaryExprs_2201)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_21e8= _argDeclBase_21e2.begin(), itLocalVar_21f1= _localVar_21eb.begin(), itContext_21fa= _context_21f4.begin(), itUnaryExprs_2203= _unaryExprs_21fd.begin(); itArgDeclBase_21e8!= _argDeclBase_21e2.end(), itLocalVar_21f1!= _localVar_21eb.end(), itContext_21fa!= _context_21f4.end(), itUnaryExprs_2203!= _unaryExprs_21fd.end(); ++itArgDeclBase_21e8, ++itLocalVar_21f1, ++itContext_21fa, ++itUnaryExprs_2203)
	{
		if( ( *itArgDeclBase_21e8== argDeclBase_21e6)&& ( *itLocalVar_21f1== localVar_21ef)&& ( *itContext_21fa== context_21f8)&& ( *itUnaryExprs_2203== unaryExprs_2201))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_21e2.push_back( argDeclBase_21e6);
		_localVar_21eb.push_back( localVar_21ef);
		_context_21f4.push_back( context_21f8);
		_unaryExprs_21fd.push_back( unaryExprs_2201);
	}
	return isUnique;
}

bool RisingEdge_21d9::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void RisingEdge_21d9::processInputPackets( const Packets_t& argDeclBases_21da, const Packets_t& localVars_21dc, const Packets_t& contexts_21de, const Packets_t& unaryExprss_21e0)
{
	for( Packets_t::const_iterator itArgDeclBase_21e3= argDeclBases_21da.begin(), itLocalVar_21ec= localVars_21dc.begin(), itContext_21f5= contexts_21de.begin(), itUnaryExprs_21fe= unaryExprss_21e0.begin(); itArgDeclBase_21e3!= argDeclBases_21da.end(), itLocalVar_21ec!= localVars_21dc.end(), itContext_21f5!= contexts_21de.end(), itUnaryExprs_21fe!= unaryExprss_21e0.end(); ++itArgDeclBase_21e3, ++itLocalVar_21ec, ++itContext_21f5, ++itUnaryExprs_21fe)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_21e3, *itLocalVar_21ec, *itContext_21f5, *itUnaryExprs_21fe);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_21e3, *itLocalVar_21ec, *itContext_21f5, *itUnaryExprs_21fe);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool RisingEdge_21d9::patternMatcher( const Udm::Object& argDeclBase_21e4, const Udm::Object& localVar_21ed, const Udm::Object& context_21f6, const Udm::Object& unaryExprs_21ff)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_21e4.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_21e9= SFC::ArgDeclBase::Cast( argDeclBase_21e4);
		if( false== Uml::IsDerivedFrom( localVar_21ed.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_21f2= SFC::LocalVar::Cast( localVar_21ed);
		if( false== Uml::IsDerivedFrom( context_21f6.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_21fb= SFC::Arg::Cast( context_21f6);
		if( false== Uml::IsDerivedFrom( unaryExprs_21ff.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_2204= SFC::UnaryExprs::Cast( unaryExprs_21ff);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2209;
		if( !isValidBound(boundObjs_2209, argDeclBase_21e9, true))
			continue;
		currMatch.argDeclBase_220a= argDeclBase_21e9;
		if( !isValidBound(boundObjs_2209, localVar_21f2, true))
			continue;
		currMatch.localVar_220b= localVar_21f2;
		if( !isValidBound(boundObjs_2209, context_21fb, true))
			continue;
		currMatch.context_220c= context_21fb;
		if( !isValidBound(boundObjs_2209, unaryExprs_2204, true))
			continue;
		currMatch.unaryExprs_220d= unaryExprs_2204;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void RisingEdge_21d9::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newAnd_220e= SFC::BinaryExprs::Create( currMatch.unaryExprs_220d, SFC::UnaryExprs::meta_subexpr);
		SFC::BinaryExprs newLessThan_220f= SFC::BinaryExprs::Create( newAnd_220e, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newGreaterThan_2210= SFC::BinaryExprs::Create( newAnd_220e, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newDot_2211= SFC::BinaryExprs::Create( newLessThan_220f, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_2212= SFC::ArgDeclRef::Create( newDot_2211, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_2213= SFC::ArgDeclRef::Create( newGreaterThan_2210, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newZero2_2214= SFC::Int::Create( newGreaterThan_2210, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newZero_2215= SFC::Int::Create( newLessThan_220f, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef3_2216= SFC::ArgDeclRef::Create( newDot_2211, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs& And= newAnd_220e;
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_220a;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_2213;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_2212;
		SFC::ArgDeclRef& ArgDeclRef3= newArgDeclRef3_2216;
		SFC::Arg& Context= currMatch.context_220c;
		SFC::BinaryExprs& Dot= newDot_2211;
		SFC::BinaryExprs& GreaterThan= newGreaterThan_2210;
		SFC::BinaryExprs& LessThan= newLessThan_220f;
		SFC::LocalVar& LocalVar= currMatch.localVar_220b;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_220d;
		SFC::Int& Zero= newZero_2215;
		SFC::Int& Zero2= newZero2_2214;
		{
Zero2.val() = 0;
};
		{
Zero.val() = 0;
};
		{
Dot.op() = ".";
};
		{
GreaterThan.op() = ">";
};
		{
And.op() = "&&";
};
		{
LessThan.op() = "<=";
};
		newArgDeclRef3_2216.argdecl()= currMatch.context_220c;
		newArgDeclRef_2213.argdecl()= currMatch.argDeclBase_220a;
		newArgDeclRef2_2212.argdecl()= currMatch.localVar_220b;
	}
}

void EdgeTest_2217::operator()( const Packets_t& triggers_2218, const Packets_t& argdecls_221a, const Packets_t& oldvals_221c, const Packets_t& contexts_221e, const Packets_t& initexprs_2220, Packets_t& argdecls_2222, Packets_t& oldvals_2223, Packets_t& contexts_2224, Packets_t& initexprs_2225, Packets_t& argdecls_2226, Packets_t& oldvals_2227, Packets_t& contexts_2228, Packets_t& initexprs_2229, Packets_t& argdecls_222a, Packets_t& oldvals_222b, Packets_t& contexts_222c, Packets_t& initexprs_222d)
{
#ifdef PRINT_INFO
	printLog( "EdgeTest_2217" );
#endif
	_argdecl_222e= &argdecls_2222;
	_oldval_222f= &oldvals_2223;
	_context_2230= &contexts_2224;
	_initexpr_2231= &initexprs_2225;
	_argdecl_2232= &argdecls_2226;
	_oldval_2233= &oldvals_2227;
	_context_2234= &contexts_2228;
	_initexpr_2235= &initexprs_2229;
	_argdecl_2236= &argdecls_222a;
	_oldval_2237= &oldvals_222b;
	_context_2238= &contexts_222c;
	_initexpr_2239= &initexprs_222d;
	for( Packets_t::const_iterator ittrigger_223b= triggers_2218.begin(), itargdecl_2242= argdecls_221a.begin(), itoldval_2249= oldvals_221c.begin(), itcontext_2250= contexts_221e.begin(), itinitexpr_2257= initexprs_2220.begin(); ittrigger_223b!= triggers_2218.end(), itargdecl_2242!= argdecls_221a.end(), itoldval_2249!= oldvals_221c.end(), itcontext_2250!= contexts_221e.end(), itinitexpr_2257!= initexprs_2220.end(); ++ittrigger_223b, ++itargdecl_2242, ++itoldval_2249, ++itcontext_2250, ++itinitexpr_2257)
	{
		bool isUnique= isInputUnique( *ittrigger_223b, *itargdecl_2242, *itoldval_2249, *itcontext_2250, *itinitexpr_2257);
		if( !isUnique)
			continue;
		Packets_t onetrigger_223f( 1, *ittrigger_223b);
		Packets_t oneargdecl_2246( 1, *itargdecl_2242);
		Packets_t oneoldval_224d( 1, *itoldval_2249);
		Packets_t onecontext_2254( 1, *itcontext_2250);
		Packets_t oneinitexpr_225b( 1, *itinitexpr_2257);
		executeOne( onetrigger_223f, oneargdecl_2246, oneoldval_224d, onecontext_2254, oneinitexpr_225b);
	}
}

void EdgeTest_2217::executeOne( const Packets_t& triggers_2218, const Packets_t& argdecls_221a, const Packets_t& oldvals_221c, const Packets_t& contexts_221e, const Packets_t& initexprs_2220)
{
	Packets_t argDeclBases_2262;
	Packets_t localVars_2265;
	Packets_t contexts_2268;
	Packets_t unaryExprss_226b;
	RisingEdge_225d risingEdge_225d;
	bool isMatchRisingEdge_225d= risingEdge_225d( triggers_2218, argdecls_221a, oldvals_221c, contexts_221e, initexprs_2220, argDeclBases_2262, localVars_2265, contexts_2268, unaryExprss_226b);
	_argdecl_222e->insert( _argdecl_222e->end(), argDeclBases_2262.begin(), argDeclBases_2262.end());
	_oldval_222f->insert( _oldval_222f->end(), localVars_2265.begin(), localVars_2265.end());
	_context_2230->insert( _context_2230->end(), contexts_2268.begin(), contexts_2268.end());
	_initexpr_2231->insert( _initexpr_2231->end(), unaryExprss_226b.begin(), unaryExprss_226b.end());
	if( isMatchRisingEdge_225d)
		return;
	Packets_t argDeclBases_22b8;
	Packets_t localVars_22bb;
	Packets_t contexts_22be;
	Packets_t unaryExprss_22c1;
	FallingEdge_22b3 fallingEdge_22b3;
	bool isMatchFallingEdge_22b3= fallingEdge_22b3( triggers_2218, argdecls_221a, oldvals_221c, contexts_221e, initexprs_2220, argDeclBases_22b8, localVars_22bb, contexts_22be, unaryExprss_22c1);
	_argdecl_2232->insert( _argdecl_2232->end(), argDeclBases_22b8.begin(), argDeclBases_22b8.end());
	_oldval_2233->insert( _oldval_2233->end(), localVars_22bb.begin(), localVars_22bb.end());
	_context_2234->insert( _context_2234->end(), contexts_22be.begin(), contexts_22be.end());
	_initexpr_2235->insert( _initexpr_2235->end(), unaryExprss_22c1.begin(), unaryExprss_22c1.end());
	Packets_t argDeclBases_230e;
	Packets_t localVars_2311;
	Packets_t contexts_2314;
	Packets_t unaryExprss_2317;
	EitherEdge_2309 eitherEdge_2309;
	bool isMatchEitherEdge_2309= eitherEdge_2309( triggers_2218, argdecls_221a, oldvals_221c, contexts_221e, initexprs_2220, argDeclBases_230e, localVars_2311, contexts_2314, unaryExprss_2317);
	_argdecl_2236->insert( _argdecl_2236->end(), argDeclBases_230e.begin(), argDeclBases_230e.end());
	_oldval_2237->insert( _oldval_2237->end(), localVars_2311.begin(), localVars_2311.end());
	_context_2238->insert( _context_2238->end(), contexts_2314.begin(), contexts_2314.end());
	_initexpr_2239->insert( _initexpr_2239->end(), unaryExprss_2317.begin(), unaryExprss_2317.end());
}

bool EdgeTest_2217::isInputUnique( const Udm::Object& trigger_223c, const Udm::Object& argdecl_2243, const Udm::Object& oldval_224a, const Udm::Object& context_2251, const Udm::Object& initexpr_2258)
{
	bool isUnique= true;
	for( Packets_t::const_iterator ittrigger_223e= _trigger_223a.begin(), itargdecl_2245= _argdecl_2241.begin(), itoldval_224c= _oldval_2248.begin(), itcontext_2253= _context_224f.begin(), itinitexpr_225a= _initexpr_2256.begin(); ittrigger_223e!= _trigger_223a.end(), itargdecl_2245!= _argdecl_2241.end(), itoldval_224c!= _oldval_2248.end(), itcontext_2253!= _context_224f.end(), itinitexpr_225a!= _initexpr_2256.end(); ++ittrigger_223e, ++itargdecl_2245, ++itoldval_224c, ++itcontext_2253, ++itinitexpr_225a)
	{
		if( ( *ittrigger_223e== trigger_223c)&& ( *itargdecl_2245== argdecl_2243)&& ( *itoldval_224c== oldval_224a)&& ( *itcontext_2253== context_2251)&& ( *itinitexpr_225a== initexpr_2258))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_trigger_223a.push_back( trigger_223c);
		_argdecl_2241.push_back( argdecl_2243);
		_oldval_2248.push_back( oldval_224a);
		_context_224f.push_back( context_2251);
		_initexpr_2256.push_back( initexpr_2258);
	}
	return isUnique;
}

bool RisingEdge_225d::operator()( const Packets_t& triggerPorts_225e, const Packets_t& argDeclBases_2260, const Packets_t& localVars_2263, const Packets_t& contexts_2266, const Packets_t& unaryExprss_2269, Packets_t& argDeclBases_2262, Packets_t& localVars_2265, Packets_t& contexts_2268, Packets_t& unaryExprss_226b)
{
#ifdef PRINT_INFO
	printLog( "RisingEdge_225d" );
#endif
	_argDeclBase_226c= &argDeclBases_2262;
	_localVar_226d= &localVars_2265;
	_context_226e= &contexts_2268;
	_unaryExprs_226f= &unaryExprss_226b;
	processInputPackets( triggerPorts_225e, argDeclBases_2260, localVars_2263, contexts_2266, unaryExprss_2269);
	if( false== _matches.empty())
		return true;
	return false;
}

bool RisingEdge_225d::isInputUnique( const Udm::Object& triggerPort_2274, const Udm::Object& argDeclBase_227d, const Udm::Object& localVar_2286, const Udm::Object& context_228f, const Udm::Object& unaryExprs_2298)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itTriggerPort_2276= _triggerPort_2270.begin(), itArgDeclBase_227f= _argDeclBase_2279.begin(), itLocalVar_2288= _localVar_2282.begin(), itContext_2291= _context_228b.begin(), itUnaryExprs_229a= _unaryExprs_2294.begin(); itTriggerPort_2276!= _triggerPort_2270.end(), itArgDeclBase_227f!= _argDeclBase_2279.end(), itLocalVar_2288!= _localVar_2282.end(), itContext_2291!= _context_228b.end(), itUnaryExprs_229a!= _unaryExprs_2294.end(); ++itTriggerPort_2276, ++itArgDeclBase_227f, ++itLocalVar_2288, ++itContext_2291, ++itUnaryExprs_229a)
	{
		if( ( *itTriggerPort_2276== triggerPort_2274)&& ( *itArgDeclBase_227f== argDeclBase_227d)&& ( *itLocalVar_2288== localVar_2286)&& ( *itContext_2291== context_228f)&& ( *itUnaryExprs_229a== unaryExprs_2298))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_triggerPort_2270.push_back( triggerPort_2274);
		_argDeclBase_2279.push_back( argDeclBase_227d);
		_localVar_2282.push_back( localVar_2286);
		_context_228b.push_back( context_228f);
		_unaryExprs_2294.push_back( unaryExprs_2298);
	}
	return isUnique;
}

bool RisingEdge_225d::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool RisingEdge_225d::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, SFC::Arg& Context, SFC::LocalVar& LocalVar, CyberComposition::Simulink::TriggerPort& TriggerPort, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	std::string trigger = TriggerPort.TriggerType();
Gz_guard = trigger == "rising";;
	return Gz_guard;
}

void RisingEdge_225d::processInputPackets( const Packets_t& triggerPorts_225e, const Packets_t& argDeclBases_2260, const Packets_t& localVars_2263, const Packets_t& contexts_2266, const Packets_t& unaryExprss_2269)
{
	for( Packets_t::const_iterator itTriggerPort_2271= triggerPorts_225e.begin(), itArgDeclBase_227a= argDeclBases_2260.begin(), itLocalVar_2283= localVars_2263.begin(), itContext_228c= contexts_2266.begin(), itUnaryExprs_2295= unaryExprss_2269.begin(); itTriggerPort_2271!= triggerPorts_225e.end(), itArgDeclBase_227a!= argDeclBases_2260.end(), itLocalVar_2283!= localVars_2263.end(), itContext_228c!= contexts_2266.end(), itUnaryExprs_2295!= unaryExprss_2269.end(); ++itTriggerPort_2271, ++itArgDeclBase_227a, ++itLocalVar_2283, ++itContext_228c, ++itUnaryExprs_2295)
	{
		bool isUnique= isInputUnique( *itTriggerPort_2271, *itArgDeclBase_227a, *itLocalVar_2283, *itContext_228c, *itUnaryExprs_2295);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itTriggerPort_2271, *itArgDeclBase_227a, *itLocalVar_2283, *itContext_228c, *itUnaryExprs_2295);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_22a2, currMatch.localVar_22a3, currMatch.context_22a4, currMatch.unaryExprs_22a5);
	}
}

bool RisingEdge_225d::patternMatcher( const Udm::Object& triggerPort_2272, const Udm::Object& argDeclBase_227b, const Udm::Object& localVar_2284, const Udm::Object& context_228d, const Udm::Object& unaryExprs_2296)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( triggerPort_2272.type(), CyberComposition::Simulink::TriggerPort::meta))
			continue;
		CyberComposition::Simulink::TriggerPort triggerPort_2277= CyberComposition::Simulink::TriggerPort::Cast( triggerPort_2272);
		if( false== Uml::IsDerivedFrom( argDeclBase_227b.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_2280= SFC::ArgDeclBase::Cast( argDeclBase_227b);
		if( false== Uml::IsDerivedFrom( localVar_2284.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_2289= SFC::LocalVar::Cast( localVar_2284);
		if( false== Uml::IsDerivedFrom( context_228d.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_2292= SFC::Arg::Cast( context_228d);
		if( false== Uml::IsDerivedFrom( unaryExprs_2296.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_229b= SFC::UnaryExprs::Cast( unaryExprs_2296);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_22a0;
		if( !isValidBound(boundObjs_22a0, triggerPort_2277, true))
			continue;
		currMatch.triggerPort_22a1= triggerPort_2277;
		if( !isValidBound(boundObjs_22a0, argDeclBase_2280, true))
			continue;
		currMatch.argDeclBase_22a2= argDeclBase_2280;
		if( !isValidBound(boundObjs_22a0, localVar_2289, true))
			continue;
		currMatch.localVar_22a3= localVar_2289;
		if( !isValidBound(boundObjs_22a0, context_2292, true))
			continue;
		currMatch.context_22a4= context_2292;
		if( !isValidBound(boundObjs_22a0, unaryExprs_229b, true))
			continue;
		currMatch.unaryExprs_22a5= unaryExprs_229b;
		bool Gz_guard= isGuardTrue( currMatch.argDeclBase_22a2, currMatch.context_22a4, currMatch.localVar_22a3, currMatch.triggerPort_22a1, currMatch.unaryExprs_22a5);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void RisingEdge_225d::outputAppender( const SFC::ArgDeclBase& argDeclBase_22ab, const SFC::LocalVar& localVar_22ad, const SFC::Arg& context_22af, const SFC::UnaryExprs& unaryExprs_22b1)
{
	_argDeclBase_226c->push_back( argDeclBase_22ab);
	_localVar_226d->push_back( localVar_22ad);
	_context_226e->push_back( context_22af);
	_unaryExprs_226f->push_back( unaryExprs_22b1);
}

bool FallingEdge_22b3::operator()( const Packets_t& triggerPorts_22b4, const Packets_t& argDeclBases_22b6, const Packets_t& localVars_22b9, const Packets_t& contexts_22bc, const Packets_t& unaryExprss_22bf, Packets_t& argDeclBases_22b8, Packets_t& localVars_22bb, Packets_t& contexts_22be, Packets_t& unaryExprss_22c1)
{
#ifdef PRINT_INFO
	printLog( "FallingEdge_22b3" );
#endif
	_argDeclBase_22c2= &argDeclBases_22b8;
	_localVar_22c3= &localVars_22bb;
	_context_22c4= &contexts_22be;
	_unaryExprs_22c5= &unaryExprss_22c1;
	processInputPackets( triggerPorts_22b4, argDeclBases_22b6, localVars_22b9, contexts_22bc, unaryExprss_22bf);
	if( false== _matches.empty())
		return true;
	return false;
}

bool FallingEdge_22b3::isInputUnique( const Udm::Object& triggerPort_22ca, const Udm::Object& argDeclBase_22d3, const Udm::Object& localVar_22dc, const Udm::Object& context_22e5, const Udm::Object& unaryExprs_22ee)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itTriggerPort_22cc= _triggerPort_22c6.begin(), itArgDeclBase_22d5= _argDeclBase_22cf.begin(), itLocalVar_22de= _localVar_22d8.begin(), itContext_22e7= _context_22e1.begin(), itUnaryExprs_22f0= _unaryExprs_22ea.begin(); itTriggerPort_22cc!= _triggerPort_22c6.end(), itArgDeclBase_22d5!= _argDeclBase_22cf.end(), itLocalVar_22de!= _localVar_22d8.end(), itContext_22e7!= _context_22e1.end(), itUnaryExprs_22f0!= _unaryExprs_22ea.end(); ++itTriggerPort_22cc, ++itArgDeclBase_22d5, ++itLocalVar_22de, ++itContext_22e7, ++itUnaryExprs_22f0)
	{
		if( ( *itTriggerPort_22cc== triggerPort_22ca)&& ( *itArgDeclBase_22d5== argDeclBase_22d3)&& ( *itLocalVar_22de== localVar_22dc)&& ( *itContext_22e7== context_22e5)&& ( *itUnaryExprs_22f0== unaryExprs_22ee))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_triggerPort_22c6.push_back( triggerPort_22ca);
		_argDeclBase_22cf.push_back( argDeclBase_22d3);
		_localVar_22d8.push_back( localVar_22dc);
		_context_22e1.push_back( context_22e5);
		_unaryExprs_22ea.push_back( unaryExprs_22ee);
	}
	return isUnique;
}

bool FallingEdge_22b3::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool FallingEdge_22b3::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, SFC::Arg& Context, SFC::LocalVar& LocalVar, CyberComposition::Simulink::TriggerPort& TriggerPort, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	std::string trigger = TriggerPort.TriggerType();
Gz_guard = trigger == "falling";;
	return Gz_guard;
}

void FallingEdge_22b3::processInputPackets( const Packets_t& triggerPorts_22b4, const Packets_t& argDeclBases_22b6, const Packets_t& localVars_22b9, const Packets_t& contexts_22bc, const Packets_t& unaryExprss_22bf)
{
	for( Packets_t::const_iterator itTriggerPort_22c7= triggerPorts_22b4.begin(), itArgDeclBase_22d0= argDeclBases_22b6.begin(), itLocalVar_22d9= localVars_22b9.begin(), itContext_22e2= contexts_22bc.begin(), itUnaryExprs_22eb= unaryExprss_22bf.begin(); itTriggerPort_22c7!= triggerPorts_22b4.end(), itArgDeclBase_22d0!= argDeclBases_22b6.end(), itLocalVar_22d9!= localVars_22b9.end(), itContext_22e2!= contexts_22bc.end(), itUnaryExprs_22eb!= unaryExprss_22bf.end(); ++itTriggerPort_22c7, ++itArgDeclBase_22d0, ++itLocalVar_22d9, ++itContext_22e2, ++itUnaryExprs_22eb)
	{
		bool isUnique= isInputUnique( *itTriggerPort_22c7, *itArgDeclBase_22d0, *itLocalVar_22d9, *itContext_22e2, *itUnaryExprs_22eb);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itTriggerPort_22c7, *itArgDeclBase_22d0, *itLocalVar_22d9, *itContext_22e2, *itUnaryExprs_22eb);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_22f8, currMatch.localVar_22f9, currMatch.context_22fa, currMatch.unaryExprs_22fb);
	}
}

bool FallingEdge_22b3::patternMatcher( const Udm::Object& triggerPort_22c8, const Udm::Object& argDeclBase_22d1, const Udm::Object& localVar_22da, const Udm::Object& context_22e3, const Udm::Object& unaryExprs_22ec)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( triggerPort_22c8.type(), CyberComposition::Simulink::TriggerPort::meta))
			continue;
		CyberComposition::Simulink::TriggerPort triggerPort_22cd= CyberComposition::Simulink::TriggerPort::Cast( triggerPort_22c8);
		if( false== Uml::IsDerivedFrom( argDeclBase_22d1.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_22d6= SFC::ArgDeclBase::Cast( argDeclBase_22d1);
		if( false== Uml::IsDerivedFrom( localVar_22da.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_22df= SFC::LocalVar::Cast( localVar_22da);
		if( false== Uml::IsDerivedFrom( context_22e3.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_22e8= SFC::Arg::Cast( context_22e3);
		if( false== Uml::IsDerivedFrom( unaryExprs_22ec.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_22f1= SFC::UnaryExprs::Cast( unaryExprs_22ec);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_22f6;
		if( !isValidBound(boundObjs_22f6, triggerPort_22cd, true))
			continue;
		currMatch.triggerPort_22f7= triggerPort_22cd;
		if( !isValidBound(boundObjs_22f6, argDeclBase_22d6, true))
			continue;
		currMatch.argDeclBase_22f8= argDeclBase_22d6;
		if( !isValidBound(boundObjs_22f6, localVar_22df, true))
			continue;
		currMatch.localVar_22f9= localVar_22df;
		if( !isValidBound(boundObjs_22f6, context_22e8, true))
			continue;
		currMatch.context_22fa= context_22e8;
		if( !isValidBound(boundObjs_22f6, unaryExprs_22f1, true))
			continue;
		currMatch.unaryExprs_22fb= unaryExprs_22f1;
		bool Gz_guard= isGuardTrue( currMatch.argDeclBase_22f8, currMatch.context_22fa, currMatch.localVar_22f9, currMatch.triggerPort_22f7, currMatch.unaryExprs_22fb);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void FallingEdge_22b3::outputAppender( const SFC::ArgDeclBase& argDeclBase_2301, const SFC::LocalVar& localVar_2303, const SFC::Arg& context_2305, const SFC::UnaryExprs& unaryExprs_2307)
{
	_argDeclBase_22c2->push_back( argDeclBase_2301);
	_localVar_22c3->push_back( localVar_2303);
	_context_22c4->push_back( context_2305);
	_unaryExprs_22c5->push_back( unaryExprs_2307);
}

bool EitherEdge_2309::operator()( const Packets_t& triggerPorts_230a, const Packets_t& argDeclBases_230c, const Packets_t& localVars_230f, const Packets_t& contexts_2312, const Packets_t& unaryExprss_2315, Packets_t& argDeclBases_230e, Packets_t& localVars_2311, Packets_t& contexts_2314, Packets_t& unaryExprss_2317)
{
#ifdef PRINT_INFO
	printLog( "EitherEdge_2309" );
#endif
	_argDeclBase_2318= &argDeclBases_230e;
	_localVar_2319= &localVars_2311;
	_context_231a= &contexts_2314;
	_unaryExprs_231b= &unaryExprss_2317;
	processInputPackets( triggerPorts_230a, argDeclBases_230c, localVars_230f, contexts_2312, unaryExprss_2315);
	if( false== _matches.empty())
		return true;
	return false;
}

bool EitherEdge_2309::isInputUnique( const Udm::Object& triggerPort_2320, const Udm::Object& argDeclBase_2329, const Udm::Object& localVar_2332, const Udm::Object& context_233b, const Udm::Object& unaryExprs_2344)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itTriggerPort_2322= _triggerPort_231c.begin(), itArgDeclBase_232b= _argDeclBase_2325.begin(), itLocalVar_2334= _localVar_232e.begin(), itContext_233d= _context_2337.begin(), itUnaryExprs_2346= _unaryExprs_2340.begin(); itTriggerPort_2322!= _triggerPort_231c.end(), itArgDeclBase_232b!= _argDeclBase_2325.end(), itLocalVar_2334!= _localVar_232e.end(), itContext_233d!= _context_2337.end(), itUnaryExprs_2346!= _unaryExprs_2340.end(); ++itTriggerPort_2322, ++itArgDeclBase_232b, ++itLocalVar_2334, ++itContext_233d, ++itUnaryExprs_2346)
	{
		if( ( *itTriggerPort_2322== triggerPort_2320)&& ( *itArgDeclBase_232b== argDeclBase_2329)&& ( *itLocalVar_2334== localVar_2332)&& ( *itContext_233d== context_233b)&& ( *itUnaryExprs_2346== unaryExprs_2344))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_triggerPort_231c.push_back( triggerPort_2320);
		_argDeclBase_2325.push_back( argDeclBase_2329);
		_localVar_232e.push_back( localVar_2332);
		_context_2337.push_back( context_233b);
		_unaryExprs_2340.push_back( unaryExprs_2344);
	}
	return isUnique;
}

bool EitherEdge_2309::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool EitherEdge_2309::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, SFC::Arg& Context, SFC::LocalVar& LocalVar, CyberComposition::Simulink::TriggerPort& TriggerPort, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	std::string trigger = TriggerPort.TriggerType();
Gz_guard = trigger == "either";;
	return Gz_guard;
}

void EitherEdge_2309::processInputPackets( const Packets_t& triggerPorts_230a, const Packets_t& argDeclBases_230c, const Packets_t& localVars_230f, const Packets_t& contexts_2312, const Packets_t& unaryExprss_2315)
{
	for( Packets_t::const_iterator itTriggerPort_231d= triggerPorts_230a.begin(), itArgDeclBase_2326= argDeclBases_230c.begin(), itLocalVar_232f= localVars_230f.begin(), itContext_2338= contexts_2312.begin(), itUnaryExprs_2341= unaryExprss_2315.begin(); itTriggerPort_231d!= triggerPorts_230a.end(), itArgDeclBase_2326!= argDeclBases_230c.end(), itLocalVar_232f!= localVars_230f.end(), itContext_2338!= contexts_2312.end(), itUnaryExprs_2341!= unaryExprss_2315.end(); ++itTriggerPort_231d, ++itArgDeclBase_2326, ++itLocalVar_232f, ++itContext_2338, ++itUnaryExprs_2341)
	{
		bool isUnique= isInputUnique( *itTriggerPort_231d, *itArgDeclBase_2326, *itLocalVar_232f, *itContext_2338, *itUnaryExprs_2341);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itTriggerPort_231d, *itArgDeclBase_2326, *itLocalVar_232f, *itContext_2338, *itUnaryExprs_2341);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_234e, currMatch.localVar_234f, currMatch.context_2350, currMatch.unaryExprs_2351);
	}
}

bool EitherEdge_2309::patternMatcher( const Udm::Object& triggerPort_231e, const Udm::Object& argDeclBase_2327, const Udm::Object& localVar_2330, const Udm::Object& context_2339, const Udm::Object& unaryExprs_2342)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( triggerPort_231e.type(), CyberComposition::Simulink::TriggerPort::meta))
			continue;
		CyberComposition::Simulink::TriggerPort triggerPort_2323= CyberComposition::Simulink::TriggerPort::Cast( triggerPort_231e);
		if( false== Uml::IsDerivedFrom( argDeclBase_2327.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_232c= SFC::ArgDeclBase::Cast( argDeclBase_2327);
		if( false== Uml::IsDerivedFrom( localVar_2330.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_2335= SFC::LocalVar::Cast( localVar_2330);
		if( false== Uml::IsDerivedFrom( context_2339.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_233e= SFC::Arg::Cast( context_2339);
		if( false== Uml::IsDerivedFrom( unaryExprs_2342.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_2347= SFC::UnaryExprs::Cast( unaryExprs_2342);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_234c;
		if( !isValidBound(boundObjs_234c, triggerPort_2323, true))
			continue;
		currMatch.triggerPort_234d= triggerPort_2323;
		if( !isValidBound(boundObjs_234c, argDeclBase_232c, true))
			continue;
		currMatch.argDeclBase_234e= argDeclBase_232c;
		if( !isValidBound(boundObjs_234c, localVar_2335, true))
			continue;
		currMatch.localVar_234f= localVar_2335;
		if( !isValidBound(boundObjs_234c, context_233e, true))
			continue;
		currMatch.context_2350= context_233e;
		if( !isValidBound(boundObjs_234c, unaryExprs_2347, true))
			continue;
		currMatch.unaryExprs_2351= unaryExprs_2347;
		bool Gz_guard= isGuardTrue( currMatch.argDeclBase_234e, currMatch.context_2350, currMatch.localVar_234f, currMatch.triggerPort_234d, currMatch.unaryExprs_2351);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void EitherEdge_2309::outputAppender( const SFC::ArgDeclBase& argDeclBase_2357, const SFC::LocalVar& localVar_2359, const SFC::Arg& context_235b, const SFC::UnaryExprs& unaryExprs_235d)
{
	_argDeclBase_2318->push_back( argDeclBase_2357);
	_localVar_2319->push_back( localVar_2359);
	_context_231a->push_back( context_235b);
	_unaryExprs_231b->push_back( unaryExprs_235d);
}

void StartAssignment_235f::operator()( const Packets_t& triggerPorts_2360, const Packets_t& argDeclBases_2363, const Packets_t& oldvals_2366, const Packets_t& contexts_2369, const Packets_t& triggerVars_236c, const Packets_t& functions_236e, Packets_t& triggerPorts_2362, Packets_t& argDeclBases_2365, Packets_t& oldvals_2368, Packets_t& contexts_236b, Packets_t& unaryExprss_2370)
{
#ifdef PRINT_INFO
	printLog( "StartAssignment_235f" );
#endif
	RTTGenerator::Instance()->generateRule(2270, "StartAssignment");
	_triggerPort_2371= &triggerPorts_2362;
	_argDeclBase_2372= &argDeclBases_2365;
	_oldval_2373= &oldvals_2368;
	_context_2374= &contexts_236b;
	_unaryExprs_2375= &unaryExprss_2370;
	processInputPackets( triggerPorts_2360, argDeclBases_2363, oldvals_2366, contexts_2369, triggerVars_236c, functions_236e);
}

bool StartAssignment_235f::isInputUnique( const Udm::Object& triggerPort_237a, const Udm::Object& argDeclBase_2383, const Udm::Object& oldval_238c, const Udm::Object& context_2395, const Udm::Object& triggerVar_239e, const Udm::Object& function_23a7)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itTriggerPort_237c= _triggerPort_2376.begin(), itArgDeclBase_2385= _argDeclBase_237f.begin(), itoldval_238e= _oldval_2388.begin(), itContext_2397= _context_2391.begin(), itTriggerVar_23a0= _triggerVar_239a.begin(), itFunction_23a9= _function_23a3.begin(); itTriggerPort_237c!= _triggerPort_2376.end(), itArgDeclBase_2385!= _argDeclBase_237f.end(), itoldval_238e!= _oldval_2388.end(), itContext_2397!= _context_2391.end(), itTriggerVar_23a0!= _triggerVar_239a.end(), itFunction_23a9!= _function_23a3.end(); ++itTriggerPort_237c, ++itArgDeclBase_2385, ++itoldval_238e, ++itContext_2397, ++itTriggerVar_23a0, ++itFunction_23a9)
	{
		if( ( *itTriggerPort_237c== triggerPort_237a)&& ( *itArgDeclBase_2385== argDeclBase_2383)&& ( *itoldval_238e== oldval_238c)&& ( *itContext_2397== context_2395)&& ( *itTriggerVar_23a0== triggerVar_239e)&& ( *itFunction_23a9== function_23a7))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_triggerPort_2376.push_back( triggerPort_237a);
		_argDeclBase_237f.push_back( argDeclBase_2383);
		_oldval_2388.push_back( oldval_238c);
		_context_2391.push_back( context_2395);
		_triggerVar_239a.push_back( triggerVar_239e);
		_function_23a3.push_back( function_23a7);
	}
	return isUnique;
}

bool StartAssignment_235f::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void StartAssignment_235f::processInputPackets( const Packets_t& triggerPorts_2360, const Packets_t& argDeclBases_2363, const Packets_t& oldvals_2366, const Packets_t& contexts_2369, const Packets_t& triggerVars_236c, const Packets_t& functions_236e)
{
	for( Packets_t::const_iterator itTriggerPort_2377= triggerPorts_2360.begin(), itArgDeclBase_2380= argDeclBases_2363.begin(), itoldval_2389= oldvals_2366.begin(), itContext_2392= contexts_2369.begin(), itTriggerVar_239b= triggerVars_236c.begin(), itFunction_23a4= functions_236e.begin(); itTriggerPort_2377!= triggerPorts_2360.end(), itArgDeclBase_2380!= argDeclBases_2363.end(), itoldval_2389!= oldvals_2366.end(), itContext_2392!= contexts_2369.end(), itTriggerVar_239b!= triggerVars_236c.end(), itFunction_23a4!= functions_236e.end(); ++itTriggerPort_2377, ++itArgDeclBase_2380, ++itoldval_2389, ++itContext_2392, ++itTriggerVar_239b, ++itFunction_23a4)
	{
		bool isUnique= isInputUnique( *itTriggerPort_2377, *itArgDeclBase_2380, *itoldval_2389, *itContext_2392, *itTriggerVar_239b, *itFunction_23a4);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itTriggerPort_2377, *itArgDeclBase_2380, *itoldval_2389, *itContext_2392, *itTriggerVar_239b, *itFunction_23a4);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool StartAssignment_235f::patternMatcher( const Udm::Object& triggerPort_2378, const Udm::Object& argDeclBase_2381, const Udm::Object& oldval_238a, const Udm::Object& context_2393, const Udm::Object& triggerVar_239c, const Udm::Object& function_23a5)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( triggerPort_2378.type(), CyberComposition::Simulink::TriggerPort::meta))
			continue;
		CyberComposition::Simulink::TriggerPort triggerPort_237d= CyberComposition::Simulink::TriggerPort::Cast( triggerPort_2378);
		if( false== Uml::IsDerivedFrom( argDeclBase_2381.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_2386= SFC::ArgDeclBase::Cast( argDeclBase_2381);
		if( false== Uml::IsDerivedFrom( oldval_238a.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar oldval_238f= SFC::LocalVar::Cast( oldval_238a);
		if( false== Uml::IsDerivedFrom( context_2393.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_2398= SFC::Arg::Cast( context_2393);
		if( false== Uml::IsDerivedFrom( triggerVar_239c.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_23a1= SFC::LocalVar::Cast( triggerVar_239c);
		if( false== Uml::IsDerivedFrom( function_23a5.type(), SFC::Function::meta))
			continue;
		SFC::Function function_23aa= SFC::Function::Cast( function_23a5);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_23af;
		if( !isValidBound(boundObjs_23af, triggerPort_237d, true))
			continue;
		currMatch.triggerPort_23b0= triggerPort_237d;
		if( !isValidBound(boundObjs_23af, argDeclBase_2386, true))
			continue;
		currMatch.argDeclBase_23b1= argDeclBase_2386;
		if( !isValidBound(boundObjs_23af, oldval_238f, true))
			continue;
		currMatch.oldval_23b2= oldval_238f;
		if( !isValidBound(boundObjs_23af, context_2398, true))
			continue;
		currMatch.context_23b3= context_2398;
		if( !isValidBound(boundObjs_23af, triggerVar_23a1, true))
			continue;
		currMatch.triggerVar_23b4= triggerVar_23a1;
		if( !isValidBound(boundObjs_23af, function_23aa, true))
			continue;
		currMatch.function_23b5= function_23aa;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void StartAssignment_235f::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newAssignment_23b6= SFC::UserCode::Create( currMatch.function_23b5, SFC::Function::meta_stmnt);
		SFC::BinaryExprs newAssign_23b7= SFC::BinaryExprs::Create( newAssignment_23b6, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newArgDeclRef_23b8= SFC::ArgDeclRef::Create( newAssign_23b7, SFC::BinaryExprs::meta_leftexpr);
		SFC::UnaryExprs newUnaryExprs_23b9= SFC::UnaryExprs::Create( newAssign_23b7, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_23b1;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_23b8;
		SFC::BinaryExprs& Assign= newAssign_23b7;
		SFC::UserCode& Assignment= newAssignment_23b6;
		SFC::Arg& Context= currMatch.context_23b3;
		SFC::Function& Function= currMatch.function_23b5;
		CyberComposition::Simulink::TriggerPort& TriggerPort= currMatch.triggerPort_23b0;
		SFC::LocalVar& TriggerVar= currMatch.triggerVar_23b4;
		SFC::UnaryExprs& UnaryExprs= newUnaryExprs_23b9;
		SFC::LocalVar& oldval= currMatch.oldval_23b2;
		{
Assign.op() = "=";
};
		{
__int64 statementCount = Function.statementCount();
Assignment.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		{
UnaryExprs.op() = "";
};
		newArgDeclRef_23b8.argdecl()= currMatch.triggerVar_23b4;
		outputAppender( currMatch.triggerPort_23b0, currMatch.argDeclBase_23b1, currMatch.oldval_23b2, currMatch.context_23b3, newUnaryExprs_23b9);
	}
}

void StartAssignment_235f::outputAppender( const CyberComposition::Simulink::TriggerPort& triggerPort_23ba, const SFC::ArgDeclBase& argDeclBase_23bc, const SFC::LocalVar& oldval_23be, const SFC::Arg& context_23c0, const SFC::UnaryExprs& unaryExprs_23c2)
{
	_triggerPort_2371->push_back( triggerPort_23ba);
	_argDeclBase_2372->push_back( argDeclBase_23bc);
	_oldval_2373->push_back( oldval_23be);
	_context_2374->push_back( context_23c0);
	_unaryExprs_2375->push_back( unaryExprs_23c2);
}

void AddTriggerVar_23c4::operator()( const Packets_t& triggerPorts_23c5, const Packets_t& argDeclBases_23c8, const Packets_t& dTs_23cb, const Packets_t& localVars_23cd, const Packets_t& contexts_23d0, const Packets_t& functions_23d4, Packets_t& triggerPorts_23c7, Packets_t& argDeclBases_23ca, Packets_t& localVars_23cf, Packets_t& contexts_23d2, Packets_t& triggerVars_23d3, Packets_t& functions_23d6)
{
#ifdef PRINT_INFO
	printLog( "AddTriggerVar_23c4" );
#endif
	RTTGenerator::Instance()->generateRule(2289, "AddTriggerVar");
	_triggerPort_23d7= &triggerPorts_23c7;
	_argDeclBase_23d8= &argDeclBases_23ca;
	_localVar_23d9= &localVars_23cf;
	_context_23da= &contexts_23d2;
	_triggerVar_23db= &triggerVars_23d3;
	_function_23dc= &functions_23d6;
	processInputPackets( triggerPorts_23c5, argDeclBases_23c8, dTs_23cb, localVars_23cd, contexts_23d0, functions_23d4);
}

bool AddTriggerVar_23c4::isInputUnique( const Udm::Object& triggerPort_23e1, const Udm::Object& argDeclBase_23ea, const Udm::Object& dT_23f3, const Udm::Object& localVar_23fc, const Udm::Object& context_2405, const Udm::Object& function_240e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itTriggerPort_23e3= _triggerPort_23dd.begin(), itArgDeclBase_23ec= _argDeclBase_23e6.begin(), itDT_23f5= _dT_23ef.begin(), itLocalVar_23fe= _localVar_23f8.begin(), itContext_2407= _context_2401.begin(), itFunction_2410= _function_240a.begin(); itTriggerPort_23e3!= _triggerPort_23dd.end(), itArgDeclBase_23ec!= _argDeclBase_23e6.end(), itDT_23f5!= _dT_23ef.end(), itLocalVar_23fe!= _localVar_23f8.end(), itContext_2407!= _context_2401.end(), itFunction_2410!= _function_240a.end(); ++itTriggerPort_23e3, ++itArgDeclBase_23ec, ++itDT_23f5, ++itLocalVar_23fe, ++itContext_2407, ++itFunction_2410)
	{
		if( ( *itTriggerPort_23e3== triggerPort_23e1)&& ( *itArgDeclBase_23ec== argDeclBase_23ea)&& ( *itDT_23f5== dT_23f3)&& ( *itLocalVar_23fe== localVar_23fc)&& ( *itContext_2407== context_2405)&& ( *itFunction_2410== function_240e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_triggerPort_23dd.push_back( triggerPort_23e1);
		_argDeclBase_23e6.push_back( argDeclBase_23ea);
		_dT_23ef.push_back( dT_23f3);
		_localVar_23f8.push_back( localVar_23fc);
		_context_2401.push_back( context_2405);
		_function_240a.push_back( function_240e);
	}
	return isUnique;
}

bool AddTriggerVar_23c4::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool AddTriggerVar_23c4::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, SFC::Arg& Context, SFC::DT& DT, SFC::Function& Function, SFC::LocalVar& LocalVar, CyberComposition::Simulink::TriggerPort& TriggerPort)
{
	bool Gz_guard= false;
	Gz_guard = DT.type() != SFC::Struct::meta;;
	return Gz_guard;
}

void AddTriggerVar_23c4::processInputPackets( const Packets_t& triggerPorts_23c5, const Packets_t& argDeclBases_23c8, const Packets_t& dTs_23cb, const Packets_t& localVars_23cd, const Packets_t& contexts_23d0, const Packets_t& functions_23d4)
{
	for( Packets_t::const_iterator itTriggerPort_23de= triggerPorts_23c5.begin(), itArgDeclBase_23e7= argDeclBases_23c8.begin(), itDT_23f0= dTs_23cb.begin(), itLocalVar_23f9= localVars_23cd.begin(), itContext_2402= contexts_23d0.begin(), itFunction_240b= functions_23d4.begin(); itTriggerPort_23de!= triggerPorts_23c5.end(), itArgDeclBase_23e7!= argDeclBases_23c8.end(), itDT_23f0!= dTs_23cb.end(), itLocalVar_23f9!= localVars_23cd.end(), itContext_2402!= contexts_23d0.end(), itFunction_240b!= functions_23d4.end(); ++itTriggerPort_23de, ++itArgDeclBase_23e7, ++itDT_23f0, ++itLocalVar_23f9, ++itContext_2402, ++itFunction_240b)
	{
		bool isUnique= isInputUnique( *itTriggerPort_23de, *itArgDeclBase_23e7, *itDT_23f0, *itLocalVar_23f9, *itContext_2402, *itFunction_240b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itTriggerPort_23de, *itArgDeclBase_23e7, *itDT_23f0, *itLocalVar_23f9, *itContext_2402, *itFunction_240b);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AddTriggerVar_23c4::patternMatcher( const Udm::Object& triggerPort_23df, const Udm::Object& argDeclBase_23e8, const Udm::Object& dT_23f1, const Udm::Object& localVar_23fa, const Udm::Object& context_2403, const Udm::Object& function_240c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( triggerPort_23df.type(), CyberComposition::Simulink::TriggerPort::meta))
			continue;
		CyberComposition::Simulink::TriggerPort triggerPort_23e4= CyberComposition::Simulink::TriggerPort::Cast( triggerPort_23df);
		if( false== Uml::IsDerivedFrom( argDeclBase_23e8.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_23ed= SFC::ArgDeclBase::Cast( argDeclBase_23e8);
		if( false== Uml::IsDerivedFrom( dT_23f1.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_23f6= SFC::DT::Cast( dT_23f1);
		if( false== Uml::IsDerivedFrom( localVar_23fa.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_23ff= SFC::LocalVar::Cast( localVar_23fa);
		if( false== Uml::IsDerivedFrom( context_2403.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_2408= SFC::Arg::Cast( context_2403);
		if( false== Uml::IsDerivedFrom( function_240c.type(), SFC::Function::meta))
			continue;
		SFC::Function function_2411= SFC::Function::Cast( function_240c);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2416;
		if( !isValidBound(boundObjs_2416, triggerPort_23e4, true))
			continue;
		currMatch.triggerPort_2417= triggerPort_23e4;
		if( !isValidBound(boundObjs_2416, argDeclBase_23ed, true))
			continue;
		currMatch.argDeclBase_2418= argDeclBase_23ed;
		if( !isValidBound(boundObjs_2416, dT_23f6, true))
			continue;
		currMatch.dT_2419= dT_23f6;
		if( !isValidBound(boundObjs_2416, localVar_23ff, true))
			continue;
		currMatch.localVar_241a= localVar_23ff;
		if( !isValidBound(boundObjs_2416, context_2408, true))
			continue;
		currMatch.context_241b= context_2408;
		if( !isValidBound(boundObjs_2416, function_2411, true))
			continue;
		currMatch.function_241c= function_2411;
		bool Gz_guard= isGuardTrue( currMatch.argDeclBase_2418, currMatch.context_241b, currMatch.dT_2419, currMatch.function_241c, currMatch.localVar_241a, currMatch.triggerPort_2417);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void AddTriggerVar_23c4::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newTriggerVar_2423= SFC::LocalVar::Create( currMatch.function_241c, SFC::Function::meta_stmnt);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_2418;
		SFC::Arg& Context= currMatch.context_241b;
		SFC::DT& DT= currMatch.dT_2419;
		SFC::Function& Function= currMatch.function_241c;
		SFC::LocalVar& LocalVar= currMatch.localVar_241a;
		CyberComposition::Simulink::TriggerPort& TriggerPort= currMatch.triggerPort_2417;
		SFC::LocalVar& TriggerVar= newTriggerVar_2423;
		{
TriggerVar.type() = "int";
TriggerVar.name() = std::string( "event" ) + boost::lexical_cast< std::string >( TriggerVar.uniqueId() );
};
		{
__int64 statementCount = Function.statementCount();
TriggerVar.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		currMatch.localVar_241a.trigvar()= newTriggerVar_2423;
		newTriggerVar_2423.dt()= currMatch.dT_2419;
		outputAppender( currMatch.triggerPort_2417, currMatch.argDeclBase_2418, currMatch.localVar_241a, currMatch.context_241b, newTriggerVar_2423, currMatch.function_241c);
	}
}

void AddTriggerVar_23c4::outputAppender( const CyberComposition::Simulink::TriggerPort& triggerPort_2424, const SFC::ArgDeclBase& argDeclBase_2426, const SFC::LocalVar& localVar_2428, const SFC::Arg& context_242a, const SFC::LocalVar& triggerVar_242c, const SFC::Function& function_242e)
{
	_triggerPort_23d7->push_back( triggerPort_2424);
	_argDeclBase_23d8->push_back( argDeclBase_2426);
	_localVar_23d9->push_back( localVar_2428);
	_context_23da->push_back( context_242a);
	_triggerVar_23db->push_back( triggerVar_242c);
	_function_23dc->push_back( function_242e);
}

void AddStructTriggerVars_245d::operator()( const Packets_t& triggers_245e, const Packets_t& argdecls_2460, const Packets_t& dts_2462, const Packets_t& oldvals_2464, const Packets_t& contexts_2466, const Packets_t& functions_2468)
{
#ifdef PRINT_INFO
	printLog( "AddStructTriggerVars_245d" );
#endif
	if( ( !triggers_245e.empty())&& ( !argdecls_2460.empty())&& ( !dts_2462.empty())&& ( !oldvals_2464.empty())&& ( !contexts_2466.empty())&& ( !functions_2468.empty()))
		callAddTriggerVar_27d1( triggers_245e, argdecls_2460, dts_2462, oldvals_2464, contexts_2466, functions_2468);
}

void AddStructTriggerVars_245d::callAddTriggerVar_27d1( const Packets_t& triggerPorts_26ed, const Packets_t& argDeclBases_26f0, const Packets_t& structs_26f3, const Packets_t& localVars_26f6, const Packets_t& contexts_26f9, const Packets_t& functions_26fd)
{
	Packets_t triggerPorts_26ef;
	Packets_t argDeclBases_26f2;
	Packets_t structs_26f5;
	Packets_t localVars_26f8;
	Packets_t contexts_26fb;
	Packets_t triggerVars_26fc;
	Packets_t functions_26ff;
	AddTriggerVar_26ec addTriggerVar_26ec;
	addTriggerVar_26ec( triggerPorts_26ed, argDeclBases_26f0, structs_26f3, localVars_26f6, contexts_26f9, functions_26fd, triggerPorts_26ef, argDeclBases_26f2, structs_26f5, localVars_26f8, contexts_26fb, triggerVars_26fc, functions_26ff);
	if( ( !triggerPorts_26ef.empty())&& ( !argDeclBases_26f2.empty())&& ( !structs_26f5.empty())&& ( !localVars_26f8.empty())&& ( !contexts_26fb.empty())&& ( !triggerVars_26fc.empty())&& ( !functions_26ff.empty()))
		callStartAssignment_27d8( triggerPorts_26ef, argDeclBases_26f2, structs_26f5, localVars_26f8, contexts_26fb, triggerVars_26fc, functions_26ff);
}

void AddStructTriggerVars_245d::callStartAssignment_27d8( const Packets_t& triggerPorts_2757, const Packets_t& argDeclBases_275a, const Packets_t& structs_275e, const Packets_t& oldvals_2760, const Packets_t& contexts_2763, const Packets_t& triggerVars_2766, const Packets_t& functions_2768)
{
	Packets_t triggerPorts_2759;
	Packets_t argDeclBases_275c;
	Packets_t localVars_275d;
	Packets_t oldvals_2762;
	Packets_t contexts_2765;
	Packets_t unaryExprss_276a;
	StartAssignment_2756 startAssignment_2756;
	startAssignment_2756( triggerPorts_2757, argDeclBases_275a, structs_275e, oldvals_2760, contexts_2763, triggerVars_2766, functions_2768, triggerPorts_2759, argDeclBases_275c, localVars_275d, oldvals_2762, contexts_2765, unaryExprss_276a);
	if( ( !triggerPorts_2759.empty())&& ( !argDeclBases_275c.empty())&& ( !localVars_275d.empty())&& ( !oldvals_2762.empty())&& ( !contexts_2765.empty())&& ( !unaryExprss_276a.empty()))
		callEdgeTest_27e0( triggerPorts_2759, argDeclBases_275c, localVars_275d, oldvals_2762, contexts_2765, unaryExprss_276a);
}

void AddStructTriggerVars_245d::callEdgeTest_27e0( const Packets_t& triggers_2563, const Packets_t& argdecls_2565, const Packets_t& members_2567, const Packets_t& oldvals_2569, const Packets_t& contexts_256b, const Packets_t& initexprs_256d)
{
	Packets_t argdecls_256f;
	Packets_t members_2570;
	Packets_t oldvals_2571;
	Packets_t contexts_2572;
	Packets_t initexprs_2573;
	Packets_t argdecls_2574;
	Packets_t members_2575;
	Packets_t oldvals_2576;
	Packets_t contexts_2577;
	Packets_t initexprs_2578;
	Packets_t argdecls_2579;
	Packets_t members_257a;
	Packets_t oldvals_257b;
	Packets_t contexts_257c;
	Packets_t initexprs_257d;
	EdgeTest_2562 edgeTest_2562;
	edgeTest_2562( triggers_2563, argdecls_2565, members_2567, oldvals_2569, contexts_256b, initexprs_256d, argdecls_256f, members_2570, oldvals_2571, contexts_2572, initexprs_2573, argdecls_2574, members_2575, oldvals_2576, contexts_2577, initexprs_2578, argdecls_2579, members_257a, oldvals_257b, contexts_257c, initexprs_257d);
	if( ( !argdecls_2579.empty())&& ( !members_257a.empty())&& ( !oldvals_257b.empty())&& ( !contexts_257c.empty())&& ( !initexprs_257d.empty()))
		callEitherEdge_27e7( argdecls_2579, members_257a, oldvals_257b, contexts_257c, initexprs_257d);
	if( ( !argdecls_2574.empty())&& ( !members_2575.empty())&& ( !oldvals_2576.empty())&& ( !contexts_2577.empty())&& ( !initexprs_2578.empty()))
		callFallingEdge_27ed( argdecls_2574, members_2575, oldvals_2576, contexts_2577, initexprs_2578);
	if( ( !argdecls_256f.empty())&& ( !members_2570.empty())&& ( !oldvals_2571.empty())&& ( !contexts_2572.empty())&& ( !initexprs_2573.empty()))
		callRisingEdge_27f3( argdecls_256f, members_2570, oldvals_2571, contexts_2572, initexprs_2573);
}

void AddStructTriggerVars_245d::callEitherEdge_27e7( const Packets_t& argDeclBases_246b, const Packets_t& members_246e, const Packets_t& localVars_2471, const Packets_t& contexts_2474, const Packets_t& unaryExprss_2477)
{
	Packets_t argDeclBases_246d;
	Packets_t members_2470;
	Packets_t localVars_2473;
	Packets_t contexts_2476;
	Packets_t leftUnaryExprss_2479;
	Packets_t rightUnaryExprss_247a;
	EitherEdge_246a eitherEdge_246a;
	eitherEdge_246a( argDeclBases_246b, members_246e, localVars_2471, contexts_2474, unaryExprss_2477, argDeclBases_246d, members_2470, localVars_2473, contexts_2476, leftUnaryExprss_2479, rightUnaryExprss_247a);
	if( ( !argDeclBases_246d.empty())&& ( !members_2470.empty())&& ( !localVars_2473.empty())&& ( !contexts_2476.empty())&& ( !rightUnaryExprss_247a.empty()))
		callFallingEdge_27f9( argDeclBases_246d, members_2470, localVars_2473, contexts_2476, rightUnaryExprss_247a);
	if( ( !argDeclBases_246d.empty())&& ( !members_2470.empty())&& ( !localVars_2473.empty())&& ( !contexts_2476.empty())&& ( !leftUnaryExprss_2479.empty()))
		callRisingEdge_27ff( argDeclBases_246d, members_2470, localVars_2473, contexts_2476, leftUnaryExprss_2479);
}

void AddStructTriggerVars_245d::callFallingEdge_27ed( const Packets_t& argDeclBases_24c7, const Packets_t& members_24c9, const Packets_t& localVars_24cb, const Packets_t& contexts_24cd, const Packets_t& unaryExprss_24cf)
{
	FallingEdge_24c6 fallingEdge_24c6;
	fallingEdge_24c6( argDeclBases_24c7, members_24c9, localVars_24cb, contexts_24cd, unaryExprss_24cf);
}

void AddStructTriggerVars_245d::callRisingEdge_27f3( const Packets_t& argDeclBases_2515, const Packets_t& members_2517, const Packets_t& localVars_2519, const Packets_t& contexts_251b, const Packets_t& unaryExprss_251d)
{
	RisingEdge_2514 risingEdge_2514;
	risingEdge_2514( argDeclBases_2515, members_2517, localVars_2519, contexts_251b, unaryExprss_251d);
}

void AddStructTriggerVars_245d::callFallingEdge_27f9( const Packets_t& argDeclBases_24c7, const Packets_t& members_24c9, const Packets_t& localVars_24cb, const Packets_t& contexts_24cd, const Packets_t& unaryExprss_24cf)
{
	FallingEdge_24c6 fallingEdge_24c6;
	fallingEdge_24c6( argDeclBases_24c7, members_24c9, localVars_24cb, contexts_24cd, unaryExprss_24cf);
}

void AddStructTriggerVars_245d::callRisingEdge_27ff( const Packets_t& argDeclBases_2515, const Packets_t& members_2517, const Packets_t& localVars_2519, const Packets_t& contexts_251b, const Packets_t& unaryExprss_251d)
{
	RisingEdge_2514 risingEdge_2514;
	risingEdge_2514( argDeclBases_2515, members_2517, localVars_2519, contexts_251b, unaryExprss_251d);
}

void EitherEdge_246a::operator()( const Packets_t& argDeclBases_246b, const Packets_t& members_246e, const Packets_t& localVars_2471, const Packets_t& contexts_2474, const Packets_t& unaryExprss_2477, Packets_t& argDeclBases_246d, Packets_t& members_2470, Packets_t& localVars_2473, Packets_t& contexts_2476, Packets_t& leftUnaryExprss_2479, Packets_t& rightUnaryExprss_247a)
{
#ifdef PRINT_INFO
	printLog( "EitherEdge_246a" );
#endif
	RTTGenerator::Instance()->generateRule(2309, "EitherEdge");
	_argDeclBase_247b= &argDeclBases_246d;
	_member_247c= &members_2470;
	_localVar_247d= &localVars_2473;
	_context_247e= &contexts_2476;
	_leftUnaryExprs_247f= &leftUnaryExprss_2479;
	_rightUnaryExprs_2480= &rightUnaryExprss_247a;
	processInputPackets( argDeclBases_246b, members_246e, localVars_2471, contexts_2474, unaryExprss_2477);
}

bool EitherEdge_246a::isInputUnique( const Udm::Object& argDeclBase_2485, const Udm::Object& member_248e, const Udm::Object& localVar_2497, const Udm::Object& context_24a0, const Udm::Object& unaryExprs_24a9)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_2487= _argDeclBase_2481.begin(), itMember_2490= _member_248a.begin(), itLocalVar_2499= _localVar_2493.begin(), itContext_24a2= _context_249c.begin(), itUnaryExprs_24ab= _unaryExprs_24a5.begin(); itArgDeclBase_2487!= _argDeclBase_2481.end(), itMember_2490!= _member_248a.end(), itLocalVar_2499!= _localVar_2493.end(), itContext_24a2!= _context_249c.end(), itUnaryExprs_24ab!= _unaryExprs_24a5.end(); ++itArgDeclBase_2487, ++itMember_2490, ++itLocalVar_2499, ++itContext_24a2, ++itUnaryExprs_24ab)
	{
		if( ( *itArgDeclBase_2487== argDeclBase_2485)&& ( *itMember_2490== member_248e)&& ( *itLocalVar_2499== localVar_2497)&& ( *itContext_24a2== context_24a0)&& ( *itUnaryExprs_24ab== unaryExprs_24a9))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_2481.push_back( argDeclBase_2485);
		_member_248a.push_back( member_248e);
		_localVar_2493.push_back( localVar_2497);
		_context_249c.push_back( context_24a0);
		_unaryExprs_24a5.push_back( unaryExprs_24a9);
	}
	return isUnique;
}

bool EitherEdge_246a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void EitherEdge_246a::processInputPackets( const Packets_t& argDeclBases_246b, const Packets_t& members_246e, const Packets_t& localVars_2471, const Packets_t& contexts_2474, const Packets_t& unaryExprss_2477)
{
	for( Packets_t::const_iterator itArgDeclBase_2482= argDeclBases_246b.begin(), itMember_248b= members_246e.begin(), itLocalVar_2494= localVars_2471.begin(), itContext_249d= contexts_2474.begin(), itUnaryExprs_24a6= unaryExprss_2477.begin(); itArgDeclBase_2482!= argDeclBases_246b.end(), itMember_248b!= members_246e.end(), itLocalVar_2494!= localVars_2471.end(), itContext_249d!= contexts_2474.end(), itUnaryExprs_24a6!= unaryExprss_2477.end(); ++itArgDeclBase_2482, ++itMember_248b, ++itLocalVar_2494, ++itContext_249d, ++itUnaryExprs_24a6)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_2482, *itMember_248b, *itLocalVar_2494, *itContext_249d, *itUnaryExprs_24a6);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_2482, *itMember_248b, *itLocalVar_2494, *itContext_249d, *itUnaryExprs_24a6);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool EitherEdge_246a::patternMatcher( const Udm::Object& argDeclBase_2483, const Udm::Object& member_248c, const Udm::Object& localVar_2495, const Udm::Object& context_249e, const Udm::Object& unaryExprs_24a7)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_2483.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_2488= SFC::ArgDeclBase::Cast( argDeclBase_2483);
		if( false== Uml::IsDerivedFrom( member_248c.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_2491= SFC::LocalVar::Cast( member_248c);
		if( false== Uml::IsDerivedFrom( localVar_2495.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_249a= SFC::LocalVar::Cast( localVar_2495);
		if( false== Uml::IsDerivedFrom( context_249e.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_24a3= SFC::Arg::Cast( context_249e);
		if( false== Uml::IsDerivedFrom( unaryExprs_24a7.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_24ac= SFC::UnaryExprs::Cast( unaryExprs_24a7);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_24b1;
		if( !isValidBound(boundObjs_24b1, argDeclBase_2488, true))
			continue;
		currMatch.argDeclBase_24b2= argDeclBase_2488;
		if( !isValidBound(boundObjs_24b1, member_2491, true))
			continue;
		currMatch.member_24b3= member_2491;
		if( !isValidBound(boundObjs_24b1, localVar_249a, true))
			continue;
		currMatch.localVar_24b4= localVar_249a;
		if( !isValidBound(boundObjs_24b1, context_24a3, true))
			continue;
		currMatch.context_24b5= context_24a3;
		if( !isValidBound(boundObjs_24b1, unaryExprs_24ac, true))
			continue;
		currMatch.unaryExprs_24b6= unaryExprs_24ac;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void EitherEdge_246a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newOr_24b7= SFC::BinaryExprs::Create( currMatch.unaryExprs_24b6, SFC::UnaryExprs::meta_subexpr);
		SFC::UnaryExprs newRightUnaryExprs_24b8= SFC::UnaryExprs::Create( newOr_24b7, SFC::BinaryExprs::meta_rightexpr);
		SFC::UnaryExprs newLeftUnaryExprs_24b9= SFC::UnaryExprs::Create( newOr_24b7, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_24b2;
		SFC::Arg& Context= currMatch.context_24b5;
		SFC::UnaryExprs& LeftUnaryExprs= newLeftUnaryExprs_24b9;
		SFC::LocalVar& LocalVar= currMatch.localVar_24b4;
		SFC::LocalVar& Member= currMatch.member_24b3;
		SFC::BinaryExprs& Or= newOr_24b7;
		SFC::UnaryExprs& RightUnaryExprs= newRightUnaryExprs_24b8;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_24b6;
		{
Or.op() = "||";
};
		{
RightUnaryExprs.op() = "";
};
		{
LeftUnaryExprs.op() = "";
};
		outputAppender( currMatch.argDeclBase_24b2, currMatch.member_24b3, currMatch.localVar_24b4, currMatch.context_24b5, newLeftUnaryExprs_24b9, newRightUnaryExprs_24b8);
	}
}

void EitherEdge_246a::outputAppender( const SFC::ArgDeclBase& argDeclBase_24ba, const SFC::LocalVar& member_24bc, const SFC::LocalVar& localVar_24be, const SFC::Arg& context_24c0, const SFC::UnaryExprs& leftUnaryExprs_24c2, const SFC::UnaryExprs& rightUnaryExprs_24c4)
{
	_argDeclBase_247b->push_back( argDeclBase_24ba);
	_member_247c->push_back( member_24bc);
	_localVar_247d->push_back( localVar_24be);
	_context_247e->push_back( context_24c0);
	_leftUnaryExprs_247f->push_back( leftUnaryExprs_24c2);
	_rightUnaryExprs_2480->push_back( rightUnaryExprs_24c4);
}

void FallingEdge_24c6::operator()( const Packets_t& argDeclBases_24c7, const Packets_t& members_24c9, const Packets_t& localVars_24cb, const Packets_t& contexts_24cd, const Packets_t& unaryExprss_24cf)
{
#ifdef PRINT_INFO
	printLog( "FallingEdge_24c6" );
#endif
	RTTGenerator::Instance()->generateRule(2324, "FallingEdge");
	processInputPackets( argDeclBases_24c7, members_24c9, localVars_24cb, contexts_24cd, unaryExprss_24cf);
}

bool FallingEdge_24c6::isInputUnique( const Udm::Object& argDeclBase_24d5, const Udm::Object& member_24de, const Udm::Object& localVar_24e7, const Udm::Object& context_24f0, const Udm::Object& unaryExprs_24f9)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_24d7= _argDeclBase_24d1.begin(), itMember_24e0= _member_24da.begin(), itLocalVar_24e9= _localVar_24e3.begin(), itContext_24f2= _context_24ec.begin(), itUnaryExprs_24fb= _unaryExprs_24f5.begin(); itArgDeclBase_24d7!= _argDeclBase_24d1.end(), itMember_24e0!= _member_24da.end(), itLocalVar_24e9!= _localVar_24e3.end(), itContext_24f2!= _context_24ec.end(), itUnaryExprs_24fb!= _unaryExprs_24f5.end(); ++itArgDeclBase_24d7, ++itMember_24e0, ++itLocalVar_24e9, ++itContext_24f2, ++itUnaryExprs_24fb)
	{
		if( ( *itArgDeclBase_24d7== argDeclBase_24d5)&& ( *itMember_24e0== member_24de)&& ( *itLocalVar_24e9== localVar_24e7)&& ( *itContext_24f2== context_24f0)&& ( *itUnaryExprs_24fb== unaryExprs_24f9))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_24d1.push_back( argDeclBase_24d5);
		_member_24da.push_back( member_24de);
		_localVar_24e3.push_back( localVar_24e7);
		_context_24ec.push_back( context_24f0);
		_unaryExprs_24f5.push_back( unaryExprs_24f9);
	}
	return isUnique;
}

bool FallingEdge_24c6::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void FallingEdge_24c6::processInputPackets( const Packets_t& argDeclBases_24c7, const Packets_t& members_24c9, const Packets_t& localVars_24cb, const Packets_t& contexts_24cd, const Packets_t& unaryExprss_24cf)
{
	for( Packets_t::const_iterator itArgDeclBase_24d2= argDeclBases_24c7.begin(), itMember_24db= members_24c9.begin(), itLocalVar_24e4= localVars_24cb.begin(), itContext_24ed= contexts_24cd.begin(), itUnaryExprs_24f6= unaryExprss_24cf.begin(); itArgDeclBase_24d2!= argDeclBases_24c7.end(), itMember_24db!= members_24c9.end(), itLocalVar_24e4!= localVars_24cb.end(), itContext_24ed!= contexts_24cd.end(), itUnaryExprs_24f6!= unaryExprss_24cf.end(); ++itArgDeclBase_24d2, ++itMember_24db, ++itLocalVar_24e4, ++itContext_24ed, ++itUnaryExprs_24f6)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_24d2, *itMember_24db, *itLocalVar_24e4, *itContext_24ed, *itUnaryExprs_24f6);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_24d2, *itMember_24db, *itLocalVar_24e4, *itContext_24ed, *itUnaryExprs_24f6);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool FallingEdge_24c6::patternMatcher( const Udm::Object& argDeclBase_24d3, const Udm::Object& member_24dc, const Udm::Object& localVar_24e5, const Udm::Object& context_24ee, const Udm::Object& unaryExprs_24f7)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_24d3.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_24d8= SFC::ArgDeclBase::Cast( argDeclBase_24d3);
		if( false== Uml::IsDerivedFrom( member_24dc.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_24e1= SFC::LocalVar::Cast( member_24dc);
		if( false== Uml::IsDerivedFrom( localVar_24e5.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_24ea= SFC::LocalVar::Cast( localVar_24e5);
		if( false== Uml::IsDerivedFrom( context_24ee.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_24f3= SFC::Arg::Cast( context_24ee);
		if( false== Uml::IsDerivedFrom( unaryExprs_24f7.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_24fc= SFC::UnaryExprs::Cast( unaryExprs_24f7);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2501;
		if( !isValidBound(boundObjs_2501, argDeclBase_24d8, true))
			continue;
		currMatch.argDeclBase_2502= argDeclBase_24d8;
		if( !isValidBound(boundObjs_2501, member_24e1, true))
			continue;
		currMatch.member_2503= member_24e1;
		if( !isValidBound(boundObjs_2501, localVar_24ea, true))
			continue;
		currMatch.localVar_2504= localVar_24ea;
		if( !isValidBound(boundObjs_2501, context_24f3, true))
			continue;
		currMatch.context_2505= context_24f3;
		if( !isValidBound(boundObjs_2501, unaryExprs_24fc, true))
			continue;
		currMatch.unaryExprs_2506= unaryExprs_24fc;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void FallingEdge_24c6::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newAnd_2507= SFC::BinaryExprs::Create( currMatch.unaryExprs_2506, SFC::UnaryExprs::meta_subexpr);
		SFC::BinaryExprs newGreaterThan_2508= SFC::BinaryExprs::Create( newAnd_2507, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newMemberDot_2509= SFC::BinaryExprs::Create( newGreaterThan_2508, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newMemberRef2_250a= SFC::ArgDeclRef::Create( newMemberDot_2509, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newDot_250b= SFC::BinaryExprs::Create( newMemberDot_2509, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newLessThan_250c= SFC::BinaryExprs::Create( newAnd_2507, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newArgDeclDot_250d= SFC::BinaryExprs::Create( newLessThan_250c, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef_250e= SFC::ArgDeclRef::Create( newArgDeclDot_250d, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newMemberRef_250f= SFC::ArgDeclRef::Create( newArgDeclDot_250d, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef2_2510= SFC::ArgDeclRef::Create( newDot_250b, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newZero2_2511= SFC::Int::Create( newLessThan_250c, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newZero_2512= SFC::Int::Create( newGreaterThan_2508, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef3_2513= SFC::ArgDeclRef::Create( newDot_250b, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs& And= newAnd_2507;
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_2502;
		SFC::BinaryExprs& ArgDeclDot= newArgDeclDot_250d;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_250e;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_2510;
		SFC::ArgDeclRef& ArgDeclRef3= newArgDeclRef3_2513;
		SFC::Arg& Context= currMatch.context_2505;
		SFC::BinaryExprs& Dot= newDot_250b;
		SFC::BinaryExprs& GreaterThan= newGreaterThan_2508;
		SFC::BinaryExprs& LessThan= newLessThan_250c;
		SFC::LocalVar& LocalVar= currMatch.localVar_2504;
		SFC::LocalVar& Member= currMatch.member_2503;
		SFC::BinaryExprs& MemberDot= newMemberDot_2509;
		SFC::ArgDeclRef& MemberRef= newMemberRef_250f;
		SFC::ArgDeclRef& MemberRef2= newMemberRef2_250a;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_2506;
		SFC::Int& Zero= newZero_2512;
		SFC::Int& Zero2= newZero2_2511;
		{
MemberDot.op() = ".";
};
		{
ArgDeclDot.op() = ".";
};
		{
Zero2.val() = 0;
};
		{
Zero.val() = 0;
};
		{
Dot.op() = ".";
};
		{
GreaterThan.op() = ">=";
};
		{
And.op() = "&&";
};
		{
LessThan.op() = "<";
};
		newMemberRef_250f.argdecl()= currMatch.member_2503;
		newMemberRef2_250a.argdecl()= currMatch.member_2503;
		newArgDeclRef3_2513.argdecl()= currMatch.context_2505;
		newArgDeclRef_250e.argdecl()= currMatch.argDeclBase_2502;
		newArgDeclRef2_2510.argdecl()= currMatch.localVar_2504;
	}
}

void RisingEdge_2514::operator()( const Packets_t& argDeclBases_2515, const Packets_t& members_2517, const Packets_t& localVars_2519, const Packets_t& contexts_251b, const Packets_t& unaryExprss_251d)
{
#ifdef PRINT_INFO
	printLog( "RisingEdge_2514" );
#endif
	RTTGenerator::Instance()->generateRule(2369, "RisingEdge");
	processInputPackets( argDeclBases_2515, members_2517, localVars_2519, contexts_251b, unaryExprss_251d);
}

bool RisingEdge_2514::isInputUnique( const Udm::Object& argDeclBase_2523, const Udm::Object& member_252c, const Udm::Object& localVar_2535, const Udm::Object& context_253e, const Udm::Object& unaryExprs_2547)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_2525= _argDeclBase_251f.begin(), itMember_252e= _member_2528.begin(), itLocalVar_2537= _localVar_2531.begin(), itContext_2540= _context_253a.begin(), itUnaryExprs_2549= _unaryExprs_2543.begin(); itArgDeclBase_2525!= _argDeclBase_251f.end(), itMember_252e!= _member_2528.end(), itLocalVar_2537!= _localVar_2531.end(), itContext_2540!= _context_253a.end(), itUnaryExprs_2549!= _unaryExprs_2543.end(); ++itArgDeclBase_2525, ++itMember_252e, ++itLocalVar_2537, ++itContext_2540, ++itUnaryExprs_2549)
	{
		if( ( *itArgDeclBase_2525== argDeclBase_2523)&& ( *itMember_252e== member_252c)&& ( *itLocalVar_2537== localVar_2535)&& ( *itContext_2540== context_253e)&& ( *itUnaryExprs_2549== unaryExprs_2547))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_251f.push_back( argDeclBase_2523);
		_member_2528.push_back( member_252c);
		_localVar_2531.push_back( localVar_2535);
		_context_253a.push_back( context_253e);
		_unaryExprs_2543.push_back( unaryExprs_2547);
	}
	return isUnique;
}

bool RisingEdge_2514::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void RisingEdge_2514::processInputPackets( const Packets_t& argDeclBases_2515, const Packets_t& members_2517, const Packets_t& localVars_2519, const Packets_t& contexts_251b, const Packets_t& unaryExprss_251d)
{
	for( Packets_t::const_iterator itArgDeclBase_2520= argDeclBases_2515.begin(), itMember_2529= members_2517.begin(), itLocalVar_2532= localVars_2519.begin(), itContext_253b= contexts_251b.begin(), itUnaryExprs_2544= unaryExprss_251d.begin(); itArgDeclBase_2520!= argDeclBases_2515.end(), itMember_2529!= members_2517.end(), itLocalVar_2532!= localVars_2519.end(), itContext_253b!= contexts_251b.end(), itUnaryExprs_2544!= unaryExprss_251d.end(); ++itArgDeclBase_2520, ++itMember_2529, ++itLocalVar_2532, ++itContext_253b, ++itUnaryExprs_2544)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_2520, *itMember_2529, *itLocalVar_2532, *itContext_253b, *itUnaryExprs_2544);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_2520, *itMember_2529, *itLocalVar_2532, *itContext_253b, *itUnaryExprs_2544);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool RisingEdge_2514::patternMatcher( const Udm::Object& argDeclBase_2521, const Udm::Object& member_252a, const Udm::Object& localVar_2533, const Udm::Object& context_253c, const Udm::Object& unaryExprs_2545)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_2521.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_2526= SFC::ArgDeclBase::Cast( argDeclBase_2521);
		if( false== Uml::IsDerivedFrom( member_252a.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_252f= SFC::LocalVar::Cast( member_252a);
		if( false== Uml::IsDerivedFrom( localVar_2533.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_2538= SFC::LocalVar::Cast( localVar_2533);
		if( false== Uml::IsDerivedFrom( context_253c.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_2541= SFC::Arg::Cast( context_253c);
		if( false== Uml::IsDerivedFrom( unaryExprs_2545.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_254a= SFC::UnaryExprs::Cast( unaryExprs_2545);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_254f;
		if( !isValidBound(boundObjs_254f, argDeclBase_2526, true))
			continue;
		currMatch.argDeclBase_2550= argDeclBase_2526;
		if( !isValidBound(boundObjs_254f, member_252f, true))
			continue;
		currMatch.member_2551= member_252f;
		if( !isValidBound(boundObjs_254f, localVar_2538, true))
			continue;
		currMatch.localVar_2552= localVar_2538;
		if( !isValidBound(boundObjs_254f, context_2541, true))
			continue;
		currMatch.context_2553= context_2541;
		if( !isValidBound(boundObjs_254f, unaryExprs_254a, true))
			continue;
		currMatch.unaryExprs_2554= unaryExprs_254a;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void RisingEdge_2514::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newAnd_2555= SFC::BinaryExprs::Create( currMatch.unaryExprs_2554, SFC::UnaryExprs::meta_subexpr);
		SFC::BinaryExprs newLessThan_2556= SFC::BinaryExprs::Create( newAnd_2555, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newMemberDot_2557= SFC::BinaryExprs::Create( newLessThan_2556, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newDot_2558= SFC::BinaryExprs::Create( newMemberDot_2557, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newMemberRef2_2559= SFC::ArgDeclRef::Create( newMemberDot_2557, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newGreaterThan_255a= SFC::BinaryExprs::Create( newAnd_2555, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newArgDeclDot_255b= SFC::BinaryExprs::Create( newGreaterThan_255a, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newMemberRef_255c= SFC::ArgDeclRef::Create( newArgDeclDot_255b, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_255d= SFC::ArgDeclRef::Create( newArgDeclDot_255b, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_255e= SFC::ArgDeclRef::Create( newDot_2558, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newZero2_255f= SFC::Int::Create( newGreaterThan_255a, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newZero_2560= SFC::Int::Create( newLessThan_2556, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef3_2561= SFC::ArgDeclRef::Create( newDot_2558, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs& And= newAnd_2555;
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_2550;
		SFC::BinaryExprs& ArgDeclDot= newArgDeclDot_255b;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_255d;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_255e;
		SFC::ArgDeclRef& ArgDeclRef3= newArgDeclRef3_2561;
		SFC::Arg& Context= currMatch.context_2553;
		SFC::BinaryExprs& Dot= newDot_2558;
		SFC::BinaryExprs& GreaterThan= newGreaterThan_255a;
		SFC::BinaryExprs& LessThan= newLessThan_2556;
		SFC::LocalVar& LocalVar= currMatch.localVar_2552;
		SFC::LocalVar& Member= currMatch.member_2551;
		SFC::BinaryExprs& MemberDot= newMemberDot_2557;
		SFC::ArgDeclRef& MemberRef= newMemberRef_255c;
		SFC::ArgDeclRef& MemberRef2= newMemberRef2_2559;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_2554;
		SFC::Int& Zero= newZero_2560;
		SFC::Int& Zero2= newZero2_255f;
		{
ArgDeclDot.op() = ".";
};
		{
MemberDot.op() = ".";
};
		{
Zero2.val() = 0;
};
		{
Zero.val() = 0;
};
		{
Dot.op() = ".";
};
		{
GreaterThan.op() = ">";
};
		{
And.op() = "&&";
};
		{
LessThan.op() = "<=";
};
		newMemberRef2_2559.argdecl()= currMatch.member_2551;
		newMemberRef_255c.argdecl()= currMatch.member_2551;
		newArgDeclRef3_2561.argdecl()= currMatch.context_2553;
		newArgDeclRef_255d.argdecl()= currMatch.argDeclBase_2550;
		newArgDeclRef2_255e.argdecl()= currMatch.localVar_2552;
	}
}

void EdgeTest_2562::operator()( const Packets_t& triggers_2563, const Packets_t& argdecls_2565, const Packets_t& members_2567, const Packets_t& oldvals_2569, const Packets_t& contexts_256b, const Packets_t& initexprs_256d, Packets_t& argdecls_256f, Packets_t& members_2570, Packets_t& oldvals_2571, Packets_t& contexts_2572, Packets_t& initexprs_2573, Packets_t& argdecls_2574, Packets_t& members_2575, Packets_t& oldvals_2576, Packets_t& contexts_2577, Packets_t& initexprs_2578, Packets_t& argdecls_2579, Packets_t& members_257a, Packets_t& oldvals_257b, Packets_t& contexts_257c, Packets_t& initexprs_257d)
{
#ifdef PRINT_INFO
	printLog( "EdgeTest_2562" );
#endif
	_argdecl_257e= &argdecls_256f;
	_member_257f= &members_2570;
	_oldval_2580= &oldvals_2571;
	_context_2581= &contexts_2572;
	_initexpr_2582= &initexprs_2573;
	_argdecl_2583= &argdecls_2574;
	_member_2584= &members_2575;
	_oldval_2585= &oldvals_2576;
	_context_2586= &contexts_2577;
	_initexpr_2587= &initexprs_2578;
	_argdecl_2588= &argdecls_2579;
	_member_2589= &members_257a;
	_oldval_258a= &oldvals_257b;
	_context_258b= &contexts_257c;
	_initexpr_258c= &initexprs_257d;
	for( Packets_t::const_iterator ittrigger_258e= triggers_2563.begin(), itargdecl_2595= argdecls_2565.begin(), itmember_259c= members_2567.begin(), itoldval_25a3= oldvals_2569.begin(), itcontext_25aa= contexts_256b.begin(), itinitexpr_25b1= initexprs_256d.begin(); ittrigger_258e!= triggers_2563.end(), itargdecl_2595!= argdecls_2565.end(), itmember_259c!= members_2567.end(), itoldval_25a3!= oldvals_2569.end(), itcontext_25aa!= contexts_256b.end(), itinitexpr_25b1!= initexprs_256d.end(); ++ittrigger_258e, ++itargdecl_2595, ++itmember_259c, ++itoldval_25a3, ++itcontext_25aa, ++itinitexpr_25b1)
	{
		bool isUnique= isInputUnique( *ittrigger_258e, *itargdecl_2595, *itmember_259c, *itoldval_25a3, *itcontext_25aa, *itinitexpr_25b1);
		if( !isUnique)
			continue;
		Packets_t onetrigger_2592( 1, *ittrigger_258e);
		Packets_t oneargdecl_2599( 1, *itargdecl_2595);
		Packets_t onemember_25a0( 1, *itmember_259c);
		Packets_t oneoldval_25a7( 1, *itoldval_25a3);
		Packets_t onecontext_25ae( 1, *itcontext_25aa);
		Packets_t oneinitexpr_25b5( 1, *itinitexpr_25b1);
		executeOne( onetrigger_2592, oneargdecl_2599, onemember_25a0, oneoldval_25a7, onecontext_25ae, oneinitexpr_25b5);
	}
}

void EdgeTest_2562::executeOne( const Packets_t& triggers_2563, const Packets_t& argdecls_2565, const Packets_t& members_2567, const Packets_t& oldvals_2569, const Packets_t& contexts_256b, const Packets_t& initexprs_256d)
{
	Packets_t argDeclBases_25bc;
	Packets_t members_25bf;
	Packets_t localVars_25c2;
	Packets_t contexts_25c5;
	Packets_t unaryExprss_25c8;
	RisingEdge_25b7 risingEdge_25b7;
	bool isMatchRisingEdge_25b7= risingEdge_25b7( triggers_2563, argdecls_2565, members_2567, oldvals_2569, contexts_256b, initexprs_256d, argDeclBases_25bc, members_25bf, localVars_25c2, contexts_25c5, unaryExprss_25c8);
	_argdecl_257e->insert( _argdecl_257e->end(), argDeclBases_25bc.begin(), argDeclBases_25bc.end());
	_member_257f->insert( _member_257f->end(), members_25bf.begin(), members_25bf.end());
	_oldval_2580->insert( _oldval_2580->end(), localVars_25c2.begin(), localVars_25c2.end());
	_context_2581->insert( _context_2581->end(), contexts_25c5.begin(), contexts_25c5.end());
	_initexpr_2582->insert( _initexpr_2582->end(), unaryExprss_25c8.begin(), unaryExprss_25c8.end());
	if( isMatchRisingEdge_25b7)
		return;
	Packets_t argDeclBases_2623;
	Packets_t members_2626;
	Packets_t localVars_2629;
	Packets_t contexts_262c;
	Packets_t unaryExprss_262f;
	FallingEdge_261e fallingEdge_261e;
	bool isMatchFallingEdge_261e= fallingEdge_261e( triggers_2563, argdecls_2565, members_2567, oldvals_2569, contexts_256b, initexprs_256d, argDeclBases_2623, members_2626, localVars_2629, contexts_262c, unaryExprss_262f);
	_argdecl_2583->insert( _argdecl_2583->end(), argDeclBases_2623.begin(), argDeclBases_2623.end());
	_member_2584->insert( _member_2584->end(), members_2626.begin(), members_2626.end());
	_oldval_2585->insert( _oldval_2585->end(), localVars_2629.begin(), localVars_2629.end());
	_context_2586->insert( _context_2586->end(), contexts_262c.begin(), contexts_262c.end());
	_initexpr_2587->insert( _initexpr_2587->end(), unaryExprss_262f.begin(), unaryExprss_262f.end());
	Packets_t argDeclBases_268a;
	Packets_t members_268d;
	Packets_t localVars_2690;
	Packets_t contexts_2693;
	Packets_t unaryExprss_2696;
	EitherEdge_2685 eitherEdge_2685;
	bool isMatchEitherEdge_2685= eitherEdge_2685( triggers_2563, argdecls_2565, members_2567, oldvals_2569, contexts_256b, initexprs_256d, argDeclBases_268a, members_268d, localVars_2690, contexts_2693, unaryExprss_2696);
	_argdecl_2588->insert( _argdecl_2588->end(), argDeclBases_268a.begin(), argDeclBases_268a.end());
	_member_2589->insert( _member_2589->end(), members_268d.begin(), members_268d.end());
	_oldval_258a->insert( _oldval_258a->end(), localVars_2690.begin(), localVars_2690.end());
	_context_258b->insert( _context_258b->end(), contexts_2693.begin(), contexts_2693.end());
	_initexpr_258c->insert( _initexpr_258c->end(), unaryExprss_2696.begin(), unaryExprss_2696.end());
}

bool EdgeTest_2562::isInputUnique( const Udm::Object& trigger_258f, const Udm::Object& argdecl_2596, const Udm::Object& member_259d, const Udm::Object& oldval_25a4, const Udm::Object& context_25ab, const Udm::Object& initexpr_25b2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator ittrigger_2591= _trigger_258d.begin(), itargdecl_2598= _argdecl_2594.begin(), itmember_259f= _member_259b.begin(), itoldval_25a6= _oldval_25a2.begin(), itcontext_25ad= _context_25a9.begin(), itinitexpr_25b4= _initexpr_25b0.begin(); ittrigger_2591!= _trigger_258d.end(), itargdecl_2598!= _argdecl_2594.end(), itmember_259f!= _member_259b.end(), itoldval_25a6!= _oldval_25a2.end(), itcontext_25ad!= _context_25a9.end(), itinitexpr_25b4!= _initexpr_25b0.end(); ++ittrigger_2591, ++itargdecl_2598, ++itmember_259f, ++itoldval_25a6, ++itcontext_25ad, ++itinitexpr_25b4)
	{
		if( ( *ittrigger_2591== trigger_258f)&& ( *itargdecl_2598== argdecl_2596)&& ( *itmember_259f== member_259d)&& ( *itoldval_25a6== oldval_25a4)&& ( *itcontext_25ad== context_25ab)&& ( *itinitexpr_25b4== initexpr_25b2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_trigger_258d.push_back( trigger_258f);
		_argdecl_2594.push_back( argdecl_2596);
		_member_259b.push_back( member_259d);
		_oldval_25a2.push_back( oldval_25a4);
		_context_25a9.push_back( context_25ab);
		_initexpr_25b0.push_back( initexpr_25b2);
	}
	return isUnique;
}

bool RisingEdge_25b7::operator()( const Packets_t& triggerPorts_25b8, const Packets_t& argDeclBases_25ba, const Packets_t& members_25bd, const Packets_t& localVars_25c0, const Packets_t& contexts_25c3, const Packets_t& unaryExprss_25c6, Packets_t& argDeclBases_25bc, Packets_t& members_25bf, Packets_t& localVars_25c2, Packets_t& contexts_25c5, Packets_t& unaryExprss_25c8)
{
#ifdef PRINT_INFO
	printLog( "RisingEdge_25b7" );
#endif
	_argDeclBase_25c9= &argDeclBases_25bc;
	_member_25ca= &members_25bf;
	_localVar_25cb= &localVars_25c2;
	_context_25cc= &contexts_25c5;
	_unaryExprs_25cd= &unaryExprss_25c8;
	processInputPackets( triggerPorts_25b8, argDeclBases_25ba, members_25bd, localVars_25c0, contexts_25c3, unaryExprss_25c6);
	if( false== _matches.empty())
		return true;
	return false;
}

bool RisingEdge_25b7::isInputUnique( const Udm::Object& triggerPort_25d2, const Udm::Object& argDeclBase_25db, const Udm::Object& member_25e4, const Udm::Object& localVar_25ed, const Udm::Object& context_25f6, const Udm::Object& unaryExprs_25ff)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itTriggerPort_25d4= _triggerPort_25ce.begin(), itArgDeclBase_25dd= _argDeclBase_25d7.begin(), itMember_25e6= _member_25e0.begin(), itLocalVar_25ef= _localVar_25e9.begin(), itContext_25f8= _context_25f2.begin(), itUnaryExprs_2601= _unaryExprs_25fb.begin(); itTriggerPort_25d4!= _triggerPort_25ce.end(), itArgDeclBase_25dd!= _argDeclBase_25d7.end(), itMember_25e6!= _member_25e0.end(), itLocalVar_25ef!= _localVar_25e9.end(), itContext_25f8!= _context_25f2.end(), itUnaryExprs_2601!= _unaryExprs_25fb.end(); ++itTriggerPort_25d4, ++itArgDeclBase_25dd, ++itMember_25e6, ++itLocalVar_25ef, ++itContext_25f8, ++itUnaryExprs_2601)
	{
		if( ( *itTriggerPort_25d4== triggerPort_25d2)&& ( *itArgDeclBase_25dd== argDeclBase_25db)&& ( *itMember_25e6== member_25e4)&& ( *itLocalVar_25ef== localVar_25ed)&& ( *itContext_25f8== context_25f6)&& ( *itUnaryExprs_2601== unaryExprs_25ff))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_triggerPort_25ce.push_back( triggerPort_25d2);
		_argDeclBase_25d7.push_back( argDeclBase_25db);
		_member_25e0.push_back( member_25e4);
		_localVar_25e9.push_back( localVar_25ed);
		_context_25f2.push_back( context_25f6);
		_unaryExprs_25fb.push_back( unaryExprs_25ff);
	}
	return isUnique;
}

bool RisingEdge_25b7::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool RisingEdge_25b7::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, SFC::Arg& Context, SFC::LocalVar& LocalVar, SFC::LocalVar& Member, CyberComposition::Simulink::TriggerPort& TriggerPort, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	std::string trigger = TriggerPort.TriggerType();
Gz_guard = trigger == "rising";;
	return Gz_guard;
}

void RisingEdge_25b7::processInputPackets( const Packets_t& triggerPorts_25b8, const Packets_t& argDeclBases_25ba, const Packets_t& members_25bd, const Packets_t& localVars_25c0, const Packets_t& contexts_25c3, const Packets_t& unaryExprss_25c6)
{
	for( Packets_t::const_iterator itTriggerPort_25cf= triggerPorts_25b8.begin(), itArgDeclBase_25d8= argDeclBases_25ba.begin(), itMember_25e1= members_25bd.begin(), itLocalVar_25ea= localVars_25c0.begin(), itContext_25f3= contexts_25c3.begin(), itUnaryExprs_25fc= unaryExprss_25c6.begin(); itTriggerPort_25cf!= triggerPorts_25b8.end(), itArgDeclBase_25d8!= argDeclBases_25ba.end(), itMember_25e1!= members_25bd.end(), itLocalVar_25ea!= localVars_25c0.end(), itContext_25f3!= contexts_25c3.end(), itUnaryExprs_25fc!= unaryExprss_25c6.end(); ++itTriggerPort_25cf, ++itArgDeclBase_25d8, ++itMember_25e1, ++itLocalVar_25ea, ++itContext_25f3, ++itUnaryExprs_25fc)
	{
		bool isUnique= isInputUnique( *itTriggerPort_25cf, *itArgDeclBase_25d8, *itMember_25e1, *itLocalVar_25ea, *itContext_25f3, *itUnaryExprs_25fc);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itTriggerPort_25cf, *itArgDeclBase_25d8, *itMember_25e1, *itLocalVar_25ea, *itContext_25f3, *itUnaryExprs_25fc);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_2609, currMatch.member_260a, currMatch.localVar_260b, currMatch.context_260c, currMatch.unaryExprs_260d);
	}
}

bool RisingEdge_25b7::patternMatcher( const Udm::Object& triggerPort_25d0, const Udm::Object& argDeclBase_25d9, const Udm::Object& member_25e2, const Udm::Object& localVar_25eb, const Udm::Object& context_25f4, const Udm::Object& unaryExprs_25fd)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( triggerPort_25d0.type(), CyberComposition::Simulink::TriggerPort::meta))
			continue;
		CyberComposition::Simulink::TriggerPort triggerPort_25d5= CyberComposition::Simulink::TriggerPort::Cast( triggerPort_25d0);
		if( false== Uml::IsDerivedFrom( argDeclBase_25d9.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_25de= SFC::ArgDeclBase::Cast( argDeclBase_25d9);
		if( false== Uml::IsDerivedFrom( member_25e2.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_25e7= SFC::LocalVar::Cast( member_25e2);
		if( false== Uml::IsDerivedFrom( localVar_25eb.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_25f0= SFC::LocalVar::Cast( localVar_25eb);
		if( false== Uml::IsDerivedFrom( context_25f4.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_25f9= SFC::Arg::Cast( context_25f4);
		if( false== Uml::IsDerivedFrom( unaryExprs_25fd.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_2602= SFC::UnaryExprs::Cast( unaryExprs_25fd);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2607;
		if( !isValidBound(boundObjs_2607, triggerPort_25d5, true))
			continue;
		currMatch.triggerPort_2608= triggerPort_25d5;
		if( !isValidBound(boundObjs_2607, argDeclBase_25de, true))
			continue;
		currMatch.argDeclBase_2609= argDeclBase_25de;
		if( !isValidBound(boundObjs_2607, member_25e7, true))
			continue;
		currMatch.member_260a= member_25e7;
		if( !isValidBound(boundObjs_2607, localVar_25f0, true))
			continue;
		currMatch.localVar_260b= localVar_25f0;
		if( !isValidBound(boundObjs_2607, context_25f9, true))
			continue;
		currMatch.context_260c= context_25f9;
		if( !isValidBound(boundObjs_2607, unaryExprs_2602, true))
			continue;
		currMatch.unaryExprs_260d= unaryExprs_2602;
		bool Gz_guard= isGuardTrue( currMatch.argDeclBase_2609, currMatch.context_260c, currMatch.localVar_260b, currMatch.member_260a, currMatch.triggerPort_2608, currMatch.unaryExprs_260d);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void RisingEdge_25b7::outputAppender( const SFC::ArgDeclBase& argDeclBase_2614, const SFC::LocalVar& member_2616, const SFC::LocalVar& localVar_2618, const SFC::Arg& context_261a, const SFC::UnaryExprs& unaryExprs_261c)
{
	_argDeclBase_25c9->push_back( argDeclBase_2614);
	_member_25ca->push_back( member_2616);
	_localVar_25cb->push_back( localVar_2618);
	_context_25cc->push_back( context_261a);
	_unaryExprs_25cd->push_back( unaryExprs_261c);
}

bool FallingEdge_261e::operator()( const Packets_t& triggerPorts_261f, const Packets_t& argDeclBases_2621, const Packets_t& members_2624, const Packets_t& localVars_2627, const Packets_t& contexts_262a, const Packets_t& unaryExprss_262d, Packets_t& argDeclBases_2623, Packets_t& members_2626, Packets_t& localVars_2629, Packets_t& contexts_262c, Packets_t& unaryExprss_262f)
{
#ifdef PRINT_INFO
	printLog( "FallingEdge_261e" );
#endif
	_argDeclBase_2630= &argDeclBases_2623;
	_member_2631= &members_2626;
	_localVar_2632= &localVars_2629;
	_context_2633= &contexts_262c;
	_unaryExprs_2634= &unaryExprss_262f;
	processInputPackets( triggerPorts_261f, argDeclBases_2621, members_2624, localVars_2627, contexts_262a, unaryExprss_262d);
	if( false== _matches.empty())
		return true;
	return false;
}

bool FallingEdge_261e::isInputUnique( const Udm::Object& triggerPort_2639, const Udm::Object& argDeclBase_2642, const Udm::Object& member_264b, const Udm::Object& localVar_2654, const Udm::Object& context_265d, const Udm::Object& unaryExprs_2666)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itTriggerPort_263b= _triggerPort_2635.begin(), itArgDeclBase_2644= _argDeclBase_263e.begin(), itMember_264d= _member_2647.begin(), itLocalVar_2656= _localVar_2650.begin(), itContext_265f= _context_2659.begin(), itUnaryExprs_2668= _unaryExprs_2662.begin(); itTriggerPort_263b!= _triggerPort_2635.end(), itArgDeclBase_2644!= _argDeclBase_263e.end(), itMember_264d!= _member_2647.end(), itLocalVar_2656!= _localVar_2650.end(), itContext_265f!= _context_2659.end(), itUnaryExprs_2668!= _unaryExprs_2662.end(); ++itTriggerPort_263b, ++itArgDeclBase_2644, ++itMember_264d, ++itLocalVar_2656, ++itContext_265f, ++itUnaryExprs_2668)
	{
		if( ( *itTriggerPort_263b== triggerPort_2639)&& ( *itArgDeclBase_2644== argDeclBase_2642)&& ( *itMember_264d== member_264b)&& ( *itLocalVar_2656== localVar_2654)&& ( *itContext_265f== context_265d)&& ( *itUnaryExprs_2668== unaryExprs_2666))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_triggerPort_2635.push_back( triggerPort_2639);
		_argDeclBase_263e.push_back( argDeclBase_2642);
		_member_2647.push_back( member_264b);
		_localVar_2650.push_back( localVar_2654);
		_context_2659.push_back( context_265d);
		_unaryExprs_2662.push_back( unaryExprs_2666);
	}
	return isUnique;
}

bool FallingEdge_261e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool FallingEdge_261e::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, SFC::Arg& Context, SFC::LocalVar& LocalVar, SFC::LocalVar& Member, CyberComposition::Simulink::TriggerPort& TriggerPort, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	std::string trigger = TriggerPort.TriggerType();
Gz_guard = trigger == "falling";;
	return Gz_guard;
}

void FallingEdge_261e::processInputPackets( const Packets_t& triggerPorts_261f, const Packets_t& argDeclBases_2621, const Packets_t& members_2624, const Packets_t& localVars_2627, const Packets_t& contexts_262a, const Packets_t& unaryExprss_262d)
{
	for( Packets_t::const_iterator itTriggerPort_2636= triggerPorts_261f.begin(), itArgDeclBase_263f= argDeclBases_2621.begin(), itMember_2648= members_2624.begin(), itLocalVar_2651= localVars_2627.begin(), itContext_265a= contexts_262a.begin(), itUnaryExprs_2663= unaryExprss_262d.begin(); itTriggerPort_2636!= triggerPorts_261f.end(), itArgDeclBase_263f!= argDeclBases_2621.end(), itMember_2648!= members_2624.end(), itLocalVar_2651!= localVars_2627.end(), itContext_265a!= contexts_262a.end(), itUnaryExprs_2663!= unaryExprss_262d.end(); ++itTriggerPort_2636, ++itArgDeclBase_263f, ++itMember_2648, ++itLocalVar_2651, ++itContext_265a, ++itUnaryExprs_2663)
	{
		bool isUnique= isInputUnique( *itTriggerPort_2636, *itArgDeclBase_263f, *itMember_2648, *itLocalVar_2651, *itContext_265a, *itUnaryExprs_2663);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itTriggerPort_2636, *itArgDeclBase_263f, *itMember_2648, *itLocalVar_2651, *itContext_265a, *itUnaryExprs_2663);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_2670, currMatch.member_2671, currMatch.localVar_2672, currMatch.context_2673, currMatch.unaryExprs_2674);
	}
}

bool FallingEdge_261e::patternMatcher( const Udm::Object& triggerPort_2637, const Udm::Object& argDeclBase_2640, const Udm::Object& member_2649, const Udm::Object& localVar_2652, const Udm::Object& context_265b, const Udm::Object& unaryExprs_2664)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( triggerPort_2637.type(), CyberComposition::Simulink::TriggerPort::meta))
			continue;
		CyberComposition::Simulink::TriggerPort triggerPort_263c= CyberComposition::Simulink::TriggerPort::Cast( triggerPort_2637);
		if( false== Uml::IsDerivedFrom( argDeclBase_2640.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_2645= SFC::ArgDeclBase::Cast( argDeclBase_2640);
		if( false== Uml::IsDerivedFrom( member_2649.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_264e= SFC::LocalVar::Cast( member_2649);
		if( false== Uml::IsDerivedFrom( localVar_2652.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_2657= SFC::LocalVar::Cast( localVar_2652);
		if( false== Uml::IsDerivedFrom( context_265b.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_2660= SFC::Arg::Cast( context_265b);
		if( false== Uml::IsDerivedFrom( unaryExprs_2664.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_2669= SFC::UnaryExprs::Cast( unaryExprs_2664);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_266e;
		if( !isValidBound(boundObjs_266e, triggerPort_263c, true))
			continue;
		currMatch.triggerPort_266f= triggerPort_263c;
		if( !isValidBound(boundObjs_266e, argDeclBase_2645, true))
			continue;
		currMatch.argDeclBase_2670= argDeclBase_2645;
		if( !isValidBound(boundObjs_266e, member_264e, true))
			continue;
		currMatch.member_2671= member_264e;
		if( !isValidBound(boundObjs_266e, localVar_2657, true))
			continue;
		currMatch.localVar_2672= localVar_2657;
		if( !isValidBound(boundObjs_266e, context_2660, true))
			continue;
		currMatch.context_2673= context_2660;
		if( !isValidBound(boundObjs_266e, unaryExprs_2669, true))
			continue;
		currMatch.unaryExprs_2674= unaryExprs_2669;
		bool Gz_guard= isGuardTrue( currMatch.argDeclBase_2670, currMatch.context_2673, currMatch.localVar_2672, currMatch.member_2671, currMatch.triggerPort_266f, currMatch.unaryExprs_2674);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void FallingEdge_261e::outputAppender( const SFC::ArgDeclBase& argDeclBase_267b, const SFC::LocalVar& member_267d, const SFC::LocalVar& localVar_267f, const SFC::Arg& context_2681, const SFC::UnaryExprs& unaryExprs_2683)
{
	_argDeclBase_2630->push_back( argDeclBase_267b);
	_member_2631->push_back( member_267d);
	_localVar_2632->push_back( localVar_267f);
	_context_2633->push_back( context_2681);
	_unaryExprs_2634->push_back( unaryExprs_2683);
}

bool EitherEdge_2685::operator()( const Packets_t& triggerPorts_2686, const Packets_t& argDeclBases_2688, const Packets_t& members_268b, const Packets_t& localVars_268e, const Packets_t& contexts_2691, const Packets_t& unaryExprss_2694, Packets_t& argDeclBases_268a, Packets_t& members_268d, Packets_t& localVars_2690, Packets_t& contexts_2693, Packets_t& unaryExprss_2696)
{
#ifdef PRINT_INFO
	printLog( "EitherEdge_2685" );
#endif
	_argDeclBase_2697= &argDeclBases_268a;
	_member_2698= &members_268d;
	_localVar_2699= &localVars_2690;
	_context_269a= &contexts_2693;
	_unaryExprs_269b= &unaryExprss_2696;
	processInputPackets( triggerPorts_2686, argDeclBases_2688, members_268b, localVars_268e, contexts_2691, unaryExprss_2694);
	if( false== _matches.empty())
		return true;
	return false;
}

bool EitherEdge_2685::isInputUnique( const Udm::Object& triggerPort_26a0, const Udm::Object& argDeclBase_26a9, const Udm::Object& member_26b2, const Udm::Object& localVar_26bb, const Udm::Object& context_26c4, const Udm::Object& unaryExprs_26cd)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itTriggerPort_26a2= _triggerPort_269c.begin(), itArgDeclBase_26ab= _argDeclBase_26a5.begin(), itMember_26b4= _member_26ae.begin(), itLocalVar_26bd= _localVar_26b7.begin(), itContext_26c6= _context_26c0.begin(), itUnaryExprs_26cf= _unaryExprs_26c9.begin(); itTriggerPort_26a2!= _triggerPort_269c.end(), itArgDeclBase_26ab!= _argDeclBase_26a5.end(), itMember_26b4!= _member_26ae.end(), itLocalVar_26bd!= _localVar_26b7.end(), itContext_26c6!= _context_26c0.end(), itUnaryExprs_26cf!= _unaryExprs_26c9.end(); ++itTriggerPort_26a2, ++itArgDeclBase_26ab, ++itMember_26b4, ++itLocalVar_26bd, ++itContext_26c6, ++itUnaryExprs_26cf)
	{
		if( ( *itTriggerPort_26a2== triggerPort_26a0)&& ( *itArgDeclBase_26ab== argDeclBase_26a9)&& ( *itMember_26b4== member_26b2)&& ( *itLocalVar_26bd== localVar_26bb)&& ( *itContext_26c6== context_26c4)&& ( *itUnaryExprs_26cf== unaryExprs_26cd))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_triggerPort_269c.push_back( triggerPort_26a0);
		_argDeclBase_26a5.push_back( argDeclBase_26a9);
		_member_26ae.push_back( member_26b2);
		_localVar_26b7.push_back( localVar_26bb);
		_context_26c0.push_back( context_26c4);
		_unaryExprs_26c9.push_back( unaryExprs_26cd);
	}
	return isUnique;
}

bool EitherEdge_2685::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool EitherEdge_2685::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, SFC::Arg& Context, SFC::LocalVar& LocalVar, SFC::LocalVar& Member, CyberComposition::Simulink::TriggerPort& TriggerPort, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	std::string trigger = TriggerPort.TriggerType();
Gz_guard = trigger == "either";;
	return Gz_guard;
}

void EitherEdge_2685::processInputPackets( const Packets_t& triggerPorts_2686, const Packets_t& argDeclBases_2688, const Packets_t& members_268b, const Packets_t& localVars_268e, const Packets_t& contexts_2691, const Packets_t& unaryExprss_2694)
{
	for( Packets_t::const_iterator itTriggerPort_269d= triggerPorts_2686.begin(), itArgDeclBase_26a6= argDeclBases_2688.begin(), itMember_26af= members_268b.begin(), itLocalVar_26b8= localVars_268e.begin(), itContext_26c1= contexts_2691.begin(), itUnaryExprs_26ca= unaryExprss_2694.begin(); itTriggerPort_269d!= triggerPorts_2686.end(), itArgDeclBase_26a6!= argDeclBases_2688.end(), itMember_26af!= members_268b.end(), itLocalVar_26b8!= localVars_268e.end(), itContext_26c1!= contexts_2691.end(), itUnaryExprs_26ca!= unaryExprss_2694.end(); ++itTriggerPort_269d, ++itArgDeclBase_26a6, ++itMember_26af, ++itLocalVar_26b8, ++itContext_26c1, ++itUnaryExprs_26ca)
	{
		bool isUnique= isInputUnique( *itTriggerPort_269d, *itArgDeclBase_26a6, *itMember_26af, *itLocalVar_26b8, *itContext_26c1, *itUnaryExprs_26ca);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itTriggerPort_269d, *itArgDeclBase_26a6, *itMember_26af, *itLocalVar_26b8, *itContext_26c1, *itUnaryExprs_26ca);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_26d7, currMatch.member_26d8, currMatch.localVar_26d9, currMatch.context_26da, currMatch.unaryExprs_26db);
	}
}

bool EitherEdge_2685::patternMatcher( const Udm::Object& triggerPort_269e, const Udm::Object& argDeclBase_26a7, const Udm::Object& member_26b0, const Udm::Object& localVar_26b9, const Udm::Object& context_26c2, const Udm::Object& unaryExprs_26cb)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( triggerPort_269e.type(), CyberComposition::Simulink::TriggerPort::meta))
			continue;
		CyberComposition::Simulink::TriggerPort triggerPort_26a3= CyberComposition::Simulink::TriggerPort::Cast( triggerPort_269e);
		if( false== Uml::IsDerivedFrom( argDeclBase_26a7.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_26ac= SFC::ArgDeclBase::Cast( argDeclBase_26a7);
		if( false== Uml::IsDerivedFrom( member_26b0.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_26b5= SFC::LocalVar::Cast( member_26b0);
		if( false== Uml::IsDerivedFrom( localVar_26b9.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_26be= SFC::LocalVar::Cast( localVar_26b9);
		if( false== Uml::IsDerivedFrom( context_26c2.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_26c7= SFC::Arg::Cast( context_26c2);
		if( false== Uml::IsDerivedFrom( unaryExprs_26cb.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_26d0= SFC::UnaryExprs::Cast( unaryExprs_26cb);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_26d5;
		if( !isValidBound(boundObjs_26d5, triggerPort_26a3, true))
			continue;
		currMatch.triggerPort_26d6= triggerPort_26a3;
		if( !isValidBound(boundObjs_26d5, argDeclBase_26ac, true))
			continue;
		currMatch.argDeclBase_26d7= argDeclBase_26ac;
		if( !isValidBound(boundObjs_26d5, member_26b5, true))
			continue;
		currMatch.member_26d8= member_26b5;
		if( !isValidBound(boundObjs_26d5, localVar_26be, true))
			continue;
		currMatch.localVar_26d9= localVar_26be;
		if( !isValidBound(boundObjs_26d5, context_26c7, true))
			continue;
		currMatch.context_26da= context_26c7;
		if( !isValidBound(boundObjs_26d5, unaryExprs_26d0, true))
			continue;
		currMatch.unaryExprs_26db= unaryExprs_26d0;
		bool Gz_guard= isGuardTrue( currMatch.argDeclBase_26d7, currMatch.context_26da, currMatch.localVar_26d9, currMatch.member_26d8, currMatch.triggerPort_26d6, currMatch.unaryExprs_26db);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void EitherEdge_2685::outputAppender( const SFC::ArgDeclBase& argDeclBase_26e2, const SFC::LocalVar& member_26e4, const SFC::LocalVar& localVar_26e6, const SFC::Arg& context_26e8, const SFC::UnaryExprs& unaryExprs_26ea)
{
	_argDeclBase_2697->push_back( argDeclBase_26e2);
	_member_2698->push_back( member_26e4);
	_localVar_2699->push_back( localVar_26e6);
	_context_269a->push_back( context_26e8);
	_unaryExprs_269b->push_back( unaryExprs_26ea);
}

void AddTriggerVar_26ec::operator()( const Packets_t& triggerPorts_26ed, const Packets_t& argDeclBases_26f0, const Packets_t& structs_26f3, const Packets_t& localVars_26f6, const Packets_t& contexts_26f9, const Packets_t& functions_26fd, Packets_t& triggerPorts_26ef, Packets_t& argDeclBases_26f2, Packets_t& structs_26f5, Packets_t& localVars_26f8, Packets_t& contexts_26fb, Packets_t& triggerVars_26fc, Packets_t& functions_26ff)
{
#ifdef PRINT_INFO
	printLog( "AddTriggerVar_26ec" );
#endif
	RTTGenerator::Instance()->generateRule(2457, "AddTriggerVar");
	_triggerPort_2700= &triggerPorts_26ef;
	_argDeclBase_2701= &argDeclBases_26f2;
	_struct_2702= &structs_26f5;
	_localVar_2703= &localVars_26f8;
	_context_2704= &contexts_26fb;
	_triggerVar_2705= &triggerVars_26fc;
	_function_2706= &functions_26ff;
	processInputPackets( triggerPorts_26ed, argDeclBases_26f0, structs_26f3, localVars_26f6, contexts_26f9, functions_26fd);
}

bool AddTriggerVar_26ec::isInputUnique( const Udm::Object& triggerPort_270b, const Udm::Object& argDeclBase_2714, const Udm::Object& struct_271d, const Udm::Object& localVar_2726, const Udm::Object& context_272f, const Udm::Object& function_2738)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itTriggerPort_270d= _triggerPort_2707.begin(), itArgDeclBase_2716= _argDeclBase_2710.begin(), itStruct_271f= _struct_2719.begin(), itLocalVar_2728= _localVar_2722.begin(), itContext_2731= _context_272b.begin(), itFunction_273a= _function_2734.begin(); itTriggerPort_270d!= _triggerPort_2707.end(), itArgDeclBase_2716!= _argDeclBase_2710.end(), itStruct_271f!= _struct_2719.end(), itLocalVar_2728!= _localVar_2722.end(), itContext_2731!= _context_272b.end(), itFunction_273a!= _function_2734.end(); ++itTriggerPort_270d, ++itArgDeclBase_2716, ++itStruct_271f, ++itLocalVar_2728, ++itContext_2731, ++itFunction_273a)
	{
		if( ( *itTriggerPort_270d== triggerPort_270b)&& ( *itArgDeclBase_2716== argDeclBase_2714)&& ( *itStruct_271f== struct_271d)&& ( *itLocalVar_2728== localVar_2726)&& ( *itContext_2731== context_272f)&& ( *itFunction_273a== function_2738))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_triggerPort_2707.push_back( triggerPort_270b);
		_argDeclBase_2710.push_back( argDeclBase_2714);
		_struct_2719.push_back( struct_271d);
		_localVar_2722.push_back( localVar_2726);
		_context_272b.push_back( context_272f);
		_function_2734.push_back( function_2738);
	}
	return isUnique;
}

bool AddTriggerVar_26ec::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void AddTriggerVar_26ec::processInputPackets( const Packets_t& triggerPorts_26ed, const Packets_t& argDeclBases_26f0, const Packets_t& structs_26f3, const Packets_t& localVars_26f6, const Packets_t& contexts_26f9, const Packets_t& functions_26fd)
{
	for( Packets_t::const_iterator itTriggerPort_2708= triggerPorts_26ed.begin(), itArgDeclBase_2711= argDeclBases_26f0.begin(), itStruct_271a= structs_26f3.begin(), itLocalVar_2723= localVars_26f6.begin(), itContext_272c= contexts_26f9.begin(), itFunction_2735= functions_26fd.begin(); itTriggerPort_2708!= triggerPorts_26ed.end(), itArgDeclBase_2711!= argDeclBases_26f0.end(), itStruct_271a!= structs_26f3.end(), itLocalVar_2723!= localVars_26f6.end(), itContext_272c!= contexts_26f9.end(), itFunction_2735!= functions_26fd.end(); ++itTriggerPort_2708, ++itArgDeclBase_2711, ++itStruct_271a, ++itLocalVar_2723, ++itContext_272c, ++itFunction_2735)
	{
		bool isUnique= isInputUnique( *itTriggerPort_2708, *itArgDeclBase_2711, *itStruct_271a, *itLocalVar_2723, *itContext_272c, *itFunction_2735);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itTriggerPort_2708, *itArgDeclBase_2711, *itStruct_271a, *itLocalVar_2723, *itContext_272c, *itFunction_2735);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AddTriggerVar_26ec::patternMatcher( const Udm::Object& triggerPort_2709, const Udm::Object& argDeclBase_2712, const Udm::Object& struct_271b, const Udm::Object& localVar_2724, const Udm::Object& context_272d, const Udm::Object& function_2736)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( triggerPort_2709.type(), CyberComposition::Simulink::TriggerPort::meta))
			continue;
		CyberComposition::Simulink::TriggerPort triggerPort_270e= CyberComposition::Simulink::TriggerPort::Cast( triggerPort_2709);
		if( false== Uml::IsDerivedFrom( argDeclBase_2712.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_2717= SFC::ArgDeclBase::Cast( argDeclBase_2712);
		if( false== Uml::IsDerivedFrom( struct_271b.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_2720= SFC::Struct::Cast( struct_271b);
		if( false== Uml::IsDerivedFrom( localVar_2724.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_2729= SFC::LocalVar::Cast( localVar_2724);
		if( false== Uml::IsDerivedFrom( context_272d.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_2732= SFC::Arg::Cast( context_272d);
		if( false== Uml::IsDerivedFrom( function_2736.type(), SFC::Function::meta))
			continue;
		SFC::Function function_273b= SFC::Function::Cast( function_2736);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2740;
		if( !isValidBound(boundObjs_2740, triggerPort_270e, true))
			continue;
		currMatch.triggerPort_2741= triggerPort_270e;
		if( !isValidBound(boundObjs_2740, argDeclBase_2717, true))
			continue;
		currMatch.argDeclBase_2742= argDeclBase_2717;
		if( !isValidBound(boundObjs_2740, struct_2720, true))
			continue;
		currMatch.struct_2743= struct_2720;
		if( !isValidBound(boundObjs_2740, localVar_2729, true))
			continue;
		currMatch.localVar_2744= localVar_2729;
		if( !isValidBound(boundObjs_2740, context_2732, true))
			continue;
		currMatch.context_2745= context_2732;
		if( !isValidBound(boundObjs_2740, function_273b, true))
			continue;
		currMatch.function_2746= function_273b;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void AddTriggerVar_26ec::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newTriggerVar_2747= SFC::LocalVar::Create( currMatch.function_2746, SFC::Function::meta_stmnt);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_2742;
		SFC::Arg& Context= currMatch.context_2745;
		SFC::Function& Function= currMatch.function_2746;
		SFC::LocalVar& LocalVar= currMatch.localVar_2744;
		SFC::Struct& Struct= currMatch.struct_2743;
		CyberComposition::Simulink::TriggerPort& TriggerPort= currMatch.triggerPort_2741;
		SFC::LocalVar& TriggerVar= newTriggerVar_2747;
		{
TriggerVar.type() = "int";
TriggerVar.name() = std::string( "event" ) + boost::lexical_cast< std::string >( TriggerVar.uniqueId() );
};
		{
__int64 statementCount = Function.statementCount();
TriggerVar.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		newTriggerVar_2747.dt()= currMatch.struct_2743;
		currMatch.localVar_2744.trigvar()= newTriggerVar_2747;
		outputAppender( currMatch.triggerPort_2741, currMatch.argDeclBase_2742, currMatch.struct_2743, currMatch.localVar_2744, currMatch.context_2745, newTriggerVar_2747, currMatch.function_2746);
	}
}

void AddTriggerVar_26ec::outputAppender( const CyberComposition::Simulink::TriggerPort& triggerPort_2748, const SFC::ArgDeclBase& argDeclBase_274a, const SFC::Struct& struct_274c, const SFC::LocalVar& localVar_274e, const SFC::Arg& context_2750, const SFC::LocalVar& triggerVar_2752, const SFC::Function& function_2754)
{
	_triggerPort_2700->push_back( triggerPort_2748);
	_argDeclBase_2701->push_back( argDeclBase_274a);
	_struct_2702->push_back( struct_274c);
	_localVar_2703->push_back( localVar_274e);
	_context_2704->push_back( context_2750);
	_triggerVar_2705->push_back( triggerVar_2752);
	_function_2706->push_back( function_2754);
}

void StartAssignment_2756::operator()( const Packets_t& triggerPorts_2757, const Packets_t& argDeclBases_275a, const Packets_t& structs_275e, const Packets_t& oldvals_2760, const Packets_t& contexts_2763, const Packets_t& triggerVars_2766, const Packets_t& functions_2768, Packets_t& triggerPorts_2759, Packets_t& argDeclBases_275c, Packets_t& localVars_275d, Packets_t& oldvals_2762, Packets_t& contexts_2765, Packets_t& unaryExprss_276a)
{
#ifdef PRINT_INFO
	printLog( "StartAssignment_2756" );
#endif
	RTTGenerator::Instance()->generateRule(2470, "StartAssignment");
	_triggerPort_276b= &triggerPorts_2759;
	_argDeclBase_276c= &argDeclBases_275c;
	_localVar_276d= &localVars_275d;
	_oldval_276e= &oldvals_2762;
	_context_276f= &contexts_2765;
	_unaryExprs_2770= &unaryExprss_276a;
	processInputPackets( triggerPorts_2757, argDeclBases_275a, structs_275e, oldvals_2760, contexts_2763, triggerVars_2766, functions_2768);
}

bool StartAssignment_2756::isInputUnique( const Udm::Object& triggerPort_2775, const Udm::Object& argDeclBase_277e, const Udm::Object& struct_2787, const Udm::Object& oldval_2790, const Udm::Object& context_2799, const Udm::Object& triggerVar_27a2, const Udm::Object& function_27ab)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itTriggerPort_2777= _triggerPort_2771.begin(), itArgDeclBase_2780= _argDeclBase_277a.begin(), itStruct_2789= _struct_2783.begin(), itoldval_2792= _oldval_278c.begin(), itContext_279b= _context_2795.begin(), itTriggerVar_27a4= _triggerVar_279e.begin(), itFunction_27ad= _function_27a7.begin(); itTriggerPort_2777!= _triggerPort_2771.end(), itArgDeclBase_2780!= _argDeclBase_277a.end(), itStruct_2789!= _struct_2783.end(), itoldval_2792!= _oldval_278c.end(), itContext_279b!= _context_2795.end(), itTriggerVar_27a4!= _triggerVar_279e.end(), itFunction_27ad!= _function_27a7.end(); ++itTriggerPort_2777, ++itArgDeclBase_2780, ++itStruct_2789, ++itoldval_2792, ++itContext_279b, ++itTriggerVar_27a4, ++itFunction_27ad)
	{
		if( ( *itTriggerPort_2777== triggerPort_2775)&& ( *itArgDeclBase_2780== argDeclBase_277e)&& ( *itStruct_2789== struct_2787)&& ( *itoldval_2792== oldval_2790)&& ( *itContext_279b== context_2799)&& ( *itTriggerVar_27a4== triggerVar_27a2)&& ( *itFunction_27ad== function_27ab))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_triggerPort_2771.push_back( triggerPort_2775);
		_argDeclBase_277a.push_back( argDeclBase_277e);
		_struct_2783.push_back( struct_2787);
		_oldval_278c.push_back( oldval_2790);
		_context_2795.push_back( context_2799);
		_triggerVar_279e.push_back( triggerVar_27a2);
		_function_27a7.push_back( function_27ab);
	}
	return isUnique;
}

bool StartAssignment_2756::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void StartAssignment_2756::processInputPackets( const Packets_t& triggerPorts_2757, const Packets_t& argDeclBases_275a, const Packets_t& structs_275e, const Packets_t& oldvals_2760, const Packets_t& contexts_2763, const Packets_t& triggerVars_2766, const Packets_t& functions_2768)
{
	for( Packets_t::const_iterator itTriggerPort_2772= triggerPorts_2757.begin(), itArgDeclBase_277b= argDeclBases_275a.begin(), itStruct_2784= structs_275e.begin(), itoldval_278d= oldvals_2760.begin(), itContext_2796= contexts_2763.begin(), itTriggerVar_279f= triggerVars_2766.begin(), itFunction_27a8= functions_2768.begin(); itTriggerPort_2772!= triggerPorts_2757.end(), itArgDeclBase_277b!= argDeclBases_275a.end(), itStruct_2784!= structs_275e.end(), itoldval_278d!= oldvals_2760.end(), itContext_2796!= contexts_2763.end(), itTriggerVar_279f!= triggerVars_2766.end(), itFunction_27a8!= functions_2768.end(); ++itTriggerPort_2772, ++itArgDeclBase_277b, ++itStruct_2784, ++itoldval_278d, ++itContext_2796, ++itTriggerVar_279f, ++itFunction_27a8)
	{
		bool isUnique= isInputUnique( *itTriggerPort_2772, *itArgDeclBase_277b, *itStruct_2784, *itoldval_278d, *itContext_2796, *itTriggerVar_279f, *itFunction_27a8);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itTriggerPort_2772, *itArgDeclBase_277b, *itStruct_2784, *itoldval_278d, *itContext_2796, *itTriggerVar_279f, *itFunction_27a8);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool StartAssignment_2756::patternMatcher( const Udm::Object& triggerPort_2773, const Udm::Object& argDeclBase_277c, const Udm::Object& struct_2785, const Udm::Object& oldval_278e, const Udm::Object& context_2797, const Udm::Object& triggerVar_27a0, const Udm::Object& function_27a9)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( triggerPort_2773.type(), CyberComposition::Simulink::TriggerPort::meta))
			continue;
		CyberComposition::Simulink::TriggerPort triggerPort_2778= CyberComposition::Simulink::TriggerPort::Cast( triggerPort_2773);
		if( false== Uml::IsDerivedFrom( argDeclBase_277c.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_2781= SFC::ArgDeclBase::Cast( argDeclBase_277c);
		if( false== Uml::IsDerivedFrom( struct_2785.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_278a= SFC::Struct::Cast( struct_2785);
		if( false== Uml::IsDerivedFrom( oldval_278e.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar oldval_2793= SFC::LocalVar::Cast( oldval_278e);
		if( false== Uml::IsDerivedFrom( context_2797.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_279c= SFC::Arg::Cast( context_2797);
		if( false== Uml::IsDerivedFrom( triggerVar_27a0.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_27a5= SFC::LocalVar::Cast( triggerVar_27a0);
		if( false== Uml::IsDerivedFrom( function_27a9.type(), SFC::Function::meta))
			continue;
		SFC::Function function_27ae= SFC::Function::Cast( function_27a9);
		set< SFC::LocalVar> localVars_27b0= struct_278a.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itLocalVar_27b1= localVars_27b0.begin(); itLocalVar_27b1!= localVars_27b0.end(); ++itLocalVar_27b1)
		{
			SFC::LocalVar currLocalVar_27b2= *itLocalVar_27b1;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_27b6;
			if( !isValidBound(boundObjs_27b6, triggerPort_2778, true))
				continue;
			currMatch.triggerPort_27b7= triggerPort_2778;
			if( !isValidBound(boundObjs_27b6, argDeclBase_2781, true))
				continue;
			currMatch.argDeclBase_27b8= argDeclBase_2781;
			if( !isValidBound(boundObjs_27b6, struct_278a, true))
				continue;
			currMatch.struct_27b9= struct_278a;
			if( !isValidBound(boundObjs_27b6, oldval_2793, true))
				continue;
			currMatch.oldval_27ba= oldval_2793;
			if( !isValidBound(boundObjs_27b6, context_279c, true))
				continue;
			currMatch.context_27bb= context_279c;
			if( !isValidBound(boundObjs_27b6, triggerVar_27a5, true))
				continue;
			currMatch.triggerVar_27bc= triggerVar_27a5;
			if( !isValidBound(boundObjs_27b6, function_27ae, true))
				continue;
			currMatch.function_27bd= function_27ae;
			if( !isValidBound(boundObjs_27b6, currLocalVar_27b2, false))
				continue;
			currMatch.localVar_27be= currLocalVar_27b2;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void StartAssignment_2756::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newAssignment_27bf= SFC::UserCode::Create( currMatch.function_27bd, SFC::Function::meta_stmnt);
		SFC::BinaryExprs newAssign_27c0= SFC::BinaryExprs::Create( newAssignment_27bf, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newDot_27c1= SFC::BinaryExprs::Create( newAssign_27c0, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_27c2= SFC::ArgDeclRef::Create( newDot_27c1, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_27c3= SFC::ArgDeclRef::Create( newDot_27c1, SFC::BinaryExprs::meta_leftexpr);
		SFC::UnaryExprs newUnaryExprs_27c4= SFC::UnaryExprs::Create( newAssign_27c0, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_27b8;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_27c3;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_27c2;
		SFC::BinaryExprs& Assign= newAssign_27c0;
		SFC::UserCode& Assignment= newAssignment_27bf;
		SFC::Arg& Context= currMatch.context_27bb;
		SFC::BinaryExprs& Dot= newDot_27c1;
		SFC::Function& Function= currMatch.function_27bd;
		SFC::LocalVar& LocalVar= currMatch.localVar_27be;
		SFC::Struct& Struct= currMatch.struct_27b9;
		CyberComposition::Simulink::TriggerPort& TriggerPort= currMatch.triggerPort_27b7;
		SFC::LocalVar& TriggerVar= currMatch.triggerVar_27bc;
		SFC::UnaryExprs& UnaryExprs= newUnaryExprs_27c4;
		SFC::LocalVar& oldval= currMatch.oldval_27ba;
		{
Assign.op() = "=";
};
		{
Dot.op() = ".";
};
		{
UnaryExprs.op() = "";
};
		{
__int64 statementCount = Function.statementCount();
Assignment.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		newArgDeclRef2_27c2.argdecl()= currMatch.localVar_27be;
		newArgDeclRef_27c3.argdecl()= currMatch.triggerVar_27bc;
		outputAppender( currMatch.triggerPort_27b7, currMatch.argDeclBase_27b8, currMatch.localVar_27be, currMatch.oldval_27ba, currMatch.context_27bb, newUnaryExprs_27c4);
	}
}

void StartAssignment_2756::outputAppender( const CyberComposition::Simulink::TriggerPort& triggerPort_27c5, const SFC::ArgDeclBase& argDeclBase_27c7, const SFC::LocalVar& localVar_27c9, const SFC::LocalVar& oldval_27cb, const SFC::Arg& context_27cd, const SFC::UnaryExprs& unaryExprs_27cf)
{
	_triggerPort_276b->push_back( triggerPort_27c5);
	_argDeclBase_276c->push_back( argDeclBase_27c7);
	_localVar_276d->push_back( localVar_27c9);
	_oldval_276e->push_back( oldval_27cb);
	_context_276f->push_back( context_27cd);
	_unaryExprs_2770->push_back( unaryExprs_27cf);
}

void SaveState_2813::operator()( const Packets_t& systems_2814, const Packets_t& triggers_2816, const Packets_t& argdecls_2818, const Packets_t& dts_281a, const Packets_t& oldvals_281c, const Packets_t& contexts_281e, const Packets_t& functions_2820, Packets_t& systems_2822, Packets_t& triggers_2823, Packets_t& dts_2824, Packets_t& oldvals_2825, Packets_t& functions_2826)
{
#ifdef PRINT_INFO
	printLog( "SaveState_2813" );
#endif
	_system_2827= &systems_2822;
	_trigger_2828= &triggers_2823;
	_dt_2829= &dts_2824;
	_oldval_282a= &oldvals_2825;
	_function_282b= &functions_2826;
	_system_2827->insert( _system_2827->end(), systems_2814.begin(), systems_2814.end());
	_trigger_2828->insert( _trigger_2828->end(), triggers_2816.begin(), triggers_2816.end());
	_dt_2829->insert( _dt_2829->end(), dts_281a.begin(), dts_281a.end());
	_oldval_282a->insert( _oldval_282a->end(), oldvals_281c.begin(), oldvals_281c.end());
	_function_282b->insert( _function_282b->end(), functions_2820.begin(), functions_2820.end());
	if( ( !argdecls_2818.empty())&& ( !dts_281a.empty())&& ( !oldvals_281c.empty())&& ( !contexts_281e.empty())&& ( !functions_2820.empty()))
		callSaveMatrixState_28f3( argdecls_2818, dts_281a, oldvals_281c, contexts_281e, functions_2820);
}

void SaveState_2813::callSaveMatrixState_28f3( const Packets_t& argdecls_288d, const Packets_t& dts_288f, const Packets_t& oldvals_2891, const Packets_t& contexts_2893, const Packets_t& functions_2895)
{
	Packets_t argdecls_2897;
	Packets_t dts_2898;
	Packets_t oldvals_2899;
	Packets_t contexts_289a;
	Packets_t functions_289b;
	SaveMatrixState_288c saveMatrixState_288c;
	saveMatrixState_288c( argdecls_288d, dts_288f, oldvals_2891, contexts_2893, functions_2895, argdecls_2897, dts_2898, oldvals_2899, contexts_289a, functions_289b);
	if( ( !argdecls_2897.empty())&& ( !dts_2898.empty())&& ( !oldvals_2899.empty())&& ( !contexts_289a.empty())&& ( !functions_289b.empty()))
		callSaveStructState_28f9( argdecls_2897, dts_2898, oldvals_2899, contexts_289a, functions_289b);
}

void SaveState_2813::callSaveStructState_28f9( const Packets_t& argdecls_282d, const Packets_t& dts_282f, const Packets_t& oldvals_2831, const Packets_t& contexts_2833, const Packets_t& functions_2835)
{
	SaveStructState_282c saveStructState_282c;
	saveStructState_282c( argdecls_282d, dts_282f, oldvals_2831, contexts_2833, functions_2835);
}

void SaveStructState_282c::operator()( const Packets_t& argdecls_282d, const Packets_t& dts_282f, const Packets_t& oldvals_2831, const Packets_t& contexts_2833, const Packets_t& functions_2835)
{
#ifdef PRINT_INFO
	printLog( "SaveStructState_282c" );
#endif
	if( ( !argdecls_282d.empty())&& ( !dts_282f.empty())&& ( !oldvals_2831.empty())&& ( !contexts_2833.empty())&& ( !functions_2835.empty()))
		callSaveStructState_2886( argdecls_282d, dts_282f, oldvals_2831, contexts_2833, functions_2835);
}

void SaveStructState_282c::callSaveStructState_2886( const Packets_t& argDeclBases_2838, const Packets_t& structs_283a, const Packets_t& localVars_283c, const Packets_t& contexts_283e, const Packets_t& functions_2840)
{
	SaveStructState_2837 saveStructState_2837;
	saveStructState_2837( argDeclBases_2838, structs_283a, localVars_283c, contexts_283e, functions_2840);
}

void SaveStructState_2837::operator()( const Packets_t& argDeclBases_2838, const Packets_t& structs_283a, const Packets_t& localVars_283c, const Packets_t& contexts_283e, const Packets_t& functions_2840)
{
#ifdef PRINT_INFO
	printLog( "SaveStructState_2837" );
#endif
	RTTGenerator::Instance()->generateRule(2517, "SaveStructState");
	processInputPackets( argDeclBases_2838, structs_283a, localVars_283c, contexts_283e, functions_2840);
}

bool SaveStructState_2837::isInputUnique( const Udm::Object& argDeclBase_2846, const Udm::Object& struct_284f, const Udm::Object& localVar_2858, const Udm::Object& context_2861, const Udm::Object& function_286a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_2848= _argDeclBase_2842.begin(), itStruct_2851= _struct_284b.begin(), itLocalVar_285a= _localVar_2854.begin(), itContext_2863= _context_285d.begin(), itFunction_286c= _function_2866.begin(); itArgDeclBase_2848!= _argDeclBase_2842.end(), itStruct_2851!= _struct_284b.end(), itLocalVar_285a!= _localVar_2854.end(), itContext_2863!= _context_285d.end(), itFunction_286c!= _function_2866.end(); ++itArgDeclBase_2848, ++itStruct_2851, ++itLocalVar_285a, ++itContext_2863, ++itFunction_286c)
	{
		if( ( *itArgDeclBase_2848== argDeclBase_2846)&& ( *itStruct_2851== struct_284f)&& ( *itLocalVar_285a== localVar_2858)&& ( *itContext_2863== context_2861)&& ( *itFunction_286c== function_286a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_2842.push_back( argDeclBase_2846);
		_struct_284b.push_back( struct_284f);
		_localVar_2854.push_back( localVar_2858);
		_context_285d.push_back( context_2861);
		_function_2866.push_back( function_286a);
	}
	return isUnique;
}

bool SaveStructState_2837::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void SaveStructState_2837::processInputPackets( const Packets_t& argDeclBases_2838, const Packets_t& structs_283a, const Packets_t& localVars_283c, const Packets_t& contexts_283e, const Packets_t& functions_2840)
{
	for( Packets_t::const_iterator itArgDeclBase_2843= argDeclBases_2838.begin(), itStruct_284c= structs_283a.begin(), itLocalVar_2855= localVars_283c.begin(), itContext_285e= contexts_283e.begin(), itFunction_2867= functions_2840.begin(); itArgDeclBase_2843!= argDeclBases_2838.end(), itStruct_284c!= structs_283a.end(), itLocalVar_2855!= localVars_283c.end(), itContext_285e!= contexts_283e.end(), itFunction_2867!= functions_2840.end(); ++itArgDeclBase_2843, ++itStruct_284c, ++itLocalVar_2855, ++itContext_285e, ++itFunction_2867)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_2843, *itStruct_284c, *itLocalVar_2855, *itContext_285e, *itFunction_2867);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_2843, *itStruct_284c, *itLocalVar_2855, *itContext_285e, *itFunction_2867);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool SaveStructState_2837::patternMatcher( const Udm::Object& argDeclBase_2844, const Udm::Object& struct_284d, const Udm::Object& localVar_2856, const Udm::Object& context_285f, const Udm::Object& function_2868)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_2844.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_2849= SFC::ArgDeclBase::Cast( argDeclBase_2844);
		if( false== Uml::IsDerivedFrom( struct_284d.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_2852= SFC::Struct::Cast( struct_284d);
		if( false== Uml::IsDerivedFrom( localVar_2856.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_285b= SFC::LocalVar::Cast( localVar_2856);
		if( false== Uml::IsDerivedFrom( context_285f.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_2864= SFC::Arg::Cast( context_285f);
		if( false== Uml::IsDerivedFrom( function_2868.type(), SFC::Function::meta))
			continue;
		SFC::Function function_286d= SFC::Function::Cast( function_2868);
		set< SFC::LocalVar> members_286f= struct_2852.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itMember_2870= members_286f.begin(); itMember_2870!= members_286f.end(); ++itMember_2870)
		{
			SFC::LocalVar currMember_2871= *itMember_2870;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2875;
			if( !isValidBound(boundObjs_2875, argDeclBase_2849, true))
				continue;
			currMatch.argDeclBase_2876= argDeclBase_2849;
			if( !isValidBound(boundObjs_2875, struct_2852, true))
				continue;
			currMatch.struct_2877= struct_2852;
			if( !isValidBound(boundObjs_2875, localVar_285b, true))
				continue;
			currMatch.localVar_2878= localVar_285b;
			if( !isValidBound(boundObjs_2875, context_2864, true))
				continue;
			currMatch.context_2879= context_2864;
			if( !isValidBound(boundObjs_2875, function_286d, true))
				continue;
			currMatch.function_287a= function_286d;
			if( !isValidBound(boundObjs_2875, currMember_2871, false))
				continue;
			currMatch.member_287b= currMember_2871;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void SaveStructState_2837::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newUserCode_287c= SFC::UserCode::Create( currMatch.function_287a);
		SFC::BinaryExprs newAssign_287d= SFC::BinaryExprs::Create( newUserCode_287c, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newArgDeclDot2_287e= SFC::BinaryExprs::Create( newAssign_287d, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef2_287f= SFC::ArgDeclRef::Create( newArgDeclDot2_287e, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newMemberRef2_2880= SFC::ArgDeclRef::Create( newArgDeclDot2_287e, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newMemberDot_2881= SFC::BinaryExprs::Create( newAssign_287d, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newContextDot_2882= SFC::BinaryExprs::Create( newMemberDot_2881, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newMemberRef3_2883= SFC::ArgDeclRef::Create( newMemberDot_2881, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef4_2884= SFC::ArgDeclRef::Create( newContextDot_2882, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef3_2885= SFC::ArgDeclRef::Create( newContextDot_2882, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_2876;
		SFC::BinaryExprs& ArgDeclDot2= newArgDeclDot2_287e;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_287f;
		SFC::ArgDeclRef& ArgDeclRef3= newArgDeclRef3_2885;
		SFC::ArgDeclRef& ArgDeclRef4= newArgDeclRef4_2884;
		SFC::BinaryExprs& Assign= newAssign_287d;
		SFC::Arg& Context= currMatch.context_2879;
		SFC::BinaryExprs& ContextDot= newContextDot_2882;
		SFC::Function& Function= currMatch.function_287a;
		SFC::LocalVar& LocalVar= currMatch.localVar_2878;
		SFC::LocalVar& Member= currMatch.member_287b;
		SFC::BinaryExprs& MemberDot= newMemberDot_2881;
		SFC::ArgDeclRef& MemberRef2= newMemberRef2_2880;
		SFC::ArgDeclRef& MemberRef3= newMemberRef3_2883;
		SFC::Struct& Struct= currMatch.struct_2877;
		SFC::UserCode& UserCode= newUserCode_287c;
		{
ArgDeclDot2.op() = ".";
};
		{
MemberDot.op() = ".";
};
		{
Assign.op() = "=";
};
		{
__int64 statementCount = Function.statementCount();
UserCode.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		{
ContextDot.op() = ".";
};
		newMemberRef2_2880.argdecl()= currMatch.member_287b;
		newMemberRef3_2883.argdecl()= currMatch.member_287b;
		newArgDeclRef3_2885.argdecl()= currMatch.localVar_2878;
		newArgDeclRef2_287f.argdecl()= currMatch.argDeclBase_2876;
		newArgDeclRef4_2884.argdecl()= currMatch.context_2879;
	}
}

void SaveMatrixState_288c::operator()( const Packets_t& argdecls_288d, const Packets_t& dts_288f, const Packets_t& oldvals_2891, const Packets_t& contexts_2893, const Packets_t& functions_2895, Packets_t& argdecls_2897, Packets_t& dts_2898, Packets_t& oldvals_2899, Packets_t& contexts_289a, Packets_t& functions_289b)
{
#ifdef PRINT_INFO
	printLog( "SaveMatrixState_288c" );
#endif
	_argdecl_289c= &argdecls_2897;
	_dt_289d= &dts_2898;
	_oldval_289e= &oldvals_2899;
	_context_289f= &contexts_289a;
	_function_28a0= &functions_289b;
	_argdecl_289c->insert( _argdecl_289c->end(), argdecls_288d.begin(), argdecls_288d.end());
	_dt_289d->insert( _dt_289d->end(), dts_288f.begin(), dts_288f.end());
	_oldval_289e->insert( _oldval_289e->end(), oldvals_2891.begin(), oldvals_2891.end());
	_context_289f->insert( _context_289f->end(), contexts_2893.begin(), contexts_2893.end());
	_function_28a0->insert( _function_28a0->end(), functions_2895.begin(), functions_2895.end());
	if( ( !argdecls_288d.empty())&& ( !dts_288f.empty())&& ( !oldvals_2891.empty())&& ( !contexts_2893.empty())&& ( !functions_2895.empty()))
		callSaveMatrixState_28ed( argdecls_288d, dts_288f, oldvals_2891, contexts_2893, functions_2895);
}

void SaveMatrixState_288c::callSaveMatrixState_28ed( const Packets_t& argDeclBases_28a2, const Packets_t& dTs_28a4, const Packets_t& localVars_28a6, const Packets_t& args_28a8, const Packets_t& functions_28aa)
{
	SaveMatrixState_28a1 saveMatrixState_28a1;
	saveMatrixState_28a1( argDeclBases_28a2, dTs_28a4, localVars_28a6, args_28a8, functions_28aa);
}

void SaveMatrixState_28a1::operator()( const Packets_t& argDeclBases_28a2, const Packets_t& dTs_28a4, const Packets_t& localVars_28a6, const Packets_t& args_28a8, const Packets_t& functions_28aa)
{
#ifdef PRINT_INFO
	printLog( "SaveMatrixState_28a1" );
#endif
	RTTGenerator::Instance()->generateRule(2566, "SaveMatrixState");
	processInputPackets( argDeclBases_28a2, dTs_28a4, localVars_28a6, args_28a8, functions_28aa);
}

bool SaveMatrixState_28a1::isInputUnique( const Udm::Object& argDeclBase_28b0, const Udm::Object& dT_28b9, const Udm::Object& localVar_28c2, const Udm::Object& arg_28cb, const Udm::Object& function_28d4)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_28b2= _argDeclBase_28ac.begin(), itDT_28bb= _dT_28b5.begin(), itLocalVar_28c4= _localVar_28be.begin(), itArg_28cd= _arg_28c7.begin(), itFunction_28d6= _function_28d0.begin(); itArgDeclBase_28b2!= _argDeclBase_28ac.end(), itDT_28bb!= _dT_28b5.end(), itLocalVar_28c4!= _localVar_28be.end(), itArg_28cd!= _arg_28c7.end(), itFunction_28d6!= _function_28d0.end(); ++itArgDeclBase_28b2, ++itDT_28bb, ++itLocalVar_28c4, ++itArg_28cd, ++itFunction_28d6)
	{
		if( ( *itArgDeclBase_28b2== argDeclBase_28b0)&& ( *itDT_28bb== dT_28b9)&& ( *itLocalVar_28c4== localVar_28c2)&& ( *itArg_28cd== arg_28cb)&& ( *itFunction_28d6== function_28d4))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_28ac.push_back( argDeclBase_28b0);
		_dT_28b5.push_back( dT_28b9);
		_localVar_28be.push_back( localVar_28c2);
		_arg_28c7.push_back( arg_28cb);
		_function_28d0.push_back( function_28d4);
	}
	return isUnique;
}

bool SaveMatrixState_28a1::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool SaveMatrixState_28a1::isGuardTrue( SFC::Arg& Arg, SFC::ArgDeclBase& ArgDeclBase, SFC::DT& DT, SFC::Function& Function, SFC::LocalVar& LocalVar)
{
	bool Gz_guard= false;
	Gz_guard = DT.type() != SFC::Struct::meta;;
	return Gz_guard;
}

void SaveMatrixState_28a1::processInputPackets( const Packets_t& argDeclBases_28a2, const Packets_t& dTs_28a4, const Packets_t& localVars_28a6, const Packets_t& args_28a8, const Packets_t& functions_28aa)
{
	for( Packets_t::const_iterator itArgDeclBase_28ad= argDeclBases_28a2.begin(), itDT_28b6= dTs_28a4.begin(), itLocalVar_28bf= localVars_28a6.begin(), itArg_28c8= args_28a8.begin(), itFunction_28d1= functions_28aa.begin(); itArgDeclBase_28ad!= argDeclBases_28a2.end(), itDT_28b6!= dTs_28a4.end(), itLocalVar_28bf!= localVars_28a6.end(), itArg_28c8!= args_28a8.end(), itFunction_28d1!= functions_28aa.end(); ++itArgDeclBase_28ad, ++itDT_28b6, ++itLocalVar_28bf, ++itArg_28c8, ++itFunction_28d1)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_28ad, *itDT_28b6, *itLocalVar_28bf, *itArg_28c8, *itFunction_28d1);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_28ad, *itDT_28b6, *itLocalVar_28bf, *itArg_28c8, *itFunction_28d1);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool SaveMatrixState_28a1::patternMatcher( const Udm::Object& argDeclBase_28ae, const Udm::Object& dT_28b7, const Udm::Object& localVar_28c0, const Udm::Object& arg_28c9, const Udm::Object& function_28d2)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_28ae.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_28b3= SFC::ArgDeclBase::Cast( argDeclBase_28ae);
		if( false== Uml::IsDerivedFrom( dT_28b7.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_28bc= SFC::DT::Cast( dT_28b7);
		if( false== Uml::IsDerivedFrom( localVar_28c0.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_28c5= SFC::LocalVar::Cast( localVar_28c0);
		if( false== Uml::IsDerivedFrom( arg_28c9.type(), SFC::Arg::meta))
			continue;
		SFC::Arg arg_28ce= SFC::Arg::Cast( arg_28c9);
		if( false== Uml::IsDerivedFrom( function_28d2.type(), SFC::Function::meta))
			continue;
		SFC::Function function_28d7= SFC::Function::Cast( function_28d2);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_28dc;
		if( !isValidBound(boundObjs_28dc, argDeclBase_28b3, true))
			continue;
		currMatch.argDeclBase_28dd= argDeclBase_28b3;
		if( !isValidBound(boundObjs_28dc, dT_28bc, true))
			continue;
		currMatch.dT_28de= dT_28bc;
		if( !isValidBound(boundObjs_28dc, localVar_28c5, true))
			continue;
		currMatch.localVar_28df= localVar_28c5;
		if( !isValidBound(boundObjs_28dc, arg_28ce, true))
			continue;
		currMatch.arg_28e0= arg_28ce;
		if( !isValidBound(boundObjs_28dc, function_28d7, true))
			continue;
		currMatch.function_28e1= function_28d7;
		bool Gz_guard= isGuardTrue( currMatch.arg_28e0, currMatch.argDeclBase_28dd, currMatch.dT_28de, currMatch.function_28e1, currMatch.localVar_28df);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void SaveMatrixState_28a1::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newUserCode_28e7= SFC::UserCode::Create( currMatch.function_28e1, SFC::Function::meta_stmnt);
		SFC::BinaryExprs newAssign_28e8= SFC::BinaryExprs::Create( newUserCode_28e7, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newArgDeclRef2_28e9= SFC::ArgDeclRef::Create( newAssign_28e8, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newDot_28ea= SFC::BinaryExprs::Create( newAssign_28e8, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef4_28eb= SFC::ArgDeclRef::Create( newDot_28ea, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef3_28ec= SFC::ArgDeclRef::Create( newDot_28ea, SFC::BinaryExprs::meta_rightexpr);
		SFC::Arg& Arg= currMatch.arg_28e0;
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_28dd;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_28e9;
		SFC::ArgDeclRef& ArgDeclRef3= newArgDeclRef3_28ec;
		SFC::ArgDeclRef& ArgDeclRef4= newArgDeclRef4_28eb;
		SFC::BinaryExprs& Assign= newAssign_28e8;
		SFC::DT& DT= currMatch.dT_28de;
		SFC::BinaryExprs& Dot= newDot_28ea;
		SFC::Function& Function= currMatch.function_28e1;
		SFC::LocalVar& LocalVar= currMatch.localVar_28df;
		SFC::UserCode& UserCode= newUserCode_28e7;
		{
Dot.op() = ".";
};
		{
Assign.op() = "=";
};
		{
__int64 statementCount = Function.statementCount();
UserCode.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		newArgDeclRef2_28e9.argdecl()= currMatch.argDeclBase_28dd;
		newArgDeclRef4_28eb.argdecl()= currMatch.arg_28e0;
		newArgDeclRef3_28ec.argdecl()= currMatch.localVar_28df;
	}
}

void AddStateVar_28ff::operator()( const Packets_t& subsystems_2900, const Packets_t& triggerPorts_2903, const Packets_t& argDeclBases_2906, const Packets_t& dTs_290a, const Packets_t& functions_290e, Packets_t& subsystems_2902, Packets_t& triggerPorts_2905, Packets_t& argDeclBases_2908, Packets_t& localVars_2909, Packets_t& dTs_290c, Packets_t& args_290d, Packets_t& functions_2910)
{
#ifdef PRINT_INFO
	printLog( "AddStateVar_28ff" );
#endif
	RTTGenerator::Instance()->generateRule(2590, "AddStateVar");
	_subsystem_2911= &subsystems_2902;
	_triggerPort_2912= &triggerPorts_2905;
	_argDeclBase_2913= &argDeclBases_2908;
	_localVar_2914= &localVars_2909;
	_dT_2915= &dTs_290c;
	_arg_2916= &args_290d;
	_function_2917= &functions_2910;
	processInputPackets( subsystems_2900, triggerPorts_2903, argDeclBases_2906, dTs_290a, functions_290e);
}

bool AddStateVar_28ff::isInputUnique( const Udm::Object& subsystem_291c, const Udm::Object& triggerPort_2925, const Udm::Object& argDeclBase_292e, const Udm::Object& dT_2937, const Udm::Object& function_2940)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_291e= _subsystem_2918.begin(), itTriggerPort_2927= _triggerPort_2921.begin(), itArgDeclBase_2930= _argDeclBase_292a.begin(), itDT_2939= _dT_2933.begin(), itFunction_2942= _function_293c.begin(); itSubsystem_291e!= _subsystem_2918.end(), itTriggerPort_2927!= _triggerPort_2921.end(), itArgDeclBase_2930!= _argDeclBase_292a.end(), itDT_2939!= _dT_2933.end(), itFunction_2942!= _function_293c.end(); ++itSubsystem_291e, ++itTriggerPort_2927, ++itArgDeclBase_2930, ++itDT_2939, ++itFunction_2942)
	{
		if( ( *itSubsystem_291e== subsystem_291c)&& ( *itTriggerPort_2927== triggerPort_2925)&& ( *itArgDeclBase_2930== argDeclBase_292e)&& ( *itDT_2939== dT_2937)&& ( *itFunction_2942== function_2940))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_2918.push_back( subsystem_291c);
		_triggerPort_2921.push_back( triggerPort_2925);
		_argDeclBase_292a.push_back( argDeclBase_292e);
		_dT_2933.push_back( dT_2937);
		_function_293c.push_back( function_2940);
	}
	return isUnique;
}

bool AddStateVar_28ff::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void AddStateVar_28ff::processInputPackets( const Packets_t& subsystems_2900, const Packets_t& triggerPorts_2903, const Packets_t& argDeclBases_2906, const Packets_t& dTs_290a, const Packets_t& functions_290e)
{
	for( Packets_t::const_iterator itSubsystem_2919= subsystems_2900.begin(), itTriggerPort_2922= triggerPorts_2903.begin(), itArgDeclBase_292b= argDeclBases_2906.begin(), itDT_2934= dTs_290a.begin(), itFunction_293d= functions_290e.begin(); itSubsystem_2919!= subsystems_2900.end(), itTriggerPort_2922!= triggerPorts_2903.end(), itArgDeclBase_292b!= argDeclBases_2906.end(), itDT_2934!= dTs_290a.end(), itFunction_293d!= functions_290e.end(); ++itSubsystem_2919, ++itTriggerPort_2922, ++itArgDeclBase_292b, ++itDT_2934, ++itFunction_293d)
	{
		bool isUnique= isInputUnique( *itSubsystem_2919, *itTriggerPort_2922, *itArgDeclBase_292b, *itDT_2934, *itFunction_293d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_2919, *itTriggerPort_2922, *itArgDeclBase_292b, *itDT_2934, *itFunction_293d);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AddStateVar_28ff::patternMatcher( const Udm::Object& subsystem_291a, const Udm::Object& triggerPort_2923, const Udm::Object& argDeclBase_292c, const Udm::Object& dT_2935, const Udm::Object& function_293e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_291a.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_291f= CyberComposition::Simulink::Subsystem::Cast( subsystem_291a);
		if( false== Uml::IsDerivedFrom( triggerPort_2923.type(), CyberComposition::Simulink::TriggerPort::meta))
			continue;
		CyberComposition::Simulink::TriggerPort triggerPort_2928= CyberComposition::Simulink::TriggerPort::Cast( triggerPort_2923);
		if( false== Uml::IsDerivedFrom( argDeclBase_292c.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_2931= SFC::ArgDeclBase::Cast( argDeclBase_292c);
		if( false== Uml::IsDerivedFrom( dT_2935.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_293a= SFC::DT::Cast( dT_2935);
		if( false== Uml::IsDerivedFrom( function_293e.type(), SFC::Function::meta))
			continue;
		SFC::Function function_2943= SFC::Function::Cast( function_293e);
		Udm::Object functionParent_2945= function_2943.container();
		if( false== Uml::IsDerivedFrom( functionParent_2945.type(), SFC::Class::meta))
			continue;
		SFC::Class classFunction_2946= SFC::Class::Cast( functionParent_2945);
		set< SFC::Struct> structs_2947= classFunction_2946.Struct_kind_children();
		for( set< SFC::Struct>::const_iterator itStruct_2948= structs_2947.begin(); itStruct_2948!= structs_2947.end(); ++itStruct_2948)
		{
			SFC::Struct currStruct_2949= *itStruct_2948;
			set< SFC::Arg> args_294a= function_2943.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itArg_294b= args_294a.begin(); itArg_294b!= args_294a.end(); ++itArg_294b)
			{
				SFC::Arg currArg_294c= *itArg_294b;
				SFC::DT struct_294d= currArg_294c.dt();
				if(!struct_294d || false== Uml::IsDerivedFrom( struct_294d.type(), SFC::Struct::meta))
					continue;
				SFC::Struct struct_294e= SFC::Struct::Cast( struct_294d);
				if( !struct_294e)
					continue;
				if( currStruct_2949!= struct_294e)
					continue;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_2952;
				if( !isValidBound(boundObjs_2952, subsystem_291f, true))
					continue;
				currMatch.subsystem_2953= subsystem_291f;
				if( !isValidBound(boundObjs_2952, triggerPort_2928, true))
					continue;
				currMatch.triggerPort_2954= triggerPort_2928;
				if( !isValidBound(boundObjs_2952, argDeclBase_2931, true))
					continue;
				currMatch.argDeclBase_2955= argDeclBase_2931;
				if( !isValidBound(boundObjs_2952, dT_293a, true))
					continue;
				currMatch.dT_2956= dT_293a;
				if( !isValidBound(boundObjs_2952, function_2943, true))
					continue;
				currMatch.function_2957= function_2943;
				if( !isValidBound(boundObjs_2952, currArg_294c, false))
					continue;
				currMatch.arg_2958= currArg_294c;
				if( !isValidBound(boundObjs_2952, currStruct_2949, false))
					continue;
				currMatch.struct_2959= currStruct_2949;
				if( !isValidBound(boundObjs_2952, classFunction_2946, false))
					continue;
				currMatch.class_295a= classFunction_2946;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void AddStateVar_28ff::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newLocalVar_295b= SFC::LocalVar::Create( currMatch.struct_2959, SFC::Struct::meta_memb);
		SFC::Arg& Arg= currMatch.arg_2958;
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_2955;
		SFC::Class& Class= currMatch.class_295a;
		SFC::DT& DT= currMatch.dT_2956;
		SFC::Function& Function= currMatch.function_2957;
		SFC::LocalVar& LocalVar= newLocalVar_295b;
		SFC::Struct& Struct= currMatch.struct_2959;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_2953;
		CyberComposition::Simulink::TriggerPort& TriggerPort= currMatch.triggerPort_2954;
		{
__int64 memberCount = Struct.memberCount();
LocalVar.statementIndex() = memberCount++;
Struct.memberCount() = memberCount;

LocalVar.name() = "triggerData" + boost::lexical_cast< std::string >( LocalVar.uniqueId() );
};
		newLocalVar_295b.dt()= currMatch.dT_2956;
		newLocalVar_295b.trig()+= currMatch.triggerPort_2954;
		outputAppender( currMatch.subsystem_2953, currMatch.triggerPort_2954, currMatch.argDeclBase_2955, newLocalVar_295b, currMatch.dT_2956, currMatch.arg_2958, currMatch.function_2957);
	}
}

void AddStateVar_28ff::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_295c, const CyberComposition::Simulink::TriggerPort& triggerPort_295e, const SFC::ArgDeclBase& argDeclBase_2960, const SFC::LocalVar& localVar_2962, const SFC::DT& dT_2964, const SFC::Arg& arg_2966, const SFC::Function& function_2968)
{
	_subsystem_2911->push_back( subsystem_295c);
	_triggerPort_2912->push_back( triggerPort_295e);
	_argDeclBase_2913->push_back( argDeclBase_2960);
	_localVar_2914->push_back( localVar_2962);
	_dT_2915->push_back( dT_2964);
	_arg_2916->push_back( arg_2966);
	_function_2917->push_back( function_2968);
}

void MakeCondition_296a::operator()( const Packets_t& systems_296b, const Packets_t& triggers_296d, const Packets_t& dts_296f, const Packets_t& oldvals_2971, const Packets_t& functions_2973, Packets_t& systems_2975, Packets_t& childSubsystems_2976, Packets_t& conditionals_2977)
{
#ifdef PRINT_INFO
	printLog( "MakeCondition_296a" );
#endif
	_system_2978= &systems_2975;
	_childSubsystem_2979= &childSubsystems_2976;
	_conditional_297a= &conditionals_2977;
	if( ( !systems_296b.empty())&& ( !triggers_296d.empty())&& ( !dts_296f.empty())&& ( !oldvals_2971.empty())&& ( !functions_2973.empty()))
		callCreateConditional_2c71( systems_296b, triggers_296d, dts_296f, oldvals_2971, functions_2973);
}

void MakeCondition_296a::callCreateConditional_2c71( const Packets_t& subsystems_2c12, const Packets_t& triggerPorts_2c15, const Packets_t& dTs_2c18, const Packets_t& localVars_2c1b, const Packets_t& functions_2c1f)
{
	Packets_t subsystems_2c14;
	Packets_t charts_2c17;
	Packets_t dTs_2c1a;
	Packets_t triggerVars_2c1d;
	Packets_t userCodes_2c1e;
	Packets_t conditionalBlocks_2c21;
	CreateConditional_2c11 createConditional_2c11;
	createConditional_2c11( subsystems_2c12, triggerPorts_2c15, dTs_2c18, localVars_2c1b, functions_2c1f, subsystems_2c14, charts_2c17, dTs_2c1a, triggerVars_2c1d, userCodes_2c1e, conditionalBlocks_2c21);
	_system_2978->insert( _system_2978->end(), subsystems_2c14.begin(), subsystems_2c14.end());
	_childSubsystem_2979->insert( _childSubsystem_2979->end(), charts_2c17.begin(), charts_2c17.end());
	_conditional_297a->insert( _conditional_297a->end(), conditionalBlocks_2c21.begin(), conditionalBlocks_2c21.end());
	if( ( !dTs_2c1a.empty())&& ( !triggerVars_2c1d.empty())&& ( !userCodes_2c1e.empty()))
		callSetMatrixCondition_2c77( dTs_2c1a, triggerVars_2c1d, userCodes_2c1e);
}

void MakeCondition_296a::callSetMatrixCondition_2c77( const Packets_t& dts_2bd4, const Packets_t& triggervars_2bd6, const Packets_t& conditions_2bd8)
{
	Packets_t dts_2bda;
	Packets_t triggervars_2bdb;
	Packets_t conditions_2bdc;
	SetMatrixCondition_2bd3 setMatrixCondition_2bd3;
	setMatrixCondition_2bd3( dts_2bd4, triggervars_2bd6, conditions_2bd8, dts_2bda, triggervars_2bdb, conditions_2bdc);
	if( ( !dts_2bda.empty())&& ( !triggervars_2bdb.empty())&& ( !conditions_2bdc.empty()))
		callSetStructCondition_2c7b( dts_2bda, triggervars_2bdb, conditions_2bdc);
}

void MakeCondition_296a::callSetStructCondition_2c7b( const Packets_t& dts_297c, const Packets_t& oldvals_297e, const Packets_t& conditions_2980)
{
	SetStructCondition_297b setStructCondition_297b;
	setStructCondition_297b( dts_297c, oldvals_297e, conditions_2980);
}

void SetStructCondition_297b::operator()( const Packets_t& dts_297c, const Packets_t& oldvals_297e, const Packets_t& conditions_2980)
{
#ifdef PRINT_INFO
	printLog( "SetStructCondition_297b" );
#endif
	if( ( !dts_297c.empty())&& ( !oldvals_297e.empty())&& ( !conditions_2980.empty()))
		callStartCondition_2bc6( dts_297c, oldvals_297e, conditions_2980);
}

void SetStructCondition_297b::callStartCondition_2bc6( const Packets_t& structs_2983, const Packets_t& triggerVars_2986, const Packets_t& userCodes_2989)
{
	Packets_t structs_2985;
	Packets_t triggerVars_2988;
	Packets_t unaryExprss_298b;
	StartCondition_2982 startCondition_2982;
	startCondition_2982( structs_2983, triggerVars_2986, userCodes_2989, structs_2985, triggerVars_2988, unaryExprss_298b);
	if( ( !structs_2985.empty())&& ( !triggerVars_2988.empty())&& ( !unaryExprss_298b.empty()))
		callgetStructMembers_2bca( structs_2985, triggerVars_2988, unaryExprss_298b);
}

void SetStructCondition_297b::callgetStructMembers_2bca( const Packets_t& structs_2b8a, const Packets_t& triggerVars_2b8e, const Packets_t& unaryExprss_2b91)
{
	Packets_t structs_2b8c;
	Packets_t members_2b8d;
	Packets_t triggerVars_2b90;
	Packets_t unaryExprss_2b93;
	GetStructMembers_2b89 getStructMembers_2b89;
	getStructMembers_2b89( structs_2b8a, triggerVars_2b8e, unaryExprss_2b91, structs_2b8c, members_2b8d, triggerVars_2b90, unaryExprss_2b93);
	if( ( !structs_2b8c.empty())&& ( !members_2b8d.empty())&& ( !triggerVars_2b90.empty())&& ( !unaryExprss_2b93.empty()))
		callPlaceMember_2bce( structs_2b8c, members_2b8d, triggerVars_2b90, unaryExprss_2b93);
}

void SetStructCondition_297b::callPlaceMember_2bce( const Packets_t& structs_29b9, const Packets_t& members_29bb, const Packets_t& trigvars_29bd, const Packets_t& condexprs_29bf)
{
	PlaceMember_29b8 placeMember_29b8;
	placeMember_29b8( structs_29b9, members_29bb, trigvars_29bd, condexprs_29bf);
}

void StartCondition_2982::operator()( const Packets_t& structs_2983, const Packets_t& triggerVars_2986, const Packets_t& userCodes_2989, Packets_t& structs_2985, Packets_t& triggerVars_2988, Packets_t& unaryExprss_298b)
{
#ifdef PRINT_INFO
	printLog( "StartCondition_2982" );
#endif
	RTTGenerator::Instance()->generateRule(2621, "StartCondition");
	_struct_298c= &structs_2985;
	_triggerVar_298d= &triggerVars_2988;
	_unaryExprs_298e= &unaryExprss_298b;
	processInputPackets( structs_2983, triggerVars_2986, userCodes_2989);
}

bool StartCondition_2982::isInputUnique( const Udm::Object& struct_2993, const Udm::Object& triggerVar_299c, const Udm::Object& userCode_29a5)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itStruct_2995= _struct_298f.begin(), itTriggerVar_299e= _triggerVar_2998.begin(), itUserCode_29a7= _userCode_29a1.begin(); itStruct_2995!= _struct_298f.end(), itTriggerVar_299e!= _triggerVar_2998.end(), itUserCode_29a7!= _userCode_29a1.end(); ++itStruct_2995, ++itTriggerVar_299e, ++itUserCode_29a7)
	{
		if( ( *itStruct_2995== struct_2993)&& ( *itTriggerVar_299e== triggerVar_299c)&& ( *itUserCode_29a7== userCode_29a5))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_298f.push_back( struct_2993);
		_triggerVar_2998.push_back( triggerVar_299c);
		_userCode_29a1.push_back( userCode_29a5);
	}
	return isUnique;
}

bool StartCondition_2982::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void StartCondition_2982::processInputPackets( const Packets_t& structs_2983, const Packets_t& triggerVars_2986, const Packets_t& userCodes_2989)
{
	for( Packets_t::const_iterator itStruct_2990= structs_2983.begin(), itTriggerVar_2999= triggerVars_2986.begin(), itUserCode_29a2= userCodes_2989.begin(); itStruct_2990!= structs_2983.end(), itTriggerVar_2999!= triggerVars_2986.end(), itUserCode_29a2!= userCodes_2989.end(); ++itStruct_2990, ++itTriggerVar_2999, ++itUserCode_29a2)
	{
		bool isUnique= isInputUnique( *itStruct_2990, *itTriggerVar_2999, *itUserCode_29a2);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itStruct_2990, *itTriggerVar_2999, *itUserCode_29a2);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool StartCondition_2982::patternMatcher( const Udm::Object& struct_2991, const Udm::Object& triggerVar_299a, const Udm::Object& userCode_29a3)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( struct_2991.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_2996= SFC::Struct::Cast( struct_2991);
		if( false== Uml::IsDerivedFrom( triggerVar_299a.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_299f= SFC::LocalVar::Cast( triggerVar_299a);
		if( false== Uml::IsDerivedFrom( userCode_29a3.type(), SFC::UserCode::meta))
			continue;
		SFC::UserCode userCode_29a8= SFC::UserCode::Cast( userCode_29a3);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_29ad;
		if( !isValidBound(boundObjs_29ad, struct_2996, true))
			continue;
		currMatch.struct_29ae= struct_2996;
		if( !isValidBound(boundObjs_29ad, triggerVar_299f, true))
			continue;
		currMatch.triggerVar_29af= triggerVar_299f;
		if( !isValidBound(boundObjs_29ad, userCode_29a8, true))
			continue;
		currMatch.userCode_29b0= userCode_29a8;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void StartCondition_2982::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UnaryExprs newUnaryExprs_29b1= SFC::UnaryExprs::Create( currMatch.userCode_29b0, SFC::UserCode::meta_codeexpr);
		SFC::Struct& Struct= currMatch.struct_29ae;
		SFC::LocalVar& TriggerVar= currMatch.triggerVar_29af;
		SFC::UnaryExprs& UnaryExprs= newUnaryExprs_29b1;
		SFC::UserCode& UserCode= currMatch.userCode_29b0;
		{
UnaryExprs.op() = "";
};
		outputAppender( currMatch.struct_29ae, currMatch.triggerVar_29af, newUnaryExprs_29b1);
	}
}

void StartCondition_2982::outputAppender( const SFC::Struct& struct_29b2, const SFC::LocalVar& triggerVar_29b4, const SFC::UnaryExprs& unaryExprs_29b6)
{
	_struct_298c->push_back( struct_29b2);
	_triggerVar_298d->push_back( triggerVar_29b4);
	_unaryExprs_298e->push_back( unaryExprs_29b6);
}

void PlaceMember_29b8::operator()( const Packets_t& structs_29b9, const Packets_t& members_29bb, const Packets_t& trigvars_29bd, const Packets_t& condexprs_29bf)
{
#ifdef PRINT_INFO
	printLog( "PlaceMember_29b8" );
#endif
	for( Packets_t::const_iterator itstruct_29c2= structs_29b9.begin(), itmember_29c9= members_29bb.begin(), ittrigvar_29d0= trigvars_29bd.begin(), itcondexpr_29d7= condexprs_29bf.begin(); itstruct_29c2!= structs_29b9.end(), itmember_29c9!= members_29bb.end(), ittrigvar_29d0!= trigvars_29bd.end(), itcondexpr_29d7!= condexprs_29bf.end(); ++itstruct_29c2, ++itmember_29c9, ++ittrigvar_29d0, ++itcondexpr_29d7)
	{
		bool isUnique= isInputUnique( *itstruct_29c2, *itmember_29c9, *ittrigvar_29d0, *itcondexpr_29d7);
		if( !isUnique)
			continue;
		Packets_t onestruct_29c6( 1, *itstruct_29c2);
		Packets_t onemember_29cd( 1, *itmember_29c9);
		Packets_t onetrigvar_29d4( 1, *ittrigvar_29d0);
		Packets_t onecondexpr_29db( 1, *itcondexpr_29d7);
		executeOne( onestruct_29c6, onemember_29cd, onetrigvar_29d4, onecondexpr_29db);
	}
}

void PlaceMember_29b8::executeOne( const Packets_t& structs_29b9, const Packets_t& members_29bb, const Packets_t& trigvars_29bd, const Packets_t& condexprs_29bf)
{
	if( ( !structs_29b9.empty())&& ( !members_29bb.empty())&& ( !trigvars_29bd.empty())&& ( !condexprs_29bf.empty()))
		callTriggerTest_2b7a( structs_29b9, members_29bb, trigvars_29bd, condexprs_29bf);
}

bool PlaceMember_29b8::isInputUnique( const Udm::Object& struct_29c3, const Udm::Object& member_29ca, const Udm::Object& trigvar_29d1, const Udm::Object& condexpr_29d8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstruct_29c5= _struct_29c1.begin(), itmember_29cc= _member_29c8.begin(), ittrigvar_29d3= _trigvar_29cf.begin(), itcondexpr_29da= _condexpr_29d6.begin(); itstruct_29c5!= _struct_29c1.end(), itmember_29cc!= _member_29c8.end(), ittrigvar_29d3!= _trigvar_29cf.end(), itcondexpr_29da!= _condexpr_29d6.end(); ++itstruct_29c5, ++itmember_29cc, ++ittrigvar_29d3, ++itcondexpr_29da)
	{
		if( ( *itstruct_29c5== struct_29c3)&& ( *itmember_29cc== member_29ca)&& ( *ittrigvar_29d3== trigvar_29d1)&& ( *itcondexpr_29da== condexpr_29d8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_29c1.push_back( struct_29c3);
		_member_29c8.push_back( member_29ca);
		_trigvar_29cf.push_back( trigvar_29d1);
		_condexpr_29d6.push_back( condexpr_29d8);
	}
	return isUnique;
}

void PlaceMember_29b8::callTriggerTest_2b7a( const Packets_t& structs_2a6b, const Packets_t& members_2a6d, const Packets_t& trigvars_2a6f, const Packets_t& condexprs_2a71)
{
	Packets_t structs_2a73;
	Packets_t members_2a74;
	Packets_t trigvars_2a75;
	Packets_t condexprs_2a76;
	Packets_t structs_2a77;
	Packets_t members_2a78;
	Packets_t trigvars_2a79;
	Packets_t condexprs_2a7a;
	TriggerTest_2a6a triggerTest_2a6a;
	triggerTest_2a6a( structs_2a6b, members_2a6d, trigvars_2a6f, condexprs_2a71, structs_2a73, members_2a74, trigvars_2a75, condexprs_2a76, structs_2a77, members_2a78, trigvars_2a79, condexprs_2a7a);
	if( ( !structs_2a77.empty())&& ( !members_2a78.empty())&& ( !trigvars_2a79.empty())&& ( !condexprs_2a7a.empty()))
		callAddTrigger_2b7f( structs_2a77, members_2a78, trigvars_2a79, condexprs_2a7a);
	if( ( !structs_2a73.empty())&& ( !members_2a74.empty())&& ( !trigvars_2a75.empty())&& ( !condexprs_2a76.empty()))
		callTraverseBinary_2b84( structs_2a73, members_2a74, trigvars_2a75, condexprs_2a76);
}

void PlaceMember_29b8::callAddTrigger_2b7f( const Packets_t& structs_29de, const Packets_t& members_29e0, const Packets_t& trigvars_29e2, const Packets_t& condexprs_29e4)
{
	AddTrigger_29dd addTrigger_29dd;
	addTrigger_29dd( structs_29de, members_29e0, trigvars_29e2, condexprs_29e4);
}

void PlaceMember_29b8::callTraverseBinary_2b84( const Packets_t& structs_2b2e, const Packets_t& members_2b31, const Packets_t& triggerVars_2b34, const Packets_t& unaryExprss_2b37)
{
	Packets_t structs_2b30;
	Packets_t members_2b33;
	Packets_t triggerVars_2b36;
	Packets_t unaryExprss_2b39;
	TraverseBinary_2b2d traverseBinary_2b2d;
	traverseBinary_2b2d( structs_2b2e, members_2b31, triggerVars_2b34, unaryExprss_2b37, structs_2b30, members_2b33, triggerVars_2b36, unaryExprss_2b39);
	if( ( !structs_2b30.empty())&& ( !members_2b33.empty())&& ( !triggerVars_2b36.empty())&& ( !unaryExprss_2b39.empty()))
		callTriggerTest_2b7a( structs_2b30, members_2b33, triggerVars_2b36, unaryExprss_2b39);
}

void AddTrigger_29dd::operator()( const Packets_t& structs_29de, const Packets_t& members_29e0, const Packets_t& trigvars_29e2, const Packets_t& condexprs_29e4)
{
#ifdef PRINT_INFO
	printLog( "AddTrigger_29dd" );
#endif
	if( ( !structs_29de.empty())&& ( !members_29e0.empty())&& ( !trigvars_29e2.empty())&& ( !condexprs_29e4.empty()))
		callAddLastTrigger_2a60( structs_29de, members_29e0, trigvars_29e2, condexprs_29e4);
	if( ( !structs_29de.empty())&& ( !members_29e0.empty())&& ( !trigvars_29e2.empty())&& ( !condexprs_29e4.empty()))
		callAddNextTrigger_2a65( structs_29de, members_29e0, trigvars_29e2, condexprs_29e4);
}

void AddTrigger_29dd::callAddLastTrigger_2a60( const Packets_t& structs_29e7, const Packets_t& members_29e9, const Packets_t& triggerVars_29eb, const Packets_t& unaryExprss_29ed)
{
	AddLastTrigger_29e6 addLastTrigger_29e6;
	addLastTrigger_29e6( structs_29e7, members_29e9, triggerVars_29eb, unaryExprss_29ed);
}

void AddTrigger_29dd::callAddNextTrigger_2a65( const Packets_t& structs_2a23, const Packets_t& members_2a25, const Packets_t& triggerVars_2a27, const Packets_t& unaryExprss_2a29)
{
	AddNextTrigger_2a22 addNextTrigger_2a22;
	addNextTrigger_2a22( structs_2a23, members_2a25, triggerVars_2a27, unaryExprss_2a29);
}

void AddLastTrigger_29e6::operator()( const Packets_t& structs_29e7, const Packets_t& members_29e9, const Packets_t& triggerVars_29eb, const Packets_t& unaryExprss_29ed)
{
#ifdef PRINT_INFO
	printLog( "AddLastTrigger_29e6" );
#endif
	RTTGenerator::Instance()->generateRule(2638, "AddLastTrigger");
	processInputPackets( structs_29e7, members_29e9, triggerVars_29eb, unaryExprss_29ed);
}

bool AddLastTrigger_29e6::isInputUnique( const Udm::Object& struct_29f3, const Udm::Object& member_29fc, const Udm::Object& triggerVar_2a05, const Udm::Object& unaryExprs_2a0e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itStruct_29f5= _struct_29ef.begin(), itMember_29fe= _member_29f8.begin(), itTriggerVar_2a07= _triggerVar_2a01.begin(), itUnaryExprs_2a10= _unaryExprs_2a0a.begin(); itStruct_29f5!= _struct_29ef.end(), itMember_29fe!= _member_29f8.end(), itTriggerVar_2a07!= _triggerVar_2a01.end(), itUnaryExprs_2a10!= _unaryExprs_2a0a.end(); ++itStruct_29f5, ++itMember_29fe, ++itTriggerVar_2a07, ++itUnaryExprs_2a10)
	{
		if( ( *itStruct_29f5== struct_29f3)&& ( *itMember_29fe== member_29fc)&& ( *itTriggerVar_2a07== triggerVar_2a05)&& ( *itUnaryExprs_2a10== unaryExprs_2a0e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_29ef.push_back( struct_29f3);
		_member_29f8.push_back( member_29fc);
		_triggerVar_2a01.push_back( triggerVar_2a05);
		_unaryExprs_2a0a.push_back( unaryExprs_2a0e);
	}
	return isUnique;
}

bool AddLastTrigger_29e6::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool AddLastTrigger_29e6::isGuardTrue( SFC::LocalVar& Member, SFC::Struct& Struct, SFC::LocalVar& TriggerVar, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	Gz_guard = Member.statementIndex() + 1 == Struct.memberCount();;
	return Gz_guard;
}

void AddLastTrigger_29e6::processInputPackets( const Packets_t& structs_29e7, const Packets_t& members_29e9, const Packets_t& triggerVars_29eb, const Packets_t& unaryExprss_29ed)
{
	for( Packets_t::const_iterator itStruct_29f0= structs_29e7.begin(), itMember_29f9= members_29e9.begin(), itTriggerVar_2a02= triggerVars_29eb.begin(), itUnaryExprs_2a0b= unaryExprss_29ed.begin(); itStruct_29f0!= structs_29e7.end(), itMember_29f9!= members_29e9.end(), itTriggerVar_2a02!= triggerVars_29eb.end(), itUnaryExprs_2a0b!= unaryExprss_29ed.end(); ++itStruct_29f0, ++itMember_29f9, ++itTriggerVar_2a02, ++itUnaryExprs_2a0b)
	{
		bool isUnique= isInputUnique( *itStruct_29f0, *itMember_29f9, *itTriggerVar_2a02, *itUnaryExprs_2a0b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itStruct_29f0, *itMember_29f9, *itTriggerVar_2a02, *itUnaryExprs_2a0b);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AddLastTrigger_29e6::patternMatcher( const Udm::Object& struct_29f1, const Udm::Object& member_29fa, const Udm::Object& triggerVar_2a03, const Udm::Object& unaryExprs_2a0c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( struct_29f1.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_29f6= SFC::Struct::Cast( struct_29f1);
		if( false== Uml::IsDerivedFrom( member_29fa.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_29ff= SFC::LocalVar::Cast( member_29fa);
		if( false== Uml::IsDerivedFrom( triggerVar_2a03.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_2a08= SFC::LocalVar::Cast( triggerVar_2a03);
		if( false== Uml::IsDerivedFrom( unaryExprs_2a0c.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_2a11= SFC::UnaryExprs::Cast( unaryExprs_2a0c);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2a16;
		if( !isValidBound(boundObjs_2a16, struct_29f6, true))
			continue;
		currMatch.struct_2a17= struct_29f6;
		if( !isValidBound(boundObjs_2a16, member_29ff, true))
			continue;
		currMatch.member_2a18= member_29ff;
		if( !isValidBound(boundObjs_2a16, triggerVar_2a08, true))
			continue;
		currMatch.triggerVar_2a19= triggerVar_2a08;
		if( !isValidBound(boundObjs_2a16, unaryExprs_2a11, true))
			continue;
		currMatch.unaryExprs_2a1a= unaryExprs_2a11;
		bool Gz_guard= isGuardTrue( currMatch.member_2a18, currMatch.struct_2a17, currMatch.triggerVar_2a19, currMatch.unaryExprs_2a1a);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void AddLastTrigger_29e6::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newDot_2a1f= SFC::BinaryExprs::Create( currMatch.unaryExprs_2a1a, SFC::UnaryExprs::meta_subexpr);
		SFC::ArgDeclRef newArgDeclRef1_2a20= SFC::ArgDeclRef::Create( newDot_2a1f, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef2_2a21= SFC::ArgDeclRef::Create( newDot_2a1f, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef& ArgDeclRef1= newArgDeclRef1_2a20;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_2a21;
		SFC::BinaryExprs& Dot= newDot_2a1f;
		SFC::LocalVar& Member= currMatch.member_2a18;
		SFC::Struct& Struct= currMatch.struct_2a17;
		SFC::LocalVar& TriggerVar= currMatch.triggerVar_2a19;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_2a1a;
		{
Dot.op() = ".";
};
		newArgDeclRef2_2a21.argdecl()= currMatch.triggerVar_2a19;
		newArgDeclRef1_2a20.argdecl()= currMatch.member_2a18;
	}
}

void AddNextTrigger_2a22::operator()( const Packets_t& structs_2a23, const Packets_t& members_2a25, const Packets_t& triggerVars_2a27, const Packets_t& unaryExprss_2a29)
{
#ifdef PRINT_INFO
	printLog( "AddNextTrigger_2a22" );
#endif
	RTTGenerator::Instance()->generateRule(2652, "AddNextTrigger");
	processInputPackets( structs_2a23, members_2a25, triggerVars_2a27, unaryExprss_2a29);
}

bool AddNextTrigger_2a22::isInputUnique( const Udm::Object& struct_2a2f, const Udm::Object& member_2a38, const Udm::Object& triggerVar_2a41, const Udm::Object& unaryExprs_2a4a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itStruct_2a31= _struct_2a2b.begin(), itMember_2a3a= _member_2a34.begin(), itTriggerVar_2a43= _triggerVar_2a3d.begin(), itUnaryExprs_2a4c= _unaryExprs_2a46.begin(); itStruct_2a31!= _struct_2a2b.end(), itMember_2a3a!= _member_2a34.end(), itTriggerVar_2a43!= _triggerVar_2a3d.end(), itUnaryExprs_2a4c!= _unaryExprs_2a46.end(); ++itStruct_2a31, ++itMember_2a3a, ++itTriggerVar_2a43, ++itUnaryExprs_2a4c)
	{
		if( ( *itStruct_2a31== struct_2a2f)&& ( *itMember_2a3a== member_2a38)&& ( *itTriggerVar_2a43== triggerVar_2a41)&& ( *itUnaryExprs_2a4c== unaryExprs_2a4a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_2a2b.push_back( struct_2a2f);
		_member_2a34.push_back( member_2a38);
		_triggerVar_2a3d.push_back( triggerVar_2a41);
		_unaryExprs_2a46.push_back( unaryExprs_2a4a);
	}
	return isUnique;
}

bool AddNextTrigger_2a22::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool AddNextTrigger_2a22::isGuardTrue( SFC::LocalVar& Member, SFC::Struct& Struct, SFC::LocalVar& TriggerVar, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	Gz_guard = Member.statementIndex() + 1 != Struct.memberCount();;
	return Gz_guard;
}

void AddNextTrigger_2a22::processInputPackets( const Packets_t& structs_2a23, const Packets_t& members_2a25, const Packets_t& triggerVars_2a27, const Packets_t& unaryExprss_2a29)
{
	for( Packets_t::const_iterator itStruct_2a2c= structs_2a23.begin(), itMember_2a35= members_2a25.begin(), itTriggerVar_2a3e= triggerVars_2a27.begin(), itUnaryExprs_2a47= unaryExprss_2a29.begin(); itStruct_2a2c!= structs_2a23.end(), itMember_2a35!= members_2a25.end(), itTriggerVar_2a3e!= triggerVars_2a27.end(), itUnaryExprs_2a47!= unaryExprss_2a29.end(); ++itStruct_2a2c, ++itMember_2a35, ++itTriggerVar_2a3e, ++itUnaryExprs_2a47)
	{
		bool isUnique= isInputUnique( *itStruct_2a2c, *itMember_2a35, *itTriggerVar_2a3e, *itUnaryExprs_2a47);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itStruct_2a2c, *itMember_2a35, *itTriggerVar_2a3e, *itUnaryExprs_2a47);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AddNextTrigger_2a22::patternMatcher( const Udm::Object& struct_2a2d, const Udm::Object& member_2a36, const Udm::Object& triggerVar_2a3f, const Udm::Object& unaryExprs_2a48)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( struct_2a2d.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_2a32= SFC::Struct::Cast( struct_2a2d);
		if( false== Uml::IsDerivedFrom( member_2a36.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_2a3b= SFC::LocalVar::Cast( member_2a36);
		if( false== Uml::IsDerivedFrom( triggerVar_2a3f.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_2a44= SFC::LocalVar::Cast( triggerVar_2a3f);
		if( false== Uml::IsDerivedFrom( unaryExprs_2a48.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_2a4d= SFC::UnaryExprs::Cast( unaryExprs_2a48);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2a52;
		if( !isValidBound(boundObjs_2a52, struct_2a32, true))
			continue;
		currMatch.struct_2a53= struct_2a32;
		if( !isValidBound(boundObjs_2a52, member_2a3b, true))
			continue;
		currMatch.member_2a54= member_2a3b;
		if( !isValidBound(boundObjs_2a52, triggerVar_2a44, true))
			continue;
		currMatch.triggerVar_2a55= triggerVar_2a44;
		if( !isValidBound(boundObjs_2a52, unaryExprs_2a4d, true))
			continue;
		currMatch.unaryExprs_2a56= unaryExprs_2a4d;
		bool Gz_guard= isGuardTrue( currMatch.member_2a54, currMatch.struct_2a53, currMatch.triggerVar_2a55, currMatch.unaryExprs_2a56);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void AddNextTrigger_2a22::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newOr_2a5b= SFC::BinaryExprs::Create( currMatch.unaryExprs_2a56, SFC::UnaryExprs::meta_subexpr);
		SFC::BinaryExprs newDot_2a5c= SFC::BinaryExprs::Create( newOr_2a5b, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_2a5d= SFC::ArgDeclRef::Create( newDot_2a5c, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef1_2a5e= SFC::ArgDeclRef::Create( newDot_2a5c, SFC::BinaryExprs::meta_rightexpr);
		SFC::UnaryExprs newDummy_2a5f= SFC::UnaryExprs::Create( newOr_2a5b, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef& ArgDeclRef1= newArgDeclRef1_2a5e;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_2a5d;
		SFC::BinaryExprs& Dot= newDot_2a5c;
		SFC::UnaryExprs& Dummy= newDummy_2a5f;
		SFC::LocalVar& Member= currMatch.member_2a54;
		SFC::BinaryExprs& Or= newOr_2a5b;
		SFC::Struct& Struct= currMatch.struct_2a53;
		SFC::LocalVar& TriggerVar= currMatch.triggerVar_2a55;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_2a56;
		{
Or.op() = "||";
};
		{
Dot.op() = ".";
};
		{
Dummy.op() = "";
};
		newArgDeclRef1_2a5e.argdecl()= currMatch.member_2a54;
		newArgDeclRef2_2a5d.argdecl()= currMatch.triggerVar_2a55;
	}
}

void TriggerTest_2a6a::operator()( const Packets_t& structs_2a6b, const Packets_t& members_2a6d, const Packets_t& trigvars_2a6f, const Packets_t& condexprs_2a71, Packets_t& structs_2a73, Packets_t& members_2a74, Packets_t& trigvars_2a75, Packets_t& condexprs_2a76, Packets_t& structs_2a77, Packets_t& members_2a78, Packets_t& trigvars_2a79, Packets_t& condexprs_2a7a)
{
#ifdef PRINT_INFO
	printLog( "TriggerTest_2a6a" );
#endif
	_struct_2a7b= &structs_2a73;
	_member_2a7c= &members_2a74;
	_trigvar_2a7d= &trigvars_2a75;
	_condexpr_2a7e= &condexprs_2a76;
	_struct_2a7f= &structs_2a77;
	_member_2a80= &members_2a78;
	_trigvar_2a81= &trigvars_2a79;
	_condexpr_2a82= &condexprs_2a7a;
	for( Packets_t::const_iterator itstruct_2a84= structs_2a6b.begin(), itmember_2a8b= members_2a6d.begin(), ittrigvar_2a92= trigvars_2a6f.begin(), itcondexpr_2a99= condexprs_2a71.begin(); itstruct_2a84!= structs_2a6b.end(), itmember_2a8b!= members_2a6d.end(), ittrigvar_2a92!= trigvars_2a6f.end(), itcondexpr_2a99!= condexprs_2a71.end(); ++itstruct_2a84, ++itmember_2a8b, ++ittrigvar_2a92, ++itcondexpr_2a99)
	{
		bool isUnique= isInputUnique( *itstruct_2a84, *itmember_2a8b, *ittrigvar_2a92, *itcondexpr_2a99);
		if( !isUnique)
			continue;
		Packets_t onestruct_2a88( 1, *itstruct_2a84);
		Packets_t onemember_2a8f( 1, *itmember_2a8b);
		Packets_t onetrigvar_2a96( 1, *ittrigvar_2a92);
		Packets_t onecondexpr_2a9d( 1, *itcondexpr_2a99);
		executeOne( onestruct_2a88, onemember_2a8f, onetrigvar_2a96, onecondexpr_2a9d);
	}
}

void TriggerTest_2a6a::executeOne( const Packets_t& structs_2a6b, const Packets_t& members_2a6d, const Packets_t& trigvars_2a6f, const Packets_t& condexprs_2a71)
{
	Packets_t structs_2aa2;
	Packets_t members_2aa5;
	Packets_t triggerVars_2aa8;
	Packets_t unaryExprss_2aab;
	HasBinaryExprs_2a9f hasBinaryExprs_2a9f;
	bool isMatchHasBinaryExprs_2a9f= hasBinaryExprs_2a9f( structs_2a6b, members_2a6d, trigvars_2a6f, condexprs_2a71, structs_2aa2, members_2aa5, triggerVars_2aa8, unaryExprss_2aab);
	_struct_2a7b->insert( _struct_2a7b->end(), structs_2aa2.begin(), structs_2aa2.end());
	_member_2a7c->insert( _member_2a7c->end(), members_2aa5.begin(), members_2aa5.end());
	_trigvar_2a7d->insert( _trigvar_2a7d->end(), triggerVars_2aa8.begin(), triggerVars_2aa8.end());
	_condexpr_2a7e->insert( _condexpr_2a7e->end(), unaryExprss_2aab.begin(), unaryExprss_2aab.end());
	if( isMatchHasBinaryExprs_2a9f)
		return;
	Packets_t structs_2aeb;
	Packets_t members_2aee;
	Packets_t triggerVars_2af1;
	Packets_t unaryExprss_2af4;
	Otherwise_2ae8 otherwise_2ae8;
	bool isMatchOtherwise_2ae8= otherwise_2ae8( structs_2a6b, members_2a6d, trigvars_2a6f, condexprs_2a71, structs_2aeb, members_2aee, triggerVars_2af1, unaryExprss_2af4);
	_struct_2a7f->insert( _struct_2a7f->end(), structs_2aeb.begin(), structs_2aeb.end());
	_member_2a80->insert( _member_2a80->end(), members_2aee.begin(), members_2aee.end());
	_trigvar_2a81->insert( _trigvar_2a81->end(), triggerVars_2af1.begin(), triggerVars_2af1.end());
	_condexpr_2a82->insert( _condexpr_2a82->end(), unaryExprss_2af4.begin(), unaryExprss_2af4.end());
	if( isMatchOtherwise_2ae8)
		return;
}

bool TriggerTest_2a6a::isInputUnique( const Udm::Object& struct_2a85, const Udm::Object& member_2a8c, const Udm::Object& trigvar_2a93, const Udm::Object& condexpr_2a9a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstruct_2a87= _struct_2a83.begin(), itmember_2a8e= _member_2a8a.begin(), ittrigvar_2a95= _trigvar_2a91.begin(), itcondexpr_2a9c= _condexpr_2a98.begin(); itstruct_2a87!= _struct_2a83.end(), itmember_2a8e!= _member_2a8a.end(), ittrigvar_2a95!= _trigvar_2a91.end(), itcondexpr_2a9c!= _condexpr_2a98.end(); ++itstruct_2a87, ++itmember_2a8e, ++ittrigvar_2a95, ++itcondexpr_2a9c)
	{
		if( ( *itstruct_2a87== struct_2a85)&& ( *itmember_2a8e== member_2a8c)&& ( *ittrigvar_2a95== trigvar_2a93)&& ( *itcondexpr_2a9c== condexpr_2a9a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_2a83.push_back( struct_2a85);
		_member_2a8a.push_back( member_2a8c);
		_trigvar_2a91.push_back( trigvar_2a93);
		_condexpr_2a98.push_back( condexpr_2a9a);
	}
	return isUnique;
}

bool HasBinaryExprs_2a9f::operator()( const Packets_t& structs_2aa0, const Packets_t& members_2aa3, const Packets_t& triggerVars_2aa6, const Packets_t& unaryExprss_2aa9, Packets_t& structs_2aa2, Packets_t& members_2aa5, Packets_t& triggerVars_2aa8, Packets_t& unaryExprss_2aab)
{
#ifdef PRINT_INFO
	printLog( "HasBinaryExprs_2a9f" );
#endif
	_struct_2aac= &structs_2aa2;
	_member_2aad= &members_2aa5;
	_triggerVar_2aae= &triggerVars_2aa8;
	_unaryExprs_2aaf= &unaryExprss_2aab;
	processInputPackets( structs_2aa0, members_2aa3, triggerVars_2aa6, unaryExprss_2aa9);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasBinaryExprs_2a9f::isInputUnique( const Udm::Object& struct_2ab4, const Udm::Object& member_2abd, const Udm::Object& triggerVar_2ac6, const Udm::Object& unaryExprs_2acf)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itStruct_2ab6= _struct_2ab0.begin(), itMember_2abf= _member_2ab9.begin(), itTriggerVar_2ac8= _triggerVar_2ac2.begin(), itUnaryExprs_2ad1= _unaryExprs_2acb.begin(); itStruct_2ab6!= _struct_2ab0.end(), itMember_2abf!= _member_2ab9.end(), itTriggerVar_2ac8!= _triggerVar_2ac2.end(), itUnaryExprs_2ad1!= _unaryExprs_2acb.end(); ++itStruct_2ab6, ++itMember_2abf, ++itTriggerVar_2ac8, ++itUnaryExprs_2ad1)
	{
		if( ( *itStruct_2ab6== struct_2ab4)&& ( *itMember_2abf== member_2abd)&& ( *itTriggerVar_2ac8== triggerVar_2ac6)&& ( *itUnaryExprs_2ad1== unaryExprs_2acf))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_2ab0.push_back( struct_2ab4);
		_member_2ab9.push_back( member_2abd);
		_triggerVar_2ac2.push_back( triggerVar_2ac6);
		_unaryExprs_2acb.push_back( unaryExprs_2acf);
	}
	return isUnique;
}

bool HasBinaryExprs_2a9f::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void HasBinaryExprs_2a9f::processInputPackets( const Packets_t& structs_2aa0, const Packets_t& members_2aa3, const Packets_t& triggerVars_2aa6, const Packets_t& unaryExprss_2aa9)
{
	for( Packets_t::const_iterator itStruct_2ab1= structs_2aa0.begin(), itMember_2aba= members_2aa3.begin(), itTriggerVar_2ac3= triggerVars_2aa6.begin(), itUnaryExprs_2acc= unaryExprss_2aa9.begin(); itStruct_2ab1!= structs_2aa0.end(), itMember_2aba!= members_2aa3.end(), itTriggerVar_2ac3!= triggerVars_2aa6.end(), itUnaryExprs_2acc!= unaryExprss_2aa9.end(); ++itStruct_2ab1, ++itMember_2aba, ++itTriggerVar_2ac3, ++itUnaryExprs_2acc)
	{
		bool isUnique= isInputUnique( *itStruct_2ab1, *itMember_2aba, *itTriggerVar_2ac3, *itUnaryExprs_2acc);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itStruct_2ab1, *itMember_2aba, *itTriggerVar_2ac3, *itUnaryExprs_2acc);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.struct_2adb, currMatch.member_2adc, currMatch.triggerVar_2add, currMatch.unaryExprs_2ade);
	}
}

bool HasBinaryExprs_2a9f::patternMatcher( const Udm::Object& struct_2ab2, const Udm::Object& member_2abb, const Udm::Object& triggerVar_2ac4, const Udm::Object& unaryExprs_2acd)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( struct_2ab2.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_2ab7= SFC::Struct::Cast( struct_2ab2);
		if( false== Uml::IsDerivedFrom( member_2abb.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_2ac0= SFC::LocalVar::Cast( member_2abb);
		if( false== Uml::IsDerivedFrom( triggerVar_2ac4.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_2ac9= SFC::LocalVar::Cast( triggerVar_2ac4);
		if( false== Uml::IsDerivedFrom( unaryExprs_2acd.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_2ad2= SFC::UnaryExprs::Cast( unaryExprs_2acd);
		set< SFC::BinaryExprs> binaryExprss_2ad4= unaryExprs_2ad2.BinaryExprs_kind_children();
		for( set< SFC::BinaryExprs>::const_iterator itBinaryExprs_2ad5= binaryExprss_2ad4.begin(); itBinaryExprs_2ad5!= binaryExprss_2ad4.end(); ++itBinaryExprs_2ad5)
		{
			SFC::BinaryExprs currBinaryExprs_2ad6= *itBinaryExprs_2ad5;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2ada;
			if( !isValidBound(boundObjs_2ada, struct_2ab7, true))
				continue;
			currMatch.struct_2adb= struct_2ab7;
			if( !isValidBound(boundObjs_2ada, member_2ac0, true))
				continue;
			currMatch.member_2adc= member_2ac0;
			if( !isValidBound(boundObjs_2ada, triggerVar_2ac9, true))
				continue;
			currMatch.triggerVar_2add= triggerVar_2ac9;
			if( !isValidBound(boundObjs_2ada, unaryExprs_2ad2, true))
				continue;
			currMatch.unaryExprs_2ade= unaryExprs_2ad2;
			if( !isValidBound(boundObjs_2ada, currBinaryExprs_2ad6, false))
				continue;
			currMatch.binaryExprs_2adf= currBinaryExprs_2ad6;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void HasBinaryExprs_2a9f::outputAppender( const SFC::Struct& struct_2ae0, const SFC::LocalVar& member_2ae2, const SFC::LocalVar& triggerVar_2ae4, const SFC::UnaryExprs& unaryExprs_2ae6)
{
	_struct_2aac->push_back( struct_2ae0);
	_member_2aad->push_back( member_2ae2);
	_triggerVar_2aae->push_back( triggerVar_2ae4);
	_unaryExprs_2aaf->push_back( unaryExprs_2ae6);
}

bool Otherwise_2ae8::operator()( const Packets_t& structs_2ae9, const Packets_t& members_2aec, const Packets_t& triggerVars_2aef, const Packets_t& unaryExprss_2af2, Packets_t& structs_2aeb, Packets_t& members_2aee, Packets_t& triggerVars_2af1, Packets_t& unaryExprss_2af4)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_2ae8" );
#endif
	_struct_2af5= &structs_2aeb;
	_member_2af6= &members_2aee;
	_triggerVar_2af7= &triggerVars_2af1;
	_unaryExprs_2af8= &unaryExprss_2af4;
	processInputPackets( structs_2ae9, members_2aec, triggerVars_2aef, unaryExprss_2af2);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_2ae8::isInputUnique( const Udm::Object& struct_2afd, const Udm::Object& member_2b06, const Udm::Object& triggerVar_2b0f, const Udm::Object& unaryExprs_2b18)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itStruct_2aff= _struct_2af9.begin(), itMember_2b08= _member_2b02.begin(), itTriggerVar_2b11= _triggerVar_2b0b.begin(), itUnaryExprs_2b1a= _unaryExprs_2b14.begin(); itStruct_2aff!= _struct_2af9.end(), itMember_2b08!= _member_2b02.end(), itTriggerVar_2b11!= _triggerVar_2b0b.end(), itUnaryExprs_2b1a!= _unaryExprs_2b14.end(); ++itStruct_2aff, ++itMember_2b08, ++itTriggerVar_2b11, ++itUnaryExprs_2b1a)
	{
		if( ( *itStruct_2aff== struct_2afd)&& ( *itMember_2b08== member_2b06)&& ( *itTriggerVar_2b11== triggerVar_2b0f)&& ( *itUnaryExprs_2b1a== unaryExprs_2b18))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_2af9.push_back( struct_2afd);
		_member_2b02.push_back( member_2b06);
		_triggerVar_2b0b.push_back( triggerVar_2b0f);
		_unaryExprs_2b14.push_back( unaryExprs_2b18);
	}
	return isUnique;
}

bool Otherwise_2ae8::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_2ae8::processInputPackets( const Packets_t& structs_2ae9, const Packets_t& members_2aec, const Packets_t& triggerVars_2aef, const Packets_t& unaryExprss_2af2)
{
	for( Packets_t::const_iterator itStruct_2afa= structs_2ae9.begin(), itMember_2b03= members_2aec.begin(), itTriggerVar_2b0c= triggerVars_2aef.begin(), itUnaryExprs_2b15= unaryExprss_2af2.begin(); itStruct_2afa!= structs_2ae9.end(), itMember_2b03!= members_2aec.end(), itTriggerVar_2b0c!= triggerVars_2aef.end(), itUnaryExprs_2b15!= unaryExprss_2af2.end(); ++itStruct_2afa, ++itMember_2b03, ++itTriggerVar_2b0c, ++itUnaryExprs_2b15)
	{
		bool isUnique= isInputUnique( *itStruct_2afa, *itMember_2b03, *itTriggerVar_2b0c, *itUnaryExprs_2b15);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itStruct_2afa, *itMember_2b03, *itTriggerVar_2b0c, *itUnaryExprs_2b15);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.struct_2b21, currMatch.member_2b22, currMatch.triggerVar_2b23, currMatch.unaryExprs_2b24);
	}
}

bool Otherwise_2ae8::patternMatcher( const Udm::Object& struct_2afb, const Udm::Object& member_2b04, const Udm::Object& triggerVar_2b0d, const Udm::Object& unaryExprs_2b16)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( struct_2afb.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_2b00= SFC::Struct::Cast( struct_2afb);
		if( false== Uml::IsDerivedFrom( member_2b04.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_2b09= SFC::LocalVar::Cast( member_2b04);
		if( false== Uml::IsDerivedFrom( triggerVar_2b0d.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_2b12= SFC::LocalVar::Cast( triggerVar_2b0d);
		if( false== Uml::IsDerivedFrom( unaryExprs_2b16.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_2b1b= SFC::UnaryExprs::Cast( unaryExprs_2b16);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2b20;
		if( !isValidBound(boundObjs_2b20, struct_2b00, true))
			continue;
		currMatch.struct_2b21= struct_2b00;
		if( !isValidBound(boundObjs_2b20, member_2b09, true))
			continue;
		currMatch.member_2b22= member_2b09;
		if( !isValidBound(boundObjs_2b20, triggerVar_2b12, true))
			continue;
		currMatch.triggerVar_2b23= triggerVar_2b12;
		if( !isValidBound(boundObjs_2b20, unaryExprs_2b1b, true))
			continue;
		currMatch.unaryExprs_2b24= unaryExprs_2b1b;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_2ae8::outputAppender( const SFC::Struct& struct_2b25, const SFC::LocalVar& member_2b27, const SFC::LocalVar& triggerVar_2b29, const SFC::UnaryExprs& unaryExprs_2b2b)
{
	_struct_2af5->push_back( struct_2b25);
	_member_2af6->push_back( member_2b27);
	_triggerVar_2af7->push_back( triggerVar_2b29);
	_unaryExprs_2af8->push_back( unaryExprs_2b2b);
}

void TraverseBinary_2b2d::operator()( const Packets_t& structs_2b2e, const Packets_t& members_2b31, const Packets_t& triggerVars_2b34, const Packets_t& unaryExprss_2b37, Packets_t& structs_2b30, Packets_t& members_2b33, Packets_t& triggerVars_2b36, Packets_t& unaryExprss_2b39)
{
#ifdef PRINT_INFO
	printLog( "TraverseBinary_2b2d" );
#endif
	RTTGenerator::Instance()->generateRule(2697, "TraverseBinary");
	_struct_2b3a= &structs_2b30;
	_member_2b3b= &members_2b33;
	_triggerVar_2b3c= &triggerVars_2b36;
	_unaryExprs_2b3d= &unaryExprss_2b39;
	processInputPackets( structs_2b2e, members_2b31, triggerVars_2b34, unaryExprss_2b37);
}

bool TraverseBinary_2b2d::isInputUnique( const Udm::Object& struct_2b42, const Udm::Object& member_2b4b, const Udm::Object& triggerVar_2b54, const Udm::Object& unaryExprs_2b5d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itStruct_2b44= _struct_2b3e.begin(), itMember_2b4d= _member_2b47.begin(), itTriggerVar_2b56= _triggerVar_2b50.begin(), itUnaryExprs_2b5f= _unaryExprs_2b59.begin(); itStruct_2b44!= _struct_2b3e.end(), itMember_2b4d!= _member_2b47.end(), itTriggerVar_2b56!= _triggerVar_2b50.end(), itUnaryExprs_2b5f!= _unaryExprs_2b59.end(); ++itStruct_2b44, ++itMember_2b4d, ++itTriggerVar_2b56, ++itUnaryExprs_2b5f)
	{
		if( ( *itStruct_2b44== struct_2b42)&& ( *itMember_2b4d== member_2b4b)&& ( *itTriggerVar_2b56== triggerVar_2b54)&& ( *itUnaryExprs_2b5f== unaryExprs_2b5d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_2b3e.push_back( struct_2b42);
		_member_2b47.push_back( member_2b4b);
		_triggerVar_2b50.push_back( triggerVar_2b54);
		_unaryExprs_2b59.push_back( unaryExprs_2b5d);
	}
	return isUnique;
}

bool TraverseBinary_2b2d::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void TraverseBinary_2b2d::processInputPackets( const Packets_t& structs_2b2e, const Packets_t& members_2b31, const Packets_t& triggerVars_2b34, const Packets_t& unaryExprss_2b37)
{
	for( Packets_t::const_iterator itStruct_2b3f= structs_2b2e.begin(), itMember_2b48= members_2b31.begin(), itTriggerVar_2b51= triggerVars_2b34.begin(), itUnaryExprs_2b5a= unaryExprss_2b37.begin(); itStruct_2b3f!= structs_2b2e.end(), itMember_2b48!= members_2b31.end(), itTriggerVar_2b51!= triggerVars_2b34.end(), itUnaryExprs_2b5a!= unaryExprss_2b37.end(); ++itStruct_2b3f, ++itMember_2b48, ++itTriggerVar_2b51, ++itUnaryExprs_2b5a)
	{
		bool isUnique= isInputUnique( *itStruct_2b3f, *itMember_2b48, *itTriggerVar_2b51, *itUnaryExprs_2b5a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itStruct_2b3f, *itMember_2b48, *itTriggerVar_2b51, *itUnaryExprs_2b5a);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool TraverseBinary_2b2d::patternMatcher( const Udm::Object& struct_2b40, const Udm::Object& member_2b49, const Udm::Object& triggerVar_2b52, const Udm::Object& unaryExprs_2b5b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( struct_2b40.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_2b45= SFC::Struct::Cast( struct_2b40);
		if( false== Uml::IsDerivedFrom( member_2b49.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_2b4e= SFC::LocalVar::Cast( member_2b49);
		if( false== Uml::IsDerivedFrom( triggerVar_2b52.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_2b57= SFC::LocalVar::Cast( triggerVar_2b52);
		if( false== Uml::IsDerivedFrom( unaryExprs_2b5b.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_2b60= SFC::UnaryExprs::Cast( unaryExprs_2b5b);
		set< SFC::BinaryExprs> binaryExprss_2b62= unaryExprs_2b60.BinaryExprs_kind_children();
		for( set< SFC::BinaryExprs>::const_iterator itBinaryExprs_2b63= binaryExprss_2b62.begin(); itBinaryExprs_2b63!= binaryExprss_2b62.end(); ++itBinaryExprs_2b63)
		{
			SFC::BinaryExprs currBinaryExprs_2b64= *itBinaryExprs_2b63;
			set< SFC::UnaryExprs> unaryExprss_2b65= currBinaryExprs_2b64.UnaryExprs_kind_children();
			for( set< SFC::UnaryExprs>::const_iterator itUnaryExprs_2b66= unaryExprss_2b65.begin(); itUnaryExprs_2b66!= unaryExprss_2b65.end(); ++itUnaryExprs_2b66)
			{
				SFC::UnaryExprs currUnaryExprs_2b67= *itUnaryExprs_2b66;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_2b6b;
				if( !isValidBound(boundObjs_2b6b, struct_2b45, true))
					continue;
				currMatch.struct_2b6c= struct_2b45;
				if( !isValidBound(boundObjs_2b6b, member_2b4e, true))
					continue;
				currMatch.member_2b6d= member_2b4e;
				if( !isValidBound(boundObjs_2b6b, triggerVar_2b57, true))
					continue;
				currMatch.triggerVar_2b6e= triggerVar_2b57;
				if( !isValidBound(boundObjs_2b6b, unaryExprs_2b60, true))
					continue;
				currMatch.unaryExprs_2b6f= unaryExprs_2b60;
				if( !isValidBound(boundObjs_2b6b, currBinaryExprs_2b64, false))
					continue;
				currMatch.binaryExprs_2b70= currBinaryExprs_2b64;
				if( !isValidBound(boundObjs_2b6b, currUnaryExprs_2b67, false))
					continue;
				currMatch.unaryExprs_2b71= currUnaryExprs_2b67;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void TraverseBinary_2b2d::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.struct_2b6c, currMatch.member_2b6d, currMatch.triggerVar_2b6e, currMatch.unaryExprs_2b71);
	}
}

void TraverseBinary_2b2d::outputAppender( const SFC::Struct& struct_2b72, const SFC::LocalVar& member_2b74, const SFC::LocalVar& triggerVar_2b76, const SFC::UnaryExprs& unaryExprs_2b78)
{
	_struct_2b3a->push_back( struct_2b72);
	_member_2b3b->push_back( member_2b74);
	_triggerVar_2b3c->push_back( triggerVar_2b76);
	_unaryExprs_2b3d->push_back( unaryExprs_2b78);
}

void GetStructMembers_2b89::operator()( const Packets_t& structs_2b8a, const Packets_t& triggerVars_2b8e, const Packets_t& unaryExprss_2b91, Packets_t& structs_2b8c, Packets_t& members_2b8d, Packets_t& triggerVars_2b90, Packets_t& unaryExprss_2b93)
{
#ifdef PRINT_INFO
	printLog( "GetStructMembers_2b89" );
#endif
	RTTGenerator::Instance()->generateRule(2706, "getStructMembers");
	_struct_2b94= &structs_2b8c;
	_member_2b95= &members_2b8d;
	_triggerVar_2b96= &triggerVars_2b90;
	_unaryExprs_2b97= &unaryExprss_2b93;
	processInputPackets( structs_2b8a, triggerVars_2b8e, unaryExprss_2b91);
	sortOutputs( );
}

bool GetStructMembers_2b89::isInputUnique( const Udm::Object& struct_2b9c, const Udm::Object& triggerVar_2ba5, const Udm::Object& unaryExprs_2bae)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itStruct_2b9e= _struct_2b98.begin(), itTriggerVar_2ba7= _triggerVar_2ba1.begin(), itUnaryExprs_2bb0= _unaryExprs_2baa.begin(); itStruct_2b9e!= _struct_2b98.end(), itTriggerVar_2ba7!= _triggerVar_2ba1.end(), itUnaryExprs_2bb0!= _unaryExprs_2baa.end(); ++itStruct_2b9e, ++itTriggerVar_2ba7, ++itUnaryExprs_2bb0)
	{
		if( ( *itStruct_2b9e== struct_2b9c)&& ( *itTriggerVar_2ba7== triggerVar_2ba5)&& ( *itUnaryExprs_2bb0== unaryExprs_2bae))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_2b98.push_back( struct_2b9c);
		_triggerVar_2ba1.push_back( triggerVar_2ba5);
		_unaryExprs_2baa.push_back( unaryExprs_2bae);
	}
	return isUnique;
}

bool GetStructMembers_2b89::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetStructMembers_2b89::processInputPackets( const Packets_t& structs_2b8a, const Packets_t& triggerVars_2b8e, const Packets_t& unaryExprss_2b91)
{
	for( Packets_t::const_iterator itStruct_2b99= structs_2b8a.begin(), itTriggerVar_2ba2= triggerVars_2b8e.begin(), itUnaryExprs_2bab= unaryExprss_2b91.begin(); itStruct_2b99!= structs_2b8a.end(), itTriggerVar_2ba2!= triggerVars_2b8e.end(), itUnaryExprs_2bab!= unaryExprss_2b91.end(); ++itStruct_2b99, ++itTriggerVar_2ba2, ++itUnaryExprs_2bab)
	{
		bool isUnique= isInputUnique( *itStruct_2b99, *itTriggerVar_2ba2, *itUnaryExprs_2bab);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itStruct_2b99, *itTriggerVar_2ba2, *itUnaryExprs_2bab);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetStructMembers_2b89::patternMatcher( const Udm::Object& struct_2b9a, const Udm::Object& triggerVar_2ba3, const Udm::Object& unaryExprs_2bac)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( struct_2b9a.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_2b9f= SFC::Struct::Cast( struct_2b9a);
		if( false== Uml::IsDerivedFrom( triggerVar_2ba3.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_2ba8= SFC::LocalVar::Cast( triggerVar_2ba3);
		if( false== Uml::IsDerivedFrom( unaryExprs_2bac.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_2bb1= SFC::UnaryExprs::Cast( unaryExprs_2bac);
		set< SFC::LocalVar> members_2bb3= struct_2b9f.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itMember_2bb4= members_2bb3.begin(); itMember_2bb4!= members_2bb3.end(); ++itMember_2bb4)
		{
			SFC::LocalVar currMember_2bb5= *itMember_2bb4;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2bb9;
			if( !isValidBound(boundObjs_2bb9, struct_2b9f, true))
				continue;
			currMatch.struct_2bba= struct_2b9f;
			if( !isValidBound(boundObjs_2bb9, triggerVar_2ba8, true))
				continue;
			currMatch.triggerVar_2bbb= triggerVar_2ba8;
			if( !isValidBound(boundObjs_2bb9, unaryExprs_2bb1, true))
				continue;
			currMatch.unaryExprs_2bbc= unaryExprs_2bb1;
			if( !isValidBound(boundObjs_2bb9, currMember_2bb5, false))
				continue;
			currMatch.member_2bbd= currMember_2bb5;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetStructMembers_2b89::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.struct_2bba, currMatch.member_2bbd, currMatch.triggerVar_2bbb, currMatch.unaryExprs_2bbc);
	}
}

void GetStructMembers_2b89::outputAppender( const SFC::Struct& struct_2bbe, const SFC::LocalVar& member_2bc0, const SFC::LocalVar& triggerVar_2bc2, const SFC::UnaryExprs& unaryExprs_2bc4)
{
	_struct_2b94->push_back( struct_2bbe);
	_member_2b95->push_back( member_2bc0);
	_triggerVar_2b96->push_back( triggerVar_2bc2);
	_unaryExprs_2b97->push_back( unaryExprs_2bc4);
}

void GetStructMembers_2b89::sortOutputs()
{
	typedef std::multiset< SFC::LocalVar, std::pointer_to_binary_function< const SFC::LocalVar&, const SFC::LocalVar&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const SFC::LocalVar&, const SFC::LocalVar&, bool> ptr_StatementOrder( StatementOrder< SFC::LocalVar>);
	SortedSet_t sortedSet( ptr_StatementOrder);
	std::vector< int> permutationVector( _member_2b95->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _member_2b95->begin(); it!= _member_2b95->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( SFC::LocalVar::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _member_2b95->begin());
	// order rest of the containers
	permutate( permutationVector, *_struct_2b94);
	permutate( permutationVector, *_triggerVar_2b96);
	permutate( permutationVector, *_unaryExprs_2b97);
}

void SetMatrixCondition_2bd3::operator()( const Packets_t& dts_2bd4, const Packets_t& triggervars_2bd6, const Packets_t& conditions_2bd8, Packets_t& dts_2bda, Packets_t& triggervars_2bdb, Packets_t& conditions_2bdc)
{
#ifdef PRINT_INFO
	printLog( "SetMatrixCondition_2bd3" );
#endif
	_dt_2bdd= &dts_2bda;
	_triggervar_2bde= &triggervars_2bdb;
	_condition_2bdf= &conditions_2bdc;
	if( ( !dts_2bd4.empty())&& ( !triggervars_2bd6.empty())&& ( !conditions_2bd8.empty()))
		callMatrixCondition_2c0d( dts_2bd4, triggervars_2bd6, conditions_2bd8);
	_dt_2bdd->insert( _dt_2bdd->end(), dts_2bd4.begin(), dts_2bd4.end());
	_triggervar_2bde->insert( _triggervar_2bde->end(), triggervars_2bd6.begin(), triggervars_2bd6.end());
	_condition_2bdf->insert( _condition_2bdf->end(), conditions_2bd8.begin(), conditions_2bd8.end());
}

void SetMatrixCondition_2bd3::callMatrixCondition_2c0d( const Packets_t& dTs_2be1, const Packets_t& triggerVars_2be3, const Packets_t& conditions_2be5)
{
	MatrixCondition_2be0 matrixCondition_2be0;
	matrixCondition_2be0( dTs_2be1, triggerVars_2be3, conditions_2be5);
}

void MatrixCondition_2be0::operator()( const Packets_t& dTs_2be1, const Packets_t& triggerVars_2be3, const Packets_t& conditions_2be5)
{
#ifdef PRINT_INFO
	printLog( "MatrixCondition_2be0" );
#endif
	RTTGenerator::Instance()->generateRule(2719, "MatrixCondition");
	processInputPackets( dTs_2be1, triggerVars_2be3, conditions_2be5);
}

bool MatrixCondition_2be0::isInputUnique( const Udm::Object& dT_2beb, const Udm::Object& triggerVar_2bf4, const Udm::Object& condition_2bfd)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itDT_2bed= _dT_2be7.begin(), itTriggerVar_2bf6= _triggerVar_2bf0.begin(), itCondition_2bff= _condition_2bf9.begin(); itDT_2bed!= _dT_2be7.end(), itTriggerVar_2bf6!= _triggerVar_2bf0.end(), itCondition_2bff!= _condition_2bf9.end(); ++itDT_2bed, ++itTriggerVar_2bf6, ++itCondition_2bff)
	{
		if( ( *itDT_2bed== dT_2beb)&& ( *itTriggerVar_2bf6== triggerVar_2bf4)&& ( *itCondition_2bff== condition_2bfd))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_dT_2be7.push_back( dT_2beb);
		_triggerVar_2bf0.push_back( triggerVar_2bf4);
		_condition_2bf9.push_back( condition_2bfd);
	}
	return isUnique;
}

bool MatrixCondition_2be0::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool MatrixCondition_2be0::isGuardTrue( SFC::UserCode& Condition, SFC::DT& DT, SFC::LocalVar& TriggerVar)
{
	bool Gz_guard= false;
	Gz_guard = DT.type() != SFC::Struct::meta;;
	return Gz_guard;
}

void MatrixCondition_2be0::processInputPackets( const Packets_t& dTs_2be1, const Packets_t& triggerVars_2be3, const Packets_t& conditions_2be5)
{
	for( Packets_t::const_iterator itDT_2be8= dTs_2be1.begin(), itTriggerVar_2bf1= triggerVars_2be3.begin(), itCondition_2bfa= conditions_2be5.begin(); itDT_2be8!= dTs_2be1.end(), itTriggerVar_2bf1!= triggerVars_2be3.end(), itCondition_2bfa!= conditions_2be5.end(); ++itDT_2be8, ++itTriggerVar_2bf1, ++itCondition_2bfa)
	{
		bool isUnique= isInputUnique( *itDT_2be8, *itTriggerVar_2bf1, *itCondition_2bfa);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itDT_2be8, *itTriggerVar_2bf1, *itCondition_2bfa);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool MatrixCondition_2be0::patternMatcher( const Udm::Object& dT_2be9, const Udm::Object& triggerVar_2bf2, const Udm::Object& condition_2bfb)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( dT_2be9.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_2bee= SFC::DT::Cast( dT_2be9);
		if( false== Uml::IsDerivedFrom( triggerVar_2bf2.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_2bf7= SFC::LocalVar::Cast( triggerVar_2bf2);
		if( false== Uml::IsDerivedFrom( condition_2bfb.type(), SFC::UserCode::meta))
			continue;
		SFC::UserCode condition_2c00= SFC::UserCode::Cast( condition_2bfb);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2c05;
		if( !isValidBound(boundObjs_2c05, dT_2bee, true))
			continue;
		currMatch.dT_2c06= dT_2bee;
		if( !isValidBound(boundObjs_2c05, triggerVar_2bf7, true))
			continue;
		currMatch.triggerVar_2c07= triggerVar_2bf7;
		if( !isValidBound(boundObjs_2c05, condition_2c00, true))
			continue;
		currMatch.condition_2c08= condition_2c00;
		bool Gz_guard= isGuardTrue( currMatch.condition_2c08, currMatch.dT_2c06, currMatch.triggerVar_2c07);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void MatrixCondition_2be0::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ArgDeclRef newArgDeclRef_2c0c= SFC::ArgDeclRef::Create( currMatch.condition_2c08, SFC::UserCode::meta_codeexpr);
		newArgDeclRef_2c0c.argdecl()= currMatch.triggerVar_2c07;
	}
}

void CreateConditional_2c11::operator()( const Packets_t& subsystems_2c12, const Packets_t& triggerPorts_2c15, const Packets_t& dTs_2c18, const Packets_t& localVars_2c1b, const Packets_t& functions_2c1f, Packets_t& subsystems_2c14, Packets_t& charts_2c17, Packets_t& dTs_2c1a, Packets_t& triggerVars_2c1d, Packets_t& userCodes_2c1e, Packets_t& conditionalBlocks_2c21)
{
#ifdef PRINT_INFO
	printLog( "CreateConditional_2c11" );
#endif
	RTTGenerator::Instance()->generateRule(2726, "CreateConditional");
	_subsystem_2c22= &subsystems_2c14;
	_chart_2c23= &charts_2c17;
	_dT_2c24= &dTs_2c1a;
	_triggerVar_2c25= &triggerVars_2c1d;
	_userCode_2c26= &userCodes_2c1e;
	_conditionalBlock_2c27= &conditionalBlocks_2c21;
	processInputPackets( subsystems_2c12, triggerPorts_2c15, dTs_2c18, localVars_2c1b, functions_2c1f);
}

bool CreateConditional_2c11::isInputUnique( const Udm::Object& subsystem_2c2c, const Udm::Object& triggerPort_2c35, const Udm::Object& dT_2c3e, const Udm::Object& localVar_2c47, const Udm::Object& function_2c50)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_2c2e= _subsystem_2c28.begin(), itTriggerPort_2c37= _triggerPort_2c31.begin(), itDT_2c40= _dT_2c3a.begin(), itLocalVar_2c49= _localVar_2c43.begin(), itFunction_2c52= _function_2c4c.begin(); itSubsystem_2c2e!= _subsystem_2c28.end(), itTriggerPort_2c37!= _triggerPort_2c31.end(), itDT_2c40!= _dT_2c3a.end(), itLocalVar_2c49!= _localVar_2c43.end(), itFunction_2c52!= _function_2c4c.end(); ++itSubsystem_2c2e, ++itTriggerPort_2c37, ++itDT_2c40, ++itLocalVar_2c49, ++itFunction_2c52)
	{
		if( ( *itSubsystem_2c2e== subsystem_2c2c)&& ( *itTriggerPort_2c37== triggerPort_2c35)&& ( *itDT_2c40== dT_2c3e)&& ( *itLocalVar_2c49== localVar_2c47)&& ( *itFunction_2c52== function_2c50))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_2c28.push_back( subsystem_2c2c);
		_triggerPort_2c31.push_back( triggerPort_2c35);
		_dT_2c3a.push_back( dT_2c3e);
		_localVar_2c43.push_back( localVar_2c47);
		_function_2c4c.push_back( function_2c50);
	}
	return isUnique;
}

bool CreateConditional_2c11::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateConditional_2c11::processInputPackets( const Packets_t& subsystems_2c12, const Packets_t& triggerPorts_2c15, const Packets_t& dTs_2c18, const Packets_t& localVars_2c1b, const Packets_t& functions_2c1f)
{
	for( Packets_t::const_iterator itSubsystem_2c29= subsystems_2c12.begin(), itTriggerPort_2c32= triggerPorts_2c15.begin(), itDT_2c3b= dTs_2c18.begin(), itLocalVar_2c44= localVars_2c1b.begin(), itFunction_2c4d= functions_2c1f.begin(); itSubsystem_2c29!= subsystems_2c12.end(), itTriggerPort_2c32!= triggerPorts_2c15.end(), itDT_2c3b!= dTs_2c18.end(), itLocalVar_2c44!= localVars_2c1b.end(), itFunction_2c4d!= functions_2c1f.end(); ++itSubsystem_2c29, ++itTriggerPort_2c32, ++itDT_2c3b, ++itLocalVar_2c44, ++itFunction_2c4d)
	{
		bool isUnique= isInputUnique( *itSubsystem_2c29, *itTriggerPort_2c32, *itDT_2c3b, *itLocalVar_2c44, *itFunction_2c4d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_2c29, *itTriggerPort_2c32, *itDT_2c3b, *itLocalVar_2c44, *itFunction_2c4d);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateConditional_2c11::patternMatcher( const Udm::Object& subsystem_2c2a, const Udm::Object& triggerPort_2c33, const Udm::Object& dT_2c3c, const Udm::Object& localVar_2c45, const Udm::Object& function_2c4e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_2c2a.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_2c2f= CyberComposition::Simulink::Subsystem::Cast( subsystem_2c2a);
		if( false== Uml::IsDerivedFrom( triggerPort_2c33.type(), CyberComposition::Simulink::TriggerPort::meta))
			continue;
		CyberComposition::Simulink::TriggerPort triggerPort_2c38= CyberComposition::Simulink::TriggerPort::Cast( triggerPort_2c33);
		if( false== Uml::IsDerivedFrom( dT_2c3c.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_2c41= SFC::DT::Cast( dT_2c3c);
		if( false== Uml::IsDerivedFrom( localVar_2c45.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_2c4a= SFC::LocalVar::Cast( localVar_2c45);
		if( false== Uml::IsDerivedFrom( function_2c4e.type(), SFC::Function::meta))
			continue;
		SFC::Function function_2c53= SFC::Function::Cast( function_2c4e);
		Udm::Object triggerPortParent_2c55= triggerPort_2c38.container();
		if( false== Uml::IsDerivedFrom( triggerPortParent_2c55.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem chartTriggerPort_2c56= CyberComposition::Simulink::Subsystem::Cast( triggerPortParent_2c55);
		SFC::LocalVar triggerVar_2c57= localVar_2c4a.trigvar();
		if( !triggerVar_2c57)
			continue;
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2c5b;
		if( !isValidBound(boundObjs_2c5b, subsystem_2c2f, true))
			continue;
		currMatch.subsystem_2c5c= subsystem_2c2f;
		if( !isValidBound(boundObjs_2c5b, triggerPort_2c38, true))
			continue;
		currMatch.triggerPort_2c5d= triggerPort_2c38;
		if( !isValidBound(boundObjs_2c5b, dT_2c41, true))
			continue;
		currMatch.dT_2c5e= dT_2c41;
		if( !isValidBound(boundObjs_2c5b, localVar_2c4a, true))
			continue;
		currMatch.localVar_2c5f= localVar_2c4a;
		if( !isValidBound(boundObjs_2c5b, function_2c53, true))
			continue;
		currMatch.function_2c60= function_2c53;
		if( !isValidBound(boundObjs_2c5b, chartTriggerPort_2c56, false))
			continue;
		currMatch.chart_2c61= chartTriggerPort_2c56;
		if( !isValidBound(boundObjs_2c5b, triggerVar_2c57, false))
			continue;
		currMatch.triggerVar_2c62= triggerVar_2c57;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateConditional_2c11::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_2c63= SFC::ConditionalBlock::Create( currMatch.function_2c60, SFC::Function::meta_stmnt);
		SFC::UserCode newUserCode_2c64= SFC::UserCode::Create( newConditionalBlock_2c63, SFC::ConditionalBlock::meta_cond);
		CyberComposition::Simulink::Subsystem& Chart= currMatch.chart_2c61;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_2c63;
		SFC::DT& DT= currMatch.dT_2c5e;
		SFC::Function& Function= currMatch.function_2c60;
		SFC::LocalVar& LocalVar= currMatch.localVar_2c5f;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_2c5c;
		CyberComposition::Simulink::TriggerPort& TriggerPort= currMatch.triggerPort_2c5d;
		SFC::LocalVar& TriggerVar= currMatch.triggerVar_2c62;
		SFC::UserCode& UserCode= newUserCode_2c64;
		{
__int64 statementCount = Function.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		outputAppender( currMatch.subsystem_2c5c, currMatch.chart_2c61, currMatch.dT_2c5e, currMatch.triggerVar_2c62, newUserCode_2c64, newConditionalBlock_2c63);
	}
}

void CreateConditional_2c11::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_2c65, const CyberComposition::Simulink::Subsystem& chart_2c67, const SFC::DT& dT_2c69, const SFC::LocalVar& triggerVar_2c6b, const SFC::UserCode& userCode_2c6d, const SFC::ConditionalBlock& conditionalBlock_2c6f)
{
	_subsystem_2c22->push_back( subsystem_2c65);
	_chart_2c23->push_back( chart_2c67);
	_dT_2c24->push_back( dT_2c69);
	_triggerVar_2c25->push_back( triggerVar_2c6b);
	_userCode_2c26->push_back( userCode_2c6d);
	_conditionalBlock_2c27->push_back( conditionalBlock_2c6f);
}

void CreateAction_2ca9::operator()( const Packets_t& subsystems_2caa, const Packets_t& blocks_2cad, const Packets_t& functions_2cb0, Packets_t& subsystems_2cac, Packets_t& blocks_2caf, Packets_t& conditionalBlocks_2cb2)
{
#ifdef PRINT_INFO
	printLog( "CreateAction_2ca9" );
#endif
	RTTGenerator::Instance()->generateRule(2741, "CreateAction");
	_subsystem_2cb3= &subsystems_2cac;
	_block_2cb4= &blocks_2caf;
	_conditionalBlock_2cb5= &conditionalBlocks_2cb2;
	processInputPackets( subsystems_2caa, blocks_2cad, functions_2cb0);
}

bool CreateAction_2ca9::isInputUnique( const Udm::Object& subsystem_2cba, const Udm::Object& block_2cc3, const Udm::Object& function_2ccc)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_2cbc= _subsystem_2cb6.begin(), itBlock_2cc5= _block_2cbf.begin(), itFunction_2cce= _function_2cc8.begin(); itSubsystem_2cbc!= _subsystem_2cb6.end(), itBlock_2cc5!= _block_2cbf.end(), itFunction_2cce!= _function_2cc8.end(); ++itSubsystem_2cbc, ++itBlock_2cc5, ++itFunction_2cce)
	{
		if( ( *itSubsystem_2cbc== subsystem_2cba)&& ( *itBlock_2cc5== block_2cc3)&& ( *itFunction_2cce== function_2ccc))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_2cb6.push_back( subsystem_2cba);
		_block_2cbf.push_back( block_2cc3);
		_function_2cc8.push_back( function_2ccc);
	}
	return isUnique;
}

bool CreateAction_2ca9::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateAction_2ca9::processInputPackets( const Packets_t& subsystems_2caa, const Packets_t& blocks_2cad, const Packets_t& functions_2cb0)
{
	for( Packets_t::const_iterator itSubsystem_2cb7= subsystems_2caa.begin(), itBlock_2cc0= blocks_2cad.begin(), itFunction_2cc9= functions_2cb0.begin(); itSubsystem_2cb7!= subsystems_2caa.end(), itBlock_2cc0!= blocks_2cad.end(), itFunction_2cc9!= functions_2cb0.end(); ++itSubsystem_2cb7, ++itBlock_2cc0, ++itFunction_2cc9)
	{
		bool isUnique= isInputUnique( *itSubsystem_2cb7, *itBlock_2cc0, *itFunction_2cc9);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_2cb7, *itBlock_2cc0, *itFunction_2cc9);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateAction_2ca9::patternMatcher( const Udm::Object& subsystem_2cb8, const Udm::Object& block_2cc1, const Udm::Object& function_2cca)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_2cb8.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_2cbd= CyberComposition::Simulink::Subsystem::Cast( subsystem_2cb8);
		if( false== Uml::IsDerivedFrom( block_2cc1.type(), CyberComposition::Simulink::Block::meta))
			continue;
		CyberComposition::Simulink::Block block_2cc6= CyberComposition::Simulink::Block::Cast( block_2cc1);
		if( false== Uml::IsDerivedFrom( function_2cca.type(), SFC::Function::meta))
			continue;
		SFC::Function function_2ccf= SFC::Function::Cast( function_2cca);
		set< CyberComposition::Simulink::EnablePort> actionPorts_2cd1= block_2cc6.EnablePort_kind_children();
		for( set< CyberComposition::Simulink::EnablePort>::const_iterator itActionPort_2cd2= actionPorts_2cd1.begin(); itActionPort_2cd2!= actionPorts_2cd1.end(); ++itActionPort_2cd2)
		{
			CyberComposition::Simulink::EnablePort currActionPort_2cd3= *itActionPort_2cd2;
			SFC::ArgDeclBase argDeclBase_2cd4= currActionPort_2cd3.argdecl();
			if( !argDeclBase_2cd4)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2cd8;
			if( !isValidBound(boundObjs_2cd8, subsystem_2cbd, true))
				continue;
			currMatch.subsystem_2cd9= subsystem_2cbd;
			if( !isValidBound(boundObjs_2cd8, block_2cc6, true))
				continue;
			currMatch.block_2cda= block_2cc6;
			if( !isValidBound(boundObjs_2cd8, function_2ccf, true))
				continue;
			currMatch.function_2cdb= function_2ccf;
			if( !isValidBound(boundObjs_2cd8, currActionPort_2cd3, false))
				continue;
			currMatch.actionPort_2cdc= currActionPort_2cd3;
			if( !isValidBound(boundObjs_2cd8, argDeclBase_2cd4, false))
				continue;
			currMatch.argDeclBase_2cdd= argDeclBase_2cd4;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateAction_2ca9::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_2cde= SFC::ConditionalBlock::Create( currMatch.function_2cdb);
		SFC::UserCode newUserCode_2cdf= SFC::UserCode::Create( newConditionalBlock_2cde, SFC::ConditionalBlock::meta_cond);
		SFC::BinaryExprs newBinaryExprs_2ce0= SFC::BinaryExprs::Create( newUserCode_2cdf, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newArgDeclRef_2ce1= SFC::ArgDeclRef::Create( newBinaryExprs_2ce0, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newZero_2ce2= SFC::Int::Create( newBinaryExprs_2ce0, SFC::BinaryExprs::meta_rightexpr);
		CyberComposition::Simulink::EnablePort& ActionPort= currMatch.actionPort_2cdc;
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_2cdd;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_2ce1;
		SFC::BinaryExprs& BinaryExprs= newBinaryExprs_2ce0;
		CyberComposition::Simulink::Block& Block= currMatch.block_2cda;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_2cde;
		SFC::Function& Function= currMatch.function_2cdb;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_2cd9;
		SFC::UserCode& UserCode= newUserCode_2cdf;
		SFC::Int& Zero= newZero_2ce2;
		{
Zero.val() = 0;
};
		{
BinaryExprs.op() = ">";
};
		{
__int64 statementCount = Function.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		newArgDeclRef_2ce1.argdecl()= currMatch.argDeclBase_2cdd;
		outputAppender( currMatch.subsystem_2cd9, currMatch.block_2cda, newConditionalBlock_2cde);
	}
}

void CreateAction_2ca9::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_2ce3, const CyberComposition::Simulink::Block& block_2ce5, const SFC::ConditionalBlock& conditionalBlock_2ce7)
{
	_subsystem_2cb3->push_back( subsystem_2ce3);
	_block_2cb4->push_back( block_2ce5);
	_conditionalBlock_2cb5->push_back( conditionalBlock_2ce7);
}

void MakeArgDeclRef_2cf5::operator()( const Packets_t& systems_2cf6, const Packets_t& argPorts_2cf8, const Packets_t& argVals_2cfa)
{
#ifdef PRINT_INFO
	printLog( "MakeArgDeclRef_2cf5" );
#endif
	if( ( !systems_2cf6.empty())&& ( !argPorts_2cf8.empty())&& ( !argVals_2cfa.empty()))
		callCheckSigSrc_2de6( systems_2cf6, argPorts_2cf8, argVals_2cfa);
}

void MakeArgDeclRef_2cf5::callCheckSigSrc_2de6( const Packets_t& systems_2d29, const Packets_t& argPorts_2d2b, const Packets_t& argVals_2d2d)
{
	Packets_t systems_2d2f;
	Packets_t argPorts_2d30;
	Packets_t argVals_2d31;
	Packets_t systems_2d32;
	Packets_t argPorts_2d33;
	Packets_t argVals_2d34;
	CheckSigSrc_2d28 checkSigSrc_2d28;
	checkSigSrc_2d28( systems_2d29, argPorts_2d2b, argVals_2d2d, systems_2d2f, argPorts_2d30, argVals_2d31, systems_2d32, argPorts_2d33, argVals_2d34);
	if( ( !systems_2d2f.empty())&& ( !argPorts_2d30.empty())&& ( !argVals_2d31.empty()))
		callInpArgValTrigger_2dea( systems_2d2f, argPorts_2d30, argVals_2d31);
	if( ( !systems_2d32.empty())&& ( !argPorts_2d33.empty())&& ( !argVals_2d34.empty()))
		callInpArgVal_2dee( systems_2d32, argPorts_2d33, argVals_2d34);
}

void MakeArgDeclRef_2cf5::callInpArgValTrigger_2dea( const Packets_t& subsystems_2cfd, const Packets_t& triggerPorts_2cff, const Packets_t& argVals_2d01)
{
	InpArgValTrigger_2cfc inpArgValTrigger_2cfc;
	inpArgValTrigger_2cfc( subsystems_2cfd, triggerPorts_2cff, argVals_2d01);
}

void MakeArgDeclRef_2cf5::callInpArgVal_2dee( const Packets_t& subsystems_2dbb, const Packets_t& dstPorts_2dbd, const Packets_t& argVals_2dbf)
{
	InpArgVal_2dba inpArgVal_2dba;
	inpArgVal_2dba( subsystems_2dbb, dstPorts_2dbd, argVals_2dbf);
}

void InpArgValTrigger_2cfc::operator()( const Packets_t& subsystems_2cfd, const Packets_t& triggerPorts_2cff, const Packets_t& argVals_2d01)
{
#ifdef PRINT_INFO
	printLog( "InpArgValTrigger_2cfc" );
#endif
	RTTGenerator::Instance()->generateRule(4947, "InpArgValTrigger");
	processInputPackets( subsystems_2cfd, triggerPorts_2cff, argVals_2d01);
}

bool InpArgValTrigger_2cfc::isInputUnique( const Udm::Object& subsystem_2d07, const Udm::Object& triggerPort_2d10, const Udm::Object& argVal_2d19)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_2d09= _subsystem_2d03.begin(), itTriggerPort_2d12= _triggerPort_2d0c.begin(), itArgVal_2d1b= _argVal_2d15.begin(); itSubsystem_2d09!= _subsystem_2d03.end(), itTriggerPort_2d12!= _triggerPort_2d0c.end(), itArgVal_2d1b!= _argVal_2d15.end(); ++itSubsystem_2d09, ++itTriggerPort_2d12, ++itArgVal_2d1b)
	{
		if( ( *itSubsystem_2d09== subsystem_2d07)&& ( *itTriggerPort_2d12== triggerPort_2d10)&& ( *itArgVal_2d1b== argVal_2d19))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_2d03.push_back( subsystem_2d07);
		_triggerPort_2d0c.push_back( triggerPort_2d10);
		_argVal_2d15.push_back( argVal_2d19);
	}
	return isUnique;
}

bool InpArgValTrigger_2cfc::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void InpArgValTrigger_2cfc::processInputPackets( const Packets_t& subsystems_2cfd, const Packets_t& triggerPorts_2cff, const Packets_t& argVals_2d01)
{
	for( Packets_t::const_iterator itSubsystem_2d04= subsystems_2cfd.begin(), itTriggerPort_2d0d= triggerPorts_2cff.begin(), itArgVal_2d16= argVals_2d01.begin(); itSubsystem_2d04!= subsystems_2cfd.end(), itTriggerPort_2d0d!= triggerPorts_2cff.end(), itArgVal_2d16!= argVals_2d01.end(); ++itSubsystem_2d04, ++itTriggerPort_2d0d, ++itArgVal_2d16)
	{
		bool isUnique= isInputUnique( *itSubsystem_2d04, *itTriggerPort_2d0d, *itArgVal_2d16);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_2d04, *itTriggerPort_2d0d, *itArgVal_2d16);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InpArgValTrigger_2cfc::patternMatcher( const Udm::Object& subsystem_2d05, const Udm::Object& triggerPort_2d0e, const Udm::Object& argVal_2d17)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_2d05.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_2d0a= CyberComposition::Simulink::Subsystem::Cast( subsystem_2d05);
		if( false== Uml::IsDerivedFrom( triggerPort_2d0e.type(), CyberComposition::Simulink::TriggerPort::meta))
			continue;
		CyberComposition::Simulink::TriggerPort triggerPort_2d13= CyberComposition::Simulink::TriggerPort::Cast( triggerPort_2d0e);
		if( false== Uml::IsDerivedFrom( argVal_2d17.type(), SFC::ArgVal::meta))
			continue;
		SFC::ArgVal argVal_2d1c= SFC::ArgVal::Cast( argVal_2d17);
		SFC::LocalVar localVar_2d1e= triggerPort_2d13.memb();
		if( !localVar_2d1e)
			continue;
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2d22;
		if( !isValidBound(boundObjs_2d22, subsystem_2d0a, true))
			continue;
		currMatch.subsystem_2d23= subsystem_2d0a;
		if( !isValidBound(boundObjs_2d22, triggerPort_2d13, true))
			continue;
		currMatch.triggerPort_2d24= triggerPort_2d13;
		if( !isValidBound(boundObjs_2d22, argVal_2d1c, true))
			continue;
		currMatch.argVal_2d25= argVal_2d1c;
		if( !isValidBound(boundObjs_2d22, localVar_2d1e, false))
			continue;
		currMatch.localVar_2d26= localVar_2d1e;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void InpArgValTrigger_2cfc::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ArgDeclRef newDeclRef_2d27= SFC::ArgDeclRef::Create( currMatch.argVal_2d25, SFC::ArgVal::meta_argexpr);
		newDeclRef_2d27.argdecl()= currMatch.localVar_2d26;
	}
}

void CheckSigSrc_2d28::operator()( const Packets_t& systems_2d29, const Packets_t& argPorts_2d2b, const Packets_t& argVals_2d2d, Packets_t& systems_2d2f, Packets_t& argPorts_2d30, Packets_t& argVals_2d31, Packets_t& systems_2d32, Packets_t& argPorts_2d33, Packets_t& argVals_2d34)
{
#ifdef PRINT_INFO
	printLog( "CheckSigSrc_2d28" );
#endif
	_system_2d35= &systems_2d2f;
	_argPort_2d36= &argPorts_2d30;
	_argVal_2d37= &argVals_2d31;
	_system_2d38= &systems_2d32;
	_argPort_2d39= &argPorts_2d33;
	_argVal_2d3a= &argVals_2d34;
	for( Packets_t::const_iterator itsystem_2d3c= systems_2d29.begin(), itargPort_2d43= argPorts_2d2b.begin(), itargVal_2d4a= argVals_2d2d.begin(); itsystem_2d3c!= systems_2d29.end(), itargPort_2d43!= argPorts_2d2b.end(), itargVal_2d4a!= argVals_2d2d.end(); ++itsystem_2d3c, ++itargPort_2d43, ++itargVal_2d4a)
	{
		bool isUnique= isInputUnique( *itsystem_2d3c, *itargPort_2d43, *itargVal_2d4a);
		if( !isUnique)
			continue;
		Packets_t onesystem_2d40( 1, *itsystem_2d3c);
		Packets_t oneargPort_2d47( 1, *itargPort_2d43);
		Packets_t oneargVal_2d4e( 1, *itargVal_2d4a);
		executeOne( onesystem_2d40, oneargPort_2d47, oneargVal_2d4e);
	}
}

void CheckSigSrc_2d28::executeOne( const Packets_t& systems_2d29, const Packets_t& argPorts_2d2b, const Packets_t& argVals_2d2d)
{
	Packets_t subsystems_2d53;
	Packets_t triggerPorts_2d56;
	Packets_t argVals_2d59;
	IsTrigger_2d50 isTrigger_2d50;
	bool isMatchIsTrigger_2d50= isTrigger_2d50( systems_2d29, argPorts_2d2b, argVals_2d2d, subsystems_2d53, triggerPorts_2d56, argVals_2d59);
	_system_2d35->insert( _system_2d35->end(), subsystems_2d53.begin(), subsystems_2d53.end());
	_argPort_2d36->insert( _argPort_2d36->end(), triggerPorts_2d56.begin(), triggerPorts_2d56.end());
	_argVal_2d37->insert( _argVal_2d37->end(), argVals_2d59.begin(), argVals_2d59.end());
	if( isMatchIsTrigger_2d50)
		return;
	Packets_t subsystems_2d88;
	Packets_t dstPorts_2d8b;
	Packets_t argVals_2d8e;
	Otherwise_2d85 otherwise_2d85;
	bool isMatchOtherwise_2d85= otherwise_2d85( systems_2d29, argPorts_2d2b, argVals_2d2d, subsystems_2d88, dstPorts_2d8b, argVals_2d8e);
	_system_2d38->insert( _system_2d38->end(), subsystems_2d88.begin(), subsystems_2d88.end());
	_argPort_2d39->insert( _argPort_2d39->end(), dstPorts_2d8b.begin(), dstPorts_2d8b.end());
	_argVal_2d3a->insert( _argVal_2d3a->end(), argVals_2d8e.begin(), argVals_2d8e.end());
	if( isMatchOtherwise_2d85)
		return;
}

bool CheckSigSrc_2d28::isInputUnique( const Udm::Object& system_2d3d, const Udm::Object& argPort_2d44, const Udm::Object& argVal_2d4b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itsystem_2d3f= _system_2d3b.begin(), itargPort_2d46= _argPort_2d42.begin(), itargVal_2d4d= _argVal_2d49.begin(); itsystem_2d3f!= _system_2d3b.end(), itargPort_2d46!= _argPort_2d42.end(), itargVal_2d4d!= _argVal_2d49.end(); ++itsystem_2d3f, ++itargPort_2d46, ++itargVal_2d4d)
	{
		if( ( *itsystem_2d3f== system_2d3d)&& ( *itargPort_2d46== argPort_2d44)&& ( *itargVal_2d4d== argVal_2d4b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_system_2d3b.push_back( system_2d3d);
		_argPort_2d42.push_back( argPort_2d44);
		_argVal_2d49.push_back( argVal_2d4b);
	}
	return isUnique;
}

bool IsTrigger_2d50::operator()( const Packets_t& subsystems_2d51, const Packets_t& triggerPorts_2d54, const Packets_t& argVals_2d57, Packets_t& subsystems_2d53, Packets_t& triggerPorts_2d56, Packets_t& argVals_2d59)
{
#ifdef PRINT_INFO
	printLog( "IsTrigger_2d50" );
#endif
	_subsystem_2d5a= &subsystems_2d53;
	_triggerPort_2d5b= &triggerPorts_2d56;
	_argVal_2d5c= &argVals_2d59;
	processInputPackets( subsystems_2d51, triggerPorts_2d54, argVals_2d57);
	if( false== _matches.empty())
		return true;
	return false;
}

bool IsTrigger_2d50::isInputUnique( const Udm::Object& subsystem_2d61, const Udm::Object& triggerPort_2d6a, const Udm::Object& argVal_2d73)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_2d63= _subsystem_2d5d.begin(), itTriggerPort_2d6c= _triggerPort_2d66.begin(), itArgVal_2d75= _argVal_2d6f.begin(); itSubsystem_2d63!= _subsystem_2d5d.end(), itTriggerPort_2d6c!= _triggerPort_2d66.end(), itArgVal_2d75!= _argVal_2d6f.end(); ++itSubsystem_2d63, ++itTriggerPort_2d6c, ++itArgVal_2d75)
	{
		if( ( *itSubsystem_2d63== subsystem_2d61)&& ( *itTriggerPort_2d6c== triggerPort_2d6a)&& ( *itArgVal_2d75== argVal_2d73))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_2d5d.push_back( subsystem_2d61);
		_triggerPort_2d66.push_back( triggerPort_2d6a);
		_argVal_2d6f.push_back( argVal_2d73);
	}
	return isUnique;
}

bool IsTrigger_2d50::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void IsTrigger_2d50::processInputPackets( const Packets_t& subsystems_2d51, const Packets_t& triggerPorts_2d54, const Packets_t& argVals_2d57)
{
	for( Packets_t::const_iterator itSubsystem_2d5e= subsystems_2d51.begin(), itTriggerPort_2d67= triggerPorts_2d54.begin(), itArgVal_2d70= argVals_2d57.begin(); itSubsystem_2d5e!= subsystems_2d51.end(), itTriggerPort_2d67!= triggerPorts_2d54.end(), itArgVal_2d70!= argVals_2d57.end(); ++itSubsystem_2d5e, ++itTriggerPort_2d67, ++itArgVal_2d70)
	{
		bool isUnique= isInputUnique( *itSubsystem_2d5e, *itTriggerPort_2d67, *itArgVal_2d70);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_2d5e, *itTriggerPort_2d67, *itArgVal_2d70);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_2d7c, currMatch.triggerPort_2d7d, currMatch.argVal_2d7e);
	}
}

bool IsTrigger_2d50::patternMatcher( const Udm::Object& subsystem_2d5f, const Udm::Object& triggerPort_2d68, const Udm::Object& argVal_2d71)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_2d5f.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_2d64= CyberComposition::Simulink::Subsystem::Cast( subsystem_2d5f);
		if( false== Uml::IsDerivedFrom( triggerPort_2d68.type(), CyberComposition::Simulink::TriggerPort::meta))
			continue;
		CyberComposition::Simulink::TriggerPort triggerPort_2d6d= CyberComposition::Simulink::TriggerPort::Cast( triggerPort_2d68);
		if( false== Uml::IsDerivedFrom( argVal_2d71.type(), SFC::ArgVal::meta))
			continue;
		SFC::ArgVal argVal_2d76= SFC::ArgVal::Cast( argVal_2d71);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2d7b;
		if( !isValidBound(boundObjs_2d7b, subsystem_2d64, true))
			continue;
		currMatch.subsystem_2d7c= subsystem_2d64;
		if( !isValidBound(boundObjs_2d7b, triggerPort_2d6d, true))
			continue;
		currMatch.triggerPort_2d7d= triggerPort_2d6d;
		if( !isValidBound(boundObjs_2d7b, argVal_2d76, true))
			continue;
		currMatch.argVal_2d7e= argVal_2d76;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void IsTrigger_2d50::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_2d7f, const CyberComposition::Simulink::TriggerPort& triggerPort_2d81, const SFC::ArgVal& argVal_2d83)
{
	_subsystem_2d5a->push_back( subsystem_2d7f);
	_triggerPort_2d5b->push_back( triggerPort_2d81);
	_argVal_2d5c->push_back( argVal_2d83);
}

bool Otherwise_2d85::operator()( const Packets_t& subsystems_2d86, const Packets_t& dstPorts_2d89, const Packets_t& argVals_2d8c, Packets_t& subsystems_2d88, Packets_t& dstPorts_2d8b, Packets_t& argVals_2d8e)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_2d85" );
#endif
	_subsystem_2d8f= &subsystems_2d88;
	_dstPort_2d90= &dstPorts_2d8b;
	_argVal_2d91= &argVals_2d8e;
	processInputPackets( subsystems_2d86, dstPorts_2d89, argVals_2d8c);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_2d85::isInputUnique( const Udm::Object& subsystem_2d96, const Udm::Object& dstPort_2d9f, const Udm::Object& argVal_2da8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_2d98= _subsystem_2d92.begin(), itDstPort_2da1= _dstPort_2d9b.begin(), itArgVal_2daa= _argVal_2da4.begin(); itSubsystem_2d98!= _subsystem_2d92.end(), itDstPort_2da1!= _dstPort_2d9b.end(), itArgVal_2daa!= _argVal_2da4.end(); ++itSubsystem_2d98, ++itDstPort_2da1, ++itArgVal_2daa)
	{
		if( ( *itSubsystem_2d98== subsystem_2d96)&& ( *itDstPort_2da1== dstPort_2d9f)&& ( *itArgVal_2daa== argVal_2da8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_2d92.push_back( subsystem_2d96);
		_dstPort_2d9b.push_back( dstPort_2d9f);
		_argVal_2da4.push_back( argVal_2da8);
	}
	return isUnique;
}

bool Otherwise_2d85::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_2d85::processInputPackets( const Packets_t& subsystems_2d86, const Packets_t& dstPorts_2d89, const Packets_t& argVals_2d8c)
{
	for( Packets_t::const_iterator itSubsystem_2d93= subsystems_2d86.begin(), itDstPort_2d9c= dstPorts_2d89.begin(), itArgVal_2da5= argVals_2d8c.begin(); itSubsystem_2d93!= subsystems_2d86.end(), itDstPort_2d9c!= dstPorts_2d89.end(), itArgVal_2da5!= argVals_2d8c.end(); ++itSubsystem_2d93, ++itDstPort_2d9c, ++itArgVal_2da5)
	{
		bool isUnique= isInputUnique( *itSubsystem_2d93, *itDstPort_2d9c, *itArgVal_2da5);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_2d93, *itDstPort_2d9c, *itArgVal_2da5);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_2db1, currMatch.dstPort_2db2, currMatch.argVal_2db3);
	}
}

bool Otherwise_2d85::patternMatcher( const Udm::Object& subsystem_2d94, const Udm::Object& dstPort_2d9d, const Udm::Object& argVal_2da6)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_2d94.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_2d99= CyberComposition::Simulink::Subsystem::Cast( subsystem_2d94);
		if( false== Uml::IsDerivedFrom( dstPort_2d9d.type(), CyberComposition::Simulink::SF_Port::meta))
			continue;
		CyberComposition::Simulink::SF_Port dstPort_2da2= CyberComposition::Simulink::SF_Port::Cast( dstPort_2d9d);
		if( false== Uml::IsDerivedFrom( argVal_2da6.type(), SFC::ArgVal::meta))
			continue;
		SFC::ArgVal argVal_2dab= SFC::ArgVal::Cast( argVal_2da6);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2db0;
		if( !isValidBound(boundObjs_2db0, subsystem_2d99, true))
			continue;
		currMatch.subsystem_2db1= subsystem_2d99;
		if( !isValidBound(boundObjs_2db0, dstPort_2da2, true))
			continue;
		currMatch.dstPort_2db2= dstPort_2da2;
		if( !isValidBound(boundObjs_2db0, argVal_2dab, true))
			continue;
		currMatch.argVal_2db3= argVal_2dab;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_2d85::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_2db4, const CyberComposition::Simulink::SF_Port& dstPort_2db6, const SFC::ArgVal& argVal_2db8)
{
	_subsystem_2d8f->push_back( subsystem_2db4);
	_dstPort_2d90->push_back( dstPort_2db6);
	_argVal_2d91->push_back( argVal_2db8);
}

void InpArgVal_2dba::operator()( const Packets_t& subsystems_2dbb, const Packets_t& dstPorts_2dbd, const Packets_t& argVals_2dbf)
{
#ifdef PRINT_INFO
	printLog( "InpArgVal_2dba" );
#endif
	RTTGenerator::Instance()->generateRule(4974, "InpArgVal");
	processInputPackets( subsystems_2dbb, dstPorts_2dbd, argVals_2dbf);
}

bool InpArgVal_2dba::isInputUnique( const Udm::Object& subsystem_2dc5, const Udm::Object& dstPort_2dce, const Udm::Object& argVal_2dd7)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_2dc7= _subsystem_2dc1.begin(), itDstPort_2dd0= _dstPort_2dca.begin(), itArgVal_2dd9= _argVal_2dd3.begin(); itSubsystem_2dc7!= _subsystem_2dc1.end(), itDstPort_2dd0!= _dstPort_2dca.end(), itArgVal_2dd9!= _argVal_2dd3.end(); ++itSubsystem_2dc7, ++itDstPort_2dd0, ++itArgVal_2dd9)
	{
		if( ( *itSubsystem_2dc7== subsystem_2dc5)&& ( *itDstPort_2dd0== dstPort_2dce)&& ( *itArgVal_2dd9== argVal_2dd7))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_2dc1.push_back( subsystem_2dc5);
		_dstPort_2dca.push_back( dstPort_2dce);
		_argVal_2dd3.push_back( argVal_2dd7);
	}
	return isUnique;
}

bool InpArgVal_2dba::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void InpArgVal_2dba::processInputPackets( const Packets_t& subsystems_2dbb, const Packets_t& dstPorts_2dbd, const Packets_t& argVals_2dbf)
{
	for( Packets_t::const_iterator itSubsystem_2dc2= subsystems_2dbb.begin(), itDstPort_2dcb= dstPorts_2dbd.begin(), itArgVal_2dd4= argVals_2dbf.begin(); itSubsystem_2dc2!= subsystems_2dbb.end(), itDstPort_2dcb!= dstPorts_2dbd.end(), itArgVal_2dd4!= argVals_2dbf.end(); ++itSubsystem_2dc2, ++itDstPort_2dcb, ++itArgVal_2dd4)
	{
		bool isUnique= isInputUnique( *itSubsystem_2dc2, *itDstPort_2dcb, *itArgVal_2dd4);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_2dc2, *itDstPort_2dcb, *itArgVal_2dd4);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InpArgVal_2dba::patternMatcher( const Udm::Object& subsystem_2dc3, const Udm::Object& dstPort_2dcc, const Udm::Object& argVal_2dd5)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_2dc3.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_2dc8= CyberComposition::Simulink::Subsystem::Cast( subsystem_2dc3);
		if( false== Uml::IsDerivedFrom( dstPort_2dcc.type(), CyberComposition::Simulink::SF_Port::meta))
			continue;
		CyberComposition::Simulink::SF_Port dstPort_2dd1= CyberComposition::Simulink::SF_Port::Cast( dstPort_2dcc);
		if( false== Uml::IsDerivedFrom( argVal_2dd5.type(), SFC::ArgVal::meta))
			continue;
		SFC::ArgVal argVal_2dda= SFC::ArgVal::Cast( argVal_2dd5);
		SFC::ArgDeclBase argDeclBase_2ddc= dstPort_2dd1.argdecl();
		if( !argDeclBase_2ddc)
			continue;
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2de0;
		if( !isValidBound(boundObjs_2de0, subsystem_2dc8, true))
			continue;
		currMatch.subsystem_2de1= subsystem_2dc8;
		if( !isValidBound(boundObjs_2de0, dstPort_2dd1, true))
			continue;
		currMatch.dstPort_2de2= dstPort_2dd1;
		if( !isValidBound(boundObjs_2de0, argVal_2dda, true))
			continue;
		currMatch.argVal_2de3= argVal_2dda;
		if( !isValidBound(boundObjs_2de0, argDeclBase_2ddc, false))
			continue;
		currMatch.argDeclBase_2de4= argDeclBase_2ddc;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void InpArgVal_2dba::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ArgDeclRef newDeclRef_2de5= SFC::ArgDeclRef::Create( currMatch.argVal_2de3, SFC::ArgVal::meta_argexpr);
		newDeclRef_2de5.argdecl()= currMatch.argDeclBase_2de4;
	}
}

void PrimitiveChildBlock_2e02::operator()( const Packets_t& childPrimitives_2e03, const Packets_t& systemFunctions_2e05)
{
#ifdef PRINT_INFO
	printLog( "PrimitiveChildBlock_2e02" );
#endif
	if( ( !childPrimitives_2e03.empty())&& ( !systemFunctions_2e05.empty()))
		callCreateCGCall_3053( childPrimitives_2e03, systemFunctions_2e05);
}

void PrimitiveChildBlock_2e02::callCreateCGCall_3053( const Packets_t& childPrimitives_2e08, const Packets_t& systemFunctions_2e0a)
{
	Packets_t childPrimitives_2e0c;
	Packets_t systemFunctions_2e0d;
	CreateCGCall_2e07 createCGCall_2e07;
	createCGCall_2e07( childPrimitives_2e08, systemFunctions_2e0a, childPrimitives_2e0c, systemFunctions_2e0d);
	if( ( !childPrimitives_2e0c.empty())&& ( !systemFunctions_2e0d.empty()))
		callCallCG_3056( childPrimitives_2e0c, systemFunctions_2e0d);
}

void PrimitiveChildBlock_2e02::callCallCG_3056( const Packets_t& primitives_2f32, const Packets_t& compoundStatements_2f35)
{
	Packets_t primitives_2f34;
	Packets_t compoundStatements_2f37;
	CallCG_2f31 callCG_2f31;
	callCG_2f31( primitives_2f32, compoundStatements_2f35, primitives_2f34, compoundStatements_2f37);
	if( ( !primitives_2f34.empty())&& ( !compoundStatements_2f37.empty()))
		callSetupIfVar_3059( primitives_2f34, compoundStatements_2f37);
}

void PrimitiveChildBlock_2e02::callSetupIfVar_3059( const Packets_t& childPrimitives_2f53, const Packets_t& systemFunctions_2f55)
{
	SetupIfVar_2f52 setupIfVar_2f52;
	setupIfVar_2f52( childPrimitives_2f53, systemFunctions_2f55);
}

void CreateCGCall_2e07::operator()( const Packets_t& childPrimitives_2e08, const Packets_t& systemFunctions_2e0a, Packets_t& childPrimitives_2e0c, Packets_t& systemFunctions_2e0d)
{
#ifdef PRINT_INFO
	printLog( "CreateCGCall_2e07" );
#endif
	_childPrimitive_2e0e= &childPrimitives_2e0c;
	_systemFunction_2e0f= &systemFunctions_2e0d;
	if( ( !childPrimitives_2e08.empty())&& ( !systemFunctions_2e0a.empty()))
		callInitEBCall_2f25( childPrimitives_2e08, systemFunctions_2e0a);
	_childPrimitive_2e0e->insert( _childPrimitive_2e0e->end(), childPrimitives_2e08.begin(), childPrimitives_2e08.end());
	_systemFunction_2e0f->insert( _systemFunction_2e0f->end(), systemFunctions_2e0a.begin(), systemFunctions_2e0a.end());
}

void CreateCGCall_2e07::callInitEBCall_2f25( const Packets_t& primitives_2e11, const Packets_t& parents_2e14)
{
	Packets_t primitives_2e13;
	InitEBCall_2e10 initEBCall_2e10;
	initEBCall_2e10( primitives_2e11, parents_2e14, primitives_2e13);
	if( ( !primitives_2e13.empty()))
		callGetSortedOutPorts_2f28( primitives_2e13);
	if( ( !primitives_2e13.empty()))
		callMapParams_2f2a( primitives_2e13);
	if( ( !primitives_2e13.empty()))
		callGetInputs_2f2c( primitives_2e13);
}

void CreateCGCall_2e07::callGetSortedOutPorts_2f28( const Packets_t& functions_2e30)
{
	Packets_t functions_2e32;
	Packets_t outputPorts_2e33;
	GetSortedOutPorts_2e2f getSortedOutPorts_2e2f;
	getSortedOutPorts_2e2f( functions_2e30, functions_2e32, outputPorts_2e33);
	if( ( !functions_2e32.empty())&& ( !outputPorts_2e33.empty()))
		callListOutPorts_2f2e( functions_2e32, outputPorts_2e33);
}

void CreateCGCall_2e07::callMapParams_2f2a( const Packets_t& primitives_2e4d)
{
	MapParams_2e4c mapParams_2e4c;
	mapParams_2e4c( primitives_2e4d);
}

void CreateCGCall_2e07::callGetInputs_2f2c( const Packets_t& childPrimitives_2e81)
{
	GetInputs_2e80 getInputs_2e80;
	getInputs_2e80( childPrimitives_2e81);
}

void CreateCGCall_2e07::callListOutPorts_2f2e( const Packets_t& primitives_2e62, const Packets_t& outputPorts_2e64)
{
	ListOutPorts_2e61 listOutPorts_2e61;
	listOutPorts_2e61( primitives_2e62, outputPorts_2e64);
}

void InitEBCall_2e10::operator()( const Packets_t& primitives_2e11, const Packets_t& parents_2e14, Packets_t& primitives_2e13)
{
#ifdef PRINT_INFO
	printLog( "InitEBCall_2e10" );
#endif
	RTTGenerator::Instance()->generateRule(2771, "InitEBCall");
	_primitive_2e16= &primitives_2e13;
	processInputPackets( primitives_2e11, parents_2e14);
	forwardInputs( );
}

bool InitEBCall_2e10::isInputUnique( const Udm::Object& primitive_2e1b, const Udm::Object& parent_2e24)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itPrimitive_2e1d= _primitive_2e17.begin(), itParent_2e26= _parent_2e20.begin(); itPrimitive_2e1d!= _primitive_2e17.end(), itParent_2e26!= _parent_2e20.end(); ++itPrimitive_2e1d, ++itParent_2e26)
	{
		if( ( *itPrimitive_2e1d== primitive_2e1b)&& ( *itParent_2e26== parent_2e24))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_primitive_2e17.push_back( primitive_2e1b);
		_parent_2e20.push_back( parent_2e24);
	}
	return isUnique;
}

bool InitEBCall_2e10::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void InitEBCall_2e10::processInputPackets( const Packets_t& primitives_2e11, const Packets_t& parents_2e14)
{
	for( Packets_t::const_iterator itPrimitive_2e18= primitives_2e11.begin(), itParent_2e21= parents_2e14.begin(); itPrimitive_2e18!= primitives_2e11.end(), itParent_2e21!= parents_2e14.end(); ++itPrimitive_2e18, ++itParent_2e21)
	{
		bool isUnique= isInputUnique( *itPrimitive_2e18, *itParent_2e21);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itPrimitive_2e18, *itParent_2e21);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool InitEBCall_2e10::patternMatcher( const Udm::Object& primitive_2e19, const Udm::Object& parent_2e22)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( primitive_2e19.type(), CyberComposition::Simulink::Primitive::meta))
			continue;
		CyberComposition::Simulink::Primitive primitive_2e1e= CyberComposition::Simulink::Primitive::Cast( primitive_2e19);
		if( false== Uml::IsDerivedFrom( parent_2e22.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement parent_2e27= SFC::CompoundStatement::Cast( parent_2e22);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2e2c;
		if( !isValidBound(boundObjs_2e2c, primitive_2e1e, true))
			continue;
		currMatch.primitive_2e2d= primitive_2e1e;
		if( !isValidBound(boundObjs_2e2c, parent_2e27, true))
			continue;
		currMatch.parent_2e2e= parent_2e27;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void InitEBCall_2e10::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::CompoundStatement& Parent= currMatch.parent_2e2e;
		CyberComposition::Simulink::Primitive& Primitive= currMatch.primitive_2e2d;
		{
CodeGenerator::getSingleton().getBlockSetup( Primitive ).setContext( Parent );
};
	}
}

void InitEBCall_2e10::forwardInputs()
{
	*_primitive_2e16= _primitive_2e17;
}

void GetSortedOutPorts_2e2f::operator()( const Packets_t& functions_2e30, Packets_t& functions_2e32, Packets_t& outputPorts_2e33)
{
#ifdef PRINT_INFO
	printLog( "GetSortedOutPorts_2e2f" );
#endif
	RTTGenerator::Instance()->generateRule(2775, "GetSortedOutPorts");
	_function_2e34= &functions_2e32;
	_outputPort_2e35= &outputPorts_2e33;
	processInputPackets( functions_2e30);
	sortOutputs( );
}

bool GetSortedOutPorts_2e2f::isInputUnique( const Udm::Object& function_2e3a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itFunction_2e3c= _function_2e36.begin(); itFunction_2e3c!= _function_2e36.end(); ++itFunction_2e3c)
	{
		if( ( *itFunction_2e3c== function_2e3a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_function_2e36.push_back( function_2e3a);
	return isUnique;
}

bool GetSortedOutPorts_2e2f::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetSortedOutPorts_2e2f::processInputPackets( const Packets_t& functions_2e30)
{
	for( Packets_t::const_iterator itFunction_2e37= functions_2e30.begin(); itFunction_2e37!= functions_2e30.end(); ++itFunction_2e37)
	{
		bool isUnique= isInputUnique( *itFunction_2e37);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itFunction_2e37);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetSortedOutPorts_2e2f::patternMatcher( const Udm::Object& function_2e38)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( function_2e38.type(), CyberComposition::Simulink::Primitive::meta))
			continue;
		CyberComposition::Simulink::Primitive function_2e3d= CyberComposition::Simulink::Primitive::Cast( function_2e38);
		set< CyberComposition::Simulink::OutputPort> outputPorts_2e3f= function_2e3d.OutputPort_kind_children();
		for( set< CyberComposition::Simulink::OutputPort>::const_iterator itOutputPort_2e40= outputPorts_2e3f.begin(); itOutputPort_2e40!= outputPorts_2e3f.end(); ++itOutputPort_2e40)
		{
			CyberComposition::Simulink::OutputPort currOutputPort_2e41= *itOutputPort_2e40;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2e45;
			if( !isValidBound(boundObjs_2e45, function_2e3d, true))
				continue;
			currMatch.function_2e46= function_2e3d;
			if( !isValidBound(boundObjs_2e45, currOutputPort_2e41, false))
				continue;
			currMatch.outputPort_2e47= currOutputPort_2e41;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetSortedOutPorts_2e2f::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.function_2e46, currMatch.outputPort_2e47);
	}
}

void GetSortedOutPorts_2e2f::outputAppender( const CyberComposition::Simulink::Primitive& function_2e48, const CyberComposition::Simulink::OutputPort& outputPort_2e4a)
{
	_function_2e34->push_back( function_2e48);
	_outputPort_2e35->push_back( outputPort_2e4a);
}

void GetSortedOutPorts_2e2f::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::OutputPort, std::pointer_to_binary_function< const CyberComposition::Simulink::OutputPort&, const CyberComposition::Simulink::OutputPort&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::OutputPort&, const CyberComposition::Simulink::OutputPort&, bool> ptr_PortOrder( PortOrder< CyberComposition::Simulink::OutputPort>);
	SortedSet_t sortedSet( ptr_PortOrder);
	std::vector< int> permutationVector( _outputPort_2e35->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _outputPort_2e35->begin(); it!= _outputPort_2e35->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::OutputPort::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _outputPort_2e35->begin());
	// order rest of the containers
	permutate( permutationVector, *_function_2e34);
}

void MapParams_2e4c::operator()( const Packets_t& primitives_2e4d)
{
#ifdef PRINT_INFO
	printLog( "MapParams_2e4c" );
#endif
	RTTGenerator::Instance()->generateRule(2779, "MapParams");
	processInputPackets( primitives_2e4d);
}

bool MapParams_2e4c::isInputUnique( const Udm::Object& primitive_2e53)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itPrimitive_2e55= _primitive_2e4f.begin(); itPrimitive_2e55!= _primitive_2e4f.end(); ++itPrimitive_2e55)
	{
		if( ( *itPrimitive_2e55== primitive_2e53))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_primitive_2e4f.push_back( primitive_2e53);
	return isUnique;
}

bool MapParams_2e4c::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void MapParams_2e4c::processInputPackets( const Packets_t& primitives_2e4d)
{
	for( Packets_t::const_iterator itPrimitive_2e50= primitives_2e4d.begin(); itPrimitive_2e50!= primitives_2e4d.end(); ++itPrimitive_2e50)
	{
		bool isUnique= isInputUnique( *itPrimitive_2e50);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itPrimitive_2e50);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool MapParams_2e4c::patternMatcher( const Udm::Object& primitive_2e51)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( primitive_2e51.type(), CyberComposition::Simulink::Primitive::meta))
			continue;
		CyberComposition::Simulink::Primitive primitive_2e56= CyberComposition::Simulink::Primitive::Cast( primitive_2e51);
		set< CyberComposition::Simulink::SF_Parameter> parameters_2e58= primitive_2e56.SF_Parameter_kind_children();
		for( set< CyberComposition::Simulink::SF_Parameter>::const_iterator itParameter_2e59= parameters_2e58.begin(); itParameter_2e59!= parameters_2e58.end(); ++itParameter_2e59)
		{
			CyberComposition::Simulink::SF_Parameter currParameter_2e5a= *itParameter_2e59;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2e5e;
			if( !isValidBound(boundObjs_2e5e, primitive_2e56, true))
				continue;
			currMatch.primitive_2e5f= primitive_2e56;
			if( !isValidBound(boundObjs_2e5e, currParameter_2e5a, false))
				continue;
			currMatch.parameter_2e60= currParameter_2e5a;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void MapParams_2e4c::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		CyberComposition::Simulink::SF_Parameter& Parameter= currMatch.parameter_2e60;
		CyberComposition::Simulink::Primitive& Primitive= currMatch.primitive_2e5f;
		{
CodeGenerator::getSingleton().getBlockSetup( Primitive ).addParameter( Parameter );
};
	}
}

void ListOutPorts_2e61::operator()( const Packets_t& primitives_2e62, const Packets_t& outputPorts_2e64)
{
#ifdef PRINT_INFO
	printLog( "ListOutPorts_2e61" );
#endif
	RTTGenerator::Instance()->generateRule(2784, "ListOutPorts");
	processInputPackets( primitives_2e62, outputPorts_2e64);
}

bool ListOutPorts_2e61::isInputUnique( const Udm::Object& primitive_2e6a, const Udm::Object& outputPort_2e73)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itPrimitive_2e6c= _primitive_2e66.begin(), itOutputPort_2e75= _outputPort_2e6f.begin(); itPrimitive_2e6c!= _primitive_2e66.end(), itOutputPort_2e75!= _outputPort_2e6f.end(); ++itPrimitive_2e6c, ++itOutputPort_2e75)
	{
		if( ( *itPrimitive_2e6c== primitive_2e6a)&& ( *itOutputPort_2e75== outputPort_2e73))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_primitive_2e66.push_back( primitive_2e6a);
		_outputPort_2e6f.push_back( outputPort_2e73);
	}
	return isUnique;
}

bool ListOutPorts_2e61::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void ListOutPorts_2e61::processInputPackets( const Packets_t& primitives_2e62, const Packets_t& outputPorts_2e64)
{
	for( Packets_t::const_iterator itPrimitive_2e67= primitives_2e62.begin(), itOutputPort_2e70= outputPorts_2e64.begin(); itPrimitive_2e67!= primitives_2e62.end(), itOutputPort_2e70!= outputPorts_2e64.end(); ++itPrimitive_2e67, ++itOutputPort_2e70)
	{
		bool isUnique= isInputUnique( *itPrimitive_2e67, *itOutputPort_2e70);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itPrimitive_2e67, *itOutputPort_2e70);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ListOutPorts_2e61::patternMatcher( const Udm::Object& primitive_2e68, const Udm::Object& outputPort_2e71)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( primitive_2e68.type(), CyberComposition::Simulink::Primitive::meta))
			continue;
		CyberComposition::Simulink::Primitive primitive_2e6d= CyberComposition::Simulink::Primitive::Cast( primitive_2e68);
		if( false== Uml::IsDerivedFrom( outputPort_2e71.type(), CyberComposition::Simulink::OutputPort::meta))
			continue;
		CyberComposition::Simulink::OutputPort outputPort_2e76= CyberComposition::Simulink::OutputPort::Cast( outputPort_2e71);
		SFC::ArgDeclBase argDeclBase_2e78= outputPort_2e76.argdecl();
		if( !argDeclBase_2e78)
			continue;
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2e7c;
		if( !isValidBound(boundObjs_2e7c, primitive_2e6d, true))
			continue;
		currMatch.primitive_2e7d= primitive_2e6d;
		if( !isValidBound(boundObjs_2e7c, outputPort_2e76, true))
			continue;
		currMatch.outputPort_2e7e= outputPort_2e76;
		if( !isValidBound(boundObjs_2e7c, argDeclBase_2e78, false))
			continue;
		currMatch.argDeclBase_2e7f= argDeclBase_2e78;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void ListOutPorts_2e61::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_2e7f;
		CyberComposition::Simulink::OutputPort& OutputPort= currMatch.outputPort_2e7e;
		CyberComposition::Simulink::Primitive& Primitive= currMatch.primitive_2e7d;
		{
CodeGenerator::getSingleton().getBlockSetup( Primitive ).addOutput( ArgDeclBase );
};
	}
}

void GetInputs_2e80::operator()( const Packets_t& childPrimitives_2e81)
{
#ifdef PRINT_INFO
	printLog( "GetInputs_2e80" );
#endif
	if( ( !childPrimitives_2e81.empty()))
		callProcessMerge_2f21( childPrimitives_2e81);
}

void GetInputs_2e80::callProcessMerge_2f21( const Packets_t& childPrimitives_2e84)
{
	Packets_t childPrimitives_2e86;
	ProcessMerge_2e83 processMerge_2e83;
	processMerge_2e83( childPrimitives_2e84, childPrimitives_2e86);
	if( ( !childPrimitives_2e86.empty()))
		callGetInputPorts_2f23( childPrimitives_2e86);
}

void GetInputs_2e80::callGetInputPorts_2f23( const Packets_t& childPrimitives_2ede)
{
	GetInputPorts_2edd getInputPorts_2edd;
	getInputPorts_2edd( childPrimitives_2ede);
}

void ProcessMerge_2e83::operator()( const Packets_t& childPrimitives_2e84, Packets_t& childPrimitives_2e86)
{
#ifdef PRINT_INFO
	printLog( "ProcessMerge_2e83" );
#endif
	_childPrimitive_2e87= &childPrimitives_2e86;
	_childPrimitive_2e87->insert( _childPrimitive_2e87->end(), childPrimitives_2e84.begin(), childPrimitives_2e84.end());
	if( ( !childPrimitives_2e84.empty()))
		callGetMergeBlocks_2ed9( childPrimitives_2e84);
}

void ProcessMerge_2e83::callGetMergeBlocks_2ed9( const Packets_t& childPrimitives_2e89)
{
	Packets_t childPrimitives_2e8b;
	GetMergeBlocks_2e88 getMergeBlocks_2e88;
	getMergeBlocks_2e88( childPrimitives_2e89, childPrimitives_2e8b);
	if( ( !childPrimitives_2e8b.empty()))
		callMergeAsSwitch_2edb( childPrimitives_2e8b);
}

void ProcessMerge_2e83::callMergeAsSwitch_2edb( const Packets_t& primitives_2eab)
{
	MergeAsSwitch_2eaa mergeAsSwitch_2eaa;
	mergeAsSwitch_2eaa( primitives_2eab);
}

void GetMergeBlocks_2e88::operator()( const Packets_t& childPrimitives_2e89, Packets_t& childPrimitives_2e8b)
{
#ifdef PRINT_INFO
	printLog( "GetMergeBlocks_2e88" );
#endif
	_childPrimitive_2e8c= &childPrimitives_2e8b;
	for( Packets_t::const_iterator itchildPrimitive_2e8e= childPrimitives_2e89.begin(); itchildPrimitive_2e8e!= childPrimitives_2e89.end(); ++itchildPrimitive_2e8e)
	{
		bool isUnique= isInputUnique( *itchildPrimitive_2e8e);
		if( !isUnique)
			continue;
		Packets_t onechildPrimitive_2e92( 1, *itchildPrimitive_2e8e);
		executeOne( onechildPrimitive_2e92);
	}
}

void GetMergeBlocks_2e88::executeOne( const Packets_t& childPrimitives_2e89)
{
	Packets_t primitives_2e97;
	MergeBlocksOnly_2e94 mergeBlocksOnly_2e94;
	bool isMatchMergeBlocksOnly_2e94= mergeBlocksOnly_2e94( childPrimitives_2e89, primitives_2e97);
	_childPrimitive_2e8c->insert( _childPrimitive_2e8c->end(), primitives_2e97.begin(), primitives_2e97.end());
}

bool GetMergeBlocks_2e88::isInputUnique( const Udm::Object& childPrimitive_2e8f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itchildPrimitive_2e91= _childPrimitive_2e8d.begin(); itchildPrimitive_2e91!= _childPrimitive_2e8d.end(); ++itchildPrimitive_2e91)
	{
		if( ( *itchildPrimitive_2e91== childPrimitive_2e8f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_childPrimitive_2e8d.push_back( childPrimitive_2e8f);
	return isUnique;
}

bool MergeBlocksOnly_2e94::operator()( const Packets_t& primitives_2e95, Packets_t& primitives_2e97)
{
#ifdef PRINT_INFO
	printLog( "MergeBlocksOnly_2e94" );
#endif
	_primitive_2e98= &primitives_2e97;
	processInputPackets( primitives_2e95);
	if( false== _matches.empty())
		return true;
	return false;
}

bool MergeBlocksOnly_2e94::isInputUnique( const Udm::Object& primitive_2e9d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itPrimitive_2e9f= _primitive_2e99.begin(); itPrimitive_2e9f!= _primitive_2e99.end(); ++itPrimitive_2e9f)
	{
		if( ( *itPrimitive_2e9f== primitive_2e9d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_primitive_2e99.push_back( primitive_2e9d);
	return isUnique;
}

bool MergeBlocksOnly_2e94::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool MergeBlocksOnly_2e94::isGuardTrue( CyberComposition::Simulink::Primitive& Primitive)
{
	bool Gz_guard= false;
	std::string blockType = Primitive.BlockType();
Gz_guard = blockType == "Merge";;
	return Gz_guard;
}

void MergeBlocksOnly_2e94::processInputPackets( const Packets_t& primitives_2e95)
{
	for( Packets_t::const_iterator itPrimitive_2e9a= primitives_2e95.begin(); itPrimitive_2e9a!= primitives_2e95.end(); ++itPrimitive_2e9a)
	{
		bool isUnique= isInputUnique( *itPrimitive_2e9a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itPrimitive_2e9a);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.primitive_2ea6);
	}
}

bool MergeBlocksOnly_2e94::patternMatcher( const Udm::Object& primitive_2e9b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( primitive_2e9b.type(), CyberComposition::Simulink::Primitive::meta))
			continue;
		CyberComposition::Simulink::Primitive primitive_2ea0= CyberComposition::Simulink::Primitive::Cast( primitive_2e9b);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2ea5;
		if( !isValidBound(boundObjs_2ea5, primitive_2ea0, true))
			continue;
		currMatch.primitive_2ea6= primitive_2ea0;
		bool Gz_guard= isGuardTrue( currMatch.primitive_2ea6);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void MergeBlocksOnly_2e94::outputAppender( const CyberComposition::Simulink::Primitive& primitive_2ea8)
{
	_primitive_2e98->push_back( primitive_2ea8);
}

void MergeAsSwitch_2eaa::operator()( const Packets_t& primitives_2eab)
{
#ifdef PRINT_INFO
	printLog( "MergeAsSwitch_2eaa" );
#endif
	RTTGenerator::Instance()->generateRule(2800, "MergeAsSwitch");
	processInputPackets( primitives_2eab);
}

bool MergeAsSwitch_2eaa::isInputUnique( const Udm::Object& primitive_2eb1)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itPrimitive_2eb3= _primitive_2ead.begin(); itPrimitive_2eb3!= _primitive_2ead.end(); ++itPrimitive_2eb3)
	{
		if( ( *itPrimitive_2eb3== primitive_2eb1))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_primitive_2ead.push_back( primitive_2eb1);
	return isUnique;
}

bool MergeAsSwitch_2eaa::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void MergeAsSwitch_2eaa::processInputPackets( const Packets_t& primitives_2eab)
{
	for( Packets_t::const_iterator itPrimitive_2eae= primitives_2eab.begin(); itPrimitive_2eae!= primitives_2eab.end(); ++itPrimitive_2eae)
	{
		bool isUnique= isInputUnique( *itPrimitive_2eae);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itPrimitive_2eae);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool MergeAsSwitch_2eaa::patternMatcher( const Udm::Object& primitive_2eaf)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( primitive_2eaf.type(), CyberComposition::Simulink::Primitive::meta))
			continue;
		CyberComposition::Simulink::Primitive primitive_2eb4= CyberComposition::Simulink::Primitive::Cast( primitive_2eaf);
		set< CyberComposition::Simulink::InputPort> inputPorts_2eb6= primitive_2eb4.InputPort_kind_children();
		for( set< CyberComposition::Simulink::InputPort>::const_iterator itInputPort_2eb7= inputPorts_2eb6.begin(); itInputPort_2eb7!= inputPorts_2eb6.end(); ++itInputPort_2eb7)
		{
			CyberComposition::Simulink::InputPort currInputPort_2eb8= *itInputPort_2eb7;
			set< CyberComposition::Simulink::Line> line2s_2eb9= currInputPort_2eb8.srcLine();
			for( set< CyberComposition::Simulink::Line>::const_iterator itLine2s_2eba= line2s_2eb9.begin(); itLine2s_2eba!= line2s_2eb9.end(); ++itLine2s_2eba)
			{
				CyberComposition::Simulink::Line currLine2_2ebb= *itLine2s_2eba;
				CyberComposition::Simulink::SF_Port actionOutput_2ebc= currLine2_2ebb.srcLine_end();
				if( false== Uml::IsDerivedFrom( actionOutput_2ebc.type(), CyberComposition::Simulink::OutputPort::meta))
					continue;
				CyberComposition::Simulink::OutputPort currActionOutput_2ebd= CyberComposition::Simulink::OutputPort::Cast( actionOutput_2ebc);
				Udm::Object actionOutputParent_2ebe= currActionOutput_2ebd.container();
				if( false== Uml::IsDerivedFrom( actionOutputParent_2ebe.type(), CyberComposition::Simulink::Subsystem::meta))
					continue;
				CyberComposition::Simulink::Subsystem ifActionActionOutput_2ebf= CyberComposition::Simulink::Subsystem::Cast( actionOutputParent_2ebe);
				set< CyberComposition::Simulink::EnablePort> actionPorts_2ec0= ifActionActionOutput_2ebf.EnablePort_kind_children();
				for( set< CyberComposition::Simulink::EnablePort>::const_iterator itActionPort_2ec1= actionPorts_2ec0.begin(); itActionPort_2ec1!= actionPorts_2ec0.end(); ++itActionPort_2ec1)
				{
					CyberComposition::Simulink::EnablePort currActionPort_2ec2= *itActionPort_2ec1;
					set< CyberComposition::Simulink::Line> line1s_2ec3= currActionPort_2ec2.srcLine();
					for( set< CyberComposition::Simulink::Line>::const_iterator itLine1s_2ec4= line1s_2ec3.begin(); itLine1s_2ec4!= line1s_2ec3.end(); ++itLine1s_2ec4)
					{
						CyberComposition::Simulink::Line currLine1_2ec5= *itLine1s_2ec4;
						CyberComposition::Simulink::SF_Port ifOutput_2ec6= currLine1_2ec5.srcLine_end();
						if( false== Uml::IsDerivedFrom( ifOutput_2ec6.type(), CyberComposition::Simulink::OutputPort::meta))
							continue;
						CyberComposition::Simulink::OutputPort currIfOutput_2ec7= CyberComposition::Simulink::OutputPort::Cast( ifOutput_2ec6);
						Udm::Object ifOutputParent_2ec8= currIfOutput_2ec7.container();
						if( false== Uml::IsDerivedFrom( ifOutputParent_2ec8.type(), CyberComposition::Simulink::Primitive::meta))
							continue;
						CyberComposition::Simulink::Primitive ifOrSwitchCaseBlockIfOutput_2ec9= CyberComposition::Simulink::Primitive::Cast( ifOutputParent_2ec8);
						SFC::LocalVar localVar_2eca= ifOrSwitchCaseBlockIfOutput_2ec9.ifval();
						if( !localVar_2eca)
							continue;
						Match currMatch;
						set< pair<int, Udm::Object> > boundObjs_2ece;
						if( !isValidBound(boundObjs_2ece, primitive_2eb4, true))
							continue;
						currMatch.primitive_2ecf= primitive_2eb4;
						if( !isValidBound(boundObjs_2ece, currInputPort_2eb8, false))
							continue;
						currMatch.inputPort_2ed0= currInputPort_2eb8;
						if( !isValidBound(boundObjs_2ece, localVar_2eca, false))
							continue;
						currMatch.localVar_2ed1= localVar_2eca;
						if( !isValidBound(boundObjs_2ece, currActionOutput_2ebd, false))
							continue;
						currMatch.actionOutput_2ed2= currActionOutput_2ebd;
						if( !isValidBound(boundObjs_2ece, currLine1_2ec5, false))
							continue;
						currMatch.line1_2ed3= currLine1_2ec5;
						if( !isValidBound(boundObjs_2ece, currLine2_2ebb, false))
							continue;
						currMatch.line2_2ed4= currLine2_2ebb;
						if( !isValidBound(boundObjs_2ece, ifActionActionOutput_2ebf, false))
							continue;
						currMatch.ifAction_2ed5= ifActionActionOutput_2ebf;
						if( !isValidBound(boundObjs_2ece, ifOrSwitchCaseBlockIfOutput_2ec9, false))
							continue;
						currMatch.ifOrSwitchCaseBlock_2ed6= ifOrSwitchCaseBlockIfOutput_2ec9;
						if( !isValidBound(boundObjs_2ece, currIfOutput_2ec7, false))
							continue;
						currMatch.ifOutput_2ed7= currIfOutput_2ec7;
						if( !isValidBound(boundObjs_2ece, currActionPort_2ec2, false))
							continue;
						currMatch.actionPort_2ed8= currActionPort_2ec2;
						_matches.push_back( currMatch);
						return true;
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void MergeAsSwitch_2eaa::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		CyberComposition::Simulink::OutputPort& ActionOutput= currMatch.actionOutput_2ed2;
		CyberComposition::Simulink::EnablePort& ActionPort= currMatch.actionPort_2ed8;
		CyberComposition::Simulink::Subsystem& IfAction= currMatch.ifAction_2ed5;
		CyberComposition::Simulink::Primitive& IfOrSwitchCaseBlock= currMatch.ifOrSwitchCaseBlock_2ed6;
		CyberComposition::Simulink::OutputPort& IfOutput= currMatch.ifOutput_2ed7;
		CyberComposition::Simulink::InputPort& InputPort= currMatch.inputPort_2ed0;
		CyberComposition::Simulink::Line& Line1= currMatch.line1_2ed3;
		CyberComposition::Simulink::Line& Line2= currMatch.line2_2ed4;
		SFC::LocalVar& LocalVar= currMatch.localVar_2ed1;
		CyberComposition::Simulink::Primitive& Primitive= currMatch.primitive_2ecf;
		{
CodeGenerator::getSingleton().getBlockSetup( Primitive ).addInput( LocalVar );
};
	}
}

void GetInputPorts_2edd::operator()( const Packets_t& childPrimitives_2ede)
{
#ifdef PRINT_INFO
	printLog( "GetInputPorts_2edd" );
#endif
	if( ( !childPrimitives_2ede.empty()))
		callGetSortedInPorts_2f1c( childPrimitives_2ede);
}

void GetInputPorts_2edd::callGetSortedInPorts_2f1c( const Packets_t& functions_2f00)
{
	Packets_t functions_2f02;
	Packets_t inputPorts_2f03;
	GetSortedInPorts_2eff getSortedInPorts_2eff;
	getSortedInPorts_2eff( functions_2f00, functions_2f02, inputPorts_2f03);
	if( ( !functions_2f02.empty())&& ( !inputPorts_2f03.empty()))
		callListInPorts_2f1e( functions_2f02, inputPorts_2f03);
}

void GetInputPorts_2edd::callListInPorts_2f1e( const Packets_t& primitives_2ee1, const Packets_t& inputPorts_2ee3)
{
	ListInPorts_2ee0 listInPorts_2ee0;
	listInPorts_2ee0( primitives_2ee1, inputPorts_2ee3);
}

void ListInPorts_2ee0::operator()( const Packets_t& primitives_2ee1, const Packets_t& inputPorts_2ee3)
{
#ifdef PRINT_INFO
	printLog( "ListInPorts_2ee0" );
#endif
	RTTGenerator::Instance()->generateRule(2823, "ListInPorts");
	processInputPackets( primitives_2ee1, inputPorts_2ee3);
}

bool ListInPorts_2ee0::isInputUnique( const Udm::Object& primitive_2ee9, const Udm::Object& inputPort_2ef2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itPrimitive_2eeb= _primitive_2ee5.begin(), itInputPort_2ef4= _inputPort_2eee.begin(); itPrimitive_2eeb!= _primitive_2ee5.end(), itInputPort_2ef4!= _inputPort_2eee.end(); ++itPrimitive_2eeb, ++itInputPort_2ef4)
	{
		if( ( *itPrimitive_2eeb== primitive_2ee9)&& ( *itInputPort_2ef4== inputPort_2ef2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_primitive_2ee5.push_back( primitive_2ee9);
		_inputPort_2eee.push_back( inputPort_2ef2);
	}
	return isUnique;
}

bool ListInPorts_2ee0::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void ListInPorts_2ee0::processInputPackets( const Packets_t& primitives_2ee1, const Packets_t& inputPorts_2ee3)
{
	for( Packets_t::const_iterator itPrimitive_2ee6= primitives_2ee1.begin(), itInputPort_2eef= inputPorts_2ee3.begin(); itPrimitive_2ee6!= primitives_2ee1.end(), itInputPort_2eef!= inputPorts_2ee3.end(); ++itPrimitive_2ee6, ++itInputPort_2eef)
	{
		bool isUnique= isInputUnique( *itPrimitive_2ee6, *itInputPort_2eef);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itPrimitive_2ee6, *itInputPort_2eef);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ListInPorts_2ee0::patternMatcher( const Udm::Object& primitive_2ee7, const Udm::Object& inputPort_2ef0)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( primitive_2ee7.type(), CyberComposition::Simulink::Primitive::meta))
			continue;
		CyberComposition::Simulink::Primitive primitive_2eec= CyberComposition::Simulink::Primitive::Cast( primitive_2ee7);
		if( false== Uml::IsDerivedFrom( inputPort_2ef0.type(), CyberComposition::Simulink::SF_Port::meta))
			continue;
		CyberComposition::Simulink::SF_Port inputPort_2ef5= CyberComposition::Simulink::SF_Port::Cast( inputPort_2ef0);
		SFC::ArgDeclBase argDeclBase_2ef7= inputPort_2ef5.argdecl();
		if( !argDeclBase_2ef7)
			continue;
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2efb;
		if( !isValidBound(boundObjs_2efb, primitive_2eec, true))
			continue;
		currMatch.primitive_2efc= primitive_2eec;
		if( !isValidBound(boundObjs_2efb, inputPort_2ef5, true))
			continue;
		currMatch.inputPort_2efd= inputPort_2ef5;
		if( !isValidBound(boundObjs_2efb, argDeclBase_2ef7, false))
			continue;
		currMatch.argDeclBase_2efe= argDeclBase_2ef7;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void ListInPorts_2ee0::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_2efe;
		CyberComposition::Simulink::SF_Port& InputPort= currMatch.inputPort_2efd;
		CyberComposition::Simulink::Primitive& Primitive= currMatch.primitive_2efc;
		{
CodeGenerator::getSingleton().getBlockSetup( Primitive ).addInput( ArgDeclBase );
};
	}
}

void GetSortedInPorts_2eff::operator()( const Packets_t& functions_2f00, Packets_t& functions_2f02, Packets_t& inputPorts_2f03)
{
#ifdef PRINT_INFO
	printLog( "GetSortedInPorts_2eff" );
#endif
	RTTGenerator::Instance()->generateRule(2829, "GetSortedInPorts");
	_function_2f04= &functions_2f02;
	_inputPort_2f05= &inputPorts_2f03;
	processInputPackets( functions_2f00);
	sortOutputs( );
}

bool GetSortedInPorts_2eff::isInputUnique( const Udm::Object& function_2f0a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itFunction_2f0c= _function_2f06.begin(); itFunction_2f0c!= _function_2f06.end(); ++itFunction_2f0c)
	{
		if( ( *itFunction_2f0c== function_2f0a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_function_2f06.push_back( function_2f0a);
	return isUnique;
}

bool GetSortedInPorts_2eff::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetSortedInPorts_2eff::processInputPackets( const Packets_t& functions_2f00)
{
	for( Packets_t::const_iterator itFunction_2f07= functions_2f00.begin(); itFunction_2f07!= functions_2f00.end(); ++itFunction_2f07)
	{
		bool isUnique= isInputUnique( *itFunction_2f07);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itFunction_2f07);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetSortedInPorts_2eff::patternMatcher( const Udm::Object& function_2f08)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( function_2f08.type(), CyberComposition::Simulink::Primitive::meta))
			continue;
		CyberComposition::Simulink::Primitive function_2f0d= CyberComposition::Simulink::Primitive::Cast( function_2f08);
		set< CyberComposition::Simulink::InputPort> inputPorts_2f0f= function_2f0d.InputPort_kind_children();
		for( set< CyberComposition::Simulink::InputPort>::const_iterator itInputPort_2f10= inputPorts_2f0f.begin(); itInputPort_2f10!= inputPorts_2f0f.end(); ++itInputPort_2f10)
		{
			CyberComposition::Simulink::InputPort currInputPort_2f11= *itInputPort_2f10;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2f15;
			if( !isValidBound(boundObjs_2f15, function_2f0d, true))
				continue;
			currMatch.function_2f16= function_2f0d;
			if( !isValidBound(boundObjs_2f15, currInputPort_2f11, false))
				continue;
			currMatch.inputPort_2f17= currInputPort_2f11;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetSortedInPorts_2eff::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.function_2f16, currMatch.inputPort_2f17);
	}
}

void GetSortedInPorts_2eff::outputAppender( const CyberComposition::Simulink::Primitive& function_2f18, const CyberComposition::Simulink::InputPort& inputPort_2f1a)
{
	_function_2f04->push_back( function_2f18);
	_inputPort_2f05->push_back( inputPort_2f1a);
}

void GetSortedInPorts_2eff::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::InputPort, std::pointer_to_binary_function< const CyberComposition::Simulink::InputPort&, const CyberComposition::Simulink::InputPort&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::InputPort&, const CyberComposition::Simulink::InputPort&, bool> ptr_PortOrder( PortOrder< CyberComposition::Simulink::InputPort>);
	SortedSet_t sortedSet( ptr_PortOrder);
	std::vector< int> permutationVector( _inputPort_2f05->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _inputPort_2f05->begin(); it!= _inputPort_2f05->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::InputPort::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _inputPort_2f05->begin());
	// order rest of the containers
	permutate( permutationVector, *_function_2f04);
}

void CallCG_2f31::operator()( const Packets_t& primitives_2f32, const Packets_t& compoundStatements_2f35, Packets_t& primitives_2f34, Packets_t& compoundStatements_2f37)
{
#ifdef PRINT_INFO
	printLog( "CallCG_2f31" );
#endif
	RTTGenerator::Instance()->generateRule(2833, "CallCG");
	_primitive_2f38= &primitives_2f34;
	_compoundStatement_2f39= &compoundStatements_2f37;
	processInputPackets( primitives_2f32, compoundStatements_2f35);
	forwardInputs( );
}

bool CallCG_2f31::isInputUnique( const Udm::Object& primitive_2f3e, const Udm::Object& compoundStatement_2f47)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itPrimitive_2f40= _primitive_2f3a.begin(), itCompoundStatement_2f49= _compoundStatement_2f43.begin(); itPrimitive_2f40!= _primitive_2f3a.end(), itCompoundStatement_2f49!= _compoundStatement_2f43.end(); ++itPrimitive_2f40, ++itCompoundStatement_2f49)
	{
		if( ( *itPrimitive_2f40== primitive_2f3e)&& ( *itCompoundStatement_2f49== compoundStatement_2f47))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_primitive_2f3a.push_back( primitive_2f3e);
		_compoundStatement_2f43.push_back( compoundStatement_2f47);
	}
	return isUnique;
}

bool CallCG_2f31::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CallCG_2f31::processInputPackets( const Packets_t& primitives_2f32, const Packets_t& compoundStatements_2f35)
{
	for( Packets_t::const_iterator itPrimitive_2f3b= primitives_2f32.begin(), itCompoundStatement_2f44= compoundStatements_2f35.begin(); itPrimitive_2f3b!= primitives_2f32.end(), itCompoundStatement_2f44!= compoundStatements_2f35.end(); ++itPrimitive_2f3b, ++itCompoundStatement_2f44)
	{
		bool isUnique= isInputUnique( *itPrimitive_2f3b, *itCompoundStatement_2f44);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itPrimitive_2f3b, *itCompoundStatement_2f44);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CallCG_2f31::patternMatcher( const Udm::Object& primitive_2f3c, const Udm::Object& compoundStatement_2f45)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( primitive_2f3c.type(), CyberComposition::Simulink::Primitive::meta))
			continue;
		CyberComposition::Simulink::Primitive primitive_2f41= CyberComposition::Simulink::Primitive::Cast( primitive_2f3c);
		if( false== Uml::IsDerivedFrom( compoundStatement_2f45.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_2f4a= SFC::CompoundStatement::Cast( compoundStatement_2f45);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2f4f;
		if( !isValidBound(boundObjs_2f4f, primitive_2f41, true))
			continue;
		currMatch.primitive_2f50= primitive_2f41;
		if( !isValidBound(boundObjs_2f4f, compoundStatement_2f4a, true))
			continue;
		currMatch.compoundStatement_2f51= compoundStatement_2f4a;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CallCG_2f31::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_2f51;
		CyberComposition::Simulink::Primitive& Primitive= currMatch.primitive_2f50;
		{
CodeGenerator::getSingleton().generateSFC( Primitive );
CodeGenerator::getSingleton().removeBlockSetup( Primitive );
set<CyberComposition::Simulink::SF_Parameter> parameters = Primitive.SF_Parameter_kind_children();
for(auto it=parameters.begin();it!=parameters.end();++it)
{
SFC::LocalVar localVar = (*it).memb();
if(localVar!=Udm::null)
SFUtils::obj2VarNameMap[(*it).uniqueId()]=localVar.name();
}
};
	}
}

void CallCG_2f31::forwardInputs()
{
	*_primitive_2f38= _primitive_2f3a;
	*_compoundStatement_2f39= _compoundStatement_2f43;
}

void SetupIfVar_2f52::operator()( const Packets_t& childPrimitives_2f53, const Packets_t& systemFunctions_2f55)
{
#ifdef PRINT_INFO
	printLog( "SetupIfVar_2f52" );
#endif
	if( ( !childPrimitives_2f53.empty())&& ( !systemFunctions_2f55.empty()))
		callGetIfAndSwitchCaseBlocks_3044( childPrimitives_2f53, systemFunctions_2f55);
}

void SetupIfVar_2f52::callGetIfAndSwitchCaseBlocks_3044( const Packets_t& childPrimitives_2fc4, const Packets_t& systemFunctions_2fc6)
{
	Packets_t childPrimitives_2fc8;
	Packets_t systemFunctions_2fc9;
	GetIfAndSwitchCaseBlocks_2fc3 getIfAndSwitchCaseBlocks_2fc3;
	getIfAndSwitchCaseBlocks_2fc3( childPrimitives_2fc4, systemFunctions_2fc6, childPrimitives_2fc8, systemFunctions_2fc9);
	if( ( !childPrimitives_2fc8.empty())&& ( !systemFunctions_2fc9.empty()))
		callMakeIfVar_3047( childPrimitives_2fc8, systemFunctions_2fc9);
}

void SetupIfVar_2f52::callMakeIfVar_3047( const Packets_t& primitives_2f95, const Packets_t& compoundStatements_2f99)
{
	Packets_t primitives_2f97;
	Packets_t localVars_2f98;
	Packets_t conditionalGroups_2f9b;
	MakeIfVar_2f94 makeIfVar_2f94;
	makeIfVar_2f94( primitives_2f95, compoundStatements_2f99, primitives_2f97, localVars_2f98, conditionalGroups_2f9b);
	if( ( !primitives_2f97.empty())&& ( !localVars_2f98.empty())&& ( !conditionalGroups_2f9b.empty()))
		callGetIfOutputPorts_304a( primitives_2f97, localVars_2f98, conditionalGroups_2f9b);
}

void SetupIfVar_2f52::callGetIfOutputPorts_304a( const Packets_t& primitives_2f58, const Packets_t& localVars_2f5c, const Packets_t& conditionalGroups_2f5f)
{
	Packets_t primitives_2f5a;
	Packets_t outputPorts_2f5b;
	Packets_t localVars_2f5e;
	Packets_t conditionalGroups_2f61;
	GetIfOutputPorts_2f57 getIfOutputPorts_2f57;
	getIfOutputPorts_2f57( primitives_2f58, localVars_2f5c, conditionalGroups_2f5f, primitives_2f5a, outputPorts_2f5b, localVars_2f5e, conditionalGroups_2f61);
	if( ( !primitives_2f5a.empty())&& ( !outputPorts_2f5b.empty())&& ( !localVars_2f5e.empty())&& ( !conditionalGroups_2f61.empty()))
		callAssignIfVar_304e( primitives_2f5a, outputPorts_2f5b, localVars_2f5e, conditionalGroups_2f61);
}

void SetupIfVar_2f52::callAssignIfVar_304e( const Packets_t& primitives_3002, const Packets_t& outputPorts_3004, const Packets_t& ifVars_3006, const Packets_t& conditionalGroups_3008)
{
	AssignIfVar_3001 assignIfVar_3001;
	assignIfVar_3001( primitives_3002, outputPorts_3004, ifVars_3006, conditionalGroups_3008);
}

void GetIfOutputPorts_2f57::operator()( const Packets_t& primitives_2f58, const Packets_t& localVars_2f5c, const Packets_t& conditionalGroups_2f5f, Packets_t& primitives_2f5a, Packets_t& outputPorts_2f5b, Packets_t& localVars_2f5e, Packets_t& conditionalGroups_2f61)
{
#ifdef PRINT_INFO
	printLog( "GetIfOutputPorts_2f57" );
#endif
	RTTGenerator::Instance()->generateRule(2840, "GetIfOutputPorts");
	_primitive_2f62= &primitives_2f5a;
	_outputPort_2f63= &outputPorts_2f5b;
	_localVar_2f64= &localVars_2f5e;
	_conditionalGroup_2f65= &conditionalGroups_2f61;
	processInputPackets( primitives_2f58, localVars_2f5c, conditionalGroups_2f5f);
	sortOutputs( );
}

bool GetIfOutputPorts_2f57::isInputUnique( const Udm::Object& primitive_2f6a, const Udm::Object& localVar_2f73, const Udm::Object& conditionalGroup_2f7c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itPrimitive_2f6c= _primitive_2f66.begin(), itLocalVar_2f75= _localVar_2f6f.begin(), itConditionalGroup_2f7e= _conditionalGroup_2f78.begin(); itPrimitive_2f6c!= _primitive_2f66.end(), itLocalVar_2f75!= _localVar_2f6f.end(), itConditionalGroup_2f7e!= _conditionalGroup_2f78.end(); ++itPrimitive_2f6c, ++itLocalVar_2f75, ++itConditionalGroup_2f7e)
	{
		if( ( *itPrimitive_2f6c== primitive_2f6a)&& ( *itLocalVar_2f75== localVar_2f73)&& ( *itConditionalGroup_2f7e== conditionalGroup_2f7c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_primitive_2f66.push_back( primitive_2f6a);
		_localVar_2f6f.push_back( localVar_2f73);
		_conditionalGroup_2f78.push_back( conditionalGroup_2f7c);
	}
	return isUnique;
}

bool GetIfOutputPorts_2f57::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetIfOutputPorts_2f57::processInputPackets( const Packets_t& primitives_2f58, const Packets_t& localVars_2f5c, const Packets_t& conditionalGroups_2f5f)
{
	for( Packets_t::const_iterator itPrimitive_2f67= primitives_2f58.begin(), itLocalVar_2f70= localVars_2f5c.begin(), itConditionalGroup_2f79= conditionalGroups_2f5f.begin(); itPrimitive_2f67!= primitives_2f58.end(), itLocalVar_2f70!= localVars_2f5c.end(), itConditionalGroup_2f79!= conditionalGroups_2f5f.end(); ++itPrimitive_2f67, ++itLocalVar_2f70, ++itConditionalGroup_2f79)
	{
		bool isUnique= isInputUnique( *itPrimitive_2f67, *itLocalVar_2f70, *itConditionalGroup_2f79);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itPrimitive_2f67, *itLocalVar_2f70, *itConditionalGroup_2f79);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetIfOutputPorts_2f57::patternMatcher( const Udm::Object& primitive_2f68, const Udm::Object& localVar_2f71, const Udm::Object& conditionalGroup_2f7a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( primitive_2f68.type(), CyberComposition::Simulink::Primitive::meta))
			continue;
		CyberComposition::Simulink::Primitive primitive_2f6d= CyberComposition::Simulink::Primitive::Cast( primitive_2f68);
		if( false== Uml::IsDerivedFrom( localVar_2f71.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_2f76= SFC::LocalVar::Cast( localVar_2f71);
		if( false== Uml::IsDerivedFrom( conditionalGroup_2f7a.type(), SFC::ConditionalGroup::meta))
			continue;
		SFC::ConditionalGroup conditionalGroup_2f7f= SFC::ConditionalGroup::Cast( conditionalGroup_2f7a);
		set< CyberComposition::Simulink::OutputPort> outputPorts_2f81= primitive_2f6d.OutputPort_kind_children();
		for( set< CyberComposition::Simulink::OutputPort>::const_iterator itOutputPort_2f82= outputPorts_2f81.begin(); itOutputPort_2f82!= outputPorts_2f81.end(); ++itOutputPort_2f82)
		{
			CyberComposition::Simulink::OutputPort currOutputPort_2f83= *itOutputPort_2f82;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_2f87;
			if( !isValidBound(boundObjs_2f87, primitive_2f6d, true))
				continue;
			currMatch.primitive_2f88= primitive_2f6d;
			if( !isValidBound(boundObjs_2f87, localVar_2f76, true))
				continue;
			currMatch.localVar_2f89= localVar_2f76;
			if( !isValidBound(boundObjs_2f87, conditionalGroup_2f7f, true))
				continue;
			currMatch.conditionalGroup_2f8a= conditionalGroup_2f7f;
			if( !isValidBound(boundObjs_2f87, currOutputPort_2f83, false))
				continue;
			currMatch.outputPort_2f8b= currOutputPort_2f83;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetIfOutputPorts_2f57::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.primitive_2f88, currMatch.outputPort_2f8b, currMatch.localVar_2f89, currMatch.conditionalGroup_2f8a);
	}
}

void GetIfOutputPorts_2f57::outputAppender( const CyberComposition::Simulink::Primitive& primitive_2f8c, const CyberComposition::Simulink::OutputPort& outputPort_2f8e, const SFC::LocalVar& localVar_2f90, const SFC::ConditionalGroup& conditionalGroup_2f92)
{
	_primitive_2f62->push_back( primitive_2f8c);
	_outputPort_2f63->push_back( outputPort_2f8e);
	_localVar_2f64->push_back( localVar_2f90);
	_conditionalGroup_2f65->push_back( conditionalGroup_2f92);
}

void GetIfOutputPorts_2f57::sortOutputs()
{
	typedef std::multiset< CyberComposition::Simulink::OutputPort, std::pointer_to_binary_function< const CyberComposition::Simulink::OutputPort&, const CyberComposition::Simulink::OutputPort&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::Simulink::OutputPort&, const CyberComposition::Simulink::OutputPort&, bool> ptr_PortOrder( PortOrder< CyberComposition::Simulink::OutputPort>);
	SortedSet_t sortedSet( ptr_PortOrder);
	std::vector< int> permutationVector( _outputPort_2f63->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _outputPort_2f63->begin(); it!= _outputPort_2f63->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::Simulink::OutputPort::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _outputPort_2f63->begin());
	// order rest of the containers
	permutate( permutationVector, *_primitive_2f62);
	permutate( permutationVector, *_localVar_2f64);
	permutate( permutationVector, *_conditionalGroup_2f65);
}

void MakeIfVar_2f94::operator()( const Packets_t& primitives_2f95, const Packets_t& compoundStatements_2f99, Packets_t& primitives_2f97, Packets_t& localVars_2f98, Packets_t& conditionalGroups_2f9b)
{
#ifdef PRINT_INFO
	printLog( "MakeIfVar_2f94" );
#endif
	RTTGenerator::Instance()->generateRule(2846, "MakeIfVar");
	_primitive_2f9c= &primitives_2f97;
	_localVar_2f9d= &localVars_2f98;
	_conditionalGroup_2f9e= &conditionalGroups_2f9b;
	processInputPackets( primitives_2f95, compoundStatements_2f99);
}

bool MakeIfVar_2f94::isInputUnique( const Udm::Object& primitive_2fa3, const Udm::Object& compoundStatement_2fac)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itPrimitive_2fa5= _primitive_2f9f.begin(), itCompoundStatement_2fae= _compoundStatement_2fa8.begin(); itPrimitive_2fa5!= _primitive_2f9f.end(), itCompoundStatement_2fae!= _compoundStatement_2fa8.end(); ++itPrimitive_2fa5, ++itCompoundStatement_2fae)
	{
		if( ( *itPrimitive_2fa5== primitive_2fa3)&& ( *itCompoundStatement_2fae== compoundStatement_2fac))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_primitive_2f9f.push_back( primitive_2fa3);
		_compoundStatement_2fa8.push_back( compoundStatement_2fac);
	}
	return isUnique;
}

bool MakeIfVar_2f94::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void MakeIfVar_2f94::processInputPackets( const Packets_t& primitives_2f95, const Packets_t& compoundStatements_2f99)
{
	for( Packets_t::const_iterator itPrimitive_2fa0= primitives_2f95.begin(), itCompoundStatement_2fa9= compoundStatements_2f99.begin(); itPrimitive_2fa0!= primitives_2f95.end(), itCompoundStatement_2fa9!= compoundStatements_2f99.end(); ++itPrimitive_2fa0, ++itCompoundStatement_2fa9)
	{
		bool isUnique= isInputUnique( *itPrimitive_2fa0, *itCompoundStatement_2fa9);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itPrimitive_2fa0, *itCompoundStatement_2fa9);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool MakeIfVar_2f94::patternMatcher( const Udm::Object& primitive_2fa1, const Udm::Object& compoundStatement_2faa)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( primitive_2fa1.type(), CyberComposition::Simulink::Primitive::meta))
			continue;
		CyberComposition::Simulink::Primitive primitive_2fa6= CyberComposition::Simulink::Primitive::Cast( primitive_2fa1);
		if( false== Uml::IsDerivedFrom( compoundStatement_2faa.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_2faf= SFC::CompoundStatement::Cast( compoundStatement_2faa);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2fb4;
		if( !isValidBound(boundObjs_2fb4, primitive_2fa6, true))
			continue;
		currMatch.primitive_2fb5= primitive_2fa6;
		if( !isValidBound(boundObjs_2fb4, compoundStatement_2faf, true))
			continue;
		currMatch.compoundStatement_2fb6= compoundStatement_2faf;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void MakeIfVar_2f94::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newLocalVar_2fb7= SFC::LocalVar::Create( currMatch.compoundStatement_2fb6);
		SFC::ConditionalGroup newConditionalGroup_2fb8= SFC::ConditionalGroup::Create( currMatch.compoundStatement_2fb6);
		SFC::UserCode newUserCode_2fb9= SFC::UserCode::Create( currMatch.compoundStatement_2fb6);
		SFC::BinaryExprs newBinaryExprs_2fba= SFC::BinaryExprs::Create( newUserCode_2fb9);
		SFC::ArgDeclRef newArgDeclRef_2fbb= SFC::ArgDeclRef::Create( newBinaryExprs_2fba, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newInt_2fbc= SFC::Int::Create( newBinaryExprs_2fba, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_2fbb;
		SFC::BinaryExprs& BinaryExprs= newBinaryExprs_2fba;
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_2fb6;
		SFC::ConditionalGroup& ConditionalGroup= newConditionalGroup_2fb8;
		SFC::Int& Int= newInt_2fbc;
		SFC::LocalVar& LocalVar= newLocalVar_2fb7;
		CyberComposition::Simulink::Primitive& Primitive= currMatch.primitive_2fb5;
		SFC::UserCode& UserCode= newUserCode_2fb9;
		{
LocalVar.name() = std::string( "ifval" ) + boost::lexical_cast< std::string >( LocalVar.uniqueId() );
LocalVar.type() = "int";

int statementCount = CompoundStatement.statementCount();
LocalVar.statementIndex() = statementCount++;
UserCode.statementIndex() = statementCount++;
ConditionalGroup.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		{
Int.val() = -1;
};
		{
BinaryExprs.op() = "=";
};
		currMatch.primitive_2fb5.ifval()= newLocalVar_2fb7;
		newArgDeclRef_2fbb.argdecl()= newLocalVar_2fb7;
		outputAppender( currMatch.primitive_2fb5, newLocalVar_2fb7, newConditionalGroup_2fb8);
	}
}

void MakeIfVar_2f94::outputAppender( const CyberComposition::Simulink::Primitive& primitive_2fbd, const SFC::LocalVar& localVar_2fbf, const SFC::ConditionalGroup& conditionalGroup_2fc1)
{
	_primitive_2f9c->push_back( primitive_2fbd);
	_localVar_2f9d->push_back( localVar_2fbf);
	_conditionalGroup_2f9e->push_back( conditionalGroup_2fc1);
}

void GetIfAndSwitchCaseBlocks_2fc3::operator()( const Packets_t& childPrimitives_2fc4, const Packets_t& systemFunctions_2fc6, Packets_t& childPrimitives_2fc8, Packets_t& systemFunctions_2fc9)
{
#ifdef PRINT_INFO
	printLog( "GetIfAndSwitchCaseBlocks_2fc3" );
#endif
	_childPrimitive_2fca= &childPrimitives_2fc8;
	_systemFunction_2fcb= &systemFunctions_2fc9;
	for( Packets_t::const_iterator itchildPrimitive_2fcd= childPrimitives_2fc4.begin(), itsystemFunction_2fd4= systemFunctions_2fc6.begin(); itchildPrimitive_2fcd!= childPrimitives_2fc4.end(), itsystemFunction_2fd4!= systemFunctions_2fc6.end(); ++itchildPrimitive_2fcd, ++itsystemFunction_2fd4)
	{
		bool isUnique= isInputUnique( *itchildPrimitive_2fcd, *itsystemFunction_2fd4);
		if( !isUnique)
			continue;
		Packets_t onechildPrimitive_2fd1( 1, *itchildPrimitive_2fcd);
		Packets_t onesystemFunction_2fd8( 1, *itsystemFunction_2fd4);
		executeOne( onechildPrimitive_2fd1, onesystemFunction_2fd8);
	}
}

void GetIfAndSwitchCaseBlocks_2fc3::executeOne( const Packets_t& childPrimitives_2fc4, const Packets_t& systemFunctions_2fc6)
{
	Packets_t primitives_2fdd;
	Packets_t compoundStatements_2fe0;
	Case_2fda case_2fda;
	bool isMatchCase_2fda= case_2fda( childPrimitives_2fc4, systemFunctions_2fc6, primitives_2fdd, compoundStatements_2fe0);
	_childPrimitive_2fca->insert( _childPrimitive_2fca->end(), primitives_2fdd.begin(), primitives_2fdd.end());
	_systemFunction_2fcb->insert( _systemFunction_2fcb->end(), compoundStatements_2fe0.begin(), compoundStatements_2fe0.end());
}

bool GetIfAndSwitchCaseBlocks_2fc3::isInputUnique( const Udm::Object& childPrimitive_2fce, const Udm::Object& systemFunction_2fd5)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itchildPrimitive_2fd0= _childPrimitive_2fcc.begin(), itsystemFunction_2fd7= _systemFunction_2fd3.begin(); itchildPrimitive_2fd0!= _childPrimitive_2fcc.end(), itsystemFunction_2fd7!= _systemFunction_2fd3.end(); ++itchildPrimitive_2fd0, ++itsystemFunction_2fd7)
	{
		if( ( *itchildPrimitive_2fd0== childPrimitive_2fce)&& ( *itsystemFunction_2fd7== systemFunction_2fd5))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_childPrimitive_2fcc.push_back( childPrimitive_2fce);
		_systemFunction_2fd3.push_back( systemFunction_2fd5);
	}
	return isUnique;
}

bool Case_2fda::operator()( const Packets_t& primitives_2fdb, const Packets_t& compoundStatements_2fde, Packets_t& primitives_2fdd, Packets_t& compoundStatements_2fe0)
{
#ifdef PRINT_INFO
	printLog( "Case_2fda" );
#endif
	_primitive_2fe1= &primitives_2fdd;
	_compoundStatement_2fe2= &compoundStatements_2fe0;
	processInputPackets( primitives_2fdb, compoundStatements_2fde);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Case_2fda::isInputUnique( const Udm::Object& primitive_2fe7, const Udm::Object& compoundStatement_2ff0)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itPrimitive_2fe9= _primitive_2fe3.begin(), itCompoundStatement_2ff2= _compoundStatement_2fec.begin(); itPrimitive_2fe9!= _primitive_2fe3.end(), itCompoundStatement_2ff2!= _compoundStatement_2fec.end(); ++itPrimitive_2fe9, ++itCompoundStatement_2ff2)
	{
		if( ( *itPrimitive_2fe9== primitive_2fe7)&& ( *itCompoundStatement_2ff2== compoundStatement_2ff0))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_primitive_2fe3.push_back( primitive_2fe7);
		_compoundStatement_2fec.push_back( compoundStatement_2ff0);
	}
	return isUnique;
}

bool Case_2fda::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool Case_2fda::isGuardTrue( SFC::CompoundStatement& CompoundStatement, CyberComposition::Simulink::Primitive& Primitive)
{
	bool Gz_guard= false;
	std::string blockType = Primitive.BlockType();
Gz_guard = blockType == "If" || blockType == "SwitchCase";;
	return Gz_guard;
}

void Case_2fda::processInputPackets( const Packets_t& primitives_2fdb, const Packets_t& compoundStatements_2fde)
{
	for( Packets_t::const_iterator itPrimitive_2fe4= primitives_2fdb.begin(), itCompoundStatement_2fed= compoundStatements_2fde.begin(); itPrimitive_2fe4!= primitives_2fdb.end(), itCompoundStatement_2fed!= compoundStatements_2fde.end(); ++itPrimitive_2fe4, ++itCompoundStatement_2fed)
	{
		bool isUnique= isInputUnique( *itPrimitive_2fe4, *itCompoundStatement_2fed);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itPrimitive_2fe4, *itCompoundStatement_2fed);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.primitive_2ff9, currMatch.compoundStatement_2ffa);
	}
}

bool Case_2fda::patternMatcher( const Udm::Object& primitive_2fe5, const Udm::Object& compoundStatement_2fee)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( primitive_2fe5.type(), CyberComposition::Simulink::Primitive::meta))
			continue;
		CyberComposition::Simulink::Primitive primitive_2fea= CyberComposition::Simulink::Primitive::Cast( primitive_2fe5);
		if( false== Uml::IsDerivedFrom( compoundStatement_2fee.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_2ff3= SFC::CompoundStatement::Cast( compoundStatement_2fee);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_2ff8;
		if( !isValidBound(boundObjs_2ff8, primitive_2fea, true))
			continue;
		currMatch.primitive_2ff9= primitive_2fea;
		if( !isValidBound(boundObjs_2ff8, compoundStatement_2ff3, true))
			continue;
		currMatch.compoundStatement_2ffa= compoundStatement_2ff3;
		bool Gz_guard= isGuardTrue( currMatch.compoundStatement_2ffa, currMatch.primitive_2ff9);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Case_2fda::outputAppender( const CyberComposition::Simulink::Primitive& primitive_2ffd, const SFC::CompoundStatement& compoundStatement_2fff)
{
	_primitive_2fe1->push_back( primitive_2ffd);
	_compoundStatement_2fe2->push_back( compoundStatement_2fff);
}

void AssignIfVar_3001::operator()( const Packets_t& primitives_3002, const Packets_t& outputPorts_3004, const Packets_t& ifVars_3006, const Packets_t& conditionalGroups_3008)
{
#ifdef PRINT_INFO
	printLog( "AssignIfVar_3001" );
#endif
	RTTGenerator::Instance()->generateRule(2874, "AssignIfVar");
	processInputPackets( primitives_3002, outputPorts_3004, ifVars_3006, conditionalGroups_3008);
}

bool AssignIfVar_3001::isInputUnique( const Udm::Object& primitive_300e, const Udm::Object& outputPort_3017, const Udm::Object& ifVar_3020, const Udm::Object& conditionalGroup_3029)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itPrimitive_3010= _primitive_300a.begin(), itOutputPort_3019= _outputPort_3013.begin(), itIfVar_3022= _ifVar_301c.begin(), itConditionalGroup_302b= _conditionalGroup_3025.begin(); itPrimitive_3010!= _primitive_300a.end(), itOutputPort_3019!= _outputPort_3013.end(), itIfVar_3022!= _ifVar_301c.end(), itConditionalGroup_302b!= _conditionalGroup_3025.end(); ++itPrimitive_3010, ++itOutputPort_3019, ++itIfVar_3022, ++itConditionalGroup_302b)
	{
		if( ( *itPrimitive_3010== primitive_300e)&& ( *itOutputPort_3019== outputPort_3017)&& ( *itIfVar_3022== ifVar_3020)&& ( *itConditionalGroup_302b== conditionalGroup_3029))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_primitive_300a.push_back( primitive_300e);
		_outputPort_3013.push_back( outputPort_3017);
		_ifVar_301c.push_back( ifVar_3020);
		_conditionalGroup_3025.push_back( conditionalGroup_3029);
	}
	return isUnique;
}

bool AssignIfVar_3001::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void AssignIfVar_3001::processInputPackets( const Packets_t& primitives_3002, const Packets_t& outputPorts_3004, const Packets_t& ifVars_3006, const Packets_t& conditionalGroups_3008)
{
	for( Packets_t::const_iterator itPrimitive_300b= primitives_3002.begin(), itOutputPort_3014= outputPorts_3004.begin(), itIfVar_301d= ifVars_3006.begin(), itConditionalGroup_3026= conditionalGroups_3008.begin(); itPrimitive_300b!= primitives_3002.end(), itOutputPort_3014!= outputPorts_3004.end(), itIfVar_301d!= ifVars_3006.end(), itConditionalGroup_3026!= conditionalGroups_3008.end(); ++itPrimitive_300b, ++itOutputPort_3014, ++itIfVar_301d, ++itConditionalGroup_3026)
	{
		bool isUnique= isInputUnique( *itPrimitive_300b, *itOutputPort_3014, *itIfVar_301d, *itConditionalGroup_3026);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itPrimitive_300b, *itOutputPort_3014, *itIfVar_301d, *itConditionalGroup_3026);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AssignIfVar_3001::patternMatcher( const Udm::Object& primitive_300c, const Udm::Object& outputPort_3015, const Udm::Object& ifVar_301e, const Udm::Object& conditionalGroup_3027)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( primitive_300c.type(), CyberComposition::Simulink::Primitive::meta))
			continue;
		CyberComposition::Simulink::Primitive primitive_3011= CyberComposition::Simulink::Primitive::Cast( primitive_300c);
		if( false== Uml::IsDerivedFrom( outputPort_3015.type(), CyberComposition::Simulink::OutputPort::meta))
			continue;
		CyberComposition::Simulink::OutputPort outputPort_301a= CyberComposition::Simulink::OutputPort::Cast( outputPort_3015);
		if( false== Uml::IsDerivedFrom( ifVar_301e.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar ifVar_3023= SFC::LocalVar::Cast( ifVar_301e);
		if( false== Uml::IsDerivedFrom( conditionalGroup_3027.type(), SFC::ConditionalGroup::meta))
			continue;
		SFC::ConditionalGroup conditionalGroup_302c= SFC::ConditionalGroup::Cast( conditionalGroup_3027);
		set< CyberComposition::Simulink::OutputPort> outputPorts_302e= primitive_3011.OutputPort_kind_children();
		for( set< CyberComposition::Simulink::OutputPort>::const_iterator itOutputPort_302f= outputPorts_302e.begin(); itOutputPort_302f!= outputPorts_302e.end(); ++itOutputPort_302f)
		{
			CyberComposition::Simulink::OutputPort currOutputPort_3030= *itOutputPort_302f;
			if( outputPort_301a!= currOutputPort_3030)
				continue;
			SFC::ArgDeclBase argDeclBase_3031= outputPort_301a.argdecl();
			if( !argDeclBase_3031)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_3035;
			if( !isValidBound(boundObjs_3035, primitive_3011, true))
				continue;
			currMatch.primitive_3036= primitive_3011;
			if( !isValidBound(boundObjs_3035, outputPort_301a, true))
				continue;
			currMatch.outputPort_3037= outputPort_301a;
			if( !isValidBound(boundObjs_3035, ifVar_3023, true))
				continue;
			currMatch.ifVar_3038= ifVar_3023;
			if( !isValidBound(boundObjs_3035, conditionalGroup_302c, true))
				continue;
			currMatch.conditionalGroup_3039= conditionalGroup_302c;
			if( !isValidBound(boundObjs_3035, argDeclBase_3031, false))
				continue;
			currMatch.argDeclBase_303a= argDeclBase_3031;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void AssignIfVar_3001::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_303b= SFC::ConditionalBlock::Create( currMatch.conditionalGroup_3039);
		SFC::UserCode newUserCode1_303c= SFC::UserCode::Create( newConditionalBlock_303b, SFC::ConditionalBlock::meta_cond);
		SFC::BinaryExprs newComparison_303d= SFC::BinaryExprs::Create( newUserCode1_303c, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newArgDeclRef_303e= SFC::ArgDeclRef::Create( newComparison_303d, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newZero_303f= SFC::Int::Create( newComparison_303d, SFC::BinaryExprs::meta_rightexpr);
		SFC::UserCode newUserCode2_3040= SFC::UserCode::Create( newConditionalBlock_303b, SFC::ConditionalBlock::meta_stmnt);
		SFC::BinaryExprs newAssignment_3041= SFC::BinaryExprs::Create( newUserCode2_3040, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newIfVarRef_3042= SFC::ArgDeclRef::Create( newAssignment_3041, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newInt_3043= SFC::Int::Create( newAssignment_3041, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_303a;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_303e;
		SFC::BinaryExprs& Assignment= newAssignment_3041;
		SFC::BinaryExprs& Comparison= newComparison_303d;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_303b;
		SFC::ConditionalGroup& ConditionalGroup= currMatch.conditionalGroup_3039;
		SFC::LocalVar& IfVar= currMatch.ifVar_3038;
		SFC::ArgDeclRef& IfVarRef= newIfVarRef_3042;
		SFC::Int& Int= newInt_3043;
		CyberComposition::Simulink::OutputPort& OutputPort= currMatch.outputPort_3037;
		CyberComposition::Simulink::Primitive& Primitive= currMatch.primitive_3036;
		SFC::UserCode& UserCode1= newUserCode1_303c;
		SFC::UserCode& UserCode2= newUserCode2_3040;
		SFC::Int& Zero= newZero_303f;
		{
Comparison.op() = "!=";
};
		{
Zero.val() = 0;
};
		{
int statementCount = ConditionalBlock.statementCount();
UserCode2.statementIndex() = statementCount++;
ConditionalBlock.statementCount() = statementCount;
};
		{
Int.val() = OutputPort.Number();
};
		{
Assignment.op() = "=";
};
		{
int statementCount = ConditionalGroup.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
ConditionalGroup.statementCount() = statementCount;
};
		{
Int.val() = OutputPort.Number();
};
		newIfVarRef_3042.argdecl()= currMatch.ifVar_3038;
		newArgDeclRef_303e.argdecl()= currMatch.argDeclBase_303a;
	}
}

void ChartChildBlock_305c::operator()( const Packets_t& systems_305d, const Packets_t& childCharts_305f, const Packets_t& systemFunctions_3061)
{
#ifdef PRINT_INFO
	printLog( "ChartChildBlock_305c" );
#endif
	if( ( !systems_305d.empty())&& ( !childCharts_305f.empty())&& ( !systemFunctions_3061.empty()))
		callMakeTrigger_4161( systems_305d, childCharts_305f, systemFunctions_3061);
}

void ChartChildBlock_305c::callMakeTrigger_4161( const Packets_t& systems_3463, const Packets_t& childSubsystems_3465, const Packets_t& systemFunctions_3467)
{
	Packets_t systems_3469;
	Packets_t childSubsystems_346a;
	Packets_t compoundStatements_346b;
	MakeTrigger_3462 makeTrigger_3462;
	makeTrigger_3462( systems_3463, childSubsystems_3465, systemFunctions_3467, systems_3469, childSubsystems_346a, compoundStatements_346b);
	if( ( !systems_3469.empty())&& ( !childSubsystems_346a.empty())&& ( !compoundStatements_346b.empty()))
		callCreateFunctionCall_4165( systems_3469, childSubsystems_346a, compoundStatements_346b);
}

void ChartChildBlock_305c::callCreateFunctionCall_4165( const Packets_t& subsystems_30b5, const Packets_t& charts_30b8, const Packets_t& compoundStatements_30bd)
{
	Packets_t subsystems_30b7;
	Packets_t charts_30ba;
	Packets_t mains_30bb;
	Packets_t functionCalls_30bc;
	CreateFunctionCall_30b4 createFunctionCall_30b4;
	createFunctionCall_30b4( subsystems_30b5, charts_30b8, compoundStatements_30bd, subsystems_30b7, charts_30ba, mains_30bb, functionCalls_30bc);
	if( ( !subsystems_30b7.empty())&& ( !charts_30ba.empty())&& ( !mains_30bb.empty())&& ( !functionCalls_30bc.empty()))
		callGetState_4169( subsystems_30b7, charts_30ba, mains_30bb, functionCalls_30bc);
}

void ChartChildBlock_305c::callGetState_4169( const Packets_t& subsystems_3064, const Packets_t& charts_3067, const Packets_t& mains_306b, const Packets_t& functionCalls_306e)
{
	Packets_t subsystems_3066;
	Packets_t charts_3069;
	Packets_t states_306a;
	Packets_t mains_306d;
	Packets_t functionCalls_3070;
	GetState_3063 getState_3063;
	getState_3063( subsystems_3064, charts_3067, mains_306b, functionCalls_306e, subsystems_3066, charts_3069, states_306a, mains_306d, functionCalls_3070);
	if( ( !subsystems_3066.empty())&& ( !charts_3069.empty())&& ( !states_306a.empty())&& ( !mains_306d.empty())&& ( !functionCalls_3070.empty()))
		callInputData_416e( subsystems_3066, charts_3069, states_306a, mains_306d, functionCalls_3070);
}

void ChartChildBlock_305c::callInputData_416e( const Packets_t& systems_31dd, const Packets_t& childCharts_31df, const Packets_t& states_31e1, const Packets_t& functions_31e3, const Packets_t& functionCalls_31e5)
{
	Packets_t systems_31e7;
	Packets_t childCharts_31e8;
	Packets_t states_31e9;
	Packets_t functions_31ea;
	Packets_t functionCalls_31eb;
	InputData_31dc inputData_31dc;
	inputData_31dc( systems_31dd, childCharts_31df, states_31e1, functions_31e3, functionCalls_31e5, systems_31e7, childCharts_31e8, states_31e9, functions_31ea, functionCalls_31eb);
	if( ( !systems_31e7.empty())&& ( !childCharts_31e8.empty())&& ( !states_31e9.empty())&& ( !functions_31ea.empty())&& ( !functionCalls_31eb.empty()))
		callInputEvent_4174( systems_31e7, childCharts_31e8, states_31e9, functions_31ea, functionCalls_31eb);
}

void ChartChildBlock_305c::callInputEvent_4174( const Packets_t& systems_32bb, const Packets_t& childCharts_32bd, const Packets_t& states_32bf, const Packets_t& functions_32c1, const Packets_t& functionCalls_32c3)
{
	Packets_t systems_32c5;
	Packets_t childCharts_32c6;
	Packets_t states_32c7;
	Packets_t functions_32c8;
	Packets_t functionCalls_32c9;
	InputEvent_32ba inputEvent_32ba;
	inputEvent_32ba( systems_32bb, childCharts_32bd, states_32bf, functions_32c1, functionCalls_32c3, systems_32c5, childCharts_32c6, states_32c7, functions_32c8, functionCalls_32c9);
	if( ( !systems_32c5.empty())&& ( !childCharts_32c6.empty())&& ( !states_32c7.empty())&& ( !functions_32c8.empty())&& ( !functionCalls_32c9.empty()))
		callOutputData_417a( systems_32c5, childCharts_32c6, states_32c7, functions_32c8, functionCalls_32c9);
}

void ChartChildBlock_305c::callOutputData_417a( const Packets_t& systems_30ff, const Packets_t& childCharts_3101, const Packets_t& states_3103, const Packets_t& functions_3105, const Packets_t& functionCalls_3107)
{
	Packets_t systems_3109;
	Packets_t childCharts_310a;
	Packets_t states_310b;
	Packets_t functions_310c;
	Packets_t functionCalls_310d;
	OutputData_30fe outputData_30fe;
	outputData_30fe( systems_30ff, childCharts_3101, states_3103, functions_3105, functionCalls_3107, systems_3109, childCharts_310a, states_310b, functions_310c, functionCalls_310d);
	if( ( !systems_3109.empty())&& ( !childCharts_310a.empty())&& ( !states_310b.empty())&& ( !functions_310c.empty())&& ( !functionCalls_310d.empty()))
		callOutputEvent_4180( systems_3109, childCharts_310a, states_310b, functions_310c, functionCalls_310d);
}

void ChartChildBlock_305c::callOutputEvent_4180( const Packets_t& systems_33e3, const Packets_t& childCharts_33e5, const Packets_t& states_33e7, const Packets_t& functions_33e9, const Packets_t& functionCalls_33eb)
{
	OutputEvent_33e2 outputEvent_33e2;
	outputEvent_33e2( systems_33e3, childCharts_33e5, states_33e7, functions_33e9, functionCalls_33eb);
}

void GetState_3063::operator()( const Packets_t& subsystems_3064, const Packets_t& charts_3067, const Packets_t& mains_306b, const Packets_t& functionCalls_306e, Packets_t& subsystems_3066, Packets_t& charts_3069, Packets_t& states_306a, Packets_t& mains_306d, Packets_t& functionCalls_3070)
{
#ifdef PRINT_INFO
	printLog( "GetState_3063" );
#endif
	RTTGenerator::Instance()->generateRule(2913, "GetState");
	_subsystem_3071= &subsystems_3066;
	_chart_3072= &charts_3069;
	_state_3073= &states_306a;
	_main_3074= &mains_306d;
	_functionCall_3075= &functionCalls_3070;
	processInputPackets( subsystems_3064, charts_3067, mains_306b, functionCalls_306e);
}

bool GetState_3063::isInputUnique( const Udm::Object& subsystem_307a, const Udm::Object& chart_3083, const Udm::Object& main_308c, const Udm::Object& functionCall_3095)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_307c= _subsystem_3076.begin(), itChart_3085= _chart_307f.begin(), itMain_308e= _main_3088.begin(), itFunctionCall_3097= _functionCall_3091.begin(); itSubsystem_307c!= _subsystem_3076.end(), itChart_3085!= _chart_307f.end(), itMain_308e!= _main_3088.end(), itFunctionCall_3097!= _functionCall_3091.end(); ++itSubsystem_307c, ++itChart_3085, ++itMain_308e, ++itFunctionCall_3097)
	{
		if( ( *itSubsystem_307c== subsystem_307a)&& ( *itChart_3085== chart_3083)&& ( *itMain_308e== main_308c)&& ( *itFunctionCall_3097== functionCall_3095))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_3076.push_back( subsystem_307a);
		_chart_307f.push_back( chart_3083);
		_main_3088.push_back( main_308c);
		_functionCall_3091.push_back( functionCall_3095);
	}
	return isUnique;
}

bool GetState_3063::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetState_3063::processInputPackets( const Packets_t& subsystems_3064, const Packets_t& charts_3067, const Packets_t& mains_306b, const Packets_t& functionCalls_306e)
{
	for( Packets_t::const_iterator itSubsystem_3077= subsystems_3064.begin(), itChart_3080= charts_3067.begin(), itMain_3089= mains_306b.begin(), itFunctionCall_3092= functionCalls_306e.begin(); itSubsystem_3077!= subsystems_3064.end(), itChart_3080!= charts_3067.end(), itMain_3089!= mains_306b.end(), itFunctionCall_3092!= functionCalls_306e.end(); ++itSubsystem_3077, ++itChart_3080, ++itMain_3089, ++itFunctionCall_3092)
	{
		bool isUnique= isInputUnique( *itSubsystem_3077, *itChart_3080, *itMain_3089, *itFunctionCall_3092);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_3077, *itChart_3080, *itMain_3089, *itFunctionCall_3092);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetState_3063::patternMatcher( const Udm::Object& subsystem_3078, const Udm::Object& chart_3081, const Udm::Object& main_308a, const Udm::Object& functionCall_3093)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_3078.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_307d= CyberComposition::Simulink::Subsystem::Cast( subsystem_3078);
		if( false== Uml::IsDerivedFrom( chart_3081.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem chart_3086= CyberComposition::Simulink::Subsystem::Cast( chart_3081);
		if( false== Uml::IsDerivedFrom( main_308a.type(), SFC::Function::meta))
			continue;
		SFC::Function main_308f= SFC::Function::Cast( main_308a);
		if( false== Uml::IsDerivedFrom( functionCall_3093.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall functionCall_3098= SFC::FunctionCall::Cast( functionCall_3093);
		set< CyberComposition::Simulink::Primitive> primitives_309a= chart_3086.Primitive_kind_children();
		for( set< CyberComposition::Simulink::Primitive>::const_iterator itPrimitive_309b= primitives_309a.begin(); itPrimitive_309b!= primitives_309a.end(); ++itPrimitive_309b)
		{
			CyberComposition::Simulink::Primitive currPrimitive_309c= *itPrimitive_309b;
			set< CyberComposition::Simulink::State> states_309d= currPrimitive_309c.State_kind_children();
			for( set< CyberComposition::Simulink::State>::const_iterator itState_309e= states_309d.begin(); itState_309e!= states_309d.end(); ++itState_309e)
			{
				CyberComposition::Simulink::State currState_309f= *itState_309e;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_30a3;
				if( !isValidBound(boundObjs_30a3, subsystem_307d, true))
					continue;
				currMatch.subsystem_30a4= subsystem_307d;
				if( !isValidBound(boundObjs_30a3, chart_3086, true))
					continue;
				currMatch.chart_30a5= chart_3086;
				if( !isValidBound(boundObjs_30a3, main_308f, true))
					continue;
				currMatch.main_30a6= main_308f;
				if( !isValidBound(boundObjs_30a3, functionCall_3098, true))
					continue;
				currMatch.functionCall_30a7= functionCall_3098;
				if( !isValidBound(boundObjs_30a3, currState_309f, false))
					continue;
				currMatch.state_30a8= currState_309f;
				if( !isValidBound(boundObjs_30a3, currPrimitive_309c, false))
					continue;
				currMatch.primitive_30a9= currPrimitive_309c;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetState_3063::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_30a4, currMatch.chart_30a5, currMatch.state_30a8, currMatch.main_30a6, currMatch.functionCall_30a7);
	}
}

void GetState_3063::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_30aa, const CyberComposition::Simulink::Subsystem& chart_30ac, const CyberComposition::Simulink::State& state_30ae, const SFC::Function& main_30b0, const SFC::FunctionCall& functionCall_30b2)
{
	_subsystem_3071->push_back( subsystem_30aa);
	_chart_3072->push_back( chart_30ac);
	_state_3073->push_back( state_30ae);
	_main_3074->push_back( main_30b0);
	_functionCall_3075->push_back( functionCall_30b2);
}

void CreateFunctionCall_30b4::operator()( const Packets_t& subsystems_30b5, const Packets_t& charts_30b8, const Packets_t& compoundStatements_30bd, Packets_t& subsystems_30b7, Packets_t& charts_30ba, Packets_t& mains_30bb, Packets_t& functionCalls_30bc)
{
#ifdef PRINT_INFO
	printLog( "CreateFunctionCall_30b4" );
#endif
	RTTGenerator::Instance()->generateRule(2922, "CreateFunctionCall");
	_subsystem_30bf= &subsystems_30b7;
	_chart_30c0= &charts_30ba;
	_main_30c1= &mains_30bb;
	_functionCall_30c2= &functionCalls_30bc;
	processInputPackets( subsystems_30b5, charts_30b8, compoundStatements_30bd);
}

bool CreateFunctionCall_30b4::isInputUnique( const Udm::Object& subsystem_30c7, const Udm::Object& chart_30d0, const Udm::Object& compoundStatement_30d9)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_30c9= _subsystem_30c3.begin(), itChart_30d2= _chart_30cc.begin(), itCompoundStatement_30db= _compoundStatement_30d5.begin(); itSubsystem_30c9!= _subsystem_30c3.end(), itChart_30d2!= _chart_30cc.end(), itCompoundStatement_30db!= _compoundStatement_30d5.end(); ++itSubsystem_30c9, ++itChart_30d2, ++itCompoundStatement_30db)
	{
		if( ( *itSubsystem_30c9== subsystem_30c7)&& ( *itChart_30d2== chart_30d0)&& ( *itCompoundStatement_30db== compoundStatement_30d9))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_30c3.push_back( subsystem_30c7);
		_chart_30cc.push_back( chart_30d0);
		_compoundStatement_30d5.push_back( compoundStatement_30d9);
	}
	return isUnique;
}

bool CreateFunctionCall_30b4::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateFunctionCall_30b4::processInputPackets( const Packets_t& subsystems_30b5, const Packets_t& charts_30b8, const Packets_t& compoundStatements_30bd)
{
	for( Packets_t::const_iterator itSubsystem_30c4= subsystems_30b5.begin(), itChart_30cd= charts_30b8.begin(), itCompoundStatement_30d6= compoundStatements_30bd.begin(); itSubsystem_30c4!= subsystems_30b5.end(), itChart_30cd!= charts_30b8.end(), itCompoundStatement_30d6!= compoundStatements_30bd.end(); ++itSubsystem_30c4, ++itChart_30cd, ++itCompoundStatement_30d6)
	{
		bool isUnique= isInputUnique( *itSubsystem_30c4, *itChart_30cd, *itCompoundStatement_30d6);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_30c4, *itChart_30cd, *itCompoundStatement_30d6);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateFunctionCall_30b4::patternMatcher( const Udm::Object& subsystem_30c5, const Udm::Object& chart_30ce, const Udm::Object& compoundStatement_30d7)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_30c5.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_30ca= CyberComposition::Simulink::Subsystem::Cast( subsystem_30c5);
		if( false== Uml::IsDerivedFrom( chart_30ce.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem chart_30d3= CyberComposition::Simulink::Subsystem::Cast( chart_30ce);
		if( false== Uml::IsDerivedFrom( compoundStatement_30d7.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_30dc= SFC::CompoundStatement::Cast( compoundStatement_30d7);
		SFC::Function main_30de= chart_30d3.main();
		if( !main_30de)
			continue;
		set< SFC::Arg> args_30df= main_30de.Arg_kind_children();
		for( set< SFC::Arg>::const_iterator itArg_30e0= args_30df.begin(); itArg_30e0!= args_30df.end(); ++itArg_30e0)
		{
			SFC::Arg currArg_30e1= *itArg_30e0;
			Udm::Object mainParent_30e2= main_30de.container();
			if( false== Uml::IsDerivedFrom( mainParent_30e2.type(), SFC::Class::meta))
				continue;
			SFC::Class classMain_30e3= SFC::Class::Cast( mainParent_30e2);
			set< SFC::Struct> structs_30e4= classMain_30e3.Struct_kind_children();
			for( set< SFC::Struct>::const_iterator itStruct_30e5= structs_30e4.begin(); itStruct_30e5!= structs_30e4.end(); ++itStruct_30e5)
			{
				SFC::Struct currStruct_30e6= *itStruct_30e5;
				SFC::DT struct_30e7= currArg_30e1.dt();
				if( !struct_30e7 || false== Uml::IsDerivedFrom( struct_30e7.type(), SFC::Struct::meta))
					continue;
				SFC::Struct struct_30e8= SFC::Struct::Cast( struct_30e7);
				if( !struct_30e8)
					continue;
				if( currStruct_30e6!= struct_30e8)
					continue;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_30ec;
				if( !isValidBound(boundObjs_30ec, subsystem_30ca, true))
					continue;
				currMatch.subsystem_30ed= subsystem_30ca;
				if( !isValidBound(boundObjs_30ec, chart_30d3, true))
					continue;
				currMatch.chart_30ee= chart_30d3;
				if( !isValidBound(boundObjs_30ec, compoundStatement_30dc, true))
					continue;
				currMatch.compoundStatement_30ef= compoundStatement_30dc;
				if( !isValidBound(boundObjs_30ec, classMain_30e3, false))
					continue;
				currMatch.class_30f0= classMain_30e3;
				if( !isValidBound(boundObjs_30ec, currStruct_30e6, false))
					continue;
				currMatch.struct_30f1= currStruct_30e6;
				if( !isValidBound(boundObjs_30ec, currArg_30e1, false))
					continue;
				currMatch.arg_30f2= currArg_30e1;
				if( !isValidBound(boundObjs_30ec, main_30de, false))
					continue;
				currMatch.main_30f3= main_30de;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void CreateFunctionCall_30b4::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::FunctionCall newFunctionCall_30f4= SFC::FunctionCall::Create( currMatch.compoundStatement_30ef, SFC::CompoundStatement::meta_stmnt);
		SFC::ArgVal newArgVal_30f5= SFC::ArgVal::Create( newFunctionCall_30f4);
		SFC::Arg& Arg= currMatch.arg_30f2;
		SFC::ArgVal& ArgVal= newArgVal_30f5;
		CyberComposition::Simulink::Subsystem& Chart= currMatch.chart_30ee;
		SFC::Class& Class= currMatch.class_30f0;
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_30ef;
		SFC::FunctionCall& FunctionCall= newFunctionCall_30f4;
		SFC::Function& Main= currMatch.main_30f3;
		SFC::Struct& Struct= currMatch.struct_30f1;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_30ed;
		{
FunctionCall.argCount() = 1;
std::string fname = Chart.Name();
fname += "_main";
FunctionCall.libFuncName() = fname;
ArgVal.val() = "0"; /* need to fill this with instance number */
 
};
		{
__int64 statementCount = CompoundStatement.statementCount();
FunctionCall.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		{
ArgVal.argIndex() = static_cast< __int64 >( Arg.argIndex() );
};
		newFunctionCall_30f4.obj()= currMatch.chart_30ee;
		newFunctionCall_30f4.callee()= currMatch.main_30f3;
		newArgVal_30f5.arg()+= currMatch.arg_30f2;
		outputAppender( currMatch.subsystem_30ed, currMatch.chart_30ee, currMatch.main_30f3, newFunctionCall_30f4);
	}
}

void CreateFunctionCall_30b4::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_30f6, const CyberComposition::Simulink::Subsystem& chart_30f8, const SFC::Function& main_30fa, const SFC::FunctionCall& functionCall_30fc)
{
	_subsystem_30bf->push_back( subsystem_30f6);
	_chart_30c0->push_back( chart_30f8);
	_main_30c1->push_back( main_30fa);
	_functionCall_30c2->push_back( functionCall_30fc);
}

void OutputData_30fe::operator()( const Packets_t& systems_30ff, const Packets_t& childCharts_3101, const Packets_t& states_3103, const Packets_t& functions_3105, const Packets_t& functionCalls_3107, Packets_t& systems_3109, Packets_t& childCharts_310a, Packets_t& states_310b, Packets_t& functions_310c, Packets_t& functionCalls_310d)
{
#ifdef PRINT_INFO
	printLog( "OutputData_30fe" );
#endif
	_system_310e= &systems_3109;
	_childChart_310f= &childCharts_310a;
	_state_3110= &states_310b;
	_function_3111= &functions_310c;
	_functionCall_3112= &functionCalls_310d;
	_system_310e->insert( _system_310e->end(), systems_30ff.begin(), systems_30ff.end());
	_childChart_310f->insert( _childChart_310f->end(), childCharts_3101.begin(), childCharts_3101.end());
	_state_3110->insert( _state_3110->end(), states_3103.begin(), states_3103.end());
	_function_3111->insert( _function_3111->end(), functions_3105.begin(), functions_3105.end());
	_functionCall_3112->insert( _functionCall_3112->end(), functionCalls_3107.begin(), functionCalls_3107.end());
	if( ( !systems_30ff.empty())&& ( !childCharts_3101.empty())&& ( !states_3103.empty())&& ( !functions_3105.empty())&& ( !functionCalls_3107.empty()))
		callCreateOutputDataArgVal_31cc( systems_30ff, childCharts_3101, states_3103, functions_3105, functionCalls_3107);
}

void OutputData_30fe::callCreateOutputDataArgVal_31cc( const Packets_t& subsystems_3114, const Packets_t& charts_3118, const Packets_t& states_311a, const Packets_t& mains_311c, const Packets_t& functionCalls_3120)
{
	Packets_t subsystems_3116;
	Packets_t outputPorts_3117;
	Packets_t mains_311e;
	Packets_t argVals_311f;
	Packets_t functionCalls_3122;
	CreateOutputDataArgVal_3113 createOutputDataArgVal_3113;
	createOutputDataArgVal_3113( subsystems_3114, charts_3118, states_311a, mains_311c, functionCalls_3120, subsystems_3116, outputPorts_3117, mains_311e, argVals_311f, functionCalls_3122);
	if( ( !subsystems_3116.empty())&& ( !outputPorts_3117.empty())&& ( !mains_311e.empty())&& ( !argVals_311f.empty())&& ( !functionCalls_3122.empty()))
		callUpdateArgCount_31d2( subsystems_3116, outputPorts_3117, mains_311e, argVals_311f, functionCalls_3122);
}

void OutputData_30fe::callUpdateArgCount_31d2( const Packets_t& subsystems_3179, const Packets_t& outputPorts_317c, const Packets_t& functions_317f, const Packets_t& argVals_3181, const Packets_t& functionCalls_3184)
{
	Packets_t subsystems_317b;
	Packets_t outputPorts_317e;
	Packets_t argVals_3183;
	UpdateArgCount_3178 updateArgCount_3178;
	updateArgCount_3178( subsystems_3179, outputPorts_317c, functions_317f, argVals_3181, functionCalls_3184, subsystems_317b, outputPorts_317e, argVals_3183);
	if( ( !subsystems_317b.empty())&& ( !outputPorts_317e.empty())&& ( !argVals_3183.empty()))
		callMakeArgDeclRef_31d8( subsystems_317b, outputPorts_317e, argVals_3183);
}

void OutputData_30fe::callMakeArgDeclRef_31d8( const Packets_t& systems_2cf6, const Packets_t& argPorts_2cf8, const Packets_t& argVals_2cfa)
{
	MakeArgDeclRef_2cf5 makeArgDeclRef_2cf5;
	makeArgDeclRef_2cf5( systems_2cf6, argPorts_2cf8, argVals_2cfa);
}

void CreateOutputDataArgVal_3113::operator()( const Packets_t& subsystems_3114, const Packets_t& charts_3118, const Packets_t& states_311a, const Packets_t& mains_311c, const Packets_t& functionCalls_3120, Packets_t& subsystems_3116, Packets_t& outputPorts_3117, Packets_t& mains_311e, Packets_t& argVals_311f, Packets_t& functionCalls_3122)
{
#ifdef PRINT_INFO
	printLog( "CreateOutputDataArgVal_3113" );
#endif
	RTTGenerator::Instance()->generateRule(2956, "CreateOutputDataArgVal");
	_subsystem_3123= &subsystems_3116;
	_outputPort_3124= &outputPorts_3117;
	_main_3125= &mains_311e;
	_argVal_3126= &argVals_311f;
	_functionCall_3127= &functionCalls_3122;
	processInputPackets( subsystems_3114, charts_3118, states_311a, mains_311c, functionCalls_3120);
}

bool CreateOutputDataArgVal_3113::isInputUnique( const Udm::Object& subsystem_312c, const Udm::Object& chart_3135, const Udm::Object& state_313e, const Udm::Object& main_3147, const Udm::Object& functionCall_3150)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_312e= _subsystem_3128.begin(), itChart_3137= _chart_3131.begin(), itState_3140= _state_313a.begin(), itMain_3149= _main_3143.begin(), itFunctionCall_3152= _functionCall_314c.begin(); itSubsystem_312e!= _subsystem_3128.end(), itChart_3137!= _chart_3131.end(), itState_3140!= _state_313a.end(), itMain_3149!= _main_3143.end(), itFunctionCall_3152!= _functionCall_314c.end(); ++itSubsystem_312e, ++itChart_3137, ++itState_3140, ++itMain_3149, ++itFunctionCall_3152)
	{
		if( ( *itSubsystem_312e== subsystem_312c)&& ( *itChart_3137== chart_3135)&& ( *itState_3140== state_313e)&& ( *itMain_3149== main_3147)&& ( *itFunctionCall_3152== functionCall_3150))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_3128.push_back( subsystem_312c);
		_chart_3131.push_back( chart_3135);
		_state_313a.push_back( state_313e);
		_main_3143.push_back( main_3147);
		_functionCall_314c.push_back( functionCall_3150);
	}
	return isUnique;
}

bool CreateOutputDataArgVal_3113::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool CreateOutputDataArgVal_3113::isGuardTrue( CyberComposition::Simulink::Subsystem& Chart, CyberComposition::Simulink::Data& Data, SFC::FunctionCall& FunctionCall, SFC::Function& Main, CyberComposition::Simulink::OutputPort& OutputPort, CyberComposition::Simulink::State& State, CyberComposition::Simulink::Subsystem& Subsystem)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( Data.Scope() ) == "OUTPUT_DATA" &&
 static_cast< std::string >( OutputPort.name() ) == static_cast< std::string >( Data.name() );;
	return Gz_guard;
}

void CreateOutputDataArgVal_3113::processInputPackets( const Packets_t& subsystems_3114, const Packets_t& charts_3118, const Packets_t& states_311a, const Packets_t& mains_311c, const Packets_t& functionCalls_3120)
{
	for( Packets_t::const_iterator itSubsystem_3129= subsystems_3114.begin(), itChart_3132= charts_3118.begin(), itState_313b= states_311a.begin(), itMain_3144= mains_311c.begin(), itFunctionCall_314d= functionCalls_3120.begin(); itSubsystem_3129!= subsystems_3114.end(), itChart_3132!= charts_3118.end(), itState_313b!= states_311a.end(), itMain_3144!= mains_311c.end(), itFunctionCall_314d!= functionCalls_3120.end(); ++itSubsystem_3129, ++itChart_3132, ++itState_313b, ++itMain_3144, ++itFunctionCall_314d)
	{
		bool isUnique= isInputUnique( *itSubsystem_3129, *itChart_3132, *itState_313b, *itMain_3144, *itFunctionCall_314d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_3129, *itChart_3132, *itState_313b, *itMain_3144, *itFunctionCall_314d);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateOutputDataArgVal_3113::patternMatcher( const Udm::Object& subsystem_312a, const Udm::Object& chart_3133, const Udm::Object& state_313c, const Udm::Object& main_3145, const Udm::Object& functionCall_314e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_312a.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_312f= CyberComposition::Simulink::Subsystem::Cast( subsystem_312a);
		if( false== Uml::IsDerivedFrom( chart_3133.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem chart_3138= CyberComposition::Simulink::Subsystem::Cast( chart_3133);
		if( false== Uml::IsDerivedFrom( state_313c.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_3141= CyberComposition::Simulink::State::Cast( state_313c);
		if( false== Uml::IsDerivedFrom( main_3145.type(), SFC::Function::meta))
			continue;
		SFC::Function main_314a= SFC::Function::Cast( main_3145);
		if( false== Uml::IsDerivedFrom( functionCall_314e.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall functionCall_3153= SFC::FunctionCall::Cast( functionCall_314e);
		set< CyberComposition::Simulink::Data> datas_3155= state_3141.Data_kind_children();
		for( set< CyberComposition::Simulink::Data>::const_iterator itData_3156= datas_3155.begin(); itData_3156!= datas_3155.end(); ++itData_3156)
		{
			CyberComposition::Simulink::Data currData_3157= *itData_3156;
			set< CyberComposition::Simulink::OutputPort> outputPorts_3158= chart_3138.OutputPort_kind_children();
			for( set< CyberComposition::Simulink::OutputPort>::const_iterator itOutputPort_3159= outputPorts_3158.begin(); itOutputPort_3159!= outputPorts_3158.end(); ++itOutputPort_3159)
			{
				CyberComposition::Simulink::OutputPort currOutputPort_315a= *itOutputPort_3159;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_315e;
				if( !isValidBound(boundObjs_315e, subsystem_312f, true))
					continue;
				currMatch.subsystem_315f= subsystem_312f;
				if( !isValidBound(boundObjs_315e, chart_3138, true))
					continue;
				currMatch.chart_3160= chart_3138;
				if( !isValidBound(boundObjs_315e, state_3141, true))
					continue;
				currMatch.state_3161= state_3141;
				if( !isValidBound(boundObjs_315e, main_314a, true))
					continue;
				currMatch.main_3162= main_314a;
				if( !isValidBound(boundObjs_315e, functionCall_3153, true))
					continue;
				currMatch.functionCall_3163= functionCall_3153;
				if( !isValidBound(boundObjs_315e, currOutputPort_315a, false))
					continue;
				currMatch.outputPort_3164= currOutputPort_315a;
				if( !isValidBound(boundObjs_315e, currData_3157, false))
					continue;
				currMatch.data_3165= currData_3157;
				bool Gz_guard= isGuardTrue( currMatch.chart_3160, currMatch.data_3165, currMatch.functionCall_3163, currMatch.main_3162, currMatch.outputPort_3164, currMatch.state_3161, currMatch.subsystem_315f);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void CreateOutputDataArgVal_3113::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ArgVal newArgVal_316d= SFC::ArgVal::Create( currMatch.functionCall_3163);
		SFC::ArgVal& ArgVal= newArgVal_316d;
		CyberComposition::Simulink::Subsystem& Chart= currMatch.chart_3160;
		CyberComposition::Simulink::Data& Data= currMatch.data_3165;
		SFC::FunctionCall& FunctionCall= currMatch.functionCall_3163;
		SFC::Function& Main= currMatch.main_3162;
		CyberComposition::Simulink::OutputPort& OutputPort= currMatch.outputPort_3164;
		CyberComposition::Simulink::State& State= currMatch.state_3161;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_315f;
		{
ArgVal.argIndex() = static_cast< __int64 >( FunctionCall.argCount() ) + static_cast< __int64 >( Data.Port() ) - 1;
};
		outputAppender( currMatch.subsystem_315f, currMatch.outputPort_3164, currMatch.main_3162, newArgVal_316d, currMatch.functionCall_3163);
	}
}

void CreateOutputDataArgVal_3113::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_316e, const CyberComposition::Simulink::OutputPort& outputPort_3170, const SFC::Function& main_3172, const SFC::ArgVal& argVal_3174, const SFC::FunctionCall& functionCall_3176)
{
	_subsystem_3123->push_back( subsystem_316e);
	_outputPort_3124->push_back( outputPort_3170);
	_main_3125->push_back( main_3172);
	_argVal_3126->push_back( argVal_3174);
	_functionCall_3127->push_back( functionCall_3176);
}

void UpdateArgCount_3178::operator()( const Packets_t& subsystems_3179, const Packets_t& outputPorts_317c, const Packets_t& functions_317f, const Packets_t& argVals_3181, const Packets_t& functionCalls_3184, Packets_t& subsystems_317b, Packets_t& outputPorts_317e, Packets_t& argVals_3183)
{
#ifdef PRINT_INFO
	printLog( "UpdateArgCount_3178" );
#endif
	RTTGenerator::Instance()->generateRule(2969, "UpdateArgCount");
	_subsystem_3186= &subsystems_317b;
	_outputPort_3187= &outputPorts_317e;
	_argVal_3188= &argVals_3183;
	processInputPackets( subsystems_3179, outputPorts_317c, functions_317f, argVals_3181, functionCalls_3184);
	forwardInputs( );
}

bool UpdateArgCount_3178::isInputUnique( const Udm::Object& subsystem_318d, const Udm::Object& outputPort_3196, const Udm::Object& function_319f, const Udm::Object& argVal_31a8, const Udm::Object& functionCall_31b1)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_318f= _subsystem_3189.begin(), itOutputPort_3198= _outputPort_3192.begin(), itFunction_31a1= _function_319b.begin(), itArgVal_31aa= _argVal_31a4.begin(), itFunctionCall_31b3= _functionCall_31ad.begin(); itSubsystem_318f!= _subsystem_3189.end(), itOutputPort_3198!= _outputPort_3192.end(), itFunction_31a1!= _function_319b.end(), itArgVal_31aa!= _argVal_31a4.end(), itFunctionCall_31b3!= _functionCall_31ad.end(); ++itSubsystem_318f, ++itOutputPort_3198, ++itFunction_31a1, ++itArgVal_31aa, ++itFunctionCall_31b3)
	{
		if( ( *itSubsystem_318f== subsystem_318d)&& ( *itOutputPort_3198== outputPort_3196)&& ( *itFunction_31a1== function_319f)&& ( *itArgVal_31aa== argVal_31a8)&& ( *itFunctionCall_31b3== functionCall_31b1))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_3189.push_back( subsystem_318d);
		_outputPort_3192.push_back( outputPort_3196);
		_function_319b.push_back( function_319f);
		_argVal_31a4.push_back( argVal_31a8);
		_functionCall_31ad.push_back( functionCall_31b1);
	}
	return isUnique;
}

bool UpdateArgCount_3178::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool UpdateArgCount_3178::isGuardTrue( SFC::Arg& Arg, SFC::ArgVal& ArgVal, SFC::Function& Function, SFC::FunctionCall& FunctionCall, CyberComposition::Simulink::OutputPort& OutputPort, CyberComposition::Simulink::Subsystem& Subsystem)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< __int64 >( Arg.argIndex() ) == static_cast< __int64 >( ArgVal.argIndex() );;
	return Gz_guard;
}

void UpdateArgCount_3178::processInputPackets( const Packets_t& subsystems_3179, const Packets_t& outputPorts_317c, const Packets_t& functions_317f, const Packets_t& argVals_3181, const Packets_t& functionCalls_3184)
{
	for( Packets_t::const_iterator itSubsystem_318a= subsystems_3179.begin(), itOutputPort_3193= outputPorts_317c.begin(), itFunction_319c= functions_317f.begin(), itArgVal_31a5= argVals_3181.begin(), itFunctionCall_31ae= functionCalls_3184.begin(); itSubsystem_318a!= subsystems_3179.end(), itOutputPort_3193!= outputPorts_317c.end(), itFunction_319c!= functions_317f.end(), itArgVal_31a5!= argVals_3181.end(), itFunctionCall_31ae!= functionCalls_3184.end(); ++itSubsystem_318a, ++itOutputPort_3193, ++itFunction_319c, ++itArgVal_31a5, ++itFunctionCall_31ae)
	{
		bool isUnique= isInputUnique( *itSubsystem_318a, *itOutputPort_3193, *itFunction_319c, *itArgVal_31a5, *itFunctionCall_31ae);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_318a, *itOutputPort_3193, *itFunction_319c, *itArgVal_31a5, *itFunctionCall_31ae);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool UpdateArgCount_3178::patternMatcher( const Udm::Object& subsystem_318b, const Udm::Object& outputPort_3194, const Udm::Object& function_319d, const Udm::Object& argVal_31a6, const Udm::Object& functionCall_31af)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_318b.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_3190= CyberComposition::Simulink::Subsystem::Cast( subsystem_318b);
		if( false== Uml::IsDerivedFrom( outputPort_3194.type(), CyberComposition::Simulink::OutputPort::meta))
			continue;
		CyberComposition::Simulink::OutputPort outputPort_3199= CyberComposition::Simulink::OutputPort::Cast( outputPort_3194);
		if( false== Uml::IsDerivedFrom( function_319d.type(), SFC::Function::meta))
			continue;
		SFC::Function function_31a2= SFC::Function::Cast( function_319d);
		if( false== Uml::IsDerivedFrom( argVal_31a6.type(), SFC::ArgVal::meta))
			continue;
		SFC::ArgVal argVal_31ab= SFC::ArgVal::Cast( argVal_31a6);
		if( false== Uml::IsDerivedFrom( functionCall_31af.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall functionCall_31b4= SFC::FunctionCall::Cast( functionCall_31af);
		set< SFC::ArgVal> argVals_31b6= functionCall_31b4.ArgVal_kind_children();
		for( set< SFC::ArgVal>::const_iterator itArgVal_31b7= argVals_31b6.begin(); itArgVal_31b7!= argVals_31b6.end(); ++itArgVal_31b7)
		{
			SFC::ArgVal currArgVal_31b8= *itArgVal_31b7;
			if( argVal_31ab!= currArgVal_31b8)
				continue;
			set< SFC::Arg> args_31b9= function_31a2.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itArg_31ba= args_31b9.begin(); itArg_31ba!= args_31b9.end(); ++itArg_31ba)
			{
				SFC::Arg currArg_31bb= *itArg_31ba;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_31bf;
				if( !isValidBound(boundObjs_31bf, subsystem_3190, true))
					continue;
				currMatch.subsystem_31c0= subsystem_3190;
				if( !isValidBound(boundObjs_31bf, outputPort_3199, true))
					continue;
				currMatch.outputPort_31c1= outputPort_3199;
				if( !isValidBound(boundObjs_31bf, function_31a2, true))
					continue;
				currMatch.function_31c2= function_31a2;
				if( !isValidBound(boundObjs_31bf, argVal_31ab, true))
					continue;
				currMatch.argVal_31c3= argVal_31ab;
				if( !isValidBound(boundObjs_31bf, functionCall_31b4, true))
					continue;
				currMatch.functionCall_31c4= functionCall_31b4;
				if( !isValidBound(boundObjs_31bf, currArg_31bb, false))
					continue;
				currMatch.arg_31c5= currArg_31bb;
				bool Gz_guard= isGuardTrue( currMatch.arg_31c5, currMatch.argVal_31c3, currMatch.function_31c2, currMatch.functionCall_31c4, currMatch.outputPort_31c1, currMatch.subsystem_31c0);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void UpdateArgCount_3178::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg& Arg= currMatch.arg_31c5;
		SFC::ArgVal& ArgVal= currMatch.argVal_31c3;
		SFC::Function& Function= currMatch.function_31c2;
		SFC::FunctionCall& FunctionCall= currMatch.functionCall_31c4;
		CyberComposition::Simulink::OutputPort& OutputPort= currMatch.outputPort_31c1;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_31c0;
		{
FunctionCall.argCount() = static_cast< __int64 >( FunctionCall.argCount() ) + 1;
};
		currMatch.argVal_31c3.arg()+= currMatch.arg_31c5;
	}
}

void UpdateArgCount_3178::forwardInputs()
{
	*_subsystem_3186= _subsystem_3189;
	*_outputPort_3187= _outputPort_3192;
	*_argVal_3188= _argVal_31a4;
}

void InputData_31dc::operator()( const Packets_t& systems_31dd, const Packets_t& childCharts_31df, const Packets_t& states_31e1, const Packets_t& functions_31e3, const Packets_t& functionCalls_31e5, Packets_t& systems_31e7, Packets_t& childCharts_31e8, Packets_t& states_31e9, Packets_t& functions_31ea, Packets_t& functionCalls_31eb)
{
#ifdef PRINT_INFO
	printLog( "InputData_31dc" );
#endif
	_system_31ec= &systems_31e7;
	_childChart_31ed= &childCharts_31e8;
	_state_31ee= &states_31e9;
	_function_31ef= &functions_31ea;
	_functionCall_31f0= &functionCalls_31eb;
	_system_31ec->insert( _system_31ec->end(), systems_31dd.begin(), systems_31dd.end());
	_childChart_31ed->insert( _childChart_31ed->end(), childCharts_31df.begin(), childCharts_31df.end());
	_state_31ee->insert( _state_31ee->end(), states_31e1.begin(), states_31e1.end());
	_function_31ef->insert( _function_31ef->end(), functions_31e3.begin(), functions_31e3.end());
	_functionCall_31f0->insert( _functionCall_31f0->end(), functionCalls_31e5.begin(), functionCalls_31e5.end());
	if( ( !systems_31dd.empty())&& ( !childCharts_31df.empty())&& ( !states_31e1.empty())&& ( !functions_31e3.empty())&& ( !functionCalls_31e5.empty()))
		callCreateInputDataArgVal_32aa( systems_31dd, childCharts_31df, states_31e1, functions_31e3, functionCalls_31e5);
}

void InputData_31dc::callCreateInputDataArgVal_32aa( const Packets_t& subsystems_31f2, const Packets_t& charts_31f6, const Packets_t& states_31f8, const Packets_t& mains_31fa, const Packets_t& functionCalls_31fe)
{
	Packets_t subsystems_31f4;
	Packets_t inputPorts_31f5;
	Packets_t mains_31fc;
	Packets_t argVals_31fd;
	Packets_t functionCalls_3200;
	CreateInputDataArgVal_31f1 createInputDataArgVal_31f1;
	createInputDataArgVal_31f1( subsystems_31f2, charts_31f6, states_31f8, mains_31fa, functionCalls_31fe, subsystems_31f4, inputPorts_31f5, mains_31fc, argVals_31fd, functionCalls_3200);
	if( ( !subsystems_31f4.empty())&& ( !inputPorts_31f5.empty())&& ( !mains_31fc.empty())&& ( !argVals_31fd.empty())&& ( !functionCalls_3200.empty()))
		callUpdateArgCount_32b0( subsystems_31f4, inputPorts_31f5, mains_31fc, argVals_31fd, functionCalls_3200);
}

void InputData_31dc::callUpdateArgCount_32b0( const Packets_t& subsystems_3257, const Packets_t& inputPorts_325a, const Packets_t& functions_325d, const Packets_t& argVals_325f, const Packets_t& functionCalls_3262)
{
	Packets_t subsystems_3259;
	Packets_t inputPorts_325c;
	Packets_t argVals_3261;
	UpdateArgCount_3256 updateArgCount_3256;
	updateArgCount_3256( subsystems_3257, inputPorts_325a, functions_325d, argVals_325f, functionCalls_3262, subsystems_3259, inputPorts_325c, argVals_3261);
	if( ( !subsystems_3259.empty())&& ( !inputPorts_325c.empty())&& ( !argVals_3261.empty()))
		callMakeArgDeclRef_32b6( subsystems_3259, inputPorts_325c, argVals_3261);
}

void InputData_31dc::callMakeArgDeclRef_32b6( const Packets_t& systems_2cf6, const Packets_t& argPorts_2cf8, const Packets_t& argVals_2cfa)
{
	MakeArgDeclRef_2cf5 makeArgDeclRef_2cf5;
	makeArgDeclRef_2cf5( systems_2cf6, argPorts_2cf8, argVals_2cfa);
}

void CreateInputDataArgVal_31f1::operator()( const Packets_t& subsystems_31f2, const Packets_t& charts_31f6, const Packets_t& states_31f8, const Packets_t& mains_31fa, const Packets_t& functionCalls_31fe, Packets_t& subsystems_31f4, Packets_t& inputPorts_31f5, Packets_t& mains_31fc, Packets_t& argVals_31fd, Packets_t& functionCalls_3200)
{
#ifdef PRINT_INFO
	printLog( "CreateInputDataArgVal_31f1" );
#endif
	RTTGenerator::Instance()->generateRule(2991, "CreateInputDataArgVal");
	_subsystem_3201= &subsystems_31f4;
	_inputPort_3202= &inputPorts_31f5;
	_main_3203= &mains_31fc;
	_argVal_3204= &argVals_31fd;
	_functionCall_3205= &functionCalls_3200;
	processInputPackets( subsystems_31f2, charts_31f6, states_31f8, mains_31fa, functionCalls_31fe);
}

bool CreateInputDataArgVal_31f1::isInputUnique( const Udm::Object& subsystem_320a, const Udm::Object& chart_3213, const Udm::Object& state_321c, const Udm::Object& main_3225, const Udm::Object& functionCall_322e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_320c= _subsystem_3206.begin(), itChart_3215= _chart_320f.begin(), itState_321e= _state_3218.begin(), itMain_3227= _main_3221.begin(), itFunctionCall_3230= _functionCall_322a.begin(); itSubsystem_320c!= _subsystem_3206.end(), itChart_3215!= _chart_320f.end(), itState_321e!= _state_3218.end(), itMain_3227!= _main_3221.end(), itFunctionCall_3230!= _functionCall_322a.end(); ++itSubsystem_320c, ++itChart_3215, ++itState_321e, ++itMain_3227, ++itFunctionCall_3230)
	{
		if( ( *itSubsystem_320c== subsystem_320a)&& ( *itChart_3215== chart_3213)&& ( *itState_321e== state_321c)&& ( *itMain_3227== main_3225)&& ( *itFunctionCall_3230== functionCall_322e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_3206.push_back( subsystem_320a);
		_chart_320f.push_back( chart_3213);
		_state_3218.push_back( state_321c);
		_main_3221.push_back( main_3225);
		_functionCall_322a.push_back( functionCall_322e);
	}
	return isUnique;
}

bool CreateInputDataArgVal_31f1::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool CreateInputDataArgVal_31f1::isGuardTrue( CyberComposition::Simulink::Subsystem& Chart, CyberComposition::Simulink::Data& Data, SFC::FunctionCall& FunctionCall, CyberComposition::Simulink::InputPort& InputPort, SFC::Function& Main, CyberComposition::Simulink::State& State, CyberComposition::Simulink::Subsystem& Subsystem)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( Data.Scope() ) == "INPUT_DATA" &&
 static_cast< __int64 >( InputPort.Number() ) == static_cast< __int64 >( Data.Port() );;
	return Gz_guard;
}

void CreateInputDataArgVal_31f1::processInputPackets( const Packets_t& subsystems_31f2, const Packets_t& charts_31f6, const Packets_t& states_31f8, const Packets_t& mains_31fa, const Packets_t& functionCalls_31fe)
{
	for( Packets_t::const_iterator itSubsystem_3207= subsystems_31f2.begin(), itChart_3210= charts_31f6.begin(), itState_3219= states_31f8.begin(), itMain_3222= mains_31fa.begin(), itFunctionCall_322b= functionCalls_31fe.begin(); itSubsystem_3207!= subsystems_31f2.end(), itChart_3210!= charts_31f6.end(), itState_3219!= states_31f8.end(), itMain_3222!= mains_31fa.end(), itFunctionCall_322b!= functionCalls_31fe.end(); ++itSubsystem_3207, ++itChart_3210, ++itState_3219, ++itMain_3222, ++itFunctionCall_322b)
	{
		bool isUnique= isInputUnique( *itSubsystem_3207, *itChart_3210, *itState_3219, *itMain_3222, *itFunctionCall_322b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_3207, *itChart_3210, *itState_3219, *itMain_3222, *itFunctionCall_322b);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateInputDataArgVal_31f1::patternMatcher( const Udm::Object& subsystem_3208, const Udm::Object& chart_3211, const Udm::Object& state_321a, const Udm::Object& main_3223, const Udm::Object& functionCall_322c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_3208.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_320d= CyberComposition::Simulink::Subsystem::Cast( subsystem_3208);
		if( false== Uml::IsDerivedFrom( chart_3211.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem chart_3216= CyberComposition::Simulink::Subsystem::Cast( chart_3211);
		if( false== Uml::IsDerivedFrom( state_321a.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_321f= CyberComposition::Simulink::State::Cast( state_321a);
		if( false== Uml::IsDerivedFrom( main_3223.type(), SFC::Function::meta))
			continue;
		SFC::Function main_3228= SFC::Function::Cast( main_3223);
		if( false== Uml::IsDerivedFrom( functionCall_322c.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall functionCall_3231= SFC::FunctionCall::Cast( functionCall_322c);
		set< CyberComposition::Simulink::Data> datas_3233= state_321f.Data_kind_children();
		for( set< CyberComposition::Simulink::Data>::const_iterator itData_3234= datas_3233.begin(); itData_3234!= datas_3233.end(); ++itData_3234)
		{
			CyberComposition::Simulink::Data currData_3235= *itData_3234;
			set< CyberComposition::Simulink::InputPort> inputPorts_3236= chart_3216.InputPort_kind_children();
			for( set< CyberComposition::Simulink::InputPort>::const_iterator itInputPort_3237= inputPorts_3236.begin(); itInputPort_3237!= inputPorts_3236.end(); ++itInputPort_3237)
			{
				CyberComposition::Simulink::InputPort currInputPort_3238= *itInputPort_3237;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_323c;
				if( !isValidBound(boundObjs_323c, subsystem_320d, true))
					continue;
				currMatch.subsystem_323d= subsystem_320d;
				if( !isValidBound(boundObjs_323c, chart_3216, true))
					continue;
				currMatch.chart_323e= chart_3216;
				if( !isValidBound(boundObjs_323c, state_321f, true))
					continue;
				currMatch.state_323f= state_321f;
				if( !isValidBound(boundObjs_323c, main_3228, true))
					continue;
				currMatch.main_3240= main_3228;
				if( !isValidBound(boundObjs_323c, functionCall_3231, true))
					continue;
				currMatch.functionCall_3241= functionCall_3231;
				if( !isValidBound(boundObjs_323c, currInputPort_3238, false))
					continue;
				currMatch.inputPort_3242= currInputPort_3238;
				if( !isValidBound(boundObjs_323c, currData_3235, false))
					continue;
				currMatch.data_3243= currData_3235;
				bool Gz_guard= isGuardTrue( currMatch.chart_323e, currMatch.data_3243, currMatch.functionCall_3241, currMatch.inputPort_3242, currMatch.main_3240, currMatch.state_323f, currMatch.subsystem_323d);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void CreateInputDataArgVal_31f1::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ArgVal newArgVal_324b= SFC::ArgVal::Create( currMatch.functionCall_3241);
		SFC::ArgVal& ArgVal= newArgVal_324b;
		CyberComposition::Simulink::Subsystem& Chart= currMatch.chart_323e;
		CyberComposition::Simulink::Data& Data= currMatch.data_3243;
		SFC::FunctionCall& FunctionCall= currMatch.functionCall_3241;
		CyberComposition::Simulink::InputPort& InputPort= currMatch.inputPort_3242;
		SFC::Function& Main= currMatch.main_3240;
		CyberComposition::Simulink::State& State= currMatch.state_323f;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_323d;
		{
ArgVal.argIndex() = static_cast< __int64 >( FunctionCall.argCount() ) + static_cast< __int64 >( Data.Port() ) - 1;
};
		outputAppender( currMatch.subsystem_323d, currMatch.inputPort_3242, currMatch.main_3240, newArgVal_324b, currMatch.functionCall_3241);
	}
}

void CreateInputDataArgVal_31f1::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_324c, const CyberComposition::Simulink::InputPort& inputPort_324e, const SFC::Function& main_3250, const SFC::ArgVal& argVal_3252, const SFC::FunctionCall& functionCall_3254)
{
	_subsystem_3201->push_back( subsystem_324c);
	_inputPort_3202->push_back( inputPort_324e);
	_main_3203->push_back( main_3250);
	_argVal_3204->push_back( argVal_3252);
	_functionCall_3205->push_back( functionCall_3254);
}

void UpdateArgCount_3256::operator()( const Packets_t& subsystems_3257, const Packets_t& inputPorts_325a, const Packets_t& functions_325d, const Packets_t& argVals_325f, const Packets_t& functionCalls_3262, Packets_t& subsystems_3259, Packets_t& inputPorts_325c, Packets_t& argVals_3261)
{
#ifdef PRINT_INFO
	printLog( "UpdateArgCount_3256" );
#endif
	RTTGenerator::Instance()->generateRule(3004, "UpdateArgCount");
	_subsystem_3264= &subsystems_3259;
	_inputPort_3265= &inputPorts_325c;
	_argVal_3266= &argVals_3261;
	processInputPackets( subsystems_3257, inputPorts_325a, functions_325d, argVals_325f, functionCalls_3262);
	forwardInputs( );
}

bool UpdateArgCount_3256::isInputUnique( const Udm::Object& subsystem_326b, const Udm::Object& inputPort_3274, const Udm::Object& function_327d, const Udm::Object& argVal_3286, const Udm::Object& functionCall_328f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_326d= _subsystem_3267.begin(), itInputPort_3276= _inputPort_3270.begin(), itFunction_327f= _function_3279.begin(), itArgVal_3288= _argVal_3282.begin(), itFunctionCall_3291= _functionCall_328b.begin(); itSubsystem_326d!= _subsystem_3267.end(), itInputPort_3276!= _inputPort_3270.end(), itFunction_327f!= _function_3279.end(), itArgVal_3288!= _argVal_3282.end(), itFunctionCall_3291!= _functionCall_328b.end(); ++itSubsystem_326d, ++itInputPort_3276, ++itFunction_327f, ++itArgVal_3288, ++itFunctionCall_3291)
	{
		if( ( *itSubsystem_326d== subsystem_326b)&& ( *itInputPort_3276== inputPort_3274)&& ( *itFunction_327f== function_327d)&& ( *itArgVal_3288== argVal_3286)&& ( *itFunctionCall_3291== functionCall_328f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_3267.push_back( subsystem_326b);
		_inputPort_3270.push_back( inputPort_3274);
		_function_3279.push_back( function_327d);
		_argVal_3282.push_back( argVal_3286);
		_functionCall_328b.push_back( functionCall_328f);
	}
	return isUnique;
}

bool UpdateArgCount_3256::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool UpdateArgCount_3256::isGuardTrue( SFC::Arg& Arg, SFC::ArgVal& ArgVal, SFC::Function& Function, SFC::FunctionCall& FunctionCall, CyberComposition::Simulink::InputPort& InputPort, CyberComposition::Simulink::Subsystem& Subsystem)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< __int64 >( Arg.argIndex() ) == static_cast< __int64 >( ArgVal.argIndex() );;
	return Gz_guard;
}

void UpdateArgCount_3256::processInputPackets( const Packets_t& subsystems_3257, const Packets_t& inputPorts_325a, const Packets_t& functions_325d, const Packets_t& argVals_325f, const Packets_t& functionCalls_3262)
{
	for( Packets_t::const_iterator itSubsystem_3268= subsystems_3257.begin(), itInputPort_3271= inputPorts_325a.begin(), itFunction_327a= functions_325d.begin(), itArgVal_3283= argVals_325f.begin(), itFunctionCall_328c= functionCalls_3262.begin(); itSubsystem_3268!= subsystems_3257.end(), itInputPort_3271!= inputPorts_325a.end(), itFunction_327a!= functions_325d.end(), itArgVal_3283!= argVals_325f.end(), itFunctionCall_328c!= functionCalls_3262.end(); ++itSubsystem_3268, ++itInputPort_3271, ++itFunction_327a, ++itArgVal_3283, ++itFunctionCall_328c)
	{
		bool isUnique= isInputUnique( *itSubsystem_3268, *itInputPort_3271, *itFunction_327a, *itArgVal_3283, *itFunctionCall_328c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_3268, *itInputPort_3271, *itFunction_327a, *itArgVal_3283, *itFunctionCall_328c);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool UpdateArgCount_3256::patternMatcher( const Udm::Object& subsystem_3269, const Udm::Object& inputPort_3272, const Udm::Object& function_327b, const Udm::Object& argVal_3284, const Udm::Object& functionCall_328d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_3269.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_326e= CyberComposition::Simulink::Subsystem::Cast( subsystem_3269);
		if( false== Uml::IsDerivedFrom( inputPort_3272.type(), CyberComposition::Simulink::InputPort::meta))
			continue;
		CyberComposition::Simulink::InputPort inputPort_3277= CyberComposition::Simulink::InputPort::Cast( inputPort_3272);
		if( false== Uml::IsDerivedFrom( function_327b.type(), SFC::Function::meta))
			continue;
		SFC::Function function_3280= SFC::Function::Cast( function_327b);
		if( false== Uml::IsDerivedFrom( argVal_3284.type(), SFC::ArgVal::meta))
			continue;
		SFC::ArgVal argVal_3289= SFC::ArgVal::Cast( argVal_3284);
		if( false== Uml::IsDerivedFrom( functionCall_328d.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall functionCall_3292= SFC::FunctionCall::Cast( functionCall_328d);
		set< SFC::ArgVal> argVals_3294= functionCall_3292.ArgVal_kind_children();
		for( set< SFC::ArgVal>::const_iterator itArgVal_3295= argVals_3294.begin(); itArgVal_3295!= argVals_3294.end(); ++itArgVal_3295)
		{
			SFC::ArgVal currArgVal_3296= *itArgVal_3295;
			if( argVal_3289!= currArgVal_3296)
				continue;
			set< SFC::Arg> args_3297= function_3280.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itArg_3298= args_3297.begin(); itArg_3298!= args_3297.end(); ++itArg_3298)
			{
				SFC::Arg currArg_3299= *itArg_3298;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_329d;
				if( !isValidBound(boundObjs_329d, subsystem_326e, true))
					continue;
				currMatch.subsystem_329e= subsystem_326e;
				if( !isValidBound(boundObjs_329d, inputPort_3277, true))
					continue;
				currMatch.inputPort_329f= inputPort_3277;
				if( !isValidBound(boundObjs_329d, function_3280, true))
					continue;
				currMatch.function_32a0= function_3280;
				if( !isValidBound(boundObjs_329d, argVal_3289, true))
					continue;
				currMatch.argVal_32a1= argVal_3289;
				if( !isValidBound(boundObjs_329d, functionCall_3292, true))
					continue;
				currMatch.functionCall_32a2= functionCall_3292;
				if( !isValidBound(boundObjs_329d, currArg_3299, false))
					continue;
				currMatch.arg_32a3= currArg_3299;
				bool Gz_guard= isGuardTrue( currMatch.arg_32a3, currMatch.argVal_32a1, currMatch.function_32a0, currMatch.functionCall_32a2, currMatch.inputPort_329f, currMatch.subsystem_329e);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void UpdateArgCount_3256::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg& Arg= currMatch.arg_32a3;
		SFC::ArgVal& ArgVal= currMatch.argVal_32a1;
		SFC::Function& Function= currMatch.function_32a0;
		SFC::FunctionCall& FunctionCall= currMatch.functionCall_32a2;
		CyberComposition::Simulink::InputPort& InputPort= currMatch.inputPort_329f;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_329e;
		{
FunctionCall.argCount() = static_cast< __int64 >( FunctionCall.argCount() ) + 1;
};
		currMatch.argVal_32a1.arg()+= currMatch.arg_32a3;
	}
}

void UpdateArgCount_3256::forwardInputs()
{
	*_subsystem_3264= _subsystem_3267;
	*_inputPort_3265= _inputPort_3270;
	*_argVal_3266= _argVal_3282;
}

void InputEvent_32ba::operator()( const Packets_t& systems_32bb, const Packets_t& childCharts_32bd, const Packets_t& states_32bf, const Packets_t& functions_32c1, const Packets_t& functionCalls_32c3, Packets_t& systems_32c5, Packets_t& childCharts_32c6, Packets_t& states_32c7, Packets_t& functions_32c8, Packets_t& functionCalls_32c9)
{
#ifdef PRINT_INFO
	printLog( "InputEvent_32ba" );
#endif
	_system_32ca= &systems_32c5;
	_childChart_32cb= &childCharts_32c6;
	_state_32cc= &states_32c7;
	_function_32cd= &functions_32c8;
	_functionCall_32ce= &functionCalls_32c9;
	_system_32ca->insert( _system_32ca->end(), systems_32bb.begin(), systems_32bb.end());
	_childChart_32cb->insert( _childChart_32cb->end(), childCharts_32bd.begin(), childCharts_32bd.end());
	_state_32cc->insert( _state_32cc->end(), states_32bf.begin(), states_32bf.end());
	_function_32cd->insert( _function_32cd->end(), functions_32c1.begin(), functions_32c1.end());
	_functionCall_32ce->insert( _functionCall_32ce->end(), functionCalls_32c3.begin(), functionCalls_32c3.end());
	if( ( !childCharts_32bd.empty())&& ( !functions_32c1.empty())&& ( !functionCalls_32c3.empty()))
		callGetOldVar_33d6( childCharts_32bd, functions_32c1, functionCalls_32c3);
}

void InputEvent_32ba::callGetOldVar_33d6( const Packets_t& blocks_32d1, const Packets_t& mains_32d3, const Packets_t& functionCalls_32d6)
{
	Packets_t localVars_32d0;
	Packets_t mains_32d5;
	Packets_t functionCalls_32d8;
	GetOldVar_32cf getOldVar_32cf;
	getOldVar_32cf( blocks_32d1, mains_32d3, functionCalls_32d6, localVars_32d0, mains_32d5, functionCalls_32d8);
	if( ( !localVars_32d0.empty())&& ( !mains_32d5.empty())&& ( !functionCalls_32d8.empty()))
		callMatrixInputEvent_33da( localVars_32d0, mains_32d5, functionCalls_32d8);
}

void InputEvent_32ba::callMatrixInputEvent_33da( const Packets_t& oldvars_330b, const Packets_t& functions_330d, const Packets_t& functionCalls_330f)
{
	Packets_t oldvars_3311;
	Packets_t functions_3312;
	Packets_t functionCalls_3313;
	MatrixInputEvent_330a matrixInputEvent_330a;
	matrixInputEvent_330a( oldvars_330b, functions_330d, functionCalls_330f, oldvars_3311, functions_3312, functionCalls_3313);
	if( ( !oldvars_3311.empty())&& ( !functions_3312.empty())&& ( !functionCalls_3313.empty()))
		callStructInputEvent_33de( oldvars_3311, functions_3312, functionCalls_3313);
}

void InputEvent_32ba::callStructInputEvent_33de( const Packets_t& oldvars_3355, const Packets_t& functions_3357, const Packets_t& functionCalls_3359)
{
	StructInputEvent_3354 structInputEvent_3354;
	structInputEvent_3354( oldvars_3355, functions_3357, functionCalls_3359);
}

void GetOldVar_32cf::operator()( const Packets_t& blocks_32d1, const Packets_t& mains_32d3, const Packets_t& functionCalls_32d6, Packets_t& localVars_32d0, Packets_t& mains_32d5, Packets_t& functionCalls_32d8)
{
#ifdef PRINT_INFO
	printLog( "GetOldVar_32cf" );
#endif
	RTTGenerator::Instance()->generateRule(3026, "GetOldVar");
	_localVar_32d9= &localVars_32d0;
	_main_32da= &mains_32d5;
	_functionCall_32db= &functionCalls_32d8;
	processInputPackets( blocks_32d1, mains_32d3, functionCalls_32d6);
}

bool GetOldVar_32cf::isInputUnique( const Udm::Object& block_32e0, const Udm::Object& main_32e9, const Udm::Object& functionCall_32f2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itBlock_32e2= _block_32dc.begin(), itMain_32eb= _main_32e5.begin(), itFunctionCall_32f4= _functionCall_32ee.begin(); itBlock_32e2!= _block_32dc.end(), itMain_32eb!= _main_32e5.end(), itFunctionCall_32f4!= _functionCall_32ee.end(); ++itBlock_32e2, ++itMain_32eb, ++itFunctionCall_32f4)
	{
		if( ( *itBlock_32e2== block_32e0)&& ( *itMain_32eb== main_32e9)&& ( *itFunctionCall_32f4== functionCall_32f2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_block_32dc.push_back( block_32e0);
		_main_32e5.push_back( main_32e9);
		_functionCall_32ee.push_back( functionCall_32f2);
	}
	return isUnique;
}

bool GetOldVar_32cf::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetOldVar_32cf::processInputPackets( const Packets_t& blocks_32d1, const Packets_t& mains_32d3, const Packets_t& functionCalls_32d6)
{
	for( Packets_t::const_iterator itBlock_32dd= blocks_32d1.begin(), itMain_32e6= mains_32d3.begin(), itFunctionCall_32ef= functionCalls_32d6.begin(); itBlock_32dd!= blocks_32d1.end(), itMain_32e6!= mains_32d3.end(), itFunctionCall_32ef!= functionCalls_32d6.end(); ++itBlock_32dd, ++itMain_32e6, ++itFunctionCall_32ef)
	{
		bool isUnique= isInputUnique( *itBlock_32dd, *itMain_32e6, *itFunctionCall_32ef);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itBlock_32dd, *itMain_32e6, *itFunctionCall_32ef);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetOldVar_32cf::patternMatcher( const Udm::Object& block_32de, const Udm::Object& main_32e7, const Udm::Object& functionCall_32f0)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( block_32de.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem block_32e3= CyberComposition::Simulink::Subsystem::Cast( block_32de);
		if( false== Uml::IsDerivedFrom( main_32e7.type(), SFC::Function::meta))
			continue;
		SFC::Function main_32ec= SFC::Function::Cast( main_32e7);
		if( false== Uml::IsDerivedFrom( functionCall_32f0.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall functionCall_32f5= SFC::FunctionCall::Cast( functionCall_32f0);
		set< CyberComposition::Simulink::TriggerPort> triggerPorts_32f7= block_32e3.TriggerPort_kind_children();
		for( set< CyberComposition::Simulink::TriggerPort>::const_iterator itTriggerPort_32f8= triggerPorts_32f7.begin(); itTriggerPort_32f8!= triggerPorts_32f7.end(); ++itTriggerPort_32f8)
		{
			CyberComposition::Simulink::TriggerPort currTriggerPort_32f9= *itTriggerPort_32f8;
			SFC::LocalVar localVar_32fa= currTriggerPort_32f9.memb();
			if( !localVar_32fa)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_32fe;
			if( !isValidBound(boundObjs_32fe, block_32e3, true))
				continue;
			currMatch.block_32ff= block_32e3;
			if( !isValidBound(boundObjs_32fe, main_32ec, true))
				continue;
			currMatch.main_3300= main_32ec;
			if( !isValidBound(boundObjs_32fe, functionCall_32f5, true))
				continue;
			currMatch.functionCall_3301= functionCall_32f5;
			if( !isValidBound(boundObjs_32fe, localVar_32fa, false))
				continue;
			currMatch.localVar_3302= localVar_32fa;
			if( !isValidBound(boundObjs_32fe, currTriggerPort_32f9, false))
				continue;
			currMatch.triggerPort_3303= currTriggerPort_32f9;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetOldVar_32cf::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.localVar_3302, currMatch.main_3300, currMatch.functionCall_3301);
	}
}

void GetOldVar_32cf::outputAppender( const SFC::LocalVar& localVar_3304, const SFC::Function& main_3306, const SFC::FunctionCall& functionCall_3308)
{
	_localVar_32d9->push_back( localVar_3304);
	_main_32da->push_back( main_3306);
	_functionCall_32db->push_back( functionCall_3308);
}

void MatrixInputEvent_330a::operator()( const Packets_t& oldvars_330b, const Packets_t& functions_330d, const Packets_t& functionCalls_330f, Packets_t& oldvars_3311, Packets_t& functions_3312, Packets_t& functionCalls_3313)
{
#ifdef PRINT_INFO
	printLog( "MatrixInputEvent_330a" );
#endif
	_oldvar_3314= &oldvars_3311;
	_function_3315= &functions_3312;
	_functionCall_3316= &functionCalls_3313;
	_oldvar_3314->insert( _oldvar_3314->end(), oldvars_330b.begin(), oldvars_330b.end());
	_function_3315->insert( _function_3315->end(), functions_330d.begin(), functions_330d.end());
	_functionCall_3316->insert( _functionCall_3316->end(), functionCalls_330f.begin(), functionCalls_330f.end());
	if( ( !oldvars_330b.empty())&& ( !functions_330d.empty())&& ( !functionCalls_330f.empty()))
		callMatrixInputEventArgVal_3350( oldvars_330b, functions_330d, functionCalls_330f);
}

void MatrixInputEvent_330a::callMatrixInputEventArgVal_3350( const Packets_t& localVars_3318, const Packets_t& functions_331a, const Packets_t& functionCalls_331c)
{
	MatrixInputEventArgVal_3317 matrixInputEventArgVal_3317;
	matrixInputEventArgVal_3317( localVars_3318, functions_331a, functionCalls_331c);
}

void MatrixInputEventArgVal_3317::operator()( const Packets_t& localVars_3318, const Packets_t& functions_331a, const Packets_t& functionCalls_331c)
{
#ifdef PRINT_INFO
	printLog( "MatrixInputEventArgVal_3317" );
#endif
	RTTGenerator::Instance()->generateRule(3041, "MatrixInputEventArgVal");
	processInputPackets( localVars_3318, functions_331a, functionCalls_331c);
}

bool MatrixInputEventArgVal_3317::isInputUnique( const Udm::Object& localVar_3322, const Udm::Object& function_332b, const Udm::Object& functionCall_3334)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itLocalVar_3324= _localVar_331e.begin(), itFunction_332d= _function_3327.begin(), itFunctionCall_3336= _functionCall_3330.begin(); itLocalVar_3324!= _localVar_331e.end(), itFunction_332d!= _function_3327.end(), itFunctionCall_3336!= _functionCall_3330.end(); ++itLocalVar_3324, ++itFunction_332d, ++itFunctionCall_3336)
	{
		if( ( *itLocalVar_3324== localVar_3322)&& ( *itFunction_332d== function_332b)&& ( *itFunctionCall_3336== functionCall_3334))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_localVar_331e.push_back( localVar_3322);
		_function_3327.push_back( function_332b);
		_functionCall_3330.push_back( functionCall_3334);
	}
	return isUnique;
}

bool MatrixInputEventArgVal_3317::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool MatrixInputEventArgVal_3317::isGuardTrue( SFC::Arg& Arg, SFC::DT& DT, SFC::Function& Function, SFC::FunctionCall& FunctionCall, SFC::LocalVar& LocalVar, SFC::LocalVar& TriggerVar)
{
	bool Gz_guard= false;
	Gz_guard = DT.type() != SFC::Struct::meta;;
	return Gz_guard;
}

void MatrixInputEventArgVal_3317::processInputPackets( const Packets_t& localVars_3318, const Packets_t& functions_331a, const Packets_t& functionCalls_331c)
{
	for( Packets_t::const_iterator itLocalVar_331f= localVars_3318.begin(), itFunction_3328= functions_331a.begin(), itFunctionCall_3331= functionCalls_331c.begin(); itLocalVar_331f!= localVars_3318.end(), itFunction_3328!= functions_331a.end(), itFunctionCall_3331!= functionCalls_331c.end(); ++itLocalVar_331f, ++itFunction_3328, ++itFunctionCall_3331)
	{
		bool isUnique= isInputUnique( *itLocalVar_331f, *itFunction_3328, *itFunctionCall_3331);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itLocalVar_331f, *itFunction_3328, *itFunctionCall_3331);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool MatrixInputEventArgVal_3317::patternMatcher( const Udm::Object& localVar_3320, const Udm::Object& function_3329, const Udm::Object& functionCall_3332)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( localVar_3320.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_3325= SFC::LocalVar::Cast( localVar_3320);
		if( false== Uml::IsDerivedFrom( function_3329.type(), SFC::Function::meta))
			continue;
		SFC::Function function_332e= SFC::Function::Cast( function_3329);
		if( false== Uml::IsDerivedFrom( functionCall_3332.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall functionCall_3337= SFC::FunctionCall::Cast( functionCall_3332);
		set< SFC::Arg> args_3339= function_332e.Arg_kind_children();
		for( set< SFC::Arg>::const_iterator itArg_333a= args_3339.begin(); itArg_333a!= args_3339.end(); ++itArg_333a)
		{
			SFC::Arg currArg_333b= *itArg_333a;
			SFC::LocalVar triggerVar_333c= localVar_3325.trigvar();
			if( !triggerVar_333c)
				continue;
			SFC::DT dT_333d= localVar_3325.dt();
			if( !dT_333d)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_3341;
			if( !isValidBound(boundObjs_3341, localVar_3325, true))
				continue;
			currMatch.localVar_3342= localVar_3325;
			if( !isValidBound(boundObjs_3341, function_332e, true))
				continue;
			currMatch.function_3343= function_332e;
			if( !isValidBound(boundObjs_3341, functionCall_3337, true))
				continue;
			currMatch.functionCall_3344= functionCall_3337;
			if( !isValidBound(boundObjs_3341, dT_333d, false))
				continue;
			currMatch.dT_3345= dT_333d;
			if( !isValidBound(boundObjs_3341, triggerVar_333c, false))
				continue;
			currMatch.triggerVar_3346= triggerVar_333c;
			if( !isValidBound(boundObjs_3341, currArg_333b, false))
				continue;
			currMatch.arg_3347= currArg_333b;
			bool Gz_guard= isGuardTrue( currMatch.arg_3347, currMatch.dT_3345, currMatch.function_3343, currMatch.functionCall_3344, currMatch.localVar_3342, currMatch.triggerVar_3346);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void MatrixInputEventArgVal_3317::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ArgVal newArgVal_334e= SFC::ArgVal::Create( currMatch.functionCall_3344);
		SFC::ArgDeclRef newArgDeclRef_334f= SFC::ArgDeclRef::Create( newArgVal_334e, SFC::ArgVal::meta_argexpr);
		SFC::Arg& Arg= currMatch.arg_3347;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_334f;
		SFC::ArgVal& ArgVal= newArgVal_334e;
		SFC::DT& DT= currMatch.dT_3345;
		SFC::Function& Function= currMatch.function_3343;
		SFC::FunctionCall& FunctionCall= currMatch.functionCall_3344;
		SFC::LocalVar& LocalVar= currMatch.localVar_3342;
		SFC::LocalVar& TriggerVar= currMatch.triggerVar_3346;
		{
__int64 argCount = FunctionCall.argCount();
ArgVal.argIndex() = argCount++;
FunctionCall.argCount() = argCount;
};
		newArgDeclRef_334f.argdecl()= currMatch.triggerVar_3346;
		newArgVal_334e.arg()+= currMatch.arg_3347;
	}
}

void StructInputEvent_3354::operator()( const Packets_t& oldvars_3355, const Packets_t& functions_3357, const Packets_t& functionCalls_3359)
{
#ifdef PRINT_INFO
	printLog( "StructInputEvent_3354" );
#endif
	if( ( !oldvars_3355.empty())&& ( !functions_3357.empty())&& ( !functionCalls_3359.empty()))
		callStructInputEventArgVal_33ce( oldvars_3355, functions_3357, functionCalls_3359);
}

void StructInputEvent_3354::callStructInputEventArgVal_33ce( const Packets_t& localVars_335c, const Packets_t& mains_335e, const Packets_t& functionCalls_3362)
{
	Packets_t mains_3360;
	Packets_t argVals_3361;
	Packets_t functionCalls_3364;
	StructInputEventArgVal_335b structInputEventArgVal_335b;
	structInputEventArgVal_335b( localVars_335c, mains_335e, functionCalls_3362, mains_3360, argVals_3361, functionCalls_3364);
	if( ( !mains_3360.empty())&& ( !argVals_3361.empty())&& ( !functionCalls_3364.empty()))
		callUpdateArgCount_33d2( mains_3360, argVals_3361, functionCalls_3364);
}

void StructInputEvent_3354::callUpdateArgCount_33d2( const Packets_t& functions_339e, const Packets_t& argVals_33a0, const Packets_t& functionCalls_33a2)
{
	UpdateArgCount_339d updateArgCount_339d;
	updateArgCount_339d( functions_339e, argVals_33a0, functionCalls_33a2);
}

void StructInputEventArgVal_335b::operator()( const Packets_t& localVars_335c, const Packets_t& mains_335e, const Packets_t& functionCalls_3362, Packets_t& mains_3360, Packets_t& argVals_3361, Packets_t& functionCalls_3364)
{
#ifdef PRINT_INFO
	printLog( "StructInputEventArgVal_335b" );
#endif
	RTTGenerator::Instance()->generateRule(3062, "StructInputEventArgVal");
	_main_3365= &mains_3360;
	_argVal_3366= &argVals_3361;
	_functionCall_3367= &functionCalls_3364;
	processInputPackets( localVars_335c, mains_335e, functionCalls_3362);
}

bool StructInputEventArgVal_335b::isInputUnique( const Udm::Object& localVar_336c, const Udm::Object& main_3375, const Udm::Object& functionCall_337e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itLocalVar_336e= _localVar_3368.begin(), itMain_3377= _main_3371.begin(), itFunctionCall_3380= _functionCall_337a.begin(); itLocalVar_336e!= _localVar_3368.end(), itMain_3377!= _main_3371.end(), itFunctionCall_3380!= _functionCall_337a.end(); ++itLocalVar_336e, ++itMain_3377, ++itFunctionCall_3380)
	{
		if( ( *itLocalVar_336e== localVar_336c)&& ( *itMain_3377== main_3375)&& ( *itFunctionCall_3380== functionCall_337e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_localVar_3368.push_back( localVar_336c);
		_main_3371.push_back( main_3375);
		_functionCall_337a.push_back( functionCall_337e);
	}
	return isUnique;
}

bool StructInputEventArgVal_335b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void StructInputEventArgVal_335b::processInputPackets( const Packets_t& localVars_335c, const Packets_t& mains_335e, const Packets_t& functionCalls_3362)
{
	for( Packets_t::const_iterator itLocalVar_3369= localVars_335c.begin(), itMain_3372= mains_335e.begin(), itFunctionCall_337b= functionCalls_3362.begin(); itLocalVar_3369!= localVars_335c.end(), itMain_3372!= mains_335e.end(), itFunctionCall_337b!= functionCalls_3362.end(); ++itLocalVar_3369, ++itMain_3372, ++itFunctionCall_337b)
	{
		bool isUnique= isInputUnique( *itLocalVar_3369, *itMain_3372, *itFunctionCall_337b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itLocalVar_3369, *itMain_3372, *itFunctionCall_337b);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool StructInputEventArgVal_335b::patternMatcher( const Udm::Object& localVar_336a, const Udm::Object& main_3373, const Udm::Object& functionCall_337c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( localVar_336a.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_336f= SFC::LocalVar::Cast( localVar_336a);
		if( false== Uml::IsDerivedFrom( main_3373.type(), SFC::Function::meta))
			continue;
		SFC::Function main_3378= SFC::Function::Cast( main_3373);
		if( false== Uml::IsDerivedFrom( functionCall_337c.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall functionCall_3381= SFC::FunctionCall::Cast( functionCall_337c);
		SFC::DT struct_3383= localVar_336f.dt();
		if(!struct_3383 || false== Uml::IsDerivedFrom( struct_3383.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_3384= SFC::Struct::Cast( struct_3383);
		if( !struct_3384)
			continue;
		set< SFC::LocalVar> members_3385= struct_3384.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itMember_3386= members_3385.begin(); itMember_3386!= members_3385.end(); ++itMember_3386)
		{
			SFC::LocalVar currMember_3387= *itMember_3386;
			SFC::LocalVar triggerVar_3388= localVar_336f.trigvar();
			if( !triggerVar_3388)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_338c;
			if( !isValidBound(boundObjs_338c, localVar_336f, true))
				continue;
			currMatch.localVar_338d= localVar_336f;
			if( !isValidBound(boundObjs_338c, main_3378, true))
				continue;
			currMatch.main_338e= main_3378;
			if( !isValidBound(boundObjs_338c, functionCall_3381, true))
				continue;
			currMatch.functionCall_338f= functionCall_3381;
			if( !isValidBound(boundObjs_338c, triggerVar_3388, false))
				continue;
			currMatch.triggerVar_3390= triggerVar_3388;
			if( !isValidBound(boundObjs_338c, struct_3384, false))
				continue;
			currMatch.struct_3391= struct_3384;
			if( !isValidBound(boundObjs_338c, currMember_3387, false))
				continue;
			currMatch.member_3392= currMember_3387;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void StructInputEventArgVal_335b::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ArgVal newArgVal_3393= SFC::ArgVal::Create( currMatch.functionCall_338f);
		SFC::BinaryExprs newDot_3394= SFC::BinaryExprs::Create( newArgVal_3393, SFC::ArgVal::meta_argexpr);
		SFC::ArgDeclRef newArgDeclRef2_3395= SFC::ArgDeclRef::Create( newDot_3394, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_3396= SFC::ArgDeclRef::Create( newDot_3394, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_3396;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_3395;
		SFC::ArgVal& ArgVal= newArgVal_3393;
		SFC::BinaryExprs& Dot= newDot_3394;
		SFC::FunctionCall& FunctionCall= currMatch.functionCall_338f;
		SFC::LocalVar& LocalVar= currMatch.localVar_338d;
		SFC::Function& Main= currMatch.main_338e;
		SFC::LocalVar& Member= currMatch.member_3392;
		SFC::Struct& Struct= currMatch.struct_3391;
		SFC::LocalVar& TriggerVar= currMatch.triggerVar_3390;
		{
Dot.op() = ".";
};
		{
ArgVal.argIndex() = static_cast< __int64 >( FunctionCall.argCount() ) + static_cast< __int64 >( Member.statementIndex() );
};
		newArgDeclRef2_3395.argdecl()= currMatch.member_3392;
		newArgDeclRef_3396.argdecl()= currMatch.triggerVar_3390;
		outputAppender( currMatch.main_338e, newArgVal_3393, currMatch.functionCall_338f);
	}
}

void StructInputEventArgVal_335b::outputAppender( const SFC::Function& main_3397, const SFC::ArgVal& argVal_3399, const SFC::FunctionCall& functionCall_339b)
{
	_main_3365->push_back( main_3397);
	_argVal_3366->push_back( argVal_3399);
	_functionCall_3367->push_back( functionCall_339b);
}

void UpdateArgCount_339d::operator()( const Packets_t& functions_339e, const Packets_t& argVals_33a0, const Packets_t& functionCalls_33a2)
{
#ifdef PRINT_INFO
	printLog( "UpdateArgCount_339d" );
#endif
	RTTGenerator::Instance()->generateRule(3084, "UpdateArgCount");
	processInputPackets( functions_339e, argVals_33a0, functionCalls_33a2);
}

bool UpdateArgCount_339d::isInputUnique( const Udm::Object& function_33a8, const Udm::Object& argVal_33b1, const Udm::Object& functionCall_33ba)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itFunction_33aa= _function_33a4.begin(), itArgVal_33b3= _argVal_33ad.begin(), itFunctionCall_33bc= _functionCall_33b6.begin(); itFunction_33aa!= _function_33a4.end(), itArgVal_33b3!= _argVal_33ad.end(), itFunctionCall_33bc!= _functionCall_33b6.end(); ++itFunction_33aa, ++itArgVal_33b3, ++itFunctionCall_33bc)
	{
		if( ( *itFunction_33aa== function_33a8)&& ( *itArgVal_33b3== argVal_33b1)&& ( *itFunctionCall_33bc== functionCall_33ba))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_function_33a4.push_back( function_33a8);
		_argVal_33ad.push_back( argVal_33b1);
		_functionCall_33b6.push_back( functionCall_33ba);
	}
	return isUnique;
}

bool UpdateArgCount_339d::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool UpdateArgCount_339d::isGuardTrue( SFC::Arg& Arg, SFC::ArgVal& ArgVal, SFC::Function& Function, SFC::FunctionCall& FunctionCall)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< __int64 >( Arg.argIndex() ) == static_cast< __int64 >( ArgVal.argIndex() );;
	return Gz_guard;
}

void UpdateArgCount_339d::processInputPackets( const Packets_t& functions_339e, const Packets_t& argVals_33a0, const Packets_t& functionCalls_33a2)
{
	for( Packets_t::const_iterator itFunction_33a5= functions_339e.begin(), itArgVal_33ae= argVals_33a0.begin(), itFunctionCall_33b7= functionCalls_33a2.begin(); itFunction_33a5!= functions_339e.end(), itArgVal_33ae!= argVals_33a0.end(), itFunctionCall_33b7!= functionCalls_33a2.end(); ++itFunction_33a5, ++itArgVal_33ae, ++itFunctionCall_33b7)
	{
		bool isUnique= isInputUnique( *itFunction_33a5, *itArgVal_33ae, *itFunctionCall_33b7);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itFunction_33a5, *itArgVal_33ae, *itFunctionCall_33b7);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool UpdateArgCount_339d::patternMatcher( const Udm::Object& function_33a6, const Udm::Object& argVal_33af, const Udm::Object& functionCall_33b8)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( function_33a6.type(), SFC::Function::meta))
			continue;
		SFC::Function function_33ab= SFC::Function::Cast( function_33a6);
		if( false== Uml::IsDerivedFrom( argVal_33af.type(), SFC::ArgVal::meta))
			continue;
		SFC::ArgVal argVal_33b4= SFC::ArgVal::Cast( argVal_33af);
		if( false== Uml::IsDerivedFrom( functionCall_33b8.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall functionCall_33bd= SFC::FunctionCall::Cast( functionCall_33b8);
		set< SFC::Arg> args_33bf= function_33ab.Arg_kind_children();
		for( set< SFC::Arg>::const_iterator itArg_33c0= args_33bf.begin(); itArg_33c0!= args_33bf.end(); ++itArg_33c0)
		{
			SFC::Arg currArg_33c1= *itArg_33c0;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_33c5;
			if( !isValidBound(boundObjs_33c5, function_33ab, true))
				continue;
			currMatch.function_33c6= function_33ab;
			if( !isValidBound(boundObjs_33c5, argVal_33b4, true))
				continue;
			currMatch.argVal_33c7= argVal_33b4;
			if( !isValidBound(boundObjs_33c5, functionCall_33bd, true))
				continue;
			currMatch.functionCall_33c8= functionCall_33bd;
			if( !isValidBound(boundObjs_33c5, currArg_33c1, false))
				continue;
			currMatch.arg_33c9= currArg_33c1;
			bool Gz_guard= isGuardTrue( currMatch.arg_33c9, currMatch.argVal_33c7, currMatch.function_33c6, currMatch.functionCall_33c8);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void UpdateArgCount_339d::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg& Arg= currMatch.arg_33c9;
		SFC::ArgVal& ArgVal= currMatch.argVal_33c7;
		SFC::Function& Function= currMatch.function_33c6;
		SFC::FunctionCall& FunctionCall= currMatch.functionCall_33c8;
		{
FunctionCall.argCount() = static_cast< __int64 >( FunctionCall.argCount() ) + 1;
};
		currMatch.argVal_33c7.arg()+= currMatch.arg_33c9;
	}
}

void OutputEvent_33e2::operator()( const Packets_t& systems_33e3, const Packets_t& childCharts_33e5, const Packets_t& states_33e7, const Packets_t& functions_33e9, const Packets_t& functionCalls_33eb)
{
#ifdef PRINT_INFO
	printLog( "OutputEvent_33e2" );
#endif
	if( ( !systems_33e3.empty())&& ( !childCharts_33e5.empty())&& ( !states_33e7.empty())&& ( !functions_33e9.empty())&& ( !functionCalls_33eb.empty()))
		callCreateOutputEventArgVal_3452( systems_33e3, childCharts_33e5, states_33e7, functions_33e9, functionCalls_33eb);
}

void OutputEvent_33e2::callCreateOutputEventArgVal_3452( const Packets_t& subsystems_33ee, const Packets_t& charts_33f2, const Packets_t& states_33f4, const Packets_t& mains_33f6, const Packets_t& functionCalls_33fa)
{
	Packets_t subsystems_33f0;
	Packets_t outputPorts_33f1;
	Packets_t mains_33f8;
	Packets_t argVals_33f9;
	Packets_t functionCalls_33fc;
	CreateOutputEventArgVal_33ed createOutputEventArgVal_33ed;
	createOutputEventArgVal_33ed( subsystems_33ee, charts_33f2, states_33f4, mains_33f6, functionCalls_33fa, subsystems_33f0, outputPorts_33f1, mains_33f8, argVals_33f9, functionCalls_33fc);
	if( ( !subsystems_33f0.empty())&& ( !outputPorts_33f1.empty())&& ( !mains_33f8.empty())&& ( !argVals_33f9.empty())&& ( !functionCalls_33fc.empty()))
		callUpdateArgCount_3458( subsystems_33f0, outputPorts_33f1, mains_33f8, argVals_33f9, functionCalls_33fc);
}

void OutputEvent_33e2::callUpdateArgCount_3458( const Packets_t& subsystems_3179, const Packets_t& outputPorts_317c, const Packets_t& functions_317f, const Packets_t& argVals_3181, const Packets_t& functionCalls_3184)
{
	Packets_t subsystems_317b;
	Packets_t outputPorts_317e;
	Packets_t argVals_3183;
	UpdateArgCount_3178 updateArgCount_3178;
	updateArgCount_3178( subsystems_3179, outputPorts_317c, functions_317f, argVals_3181, functionCalls_3184, subsystems_317b, outputPorts_317e, argVals_3183);
	if( ( !subsystems_317b.empty())&& ( !outputPorts_317e.empty())&& ( !argVals_3183.empty()))
		callMakeArgDeclRef_345e( subsystems_317b, outputPorts_317e, argVals_3183);
}

void OutputEvent_33e2::callMakeArgDeclRef_345e( const Packets_t& systems_2cf6, const Packets_t& argPorts_2cf8, const Packets_t& argVals_2cfa)
{
	MakeArgDeclRef_2cf5 makeArgDeclRef_2cf5;
	makeArgDeclRef_2cf5( systems_2cf6, argPorts_2cf8, argVals_2cfa);
}

void CreateOutputEventArgVal_33ed::operator()( const Packets_t& subsystems_33ee, const Packets_t& charts_33f2, const Packets_t& states_33f4, const Packets_t& mains_33f6, const Packets_t& functionCalls_33fa, Packets_t& subsystems_33f0, Packets_t& outputPorts_33f1, Packets_t& mains_33f8, Packets_t& argVals_33f9, Packets_t& functionCalls_33fc)
{
#ifdef PRINT_INFO
	printLog( "CreateOutputEventArgVal_33ed" );
#endif
	RTTGenerator::Instance()->generateRule(3098, "CreateOutputEventArgVal");
	_subsystem_33fd= &subsystems_33f0;
	_outputPort_33fe= &outputPorts_33f1;
	_main_33ff= &mains_33f8;
	_argVal_3400= &argVals_33f9;
	_functionCall_3401= &functionCalls_33fc;
	processInputPackets( subsystems_33ee, charts_33f2, states_33f4, mains_33f6, functionCalls_33fa);
}

bool CreateOutputEventArgVal_33ed::isInputUnique( const Udm::Object& subsystem_3406, const Udm::Object& chart_340f, const Udm::Object& state_3418, const Udm::Object& main_3421, const Udm::Object& functionCall_342a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_3408= _subsystem_3402.begin(), itChart_3411= _chart_340b.begin(), itState_341a= _state_3414.begin(), itMain_3423= _main_341d.begin(), itFunctionCall_342c= _functionCall_3426.begin(); itSubsystem_3408!= _subsystem_3402.end(), itChart_3411!= _chart_340b.end(), itState_341a!= _state_3414.end(), itMain_3423!= _main_341d.end(), itFunctionCall_342c!= _functionCall_3426.end(); ++itSubsystem_3408, ++itChart_3411, ++itState_341a, ++itMain_3423, ++itFunctionCall_342c)
	{
		if( ( *itSubsystem_3408== subsystem_3406)&& ( *itChart_3411== chart_340f)&& ( *itState_341a== state_3418)&& ( *itMain_3423== main_3421)&& ( *itFunctionCall_342c== functionCall_342a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_3402.push_back( subsystem_3406);
		_chart_340b.push_back( chart_340f);
		_state_3414.push_back( state_3418);
		_main_341d.push_back( main_3421);
		_functionCall_3426.push_back( functionCall_342a);
	}
	return isUnique;
}

bool CreateOutputEventArgVal_33ed::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool CreateOutputEventArgVal_33ed::isGuardTrue( CyberComposition::Simulink::Subsystem& Chart, CyberComposition::Simulink::Event& Event, SFC::FunctionCall& FunctionCall, SFC::Function& Main, CyberComposition::Simulink::OutputPort& OutputPort, CyberComposition::Simulink::State& State, CyberComposition::Simulink::Subsystem& Subsystem)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( Event.Scope() ) == "OUTPUT_EVENT" &&
 static_cast< std::string >( OutputPort.name() ) == static_cast< std::string >( Event.name() );;
	return Gz_guard;
}

void CreateOutputEventArgVal_33ed::processInputPackets( const Packets_t& subsystems_33ee, const Packets_t& charts_33f2, const Packets_t& states_33f4, const Packets_t& mains_33f6, const Packets_t& functionCalls_33fa)
{
	for( Packets_t::const_iterator itSubsystem_3403= subsystems_33ee.begin(), itChart_340c= charts_33f2.begin(), itState_3415= states_33f4.begin(), itMain_341e= mains_33f6.begin(), itFunctionCall_3427= functionCalls_33fa.begin(); itSubsystem_3403!= subsystems_33ee.end(), itChart_340c!= charts_33f2.end(), itState_3415!= states_33f4.end(), itMain_341e!= mains_33f6.end(), itFunctionCall_3427!= functionCalls_33fa.end(); ++itSubsystem_3403, ++itChart_340c, ++itState_3415, ++itMain_341e, ++itFunctionCall_3427)
	{
		bool isUnique= isInputUnique( *itSubsystem_3403, *itChart_340c, *itState_3415, *itMain_341e, *itFunctionCall_3427);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_3403, *itChart_340c, *itState_3415, *itMain_341e, *itFunctionCall_3427);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateOutputEventArgVal_33ed::patternMatcher( const Udm::Object& subsystem_3404, const Udm::Object& chart_340d, const Udm::Object& state_3416, const Udm::Object& main_341f, const Udm::Object& functionCall_3428)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_3404.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_3409= CyberComposition::Simulink::Subsystem::Cast( subsystem_3404);
		if( false== Uml::IsDerivedFrom( chart_340d.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem chart_3412= CyberComposition::Simulink::Subsystem::Cast( chart_340d);
		if( false== Uml::IsDerivedFrom( state_3416.type(), CyberComposition::Simulink::State::meta))
			continue;
		CyberComposition::Simulink::State state_341b= CyberComposition::Simulink::State::Cast( state_3416);
		if( false== Uml::IsDerivedFrom( main_341f.type(), SFC::Function::meta))
			continue;
		SFC::Function main_3424= SFC::Function::Cast( main_341f);
		if( false== Uml::IsDerivedFrom( functionCall_3428.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall functionCall_342d= SFC::FunctionCall::Cast( functionCall_3428);
		set< CyberComposition::Simulink::OutputPort> outputPorts_342f= chart_3412.OutputPort_kind_children();
		for( set< CyberComposition::Simulink::OutputPort>::const_iterator itOutputPort_3430= outputPorts_342f.begin(); itOutputPort_3430!= outputPorts_342f.end(); ++itOutputPort_3430)
		{
			CyberComposition::Simulink::OutputPort currOutputPort_3431= *itOutputPort_3430;
			set< CyberComposition::Simulink::Event> events_3432= state_341b.Event_kind_children();
			for( set< CyberComposition::Simulink::Event>::const_iterator itEvent_3433= events_3432.begin(); itEvent_3433!= events_3432.end(); ++itEvent_3433)
			{
				CyberComposition::Simulink::Event currEvent_3434= *itEvent_3433;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_3438;
				if( !isValidBound(boundObjs_3438, subsystem_3409, true))
					continue;
				currMatch.subsystem_3439= subsystem_3409;
				if( !isValidBound(boundObjs_3438, chart_3412, true))
					continue;
				currMatch.chart_343a= chart_3412;
				if( !isValidBound(boundObjs_3438, state_341b, true))
					continue;
				currMatch.state_343b= state_341b;
				if( !isValidBound(boundObjs_3438, main_3424, true))
					continue;
				currMatch.main_343c= main_3424;
				if( !isValidBound(boundObjs_3438, functionCall_342d, true))
					continue;
				currMatch.functionCall_343d= functionCall_342d;
				if( !isValidBound(boundObjs_3438, currOutputPort_3431, false))
					continue;
				currMatch.outputPort_343e= currOutputPort_3431;
				if( !isValidBound(boundObjs_3438, currEvent_3434, false))
					continue;
				currMatch.event_343f= currEvent_3434;
				bool Gz_guard= isGuardTrue( currMatch.chart_343a, currMatch.event_343f, currMatch.functionCall_343d, currMatch.main_343c, currMatch.outputPort_343e, currMatch.state_343b, currMatch.subsystem_3439);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void CreateOutputEventArgVal_33ed::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ArgVal newArgVal_3447= SFC::ArgVal::Create( currMatch.functionCall_343d);
		SFC::ArgVal& ArgVal= newArgVal_3447;
		CyberComposition::Simulink::Subsystem& Chart= currMatch.chart_343a;
		CyberComposition::Simulink::Event& Event= currMatch.event_343f;
		SFC::FunctionCall& FunctionCall= currMatch.functionCall_343d;
		SFC::Function& Main= currMatch.main_343c;
		CyberComposition::Simulink::OutputPort& OutputPort= currMatch.outputPort_343e;
		CyberComposition::Simulink::State& State= currMatch.state_343b;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_3439;
		{
ArgVal.argIndex() = static_cast< __int64 >( FunctionCall.argCount() ) + static_cast< __int64 >( Event.Port() ) - 1;
};
		outputAppender( currMatch.subsystem_3439, currMatch.outputPort_343e, currMatch.main_343c, newArgVal_3447, currMatch.functionCall_343d);
	}
}

void CreateOutputEventArgVal_33ed::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_3448, const CyberComposition::Simulink::OutputPort& outputPort_344a, const SFC::Function& main_344c, const SFC::ArgVal& argVal_344e, const SFC::FunctionCall& functionCall_3450)
{
	_subsystem_33fd->push_back( subsystem_3448);
	_outputPort_33fe->push_back( outputPort_344a);
	_main_33ff->push_back( main_344c);
	_argVal_3400->push_back( argVal_344e);
	_functionCall_3401->push_back( functionCall_3450);
}

void MakeTrigger_3462::operator()( const Packets_t& systems_3463, const Packets_t& childSubsystems_3465, const Packets_t& systemFunctions_3467, Packets_t& systems_3469, Packets_t& childSubsystems_346a, Packets_t& compoundStatements_346b)
{
#ifdef PRINT_INFO
	printLog( "MakeTrigger_3462" );
#endif
	_system_346c= &systems_3469;
	_childSubsystem_346d= &childSubsystems_346a;
	_compoundStatement_346e= &compoundStatements_346b;
	if( ( !systems_3463.empty())&& ( !childSubsystems_3465.empty())&& ( !systemFunctions_3467.empty()))
		callIsTriggered_4159( systems_3463, childSubsystems_3465, systemFunctions_3467);
}

void MakeTrigger_3462::callIsTriggered_4159( const Packets_t& systems_40c4, const Packets_t& childSubsystems_40c6, const Packets_t& systemFunctions_40c8)
{
	Packets_t systems_40ca;
	Packets_t childSubsystems_40cb;
	Packets_t systemFunctions_40cc;
	Packets_t systems_40cd;
	Packets_t childSubsystems_40ce;
	Packets_t systemFunctions_40cf;
	IsTriggered_40c3 isTriggered_40c3;
	isTriggered_40c3( systems_40c4, childSubsystems_40c6, systemFunctions_40c8, systems_40ca, childSubsystems_40cb, systemFunctions_40cc, systems_40cd, childSubsystems_40ce, systemFunctions_40cf);
	_system_346c->insert( _system_346c->end(), systems_40cd.begin(), systems_40cd.end());
	_childSubsystem_346d->insert( _childSubsystem_346d->end(), childSubsystems_40ce.begin(), childSubsystems_40ce.end());
	_compoundStatement_346e->insert( _compoundStatement_346e->end(), systemFunctions_40cf.begin(), systemFunctions_40cf.end());
	if( ( !systems_40ca.empty())&& ( !childSubsystems_40cb.empty())&& ( !systemFunctions_40cc.empty()))
		callCreateTriggering_415d( systems_40ca, childSubsystems_40cb, systemFunctions_40cc);
}

void MakeTrigger_3462::callCreateTriggering_415d( const Packets_t& systems_3470, const Packets_t& childSubsystems_3472, const Packets_t& systemFunctions_3474)
{
	Packets_t systems_3476;
	Packets_t childSubsystems_3477;
	Packets_t conditionalBlocks_3478;
	CreateTriggering_346f createTriggering_346f;
	createTriggering_346f( systems_3470, childSubsystems_3472, systemFunctions_3474, systems_3476, childSubsystems_3477, conditionalBlocks_3478);
	_system_346c->insert( _system_346c->end(), systems_3476.begin(), systems_3476.end());
	_childSubsystem_346d->insert( _childSubsystem_346d->end(), childSubsystems_3477.begin(), childSubsystems_3477.end());
	_compoundStatement_346e->insert( _compoundStatement_346e->end(), conditionalBlocks_3478.begin(), conditionalBlocks_3478.end());
}

void CreateTriggering_346f::operator()( const Packets_t& systems_3470, const Packets_t& childSubsystems_3472, const Packets_t& systemFunctions_3474, Packets_t& systems_3476, Packets_t& childSubsystems_3477, Packets_t& conditionalBlocks_3478)
{
#ifdef PRINT_INFO
	printLog( "CreateTriggering_346f" );
#endif
	_system_3479= &systems_3476;
	_childSubsystem_347a= &childSubsystems_3477;
	_conditionalBlock_347b= &conditionalBlocks_3478;
	if( ( !systems_3470.empty())&& ( !childSubsystems_3472.empty())&& ( !systemFunctions_3474.empty()))
		callGetTriggerPort_40b5( systems_3470, childSubsystems_3472, systemFunctions_3474);
}

void CreateTriggering_346f::callGetTriggerPort_40b5( const Packets_t& subsystems_403c, const Packets_t& blocks_403f, const Packets_t& mains_4042)
{
	Packets_t subsystems_403e;
	Packets_t triggerPorts_4041;
	Packets_t mains_4044;
	GetTriggerPort_403b getTriggerPort_403b;
	getTriggerPort_403b( subsystems_403c, blocks_403f, mains_4042, subsystems_403e, triggerPorts_4041, mains_4044);
	if( ( !subsystems_403e.empty())&& ( !triggerPorts_4041.empty())&& ( !mains_4044.empty()))
		callAssignCondValLocalVar_40b9( subsystems_403e, triggerPorts_4041, mains_4044);
}

void CreateTriggering_346f::callAssignCondValLocalVar_40b9( const Packets_t& subsystems_4075, const Packets_t& triggerPorts_4078, const Packets_t& functions_407d)
{
	Packets_t subsystems_4077;
	Packets_t triggerPorts_407a;
	Packets_t argDeclBases_407b;
	Packets_t dTs_407c;
	Packets_t functions_407f;
	AssignCondValLocalVar_4074 assignCondValLocalVar_4074;
	assignCondValLocalVar_4074( subsystems_4075, triggerPorts_4078, functions_407d, subsystems_4077, triggerPorts_407a, argDeclBases_407b, dTs_407c, functions_407f);
	if( ( !subsystems_4077.empty())&& ( !triggerPorts_407a.empty())&& ( !argDeclBases_407b.empty())&& ( !dTs_407c.empty())&& ( !functions_407f.empty()))
		callMakeTrigger_40bd( subsystems_4077, triggerPorts_407a, argDeclBases_407b, dTs_407c, functions_407f);
}

void CreateTriggering_346f::callMakeTrigger_40bd( const Packets_t& systems_347d, const Packets_t& childSubsystemTriggers_347f, const Packets_t& argdecls_3481, const Packets_t& dts_3483, const Packets_t& functions_3485)
{
	Packets_t systems_3487;
	Packets_t childSubsystems_3488;
	Packets_t conditionals_3489;
	MakeTrigger_347c makeTrigger_347c;
	makeTrigger_347c( systems_347d, childSubsystemTriggers_347f, argdecls_3481, dts_3483, functions_3485, systems_3487, childSubsystems_3488, conditionals_3489);
	_system_3479->insert( _system_3479->end(), systems_3487.begin(), systems_3487.end());
	_childSubsystem_347a->insert( _childSubsystem_347a->end(), childSubsystems_3488.begin(), childSubsystems_3488.end());
	_conditionalBlock_347b->insert( _conditionalBlock_347b->end(), conditionals_3489.begin(), conditionals_3489.end());
}

void MakeTrigger_347c::operator()( const Packets_t& systems_347d, const Packets_t& childSubsystemTriggers_347f, const Packets_t& argdecls_3481, const Packets_t& dts_3483, const Packets_t& functions_3485, Packets_t& systems_3487, Packets_t& childSubsystems_3488, Packets_t& conditionals_3489)
{
#ifdef PRINT_INFO
	printLog( "MakeTrigger_347c" );
#endif
	_system_348a= &systems_3487;
	_childSubsystem_348b= &childSubsystems_3488;
	_conditional_348c= &conditionals_3489;
	if( ( !systems_347d.empty())&& ( !childSubsystemTriggers_347f.empty())&& ( !argdecls_3481.empty())&& ( !dts_3483.empty())&& ( !functions_3485.empty()))
		callAddStateVar_401f( systems_347d, childSubsystemTriggers_347f, argdecls_3481, dts_3483, functions_3485);
}

void MakeTrigger_347c::callAddStateVar_401f( const Packets_t& subsystems_37a0, const Packets_t& triggerPorts_37a3, const Packets_t& argDeclBases_37a6, const Packets_t& dTs_37aa, const Packets_t& functions_37ae)
{
	Packets_t subsystems_37a2;
	Packets_t charts_37a5;
	Packets_t argDeclBases_37a8;
	Packets_t localVars_37a9;
	Packets_t dTs_37ac;
	Packets_t args_37ad;
	Packets_t functions_37b0;
	AddStateVar_379f addStateVar_379f;
	addStateVar_379f( subsystems_37a0, triggerPorts_37a3, argDeclBases_37a6, dTs_37aa, functions_37ae, subsystems_37a2, charts_37a5, argDeclBases_37a8, localVars_37a9, dTs_37ac, args_37ad, functions_37b0);
	if( ( !subsystems_37a2.empty())&& ( !charts_37a5.empty())&& ( !argDeclBases_37a8.empty())&& ( !dTs_37ac.empty())&& ( !localVars_37a9.empty())&& ( !args_37ad.empty())&& ( !functions_37b0.empty()))
		callAddTriggerVars_4025( subsystems_37a2, charts_37a5, argDeclBases_37a8, dTs_37ac, localVars_37a9, args_37ad, functions_37b0);
}

void MakeTrigger_347c::callAddTriggerVars_4025( const Packets_t& systems_38fa, const Packets_t& childsystems_38fc, const Packets_t& argdecls_38fe, const Packets_t& dts_3900, const Packets_t& oldvals_3902, const Packets_t& contexts_3904, const Packets_t& functions_3906)
{
	Packets_t systems_3908;
	Packets_t childsystems_3909;
	Packets_t argdecls_390a;
	Packets_t dts_390b;
	Packets_t oldvals_390c;
	Packets_t contexts_390d;
	Packets_t functions_390e;
	AddTriggerVars_38f9 addTriggerVars_38f9;
	addTriggerVars_38f9( systems_38fa, childsystems_38fc, argdecls_38fe, dts_3900, oldvals_3902, contexts_3904, functions_3906, systems_3908, childsystems_3909, argdecls_390a, dts_390b, oldvals_390c, contexts_390d, functions_390e);
	if( ( !systems_3908.empty())&& ( !childsystems_3909.empty())&& ( !argdecls_390a.empty())&& ( !dts_390b.empty())&& ( !oldvals_390c.empty())&& ( !contexts_390d.empty())&& ( !functions_390e.empty()))
		callSaveState_402d( systems_3908, childsystems_3909, argdecls_390a, dts_390b, oldvals_390c, contexts_390d, functions_390e);
}

void MakeTrigger_347c::callSaveState_402d( const Packets_t& systems_380e, const Packets_t& childsystems_3810, const Packets_t& argdecls_3812, const Packets_t& dts_3814, const Packets_t& oldvals_3816, const Packets_t& contexts_3818, const Packets_t& functions_381a)
{
	Packets_t systems_381c;
	Packets_t childsystems_381d;
	Packets_t dts_381e;
	Packets_t oldvals_381f;
	Packets_t functions_3820;
	SaveState_380d saveState_380d;
	saveState_380d( systems_380e, childsystems_3810, argdecls_3812, dts_3814, oldvals_3816, contexts_3818, functions_381a, systems_381c, childsystems_381d, dts_381e, oldvals_381f, functions_3820);
	if( ( !systems_381c.empty())&& ( !childsystems_381d.empty())&& ( !dts_381e.empty())&& ( !oldvals_381f.empty())&& ( !functions_3820.empty()))
		callMakeCondition_4035( systems_381c, childsystems_381d, dts_381e, oldvals_381f, functions_3820);
}

void MakeTrigger_347c::callMakeCondition_4035( const Packets_t& systems_348e, const Packets_t& childSubsystems_3490, const Packets_t& dts_3492, const Packets_t& oldvals_3494, const Packets_t& functions_3496)
{
	Packets_t systems_3498;
	Packets_t childSubsystems_3499;
	Packets_t conditionals_349a;
	MakeCondition_348d makeCondition_348d;
	makeCondition_348d( systems_348e, childSubsystems_3490, dts_3492, oldvals_3494, functions_3496, systems_3498, childSubsystems_3499, conditionals_349a);
	_system_348a->insert( _system_348a->end(), systems_3498.begin(), systems_3498.end());
	_childSubsystem_348b->insert( _childSubsystem_348b->end(), childSubsystems_3499.begin(), childSubsystems_3499.end());
	_conditional_348c->insert( _conditional_348c->end(), conditionals_349a.begin(), conditionals_349a.end());
}

void MakeCondition_348d::operator()( const Packets_t& systems_348e, const Packets_t& childSubsystems_3490, const Packets_t& dts_3492, const Packets_t& oldvals_3494, const Packets_t& functions_3496, Packets_t& systems_3498, Packets_t& childSubsystems_3499, Packets_t& conditionals_349a)
{
#ifdef PRINT_INFO
	printLog( "MakeCondition_348d" );
#endif
	_system_349b= &systems_3498;
	_childSubsystem_349c= &childSubsystems_3499;
	_conditional_349d= &conditionals_349a;
	if( ( !systems_348e.empty())&& ( !childSubsystems_3490.empty())&& ( !dts_3492.empty())&& ( !oldvals_3494.empty())&& ( !functions_3496.empty()))
		callCreateConditional_3791( systems_348e, childSubsystems_3490, dts_3492, oldvals_3494, functions_3496);
}

void MakeCondition_348d::callCreateConditional_3791( const Packets_t& subsystems_349f, const Packets_t& charts_34a2, const Packets_t& dTs_34a5, const Packets_t& localVars_34a8, const Packets_t& functions_34ac)
{
	Packets_t subsystems_34a1;
	Packets_t charts_34a4;
	Packets_t dTs_34a7;
	Packets_t triggerVars_34aa;
	Packets_t userCodes_34ab;
	Packets_t conditionalBlocks_34ae;
	CreateConditional_349e createConditional_349e;
	createConditional_349e( subsystems_349f, charts_34a2, dTs_34a5, localVars_34a8, functions_34ac, subsystems_34a1, charts_34a4, dTs_34a7, triggerVars_34aa, userCodes_34ab, conditionalBlocks_34ae);
	_system_349b->insert( _system_349b->end(), subsystems_34a1.begin(), subsystems_34a1.end());
	_childSubsystem_349c->insert( _childSubsystem_349c->end(), charts_34a4.begin(), charts_34a4.end());
	_conditional_349d->insert( _conditional_349d->end(), conditionalBlocks_34ae.begin(), conditionalBlocks_34ae.end());
	if( ( !dTs_34a7.empty())&& ( !triggerVars_34aa.empty())&& ( !userCodes_34ab.empty()))
		callSetMatrixCondition_3797( dTs_34a7, triggerVars_34aa, userCodes_34ab);
}

void MakeCondition_348d::callSetMatrixCondition_3797( const Packets_t& dts_34fc, const Packets_t& triggervars_34fe, const Packets_t& conditions_3500)
{
	Packets_t dts_3502;
	Packets_t triggervars_3503;
	Packets_t conditions_3504;
	SetMatrixCondition_34fb setMatrixCondition_34fb;
	setMatrixCondition_34fb( dts_34fc, triggervars_34fe, conditions_3500, dts_3502, triggervars_3503, conditions_3504);
	if( ( !dts_3502.empty())&& ( !triggervars_3503.empty())&& ( !conditions_3504.empty()))
		callSetStructCondition_379b( dts_3502, triggervars_3503, conditions_3504);
}

void MakeCondition_348d::callSetStructCondition_379b( const Packets_t& dts_353a, const Packets_t& oldvals_353c, const Packets_t& conditions_353e)
{
	SetStructCondition_3539 setStructCondition_3539;
	setStructCondition_3539( dts_353a, oldvals_353c, conditions_353e);
}

void CreateConditional_349e::operator()( const Packets_t& subsystems_349f, const Packets_t& charts_34a2, const Packets_t& dTs_34a5, const Packets_t& localVars_34a8, const Packets_t& functions_34ac, Packets_t& subsystems_34a1, Packets_t& charts_34a4, Packets_t& dTs_34a7, Packets_t& triggerVars_34aa, Packets_t& userCodes_34ab, Packets_t& conditionalBlocks_34ae)
{
#ifdef PRINT_INFO
	printLog( "CreateConditional_349e" );
#endif
	RTTGenerator::Instance()->generateRule(3143, "CreateConditional");
	_subsystem_34af= &subsystems_34a1;
	_chart_34b0= &charts_34a4;
	_dT_34b1= &dTs_34a7;
	_triggerVar_34b2= &triggerVars_34aa;
	_userCode_34b3= &userCodes_34ab;
	_conditionalBlock_34b4= &conditionalBlocks_34ae;
	processInputPackets( subsystems_349f, charts_34a2, dTs_34a5, localVars_34a8, functions_34ac);
}

bool CreateConditional_349e::isInputUnique( const Udm::Object& subsystem_34b9, const Udm::Object& chart_34c2, const Udm::Object& dT_34cb, const Udm::Object& localVar_34d4, const Udm::Object& function_34dd)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_34bb= _subsystem_34b5.begin(), itChart_34c4= _chart_34be.begin(), itDT_34cd= _dT_34c7.begin(), itLocalVar_34d6= _localVar_34d0.begin(), itFunction_34df= _function_34d9.begin(); itSubsystem_34bb!= _subsystem_34b5.end(), itChart_34c4!= _chart_34be.end(), itDT_34cd!= _dT_34c7.end(), itLocalVar_34d6!= _localVar_34d0.end(), itFunction_34df!= _function_34d9.end(); ++itSubsystem_34bb, ++itChart_34c4, ++itDT_34cd, ++itLocalVar_34d6, ++itFunction_34df)
	{
		if( ( *itSubsystem_34bb== subsystem_34b9)&& ( *itChart_34c4== chart_34c2)&& ( *itDT_34cd== dT_34cb)&& ( *itLocalVar_34d6== localVar_34d4)&& ( *itFunction_34df== function_34dd))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_34b5.push_back( subsystem_34b9);
		_chart_34be.push_back( chart_34c2);
		_dT_34c7.push_back( dT_34cb);
		_localVar_34d0.push_back( localVar_34d4);
		_function_34d9.push_back( function_34dd);
	}
	return isUnique;
}

bool CreateConditional_349e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateConditional_349e::processInputPackets( const Packets_t& subsystems_349f, const Packets_t& charts_34a2, const Packets_t& dTs_34a5, const Packets_t& localVars_34a8, const Packets_t& functions_34ac)
{
	for( Packets_t::const_iterator itSubsystem_34b6= subsystems_349f.begin(), itChart_34bf= charts_34a2.begin(), itDT_34c8= dTs_34a5.begin(), itLocalVar_34d1= localVars_34a8.begin(), itFunction_34da= functions_34ac.begin(); itSubsystem_34b6!= subsystems_349f.end(), itChart_34bf!= charts_34a2.end(), itDT_34c8!= dTs_34a5.end(), itLocalVar_34d1!= localVars_34a8.end(), itFunction_34da!= functions_34ac.end(); ++itSubsystem_34b6, ++itChart_34bf, ++itDT_34c8, ++itLocalVar_34d1, ++itFunction_34da)
	{
		bool isUnique= isInputUnique( *itSubsystem_34b6, *itChart_34bf, *itDT_34c8, *itLocalVar_34d1, *itFunction_34da);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_34b6, *itChart_34bf, *itDT_34c8, *itLocalVar_34d1, *itFunction_34da);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateConditional_349e::patternMatcher( const Udm::Object& subsystem_34b7, const Udm::Object& chart_34c0, const Udm::Object& dT_34c9, const Udm::Object& localVar_34d2, const Udm::Object& function_34db)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_34b7.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_34bc= CyberComposition::Simulink::Subsystem::Cast( subsystem_34b7);
		if( false== Uml::IsDerivedFrom( chart_34c0.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem chart_34c5= CyberComposition::Simulink::Subsystem::Cast( chart_34c0);
		if( false== Uml::IsDerivedFrom( dT_34c9.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_34ce= SFC::DT::Cast( dT_34c9);
		if( false== Uml::IsDerivedFrom( localVar_34d2.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_34d7= SFC::LocalVar::Cast( localVar_34d2);
		if( false== Uml::IsDerivedFrom( function_34db.type(), SFC::Function::meta))
			continue;
		SFC::Function function_34e0= SFC::Function::Cast( function_34db);
		SFC::LocalVar triggerVar_34e2= localVar_34d7.trigvar();
		if( !triggerVar_34e2)
			continue;
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_34e6;
		if( !isValidBound(boundObjs_34e6, subsystem_34bc, true))
			continue;
		currMatch.subsystem_34e7= subsystem_34bc;
		if( !isValidBound(boundObjs_34e6, chart_34c5, true))
			continue;
		currMatch.chart_34e8= chart_34c5;
		if( !isValidBound(boundObjs_34e6, dT_34ce, true))
			continue;
		currMatch.dT_34e9= dT_34ce;
		if( !isValidBound(boundObjs_34e6, localVar_34d7, true))
			continue;
		currMatch.localVar_34ea= localVar_34d7;
		if( !isValidBound(boundObjs_34e6, function_34e0, true))
			continue;
		currMatch.function_34eb= function_34e0;
		if( !isValidBound(boundObjs_34e6, triggerVar_34e2, false))
			continue;
		currMatch.triggerVar_34ec= triggerVar_34e2;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateConditional_349e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_34ed= SFC::ConditionalBlock::Create( currMatch.function_34eb, SFC::Function::meta_stmnt);
		SFC::UserCode newUserCode_34ee= SFC::UserCode::Create( newConditionalBlock_34ed, SFC::ConditionalBlock::meta_cond);
		CyberComposition::Simulink::Subsystem& Chart= currMatch.chart_34e8;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_34ed;
		SFC::DT& DT= currMatch.dT_34e9;
		SFC::Function& Function= currMatch.function_34eb;
		SFC::LocalVar& LocalVar= currMatch.localVar_34ea;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_34e7;
		SFC::LocalVar& TriggerVar= currMatch.triggerVar_34ec;
		SFC::UserCode& UserCode= newUserCode_34ee;
		{
__int64 statementCount = Function.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		outputAppender( currMatch.subsystem_34e7, currMatch.chart_34e8, currMatch.dT_34e9, currMatch.triggerVar_34ec, newUserCode_34ee, newConditionalBlock_34ed);
	}
}

void CreateConditional_349e::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_34ef, const CyberComposition::Simulink::Subsystem& chart_34f1, const SFC::DT& dT_34f3, const SFC::LocalVar& triggerVar_34f5, const SFC::UserCode& userCode_34f7, const SFC::ConditionalBlock& conditionalBlock_34f9)
{
	_subsystem_34af->push_back( subsystem_34ef);
	_chart_34b0->push_back( chart_34f1);
	_dT_34b1->push_back( dT_34f3);
	_triggerVar_34b2->push_back( triggerVar_34f5);
	_userCode_34b3->push_back( userCode_34f7);
	_conditionalBlock_34b4->push_back( conditionalBlock_34f9);
}

void SetMatrixCondition_34fb::operator()( const Packets_t& dts_34fc, const Packets_t& triggervars_34fe, const Packets_t& conditions_3500, Packets_t& dts_3502, Packets_t& triggervars_3503, Packets_t& conditions_3504)
{
#ifdef PRINT_INFO
	printLog( "SetMatrixCondition_34fb" );
#endif
	_dt_3505= &dts_3502;
	_triggervar_3506= &triggervars_3503;
	_condition_3507= &conditions_3504;
	_dt_3505->insert( _dt_3505->end(), dts_34fc.begin(), dts_34fc.end());
	_triggervar_3506->insert( _triggervar_3506->end(), triggervars_34fe.begin(), triggervars_34fe.end());
	_condition_3507->insert( _condition_3507->end(), conditions_3500.begin(), conditions_3500.end());
	if( ( !dts_34fc.empty())&& ( !triggervars_34fe.empty())&& ( !conditions_3500.empty()))
		callMatrixCondition_3535( dts_34fc, triggervars_34fe, conditions_3500);
}

void SetMatrixCondition_34fb::callMatrixCondition_3535( const Packets_t& dTs_3509, const Packets_t& triggerVars_350b, const Packets_t& conditions_350d)
{
	MatrixCondition_3508 matrixCondition_3508;
	matrixCondition_3508( dTs_3509, triggerVars_350b, conditions_350d);
}

void MatrixCondition_3508::operator()( const Packets_t& dTs_3509, const Packets_t& triggerVars_350b, const Packets_t& conditions_350d)
{
#ifdef PRINT_INFO
	printLog( "MatrixCondition_3508" );
#endif
	RTTGenerator::Instance()->generateRule(3163, "MatrixCondition");
	processInputPackets( dTs_3509, triggerVars_350b, conditions_350d);
}

bool MatrixCondition_3508::isInputUnique( const Udm::Object& dT_3513, const Udm::Object& triggerVar_351c, const Udm::Object& condition_3525)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itDT_3515= _dT_350f.begin(), itTriggerVar_351e= _triggerVar_3518.begin(), itCondition_3527= _condition_3521.begin(); itDT_3515!= _dT_350f.end(), itTriggerVar_351e!= _triggerVar_3518.end(), itCondition_3527!= _condition_3521.end(); ++itDT_3515, ++itTriggerVar_351e, ++itCondition_3527)
	{
		if( ( *itDT_3515== dT_3513)&& ( *itTriggerVar_351e== triggerVar_351c)&& ( *itCondition_3527== condition_3525))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_dT_350f.push_back( dT_3513);
		_triggerVar_3518.push_back( triggerVar_351c);
		_condition_3521.push_back( condition_3525);
	}
	return isUnique;
}

bool MatrixCondition_3508::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool MatrixCondition_3508::isGuardTrue( SFC::UserCode& Condition, SFC::DT& DT, SFC::LocalVar& TriggerVar)
{
	bool Gz_guard= false;
	Gz_guard = DT.type() != SFC::Struct::meta;;
	return Gz_guard;
}

void MatrixCondition_3508::processInputPackets( const Packets_t& dTs_3509, const Packets_t& triggerVars_350b, const Packets_t& conditions_350d)
{
	for( Packets_t::const_iterator itDT_3510= dTs_3509.begin(), itTriggerVar_3519= triggerVars_350b.begin(), itCondition_3522= conditions_350d.begin(); itDT_3510!= dTs_3509.end(), itTriggerVar_3519!= triggerVars_350b.end(), itCondition_3522!= conditions_350d.end(); ++itDT_3510, ++itTriggerVar_3519, ++itCondition_3522)
	{
		bool isUnique= isInputUnique( *itDT_3510, *itTriggerVar_3519, *itCondition_3522);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itDT_3510, *itTriggerVar_3519, *itCondition_3522);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool MatrixCondition_3508::patternMatcher( const Udm::Object& dT_3511, const Udm::Object& triggerVar_351a, const Udm::Object& condition_3523)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( dT_3511.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_3516= SFC::DT::Cast( dT_3511);
		if( false== Uml::IsDerivedFrom( triggerVar_351a.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_351f= SFC::LocalVar::Cast( triggerVar_351a);
		if( false== Uml::IsDerivedFrom( condition_3523.type(), SFC::UserCode::meta))
			continue;
		SFC::UserCode condition_3528= SFC::UserCode::Cast( condition_3523);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_352d;
		if( !isValidBound(boundObjs_352d, dT_3516, true))
			continue;
		currMatch.dT_352e= dT_3516;
		if( !isValidBound(boundObjs_352d, triggerVar_351f, true))
			continue;
		currMatch.triggerVar_352f= triggerVar_351f;
		if( !isValidBound(boundObjs_352d, condition_3528, true))
			continue;
		currMatch.condition_3530= condition_3528;
		bool Gz_guard= isGuardTrue( currMatch.condition_3530, currMatch.dT_352e, currMatch.triggerVar_352f);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void MatrixCondition_3508::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ArgDeclRef newArgDeclRef_3534= SFC::ArgDeclRef::Create( currMatch.condition_3530, SFC::UserCode::meta_codeexpr);
		newArgDeclRef_3534.argdecl()= currMatch.triggerVar_352f;
	}
}

void SetStructCondition_3539::operator()( const Packets_t& dts_353a, const Packets_t& oldvals_353c, const Packets_t& conditions_353e)
{
#ifdef PRINT_INFO
	printLog( "SetStructCondition_3539" );
#endif
	if( ( !dts_353a.empty())&& ( !oldvals_353c.empty())&& ( !conditions_353e.empty()))
		callStartCondition_3784( dts_353a, oldvals_353c, conditions_353e);
}

void SetStructCondition_3539::callStartCondition_3784( const Packets_t& structs_374f, const Packets_t& triggerVars_3752, const Packets_t& userCodes_3755)
{
	Packets_t structs_3751;
	Packets_t triggerVars_3754;
	Packets_t unaryExprss_3757;
	StartCondition_374e startCondition_374e;
	startCondition_374e( structs_374f, triggerVars_3752, userCodes_3755, structs_3751, triggerVars_3754, unaryExprss_3757);
	if( ( !structs_3751.empty())&& ( !triggerVars_3754.empty())&& ( !unaryExprss_3757.empty()))
		callgetStructMembers_3788( structs_3751, triggerVars_3754, unaryExprss_3757);
}

void SetStructCondition_3539::callgetStructMembers_3788( const Packets_t& structs_3541, const Packets_t& triggerVars_3545, const Packets_t& unaryExprss_3548)
{
	Packets_t structs_3543;
	Packets_t members_3544;
	Packets_t triggerVars_3547;
	Packets_t unaryExprss_354a;
	GetStructMembers_3540 getStructMembers_3540;
	getStructMembers_3540( structs_3541, triggerVars_3545, unaryExprss_3548, structs_3543, members_3544, triggerVars_3547, unaryExprss_354a);
	if( ( !structs_3543.empty())&& ( !members_3544.empty())&& ( !triggerVars_3547.empty())&& ( !unaryExprss_354a.empty()))
		callPlaceMember_378c( structs_3543, members_3544, triggerVars_3547, unaryExprss_354a);
}

void SetStructCondition_3539::callPlaceMember_378c( const Packets_t& structs_357e, const Packets_t& members_3580, const Packets_t& trigvars_3582, const Packets_t& condexprs_3584)
{
	PlaceMember_357d placeMember_357d;
	placeMember_357d( structs_357e, members_3580, trigvars_3582, condexprs_3584);
}

void GetStructMembers_3540::operator()( const Packets_t& structs_3541, const Packets_t& triggerVars_3545, const Packets_t& unaryExprss_3548, Packets_t& structs_3543, Packets_t& members_3544, Packets_t& triggerVars_3547, Packets_t& unaryExprss_354a)
{
#ifdef PRINT_INFO
	printLog( "GetStructMembers_3540" );
#endif
	RTTGenerator::Instance()->generateRule(3174, "getStructMembers");
	_struct_354b= &structs_3543;
	_member_354c= &members_3544;
	_triggerVar_354d= &triggerVars_3547;
	_unaryExprs_354e= &unaryExprss_354a;
	processInputPackets( structs_3541, triggerVars_3545, unaryExprss_3548);
	sortOutputs( );
}

bool GetStructMembers_3540::isInputUnique( const Udm::Object& struct_3553, const Udm::Object& triggerVar_355c, const Udm::Object& unaryExprs_3565)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itStruct_3555= _struct_354f.begin(), itTriggerVar_355e= _triggerVar_3558.begin(), itUnaryExprs_3567= _unaryExprs_3561.begin(); itStruct_3555!= _struct_354f.end(), itTriggerVar_355e!= _triggerVar_3558.end(), itUnaryExprs_3567!= _unaryExprs_3561.end(); ++itStruct_3555, ++itTriggerVar_355e, ++itUnaryExprs_3567)
	{
		if( ( *itStruct_3555== struct_3553)&& ( *itTriggerVar_355e== triggerVar_355c)&& ( *itUnaryExprs_3567== unaryExprs_3565))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_354f.push_back( struct_3553);
		_triggerVar_3558.push_back( triggerVar_355c);
		_unaryExprs_3561.push_back( unaryExprs_3565);
	}
	return isUnique;
}

bool GetStructMembers_3540::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetStructMembers_3540::processInputPackets( const Packets_t& structs_3541, const Packets_t& triggerVars_3545, const Packets_t& unaryExprss_3548)
{
	for( Packets_t::const_iterator itStruct_3550= structs_3541.begin(), itTriggerVar_3559= triggerVars_3545.begin(), itUnaryExprs_3562= unaryExprss_3548.begin(); itStruct_3550!= structs_3541.end(), itTriggerVar_3559!= triggerVars_3545.end(), itUnaryExprs_3562!= unaryExprss_3548.end(); ++itStruct_3550, ++itTriggerVar_3559, ++itUnaryExprs_3562)
	{
		bool isUnique= isInputUnique( *itStruct_3550, *itTriggerVar_3559, *itUnaryExprs_3562);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itStruct_3550, *itTriggerVar_3559, *itUnaryExprs_3562);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetStructMembers_3540::patternMatcher( const Udm::Object& struct_3551, const Udm::Object& triggerVar_355a, const Udm::Object& unaryExprs_3563)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( struct_3551.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_3556= SFC::Struct::Cast( struct_3551);
		if( false== Uml::IsDerivedFrom( triggerVar_355a.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_355f= SFC::LocalVar::Cast( triggerVar_355a);
		if( false== Uml::IsDerivedFrom( unaryExprs_3563.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_3568= SFC::UnaryExprs::Cast( unaryExprs_3563);
		set< SFC::LocalVar> members_356a= struct_3556.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itMember_356b= members_356a.begin(); itMember_356b!= members_356a.end(); ++itMember_356b)
		{
			SFC::LocalVar currMember_356c= *itMember_356b;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_3570;
			if( !isValidBound(boundObjs_3570, struct_3556, true))
				continue;
			currMatch.struct_3571= struct_3556;
			if( !isValidBound(boundObjs_3570, triggerVar_355f, true))
				continue;
			currMatch.triggerVar_3572= triggerVar_355f;
			if( !isValidBound(boundObjs_3570, unaryExprs_3568, true))
				continue;
			currMatch.unaryExprs_3573= unaryExprs_3568;
			if( !isValidBound(boundObjs_3570, currMember_356c, false))
				continue;
			currMatch.member_3574= currMember_356c;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetStructMembers_3540::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.struct_3571, currMatch.member_3574, currMatch.triggerVar_3572, currMatch.unaryExprs_3573);
	}
}

void GetStructMembers_3540::outputAppender( const SFC::Struct& struct_3575, const SFC::LocalVar& member_3577, const SFC::LocalVar& triggerVar_3579, const SFC::UnaryExprs& unaryExprs_357b)
{
	_struct_354b->push_back( struct_3575);
	_member_354c->push_back( member_3577);
	_triggerVar_354d->push_back( triggerVar_3579);
	_unaryExprs_354e->push_back( unaryExprs_357b);
}

void GetStructMembers_3540::sortOutputs()
{
	typedef std::multiset< SFC::LocalVar, std::pointer_to_binary_function< const SFC::LocalVar&, const SFC::LocalVar&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const SFC::LocalVar&, const SFC::LocalVar&, bool> ptr_StatementOrder( StatementOrder< SFC::LocalVar>);
	SortedSet_t sortedSet( ptr_StatementOrder);
	std::vector< int> permutationVector( _member_354c->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _member_354c->begin(); it!= _member_354c->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( SFC::LocalVar::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _member_354c->begin());
	// order rest of the containers
	permutate( permutationVector, *_struct_354b);
	permutate( permutationVector, *_triggerVar_354d);
	permutate( permutationVector, *_unaryExprs_354e);
}

void PlaceMember_357d::operator()( const Packets_t& structs_357e, const Packets_t& members_3580, const Packets_t& trigvars_3582, const Packets_t& condexprs_3584)
{
#ifdef PRINT_INFO
	printLog( "PlaceMember_357d" );
#endif
	for( Packets_t::const_iterator itstruct_3587= structs_357e.begin(), itmember_358e= members_3580.begin(), ittrigvar_3595= trigvars_3582.begin(), itcondexpr_359c= condexprs_3584.begin(); itstruct_3587!= structs_357e.end(), itmember_358e!= members_3580.end(), ittrigvar_3595!= trigvars_3582.end(), itcondexpr_359c!= condexprs_3584.end(); ++itstruct_3587, ++itmember_358e, ++ittrigvar_3595, ++itcondexpr_359c)
	{
		bool isUnique= isInputUnique( *itstruct_3587, *itmember_358e, *ittrigvar_3595, *itcondexpr_359c);
		if( !isUnique)
			continue;
		Packets_t onestruct_358b( 1, *itstruct_3587);
		Packets_t onemember_3592( 1, *itmember_358e);
		Packets_t onetrigvar_3599( 1, *ittrigvar_3595);
		Packets_t onecondexpr_35a0( 1, *itcondexpr_359c);
		executeOne( onestruct_358b, onemember_3592, onetrigvar_3599, onecondexpr_35a0);
	}
}

void PlaceMember_357d::executeOne( const Packets_t& structs_357e, const Packets_t& members_3580, const Packets_t& trigvars_3582, const Packets_t& condexprs_3584)
{
	if( ( !structs_357e.empty())&& ( !members_3580.empty())&& ( !trigvars_3582.empty())&& ( !condexprs_3584.empty()))
		callTriggerTest_373f( structs_357e, members_3580, trigvars_3582, condexprs_3584);
}

bool PlaceMember_357d::isInputUnique( const Udm::Object& struct_3588, const Udm::Object& member_358f, const Udm::Object& trigvar_3596, const Udm::Object& condexpr_359d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstruct_358a= _struct_3586.begin(), itmember_3591= _member_358d.begin(), ittrigvar_3598= _trigvar_3594.begin(), itcondexpr_359f= _condexpr_359b.begin(); itstruct_358a!= _struct_3586.end(), itmember_3591!= _member_358d.end(), ittrigvar_3598!= _trigvar_3594.end(), itcondexpr_359f!= _condexpr_359b.end(); ++itstruct_358a, ++itmember_3591, ++ittrigvar_3598, ++itcondexpr_359f)
	{
		if( ( *itstruct_358a== struct_3588)&& ( *itmember_3591== member_358f)&& ( *ittrigvar_3598== trigvar_3596)&& ( *itcondexpr_359f== condexpr_359d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_3586.push_back( struct_3588);
		_member_358d.push_back( member_358f);
		_trigvar_3594.push_back( trigvar_3596);
		_condexpr_359b.push_back( condexpr_359d);
	}
	return isUnique;
}

void PlaceMember_357d::callTriggerTest_373f( const Packets_t& structs_35f0, const Packets_t& members_35f2, const Packets_t& trigvars_35f4, const Packets_t& condexprs_35f6)
{
	Packets_t structs_35f8;
	Packets_t members_35f9;
	Packets_t trigvars_35fa;
	Packets_t condexprs_35fb;
	Packets_t structs_35fc;
	Packets_t members_35fd;
	Packets_t trigvars_35fe;
	Packets_t condexprs_35ff;
	TriggerTest_35ef triggerTest_35ef;
	triggerTest_35ef( structs_35f0, members_35f2, trigvars_35f4, condexprs_35f6, structs_35f8, members_35f9, trigvars_35fa, condexprs_35fb, structs_35fc, members_35fd, trigvars_35fe, condexprs_35ff);
	if( ( !structs_35f8.empty())&& ( !members_35f9.empty())&& ( !trigvars_35fa.empty())&& ( !condexprs_35fb.empty()))
		callTraverseBinary_3744( structs_35f8, members_35f9, trigvars_35fa, condexprs_35fb);
	if( ( !structs_35fc.empty())&& ( !members_35fd.empty())&& ( !trigvars_35fe.empty())&& ( !condexprs_35ff.empty()))
		callAddTrigger_3749( structs_35fc, members_35fd, trigvars_35fe, condexprs_35ff);
}

void PlaceMember_357d::callTraverseBinary_3744( const Packets_t& structs_35a3, const Packets_t& members_35a6, const Packets_t& triggerVars_35a9, const Packets_t& unaryExprss_35ac)
{
	Packets_t structs_35a5;
	Packets_t members_35a8;
	Packets_t triggerVars_35ab;
	Packets_t unaryExprss_35ae;
	TraverseBinary_35a2 traverseBinary_35a2;
	traverseBinary_35a2( structs_35a3, members_35a6, triggerVars_35a9, unaryExprss_35ac, structs_35a5, members_35a8, triggerVars_35ab, unaryExprss_35ae);
	if( ( !structs_35a5.empty())&& ( !members_35a8.empty())&& ( !triggerVars_35ab.empty())&& ( !unaryExprss_35ae.empty()))
		callTriggerTest_373f( structs_35a5, members_35a8, triggerVars_35ab, unaryExprss_35ae);
}

void PlaceMember_357d::callAddTrigger_3749( const Packets_t& structs_36b3, const Packets_t& members_36b5, const Packets_t& trigvars_36b7, const Packets_t& condexprs_36b9)
{
	AddTrigger_36b2 addTrigger_36b2;
	addTrigger_36b2( structs_36b3, members_36b5, trigvars_36b7, condexprs_36b9);
}

void TraverseBinary_35a2::operator()( const Packets_t& structs_35a3, const Packets_t& members_35a6, const Packets_t& triggerVars_35a9, const Packets_t& unaryExprss_35ac, Packets_t& structs_35a5, Packets_t& members_35a8, Packets_t& triggerVars_35ab, Packets_t& unaryExprss_35ae)
{
#ifdef PRINT_INFO
	printLog( "TraverseBinary_35a2" );
#endif
	RTTGenerator::Instance()->generateRule(3185, "TraverseBinary");
	_struct_35af= &structs_35a5;
	_member_35b0= &members_35a8;
	_triggerVar_35b1= &triggerVars_35ab;
	_unaryExprs_35b2= &unaryExprss_35ae;
	processInputPackets( structs_35a3, members_35a6, triggerVars_35a9, unaryExprss_35ac);
}

bool TraverseBinary_35a2::isInputUnique( const Udm::Object& struct_35b7, const Udm::Object& member_35c0, const Udm::Object& triggerVar_35c9, const Udm::Object& unaryExprs_35d2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itStruct_35b9= _struct_35b3.begin(), itMember_35c2= _member_35bc.begin(), itTriggerVar_35cb= _triggerVar_35c5.begin(), itUnaryExprs_35d4= _unaryExprs_35ce.begin(); itStruct_35b9!= _struct_35b3.end(), itMember_35c2!= _member_35bc.end(), itTriggerVar_35cb!= _triggerVar_35c5.end(), itUnaryExprs_35d4!= _unaryExprs_35ce.end(); ++itStruct_35b9, ++itMember_35c2, ++itTriggerVar_35cb, ++itUnaryExprs_35d4)
	{
		if( ( *itStruct_35b9== struct_35b7)&& ( *itMember_35c2== member_35c0)&& ( *itTriggerVar_35cb== triggerVar_35c9)&& ( *itUnaryExprs_35d4== unaryExprs_35d2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_35b3.push_back( struct_35b7);
		_member_35bc.push_back( member_35c0);
		_triggerVar_35c5.push_back( triggerVar_35c9);
		_unaryExprs_35ce.push_back( unaryExprs_35d2);
	}
	return isUnique;
}

bool TraverseBinary_35a2::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void TraverseBinary_35a2::processInputPackets( const Packets_t& structs_35a3, const Packets_t& members_35a6, const Packets_t& triggerVars_35a9, const Packets_t& unaryExprss_35ac)
{
	for( Packets_t::const_iterator itStruct_35b4= structs_35a3.begin(), itMember_35bd= members_35a6.begin(), itTriggerVar_35c6= triggerVars_35a9.begin(), itUnaryExprs_35cf= unaryExprss_35ac.begin(); itStruct_35b4!= structs_35a3.end(), itMember_35bd!= members_35a6.end(), itTriggerVar_35c6!= triggerVars_35a9.end(), itUnaryExprs_35cf!= unaryExprss_35ac.end(); ++itStruct_35b4, ++itMember_35bd, ++itTriggerVar_35c6, ++itUnaryExprs_35cf)
	{
		bool isUnique= isInputUnique( *itStruct_35b4, *itMember_35bd, *itTriggerVar_35c6, *itUnaryExprs_35cf);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itStruct_35b4, *itMember_35bd, *itTriggerVar_35c6, *itUnaryExprs_35cf);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool TraverseBinary_35a2::patternMatcher( const Udm::Object& struct_35b5, const Udm::Object& member_35be, const Udm::Object& triggerVar_35c7, const Udm::Object& unaryExprs_35d0)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( struct_35b5.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_35ba= SFC::Struct::Cast( struct_35b5);
		if( false== Uml::IsDerivedFrom( member_35be.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_35c3= SFC::LocalVar::Cast( member_35be);
		if( false== Uml::IsDerivedFrom( triggerVar_35c7.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_35cc= SFC::LocalVar::Cast( triggerVar_35c7);
		if( false== Uml::IsDerivedFrom( unaryExprs_35d0.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_35d5= SFC::UnaryExprs::Cast( unaryExprs_35d0);
		set< SFC::BinaryExprs> binaryExprss_35d7= unaryExprs_35d5.BinaryExprs_kind_children();
		for( set< SFC::BinaryExprs>::const_iterator itBinaryExprs_35d8= binaryExprss_35d7.begin(); itBinaryExprs_35d8!= binaryExprss_35d7.end(); ++itBinaryExprs_35d8)
		{
			SFC::BinaryExprs currBinaryExprs_35d9= *itBinaryExprs_35d8;
			set< SFC::UnaryExprs> unaryExprss_35da= currBinaryExprs_35d9.UnaryExprs_kind_children();
			for( set< SFC::UnaryExprs>::const_iterator itUnaryExprs_35db= unaryExprss_35da.begin(); itUnaryExprs_35db!= unaryExprss_35da.end(); ++itUnaryExprs_35db)
			{
				SFC::UnaryExprs currUnaryExprs_35dc= *itUnaryExprs_35db;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_35e0;
				if( !isValidBound(boundObjs_35e0, struct_35ba, true))
					continue;
				currMatch.struct_35e1= struct_35ba;
				if( !isValidBound(boundObjs_35e0, member_35c3, true))
					continue;
				currMatch.member_35e2= member_35c3;
				if( !isValidBound(boundObjs_35e0, triggerVar_35cc, true))
					continue;
				currMatch.triggerVar_35e3= triggerVar_35cc;
				if( !isValidBound(boundObjs_35e0, unaryExprs_35d5, true))
					continue;
				currMatch.unaryExprs_35e4= unaryExprs_35d5;
				if( !isValidBound(boundObjs_35e0, currBinaryExprs_35d9, false))
					continue;
				currMatch.binaryExprs_35e5= currBinaryExprs_35d9;
				if( !isValidBound(boundObjs_35e0, currUnaryExprs_35dc, false))
					continue;
				currMatch.unaryExprs_35e6= currUnaryExprs_35dc;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void TraverseBinary_35a2::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.struct_35e1, currMatch.member_35e2, currMatch.triggerVar_35e3, currMatch.unaryExprs_35e6);
	}
}

void TraverseBinary_35a2::outputAppender( const SFC::Struct& struct_35e7, const SFC::LocalVar& member_35e9, const SFC::LocalVar& triggerVar_35eb, const SFC::UnaryExprs& unaryExprs_35ed)
{
	_struct_35af->push_back( struct_35e7);
	_member_35b0->push_back( member_35e9);
	_triggerVar_35b1->push_back( triggerVar_35eb);
	_unaryExprs_35b2->push_back( unaryExprs_35ed);
}

void TriggerTest_35ef::operator()( const Packets_t& structs_35f0, const Packets_t& members_35f2, const Packets_t& trigvars_35f4, const Packets_t& condexprs_35f6, Packets_t& structs_35f8, Packets_t& members_35f9, Packets_t& trigvars_35fa, Packets_t& condexprs_35fb, Packets_t& structs_35fc, Packets_t& members_35fd, Packets_t& trigvars_35fe, Packets_t& condexprs_35ff)
{
#ifdef PRINT_INFO
	printLog( "TriggerTest_35ef" );
#endif
	_struct_3600= &structs_35f8;
	_member_3601= &members_35f9;
	_trigvar_3602= &trigvars_35fa;
	_condexpr_3603= &condexprs_35fb;
	_struct_3604= &structs_35fc;
	_member_3605= &members_35fd;
	_trigvar_3606= &trigvars_35fe;
	_condexpr_3607= &condexprs_35ff;
	for( Packets_t::const_iterator itstruct_3609= structs_35f0.begin(), itmember_3610= members_35f2.begin(), ittrigvar_3617= trigvars_35f4.begin(), itcondexpr_361e= condexprs_35f6.begin(); itstruct_3609!= structs_35f0.end(), itmember_3610!= members_35f2.end(), ittrigvar_3617!= trigvars_35f4.end(), itcondexpr_361e!= condexprs_35f6.end(); ++itstruct_3609, ++itmember_3610, ++ittrigvar_3617, ++itcondexpr_361e)
	{
		bool isUnique= isInputUnique( *itstruct_3609, *itmember_3610, *ittrigvar_3617, *itcondexpr_361e);
		if( !isUnique)
			continue;
		Packets_t onestruct_360d( 1, *itstruct_3609);
		Packets_t onemember_3614( 1, *itmember_3610);
		Packets_t onetrigvar_361b( 1, *ittrigvar_3617);
		Packets_t onecondexpr_3622( 1, *itcondexpr_361e);
		executeOne( onestruct_360d, onemember_3614, onetrigvar_361b, onecondexpr_3622);
	}
}

void TriggerTest_35ef::executeOne( const Packets_t& structs_35f0, const Packets_t& members_35f2, const Packets_t& trigvars_35f4, const Packets_t& condexprs_35f6)
{
	Packets_t structs_3627;
	Packets_t members_362a;
	Packets_t triggerVars_362d;
	Packets_t unaryExprss_3630;
	HasBinaryExprs_3624 hasBinaryExprs_3624;
	bool isMatchHasBinaryExprs_3624= hasBinaryExprs_3624( structs_35f0, members_35f2, trigvars_35f4, condexprs_35f6, structs_3627, members_362a, triggerVars_362d, unaryExprss_3630);
	_struct_3600->insert( _struct_3600->end(), structs_3627.begin(), structs_3627.end());
	_member_3601->insert( _member_3601->end(), members_362a.begin(), members_362a.end());
	_trigvar_3602->insert( _trigvar_3602->end(), triggerVars_362d.begin(), triggerVars_362d.end());
	_condexpr_3603->insert( _condexpr_3603->end(), unaryExprss_3630.begin(), unaryExprss_3630.end());
	if( isMatchHasBinaryExprs_3624)
		return;
	Packets_t structs_3670;
	Packets_t members_3673;
	Packets_t triggerVars_3676;
	Packets_t unaryExprss_3679;
	Otherwise_366d otherwise_366d;
	bool isMatchOtherwise_366d= otherwise_366d( structs_35f0, members_35f2, trigvars_35f4, condexprs_35f6, structs_3670, members_3673, triggerVars_3676, unaryExprss_3679);
	_struct_3604->insert( _struct_3604->end(), structs_3670.begin(), structs_3670.end());
	_member_3605->insert( _member_3605->end(), members_3673.begin(), members_3673.end());
	_trigvar_3606->insert( _trigvar_3606->end(), triggerVars_3676.begin(), triggerVars_3676.end());
	_condexpr_3607->insert( _condexpr_3607->end(), unaryExprss_3679.begin(), unaryExprss_3679.end());
	if( isMatchOtherwise_366d)
		return;
}

bool TriggerTest_35ef::isInputUnique( const Udm::Object& struct_360a, const Udm::Object& member_3611, const Udm::Object& trigvar_3618, const Udm::Object& condexpr_361f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstruct_360c= _struct_3608.begin(), itmember_3613= _member_360f.begin(), ittrigvar_361a= _trigvar_3616.begin(), itcondexpr_3621= _condexpr_361d.begin(); itstruct_360c!= _struct_3608.end(), itmember_3613!= _member_360f.end(), ittrigvar_361a!= _trigvar_3616.end(), itcondexpr_3621!= _condexpr_361d.end(); ++itstruct_360c, ++itmember_3613, ++ittrigvar_361a, ++itcondexpr_3621)
	{
		if( ( *itstruct_360c== struct_360a)&& ( *itmember_3613== member_3611)&& ( *ittrigvar_361a== trigvar_3618)&& ( *itcondexpr_3621== condexpr_361f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_3608.push_back( struct_360a);
		_member_360f.push_back( member_3611);
		_trigvar_3616.push_back( trigvar_3618);
		_condexpr_361d.push_back( condexpr_361f);
	}
	return isUnique;
}

bool HasBinaryExprs_3624::operator()( const Packets_t& structs_3625, const Packets_t& members_3628, const Packets_t& triggerVars_362b, const Packets_t& unaryExprss_362e, Packets_t& structs_3627, Packets_t& members_362a, Packets_t& triggerVars_362d, Packets_t& unaryExprss_3630)
{
#ifdef PRINT_INFO
	printLog( "HasBinaryExprs_3624" );
#endif
	_struct_3631= &structs_3627;
	_member_3632= &members_362a;
	_triggerVar_3633= &triggerVars_362d;
	_unaryExprs_3634= &unaryExprss_3630;
	processInputPackets( structs_3625, members_3628, triggerVars_362b, unaryExprss_362e);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasBinaryExprs_3624::isInputUnique( const Udm::Object& struct_3639, const Udm::Object& member_3642, const Udm::Object& triggerVar_364b, const Udm::Object& unaryExprs_3654)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itStruct_363b= _struct_3635.begin(), itMember_3644= _member_363e.begin(), itTriggerVar_364d= _triggerVar_3647.begin(), itUnaryExprs_3656= _unaryExprs_3650.begin(); itStruct_363b!= _struct_3635.end(), itMember_3644!= _member_363e.end(), itTriggerVar_364d!= _triggerVar_3647.end(), itUnaryExprs_3656!= _unaryExprs_3650.end(); ++itStruct_363b, ++itMember_3644, ++itTriggerVar_364d, ++itUnaryExprs_3656)
	{
		if( ( *itStruct_363b== struct_3639)&& ( *itMember_3644== member_3642)&& ( *itTriggerVar_364d== triggerVar_364b)&& ( *itUnaryExprs_3656== unaryExprs_3654))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_3635.push_back( struct_3639);
		_member_363e.push_back( member_3642);
		_triggerVar_3647.push_back( triggerVar_364b);
		_unaryExprs_3650.push_back( unaryExprs_3654);
	}
	return isUnique;
}

bool HasBinaryExprs_3624::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void HasBinaryExprs_3624::processInputPackets( const Packets_t& structs_3625, const Packets_t& members_3628, const Packets_t& triggerVars_362b, const Packets_t& unaryExprss_362e)
{
	for( Packets_t::const_iterator itStruct_3636= structs_3625.begin(), itMember_363f= members_3628.begin(), itTriggerVar_3648= triggerVars_362b.begin(), itUnaryExprs_3651= unaryExprss_362e.begin(); itStruct_3636!= structs_3625.end(), itMember_363f!= members_3628.end(), itTriggerVar_3648!= triggerVars_362b.end(), itUnaryExprs_3651!= unaryExprss_362e.end(); ++itStruct_3636, ++itMember_363f, ++itTriggerVar_3648, ++itUnaryExprs_3651)
	{
		bool isUnique= isInputUnique( *itStruct_3636, *itMember_363f, *itTriggerVar_3648, *itUnaryExprs_3651);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itStruct_3636, *itMember_363f, *itTriggerVar_3648, *itUnaryExprs_3651);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.struct_3660, currMatch.member_3661, currMatch.triggerVar_3662, currMatch.unaryExprs_3663);
	}
}

bool HasBinaryExprs_3624::patternMatcher( const Udm::Object& struct_3637, const Udm::Object& member_3640, const Udm::Object& triggerVar_3649, const Udm::Object& unaryExprs_3652)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( struct_3637.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_363c= SFC::Struct::Cast( struct_3637);
		if( false== Uml::IsDerivedFrom( member_3640.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_3645= SFC::LocalVar::Cast( member_3640);
		if( false== Uml::IsDerivedFrom( triggerVar_3649.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_364e= SFC::LocalVar::Cast( triggerVar_3649);
		if( false== Uml::IsDerivedFrom( unaryExprs_3652.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_3657= SFC::UnaryExprs::Cast( unaryExprs_3652);
		set< SFC::BinaryExprs> binaryExprss_3659= unaryExprs_3657.BinaryExprs_kind_children();
		for( set< SFC::BinaryExprs>::const_iterator itBinaryExprs_365a= binaryExprss_3659.begin(); itBinaryExprs_365a!= binaryExprss_3659.end(); ++itBinaryExprs_365a)
		{
			SFC::BinaryExprs currBinaryExprs_365b= *itBinaryExprs_365a;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_365f;
			if( !isValidBound(boundObjs_365f, struct_363c, true))
				continue;
			currMatch.struct_3660= struct_363c;
			if( !isValidBound(boundObjs_365f, member_3645, true))
				continue;
			currMatch.member_3661= member_3645;
			if( !isValidBound(boundObjs_365f, triggerVar_364e, true))
				continue;
			currMatch.triggerVar_3662= triggerVar_364e;
			if( !isValidBound(boundObjs_365f, unaryExprs_3657, true))
				continue;
			currMatch.unaryExprs_3663= unaryExprs_3657;
			if( !isValidBound(boundObjs_365f, currBinaryExprs_365b, false))
				continue;
			currMatch.binaryExprs_3664= currBinaryExprs_365b;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void HasBinaryExprs_3624::outputAppender( const SFC::Struct& struct_3665, const SFC::LocalVar& member_3667, const SFC::LocalVar& triggerVar_3669, const SFC::UnaryExprs& unaryExprs_366b)
{
	_struct_3631->push_back( struct_3665);
	_member_3632->push_back( member_3667);
	_triggerVar_3633->push_back( triggerVar_3669);
	_unaryExprs_3634->push_back( unaryExprs_366b);
}

bool Otherwise_366d::operator()( const Packets_t& structs_366e, const Packets_t& members_3671, const Packets_t& triggerVars_3674, const Packets_t& unaryExprss_3677, Packets_t& structs_3670, Packets_t& members_3673, Packets_t& triggerVars_3676, Packets_t& unaryExprss_3679)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_366d" );
#endif
	_struct_367a= &structs_3670;
	_member_367b= &members_3673;
	_triggerVar_367c= &triggerVars_3676;
	_unaryExprs_367d= &unaryExprss_3679;
	processInputPackets( structs_366e, members_3671, triggerVars_3674, unaryExprss_3677);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_366d::isInputUnique( const Udm::Object& struct_3682, const Udm::Object& member_368b, const Udm::Object& triggerVar_3694, const Udm::Object& unaryExprs_369d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itStruct_3684= _struct_367e.begin(), itMember_368d= _member_3687.begin(), itTriggerVar_3696= _triggerVar_3690.begin(), itUnaryExprs_369f= _unaryExprs_3699.begin(); itStruct_3684!= _struct_367e.end(), itMember_368d!= _member_3687.end(), itTriggerVar_3696!= _triggerVar_3690.end(), itUnaryExprs_369f!= _unaryExprs_3699.end(); ++itStruct_3684, ++itMember_368d, ++itTriggerVar_3696, ++itUnaryExprs_369f)
	{
		if( ( *itStruct_3684== struct_3682)&& ( *itMember_368d== member_368b)&& ( *itTriggerVar_3696== triggerVar_3694)&& ( *itUnaryExprs_369f== unaryExprs_369d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_367e.push_back( struct_3682);
		_member_3687.push_back( member_368b);
		_triggerVar_3690.push_back( triggerVar_3694);
		_unaryExprs_3699.push_back( unaryExprs_369d);
	}
	return isUnique;
}

bool Otherwise_366d::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_366d::processInputPackets( const Packets_t& structs_366e, const Packets_t& members_3671, const Packets_t& triggerVars_3674, const Packets_t& unaryExprss_3677)
{
	for( Packets_t::const_iterator itStruct_367f= structs_366e.begin(), itMember_3688= members_3671.begin(), itTriggerVar_3691= triggerVars_3674.begin(), itUnaryExprs_369a= unaryExprss_3677.begin(); itStruct_367f!= structs_366e.end(), itMember_3688!= members_3671.end(), itTriggerVar_3691!= triggerVars_3674.end(), itUnaryExprs_369a!= unaryExprss_3677.end(); ++itStruct_367f, ++itMember_3688, ++itTriggerVar_3691, ++itUnaryExprs_369a)
	{
		bool isUnique= isInputUnique( *itStruct_367f, *itMember_3688, *itTriggerVar_3691, *itUnaryExprs_369a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itStruct_367f, *itMember_3688, *itTriggerVar_3691, *itUnaryExprs_369a);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.struct_36a6, currMatch.member_36a7, currMatch.triggerVar_36a8, currMatch.unaryExprs_36a9);
	}
}

bool Otherwise_366d::patternMatcher( const Udm::Object& struct_3680, const Udm::Object& member_3689, const Udm::Object& triggerVar_3692, const Udm::Object& unaryExprs_369b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( struct_3680.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_3685= SFC::Struct::Cast( struct_3680);
		if( false== Uml::IsDerivedFrom( member_3689.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_368e= SFC::LocalVar::Cast( member_3689);
		if( false== Uml::IsDerivedFrom( triggerVar_3692.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_3697= SFC::LocalVar::Cast( triggerVar_3692);
		if( false== Uml::IsDerivedFrom( unaryExprs_369b.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_36a0= SFC::UnaryExprs::Cast( unaryExprs_369b);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_36a5;
		if( !isValidBound(boundObjs_36a5, struct_3685, true))
			continue;
		currMatch.struct_36a6= struct_3685;
		if( !isValidBound(boundObjs_36a5, member_368e, true))
			continue;
		currMatch.member_36a7= member_368e;
		if( !isValidBound(boundObjs_36a5, triggerVar_3697, true))
			continue;
		currMatch.triggerVar_36a8= triggerVar_3697;
		if( !isValidBound(boundObjs_36a5, unaryExprs_36a0, true))
			continue;
		currMatch.unaryExprs_36a9= unaryExprs_36a0;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_366d::outputAppender( const SFC::Struct& struct_36aa, const SFC::LocalVar& member_36ac, const SFC::LocalVar& triggerVar_36ae, const SFC::UnaryExprs& unaryExprs_36b0)
{
	_struct_367a->push_back( struct_36aa);
	_member_367b->push_back( member_36ac);
	_triggerVar_367c->push_back( triggerVar_36ae);
	_unaryExprs_367d->push_back( unaryExprs_36b0);
}

void AddTrigger_36b2::operator()( const Packets_t& structs_36b3, const Packets_t& members_36b5, const Packets_t& trigvars_36b7, const Packets_t& condexprs_36b9)
{
#ifdef PRINT_INFO
	printLog( "AddTrigger_36b2" );
#endif
	if( ( !structs_36b3.empty())&& ( !members_36b5.empty())&& ( !trigvars_36b7.empty())&& ( !condexprs_36b9.empty()))
		callAddNextTrigger_3735( structs_36b3, members_36b5, trigvars_36b7, condexprs_36b9);
	if( ( !structs_36b3.empty())&& ( !members_36b5.empty())&& ( !trigvars_36b7.empty())&& ( !condexprs_36b9.empty()))
		callAddLastTrigger_373a( structs_36b3, members_36b5, trigvars_36b7, condexprs_36b9);
}

void AddTrigger_36b2::callAddNextTrigger_3735( const Packets_t& structs_36bc, const Packets_t& members_36be, const Packets_t& triggerVars_36c0, const Packets_t& unaryExprss_36c2)
{
	AddNextTrigger_36bb addNextTrigger_36bb;
	addNextTrigger_36bb( structs_36bc, members_36be, triggerVars_36c0, unaryExprss_36c2);
}

void AddTrigger_36b2::callAddLastTrigger_373a( const Packets_t& structs_36fa, const Packets_t& members_36fc, const Packets_t& triggerVars_36fe, const Packets_t& unaryExprss_3700)
{
	AddLastTrigger_36f9 addLastTrigger_36f9;
	addLastTrigger_36f9( structs_36fa, members_36fc, triggerVars_36fe, unaryExprss_3700);
}

void AddNextTrigger_36bb::operator()( const Packets_t& structs_36bc, const Packets_t& members_36be, const Packets_t& triggerVars_36c0, const Packets_t& unaryExprss_36c2)
{
#ifdef PRINT_INFO
	printLog( "AddNextTrigger_36bb" );
#endif
	RTTGenerator::Instance()->generateRule(3224, "AddNextTrigger");
	processInputPackets( structs_36bc, members_36be, triggerVars_36c0, unaryExprss_36c2);
}

bool AddNextTrigger_36bb::isInputUnique( const Udm::Object& struct_36c8, const Udm::Object& member_36d1, const Udm::Object& triggerVar_36da, const Udm::Object& unaryExprs_36e3)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itStruct_36ca= _struct_36c4.begin(), itMember_36d3= _member_36cd.begin(), itTriggerVar_36dc= _triggerVar_36d6.begin(), itUnaryExprs_36e5= _unaryExprs_36df.begin(); itStruct_36ca!= _struct_36c4.end(), itMember_36d3!= _member_36cd.end(), itTriggerVar_36dc!= _triggerVar_36d6.end(), itUnaryExprs_36e5!= _unaryExprs_36df.end(); ++itStruct_36ca, ++itMember_36d3, ++itTriggerVar_36dc, ++itUnaryExprs_36e5)
	{
		if( ( *itStruct_36ca== struct_36c8)&& ( *itMember_36d3== member_36d1)&& ( *itTriggerVar_36dc== triggerVar_36da)&& ( *itUnaryExprs_36e5== unaryExprs_36e3))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_36c4.push_back( struct_36c8);
		_member_36cd.push_back( member_36d1);
		_triggerVar_36d6.push_back( triggerVar_36da);
		_unaryExprs_36df.push_back( unaryExprs_36e3);
	}
	return isUnique;
}

bool AddNextTrigger_36bb::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool AddNextTrigger_36bb::isGuardTrue( SFC::LocalVar& Member, SFC::Struct& Struct, SFC::LocalVar& TriggerVar, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	Gz_guard = Member.statementIndex() + 1 != Struct.memberCount();;
	return Gz_guard;
}

void AddNextTrigger_36bb::processInputPackets( const Packets_t& structs_36bc, const Packets_t& members_36be, const Packets_t& triggerVars_36c0, const Packets_t& unaryExprss_36c2)
{
	for( Packets_t::const_iterator itStruct_36c5= structs_36bc.begin(), itMember_36ce= members_36be.begin(), itTriggerVar_36d7= triggerVars_36c0.begin(), itUnaryExprs_36e0= unaryExprss_36c2.begin(); itStruct_36c5!= structs_36bc.end(), itMember_36ce!= members_36be.end(), itTriggerVar_36d7!= triggerVars_36c0.end(), itUnaryExprs_36e0!= unaryExprss_36c2.end(); ++itStruct_36c5, ++itMember_36ce, ++itTriggerVar_36d7, ++itUnaryExprs_36e0)
	{
		bool isUnique= isInputUnique( *itStruct_36c5, *itMember_36ce, *itTriggerVar_36d7, *itUnaryExprs_36e0);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itStruct_36c5, *itMember_36ce, *itTriggerVar_36d7, *itUnaryExprs_36e0);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AddNextTrigger_36bb::patternMatcher( const Udm::Object& struct_36c6, const Udm::Object& member_36cf, const Udm::Object& triggerVar_36d8, const Udm::Object& unaryExprs_36e1)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( struct_36c6.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_36cb= SFC::Struct::Cast( struct_36c6);
		if( false== Uml::IsDerivedFrom( member_36cf.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_36d4= SFC::LocalVar::Cast( member_36cf);
		if( false== Uml::IsDerivedFrom( triggerVar_36d8.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_36dd= SFC::LocalVar::Cast( triggerVar_36d8);
		if( false== Uml::IsDerivedFrom( unaryExprs_36e1.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_36e6= SFC::UnaryExprs::Cast( unaryExprs_36e1);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_36eb;
		if( !isValidBound(boundObjs_36eb, struct_36cb, true))
			continue;
		currMatch.struct_36ec= struct_36cb;
		if( !isValidBound(boundObjs_36eb, member_36d4, true))
			continue;
		currMatch.member_36ed= member_36d4;
		if( !isValidBound(boundObjs_36eb, triggerVar_36dd, true))
			continue;
		currMatch.triggerVar_36ee= triggerVar_36dd;
		if( !isValidBound(boundObjs_36eb, unaryExprs_36e6, true))
			continue;
		currMatch.unaryExprs_36ef= unaryExprs_36e6;
		bool Gz_guard= isGuardTrue( currMatch.member_36ed, currMatch.struct_36ec, currMatch.triggerVar_36ee, currMatch.unaryExprs_36ef);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void AddNextTrigger_36bb::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newOr_36f4= SFC::BinaryExprs::Create( currMatch.unaryExprs_36ef, SFC::UnaryExprs::meta_subexpr);
		SFC::UnaryExprs newDummy_36f5= SFC::UnaryExprs::Create( newOr_36f4, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newDot_36f6= SFC::BinaryExprs::Create( newOr_36f4, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef1_36f7= SFC::ArgDeclRef::Create( newDot_36f6, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef2_36f8= SFC::ArgDeclRef::Create( newDot_36f6, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef& ArgDeclRef1= newArgDeclRef1_36f7;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_36f8;
		SFC::BinaryExprs& Dot= newDot_36f6;
		SFC::UnaryExprs& Dummy= newDummy_36f5;
		SFC::LocalVar& Member= currMatch.member_36ed;
		SFC::BinaryExprs& Or= newOr_36f4;
		SFC::Struct& Struct= currMatch.struct_36ec;
		SFC::LocalVar& TriggerVar= currMatch.triggerVar_36ee;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_36ef;
		{
Dummy.op() = "";
};
		{
Dot.op() = ".";
};
		{
Or.op() = "||";
};
		newArgDeclRef2_36f8.argdecl()= currMatch.triggerVar_36ee;
		newArgDeclRef1_36f7.argdecl()= currMatch.member_36ed;
	}
}

void AddLastTrigger_36f9::operator()( const Packets_t& structs_36fa, const Packets_t& members_36fc, const Packets_t& triggerVars_36fe, const Packets_t& unaryExprss_3700)
{
#ifdef PRINT_INFO
	printLog( "AddLastTrigger_36f9" );
#endif
	RTTGenerator::Instance()->generateRule(3244, "AddLastTrigger");
	processInputPackets( structs_36fa, members_36fc, triggerVars_36fe, unaryExprss_3700);
}

bool AddLastTrigger_36f9::isInputUnique( const Udm::Object& struct_3706, const Udm::Object& member_370f, const Udm::Object& triggerVar_3718, const Udm::Object& unaryExprs_3721)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itStruct_3708= _struct_3702.begin(), itMember_3711= _member_370b.begin(), itTriggerVar_371a= _triggerVar_3714.begin(), itUnaryExprs_3723= _unaryExprs_371d.begin(); itStruct_3708!= _struct_3702.end(), itMember_3711!= _member_370b.end(), itTriggerVar_371a!= _triggerVar_3714.end(), itUnaryExprs_3723!= _unaryExprs_371d.end(); ++itStruct_3708, ++itMember_3711, ++itTriggerVar_371a, ++itUnaryExprs_3723)
	{
		if( ( *itStruct_3708== struct_3706)&& ( *itMember_3711== member_370f)&& ( *itTriggerVar_371a== triggerVar_3718)&& ( *itUnaryExprs_3723== unaryExprs_3721))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_3702.push_back( struct_3706);
		_member_370b.push_back( member_370f);
		_triggerVar_3714.push_back( triggerVar_3718);
		_unaryExprs_371d.push_back( unaryExprs_3721);
	}
	return isUnique;
}

bool AddLastTrigger_36f9::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool AddLastTrigger_36f9::isGuardTrue( SFC::LocalVar& Member, SFC::Struct& Struct, SFC::LocalVar& TriggerVar, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	Gz_guard = Member.statementIndex() + 1 == Struct.memberCount();;
	return Gz_guard;
}

void AddLastTrigger_36f9::processInputPackets( const Packets_t& structs_36fa, const Packets_t& members_36fc, const Packets_t& triggerVars_36fe, const Packets_t& unaryExprss_3700)
{
	for( Packets_t::const_iterator itStruct_3703= structs_36fa.begin(), itMember_370c= members_36fc.begin(), itTriggerVar_3715= triggerVars_36fe.begin(), itUnaryExprs_371e= unaryExprss_3700.begin(); itStruct_3703!= structs_36fa.end(), itMember_370c!= members_36fc.end(), itTriggerVar_3715!= triggerVars_36fe.end(), itUnaryExprs_371e!= unaryExprss_3700.end(); ++itStruct_3703, ++itMember_370c, ++itTriggerVar_3715, ++itUnaryExprs_371e)
	{
		bool isUnique= isInputUnique( *itStruct_3703, *itMember_370c, *itTriggerVar_3715, *itUnaryExprs_371e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itStruct_3703, *itMember_370c, *itTriggerVar_3715, *itUnaryExprs_371e);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AddLastTrigger_36f9::patternMatcher( const Udm::Object& struct_3704, const Udm::Object& member_370d, const Udm::Object& triggerVar_3716, const Udm::Object& unaryExprs_371f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( struct_3704.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_3709= SFC::Struct::Cast( struct_3704);
		if( false== Uml::IsDerivedFrom( member_370d.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_3712= SFC::LocalVar::Cast( member_370d);
		if( false== Uml::IsDerivedFrom( triggerVar_3716.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_371b= SFC::LocalVar::Cast( triggerVar_3716);
		if( false== Uml::IsDerivedFrom( unaryExprs_371f.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_3724= SFC::UnaryExprs::Cast( unaryExprs_371f);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3729;
		if( !isValidBound(boundObjs_3729, struct_3709, true))
			continue;
		currMatch.struct_372a= struct_3709;
		if( !isValidBound(boundObjs_3729, member_3712, true))
			continue;
		currMatch.member_372b= member_3712;
		if( !isValidBound(boundObjs_3729, triggerVar_371b, true))
			continue;
		currMatch.triggerVar_372c= triggerVar_371b;
		if( !isValidBound(boundObjs_3729, unaryExprs_3724, true))
			continue;
		currMatch.unaryExprs_372d= unaryExprs_3724;
		bool Gz_guard= isGuardTrue( currMatch.member_372b, currMatch.struct_372a, currMatch.triggerVar_372c, currMatch.unaryExprs_372d);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void AddLastTrigger_36f9::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newDot_3732= SFC::BinaryExprs::Create( currMatch.unaryExprs_372d, SFC::UnaryExprs::meta_subexpr);
		SFC::ArgDeclRef newArgDeclRef2_3733= SFC::ArgDeclRef::Create( newDot_3732, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef1_3734= SFC::ArgDeclRef::Create( newDot_3732, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef& ArgDeclRef1= newArgDeclRef1_3734;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_3733;
		SFC::BinaryExprs& Dot= newDot_3732;
		SFC::LocalVar& Member= currMatch.member_372b;
		SFC::Struct& Struct= currMatch.struct_372a;
		SFC::LocalVar& TriggerVar= currMatch.triggerVar_372c;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_372d;
		{
Dot.op() = ".";
};
		newArgDeclRef1_3734.argdecl()= currMatch.member_372b;
		newArgDeclRef2_3733.argdecl()= currMatch.triggerVar_372c;
	}
}

void StartCondition_374e::operator()( const Packets_t& structs_374f, const Packets_t& triggerVars_3752, const Packets_t& userCodes_3755, Packets_t& structs_3751, Packets_t& triggerVars_3754, Packets_t& unaryExprss_3757)
{
#ifdef PRINT_INFO
	printLog( "StartCondition_374e" );
#endif
	RTTGenerator::Instance()->generateRule(3258, "StartCondition");
	_struct_3758= &structs_3751;
	_triggerVar_3759= &triggerVars_3754;
	_unaryExprs_375a= &unaryExprss_3757;
	processInputPackets( structs_374f, triggerVars_3752, userCodes_3755);
}

bool StartCondition_374e::isInputUnique( const Udm::Object& struct_375f, const Udm::Object& triggerVar_3768, const Udm::Object& userCode_3771)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itStruct_3761= _struct_375b.begin(), itTriggerVar_376a= _triggerVar_3764.begin(), itUserCode_3773= _userCode_376d.begin(); itStruct_3761!= _struct_375b.end(), itTriggerVar_376a!= _triggerVar_3764.end(), itUserCode_3773!= _userCode_376d.end(); ++itStruct_3761, ++itTriggerVar_376a, ++itUserCode_3773)
	{
		if( ( *itStruct_3761== struct_375f)&& ( *itTriggerVar_376a== triggerVar_3768)&& ( *itUserCode_3773== userCode_3771))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_375b.push_back( struct_375f);
		_triggerVar_3764.push_back( triggerVar_3768);
		_userCode_376d.push_back( userCode_3771);
	}
	return isUnique;
}

bool StartCondition_374e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void StartCondition_374e::processInputPackets( const Packets_t& structs_374f, const Packets_t& triggerVars_3752, const Packets_t& userCodes_3755)
{
	for( Packets_t::const_iterator itStruct_375c= structs_374f.begin(), itTriggerVar_3765= triggerVars_3752.begin(), itUserCode_376e= userCodes_3755.begin(); itStruct_375c!= structs_374f.end(), itTriggerVar_3765!= triggerVars_3752.end(), itUserCode_376e!= userCodes_3755.end(); ++itStruct_375c, ++itTriggerVar_3765, ++itUserCode_376e)
	{
		bool isUnique= isInputUnique( *itStruct_375c, *itTriggerVar_3765, *itUserCode_376e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itStruct_375c, *itTriggerVar_3765, *itUserCode_376e);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool StartCondition_374e::patternMatcher( const Udm::Object& struct_375d, const Udm::Object& triggerVar_3766, const Udm::Object& userCode_376f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( struct_375d.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_3762= SFC::Struct::Cast( struct_375d);
		if( false== Uml::IsDerivedFrom( triggerVar_3766.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_376b= SFC::LocalVar::Cast( triggerVar_3766);
		if( false== Uml::IsDerivedFrom( userCode_376f.type(), SFC::UserCode::meta))
			continue;
		SFC::UserCode userCode_3774= SFC::UserCode::Cast( userCode_376f);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3779;
		if( !isValidBound(boundObjs_3779, struct_3762, true))
			continue;
		currMatch.struct_377a= struct_3762;
		if( !isValidBound(boundObjs_3779, triggerVar_376b, true))
			continue;
		currMatch.triggerVar_377b= triggerVar_376b;
		if( !isValidBound(boundObjs_3779, userCode_3774, true))
			continue;
		currMatch.userCode_377c= userCode_3774;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void StartCondition_374e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UnaryExprs newUnaryExprs_377d= SFC::UnaryExprs::Create( currMatch.userCode_377c, SFC::UserCode::meta_codeexpr);
		SFC::Struct& Struct= currMatch.struct_377a;
		SFC::LocalVar& TriggerVar= currMatch.triggerVar_377b;
		SFC::UnaryExprs& UnaryExprs= newUnaryExprs_377d;
		SFC::UserCode& UserCode= currMatch.userCode_377c;
		{
UnaryExprs.op() = "";
};
		outputAppender( currMatch.struct_377a, currMatch.triggerVar_377b, newUnaryExprs_377d);
	}
}

void StartCondition_374e::outputAppender( const SFC::Struct& struct_377e, const SFC::LocalVar& triggerVar_3780, const SFC::UnaryExprs& unaryExprs_3782)
{
	_struct_3758->push_back( struct_377e);
	_triggerVar_3759->push_back( triggerVar_3780);
	_unaryExprs_375a->push_back( unaryExprs_3782);
}

void AddStateVar_379f::operator()( const Packets_t& subsystems_37a0, const Packets_t& triggerPorts_37a3, const Packets_t& argDeclBases_37a6, const Packets_t& dTs_37aa, const Packets_t& functions_37ae, Packets_t& subsystems_37a2, Packets_t& charts_37a5, Packets_t& argDeclBases_37a8, Packets_t& localVars_37a9, Packets_t& dTs_37ac, Packets_t& args_37ad, Packets_t& functions_37b0)
{
#ifdef PRINT_INFO
	printLog( "AddStateVar_379f" );
#endif
	RTTGenerator::Instance()->generateRule(3265, "AddStateVar");
	_subsystem_37b1= &subsystems_37a2;
	_chart_37b2= &charts_37a5;
	_argDeclBase_37b3= &argDeclBases_37a8;
	_localVar_37b4= &localVars_37a9;
	_dT_37b5= &dTs_37ac;
	_arg_37b6= &args_37ad;
	_function_37b7= &functions_37b0;
	processInputPackets( subsystems_37a0, triggerPorts_37a3, argDeclBases_37a6, dTs_37aa, functions_37ae);
}

bool AddStateVar_379f::isInputUnique( const Udm::Object& subsystem_37bc, const Udm::Object& triggerPort_37c5, const Udm::Object& argDeclBase_37ce, const Udm::Object& dT_37d7, const Udm::Object& function_37e0)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_37be= _subsystem_37b8.begin(), itTriggerPort_37c7= _triggerPort_37c1.begin(), itArgDeclBase_37d0= _argDeclBase_37ca.begin(), itDT_37d9= _dT_37d3.begin(), itFunction_37e2= _function_37dc.begin(); itSubsystem_37be!= _subsystem_37b8.end(), itTriggerPort_37c7!= _triggerPort_37c1.end(), itArgDeclBase_37d0!= _argDeclBase_37ca.end(), itDT_37d9!= _dT_37d3.end(), itFunction_37e2!= _function_37dc.end(); ++itSubsystem_37be, ++itTriggerPort_37c7, ++itArgDeclBase_37d0, ++itDT_37d9, ++itFunction_37e2)
	{
		if( ( *itSubsystem_37be== subsystem_37bc)&& ( *itTriggerPort_37c7== triggerPort_37c5)&& ( *itArgDeclBase_37d0== argDeclBase_37ce)&& ( *itDT_37d9== dT_37d7)&& ( *itFunction_37e2== function_37e0))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_37b8.push_back( subsystem_37bc);
		_triggerPort_37c1.push_back( triggerPort_37c5);
		_argDeclBase_37ca.push_back( argDeclBase_37ce);
		_dT_37d3.push_back( dT_37d7);
		_function_37dc.push_back( function_37e0);
	}
	return isUnique;
}

bool AddStateVar_379f::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void AddStateVar_379f::processInputPackets( const Packets_t& subsystems_37a0, const Packets_t& triggerPorts_37a3, const Packets_t& argDeclBases_37a6, const Packets_t& dTs_37aa, const Packets_t& functions_37ae)
{
	for( Packets_t::const_iterator itSubsystem_37b9= subsystems_37a0.begin(), itTriggerPort_37c2= triggerPorts_37a3.begin(), itArgDeclBase_37cb= argDeclBases_37a6.begin(), itDT_37d4= dTs_37aa.begin(), itFunction_37dd= functions_37ae.begin(); itSubsystem_37b9!= subsystems_37a0.end(), itTriggerPort_37c2!= triggerPorts_37a3.end(), itArgDeclBase_37cb!= argDeclBases_37a6.end(), itDT_37d4!= dTs_37aa.end(), itFunction_37dd!= functions_37ae.end(); ++itSubsystem_37b9, ++itTriggerPort_37c2, ++itArgDeclBase_37cb, ++itDT_37d4, ++itFunction_37dd)
	{
		bool isUnique= isInputUnique( *itSubsystem_37b9, *itTriggerPort_37c2, *itArgDeclBase_37cb, *itDT_37d4, *itFunction_37dd);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_37b9, *itTriggerPort_37c2, *itArgDeclBase_37cb, *itDT_37d4, *itFunction_37dd);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AddStateVar_379f::patternMatcher( const Udm::Object& subsystem_37ba, const Udm::Object& triggerPort_37c3, const Udm::Object& argDeclBase_37cc, const Udm::Object& dT_37d5, const Udm::Object& function_37de)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_37ba.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_37bf= CyberComposition::Simulink::Subsystem::Cast( subsystem_37ba);
		if( false== Uml::IsDerivedFrom( triggerPort_37c3.type(), CyberComposition::Simulink::TriggerPort::meta))
			continue;
		CyberComposition::Simulink::TriggerPort triggerPort_37c8= CyberComposition::Simulink::TriggerPort::Cast( triggerPort_37c3);
		if( false== Uml::IsDerivedFrom( argDeclBase_37cc.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_37d1= SFC::ArgDeclBase::Cast( argDeclBase_37cc);
		if( false== Uml::IsDerivedFrom( dT_37d5.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_37da= SFC::DT::Cast( dT_37d5);
		if( false== Uml::IsDerivedFrom( function_37de.type(), SFC::Function::meta))
			continue;
		SFC::Function function_37e3= SFC::Function::Cast( function_37de);
		set< SFC::Arg> args_37e5= function_37e3.Arg_kind_children();
		for( set< SFC::Arg>::const_iterator itArg_37e6= args_37e5.begin(); itArg_37e6!= args_37e5.end(); ++itArg_37e6)
		{
			SFC::Arg currArg_37e7= *itArg_37e6;
			Udm::Object functionParent_37e8= function_37e3.container();
			if( false== Uml::IsDerivedFrom( functionParent_37e8.type(), SFC::Class::meta))
				continue;
			SFC::Class classFunction_37e9= SFC::Class::Cast( functionParent_37e8);
			set< SFC::Struct> structs_37ea= classFunction_37e9.Struct_kind_children();
			for( set< SFC::Struct>::const_iterator itStruct_37eb= structs_37ea.begin(); itStruct_37eb!= structs_37ea.end(); ++itStruct_37eb)
			{
				SFC::Struct currStruct_37ec= *itStruct_37eb;
				SFC::DT struct_37ed= currArg_37e7.dt();
				if(!struct_37ed || false== Uml::IsDerivedFrom( struct_37ed.type(), SFC::Struct::meta))
					continue;
				SFC::Struct struct_37ee= SFC::Struct::Cast( struct_37ed);
				if( !struct_37ee)
					continue;
				if( currStruct_37ec!= struct_37ee)
					continue;
				Udm::Object triggerPortParent_37ef= triggerPort_37c8.container();
				if( false== Uml::IsDerivedFrom( triggerPortParent_37ef.type(), CyberComposition::Simulink::Subsystem::meta))
					continue;
				CyberComposition::Simulink::Subsystem chartTriggerPort_37f0= CyberComposition::Simulink::Subsystem::Cast( triggerPortParent_37ef);
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_37f4;
				if( !isValidBound(boundObjs_37f4, subsystem_37bf, true))
					continue;
				currMatch.subsystem_37f5= subsystem_37bf;
				if( !isValidBound(boundObjs_37f4, triggerPort_37c8, true))
					continue;
				currMatch.triggerPort_37f6= triggerPort_37c8;
				if( !isValidBound(boundObjs_37f4, argDeclBase_37d1, true))
					continue;
				currMatch.argDeclBase_37f7= argDeclBase_37d1;
				if( !isValidBound(boundObjs_37f4, dT_37da, true))
					continue;
				currMatch.dT_37f8= dT_37da;
				if( !isValidBound(boundObjs_37f4, function_37e3, true))
					continue;
				currMatch.function_37f9= function_37e3;
				if( !isValidBound(boundObjs_37f4, chartTriggerPort_37f0, false))
					continue;
				currMatch.chart_37fa= chartTriggerPort_37f0;
				if( !isValidBound(boundObjs_37f4, currArg_37e7, false))
					continue;
				currMatch.arg_37fb= currArg_37e7;
				if( !isValidBound(boundObjs_37f4, currStruct_37ec, false))
					continue;
				currMatch.struct_37fc= currStruct_37ec;
				if( !isValidBound(boundObjs_37f4, classFunction_37e9, false))
					continue;
				currMatch.class_37fd= classFunction_37e9;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void AddStateVar_379f::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newLocalVar_37fe= SFC::LocalVar::Create( currMatch.struct_37fc, SFC::Struct::meta_memb);
		SFC::Arg& Arg= currMatch.arg_37fb;
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_37f7;
		CyberComposition::Simulink::Subsystem& Chart= currMatch.chart_37fa;
		SFC::Class& Class= currMatch.class_37fd;
		SFC::DT& DT= currMatch.dT_37f8;
		SFC::Function& Function= currMatch.function_37f9;
		SFC::LocalVar& LocalVar= newLocalVar_37fe;
		SFC::Struct& Struct= currMatch.struct_37fc;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_37f5;
		CyberComposition::Simulink::TriggerPort& TriggerPort= currMatch.triggerPort_37f6;
		{
__int64 memberCount = Struct.memberCount();
LocalVar.statementIndex() = memberCount++;
Struct.memberCount() = memberCount;

LocalVar.name() = std::string( "triggerData" ) + boost::lexical_cast< std::string >( LocalVar.uniqueId() );
};
		newLocalVar_37fe.trig()+= currMatch.triggerPort_37f6;
		newLocalVar_37fe.dt()= currMatch.dT_37f8;
		outputAppender( currMatch.subsystem_37f5, currMatch.chart_37fa, currMatch.argDeclBase_37f7, newLocalVar_37fe, currMatch.dT_37f8, currMatch.arg_37fb, currMatch.function_37f9);
	}
}

void AddStateVar_379f::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_37ff, const CyberComposition::Simulink::Subsystem& chart_3801, const SFC::ArgDeclBase& argDeclBase_3803, const SFC::LocalVar& localVar_3805, const SFC::DT& dT_3807, const SFC::Arg& arg_3809, const SFC::Function& function_380b)
{
	_subsystem_37b1->push_back( subsystem_37ff);
	_chart_37b2->push_back( chart_3801);
	_argDeclBase_37b3->push_back( argDeclBase_3803);
	_localVar_37b4->push_back( localVar_3805);
	_dT_37b5->push_back( dT_3807);
	_arg_37b6->push_back( arg_3809);
	_function_37b7->push_back( function_380b);
}

void SaveState_380d::operator()( const Packets_t& systems_380e, const Packets_t& childsystems_3810, const Packets_t& argdecls_3812, const Packets_t& dts_3814, const Packets_t& oldvals_3816, const Packets_t& contexts_3818, const Packets_t& functions_381a, Packets_t& systems_381c, Packets_t& childsystems_381d, Packets_t& dts_381e, Packets_t& oldvals_381f, Packets_t& functions_3820)
{
#ifdef PRINT_INFO
	printLog( "SaveState_380d" );
#endif
	_system_3821= &systems_381c;
	_childsystem_3822= &childsystems_381d;
	_dt_3823= &dts_381e;
	_oldval_3824= &oldvals_381f;
	_function_3825= &functions_3820;
	if( ( !argdecls_3812.empty())&& ( !dts_3814.empty())&& ( !oldvals_3816.empty())&& ( !contexts_3818.empty())&& ( !functions_381a.empty()))
		callSaveMatrixState_38ed( argdecls_3812, dts_3814, oldvals_3816, contexts_3818, functions_381a);
	_system_3821->insert( _system_3821->end(), systems_380e.begin(), systems_380e.end());
	_childsystem_3822->insert( _childsystem_3822->end(), childsystems_3810.begin(), childsystems_3810.end());
	_dt_3823->insert( _dt_3823->end(), dts_3814.begin(), dts_3814.end());
	_oldval_3824->insert( _oldval_3824->end(), oldvals_3816.begin(), oldvals_3816.end());
	_function_3825->insert( _function_3825->end(), functions_381a.begin(), functions_381a.end());
}

void SaveState_380d::callSaveMatrixState_38ed( const Packets_t& argdecls_3827, const Packets_t& dts_3829, const Packets_t& oldvals_382b, const Packets_t& contexts_382d, const Packets_t& functions_382f)
{
	Packets_t argdecls_3831;
	Packets_t dts_3832;
	Packets_t oldvals_3833;
	Packets_t contexts_3834;
	Packets_t functions_3835;
	SaveMatrixState_3826 saveMatrixState_3826;
	saveMatrixState_3826( argdecls_3827, dts_3829, oldvals_382b, contexts_382d, functions_382f, argdecls_3831, dts_3832, oldvals_3833, contexts_3834, functions_3835);
	if( ( !argdecls_3831.empty())&& ( !dts_3832.empty())&& ( !oldvals_3833.empty())&& ( !contexts_3834.empty())&& ( !functions_3835.empty()))
		callSaveStructState_38f3( argdecls_3831, dts_3832, oldvals_3833, contexts_3834, functions_3835);
}

void SaveState_380d::callSaveStructState_38f3( const Packets_t& argdecls_388e, const Packets_t& dts_3890, const Packets_t& oldvals_3892, const Packets_t& contexts_3894, const Packets_t& functions_3896)
{
	SaveStructState_388d saveStructState_388d;
	saveStructState_388d( argdecls_388e, dts_3890, oldvals_3892, contexts_3894, functions_3896);
}

void SaveMatrixState_3826::operator()( const Packets_t& argdecls_3827, const Packets_t& dts_3829, const Packets_t& oldvals_382b, const Packets_t& contexts_382d, const Packets_t& functions_382f, Packets_t& argdecls_3831, Packets_t& dts_3832, Packets_t& oldvals_3833, Packets_t& contexts_3834, Packets_t& functions_3835)
{
#ifdef PRINT_INFO
	printLog( "SaveMatrixState_3826" );
#endif
	_argdecl_3836= &argdecls_3831;
	_dt_3837= &dts_3832;
	_oldval_3838= &oldvals_3833;
	_context_3839= &contexts_3834;
	_function_383a= &functions_3835;
	if( ( !argdecls_3827.empty())&& ( !dts_3829.empty())&& ( !oldvals_382b.empty())&& ( !contexts_382d.empty())&& ( !functions_382f.empty()))
		callSaveMatrixState_3887( argdecls_3827, dts_3829, oldvals_382b, contexts_382d, functions_382f);
	_argdecl_3836->insert( _argdecl_3836->end(), argdecls_3827.begin(), argdecls_3827.end());
	_dt_3837->insert( _dt_3837->end(), dts_3829.begin(), dts_3829.end());
	_oldval_3838->insert( _oldval_3838->end(), oldvals_382b.begin(), oldvals_382b.end());
	_context_3839->insert( _context_3839->end(), contexts_382d.begin(), contexts_382d.end());
	_function_383a->insert( _function_383a->end(), functions_382f.begin(), functions_382f.end());
}

void SaveMatrixState_3826::callSaveMatrixState_3887( const Packets_t& argDeclBases_383c, const Packets_t& dTs_383e, const Packets_t& localVars_3840, const Packets_t& args_3842, const Packets_t& functions_3844)
{
	SaveMatrixState_383b saveMatrixState_383b;
	saveMatrixState_383b( argDeclBases_383c, dTs_383e, localVars_3840, args_3842, functions_3844);
}

void SaveMatrixState_383b::operator()( const Packets_t& argDeclBases_383c, const Packets_t& dTs_383e, const Packets_t& localVars_3840, const Packets_t& args_3842, const Packets_t& functions_3844)
{
#ifdef PRINT_INFO
	printLog( "SaveMatrixState_383b" );
#endif
	RTTGenerator::Instance()->generateRule(3309, "SaveMatrixState");
	processInputPackets( argDeclBases_383c, dTs_383e, localVars_3840, args_3842, functions_3844);
}

bool SaveMatrixState_383b::isInputUnique( const Udm::Object& argDeclBase_384a, const Udm::Object& dT_3853, const Udm::Object& localVar_385c, const Udm::Object& arg_3865, const Udm::Object& function_386e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_384c= _argDeclBase_3846.begin(), itDT_3855= _dT_384f.begin(), itLocalVar_385e= _localVar_3858.begin(), itArg_3867= _arg_3861.begin(), itFunction_3870= _function_386a.begin(); itArgDeclBase_384c!= _argDeclBase_3846.end(), itDT_3855!= _dT_384f.end(), itLocalVar_385e!= _localVar_3858.end(), itArg_3867!= _arg_3861.end(), itFunction_3870!= _function_386a.end(); ++itArgDeclBase_384c, ++itDT_3855, ++itLocalVar_385e, ++itArg_3867, ++itFunction_3870)
	{
		if( ( *itArgDeclBase_384c== argDeclBase_384a)&& ( *itDT_3855== dT_3853)&& ( *itLocalVar_385e== localVar_385c)&& ( *itArg_3867== arg_3865)&& ( *itFunction_3870== function_386e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_3846.push_back( argDeclBase_384a);
		_dT_384f.push_back( dT_3853);
		_localVar_3858.push_back( localVar_385c);
		_arg_3861.push_back( arg_3865);
		_function_386a.push_back( function_386e);
	}
	return isUnique;
}

bool SaveMatrixState_383b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool SaveMatrixState_383b::isGuardTrue( SFC::Arg& Arg, SFC::ArgDeclBase& ArgDeclBase, SFC::DT& DT, SFC::Function& Function, SFC::LocalVar& LocalVar)
{
	bool Gz_guard= false;
	Gz_guard = DT.type() != SFC::Struct::meta;;
	return Gz_guard;
}

void SaveMatrixState_383b::processInputPackets( const Packets_t& argDeclBases_383c, const Packets_t& dTs_383e, const Packets_t& localVars_3840, const Packets_t& args_3842, const Packets_t& functions_3844)
{
	for( Packets_t::const_iterator itArgDeclBase_3847= argDeclBases_383c.begin(), itDT_3850= dTs_383e.begin(), itLocalVar_3859= localVars_3840.begin(), itArg_3862= args_3842.begin(), itFunction_386b= functions_3844.begin(); itArgDeclBase_3847!= argDeclBases_383c.end(), itDT_3850!= dTs_383e.end(), itLocalVar_3859!= localVars_3840.end(), itArg_3862!= args_3842.end(), itFunction_386b!= functions_3844.end(); ++itArgDeclBase_3847, ++itDT_3850, ++itLocalVar_3859, ++itArg_3862, ++itFunction_386b)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_3847, *itDT_3850, *itLocalVar_3859, *itArg_3862, *itFunction_386b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_3847, *itDT_3850, *itLocalVar_3859, *itArg_3862, *itFunction_386b);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool SaveMatrixState_383b::patternMatcher( const Udm::Object& argDeclBase_3848, const Udm::Object& dT_3851, const Udm::Object& localVar_385a, const Udm::Object& arg_3863, const Udm::Object& function_386c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_3848.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_384d= SFC::ArgDeclBase::Cast( argDeclBase_3848);
		if( false== Uml::IsDerivedFrom( dT_3851.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_3856= SFC::DT::Cast( dT_3851);
		if( false== Uml::IsDerivedFrom( localVar_385a.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_385f= SFC::LocalVar::Cast( localVar_385a);
		if( false== Uml::IsDerivedFrom( arg_3863.type(), SFC::Arg::meta))
			continue;
		SFC::Arg arg_3868= SFC::Arg::Cast( arg_3863);
		if( false== Uml::IsDerivedFrom( function_386c.type(), SFC::Function::meta))
			continue;
		SFC::Function function_3871= SFC::Function::Cast( function_386c);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3876;
		if( !isValidBound(boundObjs_3876, argDeclBase_384d, true))
			continue;
		currMatch.argDeclBase_3877= argDeclBase_384d;
		if( !isValidBound(boundObjs_3876, dT_3856, true))
			continue;
		currMatch.dT_3878= dT_3856;
		if( !isValidBound(boundObjs_3876, localVar_385f, true))
			continue;
		currMatch.localVar_3879= localVar_385f;
		if( !isValidBound(boundObjs_3876, arg_3868, true))
			continue;
		currMatch.arg_387a= arg_3868;
		if( !isValidBound(boundObjs_3876, function_3871, true))
			continue;
		currMatch.function_387b= function_3871;
		bool Gz_guard= isGuardTrue( currMatch.arg_387a, currMatch.argDeclBase_3877, currMatch.dT_3878, currMatch.function_387b, currMatch.localVar_3879);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void SaveMatrixState_383b::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newUserCode_3881= SFC::UserCode::Create( currMatch.function_387b, SFC::Function::meta_stmnt);
		SFC::BinaryExprs newAssign_3882= SFC::BinaryExprs::Create( newUserCode_3881, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newDot_3883= SFC::BinaryExprs::Create( newAssign_3882, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef3_3884= SFC::ArgDeclRef::Create( newDot_3883, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef4_3885= SFC::ArgDeclRef::Create( newDot_3883, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_3886= SFC::ArgDeclRef::Create( newAssign_3882, SFC::BinaryExprs::meta_rightexpr);
		SFC::Arg& Arg= currMatch.arg_387a;
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_3877;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_3886;
		SFC::ArgDeclRef& ArgDeclRef3= newArgDeclRef3_3884;
		SFC::ArgDeclRef& ArgDeclRef4= newArgDeclRef4_3885;
		SFC::BinaryExprs& Assign= newAssign_3882;
		SFC::DT& DT= currMatch.dT_3878;
		SFC::BinaryExprs& Dot= newDot_3883;
		SFC::Function& Function= currMatch.function_387b;
		SFC::LocalVar& LocalVar= currMatch.localVar_3879;
		SFC::UserCode& UserCode= newUserCode_3881;
		{
__int64 statementCount = Function.statementCount();
UserCode.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		{
Assign.op() = "=";
};
		{
Dot.op() = ".";
};
		newArgDeclRef3_3884.argdecl()= currMatch.localVar_3879;
		newArgDeclRef4_3885.argdecl()= currMatch.arg_387a;
		newArgDeclRef2_3886.argdecl()= currMatch.argDeclBase_3877;
	}
}

void SaveStructState_388d::operator()( const Packets_t& argdecls_388e, const Packets_t& dts_3890, const Packets_t& oldvals_3892, const Packets_t& contexts_3894, const Packets_t& functions_3896)
{
#ifdef PRINT_INFO
	printLog( "SaveStructState_388d" );
#endif
	if( ( !argdecls_388e.empty())&& ( !dts_3890.empty())&& ( !oldvals_3892.empty())&& ( !contexts_3894.empty())&& ( !functions_3896.empty()))
		callSaveStructState_38e7( argdecls_388e, dts_3890, oldvals_3892, contexts_3894, functions_3896);
}

void SaveStructState_388d::callSaveStructState_38e7( const Packets_t& argDeclBases_3899, const Packets_t& structs_389b, const Packets_t& localVars_389d, const Packets_t& contexts_389f, const Packets_t& functions_38a1)
{
	SaveStructState_3898 saveStructState_3898;
	saveStructState_3898( argDeclBases_3899, structs_389b, localVars_389d, contexts_389f, functions_38a1);
}

void SaveStructState_3898::operator()( const Packets_t& argDeclBases_3899, const Packets_t& structs_389b, const Packets_t& localVars_389d, const Packets_t& contexts_389f, const Packets_t& functions_38a1)
{
#ifdef PRINT_INFO
	printLog( "SaveStructState_3898" );
#endif
	RTTGenerator::Instance()->generateRule(3339, "SaveStructState");
	processInputPackets( argDeclBases_3899, structs_389b, localVars_389d, contexts_389f, functions_38a1);
}

bool SaveStructState_3898::isInputUnique( const Udm::Object& argDeclBase_38a7, const Udm::Object& struct_38b0, const Udm::Object& localVar_38b9, const Udm::Object& context_38c2, const Udm::Object& function_38cb)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_38a9= _argDeclBase_38a3.begin(), itStruct_38b2= _struct_38ac.begin(), itLocalVar_38bb= _localVar_38b5.begin(), itContext_38c4= _context_38be.begin(), itFunction_38cd= _function_38c7.begin(); itArgDeclBase_38a9!= _argDeclBase_38a3.end(), itStruct_38b2!= _struct_38ac.end(), itLocalVar_38bb!= _localVar_38b5.end(), itContext_38c4!= _context_38be.end(), itFunction_38cd!= _function_38c7.end(); ++itArgDeclBase_38a9, ++itStruct_38b2, ++itLocalVar_38bb, ++itContext_38c4, ++itFunction_38cd)
	{
		if( ( *itArgDeclBase_38a9== argDeclBase_38a7)&& ( *itStruct_38b2== struct_38b0)&& ( *itLocalVar_38bb== localVar_38b9)&& ( *itContext_38c4== context_38c2)&& ( *itFunction_38cd== function_38cb))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_38a3.push_back( argDeclBase_38a7);
		_struct_38ac.push_back( struct_38b0);
		_localVar_38b5.push_back( localVar_38b9);
		_context_38be.push_back( context_38c2);
		_function_38c7.push_back( function_38cb);
	}
	return isUnique;
}

bool SaveStructState_3898::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void SaveStructState_3898::processInputPackets( const Packets_t& argDeclBases_3899, const Packets_t& structs_389b, const Packets_t& localVars_389d, const Packets_t& contexts_389f, const Packets_t& functions_38a1)
{
	for( Packets_t::const_iterator itArgDeclBase_38a4= argDeclBases_3899.begin(), itStruct_38ad= structs_389b.begin(), itLocalVar_38b6= localVars_389d.begin(), itContext_38bf= contexts_389f.begin(), itFunction_38c8= functions_38a1.begin(); itArgDeclBase_38a4!= argDeclBases_3899.end(), itStruct_38ad!= structs_389b.end(), itLocalVar_38b6!= localVars_389d.end(), itContext_38bf!= contexts_389f.end(), itFunction_38c8!= functions_38a1.end(); ++itArgDeclBase_38a4, ++itStruct_38ad, ++itLocalVar_38b6, ++itContext_38bf, ++itFunction_38c8)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_38a4, *itStruct_38ad, *itLocalVar_38b6, *itContext_38bf, *itFunction_38c8);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_38a4, *itStruct_38ad, *itLocalVar_38b6, *itContext_38bf, *itFunction_38c8);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool SaveStructState_3898::patternMatcher( const Udm::Object& argDeclBase_38a5, const Udm::Object& struct_38ae, const Udm::Object& localVar_38b7, const Udm::Object& context_38c0, const Udm::Object& function_38c9)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_38a5.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_38aa= SFC::ArgDeclBase::Cast( argDeclBase_38a5);
		if( false== Uml::IsDerivedFrom( struct_38ae.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_38b3= SFC::Struct::Cast( struct_38ae);
		if( false== Uml::IsDerivedFrom( localVar_38b7.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_38bc= SFC::LocalVar::Cast( localVar_38b7);
		if( false== Uml::IsDerivedFrom( context_38c0.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_38c5= SFC::Arg::Cast( context_38c0);
		if( false== Uml::IsDerivedFrom( function_38c9.type(), SFC::Function::meta))
			continue;
		SFC::Function function_38ce= SFC::Function::Cast( function_38c9);
		set< SFC::LocalVar> members_38d0= struct_38b3.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itMember_38d1= members_38d0.begin(); itMember_38d1!= members_38d0.end(); ++itMember_38d1)
		{
			SFC::LocalVar currMember_38d2= *itMember_38d1;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_38d6;
			if( !isValidBound(boundObjs_38d6, argDeclBase_38aa, true))
				continue;
			currMatch.argDeclBase_38d7= argDeclBase_38aa;
			if( !isValidBound(boundObjs_38d6, struct_38b3, true))
				continue;
			currMatch.struct_38d8= struct_38b3;
			if( !isValidBound(boundObjs_38d6, localVar_38bc, true))
				continue;
			currMatch.localVar_38d9= localVar_38bc;
			if( !isValidBound(boundObjs_38d6, context_38c5, true))
				continue;
			currMatch.context_38da= context_38c5;
			if( !isValidBound(boundObjs_38d6, function_38ce, true))
				continue;
			currMatch.function_38db= function_38ce;
			if( !isValidBound(boundObjs_38d6, currMember_38d2, false))
				continue;
			currMatch.member_38dc= currMember_38d2;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void SaveStructState_3898::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newUserCode_38dd= SFC::UserCode::Create( currMatch.function_38db);
		SFC::BinaryExprs newAssign_38de= SFC::BinaryExprs::Create( newUserCode_38dd, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newMemberDot_38df= SFC::BinaryExprs::Create( newAssign_38de, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newMemberRef3_38e0= SFC::ArgDeclRef::Create( newMemberDot_38df, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newContextDot_38e1= SFC::BinaryExprs::Create( newMemberDot_38df, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef3_38e2= SFC::ArgDeclRef::Create( newContextDot_38e1, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef4_38e3= SFC::ArgDeclRef::Create( newContextDot_38e1, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newArgDeclDot2_38e4= SFC::BinaryExprs::Create( newAssign_38de, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newMemberRef2_38e5= SFC::ArgDeclRef::Create( newArgDeclDot2_38e4, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef2_38e6= SFC::ArgDeclRef::Create( newArgDeclDot2_38e4, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_38d7;
		SFC::BinaryExprs& ArgDeclDot2= newArgDeclDot2_38e4;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_38e6;
		SFC::ArgDeclRef& ArgDeclRef3= newArgDeclRef3_38e2;
		SFC::ArgDeclRef& ArgDeclRef4= newArgDeclRef4_38e3;
		SFC::BinaryExprs& Assign= newAssign_38de;
		SFC::Arg& Context= currMatch.context_38da;
		SFC::BinaryExprs& ContextDot= newContextDot_38e1;
		SFC::Function& Function= currMatch.function_38db;
		SFC::LocalVar& LocalVar= currMatch.localVar_38d9;
		SFC::LocalVar& Member= currMatch.member_38dc;
		SFC::BinaryExprs& MemberDot= newMemberDot_38df;
		SFC::ArgDeclRef& MemberRef2= newMemberRef2_38e5;
		SFC::ArgDeclRef& MemberRef3= newMemberRef3_38e0;
		SFC::Struct& Struct= currMatch.struct_38d8;
		SFC::UserCode& UserCode= newUserCode_38dd;
		{
ContextDot.op() = ".";
};
		{
__int64 statementCount = Function.statementCount();
UserCode.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		{
Assign.op() = "=";
};
		{
MemberDot.op() = ".";
};
		{
ArgDeclDot2.op() = ".";
};
		newArgDeclRef4_38e3.argdecl()= currMatch.context_38da;
		newArgDeclRef2_38e6.argdecl()= currMatch.argDeclBase_38d7;
		newArgDeclRef3_38e2.argdecl()= currMatch.localVar_38d9;
		newMemberRef3_38e0.argdecl()= currMatch.member_38dc;
		newMemberRef2_38e5.argdecl()= currMatch.member_38dc;
	}
}

void AddTriggerVars_38f9::operator()( const Packets_t& systems_38fa, const Packets_t& childsystems_38fc, const Packets_t& argdecls_38fe, const Packets_t& dts_3900, const Packets_t& oldvals_3902, const Packets_t& contexts_3904, const Packets_t& functions_3906, Packets_t& systems_3908, Packets_t& childsystems_3909, Packets_t& argdecls_390a, Packets_t& dts_390b, Packets_t& oldvals_390c, Packets_t& contexts_390d, Packets_t& functions_390e)
{
#ifdef PRINT_INFO
	printLog( "AddTriggerVars_38f9" );
#endif
	_system_390f= &systems_3908;
	_childsystem_3910= &childsystems_3909;
	_argdecl_3911= &argdecls_390a;
	_dt_3912= &dts_390b;
	_oldval_3913= &oldvals_390c;
	_context_3914= &contexts_390d;
	_function_3915= &functions_390e;
	_system_390f->insert( _system_390f->end(), systems_38fa.begin(), systems_38fa.end());
	_childsystem_3910->insert( _childsystem_3910->end(), childsystems_38fc.begin(), childsystems_38fc.end());
	_argdecl_3911->insert( _argdecl_3911->end(), argdecls_38fe.begin(), argdecls_38fe.end());
	_dt_3912->insert( _dt_3912->end(), dts_3900.begin(), dts_3900.end());
	_oldval_3913->insert( _oldval_3913->end(), oldvals_3902.begin(), oldvals_3902.end());
	_context_3914->insert( _context_3914->end(), contexts_3904.begin(), contexts_3904.end());
	_function_3915->insert( _function_3915->end(), functions_3906.begin(), functions_3906.end());
	if( ( !childsystems_38fc.empty())&& ( !argdecls_38fe.empty())&& ( !dts_3900.empty())&& ( !oldvals_3902.empty())&& ( !contexts_3904.empty())&& ( !functions_3906.empty()))
		callAddMatrixTriggerVars_4011( childsystems_38fc, argdecls_38fe, dts_3900, oldvals_3902, contexts_3904, functions_3906);
}

void AddTriggerVars_38f9::callAddMatrixTriggerVars_4011( const Packets_t& childSubsystems_3cd6, const Packets_t& argdecls_3cd8, const Packets_t& dts_3cda, const Packets_t& oldvals_3cdc, const Packets_t& contexts_3cde, const Packets_t& functions_3ce0)
{
	Packets_t childSubsystems_3ce2;
	Packets_t argdecls_3ce3;
	Packets_t dts_3ce4;
	Packets_t oldvals_3ce5;
	Packets_t contexts_3ce6;
	Packets_t functions_3ce7;
	AddMatrixTriggerVars_3cd5 addMatrixTriggerVars_3cd5;
	addMatrixTriggerVars_3cd5( childSubsystems_3cd6, argdecls_3cd8, dts_3cda, oldvals_3cdc, contexts_3cde, functions_3ce0, childSubsystems_3ce2, argdecls_3ce3, dts_3ce4, oldvals_3ce5, contexts_3ce6, functions_3ce7);
	if( ( !childSubsystems_3ce2.empty())&& ( !argdecls_3ce3.empty())&& ( !dts_3ce4.empty())&& ( !oldvals_3ce5.empty())&& ( !contexts_3ce6.empty())&& ( !functions_3ce7.empty()))
		callAddStructTriggerVars_4018( childSubsystems_3ce2, argdecls_3ce3, dts_3ce4, oldvals_3ce5, contexts_3ce6, functions_3ce7);
}

void AddTriggerVars_38f9::callAddStructTriggerVars_4018( const Packets_t& childSubsystems_3917, const Packets_t& argdecls_3919, const Packets_t& dts_391b, const Packets_t& oldvals_391d, const Packets_t& contexts_391f, const Packets_t& functions_3921)
{
	AddStructTriggerVars_3916 addStructTriggerVars_3916;
	addStructTriggerVars_3916( childSubsystems_3917, argdecls_3919, dts_391b, oldvals_391d, contexts_391f, functions_3921);
}

void AddStructTriggerVars_3916::operator()( const Packets_t& childSubsystems_3917, const Packets_t& argdecls_3919, const Packets_t& dts_391b, const Packets_t& oldvals_391d, const Packets_t& contexts_391f, const Packets_t& functions_3921)
{
#ifdef PRINT_INFO
	printLog( "AddStructTriggerVars_3916" );
#endif
	if( ( !childSubsystems_3917.empty())&& ( !argdecls_3919.empty())&& ( !dts_391b.empty())&& ( !oldvals_391d.empty())&& ( !contexts_391f.empty())&& ( !functions_3921.empty()))
		callAddTriggerVar_3ca1( childSubsystems_3917, argdecls_3919, dts_391b, oldvals_391d, contexts_391f, functions_3921);
}

void AddStructTriggerVars_3916::callAddTriggerVar_3ca1( const Packets_t& charts_39b6, const Packets_t& argDeclBases_39b9, const Packets_t& structs_39bc, const Packets_t& localVars_39bf, const Packets_t& contexts_39c2, const Packets_t& functions_39c6)
{
	Packets_t charts_39b8;
	Packets_t argDeclBases_39bb;
	Packets_t structs_39be;
	Packets_t localVars_39c1;
	Packets_t contexts_39c4;
	Packets_t triggerVars_39c5;
	Packets_t functions_39c8;
	AddTriggerVar_39b5 addTriggerVar_39b5;
	addTriggerVar_39b5( charts_39b6, argDeclBases_39b9, structs_39bc, localVars_39bf, contexts_39c2, functions_39c6, charts_39b8, argDeclBases_39bb, structs_39be, localVars_39c1, contexts_39c4, triggerVars_39c5, functions_39c8);
	if( ( !charts_39b8.empty())&& ( !argDeclBases_39bb.empty())&& ( !structs_39be.empty())&& ( !localVars_39c1.empty())&& ( !contexts_39c4.empty())&& ( !triggerVars_39c5.empty())&& ( !functions_39c8.empty()))
		callStartAssignment_3ca8( charts_39b8, argDeclBases_39bb, structs_39be, localVars_39c1, contexts_39c4, triggerVars_39c5, functions_39c8);
}

void AddStructTriggerVars_3916::callStartAssignment_3ca8( const Packets_t& charts_3925, const Packets_t& argDeclBases_3927, const Packets_t& structs_392b, const Packets_t& oldvals_392d, const Packets_t& contexts_3930, const Packets_t& triggerVars_3933, const Packets_t& functions_3935)
{
	Packets_t events_3924;
	Packets_t argDeclBases_3929;
	Packets_t localVars_392a;
	Packets_t oldvals_392f;
	Packets_t contexts_3932;
	Packets_t unaryExprss_3937;
	StartAssignment_3923 startAssignment_3923;
	startAssignment_3923( charts_3925, argDeclBases_3927, structs_392b, oldvals_392d, contexts_3930, triggerVars_3933, functions_3935, events_3924, argDeclBases_3929, localVars_392a, oldvals_392f, contexts_3932, unaryExprss_3937);
	if( ( !events_3924.empty())&& ( !argDeclBases_3929.empty())&& ( !localVars_392a.empty())&& ( !oldvals_392f.empty())&& ( !contexts_3932.empty())&& ( !unaryExprss_3937.empty()))
		callEdgeTest_3cb0( events_3924, argDeclBases_3929, localVars_392a, oldvals_392f, contexts_3932, unaryExprss_3937);
}

void AddStructTriggerVars_3916::callEdgeTest_3cb0( const Packets_t& events_3a20, const Packets_t& argdecls_3a22, const Packets_t& members_3a24, const Packets_t& oldvals_3a26, const Packets_t& contexts_3a28, const Packets_t& initexprs_3a2a)
{
	Packets_t argdecls_3a2c;
	Packets_t members_3a2d;
	Packets_t oldvals_3a2e;
	Packets_t contexts_3a2f;
	Packets_t initexprs_3a30;
	Packets_t argdecls_3a31;
	Packets_t members_3a32;
	Packets_t oldvals_3a33;
	Packets_t contexts_3a34;
	Packets_t initexprs_3a35;
	Packets_t argdecls_3a36;
	Packets_t members_3a37;
	Packets_t oldvals_3a38;
	Packets_t contexts_3a39;
	Packets_t initexprs_3a3a;
	EdgeTest_3a1f edgeTest_3a1f;
	edgeTest_3a1f( events_3a20, argdecls_3a22, members_3a24, oldvals_3a26, contexts_3a28, initexprs_3a2a, argdecls_3a2c, members_3a2d, oldvals_3a2e, contexts_3a2f, initexprs_3a30, argdecls_3a31, members_3a32, oldvals_3a33, contexts_3a34, initexprs_3a35, argdecls_3a36, members_3a37, oldvals_3a38, contexts_3a39, initexprs_3a3a);
	if( ( !argdecls_3a2c.empty())&& ( !members_3a2d.empty())&& ( !oldvals_3a2e.empty())&& ( !contexts_3a2f.empty())&& ( !initexprs_3a30.empty()))
		callRisingEdge_3cb7( argdecls_3a2c, members_3a2d, oldvals_3a2e, contexts_3a2f, initexprs_3a30);
	if( ( !argdecls_3a31.empty())&& ( !members_3a32.empty())&& ( !oldvals_3a33.empty())&& ( !contexts_3a34.empty())&& ( !initexprs_3a35.empty()))
		callFallingEdge_3cbd( argdecls_3a31, members_3a32, oldvals_3a33, contexts_3a34, initexprs_3a35);
	if( ( !argdecls_3a36.empty())&& ( !members_3a37.empty())&& ( !oldvals_3a38.empty())&& ( !contexts_3a39.empty())&& ( !initexprs_3a3a.empty()))
		callEitherEdge_3cc3( argdecls_3a36, members_3a37, oldvals_3a38, contexts_3a39, initexprs_3a3a);
}

void AddStructTriggerVars_3916::callRisingEdge_3cb7( const Packets_t& argDeclBases_3baa, const Packets_t& members_3bac, const Packets_t& localVars_3bae, const Packets_t& contexts_3bb0, const Packets_t& unaryExprss_3bb2)
{
	RisingEdge_3ba9 risingEdge_3ba9;
	risingEdge_3ba9( argDeclBases_3baa, members_3bac, localVars_3bae, contexts_3bb0, unaryExprss_3bb2);
}

void AddStructTriggerVars_3916::callFallingEdge_3cbd( const Packets_t& argDeclBases_3bf8, const Packets_t& members_3bfa, const Packets_t& localVars_3bfc, const Packets_t& contexts_3bfe, const Packets_t& unaryExprss_3c00)
{
	FallingEdge_3bf7 fallingEdge_3bf7;
	fallingEdge_3bf7( argDeclBases_3bf8, members_3bfa, localVars_3bfc, contexts_3bfe, unaryExprss_3c00);
}

void AddStructTriggerVars_3916::callEitherEdge_3cc3( const Packets_t& argDeclBases_3c46, const Packets_t& members_3c49, const Packets_t& localVars_3c4c, const Packets_t& contexts_3c4f, const Packets_t& unaryExprss_3c52)
{
	Packets_t argDeclBases_3c48;
	Packets_t members_3c4b;
	Packets_t localVars_3c4e;
	Packets_t contexts_3c51;
	Packets_t leftUnaryExprss_3c54;
	Packets_t rightUnaryExprss_3c55;
	EitherEdge_3c45 eitherEdge_3c45;
	eitherEdge_3c45( argDeclBases_3c46, members_3c49, localVars_3c4c, contexts_3c4f, unaryExprss_3c52, argDeclBases_3c48, members_3c4b, localVars_3c4e, contexts_3c51, leftUnaryExprss_3c54, rightUnaryExprss_3c55);
	if( ( !argDeclBases_3c48.empty())&& ( !members_3c4b.empty())&& ( !localVars_3c4e.empty())&& ( !contexts_3c51.empty())&& ( !leftUnaryExprss_3c54.empty()))
		callRisingEdge_3cc9( argDeclBases_3c48, members_3c4b, localVars_3c4e, contexts_3c51, leftUnaryExprss_3c54);
	if( ( !argDeclBases_3c48.empty())&& ( !members_3c4b.empty())&& ( !localVars_3c4e.empty())&& ( !contexts_3c51.empty())&& ( !rightUnaryExprss_3c55.empty()))
		callFallingEdge_3ccf( argDeclBases_3c48, members_3c4b, localVars_3c4e, contexts_3c51, rightUnaryExprss_3c55);
}

void AddStructTriggerVars_3916::callRisingEdge_3cc9( const Packets_t& argDeclBases_3baa, const Packets_t& members_3bac, const Packets_t& localVars_3bae, const Packets_t& contexts_3bb0, const Packets_t& unaryExprss_3bb2)
{
	RisingEdge_3ba9 risingEdge_3ba9;
	risingEdge_3ba9( argDeclBases_3baa, members_3bac, localVars_3bae, contexts_3bb0, unaryExprss_3bb2);
}

void AddStructTriggerVars_3916::callFallingEdge_3ccf( const Packets_t& argDeclBases_3bf8, const Packets_t& members_3bfa, const Packets_t& localVars_3bfc, const Packets_t& contexts_3bfe, const Packets_t& unaryExprss_3c00)
{
	FallingEdge_3bf7 fallingEdge_3bf7;
	fallingEdge_3bf7( argDeclBases_3bf8, members_3bfa, localVars_3bfc, contexts_3bfe, unaryExprss_3c00);
}

void StartAssignment_3923::operator()( const Packets_t& charts_3925, const Packets_t& argDeclBases_3927, const Packets_t& structs_392b, const Packets_t& oldvals_392d, const Packets_t& contexts_3930, const Packets_t& triggerVars_3933, const Packets_t& functions_3935, Packets_t& events_3924, Packets_t& argDeclBases_3929, Packets_t& localVars_392a, Packets_t& oldvals_392f, Packets_t& contexts_3932, Packets_t& unaryExprss_3937)
{
#ifdef PRINT_INFO
	printLog( "StartAssignment_3923" );
#endif
	RTTGenerator::Instance()->generateRule(3399, "StartAssignment");
	_event_3938= &events_3924;
	_argDeclBase_3939= &argDeclBases_3929;
	_localVar_393a= &localVars_392a;
	_oldval_393b= &oldvals_392f;
	_context_393c= &contexts_3932;
	_unaryExprs_393d= &unaryExprss_3937;
	processInputPackets( charts_3925, argDeclBases_3927, structs_392b, oldvals_392d, contexts_3930, triggerVars_3933, functions_3935);
}

bool StartAssignment_3923::isInputUnique( const Udm::Object& chart_3942, const Udm::Object& argDeclBase_394b, const Udm::Object& struct_3954, const Udm::Object& oldval_395d, const Udm::Object& context_3966, const Udm::Object& triggerVar_396f, const Udm::Object& function_3978)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itChart_3944= _chart_393e.begin(), itArgDeclBase_394d= _argDeclBase_3947.begin(), itStruct_3956= _struct_3950.begin(), itoldval_395f= _oldval_3959.begin(), itContext_3968= _context_3962.begin(), itTriggerVar_3971= _triggerVar_396b.begin(), itFunction_397a= _function_3974.begin(); itChart_3944!= _chart_393e.end(), itArgDeclBase_394d!= _argDeclBase_3947.end(), itStruct_3956!= _struct_3950.end(), itoldval_395f!= _oldval_3959.end(), itContext_3968!= _context_3962.end(), itTriggerVar_3971!= _triggerVar_396b.end(), itFunction_397a!= _function_3974.end(); ++itChart_3944, ++itArgDeclBase_394d, ++itStruct_3956, ++itoldval_395f, ++itContext_3968, ++itTriggerVar_3971, ++itFunction_397a)
	{
		if( ( *itChart_3944== chart_3942)&& ( *itArgDeclBase_394d== argDeclBase_394b)&& ( *itStruct_3956== struct_3954)&& ( *itoldval_395f== oldval_395d)&& ( *itContext_3968== context_3966)&& ( *itTriggerVar_3971== triggerVar_396f)&& ( *itFunction_397a== function_3978))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_chart_393e.push_back( chart_3942);
		_argDeclBase_3947.push_back( argDeclBase_394b);
		_struct_3950.push_back( struct_3954);
		_oldval_3959.push_back( oldval_395d);
		_context_3962.push_back( context_3966);
		_triggerVar_396b.push_back( triggerVar_396f);
		_function_3974.push_back( function_3978);
	}
	return isUnique;
}

bool StartAssignment_3923::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool StartAssignment_3923::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, CyberComposition::Simulink::Subsystem& Chart, SFC::Arg& Context, CyberComposition::Simulink::Event& Event, SFC::Function& Function, SFC::LocalVar& LocalVar, CyberComposition::Simulink::Primitive& Primitive, CyberComposition::Simulink::State& State, SFC::Struct& Struct, SFC::LocalVar& TriggerVar, SFC::LocalVar& oldval)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( Event.Scope() ) == "INPUT_EVENT" &&
 static_cast< __int64>( LocalVar.statementIndex() ) + 1 == static_cast< __int64 >( Event.Port() );;
	return Gz_guard;
}

void StartAssignment_3923::processInputPackets( const Packets_t& charts_3925, const Packets_t& argDeclBases_3927, const Packets_t& structs_392b, const Packets_t& oldvals_392d, const Packets_t& contexts_3930, const Packets_t& triggerVars_3933, const Packets_t& functions_3935)
{
	for( Packets_t::const_iterator itChart_393f= charts_3925.begin(), itArgDeclBase_3948= argDeclBases_3927.begin(), itStruct_3951= structs_392b.begin(), itoldval_395a= oldvals_392d.begin(), itContext_3963= contexts_3930.begin(), itTriggerVar_396c= triggerVars_3933.begin(), itFunction_3975= functions_3935.begin(); itChart_393f!= charts_3925.end(), itArgDeclBase_3948!= argDeclBases_3927.end(), itStruct_3951!= structs_392b.end(), itoldval_395a!= oldvals_392d.end(), itContext_3963!= contexts_3930.end(), itTriggerVar_396c!= triggerVars_3933.end(), itFunction_3975!= functions_3935.end(); ++itChart_393f, ++itArgDeclBase_3948, ++itStruct_3951, ++itoldval_395a, ++itContext_3963, ++itTriggerVar_396c, ++itFunction_3975)
	{
		bool isUnique= isInputUnique( *itChart_393f, *itArgDeclBase_3948, *itStruct_3951, *itoldval_395a, *itContext_3963, *itTriggerVar_396c, *itFunction_3975);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itChart_393f, *itArgDeclBase_3948, *itStruct_3951, *itoldval_395a, *itContext_3963, *itTriggerVar_396c, *itFunction_3975);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool StartAssignment_3923::patternMatcher( const Udm::Object& chart_3940, const Udm::Object& argDeclBase_3949, const Udm::Object& struct_3952, const Udm::Object& oldval_395b, const Udm::Object& context_3964, const Udm::Object& triggerVar_396d, const Udm::Object& function_3976)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( chart_3940.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem chart_3945= CyberComposition::Simulink::Subsystem::Cast( chart_3940);
		if( false== Uml::IsDerivedFrom( argDeclBase_3949.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_394e= SFC::ArgDeclBase::Cast( argDeclBase_3949);
		if( false== Uml::IsDerivedFrom( struct_3952.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_3957= SFC::Struct::Cast( struct_3952);
		if( false== Uml::IsDerivedFrom( oldval_395b.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar oldval_3960= SFC::LocalVar::Cast( oldval_395b);
		if( false== Uml::IsDerivedFrom( context_3964.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_3969= SFC::Arg::Cast( context_3964);
		if( false== Uml::IsDerivedFrom( triggerVar_396d.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_3972= SFC::LocalVar::Cast( triggerVar_396d);
		if( false== Uml::IsDerivedFrom( function_3976.type(), SFC::Function::meta))
			continue;
		SFC::Function function_397b= SFC::Function::Cast( function_3976);
		set< CyberComposition::Simulink::Primitive> primitives_397d= chart_3945.Primitive_kind_children();
		for( set< CyberComposition::Simulink::Primitive>::const_iterator itPrimitive_397e= primitives_397d.begin(); itPrimitive_397e!= primitives_397d.end(); ++itPrimitive_397e)
		{
			CyberComposition::Simulink::Primitive currPrimitive_397f= *itPrimitive_397e;
			set< SFC::LocalVar> localVars_3980= struct_3957.LocalVar_kind_children();
			for( set< SFC::LocalVar>::const_iterator itLocalVar_3981= localVars_3980.begin(); itLocalVar_3981!= localVars_3980.end(); ++itLocalVar_3981)
			{
				SFC::LocalVar currLocalVar_3982= *itLocalVar_3981;
				set< CyberComposition::Simulink::State> states_3983= currPrimitive_397f.State_kind_children();
				for( set< CyberComposition::Simulink::State>::const_iterator itState_3984= states_3983.begin(); itState_3984!= states_3983.end(); ++itState_3984)
				{
					CyberComposition::Simulink::State currState_3985= *itState_3984;
					set< CyberComposition::Simulink::Event> events_3986= currState_3985.Event_kind_children();
					for( set< CyberComposition::Simulink::Event>::const_iterator itEvent_3987= events_3986.begin(); itEvent_3987!= events_3986.end(); ++itEvent_3987)
					{
						CyberComposition::Simulink::Event currEvent_3988= *itEvent_3987;
						Match currMatch;
						set< pair<int, Udm::Object> > boundObjs_398c;
						if( !isValidBound(boundObjs_398c, chart_3945, true))
							continue;
						currMatch.chart_398d= chart_3945;
						if( !isValidBound(boundObjs_398c, argDeclBase_394e, true))
							continue;
						currMatch.argDeclBase_398e= argDeclBase_394e;
						if( !isValidBound(boundObjs_398c, struct_3957, true))
							continue;
						currMatch.struct_398f= struct_3957;
						if( !isValidBound(boundObjs_398c, oldval_3960, true))
							continue;
						currMatch.oldval_3990= oldval_3960;
						if( !isValidBound(boundObjs_398c, context_3969, true))
							continue;
						currMatch.context_3991= context_3969;
						if( !isValidBound(boundObjs_398c, triggerVar_3972, true))
							continue;
						currMatch.triggerVar_3992= triggerVar_3972;
						if( !isValidBound(boundObjs_398c, function_397b, true))
							continue;
						currMatch.function_3993= function_397b;
						if( !isValidBound(boundObjs_398c, currState_3985, false))
							continue;
						currMatch.state_3994= currState_3985;
						if( !isValidBound(boundObjs_398c, currEvent_3988, false))
							continue;
						currMatch.event_3995= currEvent_3988;
						if( !isValidBound(boundObjs_398c, currPrimitive_397f, false))
							continue;
						currMatch.primitive_3996= currPrimitive_397f;
						if( !isValidBound(boundObjs_398c, currLocalVar_3982, false))
							continue;
						currMatch.localVar_3997= currLocalVar_3982;
						bool Gz_guard= isGuardTrue( currMatch.argDeclBase_398e, currMatch.chart_398d, currMatch.context_3991, currMatch.event_3995, currMatch.function_3993, currMatch.localVar_3997, currMatch.primitive_3996, currMatch.state_3994, currMatch.struct_398f, currMatch.triggerVar_3992, currMatch.oldval_3990);
						if( true== Gz_guard)
							_matches.push_back( currMatch);
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void StartAssignment_3923::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newAssignment_39a3= SFC::UserCode::Create( currMatch.function_3993, SFC::Function::meta_stmnt);
		SFC::BinaryExprs newAssign_39a4= SFC::BinaryExprs::Create( newAssignment_39a3, SFC::UserCode::meta_codeexpr);
		SFC::UnaryExprs newUnaryExprs_39a5= SFC::UnaryExprs::Create( newAssign_39a4, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newDot_39a6= SFC::BinaryExprs::Create( newAssign_39a4, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef_39a7= SFC::ArgDeclRef::Create( newDot_39a6, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_39a8= SFC::ArgDeclRef::Create( newDot_39a6, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_398e;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_39a7;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_39a8;
		SFC::BinaryExprs& Assign= newAssign_39a4;
		SFC::UserCode& Assignment= newAssignment_39a3;
		CyberComposition::Simulink::Subsystem& Chart= currMatch.chart_398d;
		SFC::Arg& Context= currMatch.context_3991;
		SFC::BinaryExprs& Dot= newDot_39a6;
		CyberComposition::Simulink::Event& Event= currMatch.event_3995;
		SFC::Function& Function= currMatch.function_3993;
		SFC::LocalVar& LocalVar= currMatch.localVar_3997;
		CyberComposition::Simulink::Primitive& Primitive= currMatch.primitive_3996;
		CyberComposition::Simulink::State& State= currMatch.state_3994;
		SFC::Struct& Struct= currMatch.struct_398f;
		SFC::LocalVar& TriggerVar= currMatch.triggerVar_3992;
		SFC::UnaryExprs& UnaryExprs= newUnaryExprs_39a5;
		SFC::LocalVar& oldval= currMatch.oldval_3990;
		{
__int64 statementCount = Function.statementCount();
Assignment.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		{
UnaryExprs.op() = "";
};
		{
Dot.op() = ".";
};
		{
Assign.op() = "=";
};
		newArgDeclRef_39a7.argdecl()= currMatch.triggerVar_3992;
		newArgDeclRef2_39a8.argdecl()= currMatch.localVar_3997;
		outputAppender( currMatch.event_3995, currMatch.argDeclBase_398e, currMatch.localVar_3997, currMatch.oldval_3990, currMatch.context_3991, newUnaryExprs_39a5);
	}
}

void StartAssignment_3923::outputAppender( const CyberComposition::Simulink::Event& event_39a9, const SFC::ArgDeclBase& argDeclBase_39ab, const SFC::LocalVar& localVar_39ad, const SFC::LocalVar& oldval_39af, const SFC::Arg& context_39b1, const SFC::UnaryExprs& unaryExprs_39b3)
{
	_event_3938->push_back( event_39a9);
	_argDeclBase_3939->push_back( argDeclBase_39ab);
	_localVar_393a->push_back( localVar_39ad);
	_oldval_393b->push_back( oldval_39af);
	_context_393c->push_back( context_39b1);
	_unaryExprs_393d->push_back( unaryExprs_39b3);
}

void AddTriggerVar_39b5::operator()( const Packets_t& charts_39b6, const Packets_t& argDeclBases_39b9, const Packets_t& structs_39bc, const Packets_t& localVars_39bf, const Packets_t& contexts_39c2, const Packets_t& functions_39c6, Packets_t& charts_39b8, Packets_t& argDeclBases_39bb, Packets_t& structs_39be, Packets_t& localVars_39c1, Packets_t& contexts_39c4, Packets_t& triggerVars_39c5, Packets_t& functions_39c8)
{
#ifdef PRINT_INFO
	printLog( "AddTriggerVar_39b5" );
#endif
	RTTGenerator::Instance()->generateRule(3433, "AddTriggerVar");
	_chart_39c9= &charts_39b8;
	_argDeclBase_39ca= &argDeclBases_39bb;
	_struct_39cb= &structs_39be;
	_localVar_39cc= &localVars_39c1;
	_context_39cd= &contexts_39c4;
	_triggerVar_39ce= &triggerVars_39c5;
	_function_39cf= &functions_39c8;
	processInputPackets( charts_39b6, argDeclBases_39b9, structs_39bc, localVars_39bf, contexts_39c2, functions_39c6);
}

bool AddTriggerVar_39b5::isInputUnique( const Udm::Object& chart_39d4, const Udm::Object& argDeclBase_39dd, const Udm::Object& struct_39e6, const Udm::Object& localVar_39ef, const Udm::Object& context_39f8, const Udm::Object& function_3a01)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itChart_39d6= _chart_39d0.begin(), itArgDeclBase_39df= _argDeclBase_39d9.begin(), itStruct_39e8= _struct_39e2.begin(), itLocalVar_39f1= _localVar_39eb.begin(), itContext_39fa= _context_39f4.begin(), itFunction_3a03= _function_39fd.begin(); itChart_39d6!= _chart_39d0.end(), itArgDeclBase_39df!= _argDeclBase_39d9.end(), itStruct_39e8!= _struct_39e2.end(), itLocalVar_39f1!= _localVar_39eb.end(), itContext_39fa!= _context_39f4.end(), itFunction_3a03!= _function_39fd.end(); ++itChart_39d6, ++itArgDeclBase_39df, ++itStruct_39e8, ++itLocalVar_39f1, ++itContext_39fa, ++itFunction_3a03)
	{
		if( ( *itChart_39d6== chart_39d4)&& ( *itArgDeclBase_39df== argDeclBase_39dd)&& ( *itStruct_39e8== struct_39e6)&& ( *itLocalVar_39f1== localVar_39ef)&& ( *itContext_39fa== context_39f8)&& ( *itFunction_3a03== function_3a01))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_chart_39d0.push_back( chart_39d4);
		_argDeclBase_39d9.push_back( argDeclBase_39dd);
		_struct_39e2.push_back( struct_39e6);
		_localVar_39eb.push_back( localVar_39ef);
		_context_39f4.push_back( context_39f8);
		_function_39fd.push_back( function_3a01);
	}
	return isUnique;
}

bool AddTriggerVar_39b5::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void AddTriggerVar_39b5::processInputPackets( const Packets_t& charts_39b6, const Packets_t& argDeclBases_39b9, const Packets_t& structs_39bc, const Packets_t& localVars_39bf, const Packets_t& contexts_39c2, const Packets_t& functions_39c6)
{
	for( Packets_t::const_iterator itChart_39d1= charts_39b6.begin(), itArgDeclBase_39da= argDeclBases_39b9.begin(), itStruct_39e3= structs_39bc.begin(), itLocalVar_39ec= localVars_39bf.begin(), itContext_39f5= contexts_39c2.begin(), itFunction_39fe= functions_39c6.begin(); itChart_39d1!= charts_39b6.end(), itArgDeclBase_39da!= argDeclBases_39b9.end(), itStruct_39e3!= structs_39bc.end(), itLocalVar_39ec!= localVars_39bf.end(), itContext_39f5!= contexts_39c2.end(), itFunction_39fe!= functions_39c6.end(); ++itChart_39d1, ++itArgDeclBase_39da, ++itStruct_39e3, ++itLocalVar_39ec, ++itContext_39f5, ++itFunction_39fe)
	{
		bool isUnique= isInputUnique( *itChart_39d1, *itArgDeclBase_39da, *itStruct_39e3, *itLocalVar_39ec, *itContext_39f5, *itFunction_39fe);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itChart_39d1, *itArgDeclBase_39da, *itStruct_39e3, *itLocalVar_39ec, *itContext_39f5, *itFunction_39fe);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AddTriggerVar_39b5::patternMatcher( const Udm::Object& chart_39d2, const Udm::Object& argDeclBase_39db, const Udm::Object& struct_39e4, const Udm::Object& localVar_39ed, const Udm::Object& context_39f6, const Udm::Object& function_39ff)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( chart_39d2.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem chart_39d7= CyberComposition::Simulink::Subsystem::Cast( chart_39d2);
		if( false== Uml::IsDerivedFrom( argDeclBase_39db.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_39e0= SFC::ArgDeclBase::Cast( argDeclBase_39db);
		if( false== Uml::IsDerivedFrom( struct_39e4.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_39e9= SFC::Struct::Cast( struct_39e4);
		if( false== Uml::IsDerivedFrom( localVar_39ed.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_39f2= SFC::LocalVar::Cast( localVar_39ed);
		if( false== Uml::IsDerivedFrom( context_39f6.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_39fb= SFC::Arg::Cast( context_39f6);
		if( false== Uml::IsDerivedFrom( function_39ff.type(), SFC::Function::meta))
			continue;
		SFC::Function function_3a04= SFC::Function::Cast( function_39ff);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3a09;
		if( !isValidBound(boundObjs_3a09, chart_39d7, true))
			continue;
		currMatch.chart_3a0a= chart_39d7;
		if( !isValidBound(boundObjs_3a09, argDeclBase_39e0, true))
			continue;
		currMatch.argDeclBase_3a0b= argDeclBase_39e0;
		if( !isValidBound(boundObjs_3a09, struct_39e9, true))
			continue;
		currMatch.struct_3a0c= struct_39e9;
		if( !isValidBound(boundObjs_3a09, localVar_39f2, true))
			continue;
		currMatch.localVar_3a0d= localVar_39f2;
		if( !isValidBound(boundObjs_3a09, context_39fb, true))
			continue;
		currMatch.context_3a0e= context_39fb;
		if( !isValidBound(boundObjs_3a09, function_3a04, true))
			continue;
		currMatch.function_3a0f= function_3a04;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void AddTriggerVar_39b5::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newTriggerVar_3a10= SFC::LocalVar::Create( currMatch.function_3a0f, SFC::Function::meta_stmnt);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_3a0b;
		CyberComposition::Simulink::Subsystem& Chart= currMatch.chart_3a0a;
		SFC::Arg& Context= currMatch.context_3a0e;
		SFC::Function& Function= currMatch.function_3a0f;
		SFC::LocalVar& LocalVar= currMatch.localVar_3a0d;
		SFC::Struct& Struct= currMatch.struct_3a0c;
		SFC::LocalVar& TriggerVar= newTriggerVar_3a10;
		{
__int64 statementCount = Function.statementCount();
TriggerVar.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		{
TriggerVar.type() = "int";
TriggerVar.name() = std::string( "event" ) + boost::lexical_cast< std::string >( TriggerVar.uniqueId() );
};
		currMatch.localVar_3a0d.trigvar()= newTriggerVar_3a10;
		newTriggerVar_3a10.dt()= currMatch.struct_3a0c;
		outputAppender( currMatch.chart_3a0a, currMatch.argDeclBase_3a0b, currMatch.struct_3a0c, currMatch.localVar_3a0d, currMatch.context_3a0e, newTriggerVar_3a10, currMatch.function_3a0f);
	}
}

void AddTriggerVar_39b5::outputAppender( const CyberComposition::Simulink::Subsystem& chart_3a11, const SFC::ArgDeclBase& argDeclBase_3a13, const SFC::Struct& struct_3a15, const SFC::LocalVar& localVar_3a17, const SFC::Arg& context_3a19, const SFC::LocalVar& triggerVar_3a1b, const SFC::Function& function_3a1d)
{
	_chart_39c9->push_back( chart_3a11);
	_argDeclBase_39ca->push_back( argDeclBase_3a13);
	_struct_39cb->push_back( struct_3a15);
	_localVar_39cc->push_back( localVar_3a17);
	_context_39cd->push_back( context_3a19);
	_triggerVar_39ce->push_back( triggerVar_3a1b);
	_function_39cf->push_back( function_3a1d);
}

void EdgeTest_3a1f::operator()( const Packets_t& events_3a20, const Packets_t& argdecls_3a22, const Packets_t& members_3a24, const Packets_t& oldvals_3a26, const Packets_t& contexts_3a28, const Packets_t& initexprs_3a2a, Packets_t& argdecls_3a2c, Packets_t& members_3a2d, Packets_t& oldvals_3a2e, Packets_t& contexts_3a2f, Packets_t& initexprs_3a30, Packets_t& argdecls_3a31, Packets_t& members_3a32, Packets_t& oldvals_3a33, Packets_t& contexts_3a34, Packets_t& initexprs_3a35, Packets_t& argdecls_3a36, Packets_t& members_3a37, Packets_t& oldvals_3a38, Packets_t& contexts_3a39, Packets_t& initexprs_3a3a)
{
#ifdef PRINT_INFO
	printLog( "EdgeTest_3a1f" );
#endif
	_argdecl_3a3b= &argdecls_3a2c;
	_member_3a3c= &members_3a2d;
	_oldval_3a3d= &oldvals_3a2e;
	_context_3a3e= &contexts_3a2f;
	_initexpr_3a3f= &initexprs_3a30;
	_argdecl_3a40= &argdecls_3a31;
	_member_3a41= &members_3a32;
	_oldval_3a42= &oldvals_3a33;
	_context_3a43= &contexts_3a34;
	_initexpr_3a44= &initexprs_3a35;
	_argdecl_3a45= &argdecls_3a36;
	_member_3a46= &members_3a37;
	_oldval_3a47= &oldvals_3a38;
	_context_3a48= &contexts_3a39;
	_initexpr_3a49= &initexprs_3a3a;
	for( Packets_t::const_iterator itevent_3a4b= events_3a20.begin(), itargdecl_3a52= argdecls_3a22.begin(), itmember_3a59= members_3a24.begin(), itoldval_3a60= oldvals_3a26.begin(), itcontext_3a67= contexts_3a28.begin(), itinitexpr_3a6e= initexprs_3a2a.begin(); itevent_3a4b!= events_3a20.end(), itargdecl_3a52!= argdecls_3a22.end(), itmember_3a59!= members_3a24.end(), itoldval_3a60!= oldvals_3a26.end(), itcontext_3a67!= contexts_3a28.end(), itinitexpr_3a6e!= initexprs_3a2a.end(); ++itevent_3a4b, ++itargdecl_3a52, ++itmember_3a59, ++itoldval_3a60, ++itcontext_3a67, ++itinitexpr_3a6e)
	{
		bool isUnique= isInputUnique( *itevent_3a4b, *itargdecl_3a52, *itmember_3a59, *itoldval_3a60, *itcontext_3a67, *itinitexpr_3a6e);
		if( !isUnique)
			continue;
		Packets_t oneevent_3a4f( 1, *itevent_3a4b);
		Packets_t oneargdecl_3a56( 1, *itargdecl_3a52);
		Packets_t onemember_3a5d( 1, *itmember_3a59);
		Packets_t oneoldval_3a64( 1, *itoldval_3a60);
		Packets_t onecontext_3a6b( 1, *itcontext_3a67);
		Packets_t oneinitexpr_3a72( 1, *itinitexpr_3a6e);
		executeOne( oneevent_3a4f, oneargdecl_3a56, onemember_3a5d, oneoldval_3a64, onecontext_3a6b, oneinitexpr_3a72);
	}
}

void EdgeTest_3a1f::executeOne( const Packets_t& events_3a20, const Packets_t& argdecls_3a22, const Packets_t& members_3a24, const Packets_t& oldvals_3a26, const Packets_t& contexts_3a28, const Packets_t& initexprs_3a2a)
{
	Packets_t argDeclBases_3a79;
	Packets_t members_3a7c;
	Packets_t localVars_3a7f;
	Packets_t contexts_3a82;
	Packets_t unaryExprss_3a85;
	RisingEdge_3a74 risingEdge_3a74;
	bool isMatchRisingEdge_3a74= risingEdge_3a74( events_3a20, argdecls_3a22, members_3a24, oldvals_3a26, contexts_3a28, initexprs_3a2a, argDeclBases_3a79, members_3a7c, localVars_3a7f, contexts_3a82, unaryExprss_3a85);
	_argdecl_3a3b->insert( _argdecl_3a3b->end(), argDeclBases_3a79.begin(), argDeclBases_3a79.end());
	_member_3a3c->insert( _member_3a3c->end(), members_3a7c.begin(), members_3a7c.end());
	_oldval_3a3d->insert( _oldval_3a3d->end(), localVars_3a7f.begin(), localVars_3a7f.end());
	_context_3a3e->insert( _context_3a3e->end(), contexts_3a82.begin(), contexts_3a82.end());
	_initexpr_3a3f->insert( _initexpr_3a3f->end(), unaryExprss_3a85.begin(), unaryExprss_3a85.end());
	if( isMatchRisingEdge_3a74)
		return;
	Packets_t argDeclBases_3ae0;
	Packets_t members_3ae3;
	Packets_t localVars_3ae6;
	Packets_t contexts_3ae9;
	Packets_t unaryExprss_3aec;
	FallingEdge_3adb fallingEdge_3adb;
	bool isMatchFallingEdge_3adb= fallingEdge_3adb( events_3a20, argdecls_3a22, members_3a24, oldvals_3a26, contexts_3a28, initexprs_3a2a, argDeclBases_3ae0, members_3ae3, localVars_3ae6, contexts_3ae9, unaryExprss_3aec);
	_argdecl_3a40->insert( _argdecl_3a40->end(), argDeclBases_3ae0.begin(), argDeclBases_3ae0.end());
	_member_3a41->insert( _member_3a41->end(), members_3ae3.begin(), members_3ae3.end());
	_oldval_3a42->insert( _oldval_3a42->end(), localVars_3ae6.begin(), localVars_3ae6.end());
	_context_3a43->insert( _context_3a43->end(), contexts_3ae9.begin(), contexts_3ae9.end());
	_initexpr_3a44->insert( _initexpr_3a44->end(), unaryExprss_3aec.begin(), unaryExprss_3aec.end());
	Packets_t argDeclBases_3b47;
	Packets_t members_3b4a;
	Packets_t localVars_3b4d;
	Packets_t contexts_3b50;
	Packets_t unaryExprss_3b53;
	EitherEdge_3b42 eitherEdge_3b42;
	bool isMatchEitherEdge_3b42= eitherEdge_3b42( events_3a20, argdecls_3a22, members_3a24, oldvals_3a26, contexts_3a28, initexprs_3a2a, argDeclBases_3b47, members_3b4a, localVars_3b4d, contexts_3b50, unaryExprss_3b53);
	_argdecl_3a45->insert( _argdecl_3a45->end(), argDeclBases_3b47.begin(), argDeclBases_3b47.end());
	_member_3a46->insert( _member_3a46->end(), members_3b4a.begin(), members_3b4a.end());
	_oldval_3a47->insert( _oldval_3a47->end(), localVars_3b4d.begin(), localVars_3b4d.end());
	_context_3a48->insert( _context_3a48->end(), contexts_3b50.begin(), contexts_3b50.end());
	_initexpr_3a49->insert( _initexpr_3a49->end(), unaryExprss_3b53.begin(), unaryExprss_3b53.end());
}

bool EdgeTest_3a1f::isInputUnique( const Udm::Object& event_3a4c, const Udm::Object& argdecl_3a53, const Udm::Object& member_3a5a, const Udm::Object& oldval_3a61, const Udm::Object& context_3a68, const Udm::Object& initexpr_3a6f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itevent_3a4e= _event_3a4a.begin(), itargdecl_3a55= _argdecl_3a51.begin(), itmember_3a5c= _member_3a58.begin(), itoldval_3a63= _oldval_3a5f.begin(), itcontext_3a6a= _context_3a66.begin(), itinitexpr_3a71= _initexpr_3a6d.begin(); itevent_3a4e!= _event_3a4a.end(), itargdecl_3a55!= _argdecl_3a51.end(), itmember_3a5c!= _member_3a58.end(), itoldval_3a63!= _oldval_3a5f.end(), itcontext_3a6a!= _context_3a66.end(), itinitexpr_3a71!= _initexpr_3a6d.end(); ++itevent_3a4e, ++itargdecl_3a55, ++itmember_3a5c, ++itoldval_3a63, ++itcontext_3a6a, ++itinitexpr_3a71)
	{
		if( ( *itevent_3a4e== event_3a4c)&& ( *itargdecl_3a55== argdecl_3a53)&& ( *itmember_3a5c== member_3a5a)&& ( *itoldval_3a63== oldval_3a61)&& ( *itcontext_3a6a== context_3a68)&& ( *itinitexpr_3a71== initexpr_3a6f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_event_3a4a.push_back( event_3a4c);
		_argdecl_3a51.push_back( argdecl_3a53);
		_member_3a58.push_back( member_3a5a);
		_oldval_3a5f.push_back( oldval_3a61);
		_context_3a66.push_back( context_3a68);
		_initexpr_3a6d.push_back( initexpr_3a6f);
	}
	return isUnique;
}

bool RisingEdge_3a74::operator()( const Packets_t& events_3a75, const Packets_t& argDeclBases_3a77, const Packets_t& members_3a7a, const Packets_t& localVars_3a7d, const Packets_t& contexts_3a80, const Packets_t& unaryExprss_3a83, Packets_t& argDeclBases_3a79, Packets_t& members_3a7c, Packets_t& localVars_3a7f, Packets_t& contexts_3a82, Packets_t& unaryExprss_3a85)
{
#ifdef PRINT_INFO
	printLog( "RisingEdge_3a74" );
#endif
	_argDeclBase_3a86= &argDeclBases_3a79;
	_member_3a87= &members_3a7c;
	_localVar_3a88= &localVars_3a7f;
	_context_3a89= &contexts_3a82;
	_unaryExprs_3a8a= &unaryExprss_3a85;
	processInputPackets( events_3a75, argDeclBases_3a77, members_3a7a, localVars_3a7d, contexts_3a80, unaryExprss_3a83);
	if( false== _matches.empty())
		return true;
	return false;
}

bool RisingEdge_3a74::isInputUnique( const Udm::Object& event_3a8f, const Udm::Object& argDeclBase_3a98, const Udm::Object& member_3aa1, const Udm::Object& localVar_3aaa, const Udm::Object& context_3ab3, const Udm::Object& unaryExprs_3abc)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itEvent_3a91= _event_3a8b.begin(), itArgDeclBase_3a9a= _argDeclBase_3a94.begin(), itMember_3aa3= _member_3a9d.begin(), itLocalVar_3aac= _localVar_3aa6.begin(), itContext_3ab5= _context_3aaf.begin(), itUnaryExprs_3abe= _unaryExprs_3ab8.begin(); itEvent_3a91!= _event_3a8b.end(), itArgDeclBase_3a9a!= _argDeclBase_3a94.end(), itMember_3aa3!= _member_3a9d.end(), itLocalVar_3aac!= _localVar_3aa6.end(), itContext_3ab5!= _context_3aaf.end(), itUnaryExprs_3abe!= _unaryExprs_3ab8.end(); ++itEvent_3a91, ++itArgDeclBase_3a9a, ++itMember_3aa3, ++itLocalVar_3aac, ++itContext_3ab5, ++itUnaryExprs_3abe)
	{
		if( ( *itEvent_3a91== event_3a8f)&& ( *itArgDeclBase_3a9a== argDeclBase_3a98)&& ( *itMember_3aa3== member_3aa1)&& ( *itLocalVar_3aac== localVar_3aaa)&& ( *itContext_3ab5== context_3ab3)&& ( *itUnaryExprs_3abe== unaryExprs_3abc))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_event_3a8b.push_back( event_3a8f);
		_argDeclBase_3a94.push_back( argDeclBase_3a98);
		_member_3a9d.push_back( member_3aa1);
		_localVar_3aa6.push_back( localVar_3aaa);
		_context_3aaf.push_back( context_3ab3);
		_unaryExprs_3ab8.push_back( unaryExprs_3abc);
	}
	return isUnique;
}

bool RisingEdge_3a74::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool RisingEdge_3a74::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, SFC::Arg& Context, CyberComposition::Simulink::Event& Event, SFC::LocalVar& LocalVar, SFC::LocalVar& Member, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	std::string trigger = Event.Trigger();
Gz_guard = trigger == "RISING_EDGE_EVENT";;
	return Gz_guard;
}

void RisingEdge_3a74::processInputPackets( const Packets_t& events_3a75, const Packets_t& argDeclBases_3a77, const Packets_t& members_3a7a, const Packets_t& localVars_3a7d, const Packets_t& contexts_3a80, const Packets_t& unaryExprss_3a83)
{
	for( Packets_t::const_iterator itEvent_3a8c= events_3a75.begin(), itArgDeclBase_3a95= argDeclBases_3a77.begin(), itMember_3a9e= members_3a7a.begin(), itLocalVar_3aa7= localVars_3a7d.begin(), itContext_3ab0= contexts_3a80.begin(), itUnaryExprs_3ab9= unaryExprss_3a83.begin(); itEvent_3a8c!= events_3a75.end(), itArgDeclBase_3a95!= argDeclBases_3a77.end(), itMember_3a9e!= members_3a7a.end(), itLocalVar_3aa7!= localVars_3a7d.end(), itContext_3ab0!= contexts_3a80.end(), itUnaryExprs_3ab9!= unaryExprss_3a83.end(); ++itEvent_3a8c, ++itArgDeclBase_3a95, ++itMember_3a9e, ++itLocalVar_3aa7, ++itContext_3ab0, ++itUnaryExprs_3ab9)
	{
		bool isUnique= isInputUnique( *itEvent_3a8c, *itArgDeclBase_3a95, *itMember_3a9e, *itLocalVar_3aa7, *itContext_3ab0, *itUnaryExprs_3ab9);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itEvent_3a8c, *itArgDeclBase_3a95, *itMember_3a9e, *itLocalVar_3aa7, *itContext_3ab0, *itUnaryExprs_3ab9);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_3ac6, currMatch.member_3ac7, currMatch.localVar_3ac8, currMatch.context_3ac9, currMatch.unaryExprs_3aca);
	}
}

bool RisingEdge_3a74::patternMatcher( const Udm::Object& event_3a8d, const Udm::Object& argDeclBase_3a96, const Udm::Object& member_3a9f, const Udm::Object& localVar_3aa8, const Udm::Object& context_3ab1, const Udm::Object& unaryExprs_3aba)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( event_3a8d.type(), CyberComposition::Simulink::Event::meta))
			continue;
		CyberComposition::Simulink::Event event_3a92= CyberComposition::Simulink::Event::Cast( event_3a8d);
		if( false== Uml::IsDerivedFrom( argDeclBase_3a96.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_3a9b= SFC::ArgDeclBase::Cast( argDeclBase_3a96);
		if( false== Uml::IsDerivedFrom( member_3a9f.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_3aa4= SFC::LocalVar::Cast( member_3a9f);
		if( false== Uml::IsDerivedFrom( localVar_3aa8.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_3aad= SFC::LocalVar::Cast( localVar_3aa8);
		if( false== Uml::IsDerivedFrom( context_3ab1.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_3ab6= SFC::Arg::Cast( context_3ab1);
		if( false== Uml::IsDerivedFrom( unaryExprs_3aba.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_3abf= SFC::UnaryExprs::Cast( unaryExprs_3aba);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3ac4;
		if( !isValidBound(boundObjs_3ac4, event_3a92, true))
			continue;
		currMatch.event_3ac5= event_3a92;
		if( !isValidBound(boundObjs_3ac4, argDeclBase_3a9b, true))
			continue;
		currMatch.argDeclBase_3ac6= argDeclBase_3a9b;
		if( !isValidBound(boundObjs_3ac4, member_3aa4, true))
			continue;
		currMatch.member_3ac7= member_3aa4;
		if( !isValidBound(boundObjs_3ac4, localVar_3aad, true))
			continue;
		currMatch.localVar_3ac8= localVar_3aad;
		if( !isValidBound(boundObjs_3ac4, context_3ab6, true))
			continue;
		currMatch.context_3ac9= context_3ab6;
		if( !isValidBound(boundObjs_3ac4, unaryExprs_3abf, true))
			continue;
		currMatch.unaryExprs_3aca= unaryExprs_3abf;
		bool Gz_guard= isGuardTrue( currMatch.argDeclBase_3ac6, currMatch.context_3ac9, currMatch.event_3ac5, currMatch.localVar_3ac8, currMatch.member_3ac7, currMatch.unaryExprs_3aca);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void RisingEdge_3a74::outputAppender( const SFC::ArgDeclBase& argDeclBase_3ad1, const SFC::LocalVar& member_3ad3, const SFC::LocalVar& localVar_3ad5, const SFC::Arg& context_3ad7, const SFC::UnaryExprs& unaryExprs_3ad9)
{
	_argDeclBase_3a86->push_back( argDeclBase_3ad1);
	_member_3a87->push_back( member_3ad3);
	_localVar_3a88->push_back( localVar_3ad5);
	_context_3a89->push_back( context_3ad7);
	_unaryExprs_3a8a->push_back( unaryExprs_3ad9);
}

bool FallingEdge_3adb::operator()( const Packets_t& events_3adc, const Packets_t& argDeclBases_3ade, const Packets_t& members_3ae1, const Packets_t& localVars_3ae4, const Packets_t& contexts_3ae7, const Packets_t& unaryExprss_3aea, Packets_t& argDeclBases_3ae0, Packets_t& members_3ae3, Packets_t& localVars_3ae6, Packets_t& contexts_3ae9, Packets_t& unaryExprss_3aec)
{
#ifdef PRINT_INFO
	printLog( "FallingEdge_3adb" );
#endif
	_argDeclBase_3aed= &argDeclBases_3ae0;
	_member_3aee= &members_3ae3;
	_localVar_3aef= &localVars_3ae6;
	_context_3af0= &contexts_3ae9;
	_unaryExprs_3af1= &unaryExprss_3aec;
	processInputPackets( events_3adc, argDeclBases_3ade, members_3ae1, localVars_3ae4, contexts_3ae7, unaryExprss_3aea);
	if( false== _matches.empty())
		return true;
	return false;
}

bool FallingEdge_3adb::isInputUnique( const Udm::Object& event_3af6, const Udm::Object& argDeclBase_3aff, const Udm::Object& member_3b08, const Udm::Object& localVar_3b11, const Udm::Object& context_3b1a, const Udm::Object& unaryExprs_3b23)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itEvent_3af8= _event_3af2.begin(), itArgDeclBase_3b01= _argDeclBase_3afb.begin(), itMember_3b0a= _member_3b04.begin(), itLocalVar_3b13= _localVar_3b0d.begin(), itContext_3b1c= _context_3b16.begin(), itUnaryExprs_3b25= _unaryExprs_3b1f.begin(); itEvent_3af8!= _event_3af2.end(), itArgDeclBase_3b01!= _argDeclBase_3afb.end(), itMember_3b0a!= _member_3b04.end(), itLocalVar_3b13!= _localVar_3b0d.end(), itContext_3b1c!= _context_3b16.end(), itUnaryExprs_3b25!= _unaryExprs_3b1f.end(); ++itEvent_3af8, ++itArgDeclBase_3b01, ++itMember_3b0a, ++itLocalVar_3b13, ++itContext_3b1c, ++itUnaryExprs_3b25)
	{
		if( ( *itEvent_3af8== event_3af6)&& ( *itArgDeclBase_3b01== argDeclBase_3aff)&& ( *itMember_3b0a== member_3b08)&& ( *itLocalVar_3b13== localVar_3b11)&& ( *itContext_3b1c== context_3b1a)&& ( *itUnaryExprs_3b25== unaryExprs_3b23))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_event_3af2.push_back( event_3af6);
		_argDeclBase_3afb.push_back( argDeclBase_3aff);
		_member_3b04.push_back( member_3b08);
		_localVar_3b0d.push_back( localVar_3b11);
		_context_3b16.push_back( context_3b1a);
		_unaryExprs_3b1f.push_back( unaryExprs_3b23);
	}
	return isUnique;
}

bool FallingEdge_3adb::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool FallingEdge_3adb::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, SFC::Arg& Context, CyberComposition::Simulink::Event& Event, SFC::LocalVar& LocalVar, SFC::LocalVar& Member, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	std::string trigger = Event.Trigger();
Gz_guard = trigger == "FALLING_EDGE_EVENT";;
	return Gz_guard;
}

void FallingEdge_3adb::processInputPackets( const Packets_t& events_3adc, const Packets_t& argDeclBases_3ade, const Packets_t& members_3ae1, const Packets_t& localVars_3ae4, const Packets_t& contexts_3ae7, const Packets_t& unaryExprss_3aea)
{
	for( Packets_t::const_iterator itEvent_3af3= events_3adc.begin(), itArgDeclBase_3afc= argDeclBases_3ade.begin(), itMember_3b05= members_3ae1.begin(), itLocalVar_3b0e= localVars_3ae4.begin(), itContext_3b17= contexts_3ae7.begin(), itUnaryExprs_3b20= unaryExprss_3aea.begin(); itEvent_3af3!= events_3adc.end(), itArgDeclBase_3afc!= argDeclBases_3ade.end(), itMember_3b05!= members_3ae1.end(), itLocalVar_3b0e!= localVars_3ae4.end(), itContext_3b17!= contexts_3ae7.end(), itUnaryExprs_3b20!= unaryExprss_3aea.end(); ++itEvent_3af3, ++itArgDeclBase_3afc, ++itMember_3b05, ++itLocalVar_3b0e, ++itContext_3b17, ++itUnaryExprs_3b20)
	{
		bool isUnique= isInputUnique( *itEvent_3af3, *itArgDeclBase_3afc, *itMember_3b05, *itLocalVar_3b0e, *itContext_3b17, *itUnaryExprs_3b20);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itEvent_3af3, *itArgDeclBase_3afc, *itMember_3b05, *itLocalVar_3b0e, *itContext_3b17, *itUnaryExprs_3b20);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_3b2d, currMatch.member_3b2e, currMatch.localVar_3b2f, currMatch.context_3b30, currMatch.unaryExprs_3b31);
	}
}

bool FallingEdge_3adb::patternMatcher( const Udm::Object& event_3af4, const Udm::Object& argDeclBase_3afd, const Udm::Object& member_3b06, const Udm::Object& localVar_3b0f, const Udm::Object& context_3b18, const Udm::Object& unaryExprs_3b21)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( event_3af4.type(), CyberComposition::Simulink::Event::meta))
			continue;
		CyberComposition::Simulink::Event event_3af9= CyberComposition::Simulink::Event::Cast( event_3af4);
		if( false== Uml::IsDerivedFrom( argDeclBase_3afd.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_3b02= SFC::ArgDeclBase::Cast( argDeclBase_3afd);
		if( false== Uml::IsDerivedFrom( member_3b06.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_3b0b= SFC::LocalVar::Cast( member_3b06);
		if( false== Uml::IsDerivedFrom( localVar_3b0f.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_3b14= SFC::LocalVar::Cast( localVar_3b0f);
		if( false== Uml::IsDerivedFrom( context_3b18.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_3b1d= SFC::Arg::Cast( context_3b18);
		if( false== Uml::IsDerivedFrom( unaryExprs_3b21.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_3b26= SFC::UnaryExprs::Cast( unaryExprs_3b21);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3b2b;
		if( !isValidBound(boundObjs_3b2b, event_3af9, true))
			continue;
		currMatch.event_3b2c= event_3af9;
		if( !isValidBound(boundObjs_3b2b, argDeclBase_3b02, true))
			continue;
		currMatch.argDeclBase_3b2d= argDeclBase_3b02;
		if( !isValidBound(boundObjs_3b2b, member_3b0b, true))
			continue;
		currMatch.member_3b2e= member_3b0b;
		if( !isValidBound(boundObjs_3b2b, localVar_3b14, true))
			continue;
		currMatch.localVar_3b2f= localVar_3b14;
		if( !isValidBound(boundObjs_3b2b, context_3b1d, true))
			continue;
		currMatch.context_3b30= context_3b1d;
		if( !isValidBound(boundObjs_3b2b, unaryExprs_3b26, true))
			continue;
		currMatch.unaryExprs_3b31= unaryExprs_3b26;
		bool Gz_guard= isGuardTrue( currMatch.argDeclBase_3b2d, currMatch.context_3b30, currMatch.event_3b2c, currMatch.localVar_3b2f, currMatch.member_3b2e, currMatch.unaryExprs_3b31);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void FallingEdge_3adb::outputAppender( const SFC::ArgDeclBase& argDeclBase_3b38, const SFC::LocalVar& member_3b3a, const SFC::LocalVar& localVar_3b3c, const SFC::Arg& context_3b3e, const SFC::UnaryExprs& unaryExprs_3b40)
{
	_argDeclBase_3aed->push_back( argDeclBase_3b38);
	_member_3aee->push_back( member_3b3a);
	_localVar_3aef->push_back( localVar_3b3c);
	_context_3af0->push_back( context_3b3e);
	_unaryExprs_3af1->push_back( unaryExprs_3b40);
}

bool EitherEdge_3b42::operator()( const Packets_t& events_3b43, const Packets_t& argDeclBases_3b45, const Packets_t& members_3b48, const Packets_t& localVars_3b4b, const Packets_t& contexts_3b4e, const Packets_t& unaryExprss_3b51, Packets_t& argDeclBases_3b47, Packets_t& members_3b4a, Packets_t& localVars_3b4d, Packets_t& contexts_3b50, Packets_t& unaryExprss_3b53)
{
#ifdef PRINT_INFO
	printLog( "EitherEdge_3b42" );
#endif
	_argDeclBase_3b54= &argDeclBases_3b47;
	_member_3b55= &members_3b4a;
	_localVar_3b56= &localVars_3b4d;
	_context_3b57= &contexts_3b50;
	_unaryExprs_3b58= &unaryExprss_3b53;
	processInputPackets( events_3b43, argDeclBases_3b45, members_3b48, localVars_3b4b, contexts_3b4e, unaryExprss_3b51);
	if( false== _matches.empty())
		return true;
	return false;
}

bool EitherEdge_3b42::isInputUnique( const Udm::Object& event_3b5d, const Udm::Object& argDeclBase_3b66, const Udm::Object& member_3b6f, const Udm::Object& localVar_3b78, const Udm::Object& context_3b81, const Udm::Object& unaryExprs_3b8a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itEvent_3b5f= _event_3b59.begin(), itArgDeclBase_3b68= _argDeclBase_3b62.begin(), itMember_3b71= _member_3b6b.begin(), itLocalVar_3b7a= _localVar_3b74.begin(), itContext_3b83= _context_3b7d.begin(), itUnaryExprs_3b8c= _unaryExprs_3b86.begin(); itEvent_3b5f!= _event_3b59.end(), itArgDeclBase_3b68!= _argDeclBase_3b62.end(), itMember_3b71!= _member_3b6b.end(), itLocalVar_3b7a!= _localVar_3b74.end(), itContext_3b83!= _context_3b7d.end(), itUnaryExprs_3b8c!= _unaryExprs_3b86.end(); ++itEvent_3b5f, ++itArgDeclBase_3b68, ++itMember_3b71, ++itLocalVar_3b7a, ++itContext_3b83, ++itUnaryExprs_3b8c)
	{
		if( ( *itEvent_3b5f== event_3b5d)&& ( *itArgDeclBase_3b68== argDeclBase_3b66)&& ( *itMember_3b71== member_3b6f)&& ( *itLocalVar_3b7a== localVar_3b78)&& ( *itContext_3b83== context_3b81)&& ( *itUnaryExprs_3b8c== unaryExprs_3b8a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_event_3b59.push_back( event_3b5d);
		_argDeclBase_3b62.push_back( argDeclBase_3b66);
		_member_3b6b.push_back( member_3b6f);
		_localVar_3b74.push_back( localVar_3b78);
		_context_3b7d.push_back( context_3b81);
		_unaryExprs_3b86.push_back( unaryExprs_3b8a);
	}
	return isUnique;
}

bool EitherEdge_3b42::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool EitherEdge_3b42::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, SFC::Arg& Context, CyberComposition::Simulink::Event& Event, SFC::LocalVar& LocalVar, SFC::LocalVar& Member, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	std::string trigger = Event.Trigger();
Gz_guard = trigger == "EITHER_EDGE_EVENT";;
	return Gz_guard;
}

void EitherEdge_3b42::processInputPackets( const Packets_t& events_3b43, const Packets_t& argDeclBases_3b45, const Packets_t& members_3b48, const Packets_t& localVars_3b4b, const Packets_t& contexts_3b4e, const Packets_t& unaryExprss_3b51)
{
	for( Packets_t::const_iterator itEvent_3b5a= events_3b43.begin(), itArgDeclBase_3b63= argDeclBases_3b45.begin(), itMember_3b6c= members_3b48.begin(), itLocalVar_3b75= localVars_3b4b.begin(), itContext_3b7e= contexts_3b4e.begin(), itUnaryExprs_3b87= unaryExprss_3b51.begin(); itEvent_3b5a!= events_3b43.end(), itArgDeclBase_3b63!= argDeclBases_3b45.end(), itMember_3b6c!= members_3b48.end(), itLocalVar_3b75!= localVars_3b4b.end(), itContext_3b7e!= contexts_3b4e.end(), itUnaryExprs_3b87!= unaryExprss_3b51.end(); ++itEvent_3b5a, ++itArgDeclBase_3b63, ++itMember_3b6c, ++itLocalVar_3b75, ++itContext_3b7e, ++itUnaryExprs_3b87)
	{
		bool isUnique= isInputUnique( *itEvent_3b5a, *itArgDeclBase_3b63, *itMember_3b6c, *itLocalVar_3b75, *itContext_3b7e, *itUnaryExprs_3b87);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itEvent_3b5a, *itArgDeclBase_3b63, *itMember_3b6c, *itLocalVar_3b75, *itContext_3b7e, *itUnaryExprs_3b87);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_3b94, currMatch.member_3b95, currMatch.localVar_3b96, currMatch.context_3b97, currMatch.unaryExprs_3b98);
	}
}

bool EitherEdge_3b42::patternMatcher( const Udm::Object& event_3b5b, const Udm::Object& argDeclBase_3b64, const Udm::Object& member_3b6d, const Udm::Object& localVar_3b76, const Udm::Object& context_3b7f, const Udm::Object& unaryExprs_3b88)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( event_3b5b.type(), CyberComposition::Simulink::Event::meta))
			continue;
		CyberComposition::Simulink::Event event_3b60= CyberComposition::Simulink::Event::Cast( event_3b5b);
		if( false== Uml::IsDerivedFrom( argDeclBase_3b64.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_3b69= SFC::ArgDeclBase::Cast( argDeclBase_3b64);
		if( false== Uml::IsDerivedFrom( member_3b6d.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_3b72= SFC::LocalVar::Cast( member_3b6d);
		if( false== Uml::IsDerivedFrom( localVar_3b76.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_3b7b= SFC::LocalVar::Cast( localVar_3b76);
		if( false== Uml::IsDerivedFrom( context_3b7f.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_3b84= SFC::Arg::Cast( context_3b7f);
		if( false== Uml::IsDerivedFrom( unaryExprs_3b88.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_3b8d= SFC::UnaryExprs::Cast( unaryExprs_3b88);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3b92;
		if( !isValidBound(boundObjs_3b92, event_3b60, true))
			continue;
		currMatch.event_3b93= event_3b60;
		if( !isValidBound(boundObjs_3b92, argDeclBase_3b69, true))
			continue;
		currMatch.argDeclBase_3b94= argDeclBase_3b69;
		if( !isValidBound(boundObjs_3b92, member_3b72, true))
			continue;
		currMatch.member_3b95= member_3b72;
		if( !isValidBound(boundObjs_3b92, localVar_3b7b, true))
			continue;
		currMatch.localVar_3b96= localVar_3b7b;
		if( !isValidBound(boundObjs_3b92, context_3b84, true))
			continue;
		currMatch.context_3b97= context_3b84;
		if( !isValidBound(boundObjs_3b92, unaryExprs_3b8d, true))
			continue;
		currMatch.unaryExprs_3b98= unaryExprs_3b8d;
		bool Gz_guard= isGuardTrue( currMatch.argDeclBase_3b94, currMatch.context_3b97, currMatch.event_3b93, currMatch.localVar_3b96, currMatch.member_3b95, currMatch.unaryExprs_3b98);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void EitherEdge_3b42::outputAppender( const SFC::ArgDeclBase& argDeclBase_3b9f, const SFC::LocalVar& member_3ba1, const SFC::LocalVar& localVar_3ba3, const SFC::Arg& context_3ba5, const SFC::UnaryExprs& unaryExprs_3ba7)
{
	_argDeclBase_3b54->push_back( argDeclBase_3b9f);
	_member_3b55->push_back( member_3ba1);
	_localVar_3b56->push_back( localVar_3ba3);
	_context_3b57->push_back( context_3ba5);
	_unaryExprs_3b58->push_back( unaryExprs_3ba7);
}

void RisingEdge_3ba9::operator()( const Packets_t& argDeclBases_3baa, const Packets_t& members_3bac, const Packets_t& localVars_3bae, const Packets_t& contexts_3bb0, const Packets_t& unaryExprss_3bb2)
{
#ifdef PRINT_INFO
	printLog( "RisingEdge_3ba9" );
#endif
	RTTGenerator::Instance()->generateRule(3489, "RisingEdge");
	processInputPackets( argDeclBases_3baa, members_3bac, localVars_3bae, contexts_3bb0, unaryExprss_3bb2);
}

bool RisingEdge_3ba9::isInputUnique( const Udm::Object& argDeclBase_3bb8, const Udm::Object& member_3bc1, const Udm::Object& localVar_3bca, const Udm::Object& context_3bd3, const Udm::Object& unaryExprs_3bdc)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_3bba= _argDeclBase_3bb4.begin(), itMember_3bc3= _member_3bbd.begin(), itLocalVar_3bcc= _localVar_3bc6.begin(), itContext_3bd5= _context_3bcf.begin(), itUnaryExprs_3bde= _unaryExprs_3bd8.begin(); itArgDeclBase_3bba!= _argDeclBase_3bb4.end(), itMember_3bc3!= _member_3bbd.end(), itLocalVar_3bcc!= _localVar_3bc6.end(), itContext_3bd5!= _context_3bcf.end(), itUnaryExprs_3bde!= _unaryExprs_3bd8.end(); ++itArgDeclBase_3bba, ++itMember_3bc3, ++itLocalVar_3bcc, ++itContext_3bd5, ++itUnaryExprs_3bde)
	{
		if( ( *itArgDeclBase_3bba== argDeclBase_3bb8)&& ( *itMember_3bc3== member_3bc1)&& ( *itLocalVar_3bcc== localVar_3bca)&& ( *itContext_3bd5== context_3bd3)&& ( *itUnaryExprs_3bde== unaryExprs_3bdc))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_3bb4.push_back( argDeclBase_3bb8);
		_member_3bbd.push_back( member_3bc1);
		_localVar_3bc6.push_back( localVar_3bca);
		_context_3bcf.push_back( context_3bd3);
		_unaryExprs_3bd8.push_back( unaryExprs_3bdc);
	}
	return isUnique;
}

bool RisingEdge_3ba9::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void RisingEdge_3ba9::processInputPackets( const Packets_t& argDeclBases_3baa, const Packets_t& members_3bac, const Packets_t& localVars_3bae, const Packets_t& contexts_3bb0, const Packets_t& unaryExprss_3bb2)
{
	for( Packets_t::const_iterator itArgDeclBase_3bb5= argDeclBases_3baa.begin(), itMember_3bbe= members_3bac.begin(), itLocalVar_3bc7= localVars_3bae.begin(), itContext_3bd0= contexts_3bb0.begin(), itUnaryExprs_3bd9= unaryExprss_3bb2.begin(); itArgDeclBase_3bb5!= argDeclBases_3baa.end(), itMember_3bbe!= members_3bac.end(), itLocalVar_3bc7!= localVars_3bae.end(), itContext_3bd0!= contexts_3bb0.end(), itUnaryExprs_3bd9!= unaryExprss_3bb2.end(); ++itArgDeclBase_3bb5, ++itMember_3bbe, ++itLocalVar_3bc7, ++itContext_3bd0, ++itUnaryExprs_3bd9)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_3bb5, *itMember_3bbe, *itLocalVar_3bc7, *itContext_3bd0, *itUnaryExprs_3bd9);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_3bb5, *itMember_3bbe, *itLocalVar_3bc7, *itContext_3bd0, *itUnaryExprs_3bd9);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool RisingEdge_3ba9::patternMatcher( const Udm::Object& argDeclBase_3bb6, const Udm::Object& member_3bbf, const Udm::Object& localVar_3bc8, const Udm::Object& context_3bd1, const Udm::Object& unaryExprs_3bda)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_3bb6.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_3bbb= SFC::ArgDeclBase::Cast( argDeclBase_3bb6);
		if( false== Uml::IsDerivedFrom( member_3bbf.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_3bc4= SFC::LocalVar::Cast( member_3bbf);
		if( false== Uml::IsDerivedFrom( localVar_3bc8.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_3bcd= SFC::LocalVar::Cast( localVar_3bc8);
		if( false== Uml::IsDerivedFrom( context_3bd1.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_3bd6= SFC::Arg::Cast( context_3bd1);
		if( false== Uml::IsDerivedFrom( unaryExprs_3bda.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_3bdf= SFC::UnaryExprs::Cast( unaryExprs_3bda);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3be4;
		if( !isValidBound(boundObjs_3be4, argDeclBase_3bbb, true))
			continue;
		currMatch.argDeclBase_3be5= argDeclBase_3bbb;
		if( !isValidBound(boundObjs_3be4, member_3bc4, true))
			continue;
		currMatch.member_3be6= member_3bc4;
		if( !isValidBound(boundObjs_3be4, localVar_3bcd, true))
			continue;
		currMatch.localVar_3be7= localVar_3bcd;
		if( !isValidBound(boundObjs_3be4, context_3bd6, true))
			continue;
		currMatch.context_3be8= context_3bd6;
		if( !isValidBound(boundObjs_3be4, unaryExprs_3bdf, true))
			continue;
		currMatch.unaryExprs_3be9= unaryExprs_3bdf;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void RisingEdge_3ba9::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newAnd_3bea= SFC::BinaryExprs::Create( currMatch.unaryExprs_3be9, SFC::UnaryExprs::meta_subexpr);
		SFC::BinaryExprs newGreaterThan_3beb= SFC::BinaryExprs::Create( newAnd_3bea, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newZero2_3bec= SFC::Int::Create( newGreaterThan_3beb, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newLessThan_3bed= SFC::BinaryExprs::Create( newAnd_3bea, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newZero_3bee= SFC::Int::Create( newLessThan_3bed, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newArgDeclDot_3bef= SFC::BinaryExprs::Create( newGreaterThan_3beb, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef_3bf0= SFC::ArgDeclRef::Create( newArgDeclDot_3bef, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newMemberRef_3bf1= SFC::ArgDeclRef::Create( newArgDeclDot_3bef, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newMemberDot_3bf2= SFC::BinaryExprs::Create( newLessThan_3bed, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newMemberRef2_3bf3= SFC::ArgDeclRef::Create( newMemberDot_3bf2, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newDot_3bf4= SFC::BinaryExprs::Create( newMemberDot_3bf2, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef3_3bf5= SFC::ArgDeclRef::Create( newDot_3bf4, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_3bf6= SFC::ArgDeclRef::Create( newDot_3bf4, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs& And= newAnd_3bea;
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_3be5;
		SFC::BinaryExprs& ArgDeclDot= newArgDeclDot_3bef;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_3bf0;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_3bf6;
		SFC::ArgDeclRef& ArgDeclRef3= newArgDeclRef3_3bf5;
		SFC::Arg& Context= currMatch.context_3be8;
		SFC::BinaryExprs& Dot= newDot_3bf4;
		SFC::BinaryExprs& GreaterThan= newGreaterThan_3beb;
		SFC::BinaryExprs& LessThan= newLessThan_3bed;
		SFC::LocalVar& LocalVar= currMatch.localVar_3be7;
		SFC::LocalVar& Member= currMatch.member_3be6;
		SFC::BinaryExprs& MemberDot= newMemberDot_3bf2;
		SFC::ArgDeclRef& MemberRef= newMemberRef_3bf1;
		SFC::ArgDeclRef& MemberRef2= newMemberRef2_3bf3;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_3be9;
		SFC::Int& Zero= newZero_3bee;
		SFC::Int& Zero2= newZero2_3bec;
		{
LessThan.op() = "<=";
};
		{
And.op() = "&&";
};
		{
GreaterThan.op() = ">";
};
		{
Dot.op() = ".";
};
		{
Zero.val() = 0;
};
		{
Zero2.val() = 0;
};
		{
MemberDot.op() = ".";
};
		{
ArgDeclDot.op() = ".";
};
		newArgDeclRef2_3bf6.argdecl()= currMatch.localVar_3be7;
		newArgDeclRef_3bf0.argdecl()= currMatch.argDeclBase_3be5;
		newArgDeclRef3_3bf5.argdecl()= currMatch.context_3be8;
		newMemberRef_3bf1.argdecl()= currMatch.member_3be6;
		newMemberRef2_3bf3.argdecl()= currMatch.member_3be6;
	}
}

void FallingEdge_3bf7::operator()( const Packets_t& argDeclBases_3bf8, const Packets_t& members_3bfa, const Packets_t& localVars_3bfc, const Packets_t& contexts_3bfe, const Packets_t& unaryExprss_3c00)
{
#ifdef PRINT_INFO
	printLog( "FallingEdge_3bf7" );
#endif
	RTTGenerator::Instance()->generateRule(3534, "FallingEdge");
	processInputPackets( argDeclBases_3bf8, members_3bfa, localVars_3bfc, contexts_3bfe, unaryExprss_3c00);
}

bool FallingEdge_3bf7::isInputUnique( const Udm::Object& argDeclBase_3c06, const Udm::Object& member_3c0f, const Udm::Object& localVar_3c18, const Udm::Object& context_3c21, const Udm::Object& unaryExprs_3c2a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_3c08= _argDeclBase_3c02.begin(), itMember_3c11= _member_3c0b.begin(), itLocalVar_3c1a= _localVar_3c14.begin(), itContext_3c23= _context_3c1d.begin(), itUnaryExprs_3c2c= _unaryExprs_3c26.begin(); itArgDeclBase_3c08!= _argDeclBase_3c02.end(), itMember_3c11!= _member_3c0b.end(), itLocalVar_3c1a!= _localVar_3c14.end(), itContext_3c23!= _context_3c1d.end(), itUnaryExprs_3c2c!= _unaryExprs_3c26.end(); ++itArgDeclBase_3c08, ++itMember_3c11, ++itLocalVar_3c1a, ++itContext_3c23, ++itUnaryExprs_3c2c)
	{
		if( ( *itArgDeclBase_3c08== argDeclBase_3c06)&& ( *itMember_3c11== member_3c0f)&& ( *itLocalVar_3c1a== localVar_3c18)&& ( *itContext_3c23== context_3c21)&& ( *itUnaryExprs_3c2c== unaryExprs_3c2a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_3c02.push_back( argDeclBase_3c06);
		_member_3c0b.push_back( member_3c0f);
		_localVar_3c14.push_back( localVar_3c18);
		_context_3c1d.push_back( context_3c21);
		_unaryExprs_3c26.push_back( unaryExprs_3c2a);
	}
	return isUnique;
}

bool FallingEdge_3bf7::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void FallingEdge_3bf7::processInputPackets( const Packets_t& argDeclBases_3bf8, const Packets_t& members_3bfa, const Packets_t& localVars_3bfc, const Packets_t& contexts_3bfe, const Packets_t& unaryExprss_3c00)
{
	for( Packets_t::const_iterator itArgDeclBase_3c03= argDeclBases_3bf8.begin(), itMember_3c0c= members_3bfa.begin(), itLocalVar_3c15= localVars_3bfc.begin(), itContext_3c1e= contexts_3bfe.begin(), itUnaryExprs_3c27= unaryExprss_3c00.begin(); itArgDeclBase_3c03!= argDeclBases_3bf8.end(), itMember_3c0c!= members_3bfa.end(), itLocalVar_3c15!= localVars_3bfc.end(), itContext_3c1e!= contexts_3bfe.end(), itUnaryExprs_3c27!= unaryExprss_3c00.end(); ++itArgDeclBase_3c03, ++itMember_3c0c, ++itLocalVar_3c15, ++itContext_3c1e, ++itUnaryExprs_3c27)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_3c03, *itMember_3c0c, *itLocalVar_3c15, *itContext_3c1e, *itUnaryExprs_3c27);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_3c03, *itMember_3c0c, *itLocalVar_3c15, *itContext_3c1e, *itUnaryExprs_3c27);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool FallingEdge_3bf7::patternMatcher( const Udm::Object& argDeclBase_3c04, const Udm::Object& member_3c0d, const Udm::Object& localVar_3c16, const Udm::Object& context_3c1f, const Udm::Object& unaryExprs_3c28)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_3c04.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_3c09= SFC::ArgDeclBase::Cast( argDeclBase_3c04);
		if( false== Uml::IsDerivedFrom( member_3c0d.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_3c12= SFC::LocalVar::Cast( member_3c0d);
		if( false== Uml::IsDerivedFrom( localVar_3c16.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_3c1b= SFC::LocalVar::Cast( localVar_3c16);
		if( false== Uml::IsDerivedFrom( context_3c1f.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_3c24= SFC::Arg::Cast( context_3c1f);
		if( false== Uml::IsDerivedFrom( unaryExprs_3c28.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_3c2d= SFC::UnaryExprs::Cast( unaryExprs_3c28);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3c32;
		if( !isValidBound(boundObjs_3c32, argDeclBase_3c09, true))
			continue;
		currMatch.argDeclBase_3c33= argDeclBase_3c09;
		if( !isValidBound(boundObjs_3c32, member_3c12, true))
			continue;
		currMatch.member_3c34= member_3c12;
		if( !isValidBound(boundObjs_3c32, localVar_3c1b, true))
			continue;
		currMatch.localVar_3c35= localVar_3c1b;
		if( !isValidBound(boundObjs_3c32, context_3c24, true))
			continue;
		currMatch.context_3c36= context_3c24;
		if( !isValidBound(boundObjs_3c32, unaryExprs_3c2d, true))
			continue;
		currMatch.unaryExprs_3c37= unaryExprs_3c2d;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void FallingEdge_3bf7::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newAnd_3c38= SFC::BinaryExprs::Create( currMatch.unaryExprs_3c37, SFC::UnaryExprs::meta_subexpr);
		SFC::BinaryExprs newLessThan_3c39= SFC::BinaryExprs::Create( newAnd_3c38, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newZero2_3c3a= SFC::Int::Create( newLessThan_3c39, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newGreaterThan_3c3b= SFC::BinaryExprs::Create( newAnd_3c38, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newZero_3c3c= SFC::Int::Create( newGreaterThan_3c3b, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newMemberDot_3c3d= SFC::BinaryExprs::Create( newGreaterThan_3c3b, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newDot_3c3e= SFC::BinaryExprs::Create( newMemberDot_3c3d, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef3_3c3f= SFC::ArgDeclRef::Create( newDot_3c3e, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_3c40= SFC::ArgDeclRef::Create( newDot_3c3e, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newMemberRef2_3c41= SFC::ArgDeclRef::Create( newMemberDot_3c3d, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newArgDeclDot_3c42= SFC::BinaryExprs::Create( newLessThan_3c39, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newMemberRef_3c43= SFC::ArgDeclRef::Create( newArgDeclDot_3c42, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_3c44= SFC::ArgDeclRef::Create( newArgDeclDot_3c42, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs& And= newAnd_3c38;
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_3c33;
		SFC::BinaryExprs& ArgDeclDot= newArgDeclDot_3c42;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_3c44;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_3c40;
		SFC::ArgDeclRef& ArgDeclRef3= newArgDeclRef3_3c3f;
		SFC::Arg& Context= currMatch.context_3c36;
		SFC::BinaryExprs& Dot= newDot_3c3e;
		SFC::BinaryExprs& GreaterThan= newGreaterThan_3c3b;
		SFC::BinaryExprs& LessThan= newLessThan_3c39;
		SFC::LocalVar& LocalVar= currMatch.localVar_3c35;
		SFC::LocalVar& Member= currMatch.member_3c34;
		SFC::BinaryExprs& MemberDot= newMemberDot_3c3d;
		SFC::ArgDeclRef& MemberRef= newMemberRef_3c43;
		SFC::ArgDeclRef& MemberRef2= newMemberRef2_3c41;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_3c37;
		SFC::Int& Zero= newZero_3c3c;
		SFC::Int& Zero2= newZero2_3c3a;
		{
LessThan.op() = "<";
};
		{
And.op() = "&&";
};
		{
GreaterThan.op() = ">=";
};
		{
Dot.op() = ".";
};
		{
Zero.val() = 0;
};
		{
Zero2.val() = 0;
};
		{
ArgDeclDot.op() = ".";
};
		{
MemberDot.op() = ".";
};
		newArgDeclRef2_3c40.argdecl()= currMatch.localVar_3c35;
		newArgDeclRef_3c44.argdecl()= currMatch.argDeclBase_3c33;
		newArgDeclRef3_3c3f.argdecl()= currMatch.context_3c36;
		newMemberRef2_3c41.argdecl()= currMatch.member_3c34;
		newMemberRef_3c43.argdecl()= currMatch.member_3c34;
	}
}

void EitherEdge_3c45::operator()( const Packets_t& argDeclBases_3c46, const Packets_t& members_3c49, const Packets_t& localVars_3c4c, const Packets_t& contexts_3c4f, const Packets_t& unaryExprss_3c52, Packets_t& argDeclBases_3c48, Packets_t& members_3c4b, Packets_t& localVars_3c4e, Packets_t& contexts_3c51, Packets_t& leftUnaryExprss_3c54, Packets_t& rightUnaryExprss_3c55)
{
#ifdef PRINT_INFO
	printLog( "EitherEdge_3c45" );
#endif
	RTTGenerator::Instance()->generateRule(3579, "EitherEdge");
	_argDeclBase_3c56= &argDeclBases_3c48;
	_member_3c57= &members_3c4b;
	_localVar_3c58= &localVars_3c4e;
	_context_3c59= &contexts_3c51;
	_leftUnaryExprs_3c5a= &leftUnaryExprss_3c54;
	_rightUnaryExprs_3c5b= &rightUnaryExprss_3c55;
	processInputPackets( argDeclBases_3c46, members_3c49, localVars_3c4c, contexts_3c4f, unaryExprss_3c52);
}

bool EitherEdge_3c45::isInputUnique( const Udm::Object& argDeclBase_3c60, const Udm::Object& member_3c69, const Udm::Object& localVar_3c72, const Udm::Object& context_3c7b, const Udm::Object& unaryExprs_3c84)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_3c62= _argDeclBase_3c5c.begin(), itMember_3c6b= _member_3c65.begin(), itLocalVar_3c74= _localVar_3c6e.begin(), itContext_3c7d= _context_3c77.begin(), itUnaryExprs_3c86= _unaryExprs_3c80.begin(); itArgDeclBase_3c62!= _argDeclBase_3c5c.end(), itMember_3c6b!= _member_3c65.end(), itLocalVar_3c74!= _localVar_3c6e.end(), itContext_3c7d!= _context_3c77.end(), itUnaryExprs_3c86!= _unaryExprs_3c80.end(); ++itArgDeclBase_3c62, ++itMember_3c6b, ++itLocalVar_3c74, ++itContext_3c7d, ++itUnaryExprs_3c86)
	{
		if( ( *itArgDeclBase_3c62== argDeclBase_3c60)&& ( *itMember_3c6b== member_3c69)&& ( *itLocalVar_3c74== localVar_3c72)&& ( *itContext_3c7d== context_3c7b)&& ( *itUnaryExprs_3c86== unaryExprs_3c84))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_3c5c.push_back( argDeclBase_3c60);
		_member_3c65.push_back( member_3c69);
		_localVar_3c6e.push_back( localVar_3c72);
		_context_3c77.push_back( context_3c7b);
		_unaryExprs_3c80.push_back( unaryExprs_3c84);
	}
	return isUnique;
}

bool EitherEdge_3c45::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void EitherEdge_3c45::processInputPackets( const Packets_t& argDeclBases_3c46, const Packets_t& members_3c49, const Packets_t& localVars_3c4c, const Packets_t& contexts_3c4f, const Packets_t& unaryExprss_3c52)
{
	for( Packets_t::const_iterator itArgDeclBase_3c5d= argDeclBases_3c46.begin(), itMember_3c66= members_3c49.begin(), itLocalVar_3c6f= localVars_3c4c.begin(), itContext_3c78= contexts_3c4f.begin(), itUnaryExprs_3c81= unaryExprss_3c52.begin(); itArgDeclBase_3c5d!= argDeclBases_3c46.end(), itMember_3c66!= members_3c49.end(), itLocalVar_3c6f!= localVars_3c4c.end(), itContext_3c78!= contexts_3c4f.end(), itUnaryExprs_3c81!= unaryExprss_3c52.end(); ++itArgDeclBase_3c5d, ++itMember_3c66, ++itLocalVar_3c6f, ++itContext_3c78, ++itUnaryExprs_3c81)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_3c5d, *itMember_3c66, *itLocalVar_3c6f, *itContext_3c78, *itUnaryExprs_3c81);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_3c5d, *itMember_3c66, *itLocalVar_3c6f, *itContext_3c78, *itUnaryExprs_3c81);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool EitherEdge_3c45::patternMatcher( const Udm::Object& argDeclBase_3c5e, const Udm::Object& member_3c67, const Udm::Object& localVar_3c70, const Udm::Object& context_3c79, const Udm::Object& unaryExprs_3c82)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_3c5e.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_3c63= SFC::ArgDeclBase::Cast( argDeclBase_3c5e);
		if( false== Uml::IsDerivedFrom( member_3c67.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_3c6c= SFC::LocalVar::Cast( member_3c67);
		if( false== Uml::IsDerivedFrom( localVar_3c70.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_3c75= SFC::LocalVar::Cast( localVar_3c70);
		if( false== Uml::IsDerivedFrom( context_3c79.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_3c7e= SFC::Arg::Cast( context_3c79);
		if( false== Uml::IsDerivedFrom( unaryExprs_3c82.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_3c87= SFC::UnaryExprs::Cast( unaryExprs_3c82);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3c8c;
		if( !isValidBound(boundObjs_3c8c, argDeclBase_3c63, true))
			continue;
		currMatch.argDeclBase_3c8d= argDeclBase_3c63;
		if( !isValidBound(boundObjs_3c8c, member_3c6c, true))
			continue;
		currMatch.member_3c8e= member_3c6c;
		if( !isValidBound(boundObjs_3c8c, localVar_3c75, true))
			continue;
		currMatch.localVar_3c8f= localVar_3c75;
		if( !isValidBound(boundObjs_3c8c, context_3c7e, true))
			continue;
		currMatch.context_3c90= context_3c7e;
		if( !isValidBound(boundObjs_3c8c, unaryExprs_3c87, true))
			continue;
		currMatch.unaryExprs_3c91= unaryExprs_3c87;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void EitherEdge_3c45::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newOr_3c92= SFC::BinaryExprs::Create( currMatch.unaryExprs_3c91, SFC::UnaryExprs::meta_subexpr);
		SFC::UnaryExprs newLeftUnaryExprs_3c93= SFC::UnaryExprs::Create( newOr_3c92, SFC::BinaryExprs::meta_leftexpr);
		SFC::UnaryExprs newRightUnaryExprs_3c94= SFC::UnaryExprs::Create( newOr_3c92, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_3c8d;
		SFC::Arg& Context= currMatch.context_3c90;
		SFC::UnaryExprs& LeftUnaryExprs= newLeftUnaryExprs_3c93;
		SFC::LocalVar& LocalVar= currMatch.localVar_3c8f;
		SFC::LocalVar& Member= currMatch.member_3c8e;
		SFC::BinaryExprs& Or= newOr_3c92;
		SFC::UnaryExprs& RightUnaryExprs= newRightUnaryExprs_3c94;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_3c91;
		{
LeftUnaryExprs.op() = "";
};
		{
RightUnaryExprs.op() = "";
};
		{
Or.op() = "||";
};
		outputAppender( currMatch.argDeclBase_3c8d, currMatch.member_3c8e, currMatch.localVar_3c8f, currMatch.context_3c90, newLeftUnaryExprs_3c93, newRightUnaryExprs_3c94);
	}
}

void EitherEdge_3c45::outputAppender( const SFC::ArgDeclBase& argDeclBase_3c95, const SFC::LocalVar& member_3c97, const SFC::LocalVar& localVar_3c99, const SFC::Arg& context_3c9b, const SFC::UnaryExprs& leftUnaryExprs_3c9d, const SFC::UnaryExprs& rightUnaryExprs_3c9f)
{
	_argDeclBase_3c56->push_back( argDeclBase_3c95);
	_member_3c57->push_back( member_3c97);
	_localVar_3c58->push_back( localVar_3c99);
	_context_3c59->push_back( context_3c9b);
	_leftUnaryExprs_3c5a->push_back( leftUnaryExprs_3c9d);
	_rightUnaryExprs_3c5b->push_back( rightUnaryExprs_3c9f);
}

void AddMatrixTriggerVars_3cd5::operator()( const Packets_t& childSubsystems_3cd6, const Packets_t& argdecls_3cd8, const Packets_t& dts_3cda, const Packets_t& oldvals_3cdc, const Packets_t& contexts_3cde, const Packets_t& functions_3ce0, Packets_t& childSubsystems_3ce2, Packets_t& argdecls_3ce3, Packets_t& dts_3ce4, Packets_t& oldvals_3ce5, Packets_t& contexts_3ce6, Packets_t& functions_3ce7)
{
#ifdef PRINT_INFO
	printLog( "AddMatrixTriggerVars_3cd5" );
#endif
	_childSubsystem_3ce8= &childSubsystems_3ce2;
	_argdecl_3ce9= &argdecls_3ce3;
	_dt_3cea= &dts_3ce4;
	_oldval_3ceb= &oldvals_3ce5;
	_context_3cec= &contexts_3ce6;
	_function_3ced= &functions_3ce7;
	_childSubsystem_3ce8->insert( _childSubsystem_3ce8->end(), childSubsystems_3cd6.begin(), childSubsystems_3cd6.end());
	_argdecl_3ce9->insert( _argdecl_3ce9->end(), argdecls_3cd8.begin(), argdecls_3cd8.end());
	_dt_3cea->insert( _dt_3cea->end(), dts_3cda.begin(), dts_3cda.end());
	_oldval_3ceb->insert( _oldval_3ceb->end(), oldvals_3cdc.begin(), oldvals_3cdc.end());
	_context_3cec->insert( _context_3cec->end(), contexts_3cde.begin(), contexts_3cde.end());
	_function_3ced->insert( _function_3ced->end(), functions_3ce0.begin(), functions_3ce0.end());
	if( ( !childSubsystems_3cd6.empty())&& ( !argdecls_3cd8.empty())&& ( !dts_3cda.empty())&& ( !oldvals_3cdc.empty())&& ( !contexts_3cde.empty())&& ( !functions_3ce0.empty()))
		callAddTriggerVar_3fe4( childSubsystems_3cd6, argdecls_3cd8, dts_3cda, oldvals_3cdc, contexts_3cde, functions_3ce0);
}

void AddMatrixTriggerVars_3cd5::callAddTriggerVar_3fe4( const Packets_t& charts_3cef, const Packets_t& argDeclBases_3cf2, const Packets_t& dTs_3cf5, const Packets_t& localVars_3cf7, const Packets_t& contexts_3cfa, const Packets_t& functions_3cfe)
{
	Packets_t charts_3cf1;
	Packets_t argDeclBases_3cf4;
	Packets_t localVars_3cf9;
	Packets_t contexts_3cfc;
	Packets_t triggerVars_3cfd;
	Packets_t functions_3d00;
	AddTriggerVar_3cee addTriggerVar_3cee;
	addTriggerVar_3cee( charts_3cef, argDeclBases_3cf2, dTs_3cf5, localVars_3cf7, contexts_3cfa, functions_3cfe, charts_3cf1, argDeclBases_3cf4, localVars_3cf9, contexts_3cfc, triggerVars_3cfd, functions_3d00);
	if( ( !charts_3cf1.empty())&& ( !argDeclBases_3cf4.empty())&& ( !localVars_3cf9.empty())&& ( !contexts_3cfc.empty())&& ( !triggerVars_3cfd.empty())&& ( !functions_3d00.empty()))
		callStartAssignment_3feb( charts_3cf1, argDeclBases_3cf4, localVars_3cf9, contexts_3cfc, triggerVars_3cfd, functions_3d00);
}

void AddMatrixTriggerVars_3cd5::callStartAssignment_3feb( const Packets_t& charts_3d5c, const Packets_t& argDeclBases_3d5e, const Packets_t& oldvals_3d61, const Packets_t& contexts_3d64, const Packets_t& triggerVars_3d67, const Packets_t& functions_3d69)
{
	Packets_t events_3d5b;
	Packets_t argDeclBases_3d60;
	Packets_t oldvals_3d63;
	Packets_t contexts_3d66;
	Packets_t unaryExprss_3d6b;
	StartAssignment_3d5a startAssignment_3d5a;
	startAssignment_3d5a( charts_3d5c, argDeclBases_3d5e, oldvals_3d61, contexts_3d64, triggerVars_3d67, functions_3d69, events_3d5b, argDeclBases_3d60, oldvals_3d63, contexts_3d66, unaryExprss_3d6b);
	if( ( !events_3d5b.empty())&& ( !argDeclBases_3d60.empty())&& ( !oldvals_3d63.empty())&& ( !contexts_3d66.empty())&& ( !unaryExprss_3d6b.empty()))
		callEdgeTest_3ff2( events_3d5b, argDeclBases_3d60, oldvals_3d63, contexts_3d66, unaryExprss_3d6b);
}

void AddMatrixTriggerVars_3cd5::callEdgeTest_3ff2( const Packets_t& events_3dd5, const Packets_t& argdecls_3dd7, const Packets_t& oldvals_3dd9, const Packets_t& contexts_3ddb, const Packets_t& initexprs_3ddd)
{
	Packets_t argdecls_3ddf;
	Packets_t oldvals_3de0;
	Packets_t contexts_3de1;
	Packets_t initexprs_3de2;
	Packets_t argdecls_3de3;
	Packets_t oldvals_3de4;
	Packets_t contexts_3de5;
	Packets_t initexprs_3de6;
	Packets_t argdecls_3de7;
	Packets_t oldvals_3de8;
	Packets_t contexts_3de9;
	Packets_t initexprs_3dea;
	EdgeTest_3dd4 edgeTest_3dd4;
	edgeTest_3dd4( events_3dd5, argdecls_3dd7, oldvals_3dd9, contexts_3ddb, initexprs_3ddd, argdecls_3ddf, oldvals_3de0, contexts_3de1, initexprs_3de2, argdecls_3de3, oldvals_3de4, contexts_3de5, initexprs_3de6, argdecls_3de7, oldvals_3de8, contexts_3de9, initexprs_3dea);
	if( ( !argdecls_3ddf.empty())&& ( !oldvals_3de0.empty())&& ( !contexts_3de1.empty())&& ( !initexprs_3de2.empty()))
		callRisingEdge_3ff8( argdecls_3ddf, oldvals_3de0, contexts_3de1, initexprs_3de2);
	if( ( !argdecls_3de3.empty())&& ( !oldvals_3de4.empty())&& ( !contexts_3de5.empty())&& ( !initexprs_3de6.empty()))
		callFallingEdge_3ffd( argdecls_3de3, oldvals_3de4, contexts_3de5, initexprs_3de6);
	if( ( !argdecls_3de7.empty())&& ( !oldvals_3de8.empty())&& ( !contexts_3de9.empty())&& ( !initexprs_3dea.empty()))
		callEitherEdge_4002( argdecls_3de7, oldvals_3de8, contexts_3de9, initexprs_3dea);
}

void AddMatrixTriggerVars_3cd5::callRisingEdge_3ff8( const Packets_t& argDeclBases_3f1d, const Packets_t& localVars_3f1f, const Packets_t& contexts_3f21, const Packets_t& unaryExprss_3f23)
{
	RisingEdge_3f1c risingEdge_3f1c;
	risingEdge_3f1c( argDeclBases_3f1d, localVars_3f1f, contexts_3f21, unaryExprss_3f23);
}

void AddMatrixTriggerVars_3cd5::callFallingEdge_3ffd( const Packets_t& argDeclBases_3f5b, const Packets_t& localVars_3f5d, const Packets_t& contexts_3f5f, const Packets_t& unaryExprss_3f61)
{
	FallingEdge_3f5a fallingEdge_3f5a;
	fallingEdge_3f5a( argDeclBases_3f5b, localVars_3f5d, contexts_3f5f, unaryExprss_3f61);
}

void AddMatrixTriggerVars_3cd5::callEitherEdge_4002( const Packets_t& argDeclBases_3f99, const Packets_t& localVars_3f9c, const Packets_t& contexts_3f9f, const Packets_t& unaryExprss_3fa2)
{
	Packets_t argDeclBases_3f9b;
	Packets_t localVars_3f9e;
	Packets_t contexts_3fa1;
	Packets_t leftUnaryExprss_3fa4;
	Packets_t rightUnaryExprss_3fa5;
	EitherEdge_3f98 eitherEdge_3f98;
	eitherEdge_3f98( argDeclBases_3f99, localVars_3f9c, contexts_3f9f, unaryExprss_3fa2, argDeclBases_3f9b, localVars_3f9e, contexts_3fa1, leftUnaryExprss_3fa4, rightUnaryExprss_3fa5);
	if( ( !argDeclBases_3f9b.empty())&& ( !localVars_3f9e.empty())&& ( !contexts_3fa1.empty())&& ( !leftUnaryExprss_3fa4.empty()))
		callRisingEdge_4007( argDeclBases_3f9b, localVars_3f9e, contexts_3fa1, leftUnaryExprss_3fa4);
	if( ( !argDeclBases_3f9b.empty())&& ( !localVars_3f9e.empty())&& ( !contexts_3fa1.empty())&& ( !rightUnaryExprss_3fa5.empty()))
		callFallingEdge_400c( argDeclBases_3f9b, localVars_3f9e, contexts_3fa1, rightUnaryExprss_3fa5);
}

void AddMatrixTriggerVars_3cd5::callRisingEdge_4007( const Packets_t& argDeclBases_3f1d, const Packets_t& localVars_3f1f, const Packets_t& contexts_3f21, const Packets_t& unaryExprss_3f23)
{
	RisingEdge_3f1c risingEdge_3f1c;
	risingEdge_3f1c( argDeclBases_3f1d, localVars_3f1f, contexts_3f21, unaryExprss_3f23);
}

void AddMatrixTriggerVars_3cd5::callFallingEdge_400c( const Packets_t& argDeclBases_3f5b, const Packets_t& localVars_3f5d, const Packets_t& contexts_3f5f, const Packets_t& unaryExprss_3f61)
{
	FallingEdge_3f5a fallingEdge_3f5a;
	fallingEdge_3f5a( argDeclBases_3f5b, localVars_3f5d, contexts_3f5f, unaryExprss_3f61);
}

void AddTriggerVar_3cee::operator()( const Packets_t& charts_3cef, const Packets_t& argDeclBases_3cf2, const Packets_t& dTs_3cf5, const Packets_t& localVars_3cf7, const Packets_t& contexts_3cfa, const Packets_t& functions_3cfe, Packets_t& charts_3cf1, Packets_t& argDeclBases_3cf4, Packets_t& localVars_3cf9, Packets_t& contexts_3cfc, Packets_t& triggerVars_3cfd, Packets_t& functions_3d00)
{
#ifdef PRINT_INFO
	printLog( "AddTriggerVar_3cee" );
#endif
	RTTGenerator::Instance()->generateRule(3607, "AddTriggerVar");
	_chart_3d01= &charts_3cf1;
	_argDeclBase_3d02= &argDeclBases_3cf4;
	_localVar_3d03= &localVars_3cf9;
	_context_3d04= &contexts_3cfc;
	_triggerVar_3d05= &triggerVars_3cfd;
	_function_3d06= &functions_3d00;
	processInputPackets( charts_3cef, argDeclBases_3cf2, dTs_3cf5, localVars_3cf7, contexts_3cfa, functions_3cfe);
}

bool AddTriggerVar_3cee::isInputUnique( const Udm::Object& chart_3d0b, const Udm::Object& argDeclBase_3d14, const Udm::Object& dT_3d1d, const Udm::Object& localVar_3d26, const Udm::Object& context_3d2f, const Udm::Object& function_3d38)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itChart_3d0d= _chart_3d07.begin(), itArgDeclBase_3d16= _argDeclBase_3d10.begin(), itDT_3d1f= _dT_3d19.begin(), itLocalVar_3d28= _localVar_3d22.begin(), itContext_3d31= _context_3d2b.begin(), itFunction_3d3a= _function_3d34.begin(); itChart_3d0d!= _chart_3d07.end(), itArgDeclBase_3d16!= _argDeclBase_3d10.end(), itDT_3d1f!= _dT_3d19.end(), itLocalVar_3d28!= _localVar_3d22.end(), itContext_3d31!= _context_3d2b.end(), itFunction_3d3a!= _function_3d34.end(); ++itChart_3d0d, ++itArgDeclBase_3d16, ++itDT_3d1f, ++itLocalVar_3d28, ++itContext_3d31, ++itFunction_3d3a)
	{
		if( ( *itChart_3d0d== chart_3d0b)&& ( *itArgDeclBase_3d16== argDeclBase_3d14)&& ( *itDT_3d1f== dT_3d1d)&& ( *itLocalVar_3d28== localVar_3d26)&& ( *itContext_3d31== context_3d2f)&& ( *itFunction_3d3a== function_3d38))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_chart_3d07.push_back( chart_3d0b);
		_argDeclBase_3d10.push_back( argDeclBase_3d14);
		_dT_3d19.push_back( dT_3d1d);
		_localVar_3d22.push_back( localVar_3d26);
		_context_3d2b.push_back( context_3d2f);
		_function_3d34.push_back( function_3d38);
	}
	return isUnique;
}

bool AddTriggerVar_3cee::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool AddTriggerVar_3cee::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, CyberComposition::Simulink::Subsystem& Chart, SFC::Arg& Context, SFC::DT& DT, SFC::Function& Function, SFC::LocalVar& LocalVar)
{
	bool Gz_guard= false;
	Gz_guard = DT.type() != SFC::Struct::meta;;
	return Gz_guard;
}

void AddTriggerVar_3cee::processInputPackets( const Packets_t& charts_3cef, const Packets_t& argDeclBases_3cf2, const Packets_t& dTs_3cf5, const Packets_t& localVars_3cf7, const Packets_t& contexts_3cfa, const Packets_t& functions_3cfe)
{
	for( Packets_t::const_iterator itChart_3d08= charts_3cef.begin(), itArgDeclBase_3d11= argDeclBases_3cf2.begin(), itDT_3d1a= dTs_3cf5.begin(), itLocalVar_3d23= localVars_3cf7.begin(), itContext_3d2c= contexts_3cfa.begin(), itFunction_3d35= functions_3cfe.begin(); itChart_3d08!= charts_3cef.end(), itArgDeclBase_3d11!= argDeclBases_3cf2.end(), itDT_3d1a!= dTs_3cf5.end(), itLocalVar_3d23!= localVars_3cf7.end(), itContext_3d2c!= contexts_3cfa.end(), itFunction_3d35!= functions_3cfe.end(); ++itChart_3d08, ++itArgDeclBase_3d11, ++itDT_3d1a, ++itLocalVar_3d23, ++itContext_3d2c, ++itFunction_3d35)
	{
		bool isUnique= isInputUnique( *itChart_3d08, *itArgDeclBase_3d11, *itDT_3d1a, *itLocalVar_3d23, *itContext_3d2c, *itFunction_3d35);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itChart_3d08, *itArgDeclBase_3d11, *itDT_3d1a, *itLocalVar_3d23, *itContext_3d2c, *itFunction_3d35);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AddTriggerVar_3cee::patternMatcher( const Udm::Object& chart_3d09, const Udm::Object& argDeclBase_3d12, const Udm::Object& dT_3d1b, const Udm::Object& localVar_3d24, const Udm::Object& context_3d2d, const Udm::Object& function_3d36)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( chart_3d09.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem chart_3d0e= CyberComposition::Simulink::Subsystem::Cast( chart_3d09);
		if( false== Uml::IsDerivedFrom( argDeclBase_3d12.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_3d17= SFC::ArgDeclBase::Cast( argDeclBase_3d12);
		if( false== Uml::IsDerivedFrom( dT_3d1b.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_3d20= SFC::DT::Cast( dT_3d1b);
		if( false== Uml::IsDerivedFrom( localVar_3d24.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_3d29= SFC::LocalVar::Cast( localVar_3d24);
		if( false== Uml::IsDerivedFrom( context_3d2d.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_3d32= SFC::Arg::Cast( context_3d2d);
		if( false== Uml::IsDerivedFrom( function_3d36.type(), SFC::Function::meta))
			continue;
		SFC::Function function_3d3b= SFC::Function::Cast( function_3d36);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3d40;
		if( !isValidBound(boundObjs_3d40, chart_3d0e, true))
			continue;
		currMatch.chart_3d41= chart_3d0e;
		if( !isValidBound(boundObjs_3d40, argDeclBase_3d17, true))
			continue;
		currMatch.argDeclBase_3d42= argDeclBase_3d17;
		if( !isValidBound(boundObjs_3d40, dT_3d20, true))
			continue;
		currMatch.dT_3d43= dT_3d20;
		if( !isValidBound(boundObjs_3d40, localVar_3d29, true))
			continue;
		currMatch.localVar_3d44= localVar_3d29;
		if( !isValidBound(boundObjs_3d40, context_3d32, true))
			continue;
		currMatch.context_3d45= context_3d32;
		if( !isValidBound(boundObjs_3d40, function_3d3b, true))
			continue;
		currMatch.function_3d46= function_3d3b;
		bool Gz_guard= isGuardTrue( currMatch.argDeclBase_3d42, currMatch.chart_3d41, currMatch.context_3d45, currMatch.dT_3d43, currMatch.function_3d46, currMatch.localVar_3d44);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void AddTriggerVar_3cee::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newTriggerVar_3d4d= SFC::LocalVar::Create( currMatch.function_3d46, SFC::Function::meta_stmnt);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_3d42;
		CyberComposition::Simulink::Subsystem& Chart= currMatch.chart_3d41;
		SFC::Arg& Context= currMatch.context_3d45;
		SFC::DT& DT= currMatch.dT_3d43;
		SFC::Function& Function= currMatch.function_3d46;
		SFC::LocalVar& LocalVar= currMatch.localVar_3d44;
		SFC::LocalVar& TriggerVar= newTriggerVar_3d4d;
		{
__int64 statementCount = Function.statementCount();
TriggerVar.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		{
TriggerVar.type() = "int";
TriggerVar.name() = std::string( "event" ) + boost::lexical_cast< std::string >( TriggerVar.uniqueId() );
};
		currMatch.localVar_3d44.trigvar()= newTriggerVar_3d4d;
		newTriggerVar_3d4d.dt()= currMatch.dT_3d43;
		outputAppender( currMatch.chart_3d41, currMatch.argDeclBase_3d42, currMatch.localVar_3d44, currMatch.context_3d45, newTriggerVar_3d4d, currMatch.function_3d46);
	}
}

void AddTriggerVar_3cee::outputAppender( const CyberComposition::Simulink::Subsystem& chart_3d4e, const SFC::ArgDeclBase& argDeclBase_3d50, const SFC::LocalVar& localVar_3d52, const SFC::Arg& context_3d54, const SFC::LocalVar& triggerVar_3d56, const SFC::Function& function_3d58)
{
	_chart_3d01->push_back( chart_3d4e);
	_argDeclBase_3d02->push_back( argDeclBase_3d50);
	_localVar_3d03->push_back( localVar_3d52);
	_context_3d04->push_back( context_3d54);
	_triggerVar_3d05->push_back( triggerVar_3d56);
	_function_3d06->push_back( function_3d58);
}

void StartAssignment_3d5a::operator()( const Packets_t& charts_3d5c, const Packets_t& argDeclBases_3d5e, const Packets_t& oldvals_3d61, const Packets_t& contexts_3d64, const Packets_t& triggerVars_3d67, const Packets_t& functions_3d69, Packets_t& events_3d5b, Packets_t& argDeclBases_3d60, Packets_t& oldvals_3d63, Packets_t& contexts_3d66, Packets_t& unaryExprss_3d6b)
{
#ifdef PRINT_INFO
	printLog( "StartAssignment_3d5a" );
#endif
	RTTGenerator::Instance()->generateRule(3620, "StartAssignment");
	_event_3d6c= &events_3d5b;
	_argDeclBase_3d6d= &argDeclBases_3d60;
	_oldval_3d6e= &oldvals_3d63;
	_context_3d6f= &contexts_3d66;
	_unaryExprs_3d70= &unaryExprss_3d6b;
	processInputPackets( charts_3d5c, argDeclBases_3d5e, oldvals_3d61, contexts_3d64, triggerVars_3d67, functions_3d69);
}

bool StartAssignment_3d5a::isInputUnique( const Udm::Object& chart_3d75, const Udm::Object& argDeclBase_3d7e, const Udm::Object& oldval_3d87, const Udm::Object& context_3d90, const Udm::Object& triggerVar_3d99, const Udm::Object& function_3da2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itChart_3d77= _chart_3d71.begin(), itArgDeclBase_3d80= _argDeclBase_3d7a.begin(), itoldval_3d89= _oldval_3d83.begin(), itContext_3d92= _context_3d8c.begin(), itTriggerVar_3d9b= _triggerVar_3d95.begin(), itFunction_3da4= _function_3d9e.begin(); itChart_3d77!= _chart_3d71.end(), itArgDeclBase_3d80!= _argDeclBase_3d7a.end(), itoldval_3d89!= _oldval_3d83.end(), itContext_3d92!= _context_3d8c.end(), itTriggerVar_3d9b!= _triggerVar_3d95.end(), itFunction_3da4!= _function_3d9e.end(); ++itChart_3d77, ++itArgDeclBase_3d80, ++itoldval_3d89, ++itContext_3d92, ++itTriggerVar_3d9b, ++itFunction_3da4)
	{
		if( ( *itChart_3d77== chart_3d75)&& ( *itArgDeclBase_3d80== argDeclBase_3d7e)&& ( *itoldval_3d89== oldval_3d87)&& ( *itContext_3d92== context_3d90)&& ( *itTriggerVar_3d9b== triggerVar_3d99)&& ( *itFunction_3da4== function_3da2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_chart_3d71.push_back( chart_3d75);
		_argDeclBase_3d7a.push_back( argDeclBase_3d7e);
		_oldval_3d83.push_back( oldval_3d87);
		_context_3d8c.push_back( context_3d90);
		_triggerVar_3d95.push_back( triggerVar_3d99);
		_function_3d9e.push_back( function_3da2);
	}
	return isUnique;
}

bool StartAssignment_3d5a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool StartAssignment_3d5a::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, CyberComposition::Simulink::Subsystem& Chart, SFC::Arg& Context, CyberComposition::Simulink::Event& Event, SFC::Function& Function, CyberComposition::Simulink::Primitive& Primitive, CyberComposition::Simulink::State& State, SFC::LocalVar& TriggerVar, SFC::LocalVar& oldval)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( Event.Scope() ) == "INPUT_EVENT";;
	return Gz_guard;
}

void StartAssignment_3d5a::processInputPackets( const Packets_t& charts_3d5c, const Packets_t& argDeclBases_3d5e, const Packets_t& oldvals_3d61, const Packets_t& contexts_3d64, const Packets_t& triggerVars_3d67, const Packets_t& functions_3d69)
{
	for( Packets_t::const_iterator itChart_3d72= charts_3d5c.begin(), itArgDeclBase_3d7b= argDeclBases_3d5e.begin(), itoldval_3d84= oldvals_3d61.begin(), itContext_3d8d= contexts_3d64.begin(), itTriggerVar_3d96= triggerVars_3d67.begin(), itFunction_3d9f= functions_3d69.begin(); itChart_3d72!= charts_3d5c.end(), itArgDeclBase_3d7b!= argDeclBases_3d5e.end(), itoldval_3d84!= oldvals_3d61.end(), itContext_3d8d!= contexts_3d64.end(), itTriggerVar_3d96!= triggerVars_3d67.end(), itFunction_3d9f!= functions_3d69.end(); ++itChart_3d72, ++itArgDeclBase_3d7b, ++itoldval_3d84, ++itContext_3d8d, ++itTriggerVar_3d96, ++itFunction_3d9f)
	{
		bool isUnique= isInputUnique( *itChart_3d72, *itArgDeclBase_3d7b, *itoldval_3d84, *itContext_3d8d, *itTriggerVar_3d96, *itFunction_3d9f);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itChart_3d72, *itArgDeclBase_3d7b, *itoldval_3d84, *itContext_3d8d, *itTriggerVar_3d96, *itFunction_3d9f);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool StartAssignment_3d5a::patternMatcher( const Udm::Object& chart_3d73, const Udm::Object& argDeclBase_3d7c, const Udm::Object& oldval_3d85, const Udm::Object& context_3d8e, const Udm::Object& triggerVar_3d97, const Udm::Object& function_3da0)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( chart_3d73.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem chart_3d78= CyberComposition::Simulink::Subsystem::Cast( chart_3d73);
		if( false== Uml::IsDerivedFrom( argDeclBase_3d7c.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_3d81= SFC::ArgDeclBase::Cast( argDeclBase_3d7c);
		if( false== Uml::IsDerivedFrom( oldval_3d85.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar oldval_3d8a= SFC::LocalVar::Cast( oldval_3d85);
		if( false== Uml::IsDerivedFrom( context_3d8e.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_3d93= SFC::Arg::Cast( context_3d8e);
		if( false== Uml::IsDerivedFrom( triggerVar_3d97.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_3d9c= SFC::LocalVar::Cast( triggerVar_3d97);
		if( false== Uml::IsDerivedFrom( function_3da0.type(), SFC::Function::meta))
			continue;
		SFC::Function function_3da5= SFC::Function::Cast( function_3da0);
		set< CyberComposition::Simulink::Primitive> primitives_3da7= chart_3d78.Primitive_kind_children();
		for( set< CyberComposition::Simulink::Primitive>::const_iterator itPrimitive_3da8= primitives_3da7.begin(); itPrimitive_3da8!= primitives_3da7.end(); ++itPrimitive_3da8)
		{
			CyberComposition::Simulink::Primitive currPrimitive_3da9= *itPrimitive_3da8;
			set< CyberComposition::Simulink::State> states_3daa= currPrimitive_3da9.State_kind_children();
			for( set< CyberComposition::Simulink::State>::const_iterator itState_3dab= states_3daa.begin(); itState_3dab!= states_3daa.end(); ++itState_3dab)
			{
				CyberComposition::Simulink::State currState_3dac= *itState_3dab;
				set< CyberComposition::Simulink::Event> events_3dad= currState_3dac.Event_kind_children();
				for( set< CyberComposition::Simulink::Event>::const_iterator itEvent_3dae= events_3dad.begin(); itEvent_3dae!= events_3dad.end(); ++itEvent_3dae)
				{
					CyberComposition::Simulink::Event currEvent_3daf= *itEvent_3dae;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_3db3;
					if( !isValidBound(boundObjs_3db3, chart_3d78, true))
						continue;
					currMatch.chart_3db4= chart_3d78;
					if( !isValidBound(boundObjs_3db3, argDeclBase_3d81, true))
						continue;
					currMatch.argDeclBase_3db5= argDeclBase_3d81;
					if( !isValidBound(boundObjs_3db3, oldval_3d8a, true))
						continue;
					currMatch.oldval_3db6= oldval_3d8a;
					if( !isValidBound(boundObjs_3db3, context_3d93, true))
						continue;
					currMatch.context_3db7= context_3d93;
					if( !isValidBound(boundObjs_3db3, triggerVar_3d9c, true))
						continue;
					currMatch.triggerVar_3db8= triggerVar_3d9c;
					if( !isValidBound(boundObjs_3db3, function_3da5, true))
						continue;
					currMatch.function_3db9= function_3da5;
					if( !isValidBound(boundObjs_3db3, currState_3dac, false))
						continue;
					currMatch.state_3dba= currState_3dac;
					if( !isValidBound(boundObjs_3db3, currEvent_3daf, false))
						continue;
					currMatch.event_3dbb= currEvent_3daf;
					if( !isValidBound(boundObjs_3db3, currPrimitive_3da9, false))
						continue;
					currMatch.primitive_3dbc= currPrimitive_3da9;
					bool Gz_guard= isGuardTrue( currMatch.argDeclBase_3db5, currMatch.chart_3db4, currMatch.context_3db7, currMatch.event_3dbb, currMatch.function_3db9, currMatch.primitive_3dbc, currMatch.state_3dba, currMatch.triggerVar_3db8, currMatch.oldval_3db6);
					if( true== Gz_guard)
						_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void StartAssignment_3d5a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newAssignment_3dc6= SFC::UserCode::Create( currMatch.function_3db9, SFC::Function::meta_stmnt);
		SFC::BinaryExprs newAssign_3dc7= SFC::BinaryExprs::Create( newAssignment_3dc6, SFC::UserCode::meta_codeexpr);
		SFC::UnaryExprs newUnaryExprs_3dc8= SFC::UnaryExprs::Create( newAssign_3dc7, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_3dc9= SFC::ArgDeclRef::Create( newAssign_3dc7, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_3db5;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_3dc9;
		SFC::BinaryExprs& Assign= newAssign_3dc7;
		SFC::UserCode& Assignment= newAssignment_3dc6;
		CyberComposition::Simulink::Subsystem& Chart= currMatch.chart_3db4;
		SFC::Arg& Context= currMatch.context_3db7;
		CyberComposition::Simulink::Event& Event= currMatch.event_3dbb;
		SFC::Function& Function= currMatch.function_3db9;
		CyberComposition::Simulink::Primitive& Primitive= currMatch.primitive_3dbc;
		CyberComposition::Simulink::State& State= currMatch.state_3dba;
		SFC::LocalVar& TriggerVar= currMatch.triggerVar_3db8;
		SFC::UnaryExprs& UnaryExprs= newUnaryExprs_3dc8;
		SFC::LocalVar& oldval= currMatch.oldval_3db6;
		{
UnaryExprs.op() = "";
};
		{
__int64 statementCount = Function.statementCount();
Assignment.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		{
Assign.op() = "=";
};
		newArgDeclRef_3dc9.argdecl()= currMatch.triggerVar_3db8;
		outputAppender( currMatch.event_3dbb, currMatch.argDeclBase_3db5, currMatch.oldval_3db6, currMatch.context_3db7, newUnaryExprs_3dc8);
	}
}

void StartAssignment_3d5a::outputAppender( const CyberComposition::Simulink::Event& event_3dca, const SFC::ArgDeclBase& argDeclBase_3dcc, const SFC::LocalVar& oldval_3dce, const SFC::Arg& context_3dd0, const SFC::UnaryExprs& unaryExprs_3dd2)
{
	_event_3d6c->push_back( event_3dca);
	_argDeclBase_3d6d->push_back( argDeclBase_3dcc);
	_oldval_3d6e->push_back( oldval_3dce);
	_context_3d6f->push_back( context_3dd0);
	_unaryExprs_3d70->push_back( unaryExprs_3dd2);
}

void EdgeTest_3dd4::operator()( const Packets_t& events_3dd5, const Packets_t& argdecls_3dd7, const Packets_t& oldvals_3dd9, const Packets_t& contexts_3ddb, const Packets_t& initexprs_3ddd, Packets_t& argdecls_3ddf, Packets_t& oldvals_3de0, Packets_t& contexts_3de1, Packets_t& initexprs_3de2, Packets_t& argdecls_3de3, Packets_t& oldvals_3de4, Packets_t& contexts_3de5, Packets_t& initexprs_3de6, Packets_t& argdecls_3de7, Packets_t& oldvals_3de8, Packets_t& contexts_3de9, Packets_t& initexprs_3dea)
{
#ifdef PRINT_INFO
	printLog( "EdgeTest_3dd4" );
#endif
	_argdecl_3deb= &argdecls_3ddf;
	_oldval_3dec= &oldvals_3de0;
	_context_3ded= &contexts_3de1;
	_initexpr_3dee= &initexprs_3de2;
	_argdecl_3def= &argdecls_3de3;
	_oldval_3df0= &oldvals_3de4;
	_context_3df1= &contexts_3de5;
	_initexpr_3df2= &initexprs_3de6;
	_argdecl_3df3= &argdecls_3de7;
	_oldval_3df4= &oldvals_3de8;
	_context_3df5= &contexts_3de9;
	_initexpr_3df6= &initexprs_3dea;
	for( Packets_t::const_iterator itevent_3df8= events_3dd5.begin(), itargdecl_3dff= argdecls_3dd7.begin(), itoldval_3e06= oldvals_3dd9.begin(), itcontext_3e0d= contexts_3ddb.begin(), itinitexpr_3e14= initexprs_3ddd.begin(); itevent_3df8!= events_3dd5.end(), itargdecl_3dff!= argdecls_3dd7.end(), itoldval_3e06!= oldvals_3dd9.end(), itcontext_3e0d!= contexts_3ddb.end(), itinitexpr_3e14!= initexprs_3ddd.end(); ++itevent_3df8, ++itargdecl_3dff, ++itoldval_3e06, ++itcontext_3e0d, ++itinitexpr_3e14)
	{
		bool isUnique= isInputUnique( *itevent_3df8, *itargdecl_3dff, *itoldval_3e06, *itcontext_3e0d, *itinitexpr_3e14);
		if( !isUnique)
			continue;
		Packets_t oneevent_3dfc( 1, *itevent_3df8);
		Packets_t oneargdecl_3e03( 1, *itargdecl_3dff);
		Packets_t oneoldval_3e0a( 1, *itoldval_3e06);
		Packets_t onecontext_3e11( 1, *itcontext_3e0d);
		Packets_t oneinitexpr_3e18( 1, *itinitexpr_3e14);
		executeOne( oneevent_3dfc, oneargdecl_3e03, oneoldval_3e0a, onecontext_3e11, oneinitexpr_3e18);
	}
}

void EdgeTest_3dd4::executeOne( const Packets_t& events_3dd5, const Packets_t& argdecls_3dd7, const Packets_t& oldvals_3dd9, const Packets_t& contexts_3ddb, const Packets_t& initexprs_3ddd)
{
	Packets_t argDeclBases_3e1f;
	Packets_t localVars_3e22;
	Packets_t contexts_3e25;
	Packets_t unaryExprss_3e28;
	RisingEdge_3e1a risingEdge_3e1a;
	bool isMatchRisingEdge_3e1a= risingEdge_3e1a( events_3dd5, argdecls_3dd7, oldvals_3dd9, contexts_3ddb, initexprs_3ddd, argDeclBases_3e1f, localVars_3e22, contexts_3e25, unaryExprss_3e28);
	_argdecl_3deb->insert( _argdecl_3deb->end(), argDeclBases_3e1f.begin(), argDeclBases_3e1f.end());
	_oldval_3dec->insert( _oldval_3dec->end(), localVars_3e22.begin(), localVars_3e22.end());
	_context_3ded->insert( _context_3ded->end(), contexts_3e25.begin(), contexts_3e25.end());
	_initexpr_3dee->insert( _initexpr_3dee->end(), unaryExprss_3e28.begin(), unaryExprss_3e28.end());
	if( isMatchRisingEdge_3e1a)
		return;
	Packets_t argDeclBases_3e75;
	Packets_t localVars_3e78;
	Packets_t contexts_3e7b;
	Packets_t unaryExprss_3e7e;
	FallingEdge_3e70 fallingEdge_3e70;
	bool isMatchFallingEdge_3e70= fallingEdge_3e70( events_3dd5, argdecls_3dd7, oldvals_3dd9, contexts_3ddb, initexprs_3ddd, argDeclBases_3e75, localVars_3e78, contexts_3e7b, unaryExprss_3e7e);
	_argdecl_3def->insert( _argdecl_3def->end(), argDeclBases_3e75.begin(), argDeclBases_3e75.end());
	_oldval_3df0->insert( _oldval_3df0->end(), localVars_3e78.begin(), localVars_3e78.end());
	_context_3df1->insert( _context_3df1->end(), contexts_3e7b.begin(), contexts_3e7b.end());
	_initexpr_3df2->insert( _initexpr_3df2->end(), unaryExprss_3e7e.begin(), unaryExprss_3e7e.end());
	Packets_t argDeclBases_3ecb;
	Packets_t localVars_3ece;
	Packets_t contexts_3ed1;
	Packets_t unaryExprss_3ed4;
	EitherEdge_3ec6 eitherEdge_3ec6;
	bool isMatchEitherEdge_3ec6= eitherEdge_3ec6( events_3dd5, argdecls_3dd7, oldvals_3dd9, contexts_3ddb, initexprs_3ddd, argDeclBases_3ecb, localVars_3ece, contexts_3ed1, unaryExprss_3ed4);
	_argdecl_3df3->insert( _argdecl_3df3->end(), argDeclBases_3ecb.begin(), argDeclBases_3ecb.end());
	_oldval_3df4->insert( _oldval_3df4->end(), localVars_3ece.begin(), localVars_3ece.end());
	_context_3df5->insert( _context_3df5->end(), contexts_3ed1.begin(), contexts_3ed1.end());
	_initexpr_3df6->insert( _initexpr_3df6->end(), unaryExprss_3ed4.begin(), unaryExprss_3ed4.end());
}

bool EdgeTest_3dd4::isInputUnique( const Udm::Object& event_3df9, const Udm::Object& argdecl_3e00, const Udm::Object& oldval_3e07, const Udm::Object& context_3e0e, const Udm::Object& initexpr_3e15)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itevent_3dfb= _event_3df7.begin(), itargdecl_3e02= _argdecl_3dfe.begin(), itoldval_3e09= _oldval_3e05.begin(), itcontext_3e10= _context_3e0c.begin(), itinitexpr_3e17= _initexpr_3e13.begin(); itevent_3dfb!= _event_3df7.end(), itargdecl_3e02!= _argdecl_3dfe.end(), itoldval_3e09!= _oldval_3e05.end(), itcontext_3e10!= _context_3e0c.end(), itinitexpr_3e17!= _initexpr_3e13.end(); ++itevent_3dfb, ++itargdecl_3e02, ++itoldval_3e09, ++itcontext_3e10, ++itinitexpr_3e17)
	{
		if( ( *itevent_3dfb== event_3df9)&& ( *itargdecl_3e02== argdecl_3e00)&& ( *itoldval_3e09== oldval_3e07)&& ( *itcontext_3e10== context_3e0e)&& ( *itinitexpr_3e17== initexpr_3e15))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_event_3df7.push_back( event_3df9);
		_argdecl_3dfe.push_back( argdecl_3e00);
		_oldval_3e05.push_back( oldval_3e07);
		_context_3e0c.push_back( context_3e0e);
		_initexpr_3e13.push_back( initexpr_3e15);
	}
	return isUnique;
}

bool RisingEdge_3e1a::operator()( const Packets_t& events_3e1b, const Packets_t& argDeclBases_3e1d, const Packets_t& localVars_3e20, const Packets_t& contexts_3e23, const Packets_t& unaryExprss_3e26, Packets_t& argDeclBases_3e1f, Packets_t& localVars_3e22, Packets_t& contexts_3e25, Packets_t& unaryExprss_3e28)
{
#ifdef PRINT_INFO
	printLog( "RisingEdge_3e1a" );
#endif
	_argDeclBase_3e29= &argDeclBases_3e1f;
	_localVar_3e2a= &localVars_3e22;
	_context_3e2b= &contexts_3e25;
	_unaryExprs_3e2c= &unaryExprss_3e28;
	processInputPackets( events_3e1b, argDeclBases_3e1d, localVars_3e20, contexts_3e23, unaryExprss_3e26);
	if( false== _matches.empty())
		return true;
	return false;
}

bool RisingEdge_3e1a::isInputUnique( const Udm::Object& event_3e31, const Udm::Object& argDeclBase_3e3a, const Udm::Object& localVar_3e43, const Udm::Object& context_3e4c, const Udm::Object& unaryExprs_3e55)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itEvent_3e33= _event_3e2d.begin(), itArgDeclBase_3e3c= _argDeclBase_3e36.begin(), itLocalVar_3e45= _localVar_3e3f.begin(), itContext_3e4e= _context_3e48.begin(), itUnaryExprs_3e57= _unaryExprs_3e51.begin(); itEvent_3e33!= _event_3e2d.end(), itArgDeclBase_3e3c!= _argDeclBase_3e36.end(), itLocalVar_3e45!= _localVar_3e3f.end(), itContext_3e4e!= _context_3e48.end(), itUnaryExprs_3e57!= _unaryExprs_3e51.end(); ++itEvent_3e33, ++itArgDeclBase_3e3c, ++itLocalVar_3e45, ++itContext_3e4e, ++itUnaryExprs_3e57)
	{
		if( ( *itEvent_3e33== event_3e31)&& ( *itArgDeclBase_3e3c== argDeclBase_3e3a)&& ( *itLocalVar_3e45== localVar_3e43)&& ( *itContext_3e4e== context_3e4c)&& ( *itUnaryExprs_3e57== unaryExprs_3e55))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_event_3e2d.push_back( event_3e31);
		_argDeclBase_3e36.push_back( argDeclBase_3e3a);
		_localVar_3e3f.push_back( localVar_3e43);
		_context_3e48.push_back( context_3e4c);
		_unaryExprs_3e51.push_back( unaryExprs_3e55);
	}
	return isUnique;
}

bool RisingEdge_3e1a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool RisingEdge_3e1a::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, SFC::Arg& Context, CyberComposition::Simulink::Event& Event, SFC::LocalVar& LocalVar, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	std::string trigger = Event.Trigger();
Gz_guard = trigger == "RISING_EDGE_EVENT";;
	return Gz_guard;
}

void RisingEdge_3e1a::processInputPackets( const Packets_t& events_3e1b, const Packets_t& argDeclBases_3e1d, const Packets_t& localVars_3e20, const Packets_t& contexts_3e23, const Packets_t& unaryExprss_3e26)
{
	for( Packets_t::const_iterator itEvent_3e2e= events_3e1b.begin(), itArgDeclBase_3e37= argDeclBases_3e1d.begin(), itLocalVar_3e40= localVars_3e20.begin(), itContext_3e49= contexts_3e23.begin(), itUnaryExprs_3e52= unaryExprss_3e26.begin(); itEvent_3e2e!= events_3e1b.end(), itArgDeclBase_3e37!= argDeclBases_3e1d.end(), itLocalVar_3e40!= localVars_3e20.end(), itContext_3e49!= contexts_3e23.end(), itUnaryExprs_3e52!= unaryExprss_3e26.end(); ++itEvent_3e2e, ++itArgDeclBase_3e37, ++itLocalVar_3e40, ++itContext_3e49, ++itUnaryExprs_3e52)
	{
		bool isUnique= isInputUnique( *itEvent_3e2e, *itArgDeclBase_3e37, *itLocalVar_3e40, *itContext_3e49, *itUnaryExprs_3e52);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itEvent_3e2e, *itArgDeclBase_3e37, *itLocalVar_3e40, *itContext_3e49, *itUnaryExprs_3e52);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_3e5f, currMatch.localVar_3e60, currMatch.context_3e61, currMatch.unaryExprs_3e62);
	}
}

bool RisingEdge_3e1a::patternMatcher( const Udm::Object& event_3e2f, const Udm::Object& argDeclBase_3e38, const Udm::Object& localVar_3e41, const Udm::Object& context_3e4a, const Udm::Object& unaryExprs_3e53)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( event_3e2f.type(), CyberComposition::Simulink::Event::meta))
			continue;
		CyberComposition::Simulink::Event event_3e34= CyberComposition::Simulink::Event::Cast( event_3e2f);
		if( false== Uml::IsDerivedFrom( argDeclBase_3e38.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_3e3d= SFC::ArgDeclBase::Cast( argDeclBase_3e38);
		if( false== Uml::IsDerivedFrom( localVar_3e41.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_3e46= SFC::LocalVar::Cast( localVar_3e41);
		if( false== Uml::IsDerivedFrom( context_3e4a.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_3e4f= SFC::Arg::Cast( context_3e4a);
		if( false== Uml::IsDerivedFrom( unaryExprs_3e53.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_3e58= SFC::UnaryExprs::Cast( unaryExprs_3e53);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3e5d;
		if( !isValidBound(boundObjs_3e5d, event_3e34, true))
			continue;
		currMatch.event_3e5e= event_3e34;
		if( !isValidBound(boundObjs_3e5d, argDeclBase_3e3d, true))
			continue;
		currMatch.argDeclBase_3e5f= argDeclBase_3e3d;
		if( !isValidBound(boundObjs_3e5d, localVar_3e46, true))
			continue;
		currMatch.localVar_3e60= localVar_3e46;
		if( !isValidBound(boundObjs_3e5d, context_3e4f, true))
			continue;
		currMatch.context_3e61= context_3e4f;
		if( !isValidBound(boundObjs_3e5d, unaryExprs_3e58, true))
			continue;
		currMatch.unaryExprs_3e62= unaryExprs_3e58;
		bool Gz_guard= isGuardTrue( currMatch.argDeclBase_3e5f, currMatch.context_3e61, currMatch.event_3e5e, currMatch.localVar_3e60, currMatch.unaryExprs_3e62);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void RisingEdge_3e1a::outputAppender( const SFC::ArgDeclBase& argDeclBase_3e68, const SFC::LocalVar& localVar_3e6a, const SFC::Arg& context_3e6c, const SFC::UnaryExprs& unaryExprs_3e6e)
{
	_argDeclBase_3e29->push_back( argDeclBase_3e68);
	_localVar_3e2a->push_back( localVar_3e6a);
	_context_3e2b->push_back( context_3e6c);
	_unaryExprs_3e2c->push_back( unaryExprs_3e6e);
}

bool FallingEdge_3e70::operator()( const Packets_t& events_3e71, const Packets_t& argDeclBases_3e73, const Packets_t& localVars_3e76, const Packets_t& contexts_3e79, const Packets_t& unaryExprss_3e7c, Packets_t& argDeclBases_3e75, Packets_t& localVars_3e78, Packets_t& contexts_3e7b, Packets_t& unaryExprss_3e7e)
{
#ifdef PRINT_INFO
	printLog( "FallingEdge_3e70" );
#endif
	_argDeclBase_3e7f= &argDeclBases_3e75;
	_localVar_3e80= &localVars_3e78;
	_context_3e81= &contexts_3e7b;
	_unaryExprs_3e82= &unaryExprss_3e7e;
	processInputPackets( events_3e71, argDeclBases_3e73, localVars_3e76, contexts_3e79, unaryExprss_3e7c);
	if( false== _matches.empty())
		return true;
	return false;
}

bool FallingEdge_3e70::isInputUnique( const Udm::Object& event_3e87, const Udm::Object& argDeclBase_3e90, const Udm::Object& localVar_3e99, const Udm::Object& context_3ea2, const Udm::Object& unaryExprs_3eab)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itEvent_3e89= _event_3e83.begin(), itArgDeclBase_3e92= _argDeclBase_3e8c.begin(), itLocalVar_3e9b= _localVar_3e95.begin(), itContext_3ea4= _context_3e9e.begin(), itUnaryExprs_3ead= _unaryExprs_3ea7.begin(); itEvent_3e89!= _event_3e83.end(), itArgDeclBase_3e92!= _argDeclBase_3e8c.end(), itLocalVar_3e9b!= _localVar_3e95.end(), itContext_3ea4!= _context_3e9e.end(), itUnaryExprs_3ead!= _unaryExprs_3ea7.end(); ++itEvent_3e89, ++itArgDeclBase_3e92, ++itLocalVar_3e9b, ++itContext_3ea4, ++itUnaryExprs_3ead)
	{
		if( ( *itEvent_3e89== event_3e87)&& ( *itArgDeclBase_3e92== argDeclBase_3e90)&& ( *itLocalVar_3e9b== localVar_3e99)&& ( *itContext_3ea4== context_3ea2)&& ( *itUnaryExprs_3ead== unaryExprs_3eab))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_event_3e83.push_back( event_3e87);
		_argDeclBase_3e8c.push_back( argDeclBase_3e90);
		_localVar_3e95.push_back( localVar_3e99);
		_context_3e9e.push_back( context_3ea2);
		_unaryExprs_3ea7.push_back( unaryExprs_3eab);
	}
	return isUnique;
}

bool FallingEdge_3e70::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool FallingEdge_3e70::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, SFC::Arg& Context, CyberComposition::Simulink::Event& Event, SFC::LocalVar& LocalVar, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	std::string trigger = Event.Trigger();
Gz_guard = trigger == "FALLING_EDGE_EVENT";;
	return Gz_guard;
}

void FallingEdge_3e70::processInputPackets( const Packets_t& events_3e71, const Packets_t& argDeclBases_3e73, const Packets_t& localVars_3e76, const Packets_t& contexts_3e79, const Packets_t& unaryExprss_3e7c)
{
	for( Packets_t::const_iterator itEvent_3e84= events_3e71.begin(), itArgDeclBase_3e8d= argDeclBases_3e73.begin(), itLocalVar_3e96= localVars_3e76.begin(), itContext_3e9f= contexts_3e79.begin(), itUnaryExprs_3ea8= unaryExprss_3e7c.begin(); itEvent_3e84!= events_3e71.end(), itArgDeclBase_3e8d!= argDeclBases_3e73.end(), itLocalVar_3e96!= localVars_3e76.end(), itContext_3e9f!= contexts_3e79.end(), itUnaryExprs_3ea8!= unaryExprss_3e7c.end(); ++itEvent_3e84, ++itArgDeclBase_3e8d, ++itLocalVar_3e96, ++itContext_3e9f, ++itUnaryExprs_3ea8)
	{
		bool isUnique= isInputUnique( *itEvent_3e84, *itArgDeclBase_3e8d, *itLocalVar_3e96, *itContext_3e9f, *itUnaryExprs_3ea8);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itEvent_3e84, *itArgDeclBase_3e8d, *itLocalVar_3e96, *itContext_3e9f, *itUnaryExprs_3ea8);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_3eb5, currMatch.localVar_3eb6, currMatch.context_3eb7, currMatch.unaryExprs_3eb8);
	}
}

bool FallingEdge_3e70::patternMatcher( const Udm::Object& event_3e85, const Udm::Object& argDeclBase_3e8e, const Udm::Object& localVar_3e97, const Udm::Object& context_3ea0, const Udm::Object& unaryExprs_3ea9)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( event_3e85.type(), CyberComposition::Simulink::Event::meta))
			continue;
		CyberComposition::Simulink::Event event_3e8a= CyberComposition::Simulink::Event::Cast( event_3e85);
		if( false== Uml::IsDerivedFrom( argDeclBase_3e8e.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_3e93= SFC::ArgDeclBase::Cast( argDeclBase_3e8e);
		if( false== Uml::IsDerivedFrom( localVar_3e97.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_3e9c= SFC::LocalVar::Cast( localVar_3e97);
		if( false== Uml::IsDerivedFrom( context_3ea0.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_3ea5= SFC::Arg::Cast( context_3ea0);
		if( false== Uml::IsDerivedFrom( unaryExprs_3ea9.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_3eae= SFC::UnaryExprs::Cast( unaryExprs_3ea9);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3eb3;
		if( !isValidBound(boundObjs_3eb3, event_3e8a, true))
			continue;
		currMatch.event_3eb4= event_3e8a;
		if( !isValidBound(boundObjs_3eb3, argDeclBase_3e93, true))
			continue;
		currMatch.argDeclBase_3eb5= argDeclBase_3e93;
		if( !isValidBound(boundObjs_3eb3, localVar_3e9c, true))
			continue;
		currMatch.localVar_3eb6= localVar_3e9c;
		if( !isValidBound(boundObjs_3eb3, context_3ea5, true))
			continue;
		currMatch.context_3eb7= context_3ea5;
		if( !isValidBound(boundObjs_3eb3, unaryExprs_3eae, true))
			continue;
		currMatch.unaryExprs_3eb8= unaryExprs_3eae;
		bool Gz_guard= isGuardTrue( currMatch.argDeclBase_3eb5, currMatch.context_3eb7, currMatch.event_3eb4, currMatch.localVar_3eb6, currMatch.unaryExprs_3eb8);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void FallingEdge_3e70::outputAppender( const SFC::ArgDeclBase& argDeclBase_3ebe, const SFC::LocalVar& localVar_3ec0, const SFC::Arg& context_3ec2, const SFC::UnaryExprs& unaryExprs_3ec4)
{
	_argDeclBase_3e7f->push_back( argDeclBase_3ebe);
	_localVar_3e80->push_back( localVar_3ec0);
	_context_3e81->push_back( context_3ec2);
	_unaryExprs_3e82->push_back( unaryExprs_3ec4);
}

bool EitherEdge_3ec6::operator()( const Packets_t& events_3ec7, const Packets_t& argDeclBases_3ec9, const Packets_t& localVars_3ecc, const Packets_t& contexts_3ecf, const Packets_t& unaryExprss_3ed2, Packets_t& argDeclBases_3ecb, Packets_t& localVars_3ece, Packets_t& contexts_3ed1, Packets_t& unaryExprss_3ed4)
{
#ifdef PRINT_INFO
	printLog( "EitherEdge_3ec6" );
#endif
	_argDeclBase_3ed5= &argDeclBases_3ecb;
	_localVar_3ed6= &localVars_3ece;
	_context_3ed7= &contexts_3ed1;
	_unaryExprs_3ed8= &unaryExprss_3ed4;
	processInputPackets( events_3ec7, argDeclBases_3ec9, localVars_3ecc, contexts_3ecf, unaryExprss_3ed2);
	if( false== _matches.empty())
		return true;
	return false;
}

bool EitherEdge_3ec6::isInputUnique( const Udm::Object& event_3edd, const Udm::Object& argDeclBase_3ee6, const Udm::Object& localVar_3eef, const Udm::Object& context_3ef8, const Udm::Object& unaryExprs_3f01)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itEvent_3edf= _event_3ed9.begin(), itArgDeclBase_3ee8= _argDeclBase_3ee2.begin(), itLocalVar_3ef1= _localVar_3eeb.begin(), itContext_3efa= _context_3ef4.begin(), itUnaryExprs_3f03= _unaryExprs_3efd.begin(); itEvent_3edf!= _event_3ed9.end(), itArgDeclBase_3ee8!= _argDeclBase_3ee2.end(), itLocalVar_3ef1!= _localVar_3eeb.end(), itContext_3efa!= _context_3ef4.end(), itUnaryExprs_3f03!= _unaryExprs_3efd.end(); ++itEvent_3edf, ++itArgDeclBase_3ee8, ++itLocalVar_3ef1, ++itContext_3efa, ++itUnaryExprs_3f03)
	{
		if( ( *itEvent_3edf== event_3edd)&& ( *itArgDeclBase_3ee8== argDeclBase_3ee6)&& ( *itLocalVar_3ef1== localVar_3eef)&& ( *itContext_3efa== context_3ef8)&& ( *itUnaryExprs_3f03== unaryExprs_3f01))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_event_3ed9.push_back( event_3edd);
		_argDeclBase_3ee2.push_back( argDeclBase_3ee6);
		_localVar_3eeb.push_back( localVar_3eef);
		_context_3ef4.push_back( context_3ef8);
		_unaryExprs_3efd.push_back( unaryExprs_3f01);
	}
	return isUnique;
}

bool EitherEdge_3ec6::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool EitherEdge_3ec6::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, SFC::Arg& Context, CyberComposition::Simulink::Event& Event, SFC::LocalVar& LocalVar, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	std::string trigger = Event.Trigger();
Gz_guard = trigger == "EITHER_EDGE_EVENT";;
	return Gz_guard;
}

void EitherEdge_3ec6::processInputPackets( const Packets_t& events_3ec7, const Packets_t& argDeclBases_3ec9, const Packets_t& localVars_3ecc, const Packets_t& contexts_3ecf, const Packets_t& unaryExprss_3ed2)
{
	for( Packets_t::const_iterator itEvent_3eda= events_3ec7.begin(), itArgDeclBase_3ee3= argDeclBases_3ec9.begin(), itLocalVar_3eec= localVars_3ecc.begin(), itContext_3ef5= contexts_3ecf.begin(), itUnaryExprs_3efe= unaryExprss_3ed2.begin(); itEvent_3eda!= events_3ec7.end(), itArgDeclBase_3ee3!= argDeclBases_3ec9.end(), itLocalVar_3eec!= localVars_3ecc.end(), itContext_3ef5!= contexts_3ecf.end(), itUnaryExprs_3efe!= unaryExprss_3ed2.end(); ++itEvent_3eda, ++itArgDeclBase_3ee3, ++itLocalVar_3eec, ++itContext_3ef5, ++itUnaryExprs_3efe)
	{
		bool isUnique= isInputUnique( *itEvent_3eda, *itArgDeclBase_3ee3, *itLocalVar_3eec, *itContext_3ef5, *itUnaryExprs_3efe);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itEvent_3eda, *itArgDeclBase_3ee3, *itLocalVar_3eec, *itContext_3ef5, *itUnaryExprs_3efe);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_3f0b, currMatch.localVar_3f0c, currMatch.context_3f0d, currMatch.unaryExprs_3f0e);
	}
}

bool EitherEdge_3ec6::patternMatcher( const Udm::Object& event_3edb, const Udm::Object& argDeclBase_3ee4, const Udm::Object& localVar_3eed, const Udm::Object& context_3ef6, const Udm::Object& unaryExprs_3eff)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( event_3edb.type(), CyberComposition::Simulink::Event::meta))
			continue;
		CyberComposition::Simulink::Event event_3ee0= CyberComposition::Simulink::Event::Cast( event_3edb);
		if( false== Uml::IsDerivedFrom( argDeclBase_3ee4.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_3ee9= SFC::ArgDeclBase::Cast( argDeclBase_3ee4);
		if( false== Uml::IsDerivedFrom( localVar_3eed.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_3ef2= SFC::LocalVar::Cast( localVar_3eed);
		if( false== Uml::IsDerivedFrom( context_3ef6.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_3efb= SFC::Arg::Cast( context_3ef6);
		if( false== Uml::IsDerivedFrom( unaryExprs_3eff.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_3f04= SFC::UnaryExprs::Cast( unaryExprs_3eff);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3f09;
		if( !isValidBound(boundObjs_3f09, event_3ee0, true))
			continue;
		currMatch.event_3f0a= event_3ee0;
		if( !isValidBound(boundObjs_3f09, argDeclBase_3ee9, true))
			continue;
		currMatch.argDeclBase_3f0b= argDeclBase_3ee9;
		if( !isValidBound(boundObjs_3f09, localVar_3ef2, true))
			continue;
		currMatch.localVar_3f0c= localVar_3ef2;
		if( !isValidBound(boundObjs_3f09, context_3efb, true))
			continue;
		currMatch.context_3f0d= context_3efb;
		if( !isValidBound(boundObjs_3f09, unaryExprs_3f04, true))
			continue;
		currMatch.unaryExprs_3f0e= unaryExprs_3f04;
		bool Gz_guard= isGuardTrue( currMatch.argDeclBase_3f0b, currMatch.context_3f0d, currMatch.event_3f0a, currMatch.localVar_3f0c, currMatch.unaryExprs_3f0e);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void EitherEdge_3ec6::outputAppender( const SFC::ArgDeclBase& argDeclBase_3f14, const SFC::LocalVar& localVar_3f16, const SFC::Arg& context_3f18, const SFC::UnaryExprs& unaryExprs_3f1a)
{
	_argDeclBase_3ed5->push_back( argDeclBase_3f14);
	_localVar_3ed6->push_back( localVar_3f16);
	_context_3ed7->push_back( context_3f18);
	_unaryExprs_3ed8->push_back( unaryExprs_3f1a);
}

void RisingEdge_3f1c::operator()( const Packets_t& argDeclBases_3f1d, const Packets_t& localVars_3f1f, const Packets_t& contexts_3f21, const Packets_t& unaryExprss_3f23)
{
#ifdef PRINT_INFO
	printLog( "RisingEdge_3f1c" );
#endif
	RTTGenerator::Instance()->generateRule(3681, "RisingEdge");
	processInputPackets( argDeclBases_3f1d, localVars_3f1f, contexts_3f21, unaryExprss_3f23);
}

bool RisingEdge_3f1c::isInputUnique( const Udm::Object& argDeclBase_3f29, const Udm::Object& localVar_3f32, const Udm::Object& context_3f3b, const Udm::Object& unaryExprs_3f44)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_3f2b= _argDeclBase_3f25.begin(), itLocalVar_3f34= _localVar_3f2e.begin(), itContext_3f3d= _context_3f37.begin(), itUnaryExprs_3f46= _unaryExprs_3f40.begin(); itArgDeclBase_3f2b!= _argDeclBase_3f25.end(), itLocalVar_3f34!= _localVar_3f2e.end(), itContext_3f3d!= _context_3f37.end(), itUnaryExprs_3f46!= _unaryExprs_3f40.end(); ++itArgDeclBase_3f2b, ++itLocalVar_3f34, ++itContext_3f3d, ++itUnaryExprs_3f46)
	{
		if( ( *itArgDeclBase_3f2b== argDeclBase_3f29)&& ( *itLocalVar_3f34== localVar_3f32)&& ( *itContext_3f3d== context_3f3b)&& ( *itUnaryExprs_3f46== unaryExprs_3f44))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_3f25.push_back( argDeclBase_3f29);
		_localVar_3f2e.push_back( localVar_3f32);
		_context_3f37.push_back( context_3f3b);
		_unaryExprs_3f40.push_back( unaryExprs_3f44);
	}
	return isUnique;
}

bool RisingEdge_3f1c::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void RisingEdge_3f1c::processInputPackets( const Packets_t& argDeclBases_3f1d, const Packets_t& localVars_3f1f, const Packets_t& contexts_3f21, const Packets_t& unaryExprss_3f23)
{
	for( Packets_t::const_iterator itArgDeclBase_3f26= argDeclBases_3f1d.begin(), itLocalVar_3f2f= localVars_3f1f.begin(), itContext_3f38= contexts_3f21.begin(), itUnaryExprs_3f41= unaryExprss_3f23.begin(); itArgDeclBase_3f26!= argDeclBases_3f1d.end(), itLocalVar_3f2f!= localVars_3f1f.end(), itContext_3f38!= contexts_3f21.end(), itUnaryExprs_3f41!= unaryExprss_3f23.end(); ++itArgDeclBase_3f26, ++itLocalVar_3f2f, ++itContext_3f38, ++itUnaryExprs_3f41)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_3f26, *itLocalVar_3f2f, *itContext_3f38, *itUnaryExprs_3f41);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_3f26, *itLocalVar_3f2f, *itContext_3f38, *itUnaryExprs_3f41);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool RisingEdge_3f1c::patternMatcher( const Udm::Object& argDeclBase_3f27, const Udm::Object& localVar_3f30, const Udm::Object& context_3f39, const Udm::Object& unaryExprs_3f42)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_3f27.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_3f2c= SFC::ArgDeclBase::Cast( argDeclBase_3f27);
		if( false== Uml::IsDerivedFrom( localVar_3f30.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_3f35= SFC::LocalVar::Cast( localVar_3f30);
		if( false== Uml::IsDerivedFrom( context_3f39.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_3f3e= SFC::Arg::Cast( context_3f39);
		if( false== Uml::IsDerivedFrom( unaryExprs_3f42.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_3f47= SFC::UnaryExprs::Cast( unaryExprs_3f42);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3f4c;
		if( !isValidBound(boundObjs_3f4c, argDeclBase_3f2c, true))
			continue;
		currMatch.argDeclBase_3f4d= argDeclBase_3f2c;
		if( !isValidBound(boundObjs_3f4c, localVar_3f35, true))
			continue;
		currMatch.localVar_3f4e= localVar_3f35;
		if( !isValidBound(boundObjs_3f4c, context_3f3e, true))
			continue;
		currMatch.context_3f4f= context_3f3e;
		if( !isValidBound(boundObjs_3f4c, unaryExprs_3f47, true))
			continue;
		currMatch.unaryExprs_3f50= unaryExprs_3f47;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void RisingEdge_3f1c::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newAnd_3f51= SFC::BinaryExprs::Create( currMatch.unaryExprs_3f50, SFC::UnaryExprs::meta_subexpr);
		SFC::BinaryExprs newGreaterThan_3f52= SFC::BinaryExprs::Create( newAnd_3f51, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newZero2_3f53= SFC::Int::Create( newGreaterThan_3f52, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_3f54= SFC::ArgDeclRef::Create( newGreaterThan_3f52, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newLessThan_3f55= SFC::BinaryExprs::Create( newAnd_3f51, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newZero_3f56= SFC::Int::Create( newLessThan_3f55, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newDot_3f57= SFC::BinaryExprs::Create( newLessThan_3f55, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef3_3f58= SFC::ArgDeclRef::Create( newDot_3f57, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_3f59= SFC::ArgDeclRef::Create( newDot_3f57, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs& And= newAnd_3f51;
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_3f4d;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_3f54;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_3f59;
		SFC::ArgDeclRef& ArgDeclRef3= newArgDeclRef3_3f58;
		SFC::Arg& Context= currMatch.context_3f4f;
		SFC::BinaryExprs& Dot= newDot_3f57;
		SFC::BinaryExprs& GreaterThan= newGreaterThan_3f52;
		SFC::BinaryExprs& LessThan= newLessThan_3f55;
		SFC::LocalVar& LocalVar= currMatch.localVar_3f4e;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_3f50;
		SFC::Int& Zero= newZero_3f56;
		SFC::Int& Zero2= newZero2_3f53;
		{
LessThan.op() = "<=";
};
		{
And.op() = "&&";
};
		{
GreaterThan.op() = ">";
};
		{
Dot.op() = ".";
};
		{
Zero.val() = 0;
};
		{
Zero2.val() = 0;
};
		newArgDeclRef2_3f59.argdecl()= currMatch.localVar_3f4e;
		newArgDeclRef_3f54.argdecl()= currMatch.argDeclBase_3f4d;
		newArgDeclRef3_3f58.argdecl()= currMatch.context_3f4f;
	}
}

void FallingEdge_3f5a::operator()( const Packets_t& argDeclBases_3f5b, const Packets_t& localVars_3f5d, const Packets_t& contexts_3f5f, const Packets_t& unaryExprss_3f61)
{
#ifdef PRINT_INFO
	printLog( "FallingEdge_3f5a" );
#endif
	RTTGenerator::Instance()->generateRule(3713, "FallingEdge");
	processInputPackets( argDeclBases_3f5b, localVars_3f5d, contexts_3f5f, unaryExprss_3f61);
}

bool FallingEdge_3f5a::isInputUnique( const Udm::Object& argDeclBase_3f67, const Udm::Object& localVar_3f70, const Udm::Object& context_3f79, const Udm::Object& unaryExprs_3f82)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_3f69= _argDeclBase_3f63.begin(), itLocalVar_3f72= _localVar_3f6c.begin(), itContext_3f7b= _context_3f75.begin(), itUnaryExprs_3f84= _unaryExprs_3f7e.begin(); itArgDeclBase_3f69!= _argDeclBase_3f63.end(), itLocalVar_3f72!= _localVar_3f6c.end(), itContext_3f7b!= _context_3f75.end(), itUnaryExprs_3f84!= _unaryExprs_3f7e.end(); ++itArgDeclBase_3f69, ++itLocalVar_3f72, ++itContext_3f7b, ++itUnaryExprs_3f84)
	{
		if( ( *itArgDeclBase_3f69== argDeclBase_3f67)&& ( *itLocalVar_3f72== localVar_3f70)&& ( *itContext_3f7b== context_3f79)&& ( *itUnaryExprs_3f84== unaryExprs_3f82))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_3f63.push_back( argDeclBase_3f67);
		_localVar_3f6c.push_back( localVar_3f70);
		_context_3f75.push_back( context_3f79);
		_unaryExprs_3f7e.push_back( unaryExprs_3f82);
	}
	return isUnique;
}

bool FallingEdge_3f5a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void FallingEdge_3f5a::processInputPackets( const Packets_t& argDeclBases_3f5b, const Packets_t& localVars_3f5d, const Packets_t& contexts_3f5f, const Packets_t& unaryExprss_3f61)
{
	for( Packets_t::const_iterator itArgDeclBase_3f64= argDeclBases_3f5b.begin(), itLocalVar_3f6d= localVars_3f5d.begin(), itContext_3f76= contexts_3f5f.begin(), itUnaryExprs_3f7f= unaryExprss_3f61.begin(); itArgDeclBase_3f64!= argDeclBases_3f5b.end(), itLocalVar_3f6d!= localVars_3f5d.end(), itContext_3f76!= contexts_3f5f.end(), itUnaryExprs_3f7f!= unaryExprss_3f61.end(); ++itArgDeclBase_3f64, ++itLocalVar_3f6d, ++itContext_3f76, ++itUnaryExprs_3f7f)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_3f64, *itLocalVar_3f6d, *itContext_3f76, *itUnaryExprs_3f7f);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_3f64, *itLocalVar_3f6d, *itContext_3f76, *itUnaryExprs_3f7f);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool FallingEdge_3f5a::patternMatcher( const Udm::Object& argDeclBase_3f65, const Udm::Object& localVar_3f6e, const Udm::Object& context_3f77, const Udm::Object& unaryExprs_3f80)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_3f65.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_3f6a= SFC::ArgDeclBase::Cast( argDeclBase_3f65);
		if( false== Uml::IsDerivedFrom( localVar_3f6e.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_3f73= SFC::LocalVar::Cast( localVar_3f6e);
		if( false== Uml::IsDerivedFrom( context_3f77.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_3f7c= SFC::Arg::Cast( context_3f77);
		if( false== Uml::IsDerivedFrom( unaryExprs_3f80.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_3f85= SFC::UnaryExprs::Cast( unaryExprs_3f80);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3f8a;
		if( !isValidBound(boundObjs_3f8a, argDeclBase_3f6a, true))
			continue;
		currMatch.argDeclBase_3f8b= argDeclBase_3f6a;
		if( !isValidBound(boundObjs_3f8a, localVar_3f73, true))
			continue;
		currMatch.localVar_3f8c= localVar_3f73;
		if( !isValidBound(boundObjs_3f8a, context_3f7c, true))
			continue;
		currMatch.context_3f8d= context_3f7c;
		if( !isValidBound(boundObjs_3f8a, unaryExprs_3f85, true))
			continue;
		currMatch.unaryExprs_3f8e= unaryExprs_3f85;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void FallingEdge_3f5a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newAnd_3f8f= SFC::BinaryExprs::Create( currMatch.unaryExprs_3f8e, SFC::UnaryExprs::meta_subexpr);
		SFC::BinaryExprs newLessThan_3f90= SFC::BinaryExprs::Create( newAnd_3f8f, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newZero2_3f91= SFC::Int::Create( newLessThan_3f90, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newGreaterThan_3f92= SFC::BinaryExprs::Create( newAnd_3f8f, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newDot_3f93= SFC::BinaryExprs::Create( newGreaterThan_3f92, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newZero_3f94= SFC::Int::Create( newGreaterThan_3f92, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_3f95= SFC::ArgDeclRef::Create( newLessThan_3f90, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef3_3f96= SFC::ArgDeclRef::Create( newDot_3f93, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_3f97= SFC::ArgDeclRef::Create( newDot_3f93, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs& And= newAnd_3f8f;
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_3f8b;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_3f95;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_3f97;
		SFC::ArgDeclRef& ArgDeclRef3= newArgDeclRef3_3f96;
		SFC::Arg& Context= currMatch.context_3f8d;
		SFC::BinaryExprs& Dot= newDot_3f93;
		SFC::BinaryExprs& GreaterThan= newGreaterThan_3f92;
		SFC::BinaryExprs& LessThan= newLessThan_3f90;
		SFC::LocalVar& LocalVar= currMatch.localVar_3f8c;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_3f8e;
		SFC::Int& Zero= newZero_3f94;
		SFC::Int& Zero2= newZero2_3f91;
		{
Zero2.val() = 0;
};
		{
Zero.val() = 0;
};
		{
Dot.op() = ".";
};
		{
And.op() = "&&";
};
		{
LessThan.op() = "<";
};
		{
GreaterThan.op() = ">=";
};
		newArgDeclRef2_3f97.argdecl()= currMatch.localVar_3f8c;
		newArgDeclRef3_3f96.argdecl()= currMatch.context_3f8d;
		newArgDeclRef_3f95.argdecl()= currMatch.argDeclBase_3f8b;
	}
}

void EitherEdge_3f98::operator()( const Packets_t& argDeclBases_3f99, const Packets_t& localVars_3f9c, const Packets_t& contexts_3f9f, const Packets_t& unaryExprss_3fa2, Packets_t& argDeclBases_3f9b, Packets_t& localVars_3f9e, Packets_t& contexts_3fa1, Packets_t& leftUnaryExprss_3fa4, Packets_t& rightUnaryExprss_3fa5)
{
#ifdef PRINT_INFO
	printLog( "EitherEdge_3f98" );
#endif
	RTTGenerator::Instance()->generateRule(3745, "EitherEdge");
	_argDeclBase_3fa6= &argDeclBases_3f9b;
	_localVar_3fa7= &localVars_3f9e;
	_context_3fa8= &contexts_3fa1;
	_leftUnaryExprs_3fa9= &leftUnaryExprss_3fa4;
	_rightUnaryExprs_3faa= &rightUnaryExprss_3fa5;
	processInputPackets( argDeclBases_3f99, localVars_3f9c, contexts_3f9f, unaryExprss_3fa2);
}

bool EitherEdge_3f98::isInputUnique( const Udm::Object& argDeclBase_3faf, const Udm::Object& localVar_3fb8, const Udm::Object& context_3fc1, const Udm::Object& unaryExprs_3fca)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_3fb1= _argDeclBase_3fab.begin(), itLocalVar_3fba= _localVar_3fb4.begin(), itContext_3fc3= _context_3fbd.begin(), itUnaryExprs_3fcc= _unaryExprs_3fc6.begin(); itArgDeclBase_3fb1!= _argDeclBase_3fab.end(), itLocalVar_3fba!= _localVar_3fb4.end(), itContext_3fc3!= _context_3fbd.end(), itUnaryExprs_3fcc!= _unaryExprs_3fc6.end(); ++itArgDeclBase_3fb1, ++itLocalVar_3fba, ++itContext_3fc3, ++itUnaryExprs_3fcc)
	{
		if( ( *itArgDeclBase_3fb1== argDeclBase_3faf)&& ( *itLocalVar_3fba== localVar_3fb8)&& ( *itContext_3fc3== context_3fc1)&& ( *itUnaryExprs_3fcc== unaryExprs_3fca))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_3fab.push_back( argDeclBase_3faf);
		_localVar_3fb4.push_back( localVar_3fb8);
		_context_3fbd.push_back( context_3fc1);
		_unaryExprs_3fc6.push_back( unaryExprs_3fca);
	}
	return isUnique;
}

bool EitherEdge_3f98::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void EitherEdge_3f98::processInputPackets( const Packets_t& argDeclBases_3f99, const Packets_t& localVars_3f9c, const Packets_t& contexts_3f9f, const Packets_t& unaryExprss_3fa2)
{
	for( Packets_t::const_iterator itArgDeclBase_3fac= argDeclBases_3f99.begin(), itLocalVar_3fb5= localVars_3f9c.begin(), itContext_3fbe= contexts_3f9f.begin(), itUnaryExprs_3fc7= unaryExprss_3fa2.begin(); itArgDeclBase_3fac!= argDeclBases_3f99.end(), itLocalVar_3fb5!= localVars_3f9c.end(), itContext_3fbe!= contexts_3f9f.end(), itUnaryExprs_3fc7!= unaryExprss_3fa2.end(); ++itArgDeclBase_3fac, ++itLocalVar_3fb5, ++itContext_3fbe, ++itUnaryExprs_3fc7)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_3fac, *itLocalVar_3fb5, *itContext_3fbe, *itUnaryExprs_3fc7);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_3fac, *itLocalVar_3fb5, *itContext_3fbe, *itUnaryExprs_3fc7);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool EitherEdge_3f98::patternMatcher( const Udm::Object& argDeclBase_3fad, const Udm::Object& localVar_3fb6, const Udm::Object& context_3fbf, const Udm::Object& unaryExprs_3fc8)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_3fad.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_3fb2= SFC::ArgDeclBase::Cast( argDeclBase_3fad);
		if( false== Uml::IsDerivedFrom( localVar_3fb6.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_3fbb= SFC::LocalVar::Cast( localVar_3fb6);
		if( false== Uml::IsDerivedFrom( context_3fbf.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_3fc4= SFC::Arg::Cast( context_3fbf);
		if( false== Uml::IsDerivedFrom( unaryExprs_3fc8.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_3fcd= SFC::UnaryExprs::Cast( unaryExprs_3fc8);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_3fd2;
		if( !isValidBound(boundObjs_3fd2, argDeclBase_3fb2, true))
			continue;
		currMatch.argDeclBase_3fd3= argDeclBase_3fb2;
		if( !isValidBound(boundObjs_3fd2, localVar_3fbb, true))
			continue;
		currMatch.localVar_3fd4= localVar_3fbb;
		if( !isValidBound(boundObjs_3fd2, context_3fc4, true))
			continue;
		currMatch.context_3fd5= context_3fc4;
		if( !isValidBound(boundObjs_3fd2, unaryExprs_3fcd, true))
			continue;
		currMatch.unaryExprs_3fd6= unaryExprs_3fcd;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void EitherEdge_3f98::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newOr_3fd7= SFC::BinaryExprs::Create( currMatch.unaryExprs_3fd6, SFC::UnaryExprs::meta_subexpr);
		SFC::UnaryExprs newLeftUnaryExprs_3fd8= SFC::UnaryExprs::Create( newOr_3fd7, SFC::BinaryExprs::meta_leftexpr);
		SFC::UnaryExprs newRightUnaryExprs_3fd9= SFC::UnaryExprs::Create( newOr_3fd7, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_3fd3;
		SFC::Arg& Context= currMatch.context_3fd5;
		SFC::UnaryExprs& LeftUnaryExprs= newLeftUnaryExprs_3fd8;
		SFC::LocalVar& LocalVar= currMatch.localVar_3fd4;
		SFC::BinaryExprs& Or= newOr_3fd7;
		SFC::UnaryExprs& RightUnaryExprs= newRightUnaryExprs_3fd9;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_3fd6;
		{
Or.op() = "||";
};
		{
LeftUnaryExprs.op() = "";
};
		{
RightUnaryExprs.op() = "";
};
		outputAppender( currMatch.argDeclBase_3fd3, currMatch.localVar_3fd4, currMatch.context_3fd5, newLeftUnaryExprs_3fd8, newRightUnaryExprs_3fd9);
	}
}

void EitherEdge_3f98::outputAppender( const SFC::ArgDeclBase& argDeclBase_3fda, const SFC::LocalVar& localVar_3fdc, const SFC::Arg& context_3fde, const SFC::UnaryExprs& leftUnaryExprs_3fe0, const SFC::UnaryExprs& rightUnaryExprs_3fe2)
{
	_argDeclBase_3fa6->push_back( argDeclBase_3fda);
	_localVar_3fa7->push_back( localVar_3fdc);
	_context_3fa8->push_back( context_3fde);
	_leftUnaryExprs_3fa9->push_back( leftUnaryExprs_3fe0);
	_rightUnaryExprs_3faa->push_back( rightUnaryExprs_3fe2);
}

void GetTriggerPort_403b::operator()( const Packets_t& subsystems_403c, const Packets_t& blocks_403f, const Packets_t& mains_4042, Packets_t& subsystems_403e, Packets_t& triggerPorts_4041, Packets_t& mains_4044)
{
#ifdef PRINT_INFO
	printLog( "GetTriggerPort_403b" );
#endif
	RTTGenerator::Instance()->generateRule(3759, "GetTriggerPort");
	_subsystem_4045= &subsystems_403e;
	_triggerPort_4046= &triggerPorts_4041;
	_main_4047= &mains_4044;
	processInputPackets( subsystems_403c, blocks_403f, mains_4042);
}

bool GetTriggerPort_403b::isInputUnique( const Udm::Object& subsystem_404c, const Udm::Object& block_4055, const Udm::Object& main_405e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_404e= _subsystem_4048.begin(), itBlock_4057= _block_4051.begin(), itMain_4060= _main_405a.begin(); itSubsystem_404e!= _subsystem_4048.end(), itBlock_4057!= _block_4051.end(), itMain_4060!= _main_405a.end(); ++itSubsystem_404e, ++itBlock_4057, ++itMain_4060)
	{
		if( ( *itSubsystem_404e== subsystem_404c)&& ( *itBlock_4057== block_4055)&& ( *itMain_4060== main_405e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_4048.push_back( subsystem_404c);
		_block_4051.push_back( block_4055);
		_main_405a.push_back( main_405e);
	}
	return isUnique;
}

bool GetTriggerPort_403b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetTriggerPort_403b::processInputPackets( const Packets_t& subsystems_403c, const Packets_t& blocks_403f, const Packets_t& mains_4042)
{
	for( Packets_t::const_iterator itSubsystem_4049= subsystems_403c.begin(), itBlock_4052= blocks_403f.begin(), itMain_405b= mains_4042.begin(); itSubsystem_4049!= subsystems_403c.end(), itBlock_4052!= blocks_403f.end(), itMain_405b!= mains_4042.end(); ++itSubsystem_4049, ++itBlock_4052, ++itMain_405b)
	{
		bool isUnique= isInputUnique( *itSubsystem_4049, *itBlock_4052, *itMain_405b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_4049, *itBlock_4052, *itMain_405b);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetTriggerPort_403b::patternMatcher( const Udm::Object& subsystem_404a, const Udm::Object& block_4053, const Udm::Object& main_405c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_404a.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_404f= CyberComposition::Simulink::Subsystem::Cast( subsystem_404a);
		if( false== Uml::IsDerivedFrom( block_4053.type(), CyberComposition::Simulink::Block::meta))
			continue;
		CyberComposition::Simulink::Block block_4058= CyberComposition::Simulink::Block::Cast( block_4053);
		if( false== Uml::IsDerivedFrom( main_405c.type(), SFC::Function::meta))
			continue;
		SFC::Function main_4061= SFC::Function::Cast( main_405c);
		set< CyberComposition::Simulink::TriggerPort> triggerPorts_4063= block_4058.TriggerPort_kind_children();
		for( set< CyberComposition::Simulink::TriggerPort>::const_iterator itTriggerPort_4064= triggerPorts_4063.begin(); itTriggerPort_4064!= triggerPorts_4063.end(); ++itTriggerPort_4064)
		{
			CyberComposition::Simulink::TriggerPort currTriggerPort_4065= *itTriggerPort_4064;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_4069;
			if( !isValidBound(boundObjs_4069, subsystem_404f, true))
				continue;
			currMatch.subsystem_406a= subsystem_404f;
			if( !isValidBound(boundObjs_4069, block_4058, true))
				continue;
			currMatch.block_406b= block_4058;
			if( !isValidBound(boundObjs_4069, main_4061, true))
				continue;
			currMatch.main_406c= main_4061;
			if( !isValidBound(boundObjs_4069, currTriggerPort_4065, false))
				continue;
			currMatch.triggerPort_406d= currTriggerPort_4065;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetTriggerPort_403b::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_406a, currMatch.triggerPort_406d, currMatch.main_406c);
	}
}

void GetTriggerPort_403b::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_406e, const CyberComposition::Simulink::TriggerPort& triggerPort_4070, const SFC::Function& main_4072)
{
	_subsystem_4045->push_back( subsystem_406e);
	_triggerPort_4046->push_back( triggerPort_4070);
	_main_4047->push_back( main_4072);
}

void AssignCondValLocalVar_4074::operator()( const Packets_t& subsystems_4075, const Packets_t& triggerPorts_4078, const Packets_t& functions_407d, Packets_t& subsystems_4077, Packets_t& triggerPorts_407a, Packets_t& argDeclBases_407b, Packets_t& dTs_407c, Packets_t& functions_407f)
{
#ifdef PRINT_INFO
	printLog( "AssignCondValLocalVar_4074" );
#endif
	RTTGenerator::Instance()->generateRule(3765, "AssignCondValLocalVar");
	_subsystem_4080= &subsystems_4077;
	_triggerPort_4081= &triggerPorts_407a;
	_argDeclBase_4082= &argDeclBases_407b;
	_dT_4083= &dTs_407c;
	_function_4084= &functions_407f;
	processInputPackets( subsystems_4075, triggerPorts_4078, functions_407d);
}

bool AssignCondValLocalVar_4074::isInputUnique( const Udm::Object& subsystem_4089, const Udm::Object& triggerPort_4092, const Udm::Object& function_409b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_408b= _subsystem_4085.begin(), itTriggerPort_4094= _triggerPort_408e.begin(), itFunction_409d= _function_4097.begin(); itSubsystem_408b!= _subsystem_4085.end(), itTriggerPort_4094!= _triggerPort_408e.end(), itFunction_409d!= _function_4097.end(); ++itSubsystem_408b, ++itTriggerPort_4094, ++itFunction_409d)
	{
		if( ( *itSubsystem_408b== subsystem_4089)&& ( *itTriggerPort_4094== triggerPort_4092)&& ( *itFunction_409d== function_409b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_4085.push_back( subsystem_4089);
		_triggerPort_408e.push_back( triggerPort_4092);
		_function_4097.push_back( function_409b);
	}
	return isUnique;
}

bool AssignCondValLocalVar_4074::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void AssignCondValLocalVar_4074::processInputPackets( const Packets_t& subsystems_4075, const Packets_t& triggerPorts_4078, const Packets_t& functions_407d)
{
	for( Packets_t::const_iterator itSubsystem_4086= subsystems_4075.begin(), itTriggerPort_408f= triggerPorts_4078.begin(), itFunction_4098= functions_407d.begin(); itSubsystem_4086!= subsystems_4075.end(), itTriggerPort_408f!= triggerPorts_4078.end(), itFunction_4098!= functions_407d.end(); ++itSubsystem_4086, ++itTriggerPort_408f, ++itFunction_4098)
	{
		bool isUnique= isInputUnique( *itSubsystem_4086, *itTriggerPort_408f, *itFunction_4098);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_4086, *itTriggerPort_408f, *itFunction_4098);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AssignCondValLocalVar_4074::patternMatcher( const Udm::Object& subsystem_4087, const Udm::Object& triggerPort_4090, const Udm::Object& function_4099)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_4087.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_408c= CyberComposition::Simulink::Subsystem::Cast( subsystem_4087);
		if( false== Uml::IsDerivedFrom( triggerPort_4090.type(), CyberComposition::Simulink::SF_Port::meta))
			continue;
		CyberComposition::Simulink::SF_Port triggerPort_4095= CyberComposition::Simulink::SF_Port::Cast( triggerPort_4090);
		if( false== Uml::IsDerivedFrom( function_4099.type(), SFC::Function::meta))
			continue;
		SFC::Function function_409e= SFC::Function::Cast( function_4099);
		SFC::ArgDeclBase argDeclBase_40a0= triggerPort_4095.argdecl();
		if( !argDeclBase_40a0)
			continue;
		SFC::DT dT_40a1= argDeclBase_40a0.dt();
		if( !dT_40a1)
			continue;
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_40a5;
		if( !isValidBound(boundObjs_40a5, subsystem_408c, true))
			continue;
		currMatch.subsystem_40a6= subsystem_408c;
		if( !isValidBound(boundObjs_40a5, triggerPort_4095, true))
			continue;
		currMatch.triggerPort_40a7= triggerPort_4095;
		if( !isValidBound(boundObjs_40a5, function_409e, true))
			continue;
		currMatch.function_40a8= function_409e;
		if( !isValidBound(boundObjs_40a5, argDeclBase_40a0, false))
			continue;
		currMatch.argDeclBase_40a9= argDeclBase_40a0;
		if( !isValidBound(boundObjs_40a5, dT_40a1, false))
			continue;
		currMatch.dT_40aa= dT_40a1;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void AssignCondValLocalVar_4074::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_40a6, currMatch.triggerPort_40a7, currMatch.argDeclBase_40a9, currMatch.dT_40aa, currMatch.function_40a8);
	}
}

void AssignCondValLocalVar_4074::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_40ab, const CyberComposition::Simulink::SF_Port& triggerPort_40ad, const SFC::ArgDeclBase& argDeclBase_40af, const SFC::DT& dT_40b1, const SFC::Function& function_40b3)
{
	_subsystem_4080->push_back( subsystem_40ab);
	_triggerPort_4081->push_back( triggerPort_40ad);
	_argDeclBase_4082->push_back( argDeclBase_40af);
	_dT_4083->push_back( dT_40b1);
	_function_4084->push_back( function_40b3);
}

void IsTriggered_40c3::operator()( const Packets_t& systems_40c4, const Packets_t& childSubsystems_40c6, const Packets_t& systemFunctions_40c8, Packets_t& systems_40ca, Packets_t& childSubsystems_40cb, Packets_t& systemFunctions_40cc, Packets_t& systems_40cd, Packets_t& childSubsystems_40ce, Packets_t& systemFunctions_40cf)
{
#ifdef PRINT_INFO
	printLog( "IsTriggered_40c3" );
#endif
	_system_40d0= &systems_40ca;
	_childSubsystem_40d1= &childSubsystems_40cb;
	_systemFunction_40d2= &systemFunctions_40cc;
	_system_40d3= &systems_40cd;
	_childSubsystem_40d4= &childSubsystems_40ce;
	_systemFunction_40d5= &systemFunctions_40cf;
	for( Packets_t::const_iterator itsystem_40d7= systems_40c4.begin(), itchildSubsystem_40de= childSubsystems_40c6.begin(), itsystemFunction_40e5= systemFunctions_40c8.begin(); itsystem_40d7!= systems_40c4.end(), itchildSubsystem_40de!= childSubsystems_40c6.end(), itsystemFunction_40e5!= systemFunctions_40c8.end(); ++itsystem_40d7, ++itchildSubsystem_40de, ++itsystemFunction_40e5)
	{
		bool isUnique= isInputUnique( *itsystem_40d7, *itchildSubsystem_40de, *itsystemFunction_40e5);
		if( !isUnique)
			continue;
		Packets_t onesystem_40db( 1, *itsystem_40d7);
		Packets_t onechildSubsystem_40e2( 1, *itchildSubsystem_40de);
		Packets_t onesystemFunction_40e9( 1, *itsystemFunction_40e5);
		executeOne( onesystem_40db, onechildSubsystem_40e2, onesystemFunction_40e9);
	}
}

void IsTriggered_40c3::executeOne( const Packets_t& systems_40c4, const Packets_t& childSubsystems_40c6, const Packets_t& systemFunctions_40c8)
{
	Packets_t subsystems_40ee;
	Packets_t blocks_40f1;
	Packets_t mains_40f4;
	HasTriggers_40eb hasTriggers_40eb;
	bool isMatchHasTriggers_40eb= hasTriggers_40eb( systems_40c4, childSubsystems_40c6, systemFunctions_40c8, subsystems_40ee, blocks_40f1, mains_40f4);
	_system_40d0->insert( _system_40d0->end(), subsystems_40ee.begin(), subsystems_40ee.end());
	_childSubsystem_40d1->insert( _childSubsystem_40d1->end(), blocks_40f1.begin(), blocks_40f1.end());
	_systemFunction_40d2->insert( _systemFunction_40d2->end(), mains_40f4.begin(), mains_40f4.end());
	if( isMatchHasTriggers_40eb)
		return;
	Packets_t subsystems_4127;
	Packets_t blocks_412a;
	Packets_t mains_412d;
	Otherwise_4124 otherwise_4124;
	bool isMatchOtherwise_4124= otherwise_4124( systems_40c4, childSubsystems_40c6, systemFunctions_40c8, subsystems_4127, blocks_412a, mains_412d);
	_system_40d3->insert( _system_40d3->end(), subsystems_4127.begin(), subsystems_4127.end());
	_childSubsystem_40d4->insert( _childSubsystem_40d4->end(), blocks_412a.begin(), blocks_412a.end());
	_systemFunction_40d5->insert( _systemFunction_40d5->end(), mains_412d.begin(), mains_412d.end());
	if( isMatchOtherwise_4124)
		return;
}

bool IsTriggered_40c3::isInputUnique( const Udm::Object& system_40d8, const Udm::Object& childSubsystem_40df, const Udm::Object& systemFunction_40e6)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itsystem_40da= _system_40d6.begin(), itchildSubsystem_40e1= _childSubsystem_40dd.begin(), itsystemFunction_40e8= _systemFunction_40e4.begin(); itsystem_40da!= _system_40d6.end(), itchildSubsystem_40e1!= _childSubsystem_40dd.end(), itsystemFunction_40e8!= _systemFunction_40e4.end(); ++itsystem_40da, ++itchildSubsystem_40e1, ++itsystemFunction_40e8)
	{
		if( ( *itsystem_40da== system_40d8)&& ( *itchildSubsystem_40e1== childSubsystem_40df)&& ( *itsystemFunction_40e8== systemFunction_40e6))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_system_40d6.push_back( system_40d8);
		_childSubsystem_40dd.push_back( childSubsystem_40df);
		_systemFunction_40e4.push_back( systemFunction_40e6);
	}
	return isUnique;
}

bool HasTriggers_40eb::operator()( const Packets_t& subsystems_40ec, const Packets_t& blocks_40ef, const Packets_t& mains_40f2, Packets_t& subsystems_40ee, Packets_t& blocks_40f1, Packets_t& mains_40f4)
{
#ifdef PRINT_INFO
	printLog( "HasTriggers_40eb" );
#endif
	_subsystem_40f5= &subsystems_40ee;
	_block_40f6= &blocks_40f1;
	_main_40f7= &mains_40f4;
	processInputPackets( subsystems_40ec, blocks_40ef, mains_40f2);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasTriggers_40eb::isInputUnique( const Udm::Object& subsystem_40fc, const Udm::Object& block_4105, const Udm::Object& main_410e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_40fe= _subsystem_40f8.begin(), itBlock_4107= _block_4101.begin(), itMain_4110= _main_410a.begin(); itSubsystem_40fe!= _subsystem_40f8.end(), itBlock_4107!= _block_4101.end(), itMain_4110!= _main_410a.end(); ++itSubsystem_40fe, ++itBlock_4107, ++itMain_4110)
	{
		if( ( *itSubsystem_40fe== subsystem_40fc)&& ( *itBlock_4107== block_4105)&& ( *itMain_4110== main_410e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_40f8.push_back( subsystem_40fc);
		_block_4101.push_back( block_4105);
		_main_410a.push_back( main_410e);
	}
	return isUnique;
}

bool HasTriggers_40eb::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void HasTriggers_40eb::processInputPackets( const Packets_t& subsystems_40ec, const Packets_t& blocks_40ef, const Packets_t& mains_40f2)
{
	for( Packets_t::const_iterator itSubsystem_40f9= subsystems_40ec.begin(), itBlock_4102= blocks_40ef.begin(), itMain_410b= mains_40f2.begin(); itSubsystem_40f9!= subsystems_40ec.end(), itBlock_4102!= blocks_40ef.end(), itMain_410b!= mains_40f2.end(); ++itSubsystem_40f9, ++itBlock_4102, ++itMain_410b)
	{
		bool isUnique= isInputUnique( *itSubsystem_40f9, *itBlock_4102, *itMain_410b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_40f9, *itBlock_4102, *itMain_410b);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_411a, currMatch.block_411b, currMatch.main_411c);
	}
}

bool HasTriggers_40eb::patternMatcher( const Udm::Object& subsystem_40fa, const Udm::Object& block_4103, const Udm::Object& main_410c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_40fa.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_40ff= CyberComposition::Simulink::Subsystem::Cast( subsystem_40fa);
		if( false== Uml::IsDerivedFrom( block_4103.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem block_4108= CyberComposition::Simulink::Subsystem::Cast( block_4103);
		if( false== Uml::IsDerivedFrom( main_410c.type(), SFC::Function::meta))
			continue;
		SFC::Function main_4111= SFC::Function::Cast( main_410c);
		set< CyberComposition::Simulink::TriggerPort> triggerPorts_4113= block_4108.TriggerPort_kind_children();
		for( set< CyberComposition::Simulink::TriggerPort>::const_iterator itTriggerPort_4114= triggerPorts_4113.begin(); itTriggerPort_4114!= triggerPorts_4113.end(); ++itTriggerPort_4114)
		{
			CyberComposition::Simulink::TriggerPort currTriggerPort_4115= *itTriggerPort_4114;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_4119;
			if( !isValidBound(boundObjs_4119, subsystem_40ff, true))
				continue;
			currMatch.subsystem_411a= subsystem_40ff;
			if( !isValidBound(boundObjs_4119, block_4108, true))
				continue;
			currMatch.block_411b= block_4108;
			if( !isValidBound(boundObjs_4119, main_4111, true))
				continue;
			currMatch.main_411c= main_4111;
			if( !isValidBound(boundObjs_4119, currTriggerPort_4115, false))
				continue;
			currMatch.triggerPort_411d= currTriggerPort_4115;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void HasTriggers_40eb::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_411e, const CyberComposition::Simulink::Subsystem& block_4120, const SFC::Function& main_4122)
{
	_subsystem_40f5->push_back( subsystem_411e);
	_block_40f6->push_back( block_4120);
	_main_40f7->push_back( main_4122);
}

bool Otherwise_4124::operator()( const Packets_t& subsystems_4125, const Packets_t& blocks_4128, const Packets_t& mains_412b, Packets_t& subsystems_4127, Packets_t& blocks_412a, Packets_t& mains_412d)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_4124" );
#endif
	_subsystem_412e= &subsystems_4127;
	_block_412f= &blocks_412a;
	_main_4130= &mains_412d;
	processInputPackets( subsystems_4125, blocks_4128, mains_412b);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_4124::isInputUnique( const Udm::Object& subsystem_4135, const Udm::Object& block_413e, const Udm::Object& main_4147)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_4137= _subsystem_4131.begin(), itBlock_4140= _block_413a.begin(), itMain_4149= _main_4143.begin(); itSubsystem_4137!= _subsystem_4131.end(), itBlock_4140!= _block_413a.end(), itMain_4149!= _main_4143.end(); ++itSubsystem_4137, ++itBlock_4140, ++itMain_4149)
	{
		if( ( *itSubsystem_4137== subsystem_4135)&& ( *itBlock_4140== block_413e)&& ( *itMain_4149== main_4147))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_4131.push_back( subsystem_4135);
		_block_413a.push_back( block_413e);
		_main_4143.push_back( main_4147);
	}
	return isUnique;
}

bool Otherwise_4124::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_4124::processInputPackets( const Packets_t& subsystems_4125, const Packets_t& blocks_4128, const Packets_t& mains_412b)
{
	for( Packets_t::const_iterator itSubsystem_4132= subsystems_4125.begin(), itBlock_413b= blocks_4128.begin(), itMain_4144= mains_412b.begin(); itSubsystem_4132!= subsystems_4125.end(), itBlock_413b!= blocks_4128.end(), itMain_4144!= mains_412b.end(); ++itSubsystem_4132, ++itBlock_413b, ++itMain_4144)
	{
		bool isUnique= isInputUnique( *itSubsystem_4132, *itBlock_413b, *itMain_4144);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_4132, *itBlock_413b, *itMain_4144);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_4150, currMatch.block_4151, currMatch.main_4152);
	}
}

bool Otherwise_4124::patternMatcher( const Udm::Object& subsystem_4133, const Udm::Object& block_413c, const Udm::Object& main_4145)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_4133.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_4138= CyberComposition::Simulink::Subsystem::Cast( subsystem_4133);
		if( false== Uml::IsDerivedFrom( block_413c.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem block_4141= CyberComposition::Simulink::Subsystem::Cast( block_413c);
		if( false== Uml::IsDerivedFrom( main_4145.type(), SFC::Function::meta))
			continue;
		SFC::Function main_414a= SFC::Function::Cast( main_4145);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_414f;
		if( !isValidBound(boundObjs_414f, subsystem_4138, true))
			continue;
		currMatch.subsystem_4150= subsystem_4138;
		if( !isValidBound(boundObjs_414f, block_4141, true))
			continue;
		currMatch.block_4151= block_4141;
		if( !isValidBound(boundObjs_414f, main_414a, true))
			continue;
		currMatch.main_4152= main_414a;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_4124::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_4153, const CyberComposition::Simulink::Subsystem& block_4155, const SFC::Function& main_4157)
{
	_subsystem_412e->push_back( subsystem_4153);
	_block_412f->push_back( block_4155);
	_main_4130->push_back( main_4157);
}

void SFChartChildBlock_4186::operator()( const Packets_t& systems_4187, const Packets_t& childCharts_4189, const Packets_t& systemFunctions_418b)
{
#ifdef PRINT_INFO
	printLog( "SFChartChildBlock_4186" );
#endif
	if( ( !systems_4187.empty())&& ( !childCharts_4189.empty())&& ( !systemFunctions_418b.empty()))
		callMakeTrigger_5287( systems_4187, childCharts_4189, systemFunctions_418b);
}

void SFChartChildBlock_4186::callMakeTrigger_5287( const Packets_t& systems_453c, const Packets_t& childSubsystems_453e, const Packets_t& systemFunctions_4540)
{
	Packets_t systems_4542;
	Packets_t childSubsystems_4543;
	Packets_t compoundStatements_4544;
	MakeTrigger_453b makeTrigger_453b;
	makeTrigger_453b( systems_453c, childSubsystems_453e, systemFunctions_4540, systems_4542, childSubsystems_4543, compoundStatements_4544);
	if( ( !systems_4542.empty())&& ( !childSubsystems_4543.empty())&& ( !compoundStatements_4544.empty()))
		callCreateFunctionCall_528b( systems_4542, childSubsystems_4543, compoundStatements_4544);
}

void SFChartChildBlock_4186::callCreateFunctionCall_528b( const Packets_t& subsystems_418e, const Packets_t& charts_4192, const Packets_t& compoundStatements_4196)
{
	Packets_t subsystems_4190;
	Packets_t mains_4191;
	Packets_t charts_4194;
	Packets_t functionCalls_4195;
	CreateFunctionCall_418d createFunctionCall_418d;
	createFunctionCall_418d( subsystems_418e, charts_4192, compoundStatements_4196, subsystems_4190, mains_4191, charts_4194, functionCalls_4195);
	if( ( !subsystems_4190.empty())&& ( !charts_4194.empty())&& ( !mains_4191.empty())&& ( !functionCalls_4195.empty()))
		callGetState_528f( subsystems_4190, charts_4194, mains_4191, functionCalls_4195);
}

void SFChartChildBlock_4186::callGetState_528f( const Packets_t& subsystems_523b, const Packets_t& charts_523e, const Packets_t& mains_5242, const Packets_t& functionCalls_5245)
{
	Packets_t subsystems_523d;
	Packets_t charts_5240;
	Packets_t states_5241;
	Packets_t mains_5244;
	Packets_t functionCalls_5247;
	GetState_523a getState_523a;
	getState_523a( subsystems_523b, charts_523e, mains_5242, functionCalls_5245, subsystems_523d, charts_5240, states_5241, mains_5244, functionCalls_5247);
	if( ( !subsystems_523d.empty())&& ( !charts_5240.empty())&& ( !states_5241.empty())&& ( !mains_5244.empty())&& ( !functionCalls_5247.empty()))
		callInputData_5294( subsystems_523d, charts_5240, states_5241, mains_5244, functionCalls_5247);
}

void SFChartChildBlock_4186::callInputData_5294( const Packets_t& systems_42b6, const Packets_t& childCharts_42b8, const Packets_t& states_42ba, const Packets_t& functions_42bc, const Packets_t& functionCalls_42be)
{
	Packets_t systems_42c0;
	Packets_t childCharts_42c1;
	Packets_t states_42c2;
	Packets_t functions_42c3;
	Packets_t functionCalls_42c4;
	InputData_42b5 inputData_42b5;
	inputData_42b5( systems_42b6, childCharts_42b8, states_42ba, functions_42bc, functionCalls_42be, systems_42c0, childCharts_42c1, states_42c2, functions_42c3, functionCalls_42c4);
	if( ( !systems_42c0.empty())&& ( !childCharts_42c1.empty())&& ( !states_42c2.empty())&& ( !functions_42c3.empty())&& ( !functionCalls_42c4.empty()))
		callInputEvent_529a( systems_42c0, childCharts_42c1, states_42c2, functions_42c3, functionCalls_42c4);
}

void SFChartChildBlock_4186::callInputEvent_529a( const Packets_t& systems_4414, const Packets_t& childCharts_4416, const Packets_t& states_4418, const Packets_t& functions_441a, const Packets_t& functionCalls_441c)
{
	Packets_t systems_441e;
	Packets_t childCharts_441f;
	Packets_t states_4420;
	Packets_t functions_4421;
	Packets_t functionCalls_4422;
	InputEvent_4413 inputEvent_4413;
	inputEvent_4413( systems_4414, childCharts_4416, states_4418, functions_441a, functionCalls_441c, systems_441e, childCharts_441f, states_4420, functions_4421, functionCalls_4422);
	if( ( !systems_441e.empty())&& ( !childCharts_441f.empty())&& ( !states_4420.empty())&& ( !functions_4421.empty())&& ( !functionCalls_4422.empty()))
		callOutputData_52a0( systems_441e, childCharts_441f, states_4420, functions_4421, functionCalls_4422);
}

void SFChartChildBlock_4186::callOutputData_52a0( const Packets_t& systems_41d8, const Packets_t& childCharts_41da, const Packets_t& states_41dc, const Packets_t& functions_41de, const Packets_t& functionCalls_41e0)
{
	Packets_t systems_41e2;
	Packets_t childCharts_41e3;
	Packets_t states_41e4;
	Packets_t functions_41e5;
	Packets_t functionCalls_41e6;
	OutputData_41d7 outputData_41d7;
	outputData_41d7( systems_41d8, childCharts_41da, states_41dc, functions_41de, functionCalls_41e0, systems_41e2, childCharts_41e3, states_41e4, functions_41e5, functionCalls_41e6);
	if( ( !systems_41e2.empty())&& ( !childCharts_41e3.empty())&& ( !states_41e4.empty())&& ( !functions_41e5.empty())&& ( !functionCalls_41e6.empty()))
		callOutputEvent_52a6( systems_41e2, childCharts_41e3, states_41e4, functions_41e5, functionCalls_41e6);
}

void SFChartChildBlock_4186::callOutputEvent_52a6( const Packets_t& systems_4394, const Packets_t& childCharts_4396, const Packets_t& states_4398, const Packets_t& functions_439a, const Packets_t& functionCalls_439c)
{
	OutputEvent_4393 outputEvent_4393;
	outputEvent_4393( systems_4394, childCharts_4396, states_4398, functions_439a, functionCalls_439c);
}

void CreateFunctionCall_418d::operator()( const Packets_t& subsystems_418e, const Packets_t& charts_4192, const Packets_t& compoundStatements_4196, Packets_t& subsystems_4190, Packets_t& mains_4191, Packets_t& charts_4194, Packets_t& functionCalls_4195)
{
#ifdef PRINT_INFO
	printLog( "CreateFunctionCall_418d" );
#endif
	RTTGenerator::Instance()->generateRule(3797, "CreateFunctionCall");
	_subsystem_4198= &subsystems_4190;
	_main_4199= &mains_4191;
	_chart_419a= &charts_4194;
	_functionCall_419b= &functionCalls_4195;
	processInputPackets( subsystems_418e, charts_4192, compoundStatements_4196);
}

bool CreateFunctionCall_418d::isInputUnique( const Udm::Object& subsystem_41a0, const Udm::Object& chart_41a9, const Udm::Object& compoundStatement_41b2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_41a2= _subsystem_419c.begin(), itChart_41ab= _chart_41a5.begin(), itCompoundStatement_41b4= _compoundStatement_41ae.begin(); itSubsystem_41a2!= _subsystem_419c.end(), itChart_41ab!= _chart_41a5.end(), itCompoundStatement_41b4!= _compoundStatement_41ae.end(); ++itSubsystem_41a2, ++itChart_41ab, ++itCompoundStatement_41b4)
	{
		if( ( *itSubsystem_41a2== subsystem_41a0)&& ( *itChart_41ab== chart_41a9)&& ( *itCompoundStatement_41b4== compoundStatement_41b2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_419c.push_back( subsystem_41a0);
		_chart_41a5.push_back( chart_41a9);
		_compoundStatement_41ae.push_back( compoundStatement_41b2);
	}
	return isUnique;
}

bool CreateFunctionCall_418d::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateFunctionCall_418d::processInputPackets( const Packets_t& subsystems_418e, const Packets_t& charts_4192, const Packets_t& compoundStatements_4196)
{
	for( Packets_t::const_iterator itSubsystem_419d= subsystems_418e.begin(), itChart_41a6= charts_4192.begin(), itCompoundStatement_41af= compoundStatements_4196.begin(); itSubsystem_419d!= subsystems_418e.end(), itChart_41a6!= charts_4192.end(), itCompoundStatement_41af!= compoundStatements_4196.end(); ++itSubsystem_419d, ++itChart_41a6, ++itCompoundStatement_41af)
	{
		bool isUnique= isInputUnique( *itSubsystem_419d, *itChart_41a6, *itCompoundStatement_41af);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_419d, *itChart_41a6, *itCompoundStatement_41af);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateFunctionCall_418d::patternMatcher( const Udm::Object& subsystem_419e, const Udm::Object& chart_41a7, const Udm::Object& compoundStatement_41b0)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_419e.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_41a3= CyberComposition::Simulink::Subsystem::Cast( subsystem_419e);
		if( false== Uml::IsDerivedFrom( chart_41a7.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem chart_41ac= CyberComposition::Simulink::Subsystem::Cast( chart_41a7);
		if( false== Uml::IsDerivedFrom( compoundStatement_41b0.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_41b5= SFC::CompoundStatement::Cast( compoundStatement_41b0);
		SFC::Function main_41b7= chart_41ac.main();
		if( !main_41b7)
			continue;
		Udm::Object mainParent_41b8= main_41b7.container();
		if( false== Uml::IsDerivedFrom( mainParent_41b8.type(), SFC::Class::meta))
			continue;
		SFC::Class classMain_41b9= SFC::Class::Cast( mainParent_41b8);
		set< SFC::Struct> structs_41ba= classMain_41b9.Struct_kind_children();
		for( set< SFC::Struct>::const_iterator itStruct_41bb= structs_41ba.begin(); itStruct_41bb!= structs_41ba.end(); ++itStruct_41bb)
		{
			SFC::Struct currStruct_41bc= *itStruct_41bb;
			set< SFC::Arg> args_41bd= main_41b7.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itArg_41be= args_41bd.begin(); itArg_41be!= args_41bd.end(); ++itArg_41be)
			{
				SFC::Arg currArg_41bf= *itArg_41be;
				SFC::DT struct_41c0= currArg_41bf.dt();
				if(!struct_41c0 || false== Uml::IsDerivedFrom( struct_41c0.type(), SFC::Struct::meta))
					continue;
				SFC::Struct struct_41c1= SFC::Struct::Cast( struct_41c0);
				if( !struct_41c1)
					continue;
				if( currStruct_41bc!= struct_41c1)
					continue;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_41c5;
				if( !isValidBound(boundObjs_41c5, subsystem_41a3, true))
					continue;
				currMatch.subsystem_41c6= subsystem_41a3;
				if( !isValidBound(boundObjs_41c5, chart_41ac, true))
					continue;
				currMatch.chart_41c7= chart_41ac;
				if( !isValidBound(boundObjs_41c5, compoundStatement_41b5, true))
					continue;
				currMatch.compoundStatement_41c8= compoundStatement_41b5;
				if( !isValidBound(boundObjs_41c5, classMain_41b9, false))
					continue;
				currMatch.class_41c9= classMain_41b9;
				if( !isValidBound(boundObjs_41c5, currStruct_41bc, false))
					continue;
				currMatch.struct_41ca= currStruct_41bc;
				if( !isValidBound(boundObjs_41c5, currArg_41bf, false))
					continue;
				currMatch.arg_41cb= currArg_41bf;
				if( !isValidBound(boundObjs_41c5, main_41b7, false))
					continue;
				currMatch.main_41cc= main_41b7;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void CreateFunctionCall_418d::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::FunctionCall newFunctionCall_41cd= SFC::FunctionCall::Create( currMatch.compoundStatement_41c8, SFC::CompoundStatement::meta_stmnt);
		SFC::ArgVal newArgVal_41ce= SFC::ArgVal::Create( newFunctionCall_41cd);
		SFC::Arg& Arg= currMatch.arg_41cb;
		SFC::ArgVal& ArgVal= newArgVal_41ce;
		CyberComposition::Simulink::Subsystem& Chart= currMatch.chart_41c7;
		SFC::Class& Class= currMatch.class_41c9;
		SFC::CompoundStatement& CompoundStatement= currMatch.compoundStatement_41c8;
		SFC::FunctionCall& FunctionCall= newFunctionCall_41cd;
		SFC::Function& Main= currMatch.main_41cc;
		SFC::Struct& Struct= currMatch.struct_41ca;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_41c6;
		{
ArgVal.argIndex() = static_cast< __int64 >( Arg.argIndex() );
};
		{
__int64 statementCount = CompoundStatement.statementCount();
FunctionCall.statementIndex() = statementCount++;
CompoundStatement.statementCount() = statementCount;
};
		{
FunctionCall.argCount() = 1;
ArgVal.val() = "0"; /* need to fill this with instance number */
 
};
		newArgVal_41ce.arg()+= currMatch.arg_41cb;
		newFunctionCall_41cd.callee()= currMatch.main_41cc;
		newFunctionCall_41cd.obj()= currMatch.chart_41c7;
		outputAppender( currMatch.subsystem_41c6, currMatch.main_41cc, currMatch.chart_41c7, newFunctionCall_41cd);
	}
}

void CreateFunctionCall_418d::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_41cf, const SFC::Function& main_41d1, const CyberComposition::Simulink::Subsystem& chart_41d3, const SFC::FunctionCall& functionCall_41d5)
{
	_subsystem_4198->push_back( subsystem_41cf);
	_main_4199->push_back( main_41d1);
	_chart_419a->push_back( chart_41d3);
	_functionCall_419b->push_back( functionCall_41d5);
}

void OutputData_41d7::operator()( const Packets_t& systems_41d8, const Packets_t& childCharts_41da, const Packets_t& states_41dc, const Packets_t& functions_41de, const Packets_t& functionCalls_41e0, Packets_t& systems_41e2, Packets_t& childCharts_41e3, Packets_t& states_41e4, Packets_t& functions_41e5, Packets_t& functionCalls_41e6)
{
#ifdef PRINT_INFO
	printLog( "OutputData_41d7" );
#endif
	_system_41e7= &systems_41e2;
	_childChart_41e8= &childCharts_41e3;
	_state_41e9= &states_41e4;
	_function_41ea= &functions_41e5;
	_functionCall_41eb= &functionCalls_41e6;
	if( ( !systems_41d8.empty())&& ( !childCharts_41da.empty())&& ( !states_41dc.empty())&& ( !functions_41de.empty())&& ( !functionCalls_41e0.empty()))
		callCreateOutputDataArgVal_42a5( systems_41d8, childCharts_41da, states_41dc, functions_41de, functionCalls_41e0);
	_system_41e7->insert( _system_41e7->end(), systems_41d8.begin(), systems_41d8.end());
	_childChart_41e8->insert( _childChart_41e8->end(), childCharts_41da.begin(), childCharts_41da.end());
	_state_41e9->insert( _state_41e9->end(), states_41dc.begin(), states_41dc.end());
	_function_41ea->insert( _function_41ea->end(), functions_41de.begin(), functions_41de.end());
	_functionCall_41eb->insert( _functionCall_41eb->end(), functionCalls_41e0.begin(), functionCalls_41e0.end());
}

void OutputData_41d7::callCreateOutputDataArgVal_42a5( const Packets_t& subsystems_4241, const Packets_t& charts_4245, const Packets_t& states_4247, const Packets_t& mains_4249, const Packets_t& functionCalls_424d)
{
	Packets_t subsystems_4243;
	Packets_t outputPorts_4244;
	Packets_t mains_424b;
	Packets_t argVals_424c;
	Packets_t functionCalls_424f;
	CreateOutputDataArgVal_4240 createOutputDataArgVal_4240;
	createOutputDataArgVal_4240( subsystems_4241, charts_4245, states_4247, mains_4249, functionCalls_424d, subsystems_4243, outputPorts_4244, mains_424b, argVals_424c, functionCalls_424f);
	if( ( !subsystems_4243.empty())&& ( !outputPorts_4244.empty())&& ( !mains_424b.empty())&& ( !argVals_424c.empty())&& ( !functionCalls_424f.empty()))
		callUpdateArgCount_42ab( subsystems_4243, outputPorts_4244, mains_424b, argVals_424c, functionCalls_424f);
}

void OutputData_41d7::callUpdateArgCount_42ab( const Packets_t& subsystems_41ed, const Packets_t& outputPorts_41f0, const Packets_t& functions_41f3, const Packets_t& argVals_41f5, const Packets_t& functionCalls_41f8)
{
	Packets_t subsystems_41ef;
	Packets_t outputPorts_41f2;
	Packets_t argVals_41f7;
	UpdateArgCount_41ec updateArgCount_41ec;
	updateArgCount_41ec( subsystems_41ed, outputPorts_41f0, functions_41f3, argVals_41f5, functionCalls_41f8, subsystems_41ef, outputPorts_41f2, argVals_41f7);
	if( ( !subsystems_41ef.empty())&& ( !outputPorts_41f2.empty())&& ( !argVals_41f7.empty()))
		callMakeArgDeclRef_42b1( subsystems_41ef, outputPorts_41f2, argVals_41f7);
}

void OutputData_41d7::callMakeArgDeclRef_42b1( const Packets_t& systems_2cf6, const Packets_t& argPorts_2cf8, const Packets_t& argVals_2cfa)
{
	MakeArgDeclRef_2cf5 makeArgDeclRef_2cf5;
	makeArgDeclRef_2cf5( systems_2cf6, argPorts_2cf8, argVals_2cfa);
}

void UpdateArgCount_41ec::operator()( const Packets_t& subsystems_41ed, const Packets_t& outputPorts_41f0, const Packets_t& functions_41f3, const Packets_t& argVals_41f5, const Packets_t& functionCalls_41f8, Packets_t& subsystems_41ef, Packets_t& outputPorts_41f2, Packets_t& argVals_41f7)
{
#ifdef PRINT_INFO
	printLog( "UpdateArgCount_41ec" );
#endif
	RTTGenerator::Instance()->generateRule(3831, "UpdateArgCount");
	_subsystem_41fa= &subsystems_41ef;
	_outputPort_41fb= &outputPorts_41f2;
	_argVal_41fc= &argVals_41f7;
	processInputPackets( subsystems_41ed, outputPorts_41f0, functions_41f3, argVals_41f5, functionCalls_41f8);
	forwardInputs( );
}

bool UpdateArgCount_41ec::isInputUnique( const Udm::Object& subsystem_4201, const Udm::Object& outputPort_420a, const Udm::Object& function_4213, const Udm::Object& argVal_421c, const Udm::Object& functionCall_4225)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_4203= _subsystem_41fd.begin(), itOutputPort_420c= _outputPort_4206.begin(), itFunction_4215= _function_420f.begin(), itArgVal_421e= _argVal_4218.begin(), itFunctionCall_4227= _functionCall_4221.begin(); itSubsystem_4203!= _subsystem_41fd.end(), itOutputPort_420c!= _outputPort_4206.end(), itFunction_4215!= _function_420f.end(), itArgVal_421e!= _argVal_4218.end(), itFunctionCall_4227!= _functionCall_4221.end(); ++itSubsystem_4203, ++itOutputPort_420c, ++itFunction_4215, ++itArgVal_421e, ++itFunctionCall_4227)
	{
		if( ( *itSubsystem_4203== subsystem_4201)&& ( *itOutputPort_420c== outputPort_420a)&& ( *itFunction_4215== function_4213)&& ( *itArgVal_421e== argVal_421c)&& ( *itFunctionCall_4227== functionCall_4225))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_41fd.push_back( subsystem_4201);
		_outputPort_4206.push_back( outputPort_420a);
		_function_420f.push_back( function_4213);
		_argVal_4218.push_back( argVal_421c);
		_functionCall_4221.push_back( functionCall_4225);
	}
	return isUnique;
}

bool UpdateArgCount_41ec::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool UpdateArgCount_41ec::isGuardTrue( SFC::Arg& Arg, SFC::ArgVal& ArgVal, SFC::Function& Function, SFC::FunctionCall& FunctionCall, CyberComposition::Simulink::OutputPort& OutputPort, CyberComposition::Simulink::Subsystem& Subsystem)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< __int64 >( Arg.argIndex() ) == static_cast< __int64 >( ArgVal.argIndex() );;
	return Gz_guard;
}

void UpdateArgCount_41ec::processInputPackets( const Packets_t& subsystems_41ed, const Packets_t& outputPorts_41f0, const Packets_t& functions_41f3, const Packets_t& argVals_41f5, const Packets_t& functionCalls_41f8)
{
	for( Packets_t::const_iterator itSubsystem_41fe= subsystems_41ed.begin(), itOutputPort_4207= outputPorts_41f0.begin(), itFunction_4210= functions_41f3.begin(), itArgVal_4219= argVals_41f5.begin(), itFunctionCall_4222= functionCalls_41f8.begin(); itSubsystem_41fe!= subsystems_41ed.end(), itOutputPort_4207!= outputPorts_41f0.end(), itFunction_4210!= functions_41f3.end(), itArgVal_4219!= argVals_41f5.end(), itFunctionCall_4222!= functionCalls_41f8.end(); ++itSubsystem_41fe, ++itOutputPort_4207, ++itFunction_4210, ++itArgVal_4219, ++itFunctionCall_4222)
	{
		bool isUnique= isInputUnique( *itSubsystem_41fe, *itOutputPort_4207, *itFunction_4210, *itArgVal_4219, *itFunctionCall_4222);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_41fe, *itOutputPort_4207, *itFunction_4210, *itArgVal_4219, *itFunctionCall_4222);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool UpdateArgCount_41ec::patternMatcher( const Udm::Object& subsystem_41ff, const Udm::Object& outputPort_4208, const Udm::Object& function_4211, const Udm::Object& argVal_421a, const Udm::Object& functionCall_4223)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_41ff.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_4204= CyberComposition::Simulink::Subsystem::Cast( subsystem_41ff);
		if( false== Uml::IsDerivedFrom( outputPort_4208.type(), CyberComposition::Simulink::OutputPort::meta))
			continue;
		CyberComposition::Simulink::OutputPort outputPort_420d= CyberComposition::Simulink::OutputPort::Cast( outputPort_4208);
		if( false== Uml::IsDerivedFrom( function_4211.type(), SFC::Function::meta))
			continue;
		SFC::Function function_4216= SFC::Function::Cast( function_4211);
		if( false== Uml::IsDerivedFrom( argVal_421a.type(), SFC::ArgVal::meta))
			continue;
		SFC::ArgVal argVal_421f= SFC::ArgVal::Cast( argVal_421a);
		if( false== Uml::IsDerivedFrom( functionCall_4223.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall functionCall_4228= SFC::FunctionCall::Cast( functionCall_4223);
		set< SFC::ArgVal> argVals_422a= functionCall_4228.ArgVal_kind_children();
		for( set< SFC::ArgVal>::const_iterator itArgVal_422b= argVals_422a.begin(); itArgVal_422b!= argVals_422a.end(); ++itArgVal_422b)
		{
			SFC::ArgVal currArgVal_422c= *itArgVal_422b;
			if( argVal_421f!= currArgVal_422c)
				continue;
			set< SFC::Arg> args_422d= function_4216.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itArg_422e= args_422d.begin(); itArg_422e!= args_422d.end(); ++itArg_422e)
			{
				SFC::Arg currArg_422f= *itArg_422e;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_4233;
				if( !isValidBound(boundObjs_4233, subsystem_4204, true))
					continue;
				currMatch.subsystem_4234= subsystem_4204;
				if( !isValidBound(boundObjs_4233, outputPort_420d, true))
					continue;
				currMatch.outputPort_4235= outputPort_420d;
				if( !isValidBound(boundObjs_4233, function_4216, true))
					continue;
				currMatch.function_4236= function_4216;
				if( !isValidBound(boundObjs_4233, argVal_421f, true))
					continue;
				currMatch.argVal_4237= argVal_421f;
				if( !isValidBound(boundObjs_4233, functionCall_4228, true))
					continue;
				currMatch.functionCall_4238= functionCall_4228;
				if( !isValidBound(boundObjs_4233, currArg_422f, false))
					continue;
				currMatch.arg_4239= currArg_422f;
				bool Gz_guard= isGuardTrue( currMatch.arg_4239, currMatch.argVal_4237, currMatch.function_4236, currMatch.functionCall_4238, currMatch.outputPort_4235, currMatch.subsystem_4234);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void UpdateArgCount_41ec::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg& Arg= currMatch.arg_4239;
		SFC::ArgVal& ArgVal= currMatch.argVal_4237;
		SFC::Function& Function= currMatch.function_4236;
		SFC::FunctionCall& FunctionCall= currMatch.functionCall_4238;
		CyberComposition::Simulink::OutputPort& OutputPort= currMatch.outputPort_4235;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_4234;
		{
FunctionCall.argCount() = static_cast< __int64 >( FunctionCall.argCount() ) + 1;
};
		currMatch.argVal_4237.arg()+= currMatch.arg_4239;
	}
}

void UpdateArgCount_41ec::forwardInputs()
{
	*_subsystem_41fa= _subsystem_41fd;
	*_outputPort_41fb= _outputPort_4206;
	*_argVal_41fc= _argVal_4218;
}

void CreateOutputDataArgVal_4240::operator()( const Packets_t& subsystems_4241, const Packets_t& charts_4245, const Packets_t& states_4247, const Packets_t& mains_4249, const Packets_t& functionCalls_424d, Packets_t& subsystems_4243, Packets_t& outputPorts_4244, Packets_t& mains_424b, Packets_t& argVals_424c, Packets_t& functionCalls_424f)
{
#ifdef PRINT_INFO
	printLog( "CreateOutputDataArgVal_4240" );
#endif
	RTTGenerator::Instance()->generateRule(3842, "CreateOutputDataArgVal");
	_subsystem_4250= &subsystems_4243;
	_outputPort_4251= &outputPorts_4244;
	_main_4252= &mains_424b;
	_argVal_4253= &argVals_424c;
	_functionCall_4254= &functionCalls_424f;
	processInputPackets( subsystems_4241, charts_4245, states_4247, mains_4249, functionCalls_424d);
}

bool CreateOutputDataArgVal_4240::isInputUnique( const Udm::Object& subsystem_4259, const Udm::Object& chart_4262, const Udm::Object& state_426b, const Udm::Object& main_4274, const Udm::Object& functionCall_427d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_425b= _subsystem_4255.begin(), itChart_4264= _chart_425e.begin(), itState_426d= _state_4267.begin(), itMain_4276= _main_4270.begin(), itFunctionCall_427f= _functionCall_4279.begin(); itSubsystem_425b!= _subsystem_4255.end(), itChart_4264!= _chart_425e.end(), itState_426d!= _state_4267.end(), itMain_4276!= _main_4270.end(), itFunctionCall_427f!= _functionCall_4279.end(); ++itSubsystem_425b, ++itChart_4264, ++itState_426d, ++itMain_4276, ++itFunctionCall_427f)
	{
		if( ( *itSubsystem_425b== subsystem_4259)&& ( *itChart_4264== chart_4262)&& ( *itState_426d== state_426b)&& ( *itMain_4276== main_4274)&& ( *itFunctionCall_427f== functionCall_427d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_4255.push_back( subsystem_4259);
		_chart_425e.push_back( chart_4262);
		_state_4267.push_back( state_426b);
		_main_4270.push_back( main_4274);
		_functionCall_4279.push_back( functionCall_427d);
	}
	return isUnique;
}

bool CreateOutputDataArgVal_4240::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool CreateOutputDataArgVal_4240::isGuardTrue( CyberComposition::Simulink::Subsystem& Chart, CyberComposition::Simulink::SFData& Data, SFC::FunctionCall& FunctionCall, SFC::Function& Main, CyberComposition::Simulink::OutputPort& OutputPort, CyberComposition::Simulink::SFState& State, CyberComposition::Simulink::Subsystem& Subsystem)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( Data.Scope() ) == "OUTPUT_DATA" &&
 static_cast< std::string >( OutputPort.name() ) == static_cast< std::string >( Data.name() );;
	return Gz_guard;
}

void CreateOutputDataArgVal_4240::processInputPackets( const Packets_t& subsystems_4241, const Packets_t& charts_4245, const Packets_t& states_4247, const Packets_t& mains_4249, const Packets_t& functionCalls_424d)
{
	for( Packets_t::const_iterator itSubsystem_4256= subsystems_4241.begin(), itChart_425f= charts_4245.begin(), itState_4268= states_4247.begin(), itMain_4271= mains_4249.begin(), itFunctionCall_427a= functionCalls_424d.begin(); itSubsystem_4256!= subsystems_4241.end(), itChart_425f!= charts_4245.end(), itState_4268!= states_4247.end(), itMain_4271!= mains_4249.end(), itFunctionCall_427a!= functionCalls_424d.end(); ++itSubsystem_4256, ++itChart_425f, ++itState_4268, ++itMain_4271, ++itFunctionCall_427a)
	{
		bool isUnique= isInputUnique( *itSubsystem_4256, *itChart_425f, *itState_4268, *itMain_4271, *itFunctionCall_427a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_4256, *itChart_425f, *itState_4268, *itMain_4271, *itFunctionCall_427a);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateOutputDataArgVal_4240::patternMatcher( const Udm::Object& subsystem_4257, const Udm::Object& chart_4260, const Udm::Object& state_4269, const Udm::Object& main_4272, const Udm::Object& functionCall_427b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_4257.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_425c= CyberComposition::Simulink::Subsystem::Cast( subsystem_4257);
		if( false== Uml::IsDerivedFrom( chart_4260.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem chart_4265= CyberComposition::Simulink::Subsystem::Cast( chart_4260);
		if( false== Uml::IsDerivedFrom( state_4269.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState state_426e= CyberComposition::Simulink::SFState::Cast( state_4269);
		if( false== Uml::IsDerivedFrom( main_4272.type(), SFC::Function::meta))
			continue;
		SFC::Function main_4277= SFC::Function::Cast( main_4272);
		if( false== Uml::IsDerivedFrom( functionCall_427b.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall functionCall_4280= SFC::FunctionCall::Cast( functionCall_427b);
		set< CyberComposition::Simulink::OutputPort> outputPorts_4282= chart_4265.OutputPort_kind_children();
		for( set< CyberComposition::Simulink::OutputPort>::const_iterator itOutputPort_4283= outputPorts_4282.begin(); itOutputPort_4283!= outputPorts_4282.end(); ++itOutputPort_4283)
		{
			CyberComposition::Simulink::OutputPort currOutputPort_4284= *itOutputPort_4283;
			set< CyberComposition::Simulink::SFData> datas_4285= state_426e.SFData_kind_children();
			for( set< CyberComposition::Simulink::SFData>::const_iterator itData_4286= datas_4285.begin(); itData_4286!= datas_4285.end(); ++itData_4286)
			{
				CyberComposition::Simulink::SFData currData_4287= *itData_4286;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_428b;
				if( !isValidBound(boundObjs_428b, subsystem_425c, true))
					continue;
				currMatch.subsystem_428c= subsystem_425c;
				if( !isValidBound(boundObjs_428b, chart_4265, true))
					continue;
				currMatch.chart_428d= chart_4265;
				if( !isValidBound(boundObjs_428b, state_426e, true))
					continue;
				currMatch.state_428e= state_426e;
				if( !isValidBound(boundObjs_428b, main_4277, true))
					continue;
				currMatch.main_428f= main_4277;
				if( !isValidBound(boundObjs_428b, functionCall_4280, true))
					continue;
				currMatch.functionCall_4290= functionCall_4280;
				if( !isValidBound(boundObjs_428b, currOutputPort_4284, false))
					continue;
				currMatch.outputPort_4291= currOutputPort_4284;
				if( !isValidBound(boundObjs_428b, currData_4287, false))
					continue;
				currMatch.data_4292= currData_4287;
				bool Gz_guard= isGuardTrue( currMatch.chart_428d, currMatch.data_4292, currMatch.functionCall_4290, currMatch.main_428f, currMatch.outputPort_4291, currMatch.state_428e, currMatch.subsystem_428c);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void CreateOutputDataArgVal_4240::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ArgVal newArgVal_429a= SFC::ArgVal::Create( currMatch.functionCall_4290);
		SFC::ArgVal& ArgVal= newArgVal_429a;
		CyberComposition::Simulink::Subsystem& Chart= currMatch.chart_428d;
		CyberComposition::Simulink::SFData& Data= currMatch.data_4292;
		SFC::FunctionCall& FunctionCall= currMatch.functionCall_4290;
		SFC::Function& Main= currMatch.main_428f;
		CyberComposition::Simulink::OutputPort& OutputPort= currMatch.outputPort_4291;
		CyberComposition::Simulink::SFState& State= currMatch.state_428e;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_428c;
		{
ArgVal.argIndex() = static_cast< __int64 >( FunctionCall.argCount() ) + static_cast< __int64 >( Data.Port() ) - 1;
};
		outputAppender( currMatch.subsystem_428c, currMatch.outputPort_4291, currMatch.main_428f, newArgVal_429a, currMatch.functionCall_4290);
	}
}

void CreateOutputDataArgVal_4240::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_429b, const CyberComposition::Simulink::OutputPort& outputPort_429d, const SFC::Function& main_429f, const SFC::ArgVal& argVal_42a1, const SFC::FunctionCall& functionCall_42a3)
{
	_subsystem_4250->push_back( subsystem_429b);
	_outputPort_4251->push_back( outputPort_429d);
	_main_4252->push_back( main_429f);
	_argVal_4253->push_back( argVal_42a1);
	_functionCall_4254->push_back( functionCall_42a3);
}

void InputData_42b5::operator()( const Packets_t& systems_42b6, const Packets_t& childCharts_42b8, const Packets_t& states_42ba, const Packets_t& functions_42bc, const Packets_t& functionCalls_42be, Packets_t& systems_42c0, Packets_t& childCharts_42c1, Packets_t& states_42c2, Packets_t& functions_42c3, Packets_t& functionCalls_42c4)
{
#ifdef PRINT_INFO
	printLog( "InputData_42b5" );
#endif
	_system_42c5= &systems_42c0;
	_childChart_42c6= &childCharts_42c1;
	_state_42c7= &states_42c2;
	_function_42c8= &functions_42c3;
	_functionCall_42c9= &functionCalls_42c4;
	if( ( !systems_42b6.empty())&& ( !childCharts_42b8.empty())&& ( !states_42ba.empty())&& ( !functions_42bc.empty())&& ( !functionCalls_42be.empty()))
		callCreateInputDataArgVal_4383( systems_42b6, childCharts_42b8, states_42ba, functions_42bc, functionCalls_42be);
	_system_42c5->insert( _system_42c5->end(), systems_42b6.begin(), systems_42b6.end());
	_childChart_42c6->insert( _childChart_42c6->end(), childCharts_42b8.begin(), childCharts_42b8.end());
	_state_42c7->insert( _state_42c7->end(), states_42ba.begin(), states_42ba.end());
	_function_42c8->insert( _function_42c8->end(), functions_42bc.begin(), functions_42bc.end());
	_functionCall_42c9->insert( _functionCall_42c9->end(), functionCalls_42be.begin(), functionCalls_42be.end());
}

void InputData_42b5::callCreateInputDataArgVal_4383( const Packets_t& subsystems_431f, const Packets_t& charts_4323, const Packets_t& states_4325, const Packets_t& mains_4327, const Packets_t& functionCalls_432b)
{
	Packets_t subsystems_4321;
	Packets_t inputPorts_4322;
	Packets_t mains_4329;
	Packets_t argVals_432a;
	Packets_t functionCalls_432d;
	CreateInputDataArgVal_431e createInputDataArgVal_431e;
	createInputDataArgVal_431e( subsystems_431f, charts_4323, states_4325, mains_4327, functionCalls_432b, subsystems_4321, inputPorts_4322, mains_4329, argVals_432a, functionCalls_432d);
	if( ( !subsystems_4321.empty())&& ( !inputPorts_4322.empty())&& ( !mains_4329.empty())&& ( !argVals_432a.empty())&& ( !functionCalls_432d.empty()))
		callUpdateArgCount_4389( subsystems_4321, inputPorts_4322, mains_4329, argVals_432a, functionCalls_432d);
}

void InputData_42b5::callUpdateArgCount_4389( const Packets_t& subsystems_42cb, const Packets_t& inputPorts_42ce, const Packets_t& functions_42d1, const Packets_t& argVals_42d3, const Packets_t& functionCalls_42d6)
{
	Packets_t subsystems_42cd;
	Packets_t inputPorts_42d0;
	Packets_t argVals_42d5;
	UpdateArgCount_42ca updateArgCount_42ca;
	updateArgCount_42ca( subsystems_42cb, inputPorts_42ce, functions_42d1, argVals_42d3, functionCalls_42d6, subsystems_42cd, inputPorts_42d0, argVals_42d5);
	if( ( !subsystems_42cd.empty())&& ( !inputPorts_42d0.empty())&& ( !argVals_42d5.empty()))
		callMakeArgDeclRef_438f( subsystems_42cd, inputPorts_42d0, argVals_42d5);
}

void InputData_42b5::callMakeArgDeclRef_438f( const Packets_t& systems_2cf6, const Packets_t& argPorts_2cf8, const Packets_t& argVals_2cfa)
{
	MakeArgDeclRef_2cf5 makeArgDeclRef_2cf5;
	makeArgDeclRef_2cf5( systems_2cf6, argPorts_2cf8, argVals_2cfa);
}

void UpdateArgCount_42ca::operator()( const Packets_t& subsystems_42cb, const Packets_t& inputPorts_42ce, const Packets_t& functions_42d1, const Packets_t& argVals_42d3, const Packets_t& functionCalls_42d6, Packets_t& subsystems_42cd, Packets_t& inputPorts_42d0, Packets_t& argVals_42d5)
{
#ifdef PRINT_INFO
	printLog( "UpdateArgCount_42ca" );
#endif
	RTTGenerator::Instance()->generateRule(3866, "UpdateArgCount");
	_subsystem_42d8= &subsystems_42cd;
	_inputPort_42d9= &inputPorts_42d0;
	_argVal_42da= &argVals_42d5;
	processInputPackets( subsystems_42cb, inputPorts_42ce, functions_42d1, argVals_42d3, functionCalls_42d6);
	forwardInputs( );
}

bool UpdateArgCount_42ca::isInputUnique( const Udm::Object& subsystem_42df, const Udm::Object& inputPort_42e8, const Udm::Object& function_42f1, const Udm::Object& argVal_42fa, const Udm::Object& functionCall_4303)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_42e1= _subsystem_42db.begin(), itInputPort_42ea= _inputPort_42e4.begin(), itFunction_42f3= _function_42ed.begin(), itArgVal_42fc= _argVal_42f6.begin(), itFunctionCall_4305= _functionCall_42ff.begin(); itSubsystem_42e1!= _subsystem_42db.end(), itInputPort_42ea!= _inputPort_42e4.end(), itFunction_42f3!= _function_42ed.end(), itArgVal_42fc!= _argVal_42f6.end(), itFunctionCall_4305!= _functionCall_42ff.end(); ++itSubsystem_42e1, ++itInputPort_42ea, ++itFunction_42f3, ++itArgVal_42fc, ++itFunctionCall_4305)
	{
		if( ( *itSubsystem_42e1== subsystem_42df)&& ( *itInputPort_42ea== inputPort_42e8)&& ( *itFunction_42f3== function_42f1)&& ( *itArgVal_42fc== argVal_42fa)&& ( *itFunctionCall_4305== functionCall_4303))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_42db.push_back( subsystem_42df);
		_inputPort_42e4.push_back( inputPort_42e8);
		_function_42ed.push_back( function_42f1);
		_argVal_42f6.push_back( argVal_42fa);
		_functionCall_42ff.push_back( functionCall_4303);
	}
	return isUnique;
}

bool UpdateArgCount_42ca::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool UpdateArgCount_42ca::isGuardTrue( SFC::Arg& Arg, SFC::ArgVal& ArgVal, SFC::Function& Function, SFC::FunctionCall& FunctionCall, CyberComposition::Simulink::InputPort& InputPort, CyberComposition::Simulink::Subsystem& Subsystem)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< __int64 >( Arg.argIndex() ) == static_cast< __int64 >( ArgVal.argIndex() );;
	return Gz_guard;
}

void UpdateArgCount_42ca::processInputPackets( const Packets_t& subsystems_42cb, const Packets_t& inputPorts_42ce, const Packets_t& functions_42d1, const Packets_t& argVals_42d3, const Packets_t& functionCalls_42d6)
{
	for( Packets_t::const_iterator itSubsystem_42dc= subsystems_42cb.begin(), itInputPort_42e5= inputPorts_42ce.begin(), itFunction_42ee= functions_42d1.begin(), itArgVal_42f7= argVals_42d3.begin(), itFunctionCall_4300= functionCalls_42d6.begin(); itSubsystem_42dc!= subsystems_42cb.end(), itInputPort_42e5!= inputPorts_42ce.end(), itFunction_42ee!= functions_42d1.end(), itArgVal_42f7!= argVals_42d3.end(), itFunctionCall_4300!= functionCalls_42d6.end(); ++itSubsystem_42dc, ++itInputPort_42e5, ++itFunction_42ee, ++itArgVal_42f7, ++itFunctionCall_4300)
	{
		bool isUnique= isInputUnique( *itSubsystem_42dc, *itInputPort_42e5, *itFunction_42ee, *itArgVal_42f7, *itFunctionCall_4300);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_42dc, *itInputPort_42e5, *itFunction_42ee, *itArgVal_42f7, *itFunctionCall_4300);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool UpdateArgCount_42ca::patternMatcher( const Udm::Object& subsystem_42dd, const Udm::Object& inputPort_42e6, const Udm::Object& function_42ef, const Udm::Object& argVal_42f8, const Udm::Object& functionCall_4301)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_42dd.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_42e2= CyberComposition::Simulink::Subsystem::Cast( subsystem_42dd);
		if( false== Uml::IsDerivedFrom( inputPort_42e6.type(), CyberComposition::Simulink::InputPort::meta))
			continue;
		CyberComposition::Simulink::InputPort inputPort_42eb= CyberComposition::Simulink::InputPort::Cast( inputPort_42e6);
		if( false== Uml::IsDerivedFrom( function_42ef.type(), SFC::Function::meta))
			continue;
		SFC::Function function_42f4= SFC::Function::Cast( function_42ef);
		if( false== Uml::IsDerivedFrom( argVal_42f8.type(), SFC::ArgVal::meta))
			continue;
		SFC::ArgVal argVal_42fd= SFC::ArgVal::Cast( argVal_42f8);
		if( false== Uml::IsDerivedFrom( functionCall_4301.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall functionCall_4306= SFC::FunctionCall::Cast( functionCall_4301);
		set< SFC::ArgVal> argVals_4308= functionCall_4306.ArgVal_kind_children();
		for( set< SFC::ArgVal>::const_iterator itArgVal_4309= argVals_4308.begin(); itArgVal_4309!= argVals_4308.end(); ++itArgVal_4309)
		{
			SFC::ArgVal currArgVal_430a= *itArgVal_4309;
			if( argVal_42fd!= currArgVal_430a)
				continue;
			set< SFC::Arg> args_430b= function_42f4.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itArg_430c= args_430b.begin(); itArg_430c!= args_430b.end(); ++itArg_430c)
			{
				SFC::Arg currArg_430d= *itArg_430c;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_4311;
				if( !isValidBound(boundObjs_4311, subsystem_42e2, true))
					continue;
				currMatch.subsystem_4312= subsystem_42e2;
				if( !isValidBound(boundObjs_4311, inputPort_42eb, true))
					continue;
				currMatch.inputPort_4313= inputPort_42eb;
				if( !isValidBound(boundObjs_4311, function_42f4, true))
					continue;
				currMatch.function_4314= function_42f4;
				if( !isValidBound(boundObjs_4311, argVal_42fd, true))
					continue;
				currMatch.argVal_4315= argVal_42fd;
				if( !isValidBound(boundObjs_4311, functionCall_4306, true))
					continue;
				currMatch.functionCall_4316= functionCall_4306;
				if( !isValidBound(boundObjs_4311, currArg_430d, false))
					continue;
				currMatch.arg_4317= currArg_430d;
				bool Gz_guard= isGuardTrue( currMatch.arg_4317, currMatch.argVal_4315, currMatch.function_4314, currMatch.functionCall_4316, currMatch.inputPort_4313, currMatch.subsystem_4312);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void UpdateArgCount_42ca::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg& Arg= currMatch.arg_4317;
		SFC::ArgVal& ArgVal= currMatch.argVal_4315;
		SFC::Function& Function= currMatch.function_4314;
		SFC::FunctionCall& FunctionCall= currMatch.functionCall_4316;
		CyberComposition::Simulink::InputPort& InputPort= currMatch.inputPort_4313;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_4312;
		{
FunctionCall.argCount() = static_cast< __int64 >( FunctionCall.argCount() ) + 1;
};
		currMatch.argVal_4315.arg()+= currMatch.arg_4317;
	}
}

void UpdateArgCount_42ca::forwardInputs()
{
	*_subsystem_42d8= _subsystem_42db;
	*_inputPort_42d9= _inputPort_42e4;
	*_argVal_42da= _argVal_42f6;
}

void CreateInputDataArgVal_431e::operator()( const Packets_t& subsystems_431f, const Packets_t& charts_4323, const Packets_t& states_4325, const Packets_t& mains_4327, const Packets_t& functionCalls_432b, Packets_t& subsystems_4321, Packets_t& inputPorts_4322, Packets_t& mains_4329, Packets_t& argVals_432a, Packets_t& functionCalls_432d)
{
#ifdef PRINT_INFO
	printLog( "CreateInputDataArgVal_431e" );
#endif
	RTTGenerator::Instance()->generateRule(3877, "CreateInputDataArgVal");
	_subsystem_432e= &subsystems_4321;
	_inputPort_432f= &inputPorts_4322;
	_main_4330= &mains_4329;
	_argVal_4331= &argVals_432a;
	_functionCall_4332= &functionCalls_432d;
	processInputPackets( subsystems_431f, charts_4323, states_4325, mains_4327, functionCalls_432b);
}

bool CreateInputDataArgVal_431e::isInputUnique( const Udm::Object& subsystem_4337, const Udm::Object& chart_4340, const Udm::Object& state_4349, const Udm::Object& main_4352, const Udm::Object& functionCall_435b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_4339= _subsystem_4333.begin(), itChart_4342= _chart_433c.begin(), itState_434b= _state_4345.begin(), itMain_4354= _main_434e.begin(), itFunctionCall_435d= _functionCall_4357.begin(); itSubsystem_4339!= _subsystem_4333.end(), itChart_4342!= _chart_433c.end(), itState_434b!= _state_4345.end(), itMain_4354!= _main_434e.end(), itFunctionCall_435d!= _functionCall_4357.end(); ++itSubsystem_4339, ++itChart_4342, ++itState_434b, ++itMain_4354, ++itFunctionCall_435d)
	{
		if( ( *itSubsystem_4339== subsystem_4337)&& ( *itChart_4342== chart_4340)&& ( *itState_434b== state_4349)&& ( *itMain_4354== main_4352)&& ( *itFunctionCall_435d== functionCall_435b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_4333.push_back( subsystem_4337);
		_chart_433c.push_back( chart_4340);
		_state_4345.push_back( state_4349);
		_main_434e.push_back( main_4352);
		_functionCall_4357.push_back( functionCall_435b);
	}
	return isUnique;
}

bool CreateInputDataArgVal_431e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool CreateInputDataArgVal_431e::isGuardTrue( CyberComposition::Simulink::Subsystem& Chart, CyberComposition::Simulink::SFData& Data, SFC::FunctionCall& FunctionCall, CyberComposition::Simulink::InputPort& InputPort, SFC::Function& Main, CyberComposition::Simulink::SFState& State, CyberComposition::Simulink::Subsystem& Subsystem)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( Data.Scope() ) == "INPUT_DATA" &&
 static_cast< __int64 >( InputPort.Number() ) == static_cast< __int64 >( Data.Port() );;
	return Gz_guard;
}

void CreateInputDataArgVal_431e::processInputPackets( const Packets_t& subsystems_431f, const Packets_t& charts_4323, const Packets_t& states_4325, const Packets_t& mains_4327, const Packets_t& functionCalls_432b)
{
	for( Packets_t::const_iterator itSubsystem_4334= subsystems_431f.begin(), itChart_433d= charts_4323.begin(), itState_4346= states_4325.begin(), itMain_434f= mains_4327.begin(), itFunctionCall_4358= functionCalls_432b.begin(); itSubsystem_4334!= subsystems_431f.end(), itChart_433d!= charts_4323.end(), itState_4346!= states_4325.end(), itMain_434f!= mains_4327.end(), itFunctionCall_4358!= functionCalls_432b.end(); ++itSubsystem_4334, ++itChart_433d, ++itState_4346, ++itMain_434f, ++itFunctionCall_4358)
	{
		bool isUnique= isInputUnique( *itSubsystem_4334, *itChart_433d, *itState_4346, *itMain_434f, *itFunctionCall_4358);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_4334, *itChart_433d, *itState_4346, *itMain_434f, *itFunctionCall_4358);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateInputDataArgVal_431e::patternMatcher( const Udm::Object& subsystem_4335, const Udm::Object& chart_433e, const Udm::Object& state_4347, const Udm::Object& main_4350, const Udm::Object& functionCall_4359)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_4335.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_433a= CyberComposition::Simulink::Subsystem::Cast( subsystem_4335);
		if( false== Uml::IsDerivedFrom( chart_433e.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem chart_4343= CyberComposition::Simulink::Subsystem::Cast( chart_433e);
		if( false== Uml::IsDerivedFrom( state_4347.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState state_434c= CyberComposition::Simulink::SFState::Cast( state_4347);
		if( false== Uml::IsDerivedFrom( main_4350.type(), SFC::Function::meta))
			continue;
		SFC::Function main_4355= SFC::Function::Cast( main_4350);
		if( false== Uml::IsDerivedFrom( functionCall_4359.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall functionCall_435e= SFC::FunctionCall::Cast( functionCall_4359);
		set< CyberComposition::Simulink::InputPort> inputPorts_4360= chart_4343.InputPort_kind_children();
		for( set< CyberComposition::Simulink::InputPort>::const_iterator itInputPort_4361= inputPorts_4360.begin(); itInputPort_4361!= inputPorts_4360.end(); ++itInputPort_4361)
		{
			CyberComposition::Simulink::InputPort currInputPort_4362= *itInputPort_4361;
			set< CyberComposition::Simulink::SFData> datas_4363= state_434c.SFData_kind_children();
			for( set< CyberComposition::Simulink::SFData>::const_iterator itData_4364= datas_4363.begin(); itData_4364!= datas_4363.end(); ++itData_4364)
			{
				CyberComposition::Simulink::SFData currData_4365= *itData_4364;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_4369;
				if( !isValidBound(boundObjs_4369, subsystem_433a, true))
					continue;
				currMatch.subsystem_436a= subsystem_433a;
				if( !isValidBound(boundObjs_4369, chart_4343, true))
					continue;
				currMatch.chart_436b= chart_4343;
				if( !isValidBound(boundObjs_4369, state_434c, true))
					continue;
				currMatch.state_436c= state_434c;
				if( !isValidBound(boundObjs_4369, main_4355, true))
					continue;
				currMatch.main_436d= main_4355;
				if( !isValidBound(boundObjs_4369, functionCall_435e, true))
					continue;
				currMatch.functionCall_436e= functionCall_435e;
				if( !isValidBound(boundObjs_4369, currInputPort_4362, false))
					continue;
				currMatch.inputPort_436f= currInputPort_4362;
				if( !isValidBound(boundObjs_4369, currData_4365, false))
					continue;
				currMatch.data_4370= currData_4365;
				bool Gz_guard= isGuardTrue( currMatch.chart_436b, currMatch.data_4370, currMatch.functionCall_436e, currMatch.inputPort_436f, currMatch.main_436d, currMatch.state_436c, currMatch.subsystem_436a);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void CreateInputDataArgVal_431e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ArgVal newArgVal_4378= SFC::ArgVal::Create( currMatch.functionCall_436e);
		SFC::ArgVal& ArgVal= newArgVal_4378;
		CyberComposition::Simulink::Subsystem& Chart= currMatch.chart_436b;
		CyberComposition::Simulink::SFData& Data= currMatch.data_4370;
		SFC::FunctionCall& FunctionCall= currMatch.functionCall_436e;
		CyberComposition::Simulink::InputPort& InputPort= currMatch.inputPort_436f;
		SFC::Function& Main= currMatch.main_436d;
		CyberComposition::Simulink::SFState& State= currMatch.state_436c;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_436a;
		{
ArgVal.argIndex() = static_cast< __int64 >( FunctionCall.argCount() ) + static_cast< __int64 >( Data.Port() ) - 1;
};
		outputAppender( currMatch.subsystem_436a, currMatch.inputPort_436f, currMatch.main_436d, newArgVal_4378, currMatch.functionCall_436e);
	}
}

void CreateInputDataArgVal_431e::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_4379, const CyberComposition::Simulink::InputPort& inputPort_437b, const SFC::Function& main_437d, const SFC::ArgVal& argVal_437f, const SFC::FunctionCall& functionCall_4381)
{
	_subsystem_432e->push_back( subsystem_4379);
	_inputPort_432f->push_back( inputPort_437b);
	_main_4330->push_back( main_437d);
	_argVal_4331->push_back( argVal_437f);
	_functionCall_4332->push_back( functionCall_4381);
}

void OutputEvent_4393::operator()( const Packets_t& systems_4394, const Packets_t& childCharts_4396, const Packets_t& states_4398, const Packets_t& functions_439a, const Packets_t& functionCalls_439c)
{
#ifdef PRINT_INFO
	printLog( "OutputEvent_4393" );
#endif
	if( ( !systems_4394.empty())&& ( !childCharts_4396.empty())&& ( !states_4398.empty())&& ( !functions_439a.empty())&& ( !functionCalls_439c.empty()))
		callCreateOutputEventArgVal_4403( systems_4394, childCharts_4396, states_4398, functions_439a, functionCalls_439c);
}

void OutputEvent_4393::callCreateOutputEventArgVal_4403( const Packets_t& subsystems_439f, const Packets_t& charts_43a3, const Packets_t& states_43a5, const Packets_t& mains_43a7, const Packets_t& functionCalls_43ab)
{
	Packets_t subsystems_43a1;
	Packets_t outputPorts_43a2;
	Packets_t mains_43a9;
	Packets_t argVals_43aa;
	Packets_t functionCalls_43ad;
	CreateOutputEventArgVal_439e createOutputEventArgVal_439e;
	createOutputEventArgVal_439e( subsystems_439f, charts_43a3, states_43a5, mains_43a7, functionCalls_43ab, subsystems_43a1, outputPorts_43a2, mains_43a9, argVals_43aa, functionCalls_43ad);
	if( ( !subsystems_43a1.empty())&& ( !outputPorts_43a2.empty())&& ( !mains_43a9.empty())&& ( !argVals_43aa.empty())&& ( !functionCalls_43ad.empty()))
		callUpdateArgCount_4409( subsystems_43a1, outputPorts_43a2, mains_43a9, argVals_43aa, functionCalls_43ad);
}

void OutputEvent_4393::callUpdateArgCount_4409( const Packets_t& subsystems_41ed, const Packets_t& outputPorts_41f0, const Packets_t& functions_41f3, const Packets_t& argVals_41f5, const Packets_t& functionCalls_41f8)
{
	Packets_t subsystems_41ef;
	Packets_t outputPorts_41f2;
	Packets_t argVals_41f7;
	UpdateArgCount_41ec updateArgCount_41ec;
	updateArgCount_41ec( subsystems_41ed, outputPorts_41f0, functions_41f3, argVals_41f5, functionCalls_41f8, subsystems_41ef, outputPorts_41f2, argVals_41f7);
	if( ( !subsystems_41ef.empty())&& ( !outputPorts_41f2.empty())&& ( !argVals_41f7.empty()))
		callMakeArgDeclRef_440f( subsystems_41ef, outputPorts_41f2, argVals_41f7);
}

void OutputEvent_4393::callMakeArgDeclRef_440f( const Packets_t& systems_2cf6, const Packets_t& argPorts_2cf8, const Packets_t& argVals_2cfa)
{
	MakeArgDeclRef_2cf5 makeArgDeclRef_2cf5;
	makeArgDeclRef_2cf5( systems_2cf6, argPorts_2cf8, argVals_2cfa);
}

void CreateOutputEventArgVal_439e::operator()( const Packets_t& subsystems_439f, const Packets_t& charts_43a3, const Packets_t& states_43a5, const Packets_t& mains_43a7, const Packets_t& functionCalls_43ab, Packets_t& subsystems_43a1, Packets_t& outputPorts_43a2, Packets_t& mains_43a9, Packets_t& argVals_43aa, Packets_t& functionCalls_43ad)
{
#ifdef PRINT_INFO
	printLog( "CreateOutputEventArgVal_439e" );
#endif
	RTTGenerator::Instance()->generateRule(3896, "CreateOutputEventArgVal");
	_subsystem_43ae= &subsystems_43a1;
	_outputPort_43af= &outputPorts_43a2;
	_main_43b0= &mains_43a9;
	_argVal_43b1= &argVals_43aa;
	_functionCall_43b2= &functionCalls_43ad;
	processInputPackets( subsystems_439f, charts_43a3, states_43a5, mains_43a7, functionCalls_43ab);
}

bool CreateOutputEventArgVal_439e::isInputUnique( const Udm::Object& subsystem_43b7, const Udm::Object& chart_43c0, const Udm::Object& state_43c9, const Udm::Object& main_43d2, const Udm::Object& functionCall_43db)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_43b9= _subsystem_43b3.begin(), itChart_43c2= _chart_43bc.begin(), itState_43cb= _state_43c5.begin(), itMain_43d4= _main_43ce.begin(), itFunctionCall_43dd= _functionCall_43d7.begin(); itSubsystem_43b9!= _subsystem_43b3.end(), itChart_43c2!= _chart_43bc.end(), itState_43cb!= _state_43c5.end(), itMain_43d4!= _main_43ce.end(), itFunctionCall_43dd!= _functionCall_43d7.end(); ++itSubsystem_43b9, ++itChart_43c2, ++itState_43cb, ++itMain_43d4, ++itFunctionCall_43dd)
	{
		if( ( *itSubsystem_43b9== subsystem_43b7)&& ( *itChart_43c2== chart_43c0)&& ( *itState_43cb== state_43c9)&& ( *itMain_43d4== main_43d2)&& ( *itFunctionCall_43dd== functionCall_43db))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_43b3.push_back( subsystem_43b7);
		_chart_43bc.push_back( chart_43c0);
		_state_43c5.push_back( state_43c9);
		_main_43ce.push_back( main_43d2);
		_functionCall_43d7.push_back( functionCall_43db);
	}
	return isUnique;
}

bool CreateOutputEventArgVal_439e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool CreateOutputEventArgVal_439e::isGuardTrue( CyberComposition::Simulink::Subsystem& Chart, CyberComposition::Simulink::SFEvent& Event, SFC::FunctionCall& FunctionCall, SFC::Function& Main, CyberComposition::Simulink::OutputPort& OutputPort, CyberComposition::Simulink::SFState& State, CyberComposition::Simulink::Subsystem& Subsystem)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( Event.Scope() ) == "OUTPUT_EVENT" &&
 static_cast< std::string >( OutputPort.name() ) == static_cast< std::string >( Event.name() );;
	return Gz_guard;
}

void CreateOutputEventArgVal_439e::processInputPackets( const Packets_t& subsystems_439f, const Packets_t& charts_43a3, const Packets_t& states_43a5, const Packets_t& mains_43a7, const Packets_t& functionCalls_43ab)
{
	for( Packets_t::const_iterator itSubsystem_43b4= subsystems_439f.begin(), itChart_43bd= charts_43a3.begin(), itState_43c6= states_43a5.begin(), itMain_43cf= mains_43a7.begin(), itFunctionCall_43d8= functionCalls_43ab.begin(); itSubsystem_43b4!= subsystems_439f.end(), itChart_43bd!= charts_43a3.end(), itState_43c6!= states_43a5.end(), itMain_43cf!= mains_43a7.end(), itFunctionCall_43d8!= functionCalls_43ab.end(); ++itSubsystem_43b4, ++itChart_43bd, ++itState_43c6, ++itMain_43cf, ++itFunctionCall_43d8)
	{
		bool isUnique= isInputUnique( *itSubsystem_43b4, *itChart_43bd, *itState_43c6, *itMain_43cf, *itFunctionCall_43d8);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_43b4, *itChart_43bd, *itState_43c6, *itMain_43cf, *itFunctionCall_43d8);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateOutputEventArgVal_439e::patternMatcher( const Udm::Object& subsystem_43b5, const Udm::Object& chart_43be, const Udm::Object& state_43c7, const Udm::Object& main_43d0, const Udm::Object& functionCall_43d9)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_43b5.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_43ba= CyberComposition::Simulink::Subsystem::Cast( subsystem_43b5);
		if( false== Uml::IsDerivedFrom( chart_43be.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem chart_43c3= CyberComposition::Simulink::Subsystem::Cast( chart_43be);
		if( false== Uml::IsDerivedFrom( state_43c7.type(), CyberComposition::Simulink::SFState::meta))
			continue;
		CyberComposition::Simulink::SFState state_43cc= CyberComposition::Simulink::SFState::Cast( state_43c7);
		if( false== Uml::IsDerivedFrom( main_43d0.type(), SFC::Function::meta))
			continue;
		SFC::Function main_43d5= SFC::Function::Cast( main_43d0);
		if( false== Uml::IsDerivedFrom( functionCall_43d9.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall functionCall_43de= SFC::FunctionCall::Cast( functionCall_43d9);
		set< CyberComposition::Simulink::SFEvent> events_43e0= state_43cc.SFEvent_kind_children();
		for( set< CyberComposition::Simulink::SFEvent>::const_iterator itEvent_43e1= events_43e0.begin(); itEvent_43e1!= events_43e0.end(); ++itEvent_43e1)
		{
			CyberComposition::Simulink::SFEvent currEvent_43e2= *itEvent_43e1;
			set< CyberComposition::Simulink::OutputPort> outputPorts_43e3= chart_43c3.OutputPort_kind_children();
			for( set< CyberComposition::Simulink::OutputPort>::const_iterator itOutputPort_43e4= outputPorts_43e3.begin(); itOutputPort_43e4!= outputPorts_43e3.end(); ++itOutputPort_43e4)
			{
				CyberComposition::Simulink::OutputPort currOutputPort_43e5= *itOutputPort_43e4;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_43e9;
				if( !isValidBound(boundObjs_43e9, subsystem_43ba, true))
					continue;
				currMatch.subsystem_43ea= subsystem_43ba;
				if( !isValidBound(boundObjs_43e9, chart_43c3, true))
					continue;
				currMatch.chart_43eb= chart_43c3;
				if( !isValidBound(boundObjs_43e9, state_43cc, true))
					continue;
				currMatch.state_43ec= state_43cc;
				if( !isValidBound(boundObjs_43e9, main_43d5, true))
					continue;
				currMatch.main_43ed= main_43d5;
				if( !isValidBound(boundObjs_43e9, functionCall_43de, true))
					continue;
				currMatch.functionCall_43ee= functionCall_43de;
				if( !isValidBound(boundObjs_43e9, currOutputPort_43e5, false))
					continue;
				currMatch.outputPort_43ef= currOutputPort_43e5;
				if( !isValidBound(boundObjs_43e9, currEvent_43e2, false))
					continue;
				currMatch.event_43f0= currEvent_43e2;
				bool Gz_guard= isGuardTrue( currMatch.chart_43eb, currMatch.event_43f0, currMatch.functionCall_43ee, currMatch.main_43ed, currMatch.outputPort_43ef, currMatch.state_43ec, currMatch.subsystem_43ea);
				if( true== Gz_guard)
					_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void CreateOutputEventArgVal_439e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ArgVal newArgVal_43f8= SFC::ArgVal::Create( currMatch.functionCall_43ee);
		SFC::ArgVal& ArgVal= newArgVal_43f8;
		CyberComposition::Simulink::Subsystem& Chart= currMatch.chart_43eb;
		CyberComposition::Simulink::SFEvent& Event= currMatch.event_43f0;
		SFC::FunctionCall& FunctionCall= currMatch.functionCall_43ee;
		SFC::Function& Main= currMatch.main_43ed;
		CyberComposition::Simulink::OutputPort& OutputPort= currMatch.outputPort_43ef;
		CyberComposition::Simulink::SFState& State= currMatch.state_43ec;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_43ea;
		{
ArgVal.argIndex() = static_cast< __int64 >( FunctionCall.argCount() ) + static_cast< __int64 >( Event.Port() ) - 1;
};
		outputAppender( currMatch.subsystem_43ea, currMatch.outputPort_43ef, currMatch.main_43ed, newArgVal_43f8, currMatch.functionCall_43ee);
	}
}

void CreateOutputEventArgVal_439e::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_43f9, const CyberComposition::Simulink::OutputPort& outputPort_43fb, const SFC::Function& main_43fd, const SFC::ArgVal& argVal_43ff, const SFC::FunctionCall& functionCall_4401)
{
	_subsystem_43ae->push_back( subsystem_43f9);
	_outputPort_43af->push_back( outputPort_43fb);
	_main_43b0->push_back( main_43fd);
	_argVal_43b1->push_back( argVal_43ff);
	_functionCall_43b2->push_back( functionCall_4401);
}

void InputEvent_4413::operator()( const Packets_t& systems_4414, const Packets_t& childCharts_4416, const Packets_t& states_4418, const Packets_t& functions_441a, const Packets_t& functionCalls_441c, Packets_t& systems_441e, Packets_t& childCharts_441f, Packets_t& states_4420, Packets_t& functions_4421, Packets_t& functionCalls_4422)
{
#ifdef PRINT_INFO
	printLog( "InputEvent_4413" );
#endif
	_system_4423= &systems_441e;
	_childChart_4424= &childCharts_441f;
	_state_4425= &states_4420;
	_function_4426= &functions_4421;
	_functionCall_4427= &functionCalls_4422;
	if( ( !childCharts_4416.empty())&& ( !functions_441a.empty())&& ( !functionCalls_441c.empty()))
		callGetOldVar_452f( childCharts_4416, functions_441a, functionCalls_441c);
	_system_4423->insert( _system_4423->end(), systems_4414.begin(), systems_4414.end());
	_childChart_4424->insert( _childChart_4424->end(), childCharts_4416.begin(), childCharts_4416.end());
	_state_4425->insert( _state_4425->end(), states_4418.begin(), states_4418.end());
	_function_4426->insert( _function_4426->end(), functions_441a.begin(), functions_441a.end());
	_functionCall_4427->insert( _functionCall_4427->end(), functionCalls_441c.begin(), functionCalls_441c.end());
}

void InputEvent_4413::callGetOldVar_452f( const Packets_t& blocks_44f6, const Packets_t& mains_44f8, const Packets_t& functionCalls_44fb)
{
	Packets_t localVars_44f5;
	Packets_t mains_44fa;
	Packets_t functionCalls_44fd;
	GetOldVar_44f4 getOldVar_44f4;
	getOldVar_44f4( blocks_44f6, mains_44f8, functionCalls_44fb, localVars_44f5, mains_44fa, functionCalls_44fd);
	if( ( !localVars_44f5.empty())&& ( !mains_44fa.empty())&& ( !functionCalls_44fd.empty()))
		callMatrixInputEvent_4533( localVars_44f5, mains_44fa, functionCalls_44fd);
}

void InputEvent_4413::callMatrixInputEvent_4533( const Packets_t& oldvars_44ab, const Packets_t& functions_44ad, const Packets_t& functionCalls_44af)
{
	Packets_t oldvars_44b1;
	Packets_t functions_44b2;
	Packets_t functionCalls_44b3;
	MatrixInputEvent_44aa matrixInputEvent_44aa;
	matrixInputEvent_44aa( oldvars_44ab, functions_44ad, functionCalls_44af, oldvars_44b1, functions_44b2, functionCalls_44b3);
	if( ( !oldvars_44b1.empty())&& ( !functions_44b2.empty())&& ( !functionCalls_44b3.empty()))
		callStructInputEvent_4537( oldvars_44b1, functions_44b2, functionCalls_44b3);
}

void InputEvent_4413::callStructInputEvent_4537( const Packets_t& oldvars_4429, const Packets_t& functions_442b, const Packets_t& functionCalls_442d)
{
	StructInputEvent_4428 structInputEvent_4428;
	structInputEvent_4428( oldvars_4429, functions_442b, functionCalls_442d);
}

void StructInputEvent_4428::operator()( const Packets_t& oldvars_4429, const Packets_t& functions_442b, const Packets_t& functionCalls_442d)
{
#ifdef PRINT_INFO
	printLog( "StructInputEvent_4428" );
#endif
	if( ( !oldvars_4429.empty())&& ( !functions_442b.empty())&& ( !functionCalls_442d.empty()))
		callStructInputEventArgVal_44a2( oldvars_4429, functions_442b, functionCalls_442d);
}

void StructInputEvent_4428::callStructInputEventArgVal_44a2( const Packets_t& localVars_4461, const Packets_t& mains_4463, const Packets_t& functionCalls_4467)
{
	Packets_t mains_4465;
	Packets_t argVals_4466;
	Packets_t functionCalls_4469;
	StructInputEventArgVal_4460 structInputEventArgVal_4460;
	structInputEventArgVal_4460( localVars_4461, mains_4463, functionCalls_4467, mains_4465, argVals_4466, functionCalls_4469);
	if( ( !mains_4465.empty())&& ( !argVals_4466.empty())&& ( !functionCalls_4469.empty()))
		callUpdateArgCount_44a6( mains_4465, argVals_4466, functionCalls_4469);
}

void StructInputEvent_4428::callUpdateArgCount_44a6( const Packets_t& functions_4430, const Packets_t& argVals_4432, const Packets_t& functionCalls_4434)
{
	UpdateArgCount_442f updateArgCount_442f;
	updateArgCount_442f( functions_4430, argVals_4432, functionCalls_4434);
}

void UpdateArgCount_442f::operator()( const Packets_t& functions_4430, const Packets_t& argVals_4432, const Packets_t& functionCalls_4434)
{
#ifdef PRINT_INFO
	printLog( "UpdateArgCount_442f" );
#endif
	RTTGenerator::Instance()->generateRule(3924, "UpdateArgCount");
	processInputPackets( functions_4430, argVals_4432, functionCalls_4434);
}

bool UpdateArgCount_442f::isInputUnique( const Udm::Object& function_443a, const Udm::Object& argVal_4443, const Udm::Object& functionCall_444c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itFunction_443c= _function_4436.begin(), itArgVal_4445= _argVal_443f.begin(), itFunctionCall_444e= _functionCall_4448.begin(); itFunction_443c!= _function_4436.end(), itArgVal_4445!= _argVal_443f.end(), itFunctionCall_444e!= _functionCall_4448.end(); ++itFunction_443c, ++itArgVal_4445, ++itFunctionCall_444e)
	{
		if( ( *itFunction_443c== function_443a)&& ( *itArgVal_4445== argVal_4443)&& ( *itFunctionCall_444e== functionCall_444c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_function_4436.push_back( function_443a);
		_argVal_443f.push_back( argVal_4443);
		_functionCall_4448.push_back( functionCall_444c);
	}
	return isUnique;
}

bool UpdateArgCount_442f::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool UpdateArgCount_442f::isGuardTrue( SFC::Arg& Arg, SFC::ArgVal& ArgVal, SFC::Function& Function, SFC::FunctionCall& FunctionCall)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< __int64 >( Arg.argIndex() ) == static_cast< __int64 >( ArgVal.argIndex() );;
	return Gz_guard;
}

void UpdateArgCount_442f::processInputPackets( const Packets_t& functions_4430, const Packets_t& argVals_4432, const Packets_t& functionCalls_4434)
{
	for( Packets_t::const_iterator itFunction_4437= functions_4430.begin(), itArgVal_4440= argVals_4432.begin(), itFunctionCall_4449= functionCalls_4434.begin(); itFunction_4437!= functions_4430.end(), itArgVal_4440!= argVals_4432.end(), itFunctionCall_4449!= functionCalls_4434.end(); ++itFunction_4437, ++itArgVal_4440, ++itFunctionCall_4449)
	{
		bool isUnique= isInputUnique( *itFunction_4437, *itArgVal_4440, *itFunctionCall_4449);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itFunction_4437, *itArgVal_4440, *itFunctionCall_4449);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool UpdateArgCount_442f::patternMatcher( const Udm::Object& function_4438, const Udm::Object& argVal_4441, const Udm::Object& functionCall_444a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( function_4438.type(), SFC::Function::meta))
			continue;
		SFC::Function function_443d= SFC::Function::Cast( function_4438);
		if( false== Uml::IsDerivedFrom( argVal_4441.type(), SFC::ArgVal::meta))
			continue;
		SFC::ArgVal argVal_4446= SFC::ArgVal::Cast( argVal_4441);
		if( false== Uml::IsDerivedFrom( functionCall_444a.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall functionCall_444f= SFC::FunctionCall::Cast( functionCall_444a);
		set< SFC::Arg> args_4451= function_443d.Arg_kind_children();
		for( set< SFC::Arg>::const_iterator itArg_4452= args_4451.begin(); itArg_4452!= args_4451.end(); ++itArg_4452)
		{
			SFC::Arg currArg_4453= *itArg_4452;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_4457;
			if( !isValidBound(boundObjs_4457, function_443d, true))
				continue;
			currMatch.function_4458= function_443d;
			if( !isValidBound(boundObjs_4457, argVal_4446, true))
				continue;
			currMatch.argVal_4459= argVal_4446;
			if( !isValidBound(boundObjs_4457, functionCall_444f, true))
				continue;
			currMatch.functionCall_445a= functionCall_444f;
			if( !isValidBound(boundObjs_4457, currArg_4453, false))
				continue;
			currMatch.arg_445b= currArg_4453;
			bool Gz_guard= isGuardTrue( currMatch.arg_445b, currMatch.argVal_4459, currMatch.function_4458, currMatch.functionCall_445a);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void UpdateArgCount_442f::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg& Arg= currMatch.arg_445b;
		SFC::ArgVal& ArgVal= currMatch.argVal_4459;
		SFC::Function& Function= currMatch.function_4458;
		SFC::FunctionCall& FunctionCall= currMatch.functionCall_445a;
		{
FunctionCall.argCount() = static_cast< __int64 >( FunctionCall.argCount() ) + 1;
};
		currMatch.argVal_4459.arg()+= currMatch.arg_445b;
	}
}

void StructInputEventArgVal_4460::operator()( const Packets_t& localVars_4461, const Packets_t& mains_4463, const Packets_t& functionCalls_4467, Packets_t& mains_4465, Packets_t& argVals_4466, Packets_t& functionCalls_4469)
{
#ifdef PRINT_INFO
	printLog( "StructInputEventArgVal_4460" );
#endif
	RTTGenerator::Instance()->generateRule(3932, "StructInputEventArgVal");
	_main_446a= &mains_4465;
	_argVal_446b= &argVals_4466;
	_functionCall_446c= &functionCalls_4469;
	processInputPackets( localVars_4461, mains_4463, functionCalls_4467);
}

bool StructInputEventArgVal_4460::isInputUnique( const Udm::Object& localVar_4471, const Udm::Object& main_447a, const Udm::Object& functionCall_4483)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itLocalVar_4473= _localVar_446d.begin(), itMain_447c= _main_4476.begin(), itFunctionCall_4485= _functionCall_447f.begin(); itLocalVar_4473!= _localVar_446d.end(), itMain_447c!= _main_4476.end(), itFunctionCall_4485!= _functionCall_447f.end(); ++itLocalVar_4473, ++itMain_447c, ++itFunctionCall_4485)
	{
		if( ( *itLocalVar_4473== localVar_4471)&& ( *itMain_447c== main_447a)&& ( *itFunctionCall_4485== functionCall_4483))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_localVar_446d.push_back( localVar_4471);
		_main_4476.push_back( main_447a);
		_functionCall_447f.push_back( functionCall_4483);
	}
	return isUnique;
}

bool StructInputEventArgVal_4460::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void StructInputEventArgVal_4460::processInputPackets( const Packets_t& localVars_4461, const Packets_t& mains_4463, const Packets_t& functionCalls_4467)
{
	for( Packets_t::const_iterator itLocalVar_446e= localVars_4461.begin(), itMain_4477= mains_4463.begin(), itFunctionCall_4480= functionCalls_4467.begin(); itLocalVar_446e!= localVars_4461.end(), itMain_4477!= mains_4463.end(), itFunctionCall_4480!= functionCalls_4467.end(); ++itLocalVar_446e, ++itMain_4477, ++itFunctionCall_4480)
	{
		bool isUnique= isInputUnique( *itLocalVar_446e, *itMain_4477, *itFunctionCall_4480);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itLocalVar_446e, *itMain_4477, *itFunctionCall_4480);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool StructInputEventArgVal_4460::patternMatcher( const Udm::Object& localVar_446f, const Udm::Object& main_4478, const Udm::Object& functionCall_4481)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( localVar_446f.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_4474= SFC::LocalVar::Cast( localVar_446f);
		if( false== Uml::IsDerivedFrom( main_4478.type(), SFC::Function::meta))
			continue;
		SFC::Function main_447d= SFC::Function::Cast( main_4478);
		if( false== Uml::IsDerivedFrom( functionCall_4481.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall functionCall_4486= SFC::FunctionCall::Cast( functionCall_4481);
		SFC::LocalVar triggerVar_4488= localVar_4474.trigvar();
		if( !triggerVar_4488)
			continue;
		SFC::DT struct_4489= localVar_4474.dt();
		if( !struct_4489 || false== Uml::IsDerivedFrom( struct_4489.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_448a= SFC::Struct::Cast( struct_4489);
		if( !struct_448a)
			continue;
		set< SFC::LocalVar> members_448b= struct_448a.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itMember_448c= members_448b.begin(); itMember_448c!= members_448b.end(); ++itMember_448c)
		{
			SFC::LocalVar currMember_448d= *itMember_448c;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_4491;
			if( !isValidBound(boundObjs_4491, localVar_4474, true))
				continue;
			currMatch.localVar_4492= localVar_4474;
			if( !isValidBound(boundObjs_4491, main_447d, true))
				continue;
			currMatch.main_4493= main_447d;
			if( !isValidBound(boundObjs_4491, functionCall_4486, true))
				continue;
			currMatch.functionCall_4494= functionCall_4486;
			if( !isValidBound(boundObjs_4491, triggerVar_4488, false))
				continue;
			currMatch.triggerVar_4495= triggerVar_4488;
			if( !isValidBound(boundObjs_4491, struct_448a, false))
				continue;
			currMatch.struct_4496= struct_448a;
			if( !isValidBound(boundObjs_4491, currMember_448d, false))
				continue;
			currMatch.member_4497= currMember_448d;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void StructInputEventArgVal_4460::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ArgVal newArgVal_4498= SFC::ArgVal::Create( currMatch.functionCall_4494);
		SFC::BinaryExprs newDot_4499= SFC::BinaryExprs::Create( newArgVal_4498, SFC::ArgVal::meta_argexpr);
		SFC::ArgDeclRef newArgDeclRef_449a= SFC::ArgDeclRef::Create( newDot_4499, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_449b= SFC::ArgDeclRef::Create( newDot_4499, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_449a;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_449b;
		SFC::ArgVal& ArgVal= newArgVal_4498;
		SFC::BinaryExprs& Dot= newDot_4499;
		SFC::FunctionCall& FunctionCall= currMatch.functionCall_4494;
		SFC::LocalVar& LocalVar= currMatch.localVar_4492;
		SFC::Function& Main= currMatch.main_4493;
		SFC::LocalVar& Member= currMatch.member_4497;
		SFC::Struct& Struct= currMatch.struct_4496;
		SFC::LocalVar& TriggerVar= currMatch.triggerVar_4495;
		{
ArgVal.argIndex() = static_cast< __int64 >( FunctionCall.argCount() ) + static_cast< __int64 >( Member.statementIndex() );
};
		{
Dot.op() = ".";
};
		newArgDeclRef_449a.argdecl()= currMatch.triggerVar_4495;
		newArgDeclRef2_449b.argdecl()= currMatch.member_4497;
		outputAppender( currMatch.main_4493, newArgVal_4498, currMatch.functionCall_4494);
	}
}

void StructInputEventArgVal_4460::outputAppender( const SFC::Function& main_449c, const SFC::ArgVal& argVal_449e, const SFC::FunctionCall& functionCall_44a0)
{
	_main_446a->push_back( main_449c);
	_argVal_446b->push_back( argVal_449e);
	_functionCall_446c->push_back( functionCall_44a0);
}

void MatrixInputEvent_44aa::operator()( const Packets_t& oldvars_44ab, const Packets_t& functions_44ad, const Packets_t& functionCalls_44af, Packets_t& oldvars_44b1, Packets_t& functions_44b2, Packets_t& functionCalls_44b3)
{
#ifdef PRINT_INFO
	printLog( "MatrixInputEvent_44aa" );
#endif
	_oldvar_44b4= &oldvars_44b1;
	_function_44b5= &functions_44b2;
	_functionCall_44b6= &functionCalls_44b3;
	if( ( !oldvars_44ab.empty())&& ( !functions_44ad.empty())&& ( !functionCalls_44af.empty()))
		callMatrixInputEventArgVal_44f0( oldvars_44ab, functions_44ad, functionCalls_44af);
	_oldvar_44b4->insert( _oldvar_44b4->end(), oldvars_44ab.begin(), oldvars_44ab.end());
	_function_44b5->insert( _function_44b5->end(), functions_44ad.begin(), functions_44ad.end());
	_functionCall_44b6->insert( _functionCall_44b6->end(), functionCalls_44af.begin(), functionCalls_44af.end());
}

void MatrixInputEvent_44aa::callMatrixInputEventArgVal_44f0( const Packets_t& localVars_44b8, const Packets_t& functions_44ba, const Packets_t& functionCalls_44bc)
{
	MatrixInputEventArgVal_44b7 matrixInputEventArgVal_44b7;
	matrixInputEventArgVal_44b7( localVars_44b8, functions_44ba, functionCalls_44bc);
}

void MatrixInputEventArgVal_44b7::operator()( const Packets_t& localVars_44b8, const Packets_t& functions_44ba, const Packets_t& functionCalls_44bc)
{
#ifdef PRINT_INFO
	printLog( "MatrixInputEventArgVal_44b7" );
#endif
	RTTGenerator::Instance()->generateRule(3961, "MatrixInputEventArgVal");
	processInputPackets( localVars_44b8, functions_44ba, functionCalls_44bc);
}

bool MatrixInputEventArgVal_44b7::isInputUnique( const Udm::Object& localVar_44c2, const Udm::Object& function_44cb, const Udm::Object& functionCall_44d4)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itLocalVar_44c4= _localVar_44be.begin(), itFunction_44cd= _function_44c7.begin(), itFunctionCall_44d6= _functionCall_44d0.begin(); itLocalVar_44c4!= _localVar_44be.end(), itFunction_44cd!= _function_44c7.end(), itFunctionCall_44d6!= _functionCall_44d0.end(); ++itLocalVar_44c4, ++itFunction_44cd, ++itFunctionCall_44d6)
	{
		if( ( *itLocalVar_44c4== localVar_44c2)&& ( *itFunction_44cd== function_44cb)&& ( *itFunctionCall_44d6== functionCall_44d4))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_localVar_44be.push_back( localVar_44c2);
		_function_44c7.push_back( function_44cb);
		_functionCall_44d0.push_back( functionCall_44d4);
	}
	return isUnique;
}

bool MatrixInputEventArgVal_44b7::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool MatrixInputEventArgVal_44b7::isGuardTrue( SFC::Arg& Arg, SFC::DT& DT, SFC::Function& Function, SFC::FunctionCall& FunctionCall, SFC::LocalVar& LocalVar, SFC::LocalVar& TriggerVar)
{
	bool Gz_guard= false;
	Gz_guard = DT.type() != SFC::Struct::meta;;
	return Gz_guard;
}

void MatrixInputEventArgVal_44b7::processInputPackets( const Packets_t& localVars_44b8, const Packets_t& functions_44ba, const Packets_t& functionCalls_44bc)
{
	for( Packets_t::const_iterator itLocalVar_44bf= localVars_44b8.begin(), itFunction_44c8= functions_44ba.begin(), itFunctionCall_44d1= functionCalls_44bc.begin(); itLocalVar_44bf!= localVars_44b8.end(), itFunction_44c8!= functions_44ba.end(), itFunctionCall_44d1!= functionCalls_44bc.end(); ++itLocalVar_44bf, ++itFunction_44c8, ++itFunctionCall_44d1)
	{
		bool isUnique= isInputUnique( *itLocalVar_44bf, *itFunction_44c8, *itFunctionCall_44d1);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itLocalVar_44bf, *itFunction_44c8, *itFunctionCall_44d1);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool MatrixInputEventArgVal_44b7::patternMatcher( const Udm::Object& localVar_44c0, const Udm::Object& function_44c9, const Udm::Object& functionCall_44d2)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( localVar_44c0.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_44c5= SFC::LocalVar::Cast( localVar_44c0);
		if( false== Uml::IsDerivedFrom( function_44c9.type(), SFC::Function::meta))
			continue;
		SFC::Function function_44ce= SFC::Function::Cast( function_44c9);
		if( false== Uml::IsDerivedFrom( functionCall_44d2.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall functionCall_44d7= SFC::FunctionCall::Cast( functionCall_44d2);
		set< SFC::Arg> args_44d9= function_44ce.Arg_kind_children();
		for( set< SFC::Arg>::const_iterator itArg_44da= args_44d9.begin(); itArg_44da!= args_44d9.end(); ++itArg_44da)
		{
			SFC::Arg currArg_44db= *itArg_44da;
			SFC::DT dT_44dc= localVar_44c5.dt();
			if( !dT_44dc)
				continue;
			SFC::LocalVar triggerVar_44dd= localVar_44c5.trigvar();
			if( !triggerVar_44dd)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_44e1;
			if( !isValidBound(boundObjs_44e1, localVar_44c5, true))
				continue;
			currMatch.localVar_44e2= localVar_44c5;
			if( !isValidBound(boundObjs_44e1, function_44ce, true))
				continue;
			currMatch.function_44e3= function_44ce;
			if( !isValidBound(boundObjs_44e1, functionCall_44d7, true))
				continue;
			currMatch.functionCall_44e4= functionCall_44d7;
			if( !isValidBound(boundObjs_44e1, dT_44dc, false))
				continue;
			currMatch.dT_44e5= dT_44dc;
			if( !isValidBound(boundObjs_44e1, triggerVar_44dd, false))
				continue;
			currMatch.triggerVar_44e6= triggerVar_44dd;
			if( !isValidBound(boundObjs_44e1, currArg_44db, false))
				continue;
			currMatch.arg_44e7= currArg_44db;
			bool Gz_guard= isGuardTrue( currMatch.arg_44e7, currMatch.dT_44e5, currMatch.function_44e3, currMatch.functionCall_44e4, currMatch.localVar_44e2, currMatch.triggerVar_44e6);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void MatrixInputEventArgVal_44b7::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ArgVal newArgVal_44ee= SFC::ArgVal::Create( currMatch.functionCall_44e4);
		SFC::ArgDeclRef newArgDeclRef_44ef= SFC::ArgDeclRef::Create( newArgVal_44ee, SFC::ArgVal::meta_argexpr);
		SFC::Arg& Arg= currMatch.arg_44e7;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_44ef;
		SFC::ArgVal& ArgVal= newArgVal_44ee;
		SFC::DT& DT= currMatch.dT_44e5;
		SFC::Function& Function= currMatch.function_44e3;
		SFC::FunctionCall& FunctionCall= currMatch.functionCall_44e4;
		SFC::LocalVar& LocalVar= currMatch.localVar_44e2;
		SFC::LocalVar& TriggerVar= currMatch.triggerVar_44e6;
		{
__int64 argCount = FunctionCall.argCount();
ArgVal.argIndex() = argCount++;
FunctionCall.argCount() = argCount;
};
		newArgVal_44ee.arg()+= currMatch.arg_44e7;
		newArgDeclRef_44ef.argdecl()= currMatch.triggerVar_44e6;
	}
}

void GetOldVar_44f4::operator()( const Packets_t& blocks_44f6, const Packets_t& mains_44f8, const Packets_t& functionCalls_44fb, Packets_t& localVars_44f5, Packets_t& mains_44fa, Packets_t& functionCalls_44fd)
{
#ifdef PRINT_INFO
	printLog( "GetOldVar_44f4" );
#endif
	RTTGenerator::Instance()->generateRule(3978, "GetOldVar");
	_localVar_44fe= &localVars_44f5;
	_main_44ff= &mains_44fa;
	_functionCall_4500= &functionCalls_44fd;
	processInputPackets( blocks_44f6, mains_44f8, functionCalls_44fb);
}

bool GetOldVar_44f4::isInputUnique( const Udm::Object& block_4505, const Udm::Object& main_450e, const Udm::Object& functionCall_4517)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itBlock_4507= _block_4501.begin(), itMain_4510= _main_450a.begin(), itFunctionCall_4519= _functionCall_4513.begin(); itBlock_4507!= _block_4501.end(), itMain_4510!= _main_450a.end(), itFunctionCall_4519!= _functionCall_4513.end(); ++itBlock_4507, ++itMain_4510, ++itFunctionCall_4519)
	{
		if( ( *itBlock_4507== block_4505)&& ( *itMain_4510== main_450e)&& ( *itFunctionCall_4519== functionCall_4517))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_block_4501.push_back( block_4505);
		_main_450a.push_back( main_450e);
		_functionCall_4513.push_back( functionCall_4517);
	}
	return isUnique;
}

bool GetOldVar_44f4::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetOldVar_44f4::processInputPackets( const Packets_t& blocks_44f6, const Packets_t& mains_44f8, const Packets_t& functionCalls_44fb)
{
	for( Packets_t::const_iterator itBlock_4502= blocks_44f6.begin(), itMain_450b= mains_44f8.begin(), itFunctionCall_4514= functionCalls_44fb.begin(); itBlock_4502!= blocks_44f6.end(), itMain_450b!= mains_44f8.end(), itFunctionCall_4514!= functionCalls_44fb.end(); ++itBlock_4502, ++itMain_450b, ++itFunctionCall_4514)
	{
		bool isUnique= isInputUnique( *itBlock_4502, *itMain_450b, *itFunctionCall_4514);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itBlock_4502, *itMain_450b, *itFunctionCall_4514);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetOldVar_44f4::patternMatcher( const Udm::Object& block_4503, const Udm::Object& main_450c, const Udm::Object& functionCall_4515)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( block_4503.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem block_4508= CyberComposition::Simulink::Subsystem::Cast( block_4503);
		if( false== Uml::IsDerivedFrom( main_450c.type(), SFC::Function::meta))
			continue;
		SFC::Function main_4511= SFC::Function::Cast( main_450c);
		if( false== Uml::IsDerivedFrom( functionCall_4515.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall functionCall_451a= SFC::FunctionCall::Cast( functionCall_4515);
		set< CyberComposition::Simulink::TriggerPort> triggerPorts_451c= block_4508.TriggerPort_kind_children();
		for( set< CyberComposition::Simulink::TriggerPort>::const_iterator itTriggerPort_451d= triggerPorts_451c.begin(); itTriggerPort_451d!= triggerPorts_451c.end(); ++itTriggerPort_451d)
		{
			CyberComposition::Simulink::TriggerPort currTriggerPort_451e= *itTriggerPort_451d;
			SFC::LocalVar localVar_451f= currTriggerPort_451e.memb();
			if( !localVar_451f)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_4523;
			if( !isValidBound(boundObjs_4523, block_4508, true))
				continue;
			currMatch.block_4524= block_4508;
			if( !isValidBound(boundObjs_4523, main_4511, true))
				continue;
			currMatch.main_4525= main_4511;
			if( !isValidBound(boundObjs_4523, functionCall_451a, true))
				continue;
			currMatch.functionCall_4526= functionCall_451a;
			if( !isValidBound(boundObjs_4523, localVar_451f, false))
				continue;
			currMatch.localVar_4527= localVar_451f;
			if( !isValidBound(boundObjs_4523, currTriggerPort_451e, false))
				continue;
			currMatch.triggerPort_4528= currTriggerPort_451e;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetOldVar_44f4::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.localVar_4527, currMatch.main_4525, currMatch.functionCall_4526);
	}
}

void GetOldVar_44f4::outputAppender( const SFC::LocalVar& localVar_4529, const SFC::Function& main_452b, const SFC::FunctionCall& functionCall_452d)
{
	_localVar_44fe->push_back( localVar_4529);
	_main_44ff->push_back( main_452b);
	_functionCall_4500->push_back( functionCall_452d);
}

void MakeTrigger_453b::operator()( const Packets_t& systems_453c, const Packets_t& childSubsystems_453e, const Packets_t& systemFunctions_4540, Packets_t& systems_4542, Packets_t& childSubsystems_4543, Packets_t& compoundStatements_4544)
{
#ifdef PRINT_INFO
	printLog( "MakeTrigger_453b" );
#endif
	_system_4545= &systems_4542;
	_childSubsystem_4546= &childSubsystems_4543;
	_compoundStatement_4547= &compoundStatements_4544;
	if( ( !systems_453c.empty())&& ( !childSubsystems_453e.empty())&& ( !systemFunctions_4540.empty()))
		callIsTriggered_5232( systems_453c, childSubsystems_453e, systemFunctions_4540);
}

void MakeTrigger_453b::callIsTriggered_5232( const Packets_t& systems_4549, const Packets_t& childSubsystems_454b, const Packets_t& systemFunctions_454d)
{
	Packets_t systems_454f;
	Packets_t childSubsystems_4550;
	Packets_t systemFunctions_4551;
	Packets_t systems_4552;
	Packets_t childSubsystems_4553;
	Packets_t systemFunctions_4554;
	IsTriggered_4548 isTriggered_4548;
	isTriggered_4548( systems_4549, childSubsystems_454b, systemFunctions_454d, systems_454f, childSubsystems_4550, systemFunctions_4551, systems_4552, childSubsystems_4553, systemFunctions_4554);
	if( ( !systems_454f.empty())&& ( !childSubsystems_4550.empty())&& ( !systemFunctions_4551.empty()))
		callCreateTriggering_5236( systems_454f, childSubsystems_4550, systemFunctions_4551);
	_system_4545->insert( _system_4545->end(), systems_4552.begin(), systems_4552.end());
	_childSubsystem_4546->insert( _childSubsystem_4546->end(), childSubsystems_4553.begin(), childSubsystems_4553.end());
	_compoundStatement_4547->insert( _compoundStatement_4547->end(), systemFunctions_4554.begin(), systemFunctions_4554.end());
}

void MakeTrigger_453b::callCreateTriggering_5236( const Packets_t& systems_45df, const Packets_t& childSubsystems_45e1, const Packets_t& systemFunctions_45e3)
{
	Packets_t systems_45e5;
	Packets_t childSubsystems_45e6;
	Packets_t conditionalBlocks_45e7;
	CreateTriggering_45de createTriggering_45de;
	createTriggering_45de( systems_45df, childSubsystems_45e1, systemFunctions_45e3, systems_45e5, childSubsystems_45e6, conditionalBlocks_45e7);
	_system_4545->insert( _system_4545->end(), systems_45e5.begin(), systems_45e5.end());
	_childSubsystem_4546->insert( _childSubsystem_4546->end(), childSubsystems_45e6.begin(), childSubsystems_45e6.end());
	_compoundStatement_4547->insert( _compoundStatement_4547->end(), conditionalBlocks_45e7.begin(), conditionalBlocks_45e7.end());
}

void IsTriggered_4548::operator()( const Packets_t& systems_4549, const Packets_t& childSubsystems_454b, const Packets_t& systemFunctions_454d, Packets_t& systems_454f, Packets_t& childSubsystems_4550, Packets_t& systemFunctions_4551, Packets_t& systems_4552, Packets_t& childSubsystems_4553, Packets_t& systemFunctions_4554)
{
#ifdef PRINT_INFO
	printLog( "IsTriggered_4548" );
#endif
	_system_4555= &systems_454f;
	_childSubsystem_4556= &childSubsystems_4550;
	_systemFunction_4557= &systemFunctions_4551;
	_system_4558= &systems_4552;
	_childSubsystem_4559= &childSubsystems_4553;
	_systemFunction_455a= &systemFunctions_4554;
	for( Packets_t::const_iterator itsystem_455c= systems_4549.begin(), itchildSubsystem_4563= childSubsystems_454b.begin(), itsystemFunction_456a= systemFunctions_454d.begin(); itsystem_455c!= systems_4549.end(), itchildSubsystem_4563!= childSubsystems_454b.end(), itsystemFunction_456a!= systemFunctions_454d.end(); ++itsystem_455c, ++itchildSubsystem_4563, ++itsystemFunction_456a)
	{
		bool isUnique= isInputUnique( *itsystem_455c, *itchildSubsystem_4563, *itsystemFunction_456a);
		if( !isUnique)
			continue;
		Packets_t onesystem_4560( 1, *itsystem_455c);
		Packets_t onechildSubsystem_4567( 1, *itchildSubsystem_4563);
		Packets_t onesystemFunction_456e( 1, *itsystemFunction_456a);
		executeOne( onesystem_4560, onechildSubsystem_4567, onesystemFunction_456e);
	}
}

void IsTriggered_4548::executeOne( const Packets_t& systems_4549, const Packets_t& childSubsystems_454b, const Packets_t& systemFunctions_454d)
{
	Packets_t subsystems_4573;
	Packets_t blocks_4576;
	Packets_t mains_4579;
	HasTriggers_4570 hasTriggers_4570;
	bool isMatchHasTriggers_4570= hasTriggers_4570( systems_4549, childSubsystems_454b, systemFunctions_454d, subsystems_4573, blocks_4576, mains_4579);
	_system_4555->insert( _system_4555->end(), subsystems_4573.begin(), subsystems_4573.end());
	_childSubsystem_4556->insert( _childSubsystem_4556->end(), blocks_4576.begin(), blocks_4576.end());
	_systemFunction_4557->insert( _systemFunction_4557->end(), mains_4579.begin(), mains_4579.end());
	if( isMatchHasTriggers_4570)
		return;
	Packets_t subsystems_45ac;
	Packets_t blocks_45af;
	Packets_t mains_45b2;
	Otherwise_45a9 otherwise_45a9;
	bool isMatchOtherwise_45a9= otherwise_45a9( systems_4549, childSubsystems_454b, systemFunctions_454d, subsystems_45ac, blocks_45af, mains_45b2);
	_system_4558->insert( _system_4558->end(), subsystems_45ac.begin(), subsystems_45ac.end());
	_childSubsystem_4559->insert( _childSubsystem_4559->end(), blocks_45af.begin(), blocks_45af.end());
	_systemFunction_455a->insert( _systemFunction_455a->end(), mains_45b2.begin(), mains_45b2.end());
	if( isMatchOtherwise_45a9)
		return;
}

bool IsTriggered_4548::isInputUnique( const Udm::Object& system_455d, const Udm::Object& childSubsystem_4564, const Udm::Object& systemFunction_456b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itsystem_455f= _system_455b.begin(), itchildSubsystem_4566= _childSubsystem_4562.begin(), itsystemFunction_456d= _systemFunction_4569.begin(); itsystem_455f!= _system_455b.end(), itchildSubsystem_4566!= _childSubsystem_4562.end(), itsystemFunction_456d!= _systemFunction_4569.end(); ++itsystem_455f, ++itchildSubsystem_4566, ++itsystemFunction_456d)
	{
		if( ( *itsystem_455f== system_455d)&& ( *itchildSubsystem_4566== childSubsystem_4564)&& ( *itsystemFunction_456d== systemFunction_456b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_system_455b.push_back( system_455d);
		_childSubsystem_4562.push_back( childSubsystem_4564);
		_systemFunction_4569.push_back( systemFunction_456b);
	}
	return isUnique;
}

bool HasTriggers_4570::operator()( const Packets_t& subsystems_4571, const Packets_t& blocks_4574, const Packets_t& mains_4577, Packets_t& subsystems_4573, Packets_t& blocks_4576, Packets_t& mains_4579)
{
#ifdef PRINT_INFO
	printLog( "HasTriggers_4570" );
#endif
	_subsystem_457a= &subsystems_4573;
	_block_457b= &blocks_4576;
	_main_457c= &mains_4579;
	processInputPackets( subsystems_4571, blocks_4574, mains_4577);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasTriggers_4570::isInputUnique( const Udm::Object& subsystem_4581, const Udm::Object& block_458a, const Udm::Object& main_4593)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_4583= _subsystem_457d.begin(), itBlock_458c= _block_4586.begin(), itMain_4595= _main_458f.begin(); itSubsystem_4583!= _subsystem_457d.end(), itBlock_458c!= _block_4586.end(), itMain_4595!= _main_458f.end(); ++itSubsystem_4583, ++itBlock_458c, ++itMain_4595)
	{
		if( ( *itSubsystem_4583== subsystem_4581)&& ( *itBlock_458c== block_458a)&& ( *itMain_4595== main_4593))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_457d.push_back( subsystem_4581);
		_block_4586.push_back( block_458a);
		_main_458f.push_back( main_4593);
	}
	return isUnique;
}

bool HasTriggers_4570::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void HasTriggers_4570::processInputPackets( const Packets_t& subsystems_4571, const Packets_t& blocks_4574, const Packets_t& mains_4577)
{
	for( Packets_t::const_iterator itSubsystem_457e= subsystems_4571.begin(), itBlock_4587= blocks_4574.begin(), itMain_4590= mains_4577.begin(); itSubsystem_457e!= subsystems_4571.end(), itBlock_4587!= blocks_4574.end(), itMain_4590!= mains_4577.end(); ++itSubsystem_457e, ++itBlock_4587, ++itMain_4590)
	{
		bool isUnique= isInputUnique( *itSubsystem_457e, *itBlock_4587, *itMain_4590);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_457e, *itBlock_4587, *itMain_4590);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_459f, currMatch.block_45a0, currMatch.main_45a1);
	}
}

bool HasTriggers_4570::patternMatcher( const Udm::Object& subsystem_457f, const Udm::Object& block_4588, const Udm::Object& main_4591)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_457f.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_4584= CyberComposition::Simulink::Subsystem::Cast( subsystem_457f);
		if( false== Uml::IsDerivedFrom( block_4588.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem block_458d= CyberComposition::Simulink::Subsystem::Cast( block_4588);
		if( false== Uml::IsDerivedFrom( main_4591.type(), SFC::Function::meta))
			continue;
		SFC::Function main_4596= SFC::Function::Cast( main_4591);
		set< CyberComposition::Simulink::TriggerPort> triggerPorts_4598= block_458d.TriggerPort_kind_children();
		for( set< CyberComposition::Simulink::TriggerPort>::const_iterator itTriggerPort_4599= triggerPorts_4598.begin(); itTriggerPort_4599!= triggerPorts_4598.end(); ++itTriggerPort_4599)
		{
			CyberComposition::Simulink::TriggerPort currTriggerPort_459a= *itTriggerPort_4599;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_459e;
			if( !isValidBound(boundObjs_459e, subsystem_4584, true))
				continue;
			currMatch.subsystem_459f= subsystem_4584;
			if( !isValidBound(boundObjs_459e, block_458d, true))
				continue;
			currMatch.block_45a0= block_458d;
			if( !isValidBound(boundObjs_459e, main_4596, true))
				continue;
			currMatch.main_45a1= main_4596;
			if( !isValidBound(boundObjs_459e, currTriggerPort_459a, false))
				continue;
			currMatch.triggerPort_45a2= currTriggerPort_459a;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void HasTriggers_4570::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_45a3, const CyberComposition::Simulink::Subsystem& block_45a5, const SFC::Function& main_45a7)
{
	_subsystem_457a->push_back( subsystem_45a3);
	_block_457b->push_back( block_45a5);
	_main_457c->push_back( main_45a7);
}

bool Otherwise_45a9::operator()( const Packets_t& subsystems_45aa, const Packets_t& blocks_45ad, const Packets_t& mains_45b0, Packets_t& subsystems_45ac, Packets_t& blocks_45af, Packets_t& mains_45b2)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_45a9" );
#endif
	_subsystem_45b3= &subsystems_45ac;
	_block_45b4= &blocks_45af;
	_main_45b5= &mains_45b2;
	processInputPackets( subsystems_45aa, blocks_45ad, mains_45b0);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_45a9::isInputUnique( const Udm::Object& subsystem_45ba, const Udm::Object& block_45c3, const Udm::Object& main_45cc)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_45bc= _subsystem_45b6.begin(), itBlock_45c5= _block_45bf.begin(), itMain_45ce= _main_45c8.begin(); itSubsystem_45bc!= _subsystem_45b6.end(), itBlock_45c5!= _block_45bf.end(), itMain_45ce!= _main_45c8.end(); ++itSubsystem_45bc, ++itBlock_45c5, ++itMain_45ce)
	{
		if( ( *itSubsystem_45bc== subsystem_45ba)&& ( *itBlock_45c5== block_45c3)&& ( *itMain_45ce== main_45cc))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_45b6.push_back( subsystem_45ba);
		_block_45bf.push_back( block_45c3);
		_main_45c8.push_back( main_45cc);
	}
	return isUnique;
}

bool Otherwise_45a9::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_45a9::processInputPackets( const Packets_t& subsystems_45aa, const Packets_t& blocks_45ad, const Packets_t& mains_45b0)
{
	for( Packets_t::const_iterator itSubsystem_45b7= subsystems_45aa.begin(), itBlock_45c0= blocks_45ad.begin(), itMain_45c9= mains_45b0.begin(); itSubsystem_45b7!= subsystems_45aa.end(), itBlock_45c0!= blocks_45ad.end(), itMain_45c9!= mains_45b0.end(); ++itSubsystem_45b7, ++itBlock_45c0, ++itMain_45c9)
	{
		bool isUnique= isInputUnique( *itSubsystem_45b7, *itBlock_45c0, *itMain_45c9);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_45b7, *itBlock_45c0, *itMain_45c9);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_45d5, currMatch.block_45d6, currMatch.main_45d7);
	}
}

bool Otherwise_45a9::patternMatcher( const Udm::Object& subsystem_45b8, const Udm::Object& block_45c1, const Udm::Object& main_45ca)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_45b8.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_45bd= CyberComposition::Simulink::Subsystem::Cast( subsystem_45b8);
		if( false== Uml::IsDerivedFrom( block_45c1.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem block_45c6= CyberComposition::Simulink::Subsystem::Cast( block_45c1);
		if( false== Uml::IsDerivedFrom( main_45ca.type(), SFC::Function::meta))
			continue;
		SFC::Function main_45cf= SFC::Function::Cast( main_45ca);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_45d4;
		if( !isValidBound(boundObjs_45d4, subsystem_45bd, true))
			continue;
		currMatch.subsystem_45d5= subsystem_45bd;
		if( !isValidBound(boundObjs_45d4, block_45c6, true))
			continue;
		currMatch.block_45d6= block_45c6;
		if( !isValidBound(boundObjs_45d4, main_45cf, true))
			continue;
		currMatch.main_45d7= main_45cf;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_45a9::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_45d8, const CyberComposition::Simulink::Subsystem& block_45da, const SFC::Function& main_45dc)
{
	_subsystem_45b3->push_back( subsystem_45d8);
	_block_45b4->push_back( block_45da);
	_main_45b5->push_back( main_45dc);
}

void CreateTriggering_45de::operator()( const Packets_t& systems_45df, const Packets_t& childSubsystems_45e1, const Packets_t& systemFunctions_45e3, Packets_t& systems_45e5, Packets_t& childSubsystems_45e6, Packets_t& conditionalBlocks_45e7)
{
#ifdef PRINT_INFO
	printLog( "CreateTriggering_45de" );
#endif
	_system_45e8= &systems_45e5;
	_childSubsystem_45e9= &childSubsystems_45e6;
	_conditionalBlock_45ea= &conditionalBlocks_45e7;
	if( ( !systems_45df.empty())&& ( !childSubsystems_45e1.empty())&& ( !systemFunctions_45e3.empty()))
		callGetTriggerPort_5224( systems_45df, childSubsystems_45e1, systemFunctions_45e3);
}

void CreateTriggering_45de::callGetTriggerPort_5224( const Packets_t& subsystems_45ec, const Packets_t& blocks_45ef, const Packets_t& mains_45f2)
{
	Packets_t subsystems_45ee;
	Packets_t triggerPorts_45f1;
	Packets_t mains_45f4;
	GetTriggerPort_45eb getTriggerPort_45eb;
	getTriggerPort_45eb( subsystems_45ec, blocks_45ef, mains_45f2, subsystems_45ee, triggerPorts_45f1, mains_45f4);
	if( ( !subsystems_45ee.empty())&& ( !triggerPorts_45f1.empty())&& ( !mains_45f4.empty()))
		callAssignCondValLocalVar_5228( subsystems_45ee, triggerPorts_45f1, mains_45f4);
}

void CreateTriggering_45de::callAssignCondValLocalVar_5228( const Packets_t& subsystems_4625, const Packets_t& triggerPorts_4628, const Packets_t& functions_462d)
{
	Packets_t subsystems_4627;
	Packets_t triggerPorts_462a;
	Packets_t argDeclBases_462b;
	Packets_t dTs_462c;
	Packets_t functions_462f;
	AssignCondValLocalVar_4624 assignCondValLocalVar_4624;
	assignCondValLocalVar_4624( subsystems_4625, triggerPorts_4628, functions_462d, subsystems_4627, triggerPorts_462a, argDeclBases_462b, dTs_462c, functions_462f);
	if( ( !subsystems_4627.empty())&& ( !triggerPorts_462a.empty())&& ( !argDeclBases_462b.empty())&& ( !dTs_462c.empty())&& ( !functions_462f.empty()))
		callMakeTrigger_522c( subsystems_4627, triggerPorts_462a, argDeclBases_462b, dTs_462c, functions_462f);
}

void CreateTriggering_45de::callMakeTrigger_522c( const Packets_t& systems_4666, const Packets_t& childSubsystemTriggers_4668, const Packets_t& argdecls_466a, const Packets_t& dts_466c, const Packets_t& functions_466e)
{
	Packets_t systems_4670;
	Packets_t childSubsystems_4671;
	Packets_t conditionals_4672;
	MakeTrigger_4665 makeTrigger_4665;
	makeTrigger_4665( systems_4666, childSubsystemTriggers_4668, argdecls_466a, dts_466c, functions_466e, systems_4670, childSubsystems_4671, conditionals_4672);
	_system_45e8->insert( _system_45e8->end(), systems_4670.begin(), systems_4670.end());
	_childSubsystem_45e9->insert( _childSubsystem_45e9->end(), childSubsystems_4671.begin(), childSubsystems_4671.end());
	_conditionalBlock_45ea->insert( _conditionalBlock_45ea->end(), conditionals_4672.begin(), conditionals_4672.end());
}

void GetTriggerPort_45eb::operator()( const Packets_t& subsystems_45ec, const Packets_t& blocks_45ef, const Packets_t& mains_45f2, Packets_t& subsystems_45ee, Packets_t& triggerPorts_45f1, Packets_t& mains_45f4)
{
#ifdef PRINT_INFO
	printLog( "GetTriggerPort_45eb" );
#endif
	RTTGenerator::Instance()->generateRule(4020, "GetTriggerPort");
	_subsystem_45f5= &subsystems_45ee;
	_triggerPort_45f6= &triggerPorts_45f1;
	_main_45f7= &mains_45f4;
	processInputPackets( subsystems_45ec, blocks_45ef, mains_45f2);
}

bool GetTriggerPort_45eb::isInputUnique( const Udm::Object& subsystem_45fc, const Udm::Object& block_4605, const Udm::Object& main_460e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_45fe= _subsystem_45f8.begin(), itBlock_4607= _block_4601.begin(), itMain_4610= _main_460a.begin(); itSubsystem_45fe!= _subsystem_45f8.end(), itBlock_4607!= _block_4601.end(), itMain_4610!= _main_460a.end(); ++itSubsystem_45fe, ++itBlock_4607, ++itMain_4610)
	{
		if( ( *itSubsystem_45fe== subsystem_45fc)&& ( *itBlock_4607== block_4605)&& ( *itMain_4610== main_460e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_45f8.push_back( subsystem_45fc);
		_block_4601.push_back( block_4605);
		_main_460a.push_back( main_460e);
	}
	return isUnique;
}

bool GetTriggerPort_45eb::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetTriggerPort_45eb::processInputPackets( const Packets_t& subsystems_45ec, const Packets_t& blocks_45ef, const Packets_t& mains_45f2)
{
	for( Packets_t::const_iterator itSubsystem_45f9= subsystems_45ec.begin(), itBlock_4602= blocks_45ef.begin(), itMain_460b= mains_45f2.begin(); itSubsystem_45f9!= subsystems_45ec.end(), itBlock_4602!= blocks_45ef.end(), itMain_460b!= mains_45f2.end(); ++itSubsystem_45f9, ++itBlock_4602, ++itMain_460b)
	{
		bool isUnique= isInputUnique( *itSubsystem_45f9, *itBlock_4602, *itMain_460b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_45f9, *itBlock_4602, *itMain_460b);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetTriggerPort_45eb::patternMatcher( const Udm::Object& subsystem_45fa, const Udm::Object& block_4603, const Udm::Object& main_460c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_45fa.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_45ff= CyberComposition::Simulink::Subsystem::Cast( subsystem_45fa);
		if( false== Uml::IsDerivedFrom( block_4603.type(), CyberComposition::Simulink::Block::meta))
			continue;
		CyberComposition::Simulink::Block block_4608= CyberComposition::Simulink::Block::Cast( block_4603);
		if( false== Uml::IsDerivedFrom( main_460c.type(), SFC::Function::meta))
			continue;
		SFC::Function main_4611= SFC::Function::Cast( main_460c);
		set< CyberComposition::Simulink::TriggerPort> triggerPorts_4613= block_4608.TriggerPort_kind_children();
		for( set< CyberComposition::Simulink::TriggerPort>::const_iterator itTriggerPort_4614= triggerPorts_4613.begin(); itTriggerPort_4614!= triggerPorts_4613.end(); ++itTriggerPort_4614)
		{
			CyberComposition::Simulink::TriggerPort currTriggerPort_4615= *itTriggerPort_4614;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_4619;
			if( !isValidBound(boundObjs_4619, subsystem_45ff, true))
				continue;
			currMatch.subsystem_461a= subsystem_45ff;
			if( !isValidBound(boundObjs_4619, block_4608, true))
				continue;
			currMatch.block_461b= block_4608;
			if( !isValidBound(boundObjs_4619, main_4611, true))
				continue;
			currMatch.main_461c= main_4611;
			if( !isValidBound(boundObjs_4619, currTriggerPort_4615, false))
				continue;
			currMatch.triggerPort_461d= currTriggerPort_4615;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetTriggerPort_45eb::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_461a, currMatch.triggerPort_461d, currMatch.main_461c);
	}
}

void GetTriggerPort_45eb::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_461e, const CyberComposition::Simulink::TriggerPort& triggerPort_4620, const SFC::Function& main_4622)
{
	_subsystem_45f5->push_back( subsystem_461e);
	_triggerPort_45f6->push_back( triggerPort_4620);
	_main_45f7->push_back( main_4622);
}

void AssignCondValLocalVar_4624::operator()( const Packets_t& subsystems_4625, const Packets_t& triggerPorts_4628, const Packets_t& functions_462d, Packets_t& subsystems_4627, Packets_t& triggerPorts_462a, Packets_t& argDeclBases_462b, Packets_t& dTs_462c, Packets_t& functions_462f)
{
#ifdef PRINT_INFO
	printLog( "AssignCondValLocalVar_4624" );
#endif
	RTTGenerator::Instance()->generateRule(4026, "AssignCondValLocalVar");
	_subsystem_4630= &subsystems_4627;
	_triggerPort_4631= &triggerPorts_462a;
	_argDeclBase_4632= &argDeclBases_462b;
	_dT_4633= &dTs_462c;
	_function_4634= &functions_462f;
	processInputPackets( subsystems_4625, triggerPorts_4628, functions_462d);
}

bool AssignCondValLocalVar_4624::isInputUnique( const Udm::Object& subsystem_4639, const Udm::Object& triggerPort_4642, const Udm::Object& function_464b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_463b= _subsystem_4635.begin(), itTriggerPort_4644= _triggerPort_463e.begin(), itFunction_464d= _function_4647.begin(); itSubsystem_463b!= _subsystem_4635.end(), itTriggerPort_4644!= _triggerPort_463e.end(), itFunction_464d!= _function_4647.end(); ++itSubsystem_463b, ++itTriggerPort_4644, ++itFunction_464d)
	{
		if( ( *itSubsystem_463b== subsystem_4639)&& ( *itTriggerPort_4644== triggerPort_4642)&& ( *itFunction_464d== function_464b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_4635.push_back( subsystem_4639);
		_triggerPort_463e.push_back( triggerPort_4642);
		_function_4647.push_back( function_464b);
	}
	return isUnique;
}

bool AssignCondValLocalVar_4624::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void AssignCondValLocalVar_4624::processInputPackets( const Packets_t& subsystems_4625, const Packets_t& triggerPorts_4628, const Packets_t& functions_462d)
{
	for( Packets_t::const_iterator itSubsystem_4636= subsystems_4625.begin(), itTriggerPort_463f= triggerPorts_4628.begin(), itFunction_4648= functions_462d.begin(); itSubsystem_4636!= subsystems_4625.end(), itTriggerPort_463f!= triggerPorts_4628.end(), itFunction_4648!= functions_462d.end(); ++itSubsystem_4636, ++itTriggerPort_463f, ++itFunction_4648)
	{
		bool isUnique= isInputUnique( *itSubsystem_4636, *itTriggerPort_463f, *itFunction_4648);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_4636, *itTriggerPort_463f, *itFunction_4648);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AssignCondValLocalVar_4624::patternMatcher( const Udm::Object& subsystem_4637, const Udm::Object& triggerPort_4640, const Udm::Object& function_4649)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_4637.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_463c= CyberComposition::Simulink::Subsystem::Cast( subsystem_4637);
		if( false== Uml::IsDerivedFrom( triggerPort_4640.type(), CyberComposition::Simulink::SF_Port::meta))
			continue;
		CyberComposition::Simulink::SF_Port triggerPort_4645= CyberComposition::Simulink::SF_Port::Cast( triggerPort_4640);
		if( false== Uml::IsDerivedFrom( function_4649.type(), SFC::Function::meta))
			continue;
		SFC::Function function_464e= SFC::Function::Cast( function_4649);
		SFC::ArgDeclBase argDeclBase_4650= triggerPort_4645.argdecl();
		if( !argDeclBase_4650)
			continue;
		SFC::DT dT_4651= argDeclBase_4650.dt();
		if( !dT_4651)
			continue;
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4655;
		if( !isValidBound(boundObjs_4655, subsystem_463c, true))
			continue;
		currMatch.subsystem_4656= subsystem_463c;
		if( !isValidBound(boundObjs_4655, triggerPort_4645, true))
			continue;
		currMatch.triggerPort_4657= triggerPort_4645;
		if( !isValidBound(boundObjs_4655, function_464e, true))
			continue;
		currMatch.function_4658= function_464e;
		if( !isValidBound(boundObjs_4655, argDeclBase_4650, false))
			continue;
		currMatch.argDeclBase_4659= argDeclBase_4650;
		if( !isValidBound(boundObjs_4655, dT_4651, false))
			continue;
		currMatch.dT_465a= dT_4651;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void AssignCondValLocalVar_4624::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_4656, currMatch.triggerPort_4657, currMatch.argDeclBase_4659, currMatch.dT_465a, currMatch.function_4658);
	}
}

void AssignCondValLocalVar_4624::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_465b, const CyberComposition::Simulink::SF_Port& triggerPort_465d, const SFC::ArgDeclBase& argDeclBase_465f, const SFC::DT& dT_4661, const SFC::Function& function_4663)
{
	_subsystem_4630->push_back( subsystem_465b);
	_triggerPort_4631->push_back( triggerPort_465d);
	_argDeclBase_4632->push_back( argDeclBase_465f);
	_dT_4633->push_back( dT_4661);
	_function_4634->push_back( function_4663);
}

void MakeTrigger_4665::operator()( const Packets_t& systems_4666, const Packets_t& childSubsystemTriggers_4668, const Packets_t& argdecls_466a, const Packets_t& dts_466c, const Packets_t& functions_466e, Packets_t& systems_4670, Packets_t& childSubsystems_4671, Packets_t& conditionals_4672)
{
#ifdef PRINT_INFO
	printLog( "MakeTrigger_4665" );
#endif
	_system_4673= &systems_4670;
	_childSubsystem_4674= &childSubsystems_4671;
	_conditional_4675= &conditionals_4672;
	if( ( !systems_4666.empty())&& ( !childSubsystemTriggers_4668.empty())&& ( !argdecls_466a.empty())&& ( !dts_466c.empty())&& ( !functions_466e.empty()))
		callAddStateVar_5208( systems_4666, childSubsystemTriggers_4668, argdecls_466a, dts_466c, functions_466e);
}

void MakeTrigger_4665::callAddStateVar_5208( const Packets_t& subsystems_4989, const Packets_t& triggerPorts_498c, const Packets_t& argDeclBases_498f, const Packets_t& dTs_4993, const Packets_t& functions_4997)
{
	Packets_t subsystems_498b;
	Packets_t charts_498e;
	Packets_t argDeclBases_4991;
	Packets_t localVars_4992;
	Packets_t dTs_4995;
	Packets_t args_4996;
	Packets_t functions_4999;
	AddStateVar_4988 addStateVar_4988;
	addStateVar_4988( subsystems_4989, triggerPorts_498c, argDeclBases_498f, dTs_4993, functions_4997, subsystems_498b, charts_498e, argDeclBases_4991, localVars_4992, dTs_4995, args_4996, functions_4999);
	if( ( !subsystems_498b.empty())&& ( !charts_498e.empty())&& ( !argDeclBases_4991.empty())&& ( !dTs_4995.empty())&& ( !localVars_4992.empty())&& ( !args_4996.empty())&& ( !functions_4999.empty()))
		callAddTriggerVars_520e( subsystems_498b, charts_498e, argDeclBases_4991, dTs_4995, localVars_4992, args_4996, functions_4999);
}

void MakeTrigger_4665::callAddTriggerVars_520e( const Packets_t& systems_4ae3, const Packets_t& childsystems_4ae5, const Packets_t& argdecls_4ae7, const Packets_t& dts_4ae9, const Packets_t& oldvals_4aeb, const Packets_t& contexts_4aed, const Packets_t& functions_4aef)
{
	Packets_t systems_4af1;
	Packets_t childsystems_4af2;
	Packets_t argdecls_4af3;
	Packets_t dts_4af4;
	Packets_t oldvals_4af5;
	Packets_t contexts_4af6;
	Packets_t functions_4af7;
	AddTriggerVars_4ae2 addTriggerVars_4ae2;
	addTriggerVars_4ae2( systems_4ae3, childsystems_4ae5, argdecls_4ae7, dts_4ae9, oldvals_4aeb, contexts_4aed, functions_4aef, systems_4af1, childsystems_4af2, argdecls_4af3, dts_4af4, oldvals_4af5, contexts_4af6, functions_4af7);
	if( ( !systems_4af1.empty())&& ( !childsystems_4af2.empty())&& ( !argdecls_4af3.empty())&& ( !dts_4af4.empty())&& ( !oldvals_4af5.empty())&& ( !contexts_4af6.empty())&& ( !functions_4af7.empty()))
		callSaveState_5216( systems_4af1, childsystems_4af2, argdecls_4af3, dts_4af4, oldvals_4af5, contexts_4af6, functions_4af7);
}

void MakeTrigger_4665::callSaveState_5216( const Packets_t& systems_49f7, const Packets_t& childsystems_49f9, const Packets_t& argdecls_49fb, const Packets_t& dts_49fd, const Packets_t& oldvals_49ff, const Packets_t& contexts_4a01, const Packets_t& functions_4a03)
{
	Packets_t systems_4a05;
	Packets_t childsystems_4a06;
	Packets_t dts_4a07;
	Packets_t oldvals_4a08;
	Packets_t functions_4a09;
	SaveState_49f6 saveState_49f6;
	saveState_49f6( systems_49f7, childsystems_49f9, argdecls_49fb, dts_49fd, oldvals_49ff, contexts_4a01, functions_4a03, systems_4a05, childsystems_4a06, dts_4a07, oldvals_4a08, functions_4a09);
	if( ( !systems_4a05.empty())&& ( !childsystems_4a06.empty())&& ( !dts_4a07.empty())&& ( !oldvals_4a08.empty())&& ( !functions_4a09.empty()))
		callMakeCondition_521e( systems_4a05, childsystems_4a06, dts_4a07, oldvals_4a08, functions_4a09);
}

void MakeTrigger_4665::callMakeCondition_521e( const Packets_t& systems_4677, const Packets_t& childSubsystems_4679, const Packets_t& dts_467b, const Packets_t& oldvals_467d, const Packets_t& functions_467f)
{
	Packets_t systems_4681;
	Packets_t childSubsystems_4682;
	Packets_t conditionals_4683;
	MakeCondition_4676 makeCondition_4676;
	makeCondition_4676( systems_4677, childSubsystems_4679, dts_467b, oldvals_467d, functions_467f, systems_4681, childSubsystems_4682, conditionals_4683);
	_system_4673->insert( _system_4673->end(), systems_4681.begin(), systems_4681.end());
	_childSubsystem_4674->insert( _childSubsystem_4674->end(), childSubsystems_4682.begin(), childSubsystems_4682.end());
	_conditional_4675->insert( _conditional_4675->end(), conditionals_4683.begin(), conditionals_4683.end());
}

void MakeCondition_4676::operator()( const Packets_t& systems_4677, const Packets_t& childSubsystems_4679, const Packets_t& dts_467b, const Packets_t& oldvals_467d, const Packets_t& functions_467f, Packets_t& systems_4681, Packets_t& childSubsystems_4682, Packets_t& conditionals_4683)
{
#ifdef PRINT_INFO
	printLog( "MakeCondition_4676" );
#endif
	_system_4684= &systems_4681;
	_childSubsystem_4685= &childSubsystems_4682;
	_conditional_4686= &conditionals_4683;
	if( ( !systems_4677.empty())&& ( !childSubsystems_4679.empty())&& ( !dts_467b.empty())&& ( !oldvals_467d.empty())&& ( !functions_467f.empty()))
		callCreateConditional_497a( systems_4677, childSubsystems_4679, dts_467b, oldvals_467d, functions_467f);
}

void MakeCondition_4676::callCreateConditional_497a( const Packets_t& subsystems_491e, const Packets_t& charts_4921, const Packets_t& dTs_4924, const Packets_t& localVars_4927, const Packets_t& functions_492b)
{
	Packets_t subsystems_4920;
	Packets_t charts_4923;
	Packets_t dTs_4926;
	Packets_t triggerVars_4929;
	Packets_t userCodes_492a;
	Packets_t conditionalBlocks_492d;
	CreateConditional_491d createConditional_491d;
	createConditional_491d( subsystems_491e, charts_4921, dTs_4924, localVars_4927, functions_492b, subsystems_4920, charts_4923, dTs_4926, triggerVars_4929, userCodes_492a, conditionalBlocks_492d);
	_system_4684->insert( _system_4684->end(), subsystems_4920.begin(), subsystems_4920.end());
	_childSubsystem_4685->insert( _childSubsystem_4685->end(), charts_4923.begin(), charts_4923.end());
	_conditional_4686->insert( _conditional_4686->end(), conditionalBlocks_492d.begin(), conditionalBlocks_492d.end());
	if( ( !dTs_4926.empty())&& ( !triggerVars_4929.empty())&& ( !userCodes_492a.empty()))
		callSetMatrixCondition_4980( dTs_4926, triggerVars_4929, userCodes_492a);
}

void MakeCondition_4676::callSetMatrixCondition_4980( const Packets_t& dts_48e0, const Packets_t& triggervars_48e2, const Packets_t& conditions_48e4)
{
	Packets_t dts_48e6;
	Packets_t triggervars_48e7;
	Packets_t conditions_48e8;
	SetMatrixCondition_48df setMatrixCondition_48df;
	setMatrixCondition_48df( dts_48e0, triggervars_48e2, conditions_48e4, dts_48e6, triggervars_48e7, conditions_48e8);
	if( ( !dts_48e6.empty())&& ( !triggervars_48e7.empty())&& ( !conditions_48e8.empty()))
		callSetStructCondition_4984( dts_48e6, triggervars_48e7, conditions_48e8);
}

void MakeCondition_4676::callSetStructCondition_4984( const Packets_t& dts_4688, const Packets_t& oldvals_468a, const Packets_t& conditions_468c)
{
	SetStructCondition_4687 setStructCondition_4687;
	setStructCondition_4687( dts_4688, oldvals_468a, conditions_468c);
}

void SetStructCondition_4687::operator()( const Packets_t& dts_4688, const Packets_t& oldvals_468a, const Packets_t& conditions_468c)
{
#ifdef PRINT_INFO
	printLog( "SetStructCondition_4687" );
#endif
	if( ( !dts_4688.empty())&& ( !oldvals_468a.empty())&& ( !conditions_468c.empty()))
		callStartCondition_48d2( dts_4688, oldvals_468a, conditions_468c);
}

void SetStructCondition_4687::callStartCondition_48d2( const Packets_t& structs_468f, const Packets_t& triggerVars_4692, const Packets_t& userCodes_4695)
{
	Packets_t structs_4691;
	Packets_t triggerVars_4694;
	Packets_t unaryExprss_4697;
	StartCondition_468e startCondition_468e;
	startCondition_468e( structs_468f, triggerVars_4692, userCodes_4695, structs_4691, triggerVars_4694, unaryExprss_4697);
	if( ( !structs_4691.empty())&& ( !triggerVars_4694.empty())&& ( !unaryExprss_4697.empty()))
		callgetStructMembers_48d6( structs_4691, triggerVars_4694, unaryExprss_4697);
}

void SetStructCondition_4687::callgetStructMembers_48d6( const Packets_t& structs_4896, const Packets_t& triggerVars_489a, const Packets_t& unaryExprss_489d)
{
	Packets_t structs_4898;
	Packets_t members_4899;
	Packets_t triggerVars_489c;
	Packets_t unaryExprss_489f;
	GetStructMembers_4895 getStructMembers_4895;
	getStructMembers_4895( structs_4896, triggerVars_489a, unaryExprss_489d, structs_4898, members_4899, triggerVars_489c, unaryExprss_489f);
	if( ( !structs_4898.empty())&& ( !members_4899.empty())&& ( !triggerVars_489c.empty())&& ( !unaryExprss_489f.empty()))
		callPlaceMember_48da( structs_4898, members_4899, triggerVars_489c, unaryExprss_489f);
}

void SetStructCondition_4687::callPlaceMember_48da( const Packets_t& structs_46c5, const Packets_t& members_46c7, const Packets_t& trigvars_46c9, const Packets_t& condexprs_46cb)
{
	PlaceMember_46c4 placeMember_46c4;
	placeMember_46c4( structs_46c5, members_46c7, trigvars_46c9, condexprs_46cb);
}

void StartCondition_468e::operator()( const Packets_t& structs_468f, const Packets_t& triggerVars_4692, const Packets_t& userCodes_4695, Packets_t& structs_4691, Packets_t& triggerVars_4694, Packets_t& unaryExprss_4697)
{
#ifdef PRINT_INFO
	printLog( "StartCondition_468e" );
#endif
	RTTGenerator::Instance()->generateRule(4056, "StartCondition");
	_struct_4698= &structs_4691;
	_triggerVar_4699= &triggerVars_4694;
	_unaryExprs_469a= &unaryExprss_4697;
	processInputPackets( structs_468f, triggerVars_4692, userCodes_4695);
}

bool StartCondition_468e::isInputUnique( const Udm::Object& struct_469f, const Udm::Object& triggerVar_46a8, const Udm::Object& userCode_46b1)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itStruct_46a1= _struct_469b.begin(), itTriggerVar_46aa= _triggerVar_46a4.begin(), itUserCode_46b3= _userCode_46ad.begin(); itStruct_46a1!= _struct_469b.end(), itTriggerVar_46aa!= _triggerVar_46a4.end(), itUserCode_46b3!= _userCode_46ad.end(); ++itStruct_46a1, ++itTriggerVar_46aa, ++itUserCode_46b3)
	{
		if( ( *itStruct_46a1== struct_469f)&& ( *itTriggerVar_46aa== triggerVar_46a8)&& ( *itUserCode_46b3== userCode_46b1))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_469b.push_back( struct_469f);
		_triggerVar_46a4.push_back( triggerVar_46a8);
		_userCode_46ad.push_back( userCode_46b1);
	}
	return isUnique;
}

bool StartCondition_468e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void StartCondition_468e::processInputPackets( const Packets_t& structs_468f, const Packets_t& triggerVars_4692, const Packets_t& userCodes_4695)
{
	for( Packets_t::const_iterator itStruct_469c= structs_468f.begin(), itTriggerVar_46a5= triggerVars_4692.begin(), itUserCode_46ae= userCodes_4695.begin(); itStruct_469c!= structs_468f.end(), itTriggerVar_46a5!= triggerVars_4692.end(), itUserCode_46ae!= userCodes_4695.end(); ++itStruct_469c, ++itTriggerVar_46a5, ++itUserCode_46ae)
	{
		bool isUnique= isInputUnique( *itStruct_469c, *itTriggerVar_46a5, *itUserCode_46ae);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itStruct_469c, *itTriggerVar_46a5, *itUserCode_46ae);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool StartCondition_468e::patternMatcher( const Udm::Object& struct_469d, const Udm::Object& triggerVar_46a6, const Udm::Object& userCode_46af)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( struct_469d.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_46a2= SFC::Struct::Cast( struct_469d);
		if( false== Uml::IsDerivedFrom( triggerVar_46a6.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_46ab= SFC::LocalVar::Cast( triggerVar_46a6);
		if( false== Uml::IsDerivedFrom( userCode_46af.type(), SFC::UserCode::meta))
			continue;
		SFC::UserCode userCode_46b4= SFC::UserCode::Cast( userCode_46af);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_46b9;
		if( !isValidBound(boundObjs_46b9, struct_46a2, true))
			continue;
		currMatch.struct_46ba= struct_46a2;
		if( !isValidBound(boundObjs_46b9, triggerVar_46ab, true))
			continue;
		currMatch.triggerVar_46bb= triggerVar_46ab;
		if( !isValidBound(boundObjs_46b9, userCode_46b4, true))
			continue;
		currMatch.userCode_46bc= userCode_46b4;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void StartCondition_468e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UnaryExprs newUnaryExprs_46bd= SFC::UnaryExprs::Create( currMatch.userCode_46bc, SFC::UserCode::meta_codeexpr);
		SFC::Struct& Struct= currMatch.struct_46ba;
		SFC::LocalVar& TriggerVar= currMatch.triggerVar_46bb;
		SFC::UnaryExprs& UnaryExprs= newUnaryExprs_46bd;
		SFC::UserCode& UserCode= currMatch.userCode_46bc;
		{
UnaryExprs.op() = "";
};
		outputAppender( currMatch.struct_46ba, currMatch.triggerVar_46bb, newUnaryExprs_46bd);
	}
}

void StartCondition_468e::outputAppender( const SFC::Struct& struct_46be, const SFC::LocalVar& triggerVar_46c0, const SFC::UnaryExprs& unaryExprs_46c2)
{
	_struct_4698->push_back( struct_46be);
	_triggerVar_4699->push_back( triggerVar_46c0);
	_unaryExprs_469a->push_back( unaryExprs_46c2);
}

void PlaceMember_46c4::operator()( const Packets_t& structs_46c5, const Packets_t& members_46c7, const Packets_t& trigvars_46c9, const Packets_t& condexprs_46cb)
{
#ifdef PRINT_INFO
	printLog( "PlaceMember_46c4" );
#endif
	for( Packets_t::const_iterator itstruct_46ce= structs_46c5.begin(), itmember_46d5= members_46c7.begin(), ittrigvar_46dc= trigvars_46c9.begin(), itcondexpr_46e3= condexprs_46cb.begin(); itstruct_46ce!= structs_46c5.end(), itmember_46d5!= members_46c7.end(), ittrigvar_46dc!= trigvars_46c9.end(), itcondexpr_46e3!= condexprs_46cb.end(); ++itstruct_46ce, ++itmember_46d5, ++ittrigvar_46dc, ++itcondexpr_46e3)
	{
		bool isUnique= isInputUnique( *itstruct_46ce, *itmember_46d5, *ittrigvar_46dc, *itcondexpr_46e3);
		if( !isUnique)
			continue;
		Packets_t onestruct_46d2( 1, *itstruct_46ce);
		Packets_t onemember_46d9( 1, *itmember_46d5);
		Packets_t onetrigvar_46e0( 1, *ittrigvar_46dc);
		Packets_t onecondexpr_46e7( 1, *itcondexpr_46e3);
		executeOne( onestruct_46d2, onemember_46d9, onetrigvar_46e0, onecondexpr_46e7);
	}
}

void PlaceMember_46c4::executeOne( const Packets_t& structs_46c5, const Packets_t& members_46c7, const Packets_t& trigvars_46c9, const Packets_t& condexprs_46cb)
{
	if( ( !structs_46c5.empty())&& ( !members_46c7.empty())&& ( !trigvars_46c9.empty())&& ( !condexprs_46cb.empty()))
		callTriggerTest_4886( structs_46c5, members_46c7, trigvars_46c9, condexprs_46cb);
}

bool PlaceMember_46c4::isInputUnique( const Udm::Object& struct_46cf, const Udm::Object& member_46d6, const Udm::Object& trigvar_46dd, const Udm::Object& condexpr_46e4)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstruct_46d1= _struct_46cd.begin(), itmember_46d8= _member_46d4.begin(), ittrigvar_46df= _trigvar_46db.begin(), itcondexpr_46e6= _condexpr_46e2.begin(); itstruct_46d1!= _struct_46cd.end(), itmember_46d8!= _member_46d4.end(), ittrigvar_46df!= _trigvar_46db.end(), itcondexpr_46e6!= _condexpr_46e2.end(); ++itstruct_46d1, ++itmember_46d8, ++ittrigvar_46df, ++itcondexpr_46e6)
	{
		if( ( *itstruct_46d1== struct_46cf)&& ( *itmember_46d8== member_46d6)&& ( *ittrigvar_46df== trigvar_46dd)&& ( *itcondexpr_46e6== condexpr_46e4))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_46cd.push_back( struct_46cf);
		_member_46d4.push_back( member_46d6);
		_trigvar_46db.push_back( trigvar_46dd);
		_condexpr_46e2.push_back( condexpr_46e4);
	}
	return isUnique;
}

void PlaceMember_46c4::callTriggerTest_4886( const Packets_t& structs_4777, const Packets_t& members_4779, const Packets_t& trigvars_477b, const Packets_t& condexprs_477d)
{
	Packets_t structs_477f;
	Packets_t members_4780;
	Packets_t trigvars_4781;
	Packets_t condexprs_4782;
	Packets_t structs_4783;
	Packets_t members_4784;
	Packets_t trigvars_4785;
	Packets_t condexprs_4786;
	TriggerTest_4776 triggerTest_4776;
	triggerTest_4776( structs_4777, members_4779, trigvars_477b, condexprs_477d, structs_477f, members_4780, trigvars_4781, condexprs_4782, structs_4783, members_4784, trigvars_4785, condexprs_4786);
	if( ( !structs_4783.empty())&& ( !members_4784.empty())&& ( !trigvars_4785.empty())&& ( !condexprs_4786.empty()))
		callAddTrigger_488b( structs_4783, members_4784, trigvars_4785, condexprs_4786);
	if( ( !structs_477f.empty())&& ( !members_4780.empty())&& ( !trigvars_4781.empty())&& ( !condexprs_4782.empty()))
		callTraverseBinary_4890( structs_477f, members_4780, trigvars_4781, condexprs_4782);
}

void PlaceMember_46c4::callAddTrigger_488b( const Packets_t& structs_46ea, const Packets_t& members_46ec, const Packets_t& trigvars_46ee, const Packets_t& condexprs_46f0)
{
	AddTrigger_46e9 addTrigger_46e9;
	addTrigger_46e9( structs_46ea, members_46ec, trigvars_46ee, condexprs_46f0);
}

void PlaceMember_46c4::callTraverseBinary_4890( const Packets_t& structs_483a, const Packets_t& members_483d, const Packets_t& triggerVars_4840, const Packets_t& unaryExprss_4843)
{
	Packets_t structs_483c;
	Packets_t members_483f;
	Packets_t triggerVars_4842;
	Packets_t unaryExprss_4845;
	TraverseBinary_4839 traverseBinary_4839;
	traverseBinary_4839( structs_483a, members_483d, triggerVars_4840, unaryExprss_4843, structs_483c, members_483f, triggerVars_4842, unaryExprss_4845);
	if( ( !structs_483c.empty())&& ( !members_483f.empty())&& ( !triggerVars_4842.empty())&& ( !unaryExprss_4845.empty()))
		callTriggerTest_4886( structs_483c, members_483f, triggerVars_4842, unaryExprss_4845);
}

void AddTrigger_46e9::operator()( const Packets_t& structs_46ea, const Packets_t& members_46ec, const Packets_t& trigvars_46ee, const Packets_t& condexprs_46f0)
{
#ifdef PRINT_INFO
	printLog( "AddTrigger_46e9" );
#endif
	if( ( !structs_46ea.empty())&& ( !members_46ec.empty())&& ( !trigvars_46ee.empty())&& ( !condexprs_46f0.empty()))
		callAddLastTrigger_476c( structs_46ea, members_46ec, trigvars_46ee, condexprs_46f0);
	if( ( !structs_46ea.empty())&& ( !members_46ec.empty())&& ( !trigvars_46ee.empty())&& ( !condexprs_46f0.empty()))
		callAddNextTrigger_4771( structs_46ea, members_46ec, trigvars_46ee, condexprs_46f0);
}

void AddTrigger_46e9::callAddLastTrigger_476c( const Packets_t& structs_46f3, const Packets_t& members_46f5, const Packets_t& triggerVars_46f7, const Packets_t& unaryExprss_46f9)
{
	AddLastTrigger_46f2 addLastTrigger_46f2;
	addLastTrigger_46f2( structs_46f3, members_46f5, triggerVars_46f7, unaryExprss_46f9);
}

void AddTrigger_46e9::callAddNextTrigger_4771( const Packets_t& structs_472f, const Packets_t& members_4731, const Packets_t& triggerVars_4733, const Packets_t& unaryExprss_4735)
{
	AddNextTrigger_472e addNextTrigger_472e;
	addNextTrigger_472e( structs_472f, members_4731, triggerVars_4733, unaryExprss_4735);
}

void AddLastTrigger_46f2::operator()( const Packets_t& structs_46f3, const Packets_t& members_46f5, const Packets_t& triggerVars_46f7, const Packets_t& unaryExprss_46f9)
{
#ifdef PRINT_INFO
	printLog( "AddLastTrigger_46f2" );
#endif
	RTTGenerator::Instance()->generateRule(4073, "AddLastTrigger");
	processInputPackets( structs_46f3, members_46f5, triggerVars_46f7, unaryExprss_46f9);
}

bool AddLastTrigger_46f2::isInputUnique( const Udm::Object& struct_46ff, const Udm::Object& member_4708, const Udm::Object& triggerVar_4711, const Udm::Object& unaryExprs_471a)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itStruct_4701= _struct_46fb.begin(), itMember_470a= _member_4704.begin(), itTriggerVar_4713= _triggerVar_470d.begin(), itUnaryExprs_471c= _unaryExprs_4716.begin(); itStruct_4701!= _struct_46fb.end(), itMember_470a!= _member_4704.end(), itTriggerVar_4713!= _triggerVar_470d.end(), itUnaryExprs_471c!= _unaryExprs_4716.end(); ++itStruct_4701, ++itMember_470a, ++itTriggerVar_4713, ++itUnaryExprs_471c)
	{
		if( ( *itStruct_4701== struct_46ff)&& ( *itMember_470a== member_4708)&& ( *itTriggerVar_4713== triggerVar_4711)&& ( *itUnaryExprs_471c== unaryExprs_471a))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_46fb.push_back( struct_46ff);
		_member_4704.push_back( member_4708);
		_triggerVar_470d.push_back( triggerVar_4711);
		_unaryExprs_4716.push_back( unaryExprs_471a);
	}
	return isUnique;
}

bool AddLastTrigger_46f2::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool AddLastTrigger_46f2::isGuardTrue( SFC::LocalVar& Member, SFC::Struct& Struct, SFC::LocalVar& TriggerVar, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	Gz_guard = Member.statementIndex() + 1 == Struct.memberCount();;
	return Gz_guard;
}

void AddLastTrigger_46f2::processInputPackets( const Packets_t& structs_46f3, const Packets_t& members_46f5, const Packets_t& triggerVars_46f7, const Packets_t& unaryExprss_46f9)
{
	for( Packets_t::const_iterator itStruct_46fc= structs_46f3.begin(), itMember_4705= members_46f5.begin(), itTriggerVar_470e= triggerVars_46f7.begin(), itUnaryExprs_4717= unaryExprss_46f9.begin(); itStruct_46fc!= structs_46f3.end(), itMember_4705!= members_46f5.end(), itTriggerVar_470e!= triggerVars_46f7.end(), itUnaryExprs_4717!= unaryExprss_46f9.end(); ++itStruct_46fc, ++itMember_4705, ++itTriggerVar_470e, ++itUnaryExprs_4717)
	{
		bool isUnique= isInputUnique( *itStruct_46fc, *itMember_4705, *itTriggerVar_470e, *itUnaryExprs_4717);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itStruct_46fc, *itMember_4705, *itTriggerVar_470e, *itUnaryExprs_4717);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AddLastTrigger_46f2::patternMatcher( const Udm::Object& struct_46fd, const Udm::Object& member_4706, const Udm::Object& triggerVar_470f, const Udm::Object& unaryExprs_4718)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( struct_46fd.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_4702= SFC::Struct::Cast( struct_46fd);
		if( false== Uml::IsDerivedFrom( member_4706.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_470b= SFC::LocalVar::Cast( member_4706);
		if( false== Uml::IsDerivedFrom( triggerVar_470f.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_4714= SFC::LocalVar::Cast( triggerVar_470f);
		if( false== Uml::IsDerivedFrom( unaryExprs_4718.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_471d= SFC::UnaryExprs::Cast( unaryExprs_4718);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4722;
		if( !isValidBound(boundObjs_4722, struct_4702, true))
			continue;
		currMatch.struct_4723= struct_4702;
		if( !isValidBound(boundObjs_4722, member_470b, true))
			continue;
		currMatch.member_4724= member_470b;
		if( !isValidBound(boundObjs_4722, triggerVar_4714, true))
			continue;
		currMatch.triggerVar_4725= triggerVar_4714;
		if( !isValidBound(boundObjs_4722, unaryExprs_471d, true))
			continue;
		currMatch.unaryExprs_4726= unaryExprs_471d;
		bool Gz_guard= isGuardTrue( currMatch.member_4724, currMatch.struct_4723, currMatch.triggerVar_4725, currMatch.unaryExprs_4726);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void AddLastTrigger_46f2::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newDot_472b= SFC::BinaryExprs::Create( currMatch.unaryExprs_4726, SFC::UnaryExprs::meta_subexpr);
		SFC::ArgDeclRef newArgDeclRef1_472c= SFC::ArgDeclRef::Create( newDot_472b, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef2_472d= SFC::ArgDeclRef::Create( newDot_472b, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef& ArgDeclRef1= newArgDeclRef1_472c;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_472d;
		SFC::BinaryExprs& Dot= newDot_472b;
		SFC::LocalVar& Member= currMatch.member_4724;
		SFC::Struct& Struct= currMatch.struct_4723;
		SFC::LocalVar& TriggerVar= currMatch.triggerVar_4725;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_4726;
		{
Dot.op() = ".";
};
		newArgDeclRef2_472d.argdecl()= currMatch.triggerVar_4725;
		newArgDeclRef1_472c.argdecl()= currMatch.member_4724;
	}
}

void AddNextTrigger_472e::operator()( const Packets_t& structs_472f, const Packets_t& members_4731, const Packets_t& triggerVars_4733, const Packets_t& unaryExprss_4735)
{
#ifdef PRINT_INFO
	printLog( "AddNextTrigger_472e" );
#endif
	RTTGenerator::Instance()->generateRule(4087, "AddNextTrigger");
	processInputPackets( structs_472f, members_4731, triggerVars_4733, unaryExprss_4735);
}

bool AddNextTrigger_472e::isInputUnique( const Udm::Object& struct_473b, const Udm::Object& member_4744, const Udm::Object& triggerVar_474d, const Udm::Object& unaryExprs_4756)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itStruct_473d= _struct_4737.begin(), itMember_4746= _member_4740.begin(), itTriggerVar_474f= _triggerVar_4749.begin(), itUnaryExprs_4758= _unaryExprs_4752.begin(); itStruct_473d!= _struct_4737.end(), itMember_4746!= _member_4740.end(), itTriggerVar_474f!= _triggerVar_4749.end(), itUnaryExprs_4758!= _unaryExprs_4752.end(); ++itStruct_473d, ++itMember_4746, ++itTriggerVar_474f, ++itUnaryExprs_4758)
	{
		if( ( *itStruct_473d== struct_473b)&& ( *itMember_4746== member_4744)&& ( *itTriggerVar_474f== triggerVar_474d)&& ( *itUnaryExprs_4758== unaryExprs_4756))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_4737.push_back( struct_473b);
		_member_4740.push_back( member_4744);
		_triggerVar_4749.push_back( triggerVar_474d);
		_unaryExprs_4752.push_back( unaryExprs_4756);
	}
	return isUnique;
}

bool AddNextTrigger_472e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool AddNextTrigger_472e::isGuardTrue( SFC::LocalVar& Member, SFC::Struct& Struct, SFC::LocalVar& TriggerVar, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	Gz_guard = Member.statementIndex() + 1 != Struct.memberCount();;
	return Gz_guard;
}

void AddNextTrigger_472e::processInputPackets( const Packets_t& structs_472f, const Packets_t& members_4731, const Packets_t& triggerVars_4733, const Packets_t& unaryExprss_4735)
{
	for( Packets_t::const_iterator itStruct_4738= structs_472f.begin(), itMember_4741= members_4731.begin(), itTriggerVar_474a= triggerVars_4733.begin(), itUnaryExprs_4753= unaryExprss_4735.begin(); itStruct_4738!= structs_472f.end(), itMember_4741!= members_4731.end(), itTriggerVar_474a!= triggerVars_4733.end(), itUnaryExprs_4753!= unaryExprss_4735.end(); ++itStruct_4738, ++itMember_4741, ++itTriggerVar_474a, ++itUnaryExprs_4753)
	{
		bool isUnique= isInputUnique( *itStruct_4738, *itMember_4741, *itTriggerVar_474a, *itUnaryExprs_4753);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itStruct_4738, *itMember_4741, *itTriggerVar_474a, *itUnaryExprs_4753);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AddNextTrigger_472e::patternMatcher( const Udm::Object& struct_4739, const Udm::Object& member_4742, const Udm::Object& triggerVar_474b, const Udm::Object& unaryExprs_4754)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( struct_4739.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_473e= SFC::Struct::Cast( struct_4739);
		if( false== Uml::IsDerivedFrom( member_4742.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_4747= SFC::LocalVar::Cast( member_4742);
		if( false== Uml::IsDerivedFrom( triggerVar_474b.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_4750= SFC::LocalVar::Cast( triggerVar_474b);
		if( false== Uml::IsDerivedFrom( unaryExprs_4754.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_4759= SFC::UnaryExprs::Cast( unaryExprs_4754);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_475e;
		if( !isValidBound(boundObjs_475e, struct_473e, true))
			continue;
		currMatch.struct_475f= struct_473e;
		if( !isValidBound(boundObjs_475e, member_4747, true))
			continue;
		currMatch.member_4760= member_4747;
		if( !isValidBound(boundObjs_475e, triggerVar_4750, true))
			continue;
		currMatch.triggerVar_4761= triggerVar_4750;
		if( !isValidBound(boundObjs_475e, unaryExprs_4759, true))
			continue;
		currMatch.unaryExprs_4762= unaryExprs_4759;
		bool Gz_guard= isGuardTrue( currMatch.member_4760, currMatch.struct_475f, currMatch.triggerVar_4761, currMatch.unaryExprs_4762);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void AddNextTrigger_472e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newOr_4767= SFC::BinaryExprs::Create( currMatch.unaryExprs_4762, SFC::UnaryExprs::meta_subexpr);
		SFC::BinaryExprs newDot_4768= SFC::BinaryExprs::Create( newOr_4767, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_4769= SFC::ArgDeclRef::Create( newDot_4768, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef1_476a= SFC::ArgDeclRef::Create( newDot_4768, SFC::BinaryExprs::meta_rightexpr);
		SFC::UnaryExprs newDummy_476b= SFC::UnaryExprs::Create( newOr_4767, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef& ArgDeclRef1= newArgDeclRef1_476a;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_4769;
		SFC::BinaryExprs& Dot= newDot_4768;
		SFC::UnaryExprs& Dummy= newDummy_476b;
		SFC::LocalVar& Member= currMatch.member_4760;
		SFC::BinaryExprs& Or= newOr_4767;
		SFC::Struct& Struct= currMatch.struct_475f;
		SFC::LocalVar& TriggerVar= currMatch.triggerVar_4761;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_4762;
		{
Or.op() = "||";
};
		{
Dot.op() = ".";
};
		{
Dummy.op() = "";
};
		newArgDeclRef1_476a.argdecl()= currMatch.member_4760;
		newArgDeclRef2_4769.argdecl()= currMatch.triggerVar_4761;
	}
}

void TriggerTest_4776::operator()( const Packets_t& structs_4777, const Packets_t& members_4779, const Packets_t& trigvars_477b, const Packets_t& condexprs_477d, Packets_t& structs_477f, Packets_t& members_4780, Packets_t& trigvars_4781, Packets_t& condexprs_4782, Packets_t& structs_4783, Packets_t& members_4784, Packets_t& trigvars_4785, Packets_t& condexprs_4786)
{
#ifdef PRINT_INFO
	printLog( "TriggerTest_4776" );
#endif
	_struct_4787= &structs_477f;
	_member_4788= &members_4780;
	_trigvar_4789= &trigvars_4781;
	_condexpr_478a= &condexprs_4782;
	_struct_478b= &structs_4783;
	_member_478c= &members_4784;
	_trigvar_478d= &trigvars_4785;
	_condexpr_478e= &condexprs_4786;
	for( Packets_t::const_iterator itstruct_4790= structs_4777.begin(), itmember_4797= members_4779.begin(), ittrigvar_479e= trigvars_477b.begin(), itcondexpr_47a5= condexprs_477d.begin(); itstruct_4790!= structs_4777.end(), itmember_4797!= members_4779.end(), ittrigvar_479e!= trigvars_477b.end(), itcondexpr_47a5!= condexprs_477d.end(); ++itstruct_4790, ++itmember_4797, ++ittrigvar_479e, ++itcondexpr_47a5)
	{
		bool isUnique= isInputUnique( *itstruct_4790, *itmember_4797, *ittrigvar_479e, *itcondexpr_47a5);
		if( !isUnique)
			continue;
		Packets_t onestruct_4794( 1, *itstruct_4790);
		Packets_t onemember_479b( 1, *itmember_4797);
		Packets_t onetrigvar_47a2( 1, *ittrigvar_479e);
		Packets_t onecondexpr_47a9( 1, *itcondexpr_47a5);
		executeOne( onestruct_4794, onemember_479b, onetrigvar_47a2, onecondexpr_47a9);
	}
}

void TriggerTest_4776::executeOne( const Packets_t& structs_4777, const Packets_t& members_4779, const Packets_t& trigvars_477b, const Packets_t& condexprs_477d)
{
	Packets_t structs_47ae;
	Packets_t members_47b1;
	Packets_t triggerVars_47b4;
	Packets_t unaryExprss_47b7;
	HasBinaryExprs_47ab hasBinaryExprs_47ab;
	bool isMatchHasBinaryExprs_47ab= hasBinaryExprs_47ab( structs_4777, members_4779, trigvars_477b, condexprs_477d, structs_47ae, members_47b1, triggerVars_47b4, unaryExprss_47b7);
	_struct_4787->insert( _struct_4787->end(), structs_47ae.begin(), structs_47ae.end());
	_member_4788->insert( _member_4788->end(), members_47b1.begin(), members_47b1.end());
	_trigvar_4789->insert( _trigvar_4789->end(), triggerVars_47b4.begin(), triggerVars_47b4.end());
	_condexpr_478a->insert( _condexpr_478a->end(), unaryExprss_47b7.begin(), unaryExprss_47b7.end());
	if( isMatchHasBinaryExprs_47ab)
		return;
	Packets_t structs_47f7;
	Packets_t members_47fa;
	Packets_t triggerVars_47fd;
	Packets_t unaryExprss_4800;
	Otherwise_47f4 otherwise_47f4;
	bool isMatchOtherwise_47f4= otherwise_47f4( structs_4777, members_4779, trigvars_477b, condexprs_477d, structs_47f7, members_47fa, triggerVars_47fd, unaryExprss_4800);
	_struct_478b->insert( _struct_478b->end(), structs_47f7.begin(), structs_47f7.end());
	_member_478c->insert( _member_478c->end(), members_47fa.begin(), members_47fa.end());
	_trigvar_478d->insert( _trigvar_478d->end(), triggerVars_47fd.begin(), triggerVars_47fd.end());
	_condexpr_478e->insert( _condexpr_478e->end(), unaryExprss_4800.begin(), unaryExprss_4800.end());
	if( isMatchOtherwise_47f4)
		return;
}

bool TriggerTest_4776::isInputUnique( const Udm::Object& struct_4791, const Udm::Object& member_4798, const Udm::Object& trigvar_479f, const Udm::Object& condexpr_47a6)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itstruct_4793= _struct_478f.begin(), itmember_479a= _member_4796.begin(), ittrigvar_47a1= _trigvar_479d.begin(), itcondexpr_47a8= _condexpr_47a4.begin(); itstruct_4793!= _struct_478f.end(), itmember_479a!= _member_4796.end(), ittrigvar_47a1!= _trigvar_479d.end(), itcondexpr_47a8!= _condexpr_47a4.end(); ++itstruct_4793, ++itmember_479a, ++ittrigvar_47a1, ++itcondexpr_47a8)
	{
		if( ( *itstruct_4793== struct_4791)&& ( *itmember_479a== member_4798)&& ( *ittrigvar_47a1== trigvar_479f)&& ( *itcondexpr_47a8== condexpr_47a6))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_478f.push_back( struct_4791);
		_member_4796.push_back( member_4798);
		_trigvar_479d.push_back( trigvar_479f);
		_condexpr_47a4.push_back( condexpr_47a6);
	}
	return isUnique;
}

bool HasBinaryExprs_47ab::operator()( const Packets_t& structs_47ac, const Packets_t& members_47af, const Packets_t& triggerVars_47b2, const Packets_t& unaryExprss_47b5, Packets_t& structs_47ae, Packets_t& members_47b1, Packets_t& triggerVars_47b4, Packets_t& unaryExprss_47b7)
{
#ifdef PRINT_INFO
	printLog( "HasBinaryExprs_47ab" );
#endif
	_struct_47b8= &structs_47ae;
	_member_47b9= &members_47b1;
	_triggerVar_47ba= &triggerVars_47b4;
	_unaryExprs_47bb= &unaryExprss_47b7;
	processInputPackets( structs_47ac, members_47af, triggerVars_47b2, unaryExprss_47b5);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasBinaryExprs_47ab::isInputUnique( const Udm::Object& struct_47c0, const Udm::Object& member_47c9, const Udm::Object& triggerVar_47d2, const Udm::Object& unaryExprs_47db)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itStruct_47c2= _struct_47bc.begin(), itMember_47cb= _member_47c5.begin(), itTriggerVar_47d4= _triggerVar_47ce.begin(), itUnaryExprs_47dd= _unaryExprs_47d7.begin(); itStruct_47c2!= _struct_47bc.end(), itMember_47cb!= _member_47c5.end(), itTriggerVar_47d4!= _triggerVar_47ce.end(), itUnaryExprs_47dd!= _unaryExprs_47d7.end(); ++itStruct_47c2, ++itMember_47cb, ++itTriggerVar_47d4, ++itUnaryExprs_47dd)
	{
		if( ( *itStruct_47c2== struct_47c0)&& ( *itMember_47cb== member_47c9)&& ( *itTriggerVar_47d4== triggerVar_47d2)&& ( *itUnaryExprs_47dd== unaryExprs_47db))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_47bc.push_back( struct_47c0);
		_member_47c5.push_back( member_47c9);
		_triggerVar_47ce.push_back( triggerVar_47d2);
		_unaryExprs_47d7.push_back( unaryExprs_47db);
	}
	return isUnique;
}

bool HasBinaryExprs_47ab::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void HasBinaryExprs_47ab::processInputPackets( const Packets_t& structs_47ac, const Packets_t& members_47af, const Packets_t& triggerVars_47b2, const Packets_t& unaryExprss_47b5)
{
	for( Packets_t::const_iterator itStruct_47bd= structs_47ac.begin(), itMember_47c6= members_47af.begin(), itTriggerVar_47cf= triggerVars_47b2.begin(), itUnaryExprs_47d8= unaryExprss_47b5.begin(); itStruct_47bd!= structs_47ac.end(), itMember_47c6!= members_47af.end(), itTriggerVar_47cf!= triggerVars_47b2.end(), itUnaryExprs_47d8!= unaryExprss_47b5.end(); ++itStruct_47bd, ++itMember_47c6, ++itTriggerVar_47cf, ++itUnaryExprs_47d8)
	{
		bool isUnique= isInputUnique( *itStruct_47bd, *itMember_47c6, *itTriggerVar_47cf, *itUnaryExprs_47d8);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itStruct_47bd, *itMember_47c6, *itTriggerVar_47cf, *itUnaryExprs_47d8);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.struct_47e7, currMatch.member_47e8, currMatch.triggerVar_47e9, currMatch.unaryExprs_47ea);
	}
}

bool HasBinaryExprs_47ab::patternMatcher( const Udm::Object& struct_47be, const Udm::Object& member_47c7, const Udm::Object& triggerVar_47d0, const Udm::Object& unaryExprs_47d9)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( struct_47be.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_47c3= SFC::Struct::Cast( struct_47be);
		if( false== Uml::IsDerivedFrom( member_47c7.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_47cc= SFC::LocalVar::Cast( member_47c7);
		if( false== Uml::IsDerivedFrom( triggerVar_47d0.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_47d5= SFC::LocalVar::Cast( triggerVar_47d0);
		if( false== Uml::IsDerivedFrom( unaryExprs_47d9.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_47de= SFC::UnaryExprs::Cast( unaryExprs_47d9);
		set< SFC::BinaryExprs> binaryExprss_47e0= unaryExprs_47de.BinaryExprs_kind_children();
		for( set< SFC::BinaryExprs>::const_iterator itBinaryExprs_47e1= binaryExprss_47e0.begin(); itBinaryExprs_47e1!= binaryExprss_47e0.end(); ++itBinaryExprs_47e1)
		{
			SFC::BinaryExprs currBinaryExprs_47e2= *itBinaryExprs_47e1;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_47e6;
			if( !isValidBound(boundObjs_47e6, struct_47c3, true))
				continue;
			currMatch.struct_47e7= struct_47c3;
			if( !isValidBound(boundObjs_47e6, member_47cc, true))
				continue;
			currMatch.member_47e8= member_47cc;
			if( !isValidBound(boundObjs_47e6, triggerVar_47d5, true))
				continue;
			currMatch.triggerVar_47e9= triggerVar_47d5;
			if( !isValidBound(boundObjs_47e6, unaryExprs_47de, true))
				continue;
			currMatch.unaryExprs_47ea= unaryExprs_47de;
			if( !isValidBound(boundObjs_47e6, currBinaryExprs_47e2, false))
				continue;
			currMatch.binaryExprs_47eb= currBinaryExprs_47e2;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void HasBinaryExprs_47ab::outputAppender( const SFC::Struct& struct_47ec, const SFC::LocalVar& member_47ee, const SFC::LocalVar& triggerVar_47f0, const SFC::UnaryExprs& unaryExprs_47f2)
{
	_struct_47b8->push_back( struct_47ec);
	_member_47b9->push_back( member_47ee);
	_triggerVar_47ba->push_back( triggerVar_47f0);
	_unaryExprs_47bb->push_back( unaryExprs_47f2);
}

bool Otherwise_47f4::operator()( const Packets_t& structs_47f5, const Packets_t& members_47f8, const Packets_t& triggerVars_47fb, const Packets_t& unaryExprss_47fe, Packets_t& structs_47f7, Packets_t& members_47fa, Packets_t& triggerVars_47fd, Packets_t& unaryExprss_4800)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_47f4" );
#endif
	_struct_4801= &structs_47f7;
	_member_4802= &members_47fa;
	_triggerVar_4803= &triggerVars_47fd;
	_unaryExprs_4804= &unaryExprss_4800;
	processInputPackets( structs_47f5, members_47f8, triggerVars_47fb, unaryExprss_47fe);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_47f4::isInputUnique( const Udm::Object& struct_4809, const Udm::Object& member_4812, const Udm::Object& triggerVar_481b, const Udm::Object& unaryExprs_4824)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itStruct_480b= _struct_4805.begin(), itMember_4814= _member_480e.begin(), itTriggerVar_481d= _triggerVar_4817.begin(), itUnaryExprs_4826= _unaryExprs_4820.begin(); itStruct_480b!= _struct_4805.end(), itMember_4814!= _member_480e.end(), itTriggerVar_481d!= _triggerVar_4817.end(), itUnaryExprs_4826!= _unaryExprs_4820.end(); ++itStruct_480b, ++itMember_4814, ++itTriggerVar_481d, ++itUnaryExprs_4826)
	{
		if( ( *itStruct_480b== struct_4809)&& ( *itMember_4814== member_4812)&& ( *itTriggerVar_481d== triggerVar_481b)&& ( *itUnaryExprs_4826== unaryExprs_4824))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_4805.push_back( struct_4809);
		_member_480e.push_back( member_4812);
		_triggerVar_4817.push_back( triggerVar_481b);
		_unaryExprs_4820.push_back( unaryExprs_4824);
	}
	return isUnique;
}

bool Otherwise_47f4::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_47f4::processInputPackets( const Packets_t& structs_47f5, const Packets_t& members_47f8, const Packets_t& triggerVars_47fb, const Packets_t& unaryExprss_47fe)
{
	for( Packets_t::const_iterator itStruct_4806= structs_47f5.begin(), itMember_480f= members_47f8.begin(), itTriggerVar_4818= triggerVars_47fb.begin(), itUnaryExprs_4821= unaryExprss_47fe.begin(); itStruct_4806!= structs_47f5.end(), itMember_480f!= members_47f8.end(), itTriggerVar_4818!= triggerVars_47fb.end(), itUnaryExprs_4821!= unaryExprss_47fe.end(); ++itStruct_4806, ++itMember_480f, ++itTriggerVar_4818, ++itUnaryExprs_4821)
	{
		bool isUnique= isInputUnique( *itStruct_4806, *itMember_480f, *itTriggerVar_4818, *itUnaryExprs_4821);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itStruct_4806, *itMember_480f, *itTriggerVar_4818, *itUnaryExprs_4821);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.struct_482d, currMatch.member_482e, currMatch.triggerVar_482f, currMatch.unaryExprs_4830);
	}
}

bool Otherwise_47f4::patternMatcher( const Udm::Object& struct_4807, const Udm::Object& member_4810, const Udm::Object& triggerVar_4819, const Udm::Object& unaryExprs_4822)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( struct_4807.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_480c= SFC::Struct::Cast( struct_4807);
		if( false== Uml::IsDerivedFrom( member_4810.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_4815= SFC::LocalVar::Cast( member_4810);
		if( false== Uml::IsDerivedFrom( triggerVar_4819.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_481e= SFC::LocalVar::Cast( triggerVar_4819);
		if( false== Uml::IsDerivedFrom( unaryExprs_4822.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_4827= SFC::UnaryExprs::Cast( unaryExprs_4822);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_482c;
		if( !isValidBound(boundObjs_482c, struct_480c, true))
			continue;
		currMatch.struct_482d= struct_480c;
		if( !isValidBound(boundObjs_482c, member_4815, true))
			continue;
		currMatch.member_482e= member_4815;
		if( !isValidBound(boundObjs_482c, triggerVar_481e, true))
			continue;
		currMatch.triggerVar_482f= triggerVar_481e;
		if( !isValidBound(boundObjs_482c, unaryExprs_4827, true))
			continue;
		currMatch.unaryExprs_4830= unaryExprs_4827;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_47f4::outputAppender( const SFC::Struct& struct_4831, const SFC::LocalVar& member_4833, const SFC::LocalVar& triggerVar_4835, const SFC::UnaryExprs& unaryExprs_4837)
{
	_struct_4801->push_back( struct_4831);
	_member_4802->push_back( member_4833);
	_triggerVar_4803->push_back( triggerVar_4835);
	_unaryExprs_4804->push_back( unaryExprs_4837);
}

void TraverseBinary_4839::operator()( const Packets_t& structs_483a, const Packets_t& members_483d, const Packets_t& triggerVars_4840, const Packets_t& unaryExprss_4843, Packets_t& structs_483c, Packets_t& members_483f, Packets_t& triggerVars_4842, Packets_t& unaryExprss_4845)
{
#ifdef PRINT_INFO
	printLog( "TraverseBinary_4839" );
#endif
	RTTGenerator::Instance()->generateRule(4132, "TraverseBinary");
	_struct_4846= &structs_483c;
	_member_4847= &members_483f;
	_triggerVar_4848= &triggerVars_4842;
	_unaryExprs_4849= &unaryExprss_4845;
	processInputPackets( structs_483a, members_483d, triggerVars_4840, unaryExprss_4843);
}

bool TraverseBinary_4839::isInputUnique( const Udm::Object& struct_484e, const Udm::Object& member_4857, const Udm::Object& triggerVar_4860, const Udm::Object& unaryExprs_4869)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itStruct_4850= _struct_484a.begin(), itMember_4859= _member_4853.begin(), itTriggerVar_4862= _triggerVar_485c.begin(), itUnaryExprs_486b= _unaryExprs_4865.begin(); itStruct_4850!= _struct_484a.end(), itMember_4859!= _member_4853.end(), itTriggerVar_4862!= _triggerVar_485c.end(), itUnaryExprs_486b!= _unaryExprs_4865.end(); ++itStruct_4850, ++itMember_4859, ++itTriggerVar_4862, ++itUnaryExprs_486b)
	{
		if( ( *itStruct_4850== struct_484e)&& ( *itMember_4859== member_4857)&& ( *itTriggerVar_4862== triggerVar_4860)&& ( *itUnaryExprs_486b== unaryExprs_4869))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_484a.push_back( struct_484e);
		_member_4853.push_back( member_4857);
		_triggerVar_485c.push_back( triggerVar_4860);
		_unaryExprs_4865.push_back( unaryExprs_4869);
	}
	return isUnique;
}

bool TraverseBinary_4839::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void TraverseBinary_4839::processInputPackets( const Packets_t& structs_483a, const Packets_t& members_483d, const Packets_t& triggerVars_4840, const Packets_t& unaryExprss_4843)
{
	for( Packets_t::const_iterator itStruct_484b= structs_483a.begin(), itMember_4854= members_483d.begin(), itTriggerVar_485d= triggerVars_4840.begin(), itUnaryExprs_4866= unaryExprss_4843.begin(); itStruct_484b!= structs_483a.end(), itMember_4854!= members_483d.end(), itTriggerVar_485d!= triggerVars_4840.end(), itUnaryExprs_4866!= unaryExprss_4843.end(); ++itStruct_484b, ++itMember_4854, ++itTriggerVar_485d, ++itUnaryExprs_4866)
	{
		bool isUnique= isInputUnique( *itStruct_484b, *itMember_4854, *itTriggerVar_485d, *itUnaryExprs_4866);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itStruct_484b, *itMember_4854, *itTriggerVar_485d, *itUnaryExprs_4866);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool TraverseBinary_4839::patternMatcher( const Udm::Object& struct_484c, const Udm::Object& member_4855, const Udm::Object& triggerVar_485e, const Udm::Object& unaryExprs_4867)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( struct_484c.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_4851= SFC::Struct::Cast( struct_484c);
		if( false== Uml::IsDerivedFrom( member_4855.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_485a= SFC::LocalVar::Cast( member_4855);
		if( false== Uml::IsDerivedFrom( triggerVar_485e.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_4863= SFC::LocalVar::Cast( triggerVar_485e);
		if( false== Uml::IsDerivedFrom( unaryExprs_4867.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_486c= SFC::UnaryExprs::Cast( unaryExprs_4867);
		set< SFC::BinaryExprs> binaryExprss_486e= unaryExprs_486c.BinaryExprs_kind_children();
		for( set< SFC::BinaryExprs>::const_iterator itBinaryExprs_486f= binaryExprss_486e.begin(); itBinaryExprs_486f!= binaryExprss_486e.end(); ++itBinaryExprs_486f)
		{
			SFC::BinaryExprs currBinaryExprs_4870= *itBinaryExprs_486f;
			set< SFC::UnaryExprs> unaryExprss_4871= currBinaryExprs_4870.UnaryExprs_kind_children();
			for( set< SFC::UnaryExprs>::const_iterator itUnaryExprs_4872= unaryExprss_4871.begin(); itUnaryExprs_4872!= unaryExprss_4871.end(); ++itUnaryExprs_4872)
			{
				SFC::UnaryExprs currUnaryExprs_4873= *itUnaryExprs_4872;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_4877;
				if( !isValidBound(boundObjs_4877, struct_4851, true))
					continue;
				currMatch.struct_4878= struct_4851;
				if( !isValidBound(boundObjs_4877, member_485a, true))
					continue;
				currMatch.member_4879= member_485a;
				if( !isValidBound(boundObjs_4877, triggerVar_4863, true))
					continue;
				currMatch.triggerVar_487a= triggerVar_4863;
				if( !isValidBound(boundObjs_4877, unaryExprs_486c, true))
					continue;
				currMatch.unaryExprs_487b= unaryExprs_486c;
				if( !isValidBound(boundObjs_4877, currBinaryExprs_4870, false))
					continue;
				currMatch.binaryExprs_487c= currBinaryExprs_4870;
				if( !isValidBound(boundObjs_4877, currUnaryExprs_4873, false))
					continue;
				currMatch.unaryExprs_487d= currUnaryExprs_4873;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void TraverseBinary_4839::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.struct_4878, currMatch.member_4879, currMatch.triggerVar_487a, currMatch.unaryExprs_487d);
	}
}

void TraverseBinary_4839::outputAppender( const SFC::Struct& struct_487e, const SFC::LocalVar& member_4880, const SFC::LocalVar& triggerVar_4882, const SFC::UnaryExprs& unaryExprs_4884)
{
	_struct_4846->push_back( struct_487e);
	_member_4847->push_back( member_4880);
	_triggerVar_4848->push_back( triggerVar_4882);
	_unaryExprs_4849->push_back( unaryExprs_4884);
}

void GetStructMembers_4895::operator()( const Packets_t& structs_4896, const Packets_t& triggerVars_489a, const Packets_t& unaryExprss_489d, Packets_t& structs_4898, Packets_t& members_4899, Packets_t& triggerVars_489c, Packets_t& unaryExprss_489f)
{
#ifdef PRINT_INFO
	printLog( "GetStructMembers_4895" );
#endif
	RTTGenerator::Instance()->generateRule(4141, "getStructMembers");
	_struct_48a0= &structs_4898;
	_member_48a1= &members_4899;
	_triggerVar_48a2= &triggerVars_489c;
	_unaryExprs_48a3= &unaryExprss_489f;
	processInputPackets( structs_4896, triggerVars_489a, unaryExprss_489d);
	sortOutputs( );
}

bool GetStructMembers_4895::isInputUnique( const Udm::Object& struct_48a8, const Udm::Object& triggerVar_48b1, const Udm::Object& unaryExprs_48ba)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itStruct_48aa= _struct_48a4.begin(), itTriggerVar_48b3= _triggerVar_48ad.begin(), itUnaryExprs_48bc= _unaryExprs_48b6.begin(); itStruct_48aa!= _struct_48a4.end(), itTriggerVar_48b3!= _triggerVar_48ad.end(), itUnaryExprs_48bc!= _unaryExprs_48b6.end(); ++itStruct_48aa, ++itTriggerVar_48b3, ++itUnaryExprs_48bc)
	{
		if( ( *itStruct_48aa== struct_48a8)&& ( *itTriggerVar_48b3== triggerVar_48b1)&& ( *itUnaryExprs_48bc== unaryExprs_48ba))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_struct_48a4.push_back( struct_48a8);
		_triggerVar_48ad.push_back( triggerVar_48b1);
		_unaryExprs_48b6.push_back( unaryExprs_48ba);
	}
	return isUnique;
}

bool GetStructMembers_4895::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetStructMembers_4895::processInputPackets( const Packets_t& structs_4896, const Packets_t& triggerVars_489a, const Packets_t& unaryExprss_489d)
{
	for( Packets_t::const_iterator itStruct_48a5= structs_4896.begin(), itTriggerVar_48ae= triggerVars_489a.begin(), itUnaryExprs_48b7= unaryExprss_489d.begin(); itStruct_48a5!= structs_4896.end(), itTriggerVar_48ae!= triggerVars_489a.end(), itUnaryExprs_48b7!= unaryExprss_489d.end(); ++itStruct_48a5, ++itTriggerVar_48ae, ++itUnaryExprs_48b7)
	{
		bool isUnique= isInputUnique( *itStruct_48a5, *itTriggerVar_48ae, *itUnaryExprs_48b7);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itStruct_48a5, *itTriggerVar_48ae, *itUnaryExprs_48b7);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetStructMembers_4895::patternMatcher( const Udm::Object& struct_48a6, const Udm::Object& triggerVar_48af, const Udm::Object& unaryExprs_48b8)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( struct_48a6.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_48ab= SFC::Struct::Cast( struct_48a6);
		if( false== Uml::IsDerivedFrom( triggerVar_48af.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_48b4= SFC::LocalVar::Cast( triggerVar_48af);
		if( false== Uml::IsDerivedFrom( unaryExprs_48b8.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_48bd= SFC::UnaryExprs::Cast( unaryExprs_48b8);
		set< SFC::LocalVar> members_48bf= struct_48ab.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itMember_48c0= members_48bf.begin(); itMember_48c0!= members_48bf.end(); ++itMember_48c0)
		{
			SFC::LocalVar currMember_48c1= *itMember_48c0;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_48c5;
			if( !isValidBound(boundObjs_48c5, struct_48ab, true))
				continue;
			currMatch.struct_48c6= struct_48ab;
			if( !isValidBound(boundObjs_48c5, triggerVar_48b4, true))
				continue;
			currMatch.triggerVar_48c7= triggerVar_48b4;
			if( !isValidBound(boundObjs_48c5, unaryExprs_48bd, true))
				continue;
			currMatch.unaryExprs_48c8= unaryExprs_48bd;
			if( !isValidBound(boundObjs_48c5, currMember_48c1, false))
				continue;
			currMatch.member_48c9= currMember_48c1;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetStructMembers_4895::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.struct_48c6, currMatch.member_48c9, currMatch.triggerVar_48c7, currMatch.unaryExprs_48c8);
	}
}

void GetStructMembers_4895::outputAppender( const SFC::Struct& struct_48ca, const SFC::LocalVar& member_48cc, const SFC::LocalVar& triggerVar_48ce, const SFC::UnaryExprs& unaryExprs_48d0)
{
	_struct_48a0->push_back( struct_48ca);
	_member_48a1->push_back( member_48cc);
	_triggerVar_48a2->push_back( triggerVar_48ce);
	_unaryExprs_48a3->push_back( unaryExprs_48d0);
}

void GetStructMembers_4895::sortOutputs()
{
	typedef std::multiset< SFC::LocalVar, std::pointer_to_binary_function< const SFC::LocalVar&, const SFC::LocalVar&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const SFC::LocalVar&, const SFC::LocalVar&, bool> ptr_StatementOrder( StatementOrder< SFC::LocalVar>);
	SortedSet_t sortedSet( ptr_StatementOrder);
	std::vector< int> permutationVector( _member_48a1->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _member_48a1->begin(); it!= _member_48a1->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( SFC::LocalVar::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _member_48a1->begin());
	// order rest of the containers
	permutate( permutationVector, *_struct_48a0);
	permutate( permutationVector, *_triggerVar_48a2);
	permutate( permutationVector, *_unaryExprs_48a3);
}

void SetMatrixCondition_48df::operator()( const Packets_t& dts_48e0, const Packets_t& triggervars_48e2, const Packets_t& conditions_48e4, Packets_t& dts_48e6, Packets_t& triggervars_48e7, Packets_t& conditions_48e8)
{
#ifdef PRINT_INFO
	printLog( "SetMatrixCondition_48df" );
#endif
	_dt_48e9= &dts_48e6;
	_triggervar_48ea= &triggervars_48e7;
	_condition_48eb= &conditions_48e8;
	if( ( !dts_48e0.empty())&& ( !triggervars_48e2.empty())&& ( !conditions_48e4.empty()))
		callMatrixCondition_4919( dts_48e0, triggervars_48e2, conditions_48e4);
	_dt_48e9->insert( _dt_48e9->end(), dts_48e0.begin(), dts_48e0.end());
	_triggervar_48ea->insert( _triggervar_48ea->end(), triggervars_48e2.begin(), triggervars_48e2.end());
	_condition_48eb->insert( _condition_48eb->end(), conditions_48e4.begin(), conditions_48e4.end());
}

void SetMatrixCondition_48df::callMatrixCondition_4919( const Packets_t& dTs_48ed, const Packets_t& triggerVars_48ef, const Packets_t& conditions_48f1)
{
	MatrixCondition_48ec matrixCondition_48ec;
	matrixCondition_48ec( dTs_48ed, triggerVars_48ef, conditions_48f1);
}

void MatrixCondition_48ec::operator()( const Packets_t& dTs_48ed, const Packets_t& triggerVars_48ef, const Packets_t& conditions_48f1)
{
#ifdef PRINT_INFO
	printLog( "MatrixCondition_48ec" );
#endif
	RTTGenerator::Instance()->generateRule(4154, "MatrixCondition");
	processInputPackets( dTs_48ed, triggerVars_48ef, conditions_48f1);
}

bool MatrixCondition_48ec::isInputUnique( const Udm::Object& dT_48f7, const Udm::Object& triggerVar_4900, const Udm::Object& condition_4909)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itDT_48f9= _dT_48f3.begin(), itTriggerVar_4902= _triggerVar_48fc.begin(), itCondition_490b= _condition_4905.begin(); itDT_48f9!= _dT_48f3.end(), itTriggerVar_4902!= _triggerVar_48fc.end(), itCondition_490b!= _condition_4905.end(); ++itDT_48f9, ++itTriggerVar_4902, ++itCondition_490b)
	{
		if( ( *itDT_48f9== dT_48f7)&& ( *itTriggerVar_4902== triggerVar_4900)&& ( *itCondition_490b== condition_4909))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_dT_48f3.push_back( dT_48f7);
		_triggerVar_48fc.push_back( triggerVar_4900);
		_condition_4905.push_back( condition_4909);
	}
	return isUnique;
}

bool MatrixCondition_48ec::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool MatrixCondition_48ec::isGuardTrue( SFC::UserCode& Condition, SFC::DT& DT, SFC::LocalVar& TriggerVar)
{
	bool Gz_guard= false;
	Gz_guard = DT.type() != SFC::Struct::meta;;
	return Gz_guard;
}

void MatrixCondition_48ec::processInputPackets( const Packets_t& dTs_48ed, const Packets_t& triggerVars_48ef, const Packets_t& conditions_48f1)
{
	for( Packets_t::const_iterator itDT_48f4= dTs_48ed.begin(), itTriggerVar_48fd= triggerVars_48ef.begin(), itCondition_4906= conditions_48f1.begin(); itDT_48f4!= dTs_48ed.end(), itTriggerVar_48fd!= triggerVars_48ef.end(), itCondition_4906!= conditions_48f1.end(); ++itDT_48f4, ++itTriggerVar_48fd, ++itCondition_4906)
	{
		bool isUnique= isInputUnique( *itDT_48f4, *itTriggerVar_48fd, *itCondition_4906);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itDT_48f4, *itTriggerVar_48fd, *itCondition_4906);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool MatrixCondition_48ec::patternMatcher( const Udm::Object& dT_48f5, const Udm::Object& triggerVar_48fe, const Udm::Object& condition_4907)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( dT_48f5.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_48fa= SFC::DT::Cast( dT_48f5);
		if( false== Uml::IsDerivedFrom( triggerVar_48fe.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_4903= SFC::LocalVar::Cast( triggerVar_48fe);
		if( false== Uml::IsDerivedFrom( condition_4907.type(), SFC::UserCode::meta))
			continue;
		SFC::UserCode condition_490c= SFC::UserCode::Cast( condition_4907);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4911;
		if( !isValidBound(boundObjs_4911, dT_48fa, true))
			continue;
		currMatch.dT_4912= dT_48fa;
		if( !isValidBound(boundObjs_4911, triggerVar_4903, true))
			continue;
		currMatch.triggerVar_4913= triggerVar_4903;
		if( !isValidBound(boundObjs_4911, condition_490c, true))
			continue;
		currMatch.condition_4914= condition_490c;
		bool Gz_guard= isGuardTrue( currMatch.condition_4914, currMatch.dT_4912, currMatch.triggerVar_4913);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void MatrixCondition_48ec::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ArgDeclRef newArgDeclRef_4918= SFC::ArgDeclRef::Create( currMatch.condition_4914, SFC::UserCode::meta_codeexpr);
		newArgDeclRef_4918.argdecl()= currMatch.triggerVar_4913;
	}
}

void CreateConditional_491d::operator()( const Packets_t& subsystems_491e, const Packets_t& charts_4921, const Packets_t& dTs_4924, const Packets_t& localVars_4927, const Packets_t& functions_492b, Packets_t& subsystems_4920, Packets_t& charts_4923, Packets_t& dTs_4926, Packets_t& triggerVars_4929, Packets_t& userCodes_492a, Packets_t& conditionalBlocks_492d)
{
#ifdef PRINT_INFO
	printLog( "CreateConditional_491d" );
#endif
	RTTGenerator::Instance()->generateRule(4161, "CreateConditional");
	_subsystem_492e= &subsystems_4920;
	_chart_492f= &charts_4923;
	_dT_4930= &dTs_4926;
	_triggerVar_4931= &triggerVars_4929;
	_userCode_4932= &userCodes_492a;
	_conditionalBlock_4933= &conditionalBlocks_492d;
	processInputPackets( subsystems_491e, charts_4921, dTs_4924, localVars_4927, functions_492b);
}

bool CreateConditional_491d::isInputUnique( const Udm::Object& subsystem_4938, const Udm::Object& chart_4941, const Udm::Object& dT_494a, const Udm::Object& localVar_4953, const Udm::Object& function_495c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_493a= _subsystem_4934.begin(), itChart_4943= _chart_493d.begin(), itDT_494c= _dT_4946.begin(), itLocalVar_4955= _localVar_494f.begin(), itFunction_495e= _function_4958.begin(); itSubsystem_493a!= _subsystem_4934.end(), itChart_4943!= _chart_493d.end(), itDT_494c!= _dT_4946.end(), itLocalVar_4955!= _localVar_494f.end(), itFunction_495e!= _function_4958.end(); ++itSubsystem_493a, ++itChart_4943, ++itDT_494c, ++itLocalVar_4955, ++itFunction_495e)
	{
		if( ( *itSubsystem_493a== subsystem_4938)&& ( *itChart_4943== chart_4941)&& ( *itDT_494c== dT_494a)&& ( *itLocalVar_4955== localVar_4953)&& ( *itFunction_495e== function_495c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_4934.push_back( subsystem_4938);
		_chart_493d.push_back( chart_4941);
		_dT_4946.push_back( dT_494a);
		_localVar_494f.push_back( localVar_4953);
		_function_4958.push_back( function_495c);
	}
	return isUnique;
}

bool CreateConditional_491d::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateConditional_491d::processInputPackets( const Packets_t& subsystems_491e, const Packets_t& charts_4921, const Packets_t& dTs_4924, const Packets_t& localVars_4927, const Packets_t& functions_492b)
{
	for( Packets_t::const_iterator itSubsystem_4935= subsystems_491e.begin(), itChart_493e= charts_4921.begin(), itDT_4947= dTs_4924.begin(), itLocalVar_4950= localVars_4927.begin(), itFunction_4959= functions_492b.begin(); itSubsystem_4935!= subsystems_491e.end(), itChart_493e!= charts_4921.end(), itDT_4947!= dTs_4924.end(), itLocalVar_4950!= localVars_4927.end(), itFunction_4959!= functions_492b.end(); ++itSubsystem_4935, ++itChart_493e, ++itDT_4947, ++itLocalVar_4950, ++itFunction_4959)
	{
		bool isUnique= isInputUnique( *itSubsystem_4935, *itChart_493e, *itDT_4947, *itLocalVar_4950, *itFunction_4959);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_4935, *itChart_493e, *itDT_4947, *itLocalVar_4950, *itFunction_4959);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateConditional_491d::patternMatcher( const Udm::Object& subsystem_4936, const Udm::Object& chart_493f, const Udm::Object& dT_4948, const Udm::Object& localVar_4951, const Udm::Object& function_495a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_4936.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_493b= CyberComposition::Simulink::Subsystem::Cast( subsystem_4936);
		if( false== Uml::IsDerivedFrom( chart_493f.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem chart_4944= CyberComposition::Simulink::Subsystem::Cast( chart_493f);
		if( false== Uml::IsDerivedFrom( dT_4948.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_494d= SFC::DT::Cast( dT_4948);
		if( false== Uml::IsDerivedFrom( localVar_4951.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_4956= SFC::LocalVar::Cast( localVar_4951);
		if( false== Uml::IsDerivedFrom( function_495a.type(), SFC::Function::meta))
			continue;
		SFC::Function function_495f= SFC::Function::Cast( function_495a);
		SFC::LocalVar triggerVar_4961= localVar_4956.trigvar();
		if( !triggerVar_4961)
			continue;
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4965;
		if( !isValidBound(boundObjs_4965, subsystem_493b, true))
			continue;
		currMatch.subsystem_4966= subsystem_493b;
		if( !isValidBound(boundObjs_4965, chart_4944, true))
			continue;
		currMatch.chart_4967= chart_4944;
		if( !isValidBound(boundObjs_4965, dT_494d, true))
			continue;
		currMatch.dT_4968= dT_494d;
		if( !isValidBound(boundObjs_4965, localVar_4956, true))
			continue;
		currMatch.localVar_4969= localVar_4956;
		if( !isValidBound(boundObjs_4965, function_495f, true))
			continue;
		currMatch.function_496a= function_495f;
		if( !isValidBound(boundObjs_4965, triggerVar_4961, false))
			continue;
		currMatch.triggerVar_496b= triggerVar_4961;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateConditional_491d::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_496c= SFC::ConditionalBlock::Create( currMatch.function_496a, SFC::Function::meta_stmnt);
		SFC::UserCode newUserCode_496d= SFC::UserCode::Create( newConditionalBlock_496c, SFC::ConditionalBlock::meta_cond);
		CyberComposition::Simulink::Subsystem& Chart= currMatch.chart_4967;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_496c;
		SFC::DT& DT= currMatch.dT_4968;
		SFC::Function& Function= currMatch.function_496a;
		SFC::LocalVar& LocalVar= currMatch.localVar_4969;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_4966;
		SFC::LocalVar& TriggerVar= currMatch.triggerVar_496b;
		SFC::UserCode& UserCode= newUserCode_496d;
		{
__int64 statementCount = Function.statementCount();
ConditionalBlock.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		outputAppender( currMatch.subsystem_4966, currMatch.chart_4967, currMatch.dT_4968, currMatch.triggerVar_496b, newUserCode_496d, newConditionalBlock_496c);
	}
}

void CreateConditional_491d::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_496e, const CyberComposition::Simulink::Subsystem& chart_4970, const SFC::DT& dT_4972, const SFC::LocalVar& triggerVar_4974, const SFC::UserCode& userCode_4976, const SFC::ConditionalBlock& conditionalBlock_4978)
{
	_subsystem_492e->push_back( subsystem_496e);
	_chart_492f->push_back( chart_4970);
	_dT_4930->push_back( dT_4972);
	_triggerVar_4931->push_back( triggerVar_4974);
	_userCode_4932->push_back( userCode_4976);
	_conditionalBlock_4933->push_back( conditionalBlock_4978);
}

void AddStateVar_4988::operator()( const Packets_t& subsystems_4989, const Packets_t& triggerPorts_498c, const Packets_t& argDeclBases_498f, const Packets_t& dTs_4993, const Packets_t& functions_4997, Packets_t& subsystems_498b, Packets_t& charts_498e, Packets_t& argDeclBases_4991, Packets_t& localVars_4992, Packets_t& dTs_4995, Packets_t& args_4996, Packets_t& functions_4999)
{
#ifdef PRINT_INFO
	printLog( "AddStateVar_4988" );
#endif
	RTTGenerator::Instance()->generateRule(4174, "AddStateVar");
	_subsystem_499a= &subsystems_498b;
	_chart_499b= &charts_498e;
	_argDeclBase_499c= &argDeclBases_4991;
	_localVar_499d= &localVars_4992;
	_dT_499e= &dTs_4995;
	_arg_499f= &args_4996;
	_function_49a0= &functions_4999;
	processInputPackets( subsystems_4989, triggerPorts_498c, argDeclBases_498f, dTs_4993, functions_4997);
}

bool AddStateVar_4988::isInputUnique( const Udm::Object& subsystem_49a5, const Udm::Object& triggerPort_49ae, const Udm::Object& argDeclBase_49b7, const Udm::Object& dT_49c0, const Udm::Object& function_49c9)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_49a7= _subsystem_49a1.begin(), itTriggerPort_49b0= _triggerPort_49aa.begin(), itArgDeclBase_49b9= _argDeclBase_49b3.begin(), itDT_49c2= _dT_49bc.begin(), itFunction_49cb= _function_49c5.begin(); itSubsystem_49a7!= _subsystem_49a1.end(), itTriggerPort_49b0!= _triggerPort_49aa.end(), itArgDeclBase_49b9!= _argDeclBase_49b3.end(), itDT_49c2!= _dT_49bc.end(), itFunction_49cb!= _function_49c5.end(); ++itSubsystem_49a7, ++itTriggerPort_49b0, ++itArgDeclBase_49b9, ++itDT_49c2, ++itFunction_49cb)
	{
		if( ( *itSubsystem_49a7== subsystem_49a5)&& ( *itTriggerPort_49b0== triggerPort_49ae)&& ( *itArgDeclBase_49b9== argDeclBase_49b7)&& ( *itDT_49c2== dT_49c0)&& ( *itFunction_49cb== function_49c9))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_49a1.push_back( subsystem_49a5);
		_triggerPort_49aa.push_back( triggerPort_49ae);
		_argDeclBase_49b3.push_back( argDeclBase_49b7);
		_dT_49bc.push_back( dT_49c0);
		_function_49c5.push_back( function_49c9);
	}
	return isUnique;
}

bool AddStateVar_4988::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void AddStateVar_4988::processInputPackets( const Packets_t& subsystems_4989, const Packets_t& triggerPorts_498c, const Packets_t& argDeclBases_498f, const Packets_t& dTs_4993, const Packets_t& functions_4997)
{
	for( Packets_t::const_iterator itSubsystem_49a2= subsystems_4989.begin(), itTriggerPort_49ab= triggerPorts_498c.begin(), itArgDeclBase_49b4= argDeclBases_498f.begin(), itDT_49bd= dTs_4993.begin(), itFunction_49c6= functions_4997.begin(); itSubsystem_49a2!= subsystems_4989.end(), itTriggerPort_49ab!= triggerPorts_498c.end(), itArgDeclBase_49b4!= argDeclBases_498f.end(), itDT_49bd!= dTs_4993.end(), itFunction_49c6!= functions_4997.end(); ++itSubsystem_49a2, ++itTriggerPort_49ab, ++itArgDeclBase_49b4, ++itDT_49bd, ++itFunction_49c6)
	{
		bool isUnique= isInputUnique( *itSubsystem_49a2, *itTriggerPort_49ab, *itArgDeclBase_49b4, *itDT_49bd, *itFunction_49c6);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_49a2, *itTriggerPort_49ab, *itArgDeclBase_49b4, *itDT_49bd, *itFunction_49c6);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AddStateVar_4988::patternMatcher( const Udm::Object& subsystem_49a3, const Udm::Object& triggerPort_49ac, const Udm::Object& argDeclBase_49b5, const Udm::Object& dT_49be, const Udm::Object& function_49c7)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_49a3.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_49a8= CyberComposition::Simulink::Subsystem::Cast( subsystem_49a3);
		if( false== Uml::IsDerivedFrom( triggerPort_49ac.type(), CyberComposition::Simulink::TriggerPort::meta))
			continue;
		CyberComposition::Simulink::TriggerPort triggerPort_49b1= CyberComposition::Simulink::TriggerPort::Cast( triggerPort_49ac);
		if( false== Uml::IsDerivedFrom( argDeclBase_49b5.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_49ba= SFC::ArgDeclBase::Cast( argDeclBase_49b5);
		if( false== Uml::IsDerivedFrom( dT_49be.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_49c3= SFC::DT::Cast( dT_49be);
		if( false== Uml::IsDerivedFrom( function_49c7.type(), SFC::Function::meta))
			continue;
		SFC::Function function_49cc= SFC::Function::Cast( function_49c7);
		Udm::Object triggerPortParent_49ce= triggerPort_49b1.container();
		if( false== Uml::IsDerivedFrom( triggerPortParent_49ce.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem chartTriggerPort_49cf= CyberComposition::Simulink::Subsystem::Cast( triggerPortParent_49ce);
		Udm::Object functionParent_49d0= function_49cc.container();
		if( false== Uml::IsDerivedFrom( functionParent_49d0.type(), SFC::Class::meta))
			continue;
		SFC::Class classFunction_49d1= SFC::Class::Cast( functionParent_49d0);
		set< SFC::Struct> structs_49d2= classFunction_49d1.Struct_kind_children();
		for( set< SFC::Struct>::const_iterator itStruct_49d3= structs_49d2.begin(); itStruct_49d3!= structs_49d2.end(); ++itStruct_49d3)
		{
			SFC::Struct currStruct_49d4= *itStruct_49d3;
			set< SFC::Arg> args_49d5= function_49cc.Arg_kind_children();
			for( set< SFC::Arg>::const_iterator itArg_49d6= args_49d5.begin(); itArg_49d6!= args_49d5.end(); ++itArg_49d6)
			{
				SFC::Arg currArg_49d7= *itArg_49d6;
				SFC::DT struct_49d8= currArg_49d7.dt();
				if( !struct_49d8 || false== Uml::IsDerivedFrom( struct_49d8.type(), SFC::Struct::meta))
					continue;
				SFC::Struct struct_49d9= SFC::Struct::Cast( struct_49d8);
				if( !struct_49d9)
					continue;
				if( currStruct_49d4!= struct_49d9)
					continue;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_49dd;
				if( !isValidBound(boundObjs_49dd, subsystem_49a8, true))
					continue;
				currMatch.subsystem_49de= subsystem_49a8;
				if( !isValidBound(boundObjs_49dd, triggerPort_49b1, true))
					continue;
				currMatch.triggerPort_49df= triggerPort_49b1;
				if( !isValidBound(boundObjs_49dd, argDeclBase_49ba, true))
					continue;
				currMatch.argDeclBase_49e0= argDeclBase_49ba;
				if( !isValidBound(boundObjs_49dd, dT_49c3, true))
					continue;
				currMatch.dT_49e1= dT_49c3;
				if( !isValidBound(boundObjs_49dd, function_49cc, true))
					continue;
				currMatch.function_49e2= function_49cc;
				if( !isValidBound(boundObjs_49dd, chartTriggerPort_49cf, false))
					continue;
				currMatch.chart_49e3= chartTriggerPort_49cf;
				if( !isValidBound(boundObjs_49dd, currArg_49d7, false))
					continue;
				currMatch.arg_49e4= currArg_49d7;
				if( !isValidBound(boundObjs_49dd, currStruct_49d4, false))
					continue;
				currMatch.struct_49e5= currStruct_49d4;
				if( !isValidBound(boundObjs_49dd, classFunction_49d1, false))
					continue;
				currMatch.class_49e6= classFunction_49d1;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void AddStateVar_4988::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newLocalVar_49e7= SFC::LocalVar::Create( currMatch.struct_49e5, SFC::Struct::meta_memb);
		SFC::Arg& Arg= currMatch.arg_49e4;
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_49e0;
		CyberComposition::Simulink::Subsystem& Chart= currMatch.chart_49e3;
		SFC::Class& Class= currMatch.class_49e6;
		SFC::DT& DT= currMatch.dT_49e1;
		SFC::Function& Function= currMatch.function_49e2;
		SFC::LocalVar& LocalVar= newLocalVar_49e7;
		SFC::Struct& Struct= currMatch.struct_49e5;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_49de;
		CyberComposition::Simulink::TriggerPort& TriggerPort= currMatch.triggerPort_49df;
		{
__int64 memberCount = Struct.memberCount();
LocalVar.statementIndex() = memberCount++;
Struct.memberCount() = memberCount;

LocalVar.name() = std::string( "triggerData" ) + boost::lexical_cast< std::string >( LocalVar.uniqueId() );
};
		newLocalVar_49e7.dt()= currMatch.dT_49e1;
		newLocalVar_49e7.trig()+= currMatch.triggerPort_49df;
		outputAppender( currMatch.subsystem_49de, currMatch.chart_49e3, currMatch.argDeclBase_49e0, newLocalVar_49e7, currMatch.dT_49e1, currMatch.arg_49e4, currMatch.function_49e2);
	}
}

void AddStateVar_4988::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_49e8, const CyberComposition::Simulink::Subsystem& chart_49ea, const SFC::ArgDeclBase& argDeclBase_49ec, const SFC::LocalVar& localVar_49ee, const SFC::DT& dT_49f0, const SFC::Arg& arg_49f2, const SFC::Function& function_49f4)
{
	_subsystem_499a->push_back( subsystem_49e8);
	_chart_499b->push_back( chart_49ea);
	_argDeclBase_499c->push_back( argDeclBase_49ec);
	_localVar_499d->push_back( localVar_49ee);
	_dT_499e->push_back( dT_49f0);
	_arg_499f->push_back( arg_49f2);
	_function_49a0->push_back( function_49f4);
}

void SaveState_49f6::operator()( const Packets_t& systems_49f7, const Packets_t& childsystems_49f9, const Packets_t& argdecls_49fb, const Packets_t& dts_49fd, const Packets_t& oldvals_49ff, const Packets_t& contexts_4a01, const Packets_t& functions_4a03, Packets_t& systems_4a05, Packets_t& childsystems_4a06, Packets_t& dts_4a07, Packets_t& oldvals_4a08, Packets_t& functions_4a09)
{
#ifdef PRINT_INFO
	printLog( "SaveState_49f6" );
#endif
	_system_4a0a= &systems_4a05;
	_childsystem_4a0b= &childsystems_4a06;
	_dt_4a0c= &dts_4a07;
	_oldval_4a0d= &oldvals_4a08;
	_function_4a0e= &functions_4a09;
	_system_4a0a->insert( _system_4a0a->end(), systems_49f7.begin(), systems_49f7.end());
	_childsystem_4a0b->insert( _childsystem_4a0b->end(), childsystems_49f9.begin(), childsystems_49f9.end());
	_dt_4a0c->insert( _dt_4a0c->end(), dts_49fd.begin(), dts_49fd.end());
	_oldval_4a0d->insert( _oldval_4a0d->end(), oldvals_49ff.begin(), oldvals_49ff.end());
	_function_4a0e->insert( _function_4a0e->end(), functions_4a03.begin(), functions_4a03.end());
	if( ( !argdecls_49fb.empty())&& ( !dts_49fd.empty())&& ( !oldvals_49ff.empty())&& ( !contexts_4a01.empty())&& ( !functions_4a03.empty()))
		callSaveMatrixState_4ad6( argdecls_49fb, dts_49fd, oldvals_49ff, contexts_4a01, functions_4a03);
}

void SaveState_49f6::callSaveMatrixState_4ad6( const Packets_t& argdecls_4a70, const Packets_t& dts_4a72, const Packets_t& oldvals_4a74, const Packets_t& contexts_4a76, const Packets_t& functions_4a78)
{
	Packets_t argdecls_4a7a;
	Packets_t dts_4a7b;
	Packets_t oldvals_4a7c;
	Packets_t contexts_4a7d;
	Packets_t functions_4a7e;
	SaveMatrixState_4a6f saveMatrixState_4a6f;
	saveMatrixState_4a6f( argdecls_4a70, dts_4a72, oldvals_4a74, contexts_4a76, functions_4a78, argdecls_4a7a, dts_4a7b, oldvals_4a7c, contexts_4a7d, functions_4a7e);
	if( ( !argdecls_4a7a.empty())&& ( !dts_4a7b.empty())&& ( !oldvals_4a7c.empty())&& ( !contexts_4a7d.empty())&& ( !functions_4a7e.empty()))
		callSaveStructState_4adc( argdecls_4a7a, dts_4a7b, oldvals_4a7c, contexts_4a7d, functions_4a7e);
}

void SaveState_49f6::callSaveStructState_4adc( const Packets_t& argdecls_4a10, const Packets_t& dts_4a12, const Packets_t& oldvals_4a14, const Packets_t& contexts_4a16, const Packets_t& functions_4a18)
{
	SaveStructState_4a0f saveStructState_4a0f;
	saveStructState_4a0f( argdecls_4a10, dts_4a12, oldvals_4a14, contexts_4a16, functions_4a18);
}

void SaveStructState_4a0f::operator()( const Packets_t& argdecls_4a10, const Packets_t& dts_4a12, const Packets_t& oldvals_4a14, const Packets_t& contexts_4a16, const Packets_t& functions_4a18)
{
#ifdef PRINT_INFO
	printLog( "SaveStructState_4a0f" );
#endif
	if( ( !argdecls_4a10.empty())&& ( !dts_4a12.empty())&& ( !oldvals_4a14.empty())&& ( !contexts_4a16.empty())&& ( !functions_4a18.empty()))
		callSaveStructState_4a69( argdecls_4a10, dts_4a12, oldvals_4a14, contexts_4a16, functions_4a18);
}

void SaveStructState_4a0f::callSaveStructState_4a69( const Packets_t& argDeclBases_4a1b, const Packets_t& structs_4a1d, const Packets_t& localVars_4a1f, const Packets_t& contexts_4a21, const Packets_t& functions_4a23)
{
	SaveStructState_4a1a saveStructState_4a1a;
	saveStructState_4a1a( argDeclBases_4a1b, structs_4a1d, localVars_4a1f, contexts_4a21, functions_4a23);
}

void SaveStructState_4a1a::operator()( const Packets_t& argDeclBases_4a1b, const Packets_t& structs_4a1d, const Packets_t& localVars_4a1f, const Packets_t& contexts_4a21, const Packets_t& functions_4a23)
{
#ifdef PRINT_INFO
	printLog( "SaveStructState_4a1a" );
#endif
	RTTGenerator::Instance()->generateRule(4213, "SaveStructState");
	processInputPackets( argDeclBases_4a1b, structs_4a1d, localVars_4a1f, contexts_4a21, functions_4a23);
}

bool SaveStructState_4a1a::isInputUnique( const Udm::Object& argDeclBase_4a29, const Udm::Object& struct_4a32, const Udm::Object& localVar_4a3b, const Udm::Object& context_4a44, const Udm::Object& function_4a4d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_4a2b= _argDeclBase_4a25.begin(), itStruct_4a34= _struct_4a2e.begin(), itLocalVar_4a3d= _localVar_4a37.begin(), itContext_4a46= _context_4a40.begin(), itFunction_4a4f= _function_4a49.begin(); itArgDeclBase_4a2b!= _argDeclBase_4a25.end(), itStruct_4a34!= _struct_4a2e.end(), itLocalVar_4a3d!= _localVar_4a37.end(), itContext_4a46!= _context_4a40.end(), itFunction_4a4f!= _function_4a49.end(); ++itArgDeclBase_4a2b, ++itStruct_4a34, ++itLocalVar_4a3d, ++itContext_4a46, ++itFunction_4a4f)
	{
		if( ( *itArgDeclBase_4a2b== argDeclBase_4a29)&& ( *itStruct_4a34== struct_4a32)&& ( *itLocalVar_4a3d== localVar_4a3b)&& ( *itContext_4a46== context_4a44)&& ( *itFunction_4a4f== function_4a4d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_4a25.push_back( argDeclBase_4a29);
		_struct_4a2e.push_back( struct_4a32);
		_localVar_4a37.push_back( localVar_4a3b);
		_context_4a40.push_back( context_4a44);
		_function_4a49.push_back( function_4a4d);
	}
	return isUnique;
}

bool SaveStructState_4a1a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void SaveStructState_4a1a::processInputPackets( const Packets_t& argDeclBases_4a1b, const Packets_t& structs_4a1d, const Packets_t& localVars_4a1f, const Packets_t& contexts_4a21, const Packets_t& functions_4a23)
{
	for( Packets_t::const_iterator itArgDeclBase_4a26= argDeclBases_4a1b.begin(), itStruct_4a2f= structs_4a1d.begin(), itLocalVar_4a38= localVars_4a1f.begin(), itContext_4a41= contexts_4a21.begin(), itFunction_4a4a= functions_4a23.begin(); itArgDeclBase_4a26!= argDeclBases_4a1b.end(), itStruct_4a2f!= structs_4a1d.end(), itLocalVar_4a38!= localVars_4a1f.end(), itContext_4a41!= contexts_4a21.end(), itFunction_4a4a!= functions_4a23.end(); ++itArgDeclBase_4a26, ++itStruct_4a2f, ++itLocalVar_4a38, ++itContext_4a41, ++itFunction_4a4a)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_4a26, *itStruct_4a2f, *itLocalVar_4a38, *itContext_4a41, *itFunction_4a4a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_4a26, *itStruct_4a2f, *itLocalVar_4a38, *itContext_4a41, *itFunction_4a4a);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool SaveStructState_4a1a::patternMatcher( const Udm::Object& argDeclBase_4a27, const Udm::Object& struct_4a30, const Udm::Object& localVar_4a39, const Udm::Object& context_4a42, const Udm::Object& function_4a4b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_4a27.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_4a2c= SFC::ArgDeclBase::Cast( argDeclBase_4a27);
		if( false== Uml::IsDerivedFrom( struct_4a30.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_4a35= SFC::Struct::Cast( struct_4a30);
		if( false== Uml::IsDerivedFrom( localVar_4a39.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_4a3e= SFC::LocalVar::Cast( localVar_4a39);
		if( false== Uml::IsDerivedFrom( context_4a42.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_4a47= SFC::Arg::Cast( context_4a42);
		if( false== Uml::IsDerivedFrom( function_4a4b.type(), SFC::Function::meta))
			continue;
		SFC::Function function_4a50= SFC::Function::Cast( function_4a4b);
		set< SFC::LocalVar> members_4a52= struct_4a35.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itMember_4a53= members_4a52.begin(); itMember_4a53!= members_4a52.end(); ++itMember_4a53)
		{
			SFC::LocalVar currMember_4a54= *itMember_4a53;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_4a58;
			if( !isValidBound(boundObjs_4a58, argDeclBase_4a2c, true))
				continue;
			currMatch.argDeclBase_4a59= argDeclBase_4a2c;
			if( !isValidBound(boundObjs_4a58, struct_4a35, true))
				continue;
			currMatch.struct_4a5a= struct_4a35;
			if( !isValidBound(boundObjs_4a58, localVar_4a3e, true))
				continue;
			currMatch.localVar_4a5b= localVar_4a3e;
			if( !isValidBound(boundObjs_4a58, context_4a47, true))
				continue;
			currMatch.context_4a5c= context_4a47;
			if( !isValidBound(boundObjs_4a58, function_4a50, true))
				continue;
			currMatch.function_4a5d= function_4a50;
			if( !isValidBound(boundObjs_4a58, currMember_4a54, false))
				continue;
			currMatch.member_4a5e= currMember_4a54;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void SaveStructState_4a1a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newUserCode_4a5f= SFC::UserCode::Create( currMatch.function_4a5d);
		SFC::BinaryExprs newAssign_4a60= SFC::BinaryExprs::Create( newUserCode_4a5f, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newArgDeclDot2_4a61= SFC::BinaryExprs::Create( newAssign_4a60, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef2_4a62= SFC::ArgDeclRef::Create( newArgDeclDot2_4a61, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newMemberRef2_4a63= SFC::ArgDeclRef::Create( newArgDeclDot2_4a61, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newMemberDot_4a64= SFC::BinaryExprs::Create( newAssign_4a60, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newContextDot_4a65= SFC::BinaryExprs::Create( newMemberDot_4a64, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newMemberRef3_4a66= SFC::ArgDeclRef::Create( newMemberDot_4a64, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef4_4a67= SFC::ArgDeclRef::Create( newContextDot_4a65, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef3_4a68= SFC::ArgDeclRef::Create( newContextDot_4a65, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_4a59;
		SFC::BinaryExprs& ArgDeclDot2= newArgDeclDot2_4a61;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_4a62;
		SFC::ArgDeclRef& ArgDeclRef3= newArgDeclRef3_4a68;
		SFC::ArgDeclRef& ArgDeclRef4= newArgDeclRef4_4a67;
		SFC::BinaryExprs& Assign= newAssign_4a60;
		SFC::Arg& Context= currMatch.context_4a5c;
		SFC::BinaryExprs& ContextDot= newContextDot_4a65;
		SFC::Function& Function= currMatch.function_4a5d;
		SFC::LocalVar& LocalVar= currMatch.localVar_4a5b;
		SFC::LocalVar& Member= currMatch.member_4a5e;
		SFC::BinaryExprs& MemberDot= newMemberDot_4a64;
		SFC::ArgDeclRef& MemberRef2= newMemberRef2_4a63;
		SFC::ArgDeclRef& MemberRef3= newMemberRef3_4a66;
		SFC::Struct& Struct= currMatch.struct_4a5a;
		SFC::UserCode& UserCode= newUserCode_4a5f;
		{
ArgDeclDot2.op() = ".";
};
		{
MemberDot.op() = ".";
};
		{
Assign.op() = "=";
};
		{
__int64 statementCount = Function.statementCount();
UserCode.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		{
ContextDot.op() = ".";
};
		newMemberRef2_4a63.argdecl()= currMatch.member_4a5e;
		newMemberRef3_4a66.argdecl()= currMatch.member_4a5e;
		newArgDeclRef3_4a68.argdecl()= currMatch.localVar_4a5b;
		newArgDeclRef2_4a62.argdecl()= currMatch.argDeclBase_4a59;
		newArgDeclRef4_4a67.argdecl()= currMatch.context_4a5c;
	}
}

void SaveMatrixState_4a6f::operator()( const Packets_t& argdecls_4a70, const Packets_t& dts_4a72, const Packets_t& oldvals_4a74, const Packets_t& contexts_4a76, const Packets_t& functions_4a78, Packets_t& argdecls_4a7a, Packets_t& dts_4a7b, Packets_t& oldvals_4a7c, Packets_t& contexts_4a7d, Packets_t& functions_4a7e)
{
#ifdef PRINT_INFO
	printLog( "SaveMatrixState_4a6f" );
#endif
	_argdecl_4a7f= &argdecls_4a7a;
	_dt_4a80= &dts_4a7b;
	_oldval_4a81= &oldvals_4a7c;
	_context_4a82= &contexts_4a7d;
	_function_4a83= &functions_4a7e;
	_argdecl_4a7f->insert( _argdecl_4a7f->end(), argdecls_4a70.begin(), argdecls_4a70.end());
	_dt_4a80->insert( _dt_4a80->end(), dts_4a72.begin(), dts_4a72.end());
	_oldval_4a81->insert( _oldval_4a81->end(), oldvals_4a74.begin(), oldvals_4a74.end());
	_context_4a82->insert( _context_4a82->end(), contexts_4a76.begin(), contexts_4a76.end());
	_function_4a83->insert( _function_4a83->end(), functions_4a78.begin(), functions_4a78.end());
	if( ( !argdecls_4a70.empty())&& ( !dts_4a72.empty())&& ( !oldvals_4a74.empty())&& ( !contexts_4a76.empty())&& ( !functions_4a78.empty()))
		callSaveMatrixState_4ad0( argdecls_4a70, dts_4a72, oldvals_4a74, contexts_4a76, functions_4a78);
}

void SaveMatrixState_4a6f::callSaveMatrixState_4ad0( const Packets_t& argDeclBases_4a85, const Packets_t& dTs_4a87, const Packets_t& localVars_4a89, const Packets_t& args_4a8b, const Packets_t& functions_4a8d)
{
	SaveMatrixState_4a84 saveMatrixState_4a84;
	saveMatrixState_4a84( argDeclBases_4a85, dTs_4a87, localVars_4a89, args_4a8b, functions_4a8d);
}

void SaveMatrixState_4a84::operator()( const Packets_t& argDeclBases_4a85, const Packets_t& dTs_4a87, const Packets_t& localVars_4a89, const Packets_t& args_4a8b, const Packets_t& functions_4a8d)
{
#ifdef PRINT_INFO
	printLog( "SaveMatrixState_4a84" );
#endif
	RTTGenerator::Instance()->generateRule(4262, "SaveMatrixState");
	processInputPackets( argDeclBases_4a85, dTs_4a87, localVars_4a89, args_4a8b, functions_4a8d);
}

bool SaveMatrixState_4a84::isInputUnique( const Udm::Object& argDeclBase_4a93, const Udm::Object& dT_4a9c, const Udm::Object& localVar_4aa5, const Udm::Object& arg_4aae, const Udm::Object& function_4ab7)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_4a95= _argDeclBase_4a8f.begin(), itDT_4a9e= _dT_4a98.begin(), itLocalVar_4aa7= _localVar_4aa1.begin(), itArg_4ab0= _arg_4aaa.begin(), itFunction_4ab9= _function_4ab3.begin(); itArgDeclBase_4a95!= _argDeclBase_4a8f.end(), itDT_4a9e!= _dT_4a98.end(), itLocalVar_4aa7!= _localVar_4aa1.end(), itArg_4ab0!= _arg_4aaa.end(), itFunction_4ab9!= _function_4ab3.end(); ++itArgDeclBase_4a95, ++itDT_4a9e, ++itLocalVar_4aa7, ++itArg_4ab0, ++itFunction_4ab9)
	{
		if( ( *itArgDeclBase_4a95== argDeclBase_4a93)&& ( *itDT_4a9e== dT_4a9c)&& ( *itLocalVar_4aa7== localVar_4aa5)&& ( *itArg_4ab0== arg_4aae)&& ( *itFunction_4ab9== function_4ab7))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_4a8f.push_back( argDeclBase_4a93);
		_dT_4a98.push_back( dT_4a9c);
		_localVar_4aa1.push_back( localVar_4aa5);
		_arg_4aaa.push_back( arg_4aae);
		_function_4ab3.push_back( function_4ab7);
	}
	return isUnique;
}

bool SaveMatrixState_4a84::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool SaveMatrixState_4a84::isGuardTrue( SFC::Arg& Arg, SFC::ArgDeclBase& ArgDeclBase, SFC::DT& DT, SFC::Function& Function, SFC::LocalVar& LocalVar)
{
	bool Gz_guard= false;
	Gz_guard = DT.type() != SFC::Struct::meta;;
	return Gz_guard;
}

void SaveMatrixState_4a84::processInputPackets( const Packets_t& argDeclBases_4a85, const Packets_t& dTs_4a87, const Packets_t& localVars_4a89, const Packets_t& args_4a8b, const Packets_t& functions_4a8d)
{
	for( Packets_t::const_iterator itArgDeclBase_4a90= argDeclBases_4a85.begin(), itDT_4a99= dTs_4a87.begin(), itLocalVar_4aa2= localVars_4a89.begin(), itArg_4aab= args_4a8b.begin(), itFunction_4ab4= functions_4a8d.begin(); itArgDeclBase_4a90!= argDeclBases_4a85.end(), itDT_4a99!= dTs_4a87.end(), itLocalVar_4aa2!= localVars_4a89.end(), itArg_4aab!= args_4a8b.end(), itFunction_4ab4!= functions_4a8d.end(); ++itArgDeclBase_4a90, ++itDT_4a99, ++itLocalVar_4aa2, ++itArg_4aab, ++itFunction_4ab4)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_4a90, *itDT_4a99, *itLocalVar_4aa2, *itArg_4aab, *itFunction_4ab4);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_4a90, *itDT_4a99, *itLocalVar_4aa2, *itArg_4aab, *itFunction_4ab4);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool SaveMatrixState_4a84::patternMatcher( const Udm::Object& argDeclBase_4a91, const Udm::Object& dT_4a9a, const Udm::Object& localVar_4aa3, const Udm::Object& arg_4aac, const Udm::Object& function_4ab5)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_4a91.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_4a96= SFC::ArgDeclBase::Cast( argDeclBase_4a91);
		if( false== Uml::IsDerivedFrom( dT_4a9a.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_4a9f= SFC::DT::Cast( dT_4a9a);
		if( false== Uml::IsDerivedFrom( localVar_4aa3.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_4aa8= SFC::LocalVar::Cast( localVar_4aa3);
		if( false== Uml::IsDerivedFrom( arg_4aac.type(), SFC::Arg::meta))
			continue;
		SFC::Arg arg_4ab1= SFC::Arg::Cast( arg_4aac);
		if( false== Uml::IsDerivedFrom( function_4ab5.type(), SFC::Function::meta))
			continue;
		SFC::Function function_4aba= SFC::Function::Cast( function_4ab5);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4abf;
		if( !isValidBound(boundObjs_4abf, argDeclBase_4a96, true))
			continue;
		currMatch.argDeclBase_4ac0= argDeclBase_4a96;
		if( !isValidBound(boundObjs_4abf, dT_4a9f, true))
			continue;
		currMatch.dT_4ac1= dT_4a9f;
		if( !isValidBound(boundObjs_4abf, localVar_4aa8, true))
			continue;
		currMatch.localVar_4ac2= localVar_4aa8;
		if( !isValidBound(boundObjs_4abf, arg_4ab1, true))
			continue;
		currMatch.arg_4ac3= arg_4ab1;
		if( !isValidBound(boundObjs_4abf, function_4aba, true))
			continue;
		currMatch.function_4ac4= function_4aba;
		bool Gz_guard= isGuardTrue( currMatch.arg_4ac3, currMatch.argDeclBase_4ac0, currMatch.dT_4ac1, currMatch.function_4ac4, currMatch.localVar_4ac2);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void SaveMatrixState_4a84::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newUserCode_4aca= SFC::UserCode::Create( currMatch.function_4ac4, SFC::Function::meta_stmnt);
		SFC::BinaryExprs newAssign_4acb= SFC::BinaryExprs::Create( newUserCode_4aca, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newArgDeclRef2_4acc= SFC::ArgDeclRef::Create( newAssign_4acb, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newDot_4acd= SFC::BinaryExprs::Create( newAssign_4acb, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef4_4ace= SFC::ArgDeclRef::Create( newDot_4acd, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef3_4acf= SFC::ArgDeclRef::Create( newDot_4acd, SFC::BinaryExprs::meta_rightexpr);
		SFC::Arg& Arg= currMatch.arg_4ac3;
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_4ac0;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_4acc;
		SFC::ArgDeclRef& ArgDeclRef3= newArgDeclRef3_4acf;
		SFC::ArgDeclRef& ArgDeclRef4= newArgDeclRef4_4ace;
		SFC::BinaryExprs& Assign= newAssign_4acb;
		SFC::DT& DT= currMatch.dT_4ac1;
		SFC::BinaryExprs& Dot= newDot_4acd;
		SFC::Function& Function= currMatch.function_4ac4;
		SFC::LocalVar& LocalVar= currMatch.localVar_4ac2;
		SFC::UserCode& UserCode= newUserCode_4aca;
		{
Dot.op() = ".";
};
		{
Assign.op() = "=";
};
		{
__int64 statementCount = Function.statementCount();
UserCode.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		newArgDeclRef2_4acc.argdecl()= currMatch.argDeclBase_4ac0;
		newArgDeclRef4_4ace.argdecl()= currMatch.arg_4ac3;
		newArgDeclRef3_4acf.argdecl()= currMatch.localVar_4ac2;
	}
}

void AddTriggerVars_4ae2::operator()( const Packets_t& systems_4ae3, const Packets_t& childsystems_4ae5, const Packets_t& argdecls_4ae7, const Packets_t& dts_4ae9, const Packets_t& oldvals_4aeb, const Packets_t& contexts_4aed, const Packets_t& functions_4aef, Packets_t& systems_4af1, Packets_t& childsystems_4af2, Packets_t& argdecls_4af3, Packets_t& dts_4af4, Packets_t& oldvals_4af5, Packets_t& contexts_4af6, Packets_t& functions_4af7)
{
#ifdef PRINT_INFO
	printLog( "AddTriggerVars_4ae2" );
#endif
	_system_4af8= &systems_4af1;
	_childsystem_4af9= &childsystems_4af2;
	_argdecl_4afa= &argdecls_4af3;
	_dt_4afb= &dts_4af4;
	_oldval_4afc= &oldvals_4af5;
	_context_4afd= &contexts_4af6;
	_function_4afe= &functions_4af7;
	_system_4af8->insert( _system_4af8->end(), systems_4ae3.begin(), systems_4ae3.end());
	_childsystem_4af9->insert( _childsystem_4af9->end(), childsystems_4ae5.begin(), childsystems_4ae5.end());
	_argdecl_4afa->insert( _argdecl_4afa->end(), argdecls_4ae7.begin(), argdecls_4ae7.end());
	_dt_4afb->insert( _dt_4afb->end(), dts_4ae9.begin(), dts_4ae9.end());
	_oldval_4afc->insert( _oldval_4afc->end(), oldvals_4aeb.begin(), oldvals_4aeb.end());
	_context_4afd->insert( _context_4afd->end(), contexts_4aed.begin(), contexts_4aed.end());
	_function_4afe->insert( _function_4afe->end(), functions_4aef.begin(), functions_4aef.end());
	if( ( !childsystems_4ae5.empty())&& ( !argdecls_4ae7.empty())&& ( !dts_4ae9.empty())&& ( !oldvals_4aeb.empty())&& ( !contexts_4aed.empty())&& ( !functions_4aef.empty()))
		callAddMatrixTriggerVars_51fa( childsystems_4ae5, argdecls_4ae7, dts_4ae9, oldvals_4aeb, contexts_4aed, functions_4aef);
}

void AddTriggerVars_4ae2::callAddMatrixTriggerVars_51fa( const Packets_t& childSubsystems_4ebf, const Packets_t& argdecls_4ec1, const Packets_t& dts_4ec3, const Packets_t& oldvals_4ec5, const Packets_t& contexts_4ec7, const Packets_t& functions_4ec9)
{
	Packets_t childSubsystems_4ecb;
	Packets_t argdecls_4ecc;
	Packets_t dts_4ecd;
	Packets_t oldvals_4ece;
	Packets_t contexts_4ecf;
	Packets_t functions_4ed0;
	AddMatrixTriggerVars_4ebe addMatrixTriggerVars_4ebe;
	addMatrixTriggerVars_4ebe( childSubsystems_4ebf, argdecls_4ec1, dts_4ec3, oldvals_4ec5, contexts_4ec7, functions_4ec9, childSubsystems_4ecb, argdecls_4ecc, dts_4ecd, oldvals_4ece, contexts_4ecf, functions_4ed0);
	if( ( !childSubsystems_4ecb.empty())&& ( !argdecls_4ecc.empty())&& ( !dts_4ecd.empty())&& ( !oldvals_4ece.empty())&& ( !contexts_4ecf.empty())&& ( !functions_4ed0.empty()))
		callAddStructTriggerVars_5201( childSubsystems_4ecb, argdecls_4ecc, dts_4ecd, oldvals_4ece, contexts_4ecf, functions_4ed0);
}

void AddTriggerVars_4ae2::callAddStructTriggerVars_5201( const Packets_t& childSubsystems_4b00, const Packets_t& argdecls_4b02, const Packets_t& dts_4b04, const Packets_t& oldvals_4b06, const Packets_t& contexts_4b08, const Packets_t& functions_4b0a)
{
	AddStructTriggerVars_4aff addStructTriggerVars_4aff;
	addStructTriggerVars_4aff( childSubsystems_4b00, argdecls_4b02, dts_4b04, oldvals_4b06, contexts_4b08, functions_4b0a);
}

void AddStructTriggerVars_4aff::operator()( const Packets_t& childSubsystems_4b00, const Packets_t& argdecls_4b02, const Packets_t& dts_4b04, const Packets_t& oldvals_4b06, const Packets_t& contexts_4b08, const Packets_t& functions_4b0a)
{
#ifdef PRINT_INFO
	printLog( "AddStructTriggerVars_4aff" );
#endif
	if( ( !childSubsystems_4b00.empty())&& ( !argdecls_4b02.empty())&& ( !dts_4b04.empty())&& ( !oldvals_4b06.empty())&& ( !contexts_4b08.empty())&& ( !functions_4b0a.empty()))
		callAddTriggerVar_4e8a( childSubsystems_4b00, argdecls_4b02, dts_4b04, oldvals_4b06, contexts_4b08, functions_4b0a);
}

void AddStructTriggerVars_4aff::callAddTriggerVar_4e8a( const Packets_t& charts_4d8f, const Packets_t& argDeclBases_4d92, const Packets_t& structs_4d95, const Packets_t& localVars_4d98, const Packets_t& contexts_4d9b, const Packets_t& functions_4d9f)
{
	Packets_t charts_4d91;
	Packets_t argDeclBases_4d94;
	Packets_t structs_4d97;
	Packets_t localVars_4d9a;
	Packets_t contexts_4d9d;
	Packets_t triggerVars_4d9e;
	Packets_t functions_4da1;
	AddTriggerVar_4d8e addTriggerVar_4d8e;
	addTriggerVar_4d8e( charts_4d8f, argDeclBases_4d92, structs_4d95, localVars_4d98, contexts_4d9b, functions_4d9f, charts_4d91, argDeclBases_4d94, structs_4d97, localVars_4d9a, contexts_4d9d, triggerVars_4d9e, functions_4da1);
	if( ( !charts_4d91.empty())&& ( !argDeclBases_4d94.empty())&& ( !structs_4d97.empty())&& ( !localVars_4d9a.empty())&& ( !contexts_4d9d.empty())&& ( !triggerVars_4d9e.empty())&& ( !functions_4da1.empty()))
		callStartAssignment_4e91( charts_4d91, argDeclBases_4d94, structs_4d97, localVars_4d9a, contexts_4d9d, triggerVars_4d9e, functions_4da1);
}

void AddStructTriggerVars_4aff::callStartAssignment_4e91( const Packets_t& charts_4dfa, const Packets_t& argDeclBases_4dfc, const Packets_t& structs_4e00, const Packets_t& oldvals_4e02, const Packets_t& contexts_4e05, const Packets_t& triggerVars_4e08, const Packets_t& functions_4e0a)
{
	Packets_t events_4df9;
	Packets_t argDeclBases_4dfe;
	Packets_t localVars_4dff;
	Packets_t oldvals_4e04;
	Packets_t contexts_4e07;
	Packets_t unaryExprss_4e0c;
	StartAssignment_4df8 startAssignment_4df8;
	startAssignment_4df8( charts_4dfa, argDeclBases_4dfc, structs_4e00, oldvals_4e02, contexts_4e05, triggerVars_4e08, functions_4e0a, events_4df9, argDeclBases_4dfe, localVars_4dff, oldvals_4e04, contexts_4e07, unaryExprss_4e0c);
	if( ( !events_4df9.empty())&& ( !argDeclBases_4dfe.empty())&& ( !localVars_4dff.empty())&& ( !oldvals_4e04.empty())&& ( !contexts_4e07.empty())&& ( !unaryExprss_4e0c.empty()))
		callEdgeTest_4e99( events_4df9, argDeclBases_4dfe, localVars_4dff, oldvals_4e04, contexts_4e07, unaryExprss_4e0c);
}

void AddStructTriggerVars_4aff::callEdgeTest_4e99( const Packets_t& events_4c05, const Packets_t& argdecls_4c07, const Packets_t& members_4c09, const Packets_t& oldvals_4c0b, const Packets_t& contexts_4c0d, const Packets_t& initexprs_4c0f)
{
	Packets_t argdecls_4c11;
	Packets_t members_4c12;
	Packets_t oldvals_4c13;
	Packets_t contexts_4c14;
	Packets_t initexprs_4c15;
	Packets_t argdecls_4c16;
	Packets_t members_4c17;
	Packets_t oldvals_4c18;
	Packets_t contexts_4c19;
	Packets_t initexprs_4c1a;
	Packets_t argdecls_4c1b;
	Packets_t members_4c1c;
	Packets_t oldvals_4c1d;
	Packets_t contexts_4c1e;
	Packets_t initexprs_4c1f;
	EdgeTest_4c04 edgeTest_4c04;
	edgeTest_4c04( events_4c05, argdecls_4c07, members_4c09, oldvals_4c0b, contexts_4c0d, initexprs_4c0f, argdecls_4c11, members_4c12, oldvals_4c13, contexts_4c14, initexprs_4c15, argdecls_4c16, members_4c17, oldvals_4c18, contexts_4c19, initexprs_4c1a, argdecls_4c1b, members_4c1c, oldvals_4c1d, contexts_4c1e, initexprs_4c1f);
	if( ( !argdecls_4c1b.empty())&& ( !members_4c1c.empty())&& ( !oldvals_4c1d.empty())&& ( !contexts_4c1e.empty())&& ( !initexprs_4c1f.empty()))
		callEitherEdge_4ea0( argdecls_4c1b, members_4c1c, oldvals_4c1d, contexts_4c1e, initexprs_4c1f);
	if( ( !argdecls_4c16.empty())&& ( !members_4c17.empty())&& ( !oldvals_4c18.empty())&& ( !contexts_4c19.empty())&& ( !initexprs_4c1a.empty()))
		callFallingEdge_4ea6( argdecls_4c16, members_4c17, oldvals_4c18, contexts_4c19, initexprs_4c1a);
	if( ( !argdecls_4c11.empty())&& ( !members_4c12.empty())&& ( !oldvals_4c13.empty())&& ( !contexts_4c14.empty())&& ( !initexprs_4c15.empty()))
		callRisingEdge_4eac( argdecls_4c11, members_4c12, oldvals_4c13, contexts_4c14, initexprs_4c15);
}

void AddStructTriggerVars_4aff::callEitherEdge_4ea0( const Packets_t& argDeclBases_4b0d, const Packets_t& members_4b10, const Packets_t& localVars_4b13, const Packets_t& contexts_4b16, const Packets_t& unaryExprss_4b19)
{
	Packets_t argDeclBases_4b0f;
	Packets_t members_4b12;
	Packets_t localVars_4b15;
	Packets_t contexts_4b18;
	Packets_t leftUnaryExprss_4b1b;
	Packets_t rightUnaryExprss_4b1c;
	EitherEdge_4b0c eitherEdge_4b0c;
	eitherEdge_4b0c( argDeclBases_4b0d, members_4b10, localVars_4b13, contexts_4b16, unaryExprss_4b19, argDeclBases_4b0f, members_4b12, localVars_4b15, contexts_4b18, leftUnaryExprss_4b1b, rightUnaryExprss_4b1c);
	if( ( !argDeclBases_4b0f.empty())&& ( !members_4b12.empty())&& ( !localVars_4b15.empty())&& ( !contexts_4b18.empty())&& ( !rightUnaryExprss_4b1c.empty()))
		callFallingEdge_4eb2( argDeclBases_4b0f, members_4b12, localVars_4b15, contexts_4b18, rightUnaryExprss_4b1c);
	if( ( !argDeclBases_4b0f.empty())&& ( !members_4b12.empty())&& ( !localVars_4b15.empty())&& ( !contexts_4b18.empty())&& ( !leftUnaryExprss_4b1b.empty()))
		callRisingEdge_4eb8( argDeclBases_4b0f, members_4b12, localVars_4b15, contexts_4b18, leftUnaryExprss_4b1b);
}

void AddStructTriggerVars_4aff::callFallingEdge_4ea6( const Packets_t& argDeclBases_4b69, const Packets_t& members_4b6b, const Packets_t& localVars_4b6d, const Packets_t& contexts_4b6f, const Packets_t& unaryExprss_4b71)
{
	FallingEdge_4b68 fallingEdge_4b68;
	fallingEdge_4b68( argDeclBases_4b69, members_4b6b, localVars_4b6d, contexts_4b6f, unaryExprss_4b71);
}

void AddStructTriggerVars_4aff::callRisingEdge_4eac( const Packets_t& argDeclBases_4bb7, const Packets_t& members_4bb9, const Packets_t& localVars_4bbb, const Packets_t& contexts_4bbd, const Packets_t& unaryExprss_4bbf)
{
	RisingEdge_4bb6 risingEdge_4bb6;
	risingEdge_4bb6( argDeclBases_4bb7, members_4bb9, localVars_4bbb, contexts_4bbd, unaryExprss_4bbf);
}

void AddStructTriggerVars_4aff::callFallingEdge_4eb2( const Packets_t& argDeclBases_4b69, const Packets_t& members_4b6b, const Packets_t& localVars_4b6d, const Packets_t& contexts_4b6f, const Packets_t& unaryExprss_4b71)
{
	FallingEdge_4b68 fallingEdge_4b68;
	fallingEdge_4b68( argDeclBases_4b69, members_4b6b, localVars_4b6d, contexts_4b6f, unaryExprss_4b71);
}

void AddStructTriggerVars_4aff::callRisingEdge_4eb8( const Packets_t& argDeclBases_4bb7, const Packets_t& members_4bb9, const Packets_t& localVars_4bbb, const Packets_t& contexts_4bbd, const Packets_t& unaryExprss_4bbf)
{
	RisingEdge_4bb6 risingEdge_4bb6;
	risingEdge_4bb6( argDeclBases_4bb7, members_4bb9, localVars_4bbb, contexts_4bbd, unaryExprss_4bbf);
}

void EitherEdge_4b0c::operator()( const Packets_t& argDeclBases_4b0d, const Packets_t& members_4b10, const Packets_t& localVars_4b13, const Packets_t& contexts_4b16, const Packets_t& unaryExprss_4b19, Packets_t& argDeclBases_4b0f, Packets_t& members_4b12, Packets_t& localVars_4b15, Packets_t& contexts_4b18, Packets_t& leftUnaryExprss_4b1b, Packets_t& rightUnaryExprss_4b1c)
{
#ifdef PRINT_INFO
	printLog( "EitherEdge_4b0c" );
#endif
	RTTGenerator::Instance()->generateRule(4308, "EitherEdge");
	_argDeclBase_4b1d= &argDeclBases_4b0f;
	_member_4b1e= &members_4b12;
	_localVar_4b1f= &localVars_4b15;
	_context_4b20= &contexts_4b18;
	_leftUnaryExprs_4b21= &leftUnaryExprss_4b1b;
	_rightUnaryExprs_4b22= &rightUnaryExprss_4b1c;
	processInputPackets( argDeclBases_4b0d, members_4b10, localVars_4b13, contexts_4b16, unaryExprss_4b19);
}

bool EitherEdge_4b0c::isInputUnique( const Udm::Object& argDeclBase_4b27, const Udm::Object& member_4b30, const Udm::Object& localVar_4b39, const Udm::Object& context_4b42, const Udm::Object& unaryExprs_4b4b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_4b29= _argDeclBase_4b23.begin(), itMember_4b32= _member_4b2c.begin(), itLocalVar_4b3b= _localVar_4b35.begin(), itContext_4b44= _context_4b3e.begin(), itUnaryExprs_4b4d= _unaryExprs_4b47.begin(); itArgDeclBase_4b29!= _argDeclBase_4b23.end(), itMember_4b32!= _member_4b2c.end(), itLocalVar_4b3b!= _localVar_4b35.end(), itContext_4b44!= _context_4b3e.end(), itUnaryExprs_4b4d!= _unaryExprs_4b47.end(); ++itArgDeclBase_4b29, ++itMember_4b32, ++itLocalVar_4b3b, ++itContext_4b44, ++itUnaryExprs_4b4d)
	{
		if( ( *itArgDeclBase_4b29== argDeclBase_4b27)&& ( *itMember_4b32== member_4b30)&& ( *itLocalVar_4b3b== localVar_4b39)&& ( *itContext_4b44== context_4b42)&& ( *itUnaryExprs_4b4d== unaryExprs_4b4b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_4b23.push_back( argDeclBase_4b27);
		_member_4b2c.push_back( member_4b30);
		_localVar_4b35.push_back( localVar_4b39);
		_context_4b3e.push_back( context_4b42);
		_unaryExprs_4b47.push_back( unaryExprs_4b4b);
	}
	return isUnique;
}

bool EitherEdge_4b0c::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void EitherEdge_4b0c::processInputPackets( const Packets_t& argDeclBases_4b0d, const Packets_t& members_4b10, const Packets_t& localVars_4b13, const Packets_t& contexts_4b16, const Packets_t& unaryExprss_4b19)
{
	for( Packets_t::const_iterator itArgDeclBase_4b24= argDeclBases_4b0d.begin(), itMember_4b2d= members_4b10.begin(), itLocalVar_4b36= localVars_4b13.begin(), itContext_4b3f= contexts_4b16.begin(), itUnaryExprs_4b48= unaryExprss_4b19.begin(); itArgDeclBase_4b24!= argDeclBases_4b0d.end(), itMember_4b2d!= members_4b10.end(), itLocalVar_4b36!= localVars_4b13.end(), itContext_4b3f!= contexts_4b16.end(), itUnaryExprs_4b48!= unaryExprss_4b19.end(); ++itArgDeclBase_4b24, ++itMember_4b2d, ++itLocalVar_4b36, ++itContext_4b3f, ++itUnaryExprs_4b48)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_4b24, *itMember_4b2d, *itLocalVar_4b36, *itContext_4b3f, *itUnaryExprs_4b48);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_4b24, *itMember_4b2d, *itLocalVar_4b36, *itContext_4b3f, *itUnaryExprs_4b48);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool EitherEdge_4b0c::patternMatcher( const Udm::Object& argDeclBase_4b25, const Udm::Object& member_4b2e, const Udm::Object& localVar_4b37, const Udm::Object& context_4b40, const Udm::Object& unaryExprs_4b49)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_4b25.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_4b2a= SFC::ArgDeclBase::Cast( argDeclBase_4b25);
		if( false== Uml::IsDerivedFrom( member_4b2e.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_4b33= SFC::LocalVar::Cast( member_4b2e);
		if( false== Uml::IsDerivedFrom( localVar_4b37.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_4b3c= SFC::LocalVar::Cast( localVar_4b37);
		if( false== Uml::IsDerivedFrom( context_4b40.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_4b45= SFC::Arg::Cast( context_4b40);
		if( false== Uml::IsDerivedFrom( unaryExprs_4b49.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_4b4e= SFC::UnaryExprs::Cast( unaryExprs_4b49);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4b53;
		if( !isValidBound(boundObjs_4b53, argDeclBase_4b2a, true))
			continue;
		currMatch.argDeclBase_4b54= argDeclBase_4b2a;
		if( !isValidBound(boundObjs_4b53, member_4b33, true))
			continue;
		currMatch.member_4b55= member_4b33;
		if( !isValidBound(boundObjs_4b53, localVar_4b3c, true))
			continue;
		currMatch.localVar_4b56= localVar_4b3c;
		if( !isValidBound(boundObjs_4b53, context_4b45, true))
			continue;
		currMatch.context_4b57= context_4b45;
		if( !isValidBound(boundObjs_4b53, unaryExprs_4b4e, true))
			continue;
		currMatch.unaryExprs_4b58= unaryExprs_4b4e;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void EitherEdge_4b0c::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newOr_4b59= SFC::BinaryExprs::Create( currMatch.unaryExprs_4b58, SFC::UnaryExprs::meta_subexpr);
		SFC::UnaryExprs newRightUnaryExprs_4b5a= SFC::UnaryExprs::Create( newOr_4b59, SFC::BinaryExprs::meta_rightexpr);
		SFC::UnaryExprs newLeftUnaryExprs_4b5b= SFC::UnaryExprs::Create( newOr_4b59, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_4b54;
		SFC::Arg& Context= currMatch.context_4b57;
		SFC::UnaryExprs& LeftUnaryExprs= newLeftUnaryExprs_4b5b;
		SFC::LocalVar& LocalVar= currMatch.localVar_4b56;
		SFC::LocalVar& Member= currMatch.member_4b55;
		SFC::BinaryExprs& Or= newOr_4b59;
		SFC::UnaryExprs& RightUnaryExprs= newRightUnaryExprs_4b5a;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_4b58;
		{
Or.op() = "||";
};
		{
RightUnaryExprs.op() = "";
};
		{
LeftUnaryExprs.op() = "";
};
		outputAppender( currMatch.argDeclBase_4b54, currMatch.member_4b55, currMatch.localVar_4b56, currMatch.context_4b57, newLeftUnaryExprs_4b5b, newRightUnaryExprs_4b5a);
	}
}

void EitherEdge_4b0c::outputAppender( const SFC::ArgDeclBase& argDeclBase_4b5c, const SFC::LocalVar& member_4b5e, const SFC::LocalVar& localVar_4b60, const SFC::Arg& context_4b62, const SFC::UnaryExprs& leftUnaryExprs_4b64, const SFC::UnaryExprs& rightUnaryExprs_4b66)
{
	_argDeclBase_4b1d->push_back( argDeclBase_4b5c);
	_member_4b1e->push_back( member_4b5e);
	_localVar_4b1f->push_back( localVar_4b60);
	_context_4b20->push_back( context_4b62);
	_leftUnaryExprs_4b21->push_back( leftUnaryExprs_4b64);
	_rightUnaryExprs_4b22->push_back( rightUnaryExprs_4b66);
}

void FallingEdge_4b68::operator()( const Packets_t& argDeclBases_4b69, const Packets_t& members_4b6b, const Packets_t& localVars_4b6d, const Packets_t& contexts_4b6f, const Packets_t& unaryExprss_4b71)
{
#ifdef PRINT_INFO
	printLog( "FallingEdge_4b68" );
#endif
	RTTGenerator::Instance()->generateRule(4323, "FallingEdge");
	processInputPackets( argDeclBases_4b69, members_4b6b, localVars_4b6d, contexts_4b6f, unaryExprss_4b71);
}

bool FallingEdge_4b68::isInputUnique( const Udm::Object& argDeclBase_4b77, const Udm::Object& member_4b80, const Udm::Object& localVar_4b89, const Udm::Object& context_4b92, const Udm::Object& unaryExprs_4b9b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_4b79= _argDeclBase_4b73.begin(), itMember_4b82= _member_4b7c.begin(), itLocalVar_4b8b= _localVar_4b85.begin(), itContext_4b94= _context_4b8e.begin(), itUnaryExprs_4b9d= _unaryExprs_4b97.begin(); itArgDeclBase_4b79!= _argDeclBase_4b73.end(), itMember_4b82!= _member_4b7c.end(), itLocalVar_4b8b!= _localVar_4b85.end(), itContext_4b94!= _context_4b8e.end(), itUnaryExprs_4b9d!= _unaryExprs_4b97.end(); ++itArgDeclBase_4b79, ++itMember_4b82, ++itLocalVar_4b8b, ++itContext_4b94, ++itUnaryExprs_4b9d)
	{
		if( ( *itArgDeclBase_4b79== argDeclBase_4b77)&& ( *itMember_4b82== member_4b80)&& ( *itLocalVar_4b8b== localVar_4b89)&& ( *itContext_4b94== context_4b92)&& ( *itUnaryExprs_4b9d== unaryExprs_4b9b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_4b73.push_back( argDeclBase_4b77);
		_member_4b7c.push_back( member_4b80);
		_localVar_4b85.push_back( localVar_4b89);
		_context_4b8e.push_back( context_4b92);
		_unaryExprs_4b97.push_back( unaryExprs_4b9b);
	}
	return isUnique;
}

bool FallingEdge_4b68::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void FallingEdge_4b68::processInputPackets( const Packets_t& argDeclBases_4b69, const Packets_t& members_4b6b, const Packets_t& localVars_4b6d, const Packets_t& contexts_4b6f, const Packets_t& unaryExprss_4b71)
{
	for( Packets_t::const_iterator itArgDeclBase_4b74= argDeclBases_4b69.begin(), itMember_4b7d= members_4b6b.begin(), itLocalVar_4b86= localVars_4b6d.begin(), itContext_4b8f= contexts_4b6f.begin(), itUnaryExprs_4b98= unaryExprss_4b71.begin(); itArgDeclBase_4b74!= argDeclBases_4b69.end(), itMember_4b7d!= members_4b6b.end(), itLocalVar_4b86!= localVars_4b6d.end(), itContext_4b8f!= contexts_4b6f.end(), itUnaryExprs_4b98!= unaryExprss_4b71.end(); ++itArgDeclBase_4b74, ++itMember_4b7d, ++itLocalVar_4b86, ++itContext_4b8f, ++itUnaryExprs_4b98)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_4b74, *itMember_4b7d, *itLocalVar_4b86, *itContext_4b8f, *itUnaryExprs_4b98);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_4b74, *itMember_4b7d, *itLocalVar_4b86, *itContext_4b8f, *itUnaryExprs_4b98);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool FallingEdge_4b68::patternMatcher( const Udm::Object& argDeclBase_4b75, const Udm::Object& member_4b7e, const Udm::Object& localVar_4b87, const Udm::Object& context_4b90, const Udm::Object& unaryExprs_4b99)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_4b75.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_4b7a= SFC::ArgDeclBase::Cast( argDeclBase_4b75);
		if( false== Uml::IsDerivedFrom( member_4b7e.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_4b83= SFC::LocalVar::Cast( member_4b7e);
		if( false== Uml::IsDerivedFrom( localVar_4b87.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_4b8c= SFC::LocalVar::Cast( localVar_4b87);
		if( false== Uml::IsDerivedFrom( context_4b90.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_4b95= SFC::Arg::Cast( context_4b90);
		if( false== Uml::IsDerivedFrom( unaryExprs_4b99.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_4b9e= SFC::UnaryExprs::Cast( unaryExprs_4b99);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4ba3;
		if( !isValidBound(boundObjs_4ba3, argDeclBase_4b7a, true))
			continue;
		currMatch.argDeclBase_4ba4= argDeclBase_4b7a;
		if( !isValidBound(boundObjs_4ba3, member_4b83, true))
			continue;
		currMatch.member_4ba5= member_4b83;
		if( !isValidBound(boundObjs_4ba3, localVar_4b8c, true))
			continue;
		currMatch.localVar_4ba6= localVar_4b8c;
		if( !isValidBound(boundObjs_4ba3, context_4b95, true))
			continue;
		currMatch.context_4ba7= context_4b95;
		if( !isValidBound(boundObjs_4ba3, unaryExprs_4b9e, true))
			continue;
		currMatch.unaryExprs_4ba8= unaryExprs_4b9e;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void FallingEdge_4b68::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newAnd_4ba9= SFC::BinaryExprs::Create( currMatch.unaryExprs_4ba8, SFC::UnaryExprs::meta_subexpr);
		SFC::BinaryExprs newGreaterThan_4baa= SFC::BinaryExprs::Create( newAnd_4ba9, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newMemberDot_4bab= SFC::BinaryExprs::Create( newGreaterThan_4baa, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newMemberRef2_4bac= SFC::ArgDeclRef::Create( newMemberDot_4bab, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newDot_4bad= SFC::BinaryExprs::Create( newMemberDot_4bab, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newLessThan_4bae= SFC::BinaryExprs::Create( newAnd_4ba9, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newArgDeclDot_4baf= SFC::BinaryExprs::Create( newLessThan_4bae, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef_4bb0= SFC::ArgDeclRef::Create( newArgDeclDot_4baf, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newMemberRef_4bb1= SFC::ArgDeclRef::Create( newArgDeclDot_4baf, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef2_4bb2= SFC::ArgDeclRef::Create( newDot_4bad, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newZero2_4bb3= SFC::Int::Create( newLessThan_4bae, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newZero_4bb4= SFC::Int::Create( newGreaterThan_4baa, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef3_4bb5= SFC::ArgDeclRef::Create( newDot_4bad, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs& And= newAnd_4ba9;
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_4ba4;
		SFC::BinaryExprs& ArgDeclDot= newArgDeclDot_4baf;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_4bb0;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_4bb2;
		SFC::ArgDeclRef& ArgDeclRef3= newArgDeclRef3_4bb5;
		SFC::Arg& Context= currMatch.context_4ba7;
		SFC::BinaryExprs& Dot= newDot_4bad;
		SFC::BinaryExprs& GreaterThan= newGreaterThan_4baa;
		SFC::BinaryExprs& LessThan= newLessThan_4bae;
		SFC::LocalVar& LocalVar= currMatch.localVar_4ba6;
		SFC::LocalVar& Member= currMatch.member_4ba5;
		SFC::BinaryExprs& MemberDot= newMemberDot_4bab;
		SFC::ArgDeclRef& MemberRef= newMemberRef_4bb1;
		SFC::ArgDeclRef& MemberRef2= newMemberRef2_4bac;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_4ba8;
		SFC::Int& Zero= newZero_4bb4;
		SFC::Int& Zero2= newZero2_4bb3;
		{
MemberDot.op() = ".";
};
		{
ArgDeclDot.op() = ".";
};
		{
Zero2.val() = 0;
};
		{
Zero.val() = 0;
};
		{
Dot.op() = ".";
};
		{
GreaterThan.op() = ">=";
};
		{
And.op() = "&&";
};
		{
LessThan.op() = "<";
};
		newMemberRef_4bb1.argdecl()= currMatch.member_4ba5;
		newMemberRef2_4bac.argdecl()= currMatch.member_4ba5;
		newArgDeclRef3_4bb5.argdecl()= currMatch.context_4ba7;
		newArgDeclRef_4bb0.argdecl()= currMatch.argDeclBase_4ba4;
		newArgDeclRef2_4bb2.argdecl()= currMatch.localVar_4ba6;
	}
}

void RisingEdge_4bb6::operator()( const Packets_t& argDeclBases_4bb7, const Packets_t& members_4bb9, const Packets_t& localVars_4bbb, const Packets_t& contexts_4bbd, const Packets_t& unaryExprss_4bbf)
{
#ifdef PRINT_INFO
	printLog( "RisingEdge_4bb6" );
#endif
	RTTGenerator::Instance()->generateRule(4368, "RisingEdge");
	processInputPackets( argDeclBases_4bb7, members_4bb9, localVars_4bbb, contexts_4bbd, unaryExprss_4bbf);
}

bool RisingEdge_4bb6::isInputUnique( const Udm::Object& argDeclBase_4bc5, const Udm::Object& member_4bce, const Udm::Object& localVar_4bd7, const Udm::Object& context_4be0, const Udm::Object& unaryExprs_4be9)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_4bc7= _argDeclBase_4bc1.begin(), itMember_4bd0= _member_4bca.begin(), itLocalVar_4bd9= _localVar_4bd3.begin(), itContext_4be2= _context_4bdc.begin(), itUnaryExprs_4beb= _unaryExprs_4be5.begin(); itArgDeclBase_4bc7!= _argDeclBase_4bc1.end(), itMember_4bd0!= _member_4bca.end(), itLocalVar_4bd9!= _localVar_4bd3.end(), itContext_4be2!= _context_4bdc.end(), itUnaryExprs_4beb!= _unaryExprs_4be5.end(); ++itArgDeclBase_4bc7, ++itMember_4bd0, ++itLocalVar_4bd9, ++itContext_4be2, ++itUnaryExprs_4beb)
	{
		if( ( *itArgDeclBase_4bc7== argDeclBase_4bc5)&& ( *itMember_4bd0== member_4bce)&& ( *itLocalVar_4bd9== localVar_4bd7)&& ( *itContext_4be2== context_4be0)&& ( *itUnaryExprs_4beb== unaryExprs_4be9))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_4bc1.push_back( argDeclBase_4bc5);
		_member_4bca.push_back( member_4bce);
		_localVar_4bd3.push_back( localVar_4bd7);
		_context_4bdc.push_back( context_4be0);
		_unaryExprs_4be5.push_back( unaryExprs_4be9);
	}
	return isUnique;
}

bool RisingEdge_4bb6::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void RisingEdge_4bb6::processInputPackets( const Packets_t& argDeclBases_4bb7, const Packets_t& members_4bb9, const Packets_t& localVars_4bbb, const Packets_t& contexts_4bbd, const Packets_t& unaryExprss_4bbf)
{
	for( Packets_t::const_iterator itArgDeclBase_4bc2= argDeclBases_4bb7.begin(), itMember_4bcb= members_4bb9.begin(), itLocalVar_4bd4= localVars_4bbb.begin(), itContext_4bdd= contexts_4bbd.begin(), itUnaryExprs_4be6= unaryExprss_4bbf.begin(); itArgDeclBase_4bc2!= argDeclBases_4bb7.end(), itMember_4bcb!= members_4bb9.end(), itLocalVar_4bd4!= localVars_4bbb.end(), itContext_4bdd!= contexts_4bbd.end(), itUnaryExprs_4be6!= unaryExprss_4bbf.end(); ++itArgDeclBase_4bc2, ++itMember_4bcb, ++itLocalVar_4bd4, ++itContext_4bdd, ++itUnaryExprs_4be6)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_4bc2, *itMember_4bcb, *itLocalVar_4bd4, *itContext_4bdd, *itUnaryExprs_4be6);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_4bc2, *itMember_4bcb, *itLocalVar_4bd4, *itContext_4bdd, *itUnaryExprs_4be6);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool RisingEdge_4bb6::patternMatcher( const Udm::Object& argDeclBase_4bc3, const Udm::Object& member_4bcc, const Udm::Object& localVar_4bd5, const Udm::Object& context_4bde, const Udm::Object& unaryExprs_4be7)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_4bc3.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_4bc8= SFC::ArgDeclBase::Cast( argDeclBase_4bc3);
		if( false== Uml::IsDerivedFrom( member_4bcc.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_4bd1= SFC::LocalVar::Cast( member_4bcc);
		if( false== Uml::IsDerivedFrom( localVar_4bd5.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_4bda= SFC::LocalVar::Cast( localVar_4bd5);
		if( false== Uml::IsDerivedFrom( context_4bde.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_4be3= SFC::Arg::Cast( context_4bde);
		if( false== Uml::IsDerivedFrom( unaryExprs_4be7.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_4bec= SFC::UnaryExprs::Cast( unaryExprs_4be7);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4bf1;
		if( !isValidBound(boundObjs_4bf1, argDeclBase_4bc8, true))
			continue;
		currMatch.argDeclBase_4bf2= argDeclBase_4bc8;
		if( !isValidBound(boundObjs_4bf1, member_4bd1, true))
			continue;
		currMatch.member_4bf3= member_4bd1;
		if( !isValidBound(boundObjs_4bf1, localVar_4bda, true))
			continue;
		currMatch.localVar_4bf4= localVar_4bda;
		if( !isValidBound(boundObjs_4bf1, context_4be3, true))
			continue;
		currMatch.context_4bf5= context_4be3;
		if( !isValidBound(boundObjs_4bf1, unaryExprs_4bec, true))
			continue;
		currMatch.unaryExprs_4bf6= unaryExprs_4bec;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void RisingEdge_4bb6::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newAnd_4bf7= SFC::BinaryExprs::Create( currMatch.unaryExprs_4bf6, SFC::UnaryExprs::meta_subexpr);
		SFC::BinaryExprs newLessThan_4bf8= SFC::BinaryExprs::Create( newAnd_4bf7, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newMemberDot_4bf9= SFC::BinaryExprs::Create( newLessThan_4bf8, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newDot_4bfa= SFC::BinaryExprs::Create( newMemberDot_4bf9, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newMemberRef2_4bfb= SFC::ArgDeclRef::Create( newMemberDot_4bf9, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newGreaterThan_4bfc= SFC::BinaryExprs::Create( newAnd_4bf7, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newArgDeclDot_4bfd= SFC::BinaryExprs::Create( newGreaterThan_4bfc, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newMemberRef_4bfe= SFC::ArgDeclRef::Create( newArgDeclDot_4bfd, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_4bff= SFC::ArgDeclRef::Create( newArgDeclDot_4bfd, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_4c00= SFC::ArgDeclRef::Create( newDot_4bfa, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newZero2_4c01= SFC::Int::Create( newGreaterThan_4bfc, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newZero_4c02= SFC::Int::Create( newLessThan_4bf8, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef3_4c03= SFC::ArgDeclRef::Create( newDot_4bfa, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs& And= newAnd_4bf7;
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_4bf2;
		SFC::BinaryExprs& ArgDeclDot= newArgDeclDot_4bfd;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_4bff;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_4c00;
		SFC::ArgDeclRef& ArgDeclRef3= newArgDeclRef3_4c03;
		SFC::Arg& Context= currMatch.context_4bf5;
		SFC::BinaryExprs& Dot= newDot_4bfa;
		SFC::BinaryExprs& GreaterThan= newGreaterThan_4bfc;
		SFC::BinaryExprs& LessThan= newLessThan_4bf8;
		SFC::LocalVar& LocalVar= currMatch.localVar_4bf4;
		SFC::LocalVar& Member= currMatch.member_4bf3;
		SFC::BinaryExprs& MemberDot= newMemberDot_4bf9;
		SFC::ArgDeclRef& MemberRef= newMemberRef_4bfe;
		SFC::ArgDeclRef& MemberRef2= newMemberRef2_4bfb;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_4bf6;
		SFC::Int& Zero= newZero_4c02;
		SFC::Int& Zero2= newZero2_4c01;
		{
ArgDeclDot.op() = ".";
};
		{
MemberDot.op() = ".";
};
		{
Zero2.val() = 0;
};
		{
Zero.val() = 0;
};
		{
Dot.op() = ".";
};
		{
GreaterThan.op() = ">";
};
		{
And.op() = "&&";
};
		{
LessThan.op() = "<=";
};
		newMemberRef2_4bfb.argdecl()= currMatch.member_4bf3;
		newMemberRef_4bfe.argdecl()= currMatch.member_4bf3;
		newArgDeclRef3_4c03.argdecl()= currMatch.context_4bf5;
		newArgDeclRef_4bff.argdecl()= currMatch.argDeclBase_4bf2;
		newArgDeclRef2_4c00.argdecl()= currMatch.localVar_4bf4;
	}
}

void EdgeTest_4c04::operator()( const Packets_t& events_4c05, const Packets_t& argdecls_4c07, const Packets_t& members_4c09, const Packets_t& oldvals_4c0b, const Packets_t& contexts_4c0d, const Packets_t& initexprs_4c0f, Packets_t& argdecls_4c11, Packets_t& members_4c12, Packets_t& oldvals_4c13, Packets_t& contexts_4c14, Packets_t& initexprs_4c15, Packets_t& argdecls_4c16, Packets_t& members_4c17, Packets_t& oldvals_4c18, Packets_t& contexts_4c19, Packets_t& initexprs_4c1a, Packets_t& argdecls_4c1b, Packets_t& members_4c1c, Packets_t& oldvals_4c1d, Packets_t& contexts_4c1e, Packets_t& initexprs_4c1f)
{
#ifdef PRINT_INFO
	printLog( "EdgeTest_4c04" );
#endif
	_argdecl_4c20= &argdecls_4c11;
	_member_4c21= &members_4c12;
	_oldval_4c22= &oldvals_4c13;
	_context_4c23= &contexts_4c14;
	_initexpr_4c24= &initexprs_4c15;
	_argdecl_4c25= &argdecls_4c16;
	_member_4c26= &members_4c17;
	_oldval_4c27= &oldvals_4c18;
	_context_4c28= &contexts_4c19;
	_initexpr_4c29= &initexprs_4c1a;
	_argdecl_4c2a= &argdecls_4c1b;
	_member_4c2b= &members_4c1c;
	_oldval_4c2c= &oldvals_4c1d;
	_context_4c2d= &contexts_4c1e;
	_initexpr_4c2e= &initexprs_4c1f;
	for( Packets_t::const_iterator itevent_4c30= events_4c05.begin(), itargdecl_4c37= argdecls_4c07.begin(), itmember_4c3e= members_4c09.begin(), itoldval_4c45= oldvals_4c0b.begin(), itcontext_4c4c= contexts_4c0d.begin(), itinitexpr_4c53= initexprs_4c0f.begin(); itevent_4c30!= events_4c05.end(), itargdecl_4c37!= argdecls_4c07.end(), itmember_4c3e!= members_4c09.end(), itoldval_4c45!= oldvals_4c0b.end(), itcontext_4c4c!= contexts_4c0d.end(), itinitexpr_4c53!= initexprs_4c0f.end(); ++itevent_4c30, ++itargdecl_4c37, ++itmember_4c3e, ++itoldval_4c45, ++itcontext_4c4c, ++itinitexpr_4c53)
	{
		bool isUnique= isInputUnique( *itevent_4c30, *itargdecl_4c37, *itmember_4c3e, *itoldval_4c45, *itcontext_4c4c, *itinitexpr_4c53);
		if( !isUnique)
			continue;
		Packets_t oneevent_4c34( 1, *itevent_4c30);
		Packets_t oneargdecl_4c3b( 1, *itargdecl_4c37);
		Packets_t onemember_4c42( 1, *itmember_4c3e);
		Packets_t oneoldval_4c49( 1, *itoldval_4c45);
		Packets_t onecontext_4c50( 1, *itcontext_4c4c);
		Packets_t oneinitexpr_4c57( 1, *itinitexpr_4c53);
		executeOne( oneevent_4c34, oneargdecl_4c3b, onemember_4c42, oneoldval_4c49, onecontext_4c50, oneinitexpr_4c57);
	}
}

void EdgeTest_4c04::executeOne( const Packets_t& events_4c05, const Packets_t& argdecls_4c07, const Packets_t& members_4c09, const Packets_t& oldvals_4c0b, const Packets_t& contexts_4c0d, const Packets_t& initexprs_4c0f)
{
	Packets_t argDeclBases_4c5e;
	Packets_t members_4c61;
	Packets_t localVars_4c64;
	Packets_t contexts_4c67;
	Packets_t unaryExprss_4c6a;
	RisingEdge_4c59 risingEdge_4c59;
	bool isMatchRisingEdge_4c59= risingEdge_4c59( events_4c05, argdecls_4c07, members_4c09, oldvals_4c0b, contexts_4c0d, initexprs_4c0f, argDeclBases_4c5e, members_4c61, localVars_4c64, contexts_4c67, unaryExprss_4c6a);
	_argdecl_4c20->insert( _argdecl_4c20->end(), argDeclBases_4c5e.begin(), argDeclBases_4c5e.end());
	_member_4c21->insert( _member_4c21->end(), members_4c61.begin(), members_4c61.end());
	_oldval_4c22->insert( _oldval_4c22->end(), localVars_4c64.begin(), localVars_4c64.end());
	_context_4c23->insert( _context_4c23->end(), contexts_4c67.begin(), contexts_4c67.end());
	_initexpr_4c24->insert( _initexpr_4c24->end(), unaryExprss_4c6a.begin(), unaryExprss_4c6a.end());
	if( isMatchRisingEdge_4c59)
		return;
	Packets_t argDeclBases_4cc5;
	Packets_t members_4cc8;
	Packets_t localVars_4ccb;
	Packets_t contexts_4cce;
	Packets_t unaryExprss_4cd1;
	FallingEdge_4cc0 fallingEdge_4cc0;
	bool isMatchFallingEdge_4cc0= fallingEdge_4cc0( events_4c05, argdecls_4c07, members_4c09, oldvals_4c0b, contexts_4c0d, initexprs_4c0f, argDeclBases_4cc5, members_4cc8, localVars_4ccb, contexts_4cce, unaryExprss_4cd1);
	_argdecl_4c25->insert( _argdecl_4c25->end(), argDeclBases_4cc5.begin(), argDeclBases_4cc5.end());
	_member_4c26->insert( _member_4c26->end(), members_4cc8.begin(), members_4cc8.end());
	_oldval_4c27->insert( _oldval_4c27->end(), localVars_4ccb.begin(), localVars_4ccb.end());
	_context_4c28->insert( _context_4c28->end(), contexts_4cce.begin(), contexts_4cce.end());
	_initexpr_4c29->insert( _initexpr_4c29->end(), unaryExprss_4cd1.begin(), unaryExprss_4cd1.end());
	Packets_t argDeclBases_4d2c;
	Packets_t members_4d2f;
	Packets_t localVars_4d32;
	Packets_t contexts_4d35;
	Packets_t unaryExprss_4d38;
	EitherEdge_4d27 eitherEdge_4d27;
	bool isMatchEitherEdge_4d27= eitherEdge_4d27( events_4c05, argdecls_4c07, members_4c09, oldvals_4c0b, contexts_4c0d, initexprs_4c0f, argDeclBases_4d2c, members_4d2f, localVars_4d32, contexts_4d35, unaryExprss_4d38);
	_argdecl_4c2a->insert( _argdecl_4c2a->end(), argDeclBases_4d2c.begin(), argDeclBases_4d2c.end());
	_member_4c2b->insert( _member_4c2b->end(), members_4d2f.begin(), members_4d2f.end());
	_oldval_4c2c->insert( _oldval_4c2c->end(), localVars_4d32.begin(), localVars_4d32.end());
	_context_4c2d->insert( _context_4c2d->end(), contexts_4d35.begin(), contexts_4d35.end());
	_initexpr_4c2e->insert( _initexpr_4c2e->end(), unaryExprss_4d38.begin(), unaryExprss_4d38.end());
}

bool EdgeTest_4c04::isInputUnique( const Udm::Object& event_4c31, const Udm::Object& argdecl_4c38, const Udm::Object& member_4c3f, const Udm::Object& oldval_4c46, const Udm::Object& context_4c4d, const Udm::Object& initexpr_4c54)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itevent_4c33= _event_4c2f.begin(), itargdecl_4c3a= _argdecl_4c36.begin(), itmember_4c41= _member_4c3d.begin(), itoldval_4c48= _oldval_4c44.begin(), itcontext_4c4f= _context_4c4b.begin(), itinitexpr_4c56= _initexpr_4c52.begin(); itevent_4c33!= _event_4c2f.end(), itargdecl_4c3a!= _argdecl_4c36.end(), itmember_4c41!= _member_4c3d.end(), itoldval_4c48!= _oldval_4c44.end(), itcontext_4c4f!= _context_4c4b.end(), itinitexpr_4c56!= _initexpr_4c52.end(); ++itevent_4c33, ++itargdecl_4c3a, ++itmember_4c41, ++itoldval_4c48, ++itcontext_4c4f, ++itinitexpr_4c56)
	{
		if( ( *itevent_4c33== event_4c31)&& ( *itargdecl_4c3a== argdecl_4c38)&& ( *itmember_4c41== member_4c3f)&& ( *itoldval_4c48== oldval_4c46)&& ( *itcontext_4c4f== context_4c4d)&& ( *itinitexpr_4c56== initexpr_4c54))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_event_4c2f.push_back( event_4c31);
		_argdecl_4c36.push_back( argdecl_4c38);
		_member_4c3d.push_back( member_4c3f);
		_oldval_4c44.push_back( oldval_4c46);
		_context_4c4b.push_back( context_4c4d);
		_initexpr_4c52.push_back( initexpr_4c54);
	}
	return isUnique;
}

bool RisingEdge_4c59::operator()( const Packets_t& events_4c5a, const Packets_t& argDeclBases_4c5c, const Packets_t& members_4c5f, const Packets_t& localVars_4c62, const Packets_t& contexts_4c65, const Packets_t& unaryExprss_4c68, Packets_t& argDeclBases_4c5e, Packets_t& members_4c61, Packets_t& localVars_4c64, Packets_t& contexts_4c67, Packets_t& unaryExprss_4c6a)
{
#ifdef PRINT_INFO
	printLog( "RisingEdge_4c59" );
#endif
	_argDeclBase_4c6b= &argDeclBases_4c5e;
	_member_4c6c= &members_4c61;
	_localVar_4c6d= &localVars_4c64;
	_context_4c6e= &contexts_4c67;
	_unaryExprs_4c6f= &unaryExprss_4c6a;
	processInputPackets( events_4c5a, argDeclBases_4c5c, members_4c5f, localVars_4c62, contexts_4c65, unaryExprss_4c68);
	if( false== _matches.empty())
		return true;
	return false;
}

bool RisingEdge_4c59::isInputUnique( const Udm::Object& event_4c74, const Udm::Object& argDeclBase_4c7d, const Udm::Object& member_4c86, const Udm::Object& localVar_4c8f, const Udm::Object& context_4c98, const Udm::Object& unaryExprs_4ca1)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itEvent_4c76= _event_4c70.begin(), itArgDeclBase_4c7f= _argDeclBase_4c79.begin(), itMember_4c88= _member_4c82.begin(), itLocalVar_4c91= _localVar_4c8b.begin(), itContext_4c9a= _context_4c94.begin(), itUnaryExprs_4ca3= _unaryExprs_4c9d.begin(); itEvent_4c76!= _event_4c70.end(), itArgDeclBase_4c7f!= _argDeclBase_4c79.end(), itMember_4c88!= _member_4c82.end(), itLocalVar_4c91!= _localVar_4c8b.end(), itContext_4c9a!= _context_4c94.end(), itUnaryExprs_4ca3!= _unaryExprs_4c9d.end(); ++itEvent_4c76, ++itArgDeclBase_4c7f, ++itMember_4c88, ++itLocalVar_4c91, ++itContext_4c9a, ++itUnaryExprs_4ca3)
	{
		if( ( *itEvent_4c76== event_4c74)&& ( *itArgDeclBase_4c7f== argDeclBase_4c7d)&& ( *itMember_4c88== member_4c86)&& ( *itLocalVar_4c91== localVar_4c8f)&& ( *itContext_4c9a== context_4c98)&& ( *itUnaryExprs_4ca3== unaryExprs_4ca1))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_event_4c70.push_back( event_4c74);
		_argDeclBase_4c79.push_back( argDeclBase_4c7d);
		_member_4c82.push_back( member_4c86);
		_localVar_4c8b.push_back( localVar_4c8f);
		_context_4c94.push_back( context_4c98);
		_unaryExprs_4c9d.push_back( unaryExprs_4ca1);
	}
	return isUnique;
}

bool RisingEdge_4c59::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool RisingEdge_4c59::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, SFC::Arg& Context, CyberComposition::Simulink::Event& Event, SFC::LocalVar& LocalVar, SFC::LocalVar& Member, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	std::string trigger = Event.Trigger();
Gz_guard = trigger == "RISING_EDGE_EVENT";;
	return Gz_guard;
}

void RisingEdge_4c59::processInputPackets( const Packets_t& events_4c5a, const Packets_t& argDeclBases_4c5c, const Packets_t& members_4c5f, const Packets_t& localVars_4c62, const Packets_t& contexts_4c65, const Packets_t& unaryExprss_4c68)
{
	for( Packets_t::const_iterator itEvent_4c71= events_4c5a.begin(), itArgDeclBase_4c7a= argDeclBases_4c5c.begin(), itMember_4c83= members_4c5f.begin(), itLocalVar_4c8c= localVars_4c62.begin(), itContext_4c95= contexts_4c65.begin(), itUnaryExprs_4c9e= unaryExprss_4c68.begin(); itEvent_4c71!= events_4c5a.end(), itArgDeclBase_4c7a!= argDeclBases_4c5c.end(), itMember_4c83!= members_4c5f.end(), itLocalVar_4c8c!= localVars_4c62.end(), itContext_4c95!= contexts_4c65.end(), itUnaryExprs_4c9e!= unaryExprss_4c68.end(); ++itEvent_4c71, ++itArgDeclBase_4c7a, ++itMember_4c83, ++itLocalVar_4c8c, ++itContext_4c95, ++itUnaryExprs_4c9e)
	{
		bool isUnique= isInputUnique( *itEvent_4c71, *itArgDeclBase_4c7a, *itMember_4c83, *itLocalVar_4c8c, *itContext_4c95, *itUnaryExprs_4c9e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itEvent_4c71, *itArgDeclBase_4c7a, *itMember_4c83, *itLocalVar_4c8c, *itContext_4c95, *itUnaryExprs_4c9e);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_4cab, currMatch.member_4cac, currMatch.localVar_4cad, currMatch.context_4cae, currMatch.unaryExprs_4caf);
	}
}

bool RisingEdge_4c59::patternMatcher( const Udm::Object& event_4c72, const Udm::Object& argDeclBase_4c7b, const Udm::Object& member_4c84, const Udm::Object& localVar_4c8d, const Udm::Object& context_4c96, const Udm::Object& unaryExprs_4c9f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( event_4c72.type(), CyberComposition::Simulink::Event::meta))
			continue;
		CyberComposition::Simulink::Event event_4c77= CyberComposition::Simulink::Event::Cast( event_4c72);
		if( false== Uml::IsDerivedFrom( argDeclBase_4c7b.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_4c80= SFC::ArgDeclBase::Cast( argDeclBase_4c7b);
		if( false== Uml::IsDerivedFrom( member_4c84.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_4c89= SFC::LocalVar::Cast( member_4c84);
		if( false== Uml::IsDerivedFrom( localVar_4c8d.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_4c92= SFC::LocalVar::Cast( localVar_4c8d);
		if( false== Uml::IsDerivedFrom( context_4c96.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_4c9b= SFC::Arg::Cast( context_4c96);
		if( false== Uml::IsDerivedFrom( unaryExprs_4c9f.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_4ca4= SFC::UnaryExprs::Cast( unaryExprs_4c9f);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4ca9;
		if( !isValidBound(boundObjs_4ca9, event_4c77, true))
			continue;
		currMatch.event_4caa= event_4c77;
		if( !isValidBound(boundObjs_4ca9, argDeclBase_4c80, true))
			continue;
		currMatch.argDeclBase_4cab= argDeclBase_4c80;
		if( !isValidBound(boundObjs_4ca9, member_4c89, true))
			continue;
		currMatch.member_4cac= member_4c89;
		if( !isValidBound(boundObjs_4ca9, localVar_4c92, true))
			continue;
		currMatch.localVar_4cad= localVar_4c92;
		if( !isValidBound(boundObjs_4ca9, context_4c9b, true))
			continue;
		currMatch.context_4cae= context_4c9b;
		if( !isValidBound(boundObjs_4ca9, unaryExprs_4ca4, true))
			continue;
		currMatch.unaryExprs_4caf= unaryExprs_4ca4;
		bool Gz_guard= isGuardTrue( currMatch.argDeclBase_4cab, currMatch.context_4cae, currMatch.event_4caa, currMatch.localVar_4cad, currMatch.member_4cac, currMatch.unaryExprs_4caf);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void RisingEdge_4c59::outputAppender( const SFC::ArgDeclBase& argDeclBase_4cb6, const SFC::LocalVar& member_4cb8, const SFC::LocalVar& localVar_4cba, const SFC::Arg& context_4cbc, const SFC::UnaryExprs& unaryExprs_4cbe)
{
	_argDeclBase_4c6b->push_back( argDeclBase_4cb6);
	_member_4c6c->push_back( member_4cb8);
	_localVar_4c6d->push_back( localVar_4cba);
	_context_4c6e->push_back( context_4cbc);
	_unaryExprs_4c6f->push_back( unaryExprs_4cbe);
}

bool FallingEdge_4cc0::operator()( const Packets_t& events_4cc1, const Packets_t& argDeclBases_4cc3, const Packets_t& members_4cc6, const Packets_t& localVars_4cc9, const Packets_t& contexts_4ccc, const Packets_t& unaryExprss_4ccf, Packets_t& argDeclBases_4cc5, Packets_t& members_4cc8, Packets_t& localVars_4ccb, Packets_t& contexts_4cce, Packets_t& unaryExprss_4cd1)
{
#ifdef PRINT_INFO
	printLog( "FallingEdge_4cc0" );
#endif
	_argDeclBase_4cd2= &argDeclBases_4cc5;
	_member_4cd3= &members_4cc8;
	_localVar_4cd4= &localVars_4ccb;
	_context_4cd5= &contexts_4cce;
	_unaryExprs_4cd6= &unaryExprss_4cd1;
	processInputPackets( events_4cc1, argDeclBases_4cc3, members_4cc6, localVars_4cc9, contexts_4ccc, unaryExprss_4ccf);
	if( false== _matches.empty())
		return true;
	return false;
}

bool FallingEdge_4cc0::isInputUnique( const Udm::Object& event_4cdb, const Udm::Object& argDeclBase_4ce4, const Udm::Object& member_4ced, const Udm::Object& localVar_4cf6, const Udm::Object& context_4cff, const Udm::Object& unaryExprs_4d08)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itEvent_4cdd= _event_4cd7.begin(), itArgDeclBase_4ce6= _argDeclBase_4ce0.begin(), itMember_4cef= _member_4ce9.begin(), itLocalVar_4cf8= _localVar_4cf2.begin(), itContext_4d01= _context_4cfb.begin(), itUnaryExprs_4d0a= _unaryExprs_4d04.begin(); itEvent_4cdd!= _event_4cd7.end(), itArgDeclBase_4ce6!= _argDeclBase_4ce0.end(), itMember_4cef!= _member_4ce9.end(), itLocalVar_4cf8!= _localVar_4cf2.end(), itContext_4d01!= _context_4cfb.end(), itUnaryExprs_4d0a!= _unaryExprs_4d04.end(); ++itEvent_4cdd, ++itArgDeclBase_4ce6, ++itMember_4cef, ++itLocalVar_4cf8, ++itContext_4d01, ++itUnaryExprs_4d0a)
	{
		if( ( *itEvent_4cdd== event_4cdb)&& ( *itArgDeclBase_4ce6== argDeclBase_4ce4)&& ( *itMember_4cef== member_4ced)&& ( *itLocalVar_4cf8== localVar_4cf6)&& ( *itContext_4d01== context_4cff)&& ( *itUnaryExprs_4d0a== unaryExprs_4d08))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_event_4cd7.push_back( event_4cdb);
		_argDeclBase_4ce0.push_back( argDeclBase_4ce4);
		_member_4ce9.push_back( member_4ced);
		_localVar_4cf2.push_back( localVar_4cf6);
		_context_4cfb.push_back( context_4cff);
		_unaryExprs_4d04.push_back( unaryExprs_4d08);
	}
	return isUnique;
}

bool FallingEdge_4cc0::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool FallingEdge_4cc0::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, SFC::Arg& Context, CyberComposition::Simulink::Event& Event, SFC::LocalVar& LocalVar, SFC::LocalVar& Member, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	std::string trigger = Event.Trigger();
Gz_guard = trigger == "FALLING_EDGE_EVENT";;
	return Gz_guard;
}

void FallingEdge_4cc0::processInputPackets( const Packets_t& events_4cc1, const Packets_t& argDeclBases_4cc3, const Packets_t& members_4cc6, const Packets_t& localVars_4cc9, const Packets_t& contexts_4ccc, const Packets_t& unaryExprss_4ccf)
{
	for( Packets_t::const_iterator itEvent_4cd8= events_4cc1.begin(), itArgDeclBase_4ce1= argDeclBases_4cc3.begin(), itMember_4cea= members_4cc6.begin(), itLocalVar_4cf3= localVars_4cc9.begin(), itContext_4cfc= contexts_4ccc.begin(), itUnaryExprs_4d05= unaryExprss_4ccf.begin(); itEvent_4cd8!= events_4cc1.end(), itArgDeclBase_4ce1!= argDeclBases_4cc3.end(), itMember_4cea!= members_4cc6.end(), itLocalVar_4cf3!= localVars_4cc9.end(), itContext_4cfc!= contexts_4ccc.end(), itUnaryExprs_4d05!= unaryExprss_4ccf.end(); ++itEvent_4cd8, ++itArgDeclBase_4ce1, ++itMember_4cea, ++itLocalVar_4cf3, ++itContext_4cfc, ++itUnaryExprs_4d05)
	{
		bool isUnique= isInputUnique( *itEvent_4cd8, *itArgDeclBase_4ce1, *itMember_4cea, *itLocalVar_4cf3, *itContext_4cfc, *itUnaryExprs_4d05);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itEvent_4cd8, *itArgDeclBase_4ce1, *itMember_4cea, *itLocalVar_4cf3, *itContext_4cfc, *itUnaryExprs_4d05);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_4d12, currMatch.member_4d13, currMatch.localVar_4d14, currMatch.context_4d15, currMatch.unaryExprs_4d16);
	}
}

bool FallingEdge_4cc0::patternMatcher( const Udm::Object& event_4cd9, const Udm::Object& argDeclBase_4ce2, const Udm::Object& member_4ceb, const Udm::Object& localVar_4cf4, const Udm::Object& context_4cfd, const Udm::Object& unaryExprs_4d06)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( event_4cd9.type(), CyberComposition::Simulink::Event::meta))
			continue;
		CyberComposition::Simulink::Event event_4cde= CyberComposition::Simulink::Event::Cast( event_4cd9);
		if( false== Uml::IsDerivedFrom( argDeclBase_4ce2.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_4ce7= SFC::ArgDeclBase::Cast( argDeclBase_4ce2);
		if( false== Uml::IsDerivedFrom( member_4ceb.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_4cf0= SFC::LocalVar::Cast( member_4ceb);
		if( false== Uml::IsDerivedFrom( localVar_4cf4.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_4cf9= SFC::LocalVar::Cast( localVar_4cf4);
		if( false== Uml::IsDerivedFrom( context_4cfd.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_4d02= SFC::Arg::Cast( context_4cfd);
		if( false== Uml::IsDerivedFrom( unaryExprs_4d06.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_4d0b= SFC::UnaryExprs::Cast( unaryExprs_4d06);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4d10;
		if( !isValidBound(boundObjs_4d10, event_4cde, true))
			continue;
		currMatch.event_4d11= event_4cde;
		if( !isValidBound(boundObjs_4d10, argDeclBase_4ce7, true))
			continue;
		currMatch.argDeclBase_4d12= argDeclBase_4ce7;
		if( !isValidBound(boundObjs_4d10, member_4cf0, true))
			continue;
		currMatch.member_4d13= member_4cf0;
		if( !isValidBound(boundObjs_4d10, localVar_4cf9, true))
			continue;
		currMatch.localVar_4d14= localVar_4cf9;
		if( !isValidBound(boundObjs_4d10, context_4d02, true))
			continue;
		currMatch.context_4d15= context_4d02;
		if( !isValidBound(boundObjs_4d10, unaryExprs_4d0b, true))
			continue;
		currMatch.unaryExprs_4d16= unaryExprs_4d0b;
		bool Gz_guard= isGuardTrue( currMatch.argDeclBase_4d12, currMatch.context_4d15, currMatch.event_4d11, currMatch.localVar_4d14, currMatch.member_4d13, currMatch.unaryExprs_4d16);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void FallingEdge_4cc0::outputAppender( const SFC::ArgDeclBase& argDeclBase_4d1d, const SFC::LocalVar& member_4d1f, const SFC::LocalVar& localVar_4d21, const SFC::Arg& context_4d23, const SFC::UnaryExprs& unaryExprs_4d25)
{
	_argDeclBase_4cd2->push_back( argDeclBase_4d1d);
	_member_4cd3->push_back( member_4d1f);
	_localVar_4cd4->push_back( localVar_4d21);
	_context_4cd5->push_back( context_4d23);
	_unaryExprs_4cd6->push_back( unaryExprs_4d25);
}

bool EitherEdge_4d27::operator()( const Packets_t& events_4d28, const Packets_t& argDeclBases_4d2a, const Packets_t& members_4d2d, const Packets_t& localVars_4d30, const Packets_t& contexts_4d33, const Packets_t& unaryExprss_4d36, Packets_t& argDeclBases_4d2c, Packets_t& members_4d2f, Packets_t& localVars_4d32, Packets_t& contexts_4d35, Packets_t& unaryExprss_4d38)
{
#ifdef PRINT_INFO
	printLog( "EitherEdge_4d27" );
#endif
	_argDeclBase_4d39= &argDeclBases_4d2c;
	_member_4d3a= &members_4d2f;
	_localVar_4d3b= &localVars_4d32;
	_context_4d3c= &contexts_4d35;
	_unaryExprs_4d3d= &unaryExprss_4d38;
	processInputPackets( events_4d28, argDeclBases_4d2a, members_4d2d, localVars_4d30, contexts_4d33, unaryExprss_4d36);
	if( false== _matches.empty())
		return true;
	return false;
}

bool EitherEdge_4d27::isInputUnique( const Udm::Object& event_4d42, const Udm::Object& argDeclBase_4d4b, const Udm::Object& member_4d54, const Udm::Object& localVar_4d5d, const Udm::Object& context_4d66, const Udm::Object& unaryExprs_4d6f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itEvent_4d44= _event_4d3e.begin(), itArgDeclBase_4d4d= _argDeclBase_4d47.begin(), itMember_4d56= _member_4d50.begin(), itLocalVar_4d5f= _localVar_4d59.begin(), itContext_4d68= _context_4d62.begin(), itUnaryExprs_4d71= _unaryExprs_4d6b.begin(); itEvent_4d44!= _event_4d3e.end(), itArgDeclBase_4d4d!= _argDeclBase_4d47.end(), itMember_4d56!= _member_4d50.end(), itLocalVar_4d5f!= _localVar_4d59.end(), itContext_4d68!= _context_4d62.end(), itUnaryExprs_4d71!= _unaryExprs_4d6b.end(); ++itEvent_4d44, ++itArgDeclBase_4d4d, ++itMember_4d56, ++itLocalVar_4d5f, ++itContext_4d68, ++itUnaryExprs_4d71)
	{
		if( ( *itEvent_4d44== event_4d42)&& ( *itArgDeclBase_4d4d== argDeclBase_4d4b)&& ( *itMember_4d56== member_4d54)&& ( *itLocalVar_4d5f== localVar_4d5d)&& ( *itContext_4d68== context_4d66)&& ( *itUnaryExprs_4d71== unaryExprs_4d6f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_event_4d3e.push_back( event_4d42);
		_argDeclBase_4d47.push_back( argDeclBase_4d4b);
		_member_4d50.push_back( member_4d54);
		_localVar_4d59.push_back( localVar_4d5d);
		_context_4d62.push_back( context_4d66);
		_unaryExprs_4d6b.push_back( unaryExprs_4d6f);
	}
	return isUnique;
}

bool EitherEdge_4d27::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool EitherEdge_4d27::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, SFC::Arg& Context, CyberComposition::Simulink::Event& Event, SFC::LocalVar& LocalVar, SFC::LocalVar& Member, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	std::string trigger = Event.Trigger();
Gz_guard = trigger == "EITHER_EDGE_EVENT";;
	return Gz_guard;
}

void EitherEdge_4d27::processInputPackets( const Packets_t& events_4d28, const Packets_t& argDeclBases_4d2a, const Packets_t& members_4d2d, const Packets_t& localVars_4d30, const Packets_t& contexts_4d33, const Packets_t& unaryExprss_4d36)
{
	for( Packets_t::const_iterator itEvent_4d3f= events_4d28.begin(), itArgDeclBase_4d48= argDeclBases_4d2a.begin(), itMember_4d51= members_4d2d.begin(), itLocalVar_4d5a= localVars_4d30.begin(), itContext_4d63= contexts_4d33.begin(), itUnaryExprs_4d6c= unaryExprss_4d36.begin(); itEvent_4d3f!= events_4d28.end(), itArgDeclBase_4d48!= argDeclBases_4d2a.end(), itMember_4d51!= members_4d2d.end(), itLocalVar_4d5a!= localVars_4d30.end(), itContext_4d63!= contexts_4d33.end(), itUnaryExprs_4d6c!= unaryExprss_4d36.end(); ++itEvent_4d3f, ++itArgDeclBase_4d48, ++itMember_4d51, ++itLocalVar_4d5a, ++itContext_4d63, ++itUnaryExprs_4d6c)
	{
		bool isUnique= isInputUnique( *itEvent_4d3f, *itArgDeclBase_4d48, *itMember_4d51, *itLocalVar_4d5a, *itContext_4d63, *itUnaryExprs_4d6c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itEvent_4d3f, *itArgDeclBase_4d48, *itMember_4d51, *itLocalVar_4d5a, *itContext_4d63, *itUnaryExprs_4d6c);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_4d79, currMatch.member_4d7a, currMatch.localVar_4d7b, currMatch.context_4d7c, currMatch.unaryExprs_4d7d);
	}
}

bool EitherEdge_4d27::patternMatcher( const Udm::Object& event_4d40, const Udm::Object& argDeclBase_4d49, const Udm::Object& member_4d52, const Udm::Object& localVar_4d5b, const Udm::Object& context_4d64, const Udm::Object& unaryExprs_4d6d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( event_4d40.type(), CyberComposition::Simulink::Event::meta))
			continue;
		CyberComposition::Simulink::Event event_4d45= CyberComposition::Simulink::Event::Cast( event_4d40);
		if( false== Uml::IsDerivedFrom( argDeclBase_4d49.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_4d4e= SFC::ArgDeclBase::Cast( argDeclBase_4d49);
		if( false== Uml::IsDerivedFrom( member_4d52.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar member_4d57= SFC::LocalVar::Cast( member_4d52);
		if( false== Uml::IsDerivedFrom( localVar_4d5b.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_4d60= SFC::LocalVar::Cast( localVar_4d5b);
		if( false== Uml::IsDerivedFrom( context_4d64.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_4d69= SFC::Arg::Cast( context_4d64);
		if( false== Uml::IsDerivedFrom( unaryExprs_4d6d.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_4d72= SFC::UnaryExprs::Cast( unaryExprs_4d6d);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4d77;
		if( !isValidBound(boundObjs_4d77, event_4d45, true))
			continue;
		currMatch.event_4d78= event_4d45;
		if( !isValidBound(boundObjs_4d77, argDeclBase_4d4e, true))
			continue;
		currMatch.argDeclBase_4d79= argDeclBase_4d4e;
		if( !isValidBound(boundObjs_4d77, member_4d57, true))
			continue;
		currMatch.member_4d7a= member_4d57;
		if( !isValidBound(boundObjs_4d77, localVar_4d60, true))
			continue;
		currMatch.localVar_4d7b= localVar_4d60;
		if( !isValidBound(boundObjs_4d77, context_4d69, true))
			continue;
		currMatch.context_4d7c= context_4d69;
		if( !isValidBound(boundObjs_4d77, unaryExprs_4d72, true))
			continue;
		currMatch.unaryExprs_4d7d= unaryExprs_4d72;
		bool Gz_guard= isGuardTrue( currMatch.argDeclBase_4d79, currMatch.context_4d7c, currMatch.event_4d78, currMatch.localVar_4d7b, currMatch.member_4d7a, currMatch.unaryExprs_4d7d);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void EitherEdge_4d27::outputAppender( const SFC::ArgDeclBase& argDeclBase_4d84, const SFC::LocalVar& member_4d86, const SFC::LocalVar& localVar_4d88, const SFC::Arg& context_4d8a, const SFC::UnaryExprs& unaryExprs_4d8c)
{
	_argDeclBase_4d39->push_back( argDeclBase_4d84);
	_member_4d3a->push_back( member_4d86);
	_localVar_4d3b->push_back( localVar_4d88);
	_context_4d3c->push_back( context_4d8a);
	_unaryExprs_4d3d->push_back( unaryExprs_4d8c);
}

void AddTriggerVar_4d8e::operator()( const Packets_t& charts_4d8f, const Packets_t& argDeclBases_4d92, const Packets_t& structs_4d95, const Packets_t& localVars_4d98, const Packets_t& contexts_4d9b, const Packets_t& functions_4d9f, Packets_t& charts_4d91, Packets_t& argDeclBases_4d94, Packets_t& structs_4d97, Packets_t& localVars_4d9a, Packets_t& contexts_4d9d, Packets_t& triggerVars_4d9e, Packets_t& functions_4da1)
{
#ifdef PRINT_INFO
	printLog( "AddTriggerVar_4d8e" );
#endif
	RTTGenerator::Instance()->generateRule(4456, "AddTriggerVar");
	_chart_4da2= &charts_4d91;
	_argDeclBase_4da3= &argDeclBases_4d94;
	_struct_4da4= &structs_4d97;
	_localVar_4da5= &localVars_4d9a;
	_context_4da6= &contexts_4d9d;
	_triggerVar_4da7= &triggerVars_4d9e;
	_function_4da8= &functions_4da1;
	processInputPackets( charts_4d8f, argDeclBases_4d92, structs_4d95, localVars_4d98, contexts_4d9b, functions_4d9f);
}

bool AddTriggerVar_4d8e::isInputUnique( const Udm::Object& chart_4dad, const Udm::Object& argDeclBase_4db6, const Udm::Object& struct_4dbf, const Udm::Object& localVar_4dc8, const Udm::Object& context_4dd1, const Udm::Object& function_4dda)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itChart_4daf= _chart_4da9.begin(), itArgDeclBase_4db8= _argDeclBase_4db2.begin(), itStruct_4dc1= _struct_4dbb.begin(), itLocalVar_4dca= _localVar_4dc4.begin(), itContext_4dd3= _context_4dcd.begin(), itFunction_4ddc= _function_4dd6.begin(); itChart_4daf!= _chart_4da9.end(), itArgDeclBase_4db8!= _argDeclBase_4db2.end(), itStruct_4dc1!= _struct_4dbb.end(), itLocalVar_4dca!= _localVar_4dc4.end(), itContext_4dd3!= _context_4dcd.end(), itFunction_4ddc!= _function_4dd6.end(); ++itChart_4daf, ++itArgDeclBase_4db8, ++itStruct_4dc1, ++itLocalVar_4dca, ++itContext_4dd3, ++itFunction_4ddc)
	{
		if( ( *itChart_4daf== chart_4dad)&& ( *itArgDeclBase_4db8== argDeclBase_4db6)&& ( *itStruct_4dc1== struct_4dbf)&& ( *itLocalVar_4dca== localVar_4dc8)&& ( *itContext_4dd3== context_4dd1)&& ( *itFunction_4ddc== function_4dda))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_chart_4da9.push_back( chart_4dad);
		_argDeclBase_4db2.push_back( argDeclBase_4db6);
		_struct_4dbb.push_back( struct_4dbf);
		_localVar_4dc4.push_back( localVar_4dc8);
		_context_4dcd.push_back( context_4dd1);
		_function_4dd6.push_back( function_4dda);
	}
	return isUnique;
}

bool AddTriggerVar_4d8e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void AddTriggerVar_4d8e::processInputPackets( const Packets_t& charts_4d8f, const Packets_t& argDeclBases_4d92, const Packets_t& structs_4d95, const Packets_t& localVars_4d98, const Packets_t& contexts_4d9b, const Packets_t& functions_4d9f)
{
	for( Packets_t::const_iterator itChart_4daa= charts_4d8f.begin(), itArgDeclBase_4db3= argDeclBases_4d92.begin(), itStruct_4dbc= structs_4d95.begin(), itLocalVar_4dc5= localVars_4d98.begin(), itContext_4dce= contexts_4d9b.begin(), itFunction_4dd7= functions_4d9f.begin(); itChart_4daa!= charts_4d8f.end(), itArgDeclBase_4db3!= argDeclBases_4d92.end(), itStruct_4dbc!= structs_4d95.end(), itLocalVar_4dc5!= localVars_4d98.end(), itContext_4dce!= contexts_4d9b.end(), itFunction_4dd7!= functions_4d9f.end(); ++itChart_4daa, ++itArgDeclBase_4db3, ++itStruct_4dbc, ++itLocalVar_4dc5, ++itContext_4dce, ++itFunction_4dd7)
	{
		bool isUnique= isInputUnique( *itChart_4daa, *itArgDeclBase_4db3, *itStruct_4dbc, *itLocalVar_4dc5, *itContext_4dce, *itFunction_4dd7);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itChart_4daa, *itArgDeclBase_4db3, *itStruct_4dbc, *itLocalVar_4dc5, *itContext_4dce, *itFunction_4dd7);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AddTriggerVar_4d8e::patternMatcher( const Udm::Object& chart_4dab, const Udm::Object& argDeclBase_4db4, const Udm::Object& struct_4dbd, const Udm::Object& localVar_4dc6, const Udm::Object& context_4dcf, const Udm::Object& function_4dd8)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( chart_4dab.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem chart_4db0= CyberComposition::Simulink::Subsystem::Cast( chart_4dab);
		if( false== Uml::IsDerivedFrom( argDeclBase_4db4.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_4db9= SFC::ArgDeclBase::Cast( argDeclBase_4db4);
		if( false== Uml::IsDerivedFrom( struct_4dbd.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_4dc2= SFC::Struct::Cast( struct_4dbd);
		if( false== Uml::IsDerivedFrom( localVar_4dc6.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_4dcb= SFC::LocalVar::Cast( localVar_4dc6);
		if( false== Uml::IsDerivedFrom( context_4dcf.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_4dd4= SFC::Arg::Cast( context_4dcf);
		if( false== Uml::IsDerivedFrom( function_4dd8.type(), SFC::Function::meta))
			continue;
		SFC::Function function_4ddd= SFC::Function::Cast( function_4dd8);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4de2;
		if( !isValidBound(boundObjs_4de2, chart_4db0, true))
			continue;
		currMatch.chart_4de3= chart_4db0;
		if( !isValidBound(boundObjs_4de2, argDeclBase_4db9, true))
			continue;
		currMatch.argDeclBase_4de4= argDeclBase_4db9;
		if( !isValidBound(boundObjs_4de2, struct_4dc2, true))
			continue;
		currMatch.struct_4de5= struct_4dc2;
		if( !isValidBound(boundObjs_4de2, localVar_4dcb, true))
			continue;
		currMatch.localVar_4de6= localVar_4dcb;
		if( !isValidBound(boundObjs_4de2, context_4dd4, true))
			continue;
		currMatch.context_4de7= context_4dd4;
		if( !isValidBound(boundObjs_4de2, function_4ddd, true))
			continue;
		currMatch.function_4de8= function_4ddd;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void AddTriggerVar_4d8e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newTriggerVar_4de9= SFC::LocalVar::Create( currMatch.function_4de8, SFC::Function::meta_stmnt);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_4de4;
		CyberComposition::Simulink::Subsystem& Chart= currMatch.chart_4de3;
		SFC::Arg& Context= currMatch.context_4de7;
		SFC::Function& Function= currMatch.function_4de8;
		SFC::LocalVar& LocalVar= currMatch.localVar_4de6;
		SFC::Struct& Struct= currMatch.struct_4de5;
		SFC::LocalVar& TriggerVar= newTriggerVar_4de9;
		{
TriggerVar.type() = "int";
TriggerVar.name() = std::string( "event" ) + boost::lexical_cast< std::string >( TriggerVar.uniqueId() );
};
		{
__int64 statementCount = Function.statementCount();
TriggerVar.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		newTriggerVar_4de9.dt()= currMatch.struct_4de5;
		currMatch.localVar_4de6.trigvar()= newTriggerVar_4de9;
		outputAppender( currMatch.chart_4de3, currMatch.argDeclBase_4de4, currMatch.struct_4de5, currMatch.localVar_4de6, currMatch.context_4de7, newTriggerVar_4de9, currMatch.function_4de8);
	}
}

void AddTriggerVar_4d8e::outputAppender( const CyberComposition::Simulink::Subsystem& chart_4dea, const SFC::ArgDeclBase& argDeclBase_4dec, const SFC::Struct& struct_4dee, const SFC::LocalVar& localVar_4df0, const SFC::Arg& context_4df2, const SFC::LocalVar& triggerVar_4df4, const SFC::Function& function_4df6)
{
	_chart_4da2->push_back( chart_4dea);
	_argDeclBase_4da3->push_back( argDeclBase_4dec);
	_struct_4da4->push_back( struct_4dee);
	_localVar_4da5->push_back( localVar_4df0);
	_context_4da6->push_back( context_4df2);
	_triggerVar_4da7->push_back( triggerVar_4df4);
	_function_4da8->push_back( function_4df6);
}

void StartAssignment_4df8::operator()( const Packets_t& charts_4dfa, const Packets_t& argDeclBases_4dfc, const Packets_t& structs_4e00, const Packets_t& oldvals_4e02, const Packets_t& contexts_4e05, const Packets_t& triggerVars_4e08, const Packets_t& functions_4e0a, Packets_t& events_4df9, Packets_t& argDeclBases_4dfe, Packets_t& localVars_4dff, Packets_t& oldvals_4e04, Packets_t& contexts_4e07, Packets_t& unaryExprss_4e0c)
{
#ifdef PRINT_INFO
	printLog( "StartAssignment_4df8" );
#endif
	RTTGenerator::Instance()->generateRule(4469, "StartAssignment");
	_event_4e0d= &events_4df9;
	_argDeclBase_4e0e= &argDeclBases_4dfe;
	_localVar_4e0f= &localVars_4dff;
	_oldval_4e10= &oldvals_4e04;
	_context_4e11= &contexts_4e07;
	_unaryExprs_4e12= &unaryExprss_4e0c;
	processInputPackets( charts_4dfa, argDeclBases_4dfc, structs_4e00, oldvals_4e02, contexts_4e05, triggerVars_4e08, functions_4e0a);
}

bool StartAssignment_4df8::isInputUnique( const Udm::Object& chart_4e17, const Udm::Object& argDeclBase_4e20, const Udm::Object& struct_4e29, const Udm::Object& oldval_4e32, const Udm::Object& context_4e3b, const Udm::Object& triggerVar_4e44, const Udm::Object& function_4e4d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itChart_4e19= _chart_4e13.begin(), itArgDeclBase_4e22= _argDeclBase_4e1c.begin(), itStruct_4e2b= _struct_4e25.begin(), itoldval_4e34= _oldval_4e2e.begin(), itContext_4e3d= _context_4e37.begin(), itTriggerVar_4e46= _triggerVar_4e40.begin(), itFunction_4e4f= _function_4e49.begin(); itChart_4e19!= _chart_4e13.end(), itArgDeclBase_4e22!= _argDeclBase_4e1c.end(), itStruct_4e2b!= _struct_4e25.end(), itoldval_4e34!= _oldval_4e2e.end(), itContext_4e3d!= _context_4e37.end(), itTriggerVar_4e46!= _triggerVar_4e40.end(), itFunction_4e4f!= _function_4e49.end(); ++itChart_4e19, ++itArgDeclBase_4e22, ++itStruct_4e2b, ++itoldval_4e34, ++itContext_4e3d, ++itTriggerVar_4e46, ++itFunction_4e4f)
	{
		if( ( *itChart_4e19== chart_4e17)&& ( *itArgDeclBase_4e22== argDeclBase_4e20)&& ( *itStruct_4e2b== struct_4e29)&& ( *itoldval_4e34== oldval_4e32)&& ( *itContext_4e3d== context_4e3b)&& ( *itTriggerVar_4e46== triggerVar_4e44)&& ( *itFunction_4e4f== function_4e4d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_chart_4e13.push_back( chart_4e17);
		_argDeclBase_4e1c.push_back( argDeclBase_4e20);
		_struct_4e25.push_back( struct_4e29);
		_oldval_4e2e.push_back( oldval_4e32);
		_context_4e37.push_back( context_4e3b);
		_triggerVar_4e40.push_back( triggerVar_4e44);
		_function_4e49.push_back( function_4e4d);
	}
	return isUnique;
}

bool StartAssignment_4df8::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool StartAssignment_4df8::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, CyberComposition::Simulink::Subsystem& Chart, SFC::Arg& Context, CyberComposition::Simulink::Event& Event, SFC::Function& Function, SFC::LocalVar& LocalVar, CyberComposition::Simulink::Primitive& Primitive, CyberComposition::Simulink::State& State, SFC::Struct& Struct, SFC::LocalVar& TriggerVar, SFC::LocalVar& oldval)
{
	bool Gz_guard= false;
	Gz_guard =
 static_cast< std::string >( Event.Scope() ) == "INPUT_EVENT" &&
 static_cast< __int64>( LocalVar.statementIndex() ) + 1 == static_cast< __int64 >( Event.Port() );;
	return Gz_guard;
}

void StartAssignment_4df8::processInputPackets( const Packets_t& charts_4dfa, const Packets_t& argDeclBases_4dfc, const Packets_t& structs_4e00, const Packets_t& oldvals_4e02, const Packets_t& contexts_4e05, const Packets_t& triggerVars_4e08, const Packets_t& functions_4e0a)
{
	for( Packets_t::const_iterator itChart_4e14= charts_4dfa.begin(), itArgDeclBase_4e1d= argDeclBases_4dfc.begin(), itStruct_4e26= structs_4e00.begin(), itoldval_4e2f= oldvals_4e02.begin(), itContext_4e38= contexts_4e05.begin(), itTriggerVar_4e41= triggerVars_4e08.begin(), itFunction_4e4a= functions_4e0a.begin(); itChart_4e14!= charts_4dfa.end(), itArgDeclBase_4e1d!= argDeclBases_4dfc.end(), itStruct_4e26!= structs_4e00.end(), itoldval_4e2f!= oldvals_4e02.end(), itContext_4e38!= contexts_4e05.end(), itTriggerVar_4e41!= triggerVars_4e08.end(), itFunction_4e4a!= functions_4e0a.end(); ++itChart_4e14, ++itArgDeclBase_4e1d, ++itStruct_4e26, ++itoldval_4e2f, ++itContext_4e38, ++itTriggerVar_4e41, ++itFunction_4e4a)
	{
		bool isUnique= isInputUnique( *itChart_4e14, *itArgDeclBase_4e1d, *itStruct_4e26, *itoldval_4e2f, *itContext_4e38, *itTriggerVar_4e41, *itFunction_4e4a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itChart_4e14, *itArgDeclBase_4e1d, *itStruct_4e26, *itoldval_4e2f, *itContext_4e38, *itTriggerVar_4e41, *itFunction_4e4a);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool StartAssignment_4df8::patternMatcher( const Udm::Object& chart_4e15, const Udm::Object& argDeclBase_4e1e, const Udm::Object& struct_4e27, const Udm::Object& oldval_4e30, const Udm::Object& context_4e39, const Udm::Object& triggerVar_4e42, const Udm::Object& function_4e4b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( chart_4e15.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem chart_4e1a= CyberComposition::Simulink::Subsystem::Cast( chart_4e15);
		if( false== Uml::IsDerivedFrom( argDeclBase_4e1e.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_4e23= SFC::ArgDeclBase::Cast( argDeclBase_4e1e);
		if( false== Uml::IsDerivedFrom( struct_4e27.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_4e2c= SFC::Struct::Cast( struct_4e27);
		if( false== Uml::IsDerivedFrom( oldval_4e30.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar oldval_4e35= SFC::LocalVar::Cast( oldval_4e30);
		if( false== Uml::IsDerivedFrom( context_4e39.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_4e3e= SFC::Arg::Cast( context_4e39);
		if( false== Uml::IsDerivedFrom( triggerVar_4e42.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_4e47= SFC::LocalVar::Cast( triggerVar_4e42);
		if( false== Uml::IsDerivedFrom( function_4e4b.type(), SFC::Function::meta))
			continue;
		SFC::Function function_4e50= SFC::Function::Cast( function_4e4b);
		set< SFC::LocalVar> localVars_4e52= struct_4e2c.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itLocalVar_4e53= localVars_4e52.begin(); itLocalVar_4e53!= localVars_4e52.end(); ++itLocalVar_4e53)
		{
			SFC::LocalVar currLocalVar_4e54= *itLocalVar_4e53;
			set< CyberComposition::Simulink::Primitive> primitives_4e55= chart_4e1a.Primitive_kind_children();
			for( set< CyberComposition::Simulink::Primitive>::const_iterator itPrimitive_4e56= primitives_4e55.begin(); itPrimitive_4e56!= primitives_4e55.end(); ++itPrimitive_4e56)
			{
				CyberComposition::Simulink::Primitive currPrimitive_4e57= *itPrimitive_4e56;
				set< CyberComposition::Simulink::State> states_4e58= currPrimitive_4e57.State_kind_children();
				for( set< CyberComposition::Simulink::State>::const_iterator itState_4e59= states_4e58.begin(); itState_4e59!= states_4e58.end(); ++itState_4e59)
				{
					CyberComposition::Simulink::State currState_4e5a= *itState_4e59;
					set< CyberComposition::Simulink::Event> events_4e5b= currState_4e5a.Event_kind_children();
					for( set< CyberComposition::Simulink::Event>::const_iterator itEvent_4e5c= events_4e5b.begin(); itEvent_4e5c!= events_4e5b.end(); ++itEvent_4e5c)
					{
						CyberComposition::Simulink::Event currEvent_4e5d= *itEvent_4e5c;
						Match currMatch;
						set< pair<int, Udm::Object> > boundObjs_4e61;
						if( !isValidBound(boundObjs_4e61, chart_4e1a, true))
							continue;
						currMatch.chart_4e62= chart_4e1a;
						if( !isValidBound(boundObjs_4e61, argDeclBase_4e23, true))
							continue;
						currMatch.argDeclBase_4e63= argDeclBase_4e23;
						if( !isValidBound(boundObjs_4e61, struct_4e2c, true))
							continue;
						currMatch.struct_4e64= struct_4e2c;
						if( !isValidBound(boundObjs_4e61, oldval_4e35, true))
							continue;
						currMatch.oldval_4e65= oldval_4e35;
						if( !isValidBound(boundObjs_4e61, context_4e3e, true))
							continue;
						currMatch.context_4e66= context_4e3e;
						if( !isValidBound(boundObjs_4e61, triggerVar_4e47, true))
							continue;
						currMatch.triggerVar_4e67= triggerVar_4e47;
						if( !isValidBound(boundObjs_4e61, function_4e50, true))
							continue;
						currMatch.function_4e68= function_4e50;
						if( !isValidBound(boundObjs_4e61, currState_4e5a, false))
							continue;
						currMatch.state_4e69= currState_4e5a;
						if( !isValidBound(boundObjs_4e61, currEvent_4e5d, false))
							continue;
						currMatch.event_4e6a= currEvent_4e5d;
						if( !isValidBound(boundObjs_4e61, currPrimitive_4e57, false))
							continue;
						currMatch.primitive_4e6b= currPrimitive_4e57;
						if( !isValidBound(boundObjs_4e61, currLocalVar_4e54, false))
							continue;
						currMatch.localVar_4e6c= currLocalVar_4e54;
						bool Gz_guard= isGuardTrue( currMatch.argDeclBase_4e63, currMatch.chart_4e62, currMatch.context_4e66, currMatch.event_4e6a, currMatch.function_4e68, currMatch.localVar_4e6c, currMatch.primitive_4e6b, currMatch.state_4e69, currMatch.struct_4e64, currMatch.triggerVar_4e67, currMatch.oldval_4e65);
						if( true== Gz_guard)
							_matches.push_back( currMatch);
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void StartAssignment_4df8::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newAssignment_4e78= SFC::UserCode::Create( currMatch.function_4e68, SFC::Function::meta_stmnt);
		SFC::BinaryExprs newAssign_4e79= SFC::BinaryExprs::Create( newAssignment_4e78, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newDot_4e7a= SFC::BinaryExprs::Create( newAssign_4e79, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_4e7b= SFC::ArgDeclRef::Create( newDot_4e7a, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_4e7c= SFC::ArgDeclRef::Create( newDot_4e7a, SFC::BinaryExprs::meta_leftexpr);
		SFC::UnaryExprs newUnaryExprs_4e7d= SFC::UnaryExprs::Create( newAssign_4e79, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_4e63;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_4e7c;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_4e7b;
		SFC::BinaryExprs& Assign= newAssign_4e79;
		SFC::UserCode& Assignment= newAssignment_4e78;
		CyberComposition::Simulink::Subsystem& Chart= currMatch.chart_4e62;
		SFC::Arg& Context= currMatch.context_4e66;
		SFC::BinaryExprs& Dot= newDot_4e7a;
		CyberComposition::Simulink::Event& Event= currMatch.event_4e6a;
		SFC::Function& Function= currMatch.function_4e68;
		SFC::LocalVar& LocalVar= currMatch.localVar_4e6c;
		CyberComposition::Simulink::Primitive& Primitive= currMatch.primitive_4e6b;
		CyberComposition::Simulink::State& State= currMatch.state_4e69;
		SFC::Struct& Struct= currMatch.struct_4e64;
		SFC::LocalVar& TriggerVar= currMatch.triggerVar_4e67;
		SFC::UnaryExprs& UnaryExprs= newUnaryExprs_4e7d;
		SFC::LocalVar& oldval= currMatch.oldval_4e65;
		{
Assign.op() = "=";
};
		{
Dot.op() = ".";
};
		{
UnaryExprs.op() = "";
};
		{
__int64 statementCount = Function.statementCount();
Assignment.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		newArgDeclRef2_4e7b.argdecl()= currMatch.localVar_4e6c;
		newArgDeclRef_4e7c.argdecl()= currMatch.triggerVar_4e67;
		outputAppender( currMatch.event_4e6a, currMatch.argDeclBase_4e63, currMatch.localVar_4e6c, currMatch.oldval_4e65, currMatch.context_4e66, newUnaryExprs_4e7d);
	}
}

void StartAssignment_4df8::outputAppender( const CyberComposition::Simulink::Event& event_4e7e, const SFC::ArgDeclBase& argDeclBase_4e80, const SFC::LocalVar& localVar_4e82, const SFC::LocalVar& oldval_4e84, const SFC::Arg& context_4e86, const SFC::UnaryExprs& unaryExprs_4e88)
{
	_event_4e0d->push_back( event_4e7e);
	_argDeclBase_4e0e->push_back( argDeclBase_4e80);
	_localVar_4e0f->push_back( localVar_4e82);
	_oldval_4e10->push_back( oldval_4e84);
	_context_4e11->push_back( context_4e86);
	_unaryExprs_4e12->push_back( unaryExprs_4e88);
}

void AddMatrixTriggerVars_4ebe::operator()( const Packets_t& childSubsystems_4ebf, const Packets_t& argdecls_4ec1, const Packets_t& dts_4ec3, const Packets_t& oldvals_4ec5, const Packets_t& contexts_4ec7, const Packets_t& functions_4ec9, Packets_t& childSubsystems_4ecb, Packets_t& argdecls_4ecc, Packets_t& dts_4ecd, Packets_t& oldvals_4ece, Packets_t& contexts_4ecf, Packets_t& functions_4ed0)
{
#ifdef PRINT_INFO
	printLog( "AddMatrixTriggerVars_4ebe" );
#endif
	_childSubsystem_4ed1= &childSubsystems_4ecb;
	_argdecl_4ed2= &argdecls_4ecc;
	_dt_4ed3= &dts_4ecd;
	_oldval_4ed4= &oldvals_4ece;
	_context_4ed5= &contexts_4ecf;
	_function_4ed6= &functions_4ed0;
	_childSubsystem_4ed1->insert( _childSubsystem_4ed1->end(), childSubsystems_4ebf.begin(), childSubsystems_4ebf.end());
	_argdecl_4ed2->insert( _argdecl_4ed2->end(), argdecls_4ec1.begin(), argdecls_4ec1.end());
	_dt_4ed3->insert( _dt_4ed3->end(), dts_4ec3.begin(), dts_4ec3.end());
	_oldval_4ed4->insert( _oldval_4ed4->end(), oldvals_4ec5.begin(), oldvals_4ec5.end());
	_context_4ed5->insert( _context_4ed5->end(), contexts_4ec7.begin(), contexts_4ec7.end());
	_function_4ed6->insert( _function_4ed6->end(), functions_4ec9.begin(), functions_4ec9.end());
	if( ( !childSubsystems_4ebf.empty())&& ( !argdecls_4ec1.empty())&& ( !dts_4ec3.empty())&& ( !oldvals_4ec5.empty())&& ( !contexts_4ec7.empty())&& ( !functions_4ec9.empty()))
		callAddTriggerVar_51cd( childSubsystems_4ebf, argdecls_4ec1, dts_4ec3, oldvals_4ec5, contexts_4ec7, functions_4ec9);
}

void AddMatrixTriggerVars_4ebe::callAddTriggerVar_51cd( const Packets_t& charts_4f16, const Packets_t& argDeclBases_4f19, const Packets_t& dTs_4f1c, const Packets_t& localVars_4f1e, const Packets_t& contexts_4f21, const Packets_t& functions_4f25)
{
	Packets_t charts_4f18;
	Packets_t argDeclBases_4f1b;
	Packets_t localVars_4f20;
	Packets_t contexts_4f23;
	Packets_t triggerVars_4f24;
	Packets_t functions_4f27;
	AddTriggerVar_4f15 addTriggerVar_4f15;
	addTriggerVar_4f15( charts_4f16, argDeclBases_4f19, dTs_4f1c, localVars_4f1e, contexts_4f21, functions_4f25, charts_4f18, argDeclBases_4f1b, localVars_4f20, contexts_4f23, triggerVars_4f24, functions_4f27);
	if( ( !charts_4f18.empty())&& ( !argDeclBases_4f1b.empty())&& ( !localVars_4f20.empty())&& ( !contexts_4f23.empty())&& ( !triggerVars_4f24.empty())&& ( !functions_4f27.empty()))
		callStartAssignment_51d4( charts_4f18, argDeclBases_4f1b, localVars_4f20, contexts_4f23, triggerVars_4f24, functions_4f27);
}

void AddMatrixTriggerVars_4ebe::callStartAssignment_51d4( const Packets_t& charts_5155, const Packets_t& argDeclBases_5157, const Packets_t& oldvals_515a, const Packets_t& contexts_515d, const Packets_t& triggerVars_5160, const Packets_t& functions_5162)
{
	Packets_t events_5154;
	Packets_t argDeclBases_5159;
	Packets_t oldvals_515c;
	Packets_t contexts_515f;
	Packets_t unaryExprss_5164;
	StartAssignment_5153 startAssignment_5153;
	startAssignment_5153( charts_5155, argDeclBases_5157, oldvals_515a, contexts_515d, triggerVars_5160, functions_5162, events_5154, argDeclBases_5159, oldvals_515c, contexts_515f, unaryExprss_5164);
	if( ( !events_5154.empty())&& ( !argDeclBases_5159.empty())&& ( !oldvals_515c.empty())&& ( !contexts_515f.empty())&& ( !unaryExprss_5164.empty()))
		callEdgeTest_51db( events_5154, argDeclBases_5159, oldvals_515c, contexts_515f, unaryExprss_5164);
}

void AddMatrixTriggerVars_4ebe::callEdgeTest_51db( const Packets_t& events_4f82, const Packets_t& argdecls_4f84, const Packets_t& oldvals_4f86, const Packets_t& contexts_4f88, const Packets_t& initexprs_4f8a)
{
	Packets_t argdecls_4f8c;
	Packets_t oldvals_4f8d;
	Packets_t contexts_4f8e;
	Packets_t initexprs_4f8f;
	Packets_t argdecls_4f90;
	Packets_t oldvals_4f91;
	Packets_t contexts_4f92;
	Packets_t initexprs_4f93;
	Packets_t argdecls_4f94;
	Packets_t oldvals_4f95;
	Packets_t contexts_4f96;
	Packets_t initexprs_4f97;
	EdgeTest_4f81 edgeTest_4f81;
	edgeTest_4f81( events_4f82, argdecls_4f84, oldvals_4f86, contexts_4f88, initexprs_4f8a, argdecls_4f8c, oldvals_4f8d, contexts_4f8e, initexprs_4f8f, argdecls_4f90, oldvals_4f91, contexts_4f92, initexprs_4f93, argdecls_4f94, oldvals_4f95, contexts_4f96, initexprs_4f97);
	if( ( !argdecls_4f90.empty())&& ( !oldvals_4f91.empty())&& ( !contexts_4f92.empty())&& ( !initexprs_4f93.empty()))
		callFallingEdge_51e1( argdecls_4f90, oldvals_4f91, contexts_4f92, initexprs_4f93);
	if( ( !argdecls_4f94.empty())&& ( !oldvals_4f95.empty())&& ( !contexts_4f96.empty())&& ( !initexprs_4f97.empty()))
		callEitherEdge_51e6( argdecls_4f94, oldvals_4f95, contexts_4f96, initexprs_4f97);
	if( ( !argdecls_4f8c.empty())&& ( !oldvals_4f8d.empty())&& ( !contexts_4f8e.empty())&& ( !initexprs_4f8f.empty()))
		callRisingEdge_51eb( argdecls_4f8c, oldvals_4f8d, contexts_4f8e, initexprs_4f8f);
}

void AddMatrixTriggerVars_4ebe::callFallingEdge_51e1( const Packets_t& argDeclBases_50ca, const Packets_t& localVars_50cc, const Packets_t& contexts_50ce, const Packets_t& unaryExprss_50d0)
{
	FallingEdge_50c9 fallingEdge_50c9;
	fallingEdge_50c9( argDeclBases_50ca, localVars_50cc, contexts_50ce, unaryExprss_50d0);
}

void AddMatrixTriggerVars_4ebe::callEitherEdge_51e6( const Packets_t& argDeclBases_5108, const Packets_t& localVars_510b, const Packets_t& contexts_510e, const Packets_t& unaryExprss_5111)
{
	Packets_t argDeclBases_510a;
	Packets_t localVars_510d;
	Packets_t contexts_5110;
	Packets_t leftUnaryExprss_5113;
	Packets_t rightUnaryExprss_5114;
	EitherEdge_5107 eitherEdge_5107;
	eitherEdge_5107( argDeclBases_5108, localVars_510b, contexts_510e, unaryExprss_5111, argDeclBases_510a, localVars_510d, contexts_5110, leftUnaryExprss_5113, rightUnaryExprss_5114);
	if( ( !argDeclBases_510a.empty())&& ( !localVars_510d.empty())&& ( !contexts_5110.empty())&& ( !leftUnaryExprss_5113.empty()))
		callRisingEdge_51f0( argDeclBases_510a, localVars_510d, contexts_5110, leftUnaryExprss_5113);
	if( ( !argDeclBases_510a.empty())&& ( !localVars_510d.empty())&& ( !contexts_5110.empty())&& ( !rightUnaryExprss_5114.empty()))
		callFallingEdge_51f5( argDeclBases_510a, localVars_510d, contexts_5110, rightUnaryExprss_5114);
}

void AddMatrixTriggerVars_4ebe::callRisingEdge_51eb( const Packets_t& argDeclBases_4ed8, const Packets_t& localVars_4eda, const Packets_t& contexts_4edc, const Packets_t& unaryExprss_4ede)
{
	RisingEdge_4ed7 risingEdge_4ed7;
	risingEdge_4ed7( argDeclBases_4ed8, localVars_4eda, contexts_4edc, unaryExprss_4ede);
}

void AddMatrixTriggerVars_4ebe::callRisingEdge_51f0( const Packets_t& argDeclBases_4ed8, const Packets_t& localVars_4eda, const Packets_t& contexts_4edc, const Packets_t& unaryExprss_4ede)
{
	RisingEdge_4ed7 risingEdge_4ed7;
	risingEdge_4ed7( argDeclBases_4ed8, localVars_4eda, contexts_4edc, unaryExprss_4ede);
}

void AddMatrixTriggerVars_4ebe::callFallingEdge_51f5( const Packets_t& argDeclBases_50ca, const Packets_t& localVars_50cc, const Packets_t& contexts_50ce, const Packets_t& unaryExprss_50d0)
{
	FallingEdge_50c9 fallingEdge_50c9;
	fallingEdge_50c9( argDeclBases_50ca, localVars_50cc, contexts_50ce, unaryExprss_50d0);
}

void RisingEdge_4ed7::operator()( const Packets_t& argDeclBases_4ed8, const Packets_t& localVars_4eda, const Packets_t& contexts_4edc, const Packets_t& unaryExprss_4ede)
{
#ifdef PRINT_INFO
	printLog( "RisingEdge_4ed7" );
#endif
	RTTGenerator::Instance()->generateRule(4516, "RisingEdge");
	processInputPackets( argDeclBases_4ed8, localVars_4eda, contexts_4edc, unaryExprss_4ede);
}

bool RisingEdge_4ed7::isInputUnique( const Udm::Object& argDeclBase_4ee4, const Udm::Object& localVar_4eed, const Udm::Object& context_4ef6, const Udm::Object& unaryExprs_4eff)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_4ee6= _argDeclBase_4ee0.begin(), itLocalVar_4eef= _localVar_4ee9.begin(), itContext_4ef8= _context_4ef2.begin(), itUnaryExprs_4f01= _unaryExprs_4efb.begin(); itArgDeclBase_4ee6!= _argDeclBase_4ee0.end(), itLocalVar_4eef!= _localVar_4ee9.end(), itContext_4ef8!= _context_4ef2.end(), itUnaryExprs_4f01!= _unaryExprs_4efb.end(); ++itArgDeclBase_4ee6, ++itLocalVar_4eef, ++itContext_4ef8, ++itUnaryExprs_4f01)
	{
		if( ( *itArgDeclBase_4ee6== argDeclBase_4ee4)&& ( *itLocalVar_4eef== localVar_4eed)&& ( *itContext_4ef8== context_4ef6)&& ( *itUnaryExprs_4f01== unaryExprs_4eff))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_4ee0.push_back( argDeclBase_4ee4);
		_localVar_4ee9.push_back( localVar_4eed);
		_context_4ef2.push_back( context_4ef6);
		_unaryExprs_4efb.push_back( unaryExprs_4eff);
	}
	return isUnique;
}

bool RisingEdge_4ed7::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void RisingEdge_4ed7::processInputPackets( const Packets_t& argDeclBases_4ed8, const Packets_t& localVars_4eda, const Packets_t& contexts_4edc, const Packets_t& unaryExprss_4ede)
{
	for( Packets_t::const_iterator itArgDeclBase_4ee1= argDeclBases_4ed8.begin(), itLocalVar_4eea= localVars_4eda.begin(), itContext_4ef3= contexts_4edc.begin(), itUnaryExprs_4efc= unaryExprss_4ede.begin(); itArgDeclBase_4ee1!= argDeclBases_4ed8.end(), itLocalVar_4eea!= localVars_4eda.end(), itContext_4ef3!= contexts_4edc.end(), itUnaryExprs_4efc!= unaryExprss_4ede.end(); ++itArgDeclBase_4ee1, ++itLocalVar_4eea, ++itContext_4ef3, ++itUnaryExprs_4efc)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_4ee1, *itLocalVar_4eea, *itContext_4ef3, *itUnaryExprs_4efc);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_4ee1, *itLocalVar_4eea, *itContext_4ef3, *itUnaryExprs_4efc);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool RisingEdge_4ed7::patternMatcher( const Udm::Object& argDeclBase_4ee2, const Udm::Object& localVar_4eeb, const Udm::Object& context_4ef4, const Udm::Object& unaryExprs_4efd)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_4ee2.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_4ee7= SFC::ArgDeclBase::Cast( argDeclBase_4ee2);
		if( false== Uml::IsDerivedFrom( localVar_4eeb.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_4ef0= SFC::LocalVar::Cast( localVar_4eeb);
		if( false== Uml::IsDerivedFrom( context_4ef4.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_4ef9= SFC::Arg::Cast( context_4ef4);
		if( false== Uml::IsDerivedFrom( unaryExprs_4efd.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_4f02= SFC::UnaryExprs::Cast( unaryExprs_4efd);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4f07;
		if( !isValidBound(boundObjs_4f07, argDeclBase_4ee7, true))
			continue;
		currMatch.argDeclBase_4f08= argDeclBase_4ee7;
		if( !isValidBound(boundObjs_4f07, localVar_4ef0, true))
			continue;
		currMatch.localVar_4f09= localVar_4ef0;
		if( !isValidBound(boundObjs_4f07, context_4ef9, true))
			continue;
		currMatch.context_4f0a= context_4ef9;
		if( !isValidBound(boundObjs_4f07, unaryExprs_4f02, true))
			continue;
		currMatch.unaryExprs_4f0b= unaryExprs_4f02;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void RisingEdge_4ed7::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newAnd_4f0c= SFC::BinaryExprs::Create( currMatch.unaryExprs_4f0b, SFC::UnaryExprs::meta_subexpr);
		SFC::BinaryExprs newLessThan_4f0d= SFC::BinaryExprs::Create( newAnd_4f0c, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newGreaterThan_4f0e= SFC::BinaryExprs::Create( newAnd_4f0c, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newDot_4f0f= SFC::BinaryExprs::Create( newLessThan_4f0d, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_4f10= SFC::ArgDeclRef::Create( newDot_4f0f, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_4f11= SFC::ArgDeclRef::Create( newGreaterThan_4f0e, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newZero2_4f12= SFC::Int::Create( newGreaterThan_4f0e, SFC::BinaryExprs::meta_rightexpr);
		SFC::Int newZero_4f13= SFC::Int::Create( newLessThan_4f0d, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef3_4f14= SFC::ArgDeclRef::Create( newDot_4f0f, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs& And= newAnd_4f0c;
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_4f08;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_4f11;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_4f10;
		SFC::ArgDeclRef& ArgDeclRef3= newArgDeclRef3_4f14;
		SFC::Arg& Context= currMatch.context_4f0a;
		SFC::BinaryExprs& Dot= newDot_4f0f;
		SFC::BinaryExprs& GreaterThan= newGreaterThan_4f0e;
		SFC::BinaryExprs& LessThan= newLessThan_4f0d;
		SFC::LocalVar& LocalVar= currMatch.localVar_4f09;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_4f0b;
		SFC::Int& Zero= newZero_4f13;
		SFC::Int& Zero2= newZero2_4f12;
		{
Zero2.val() = 0;
};
		{
Zero.val() = 0;
};
		{
Dot.op() = ".";
};
		{
GreaterThan.op() = ">";
};
		{
And.op() = "&&";
};
		{
LessThan.op() = "<=";
};
		newArgDeclRef3_4f14.argdecl()= currMatch.context_4f0a;
		newArgDeclRef_4f11.argdecl()= currMatch.argDeclBase_4f08;
		newArgDeclRef2_4f10.argdecl()= currMatch.localVar_4f09;
	}
}

void AddTriggerVar_4f15::operator()( const Packets_t& charts_4f16, const Packets_t& argDeclBases_4f19, const Packets_t& dTs_4f1c, const Packets_t& localVars_4f1e, const Packets_t& contexts_4f21, const Packets_t& functions_4f25, Packets_t& charts_4f18, Packets_t& argDeclBases_4f1b, Packets_t& localVars_4f20, Packets_t& contexts_4f23, Packets_t& triggerVars_4f24, Packets_t& functions_4f27)
{
#ifdef PRINT_INFO
	printLog( "AddTriggerVar_4f15" );
#endif
	RTTGenerator::Instance()->generateRule(4548, "AddTriggerVar");
	_chart_4f28= &charts_4f18;
	_argDeclBase_4f29= &argDeclBases_4f1b;
	_localVar_4f2a= &localVars_4f20;
	_context_4f2b= &contexts_4f23;
	_triggerVar_4f2c= &triggerVars_4f24;
	_function_4f2d= &functions_4f27;
	processInputPackets( charts_4f16, argDeclBases_4f19, dTs_4f1c, localVars_4f1e, contexts_4f21, functions_4f25);
}

bool AddTriggerVar_4f15::isInputUnique( const Udm::Object& chart_4f32, const Udm::Object& argDeclBase_4f3b, const Udm::Object& dT_4f44, const Udm::Object& localVar_4f4d, const Udm::Object& context_4f56, const Udm::Object& function_4f5f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itChart_4f34= _chart_4f2e.begin(), itArgDeclBase_4f3d= _argDeclBase_4f37.begin(), itDT_4f46= _dT_4f40.begin(), itLocalVar_4f4f= _localVar_4f49.begin(), itContext_4f58= _context_4f52.begin(), itFunction_4f61= _function_4f5b.begin(); itChart_4f34!= _chart_4f2e.end(), itArgDeclBase_4f3d!= _argDeclBase_4f37.end(), itDT_4f46!= _dT_4f40.end(), itLocalVar_4f4f!= _localVar_4f49.end(), itContext_4f58!= _context_4f52.end(), itFunction_4f61!= _function_4f5b.end(); ++itChart_4f34, ++itArgDeclBase_4f3d, ++itDT_4f46, ++itLocalVar_4f4f, ++itContext_4f58, ++itFunction_4f61)
	{
		if( ( *itChart_4f34== chart_4f32)&& ( *itArgDeclBase_4f3d== argDeclBase_4f3b)&& ( *itDT_4f46== dT_4f44)&& ( *itLocalVar_4f4f== localVar_4f4d)&& ( *itContext_4f58== context_4f56)&& ( *itFunction_4f61== function_4f5f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_chart_4f2e.push_back( chart_4f32);
		_argDeclBase_4f37.push_back( argDeclBase_4f3b);
		_dT_4f40.push_back( dT_4f44);
		_localVar_4f49.push_back( localVar_4f4d);
		_context_4f52.push_back( context_4f56);
		_function_4f5b.push_back( function_4f5f);
	}
	return isUnique;
}

bool AddTriggerVar_4f15::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool AddTriggerVar_4f15::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, CyberComposition::Simulink::Subsystem& Chart, SFC::Arg& Context, SFC::DT& DT, SFC::Function& Function, SFC::LocalVar& LocalVar)
{
	bool Gz_guard= false;
	Gz_guard = DT.type() != SFC::Struct::meta;;
	return Gz_guard;
}

void AddTriggerVar_4f15::processInputPackets( const Packets_t& charts_4f16, const Packets_t& argDeclBases_4f19, const Packets_t& dTs_4f1c, const Packets_t& localVars_4f1e, const Packets_t& contexts_4f21, const Packets_t& functions_4f25)
{
	for( Packets_t::const_iterator itChart_4f2f= charts_4f16.begin(), itArgDeclBase_4f38= argDeclBases_4f19.begin(), itDT_4f41= dTs_4f1c.begin(), itLocalVar_4f4a= localVars_4f1e.begin(), itContext_4f53= contexts_4f21.begin(), itFunction_4f5c= functions_4f25.begin(); itChart_4f2f!= charts_4f16.end(), itArgDeclBase_4f38!= argDeclBases_4f19.end(), itDT_4f41!= dTs_4f1c.end(), itLocalVar_4f4a!= localVars_4f1e.end(), itContext_4f53!= contexts_4f21.end(), itFunction_4f5c!= functions_4f25.end(); ++itChart_4f2f, ++itArgDeclBase_4f38, ++itDT_4f41, ++itLocalVar_4f4a, ++itContext_4f53, ++itFunction_4f5c)
	{
		bool isUnique= isInputUnique( *itChart_4f2f, *itArgDeclBase_4f38, *itDT_4f41, *itLocalVar_4f4a, *itContext_4f53, *itFunction_4f5c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itChart_4f2f, *itArgDeclBase_4f38, *itDT_4f41, *itLocalVar_4f4a, *itContext_4f53, *itFunction_4f5c);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AddTriggerVar_4f15::patternMatcher( const Udm::Object& chart_4f30, const Udm::Object& argDeclBase_4f39, const Udm::Object& dT_4f42, const Udm::Object& localVar_4f4b, const Udm::Object& context_4f54, const Udm::Object& function_4f5d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( chart_4f30.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem chart_4f35= CyberComposition::Simulink::Subsystem::Cast( chart_4f30);
		if( false== Uml::IsDerivedFrom( argDeclBase_4f39.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_4f3e= SFC::ArgDeclBase::Cast( argDeclBase_4f39);
		if( false== Uml::IsDerivedFrom( dT_4f42.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_4f47= SFC::DT::Cast( dT_4f42);
		if( false== Uml::IsDerivedFrom( localVar_4f4b.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_4f50= SFC::LocalVar::Cast( localVar_4f4b);
		if( false== Uml::IsDerivedFrom( context_4f54.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_4f59= SFC::Arg::Cast( context_4f54);
		if( false== Uml::IsDerivedFrom( function_4f5d.type(), SFC::Function::meta))
			continue;
		SFC::Function function_4f62= SFC::Function::Cast( function_4f5d);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_4f67;
		if( !isValidBound(boundObjs_4f67, chart_4f35, true))
			continue;
		currMatch.chart_4f68= chart_4f35;
		if( !isValidBound(boundObjs_4f67, argDeclBase_4f3e, true))
			continue;
		currMatch.argDeclBase_4f69= argDeclBase_4f3e;
		if( !isValidBound(boundObjs_4f67, dT_4f47, true))
			continue;
		currMatch.dT_4f6a= dT_4f47;
		if( !isValidBound(boundObjs_4f67, localVar_4f50, true))
			continue;
		currMatch.localVar_4f6b= localVar_4f50;
		if( !isValidBound(boundObjs_4f67, context_4f59, true))
			continue;
		currMatch.context_4f6c= context_4f59;
		if( !isValidBound(boundObjs_4f67, function_4f62, true))
			continue;
		currMatch.function_4f6d= function_4f62;
		bool Gz_guard= isGuardTrue( currMatch.argDeclBase_4f69, currMatch.chart_4f68, currMatch.context_4f6c, currMatch.dT_4f6a, currMatch.function_4f6d, currMatch.localVar_4f6b);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void AddTriggerVar_4f15::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newTriggerVar_4f74= SFC::LocalVar::Create( currMatch.function_4f6d, SFC::Function::meta_stmnt);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_4f69;
		CyberComposition::Simulink::Subsystem& Chart= currMatch.chart_4f68;
		SFC::Arg& Context= currMatch.context_4f6c;
		SFC::DT& DT= currMatch.dT_4f6a;
		SFC::Function& Function= currMatch.function_4f6d;
		SFC::LocalVar& LocalVar= currMatch.localVar_4f6b;
		SFC::LocalVar& TriggerVar= newTriggerVar_4f74;
		{
TriggerVar.type() = "int";
TriggerVar.name() = std::string( "event" ) + boost::lexical_cast< std::string >( TriggerVar.uniqueId() );
};
		{
__int64 statementCount = Function.statementCount();
TriggerVar.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		newTriggerVar_4f74.dt()= currMatch.dT_4f6a;
		currMatch.localVar_4f6b.trigvar()= newTriggerVar_4f74;
		outputAppender( currMatch.chart_4f68, currMatch.argDeclBase_4f69, currMatch.localVar_4f6b, currMatch.context_4f6c, newTriggerVar_4f74, currMatch.function_4f6d);
	}
}

void AddTriggerVar_4f15::outputAppender( const CyberComposition::Simulink::Subsystem& chart_4f75, const SFC::ArgDeclBase& argDeclBase_4f77, const SFC::LocalVar& localVar_4f79, const SFC::Arg& context_4f7b, const SFC::LocalVar& triggerVar_4f7d, const SFC::Function& function_4f7f)
{
	_chart_4f28->push_back( chart_4f75);
	_argDeclBase_4f29->push_back( argDeclBase_4f77);
	_localVar_4f2a->push_back( localVar_4f79);
	_context_4f2b->push_back( context_4f7b);
	_triggerVar_4f2c->push_back( triggerVar_4f7d);
	_function_4f2d->push_back( function_4f7f);
}

void EdgeTest_4f81::operator()( const Packets_t& events_4f82, const Packets_t& argdecls_4f84, const Packets_t& oldvals_4f86, const Packets_t& contexts_4f88, const Packets_t& initexprs_4f8a, Packets_t& argdecls_4f8c, Packets_t& oldvals_4f8d, Packets_t& contexts_4f8e, Packets_t& initexprs_4f8f, Packets_t& argdecls_4f90, Packets_t& oldvals_4f91, Packets_t& contexts_4f92, Packets_t& initexprs_4f93, Packets_t& argdecls_4f94, Packets_t& oldvals_4f95, Packets_t& contexts_4f96, Packets_t& initexprs_4f97)
{
#ifdef PRINT_INFO
	printLog( "EdgeTest_4f81" );
#endif
	_argdecl_4f98= &argdecls_4f8c;
	_oldval_4f99= &oldvals_4f8d;
	_context_4f9a= &contexts_4f8e;
	_initexpr_4f9b= &initexprs_4f8f;
	_argdecl_4f9c= &argdecls_4f90;
	_oldval_4f9d= &oldvals_4f91;
	_context_4f9e= &contexts_4f92;
	_initexpr_4f9f= &initexprs_4f93;
	_argdecl_4fa0= &argdecls_4f94;
	_oldval_4fa1= &oldvals_4f95;
	_context_4fa2= &contexts_4f96;
	_initexpr_4fa3= &initexprs_4f97;
	for( Packets_t::const_iterator itevent_4fa5= events_4f82.begin(), itargdecl_4fac= argdecls_4f84.begin(), itoldval_4fb3= oldvals_4f86.begin(), itcontext_4fba= contexts_4f88.begin(), itinitexpr_4fc1= initexprs_4f8a.begin(); itevent_4fa5!= events_4f82.end(), itargdecl_4fac!= argdecls_4f84.end(), itoldval_4fb3!= oldvals_4f86.end(), itcontext_4fba!= contexts_4f88.end(), itinitexpr_4fc1!= initexprs_4f8a.end(); ++itevent_4fa5, ++itargdecl_4fac, ++itoldval_4fb3, ++itcontext_4fba, ++itinitexpr_4fc1)
	{
		bool isUnique= isInputUnique( *itevent_4fa5, *itargdecl_4fac, *itoldval_4fb3, *itcontext_4fba, *itinitexpr_4fc1);
		if( !isUnique)
			continue;
		Packets_t oneevent_4fa9( 1, *itevent_4fa5);
		Packets_t oneargdecl_4fb0( 1, *itargdecl_4fac);
		Packets_t oneoldval_4fb7( 1, *itoldval_4fb3);
		Packets_t onecontext_4fbe( 1, *itcontext_4fba);
		Packets_t oneinitexpr_4fc5( 1, *itinitexpr_4fc1);
		executeOne( oneevent_4fa9, oneargdecl_4fb0, oneoldval_4fb7, onecontext_4fbe, oneinitexpr_4fc5);
	}
}

void EdgeTest_4f81::executeOne( const Packets_t& events_4f82, const Packets_t& argdecls_4f84, const Packets_t& oldvals_4f86, const Packets_t& contexts_4f88, const Packets_t& initexprs_4f8a)
{
	Packets_t argDeclBases_4fcc;
	Packets_t localVars_4fcf;
	Packets_t contexts_4fd2;
	Packets_t unaryExprss_4fd5;
	RisingEdge_4fc7 risingEdge_4fc7;
	bool isMatchRisingEdge_4fc7= risingEdge_4fc7( events_4f82, argdecls_4f84, oldvals_4f86, contexts_4f88, initexprs_4f8a, argDeclBases_4fcc, localVars_4fcf, contexts_4fd2, unaryExprss_4fd5);
	_argdecl_4f98->insert( _argdecl_4f98->end(), argDeclBases_4fcc.begin(), argDeclBases_4fcc.end());
	_oldval_4f99->insert( _oldval_4f99->end(), localVars_4fcf.begin(), localVars_4fcf.end());
	_context_4f9a->insert( _context_4f9a->end(), contexts_4fd2.begin(), contexts_4fd2.end());
	_initexpr_4f9b->insert( _initexpr_4f9b->end(), unaryExprss_4fd5.begin(), unaryExprss_4fd5.end());
	if( isMatchRisingEdge_4fc7)
		return;
	Packets_t argDeclBases_5022;
	Packets_t localVars_5025;
	Packets_t contexts_5028;
	Packets_t unaryExprss_502b;
	FallingEdge_501d fallingEdge_501d;
	bool isMatchFallingEdge_501d= fallingEdge_501d( events_4f82, argdecls_4f84, oldvals_4f86, contexts_4f88, initexprs_4f8a, argDeclBases_5022, localVars_5025, contexts_5028, unaryExprss_502b);
	_argdecl_4f9c->insert( _argdecl_4f9c->end(), argDeclBases_5022.begin(), argDeclBases_5022.end());
	_oldval_4f9d->insert( _oldval_4f9d->end(), localVars_5025.begin(), localVars_5025.end());
	_context_4f9e->insert( _context_4f9e->end(), contexts_5028.begin(), contexts_5028.end());
	_initexpr_4f9f->insert( _initexpr_4f9f->end(), unaryExprss_502b.begin(), unaryExprss_502b.end());
	Packets_t argDeclBases_5078;
	Packets_t localVars_507b;
	Packets_t contexts_507e;
	Packets_t unaryExprss_5081;
	EitherEdge_5073 eitherEdge_5073;
	bool isMatchEitherEdge_5073= eitherEdge_5073( events_4f82, argdecls_4f84, oldvals_4f86, contexts_4f88, initexprs_4f8a, argDeclBases_5078, localVars_507b, contexts_507e, unaryExprss_5081);
	_argdecl_4fa0->insert( _argdecl_4fa0->end(), argDeclBases_5078.begin(), argDeclBases_5078.end());
	_oldval_4fa1->insert( _oldval_4fa1->end(), localVars_507b.begin(), localVars_507b.end());
	_context_4fa2->insert( _context_4fa2->end(), contexts_507e.begin(), contexts_507e.end());
	_initexpr_4fa3->insert( _initexpr_4fa3->end(), unaryExprss_5081.begin(), unaryExprss_5081.end());
}

bool EdgeTest_4f81::isInputUnique( const Udm::Object& event_4fa6, const Udm::Object& argdecl_4fad, const Udm::Object& oldval_4fb4, const Udm::Object& context_4fbb, const Udm::Object& initexpr_4fc2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itevent_4fa8= _event_4fa4.begin(), itargdecl_4faf= _argdecl_4fab.begin(), itoldval_4fb6= _oldval_4fb2.begin(), itcontext_4fbd= _context_4fb9.begin(), itinitexpr_4fc4= _initexpr_4fc0.begin(); itevent_4fa8!= _event_4fa4.end(), itargdecl_4faf!= _argdecl_4fab.end(), itoldval_4fb6!= _oldval_4fb2.end(), itcontext_4fbd!= _context_4fb9.end(), itinitexpr_4fc4!= _initexpr_4fc0.end(); ++itevent_4fa8, ++itargdecl_4faf, ++itoldval_4fb6, ++itcontext_4fbd, ++itinitexpr_4fc4)
	{
		if( ( *itevent_4fa8== event_4fa6)&& ( *itargdecl_4faf== argdecl_4fad)&& ( *itoldval_4fb6== oldval_4fb4)&& ( *itcontext_4fbd== context_4fbb)&& ( *itinitexpr_4fc4== initexpr_4fc2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_event_4fa4.push_back( event_4fa6);
		_argdecl_4fab.push_back( argdecl_4fad);
		_oldval_4fb2.push_back( oldval_4fb4);
		_context_4fb9.push_back( context_4fbb);
		_initexpr_4fc0.push_back( initexpr_4fc2);
	}
	return isUnique;
}

bool RisingEdge_4fc7::operator()( const Packets_t& events_4fc8, const Packets_t& argDeclBases_4fca, const Packets_t& localVars_4fcd, const Packets_t& contexts_4fd0, const Packets_t& unaryExprss_4fd3, Packets_t& argDeclBases_4fcc, Packets_t& localVars_4fcf, Packets_t& contexts_4fd2, Packets_t& unaryExprss_4fd5)
{
#ifdef PRINT_INFO
	printLog( "RisingEdge_4fc7" );
#endif
	_argDeclBase_4fd6= &argDeclBases_4fcc;
	_localVar_4fd7= &localVars_4fcf;
	_context_4fd8= &contexts_4fd2;
	_unaryExprs_4fd9= &unaryExprss_4fd5;
	processInputPackets( events_4fc8, argDeclBases_4fca, localVars_4fcd, contexts_4fd0, unaryExprss_4fd3);
	if( false== _matches.empty())
		return true;
	return false;
}

bool RisingEdge_4fc7::isInputUnique( const Udm::Object& event_4fde, const Udm::Object& argDeclBase_4fe7, const Udm::Object& localVar_4ff0, const Udm::Object& context_4ff9, const Udm::Object& unaryExprs_5002)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itEvent_4fe0= _event_4fda.begin(), itArgDeclBase_4fe9= _argDeclBase_4fe3.begin(), itLocalVar_4ff2= _localVar_4fec.begin(), itContext_4ffb= _context_4ff5.begin(), itUnaryExprs_5004= _unaryExprs_4ffe.begin(); itEvent_4fe0!= _event_4fda.end(), itArgDeclBase_4fe9!= _argDeclBase_4fe3.end(), itLocalVar_4ff2!= _localVar_4fec.end(), itContext_4ffb!= _context_4ff5.end(), itUnaryExprs_5004!= _unaryExprs_4ffe.end(); ++itEvent_4fe0, ++itArgDeclBase_4fe9, ++itLocalVar_4ff2, ++itContext_4ffb, ++itUnaryExprs_5004)
	{
		if( ( *itEvent_4fe0== event_4fde)&& ( *itArgDeclBase_4fe9== argDeclBase_4fe7)&& ( *itLocalVar_4ff2== localVar_4ff0)&& ( *itContext_4ffb== context_4ff9)&& ( *itUnaryExprs_5004== unaryExprs_5002))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_event_4fda.push_back( event_4fde);
		_argDeclBase_4fe3.push_back( argDeclBase_4fe7);
		_localVar_4fec.push_back( localVar_4ff0);
		_context_4ff5.push_back( context_4ff9);
		_unaryExprs_4ffe.push_back( unaryExprs_5002);
	}
	return isUnique;
}

bool RisingEdge_4fc7::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool RisingEdge_4fc7::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, SFC::Arg& Context, CyberComposition::Simulink::Event& Event, SFC::LocalVar& LocalVar, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	std::string trigger = Event.Trigger();
Gz_guard = trigger == "RISING_EDGE_EVENT";;
	return Gz_guard;
}

void RisingEdge_4fc7::processInputPackets( const Packets_t& events_4fc8, const Packets_t& argDeclBases_4fca, const Packets_t& localVars_4fcd, const Packets_t& contexts_4fd0, const Packets_t& unaryExprss_4fd3)
{
	for( Packets_t::const_iterator itEvent_4fdb= events_4fc8.begin(), itArgDeclBase_4fe4= argDeclBases_4fca.begin(), itLocalVar_4fed= localVars_4fcd.begin(), itContext_4ff6= contexts_4fd0.begin(), itUnaryExprs_4fff= unaryExprss_4fd3.begin(); itEvent_4fdb!= events_4fc8.end(), itArgDeclBase_4fe4!= argDeclBases_4fca.end(), itLocalVar_4fed!= localVars_4fcd.end(), itContext_4ff6!= contexts_4fd0.end(), itUnaryExprs_4fff!= unaryExprss_4fd3.end(); ++itEvent_4fdb, ++itArgDeclBase_4fe4, ++itLocalVar_4fed, ++itContext_4ff6, ++itUnaryExprs_4fff)
	{
		bool isUnique= isInputUnique( *itEvent_4fdb, *itArgDeclBase_4fe4, *itLocalVar_4fed, *itContext_4ff6, *itUnaryExprs_4fff);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itEvent_4fdb, *itArgDeclBase_4fe4, *itLocalVar_4fed, *itContext_4ff6, *itUnaryExprs_4fff);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_500c, currMatch.localVar_500d, currMatch.context_500e, currMatch.unaryExprs_500f);
	}
}

bool RisingEdge_4fc7::patternMatcher( const Udm::Object& event_4fdc, const Udm::Object& argDeclBase_4fe5, const Udm::Object& localVar_4fee, const Udm::Object& context_4ff7, const Udm::Object& unaryExprs_5000)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( event_4fdc.type(), CyberComposition::Simulink::Event::meta))
			continue;
		CyberComposition::Simulink::Event event_4fe1= CyberComposition::Simulink::Event::Cast( event_4fdc);
		if( false== Uml::IsDerivedFrom( argDeclBase_4fe5.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_4fea= SFC::ArgDeclBase::Cast( argDeclBase_4fe5);
		if( false== Uml::IsDerivedFrom( localVar_4fee.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_4ff3= SFC::LocalVar::Cast( localVar_4fee);
		if( false== Uml::IsDerivedFrom( context_4ff7.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_4ffc= SFC::Arg::Cast( context_4ff7);
		if( false== Uml::IsDerivedFrom( unaryExprs_5000.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_5005= SFC::UnaryExprs::Cast( unaryExprs_5000);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_500a;
		if( !isValidBound(boundObjs_500a, event_4fe1, true))
			continue;
		currMatch.event_500b= event_4fe1;
		if( !isValidBound(boundObjs_500a, argDeclBase_4fea, true))
			continue;
		currMatch.argDeclBase_500c= argDeclBase_4fea;
		if( !isValidBound(boundObjs_500a, localVar_4ff3, true))
			continue;
		currMatch.localVar_500d= localVar_4ff3;
		if( !isValidBound(boundObjs_500a, context_4ffc, true))
			continue;
		currMatch.context_500e= context_4ffc;
		if( !isValidBound(boundObjs_500a, unaryExprs_5005, true))
			continue;
		currMatch.unaryExprs_500f= unaryExprs_5005;
		bool Gz_guard= isGuardTrue( currMatch.argDeclBase_500c, currMatch.context_500e, currMatch.event_500b, currMatch.localVar_500d, currMatch.unaryExprs_500f);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void RisingEdge_4fc7::outputAppender( const SFC::ArgDeclBase& argDeclBase_5015, const SFC::LocalVar& localVar_5017, const SFC::Arg& context_5019, const SFC::UnaryExprs& unaryExprs_501b)
{
	_argDeclBase_4fd6->push_back( argDeclBase_5015);
	_localVar_4fd7->push_back( localVar_5017);
	_context_4fd8->push_back( context_5019);
	_unaryExprs_4fd9->push_back( unaryExprs_501b);
}

bool FallingEdge_501d::operator()( const Packets_t& events_501e, const Packets_t& argDeclBases_5020, const Packets_t& localVars_5023, const Packets_t& contexts_5026, const Packets_t& unaryExprss_5029, Packets_t& argDeclBases_5022, Packets_t& localVars_5025, Packets_t& contexts_5028, Packets_t& unaryExprss_502b)
{
#ifdef PRINT_INFO
	printLog( "FallingEdge_501d" );
#endif
	_argDeclBase_502c= &argDeclBases_5022;
	_localVar_502d= &localVars_5025;
	_context_502e= &contexts_5028;
	_unaryExprs_502f= &unaryExprss_502b;
	processInputPackets( events_501e, argDeclBases_5020, localVars_5023, contexts_5026, unaryExprss_5029);
	if( false== _matches.empty())
		return true;
	return false;
}

bool FallingEdge_501d::isInputUnique( const Udm::Object& event_5034, const Udm::Object& argDeclBase_503d, const Udm::Object& localVar_5046, const Udm::Object& context_504f, const Udm::Object& unaryExprs_5058)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itEvent_5036= _event_5030.begin(), itArgDeclBase_503f= _argDeclBase_5039.begin(), itLocalVar_5048= _localVar_5042.begin(), itContext_5051= _context_504b.begin(), itUnaryExprs_505a= _unaryExprs_5054.begin(); itEvent_5036!= _event_5030.end(), itArgDeclBase_503f!= _argDeclBase_5039.end(), itLocalVar_5048!= _localVar_5042.end(), itContext_5051!= _context_504b.end(), itUnaryExprs_505a!= _unaryExprs_5054.end(); ++itEvent_5036, ++itArgDeclBase_503f, ++itLocalVar_5048, ++itContext_5051, ++itUnaryExprs_505a)
	{
		if( ( *itEvent_5036== event_5034)&& ( *itArgDeclBase_503f== argDeclBase_503d)&& ( *itLocalVar_5048== localVar_5046)&& ( *itContext_5051== context_504f)&& ( *itUnaryExprs_505a== unaryExprs_5058))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_event_5030.push_back( event_5034);
		_argDeclBase_5039.push_back( argDeclBase_503d);
		_localVar_5042.push_back( localVar_5046);
		_context_504b.push_back( context_504f);
		_unaryExprs_5054.push_back( unaryExprs_5058);
	}
	return isUnique;
}

bool FallingEdge_501d::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool FallingEdge_501d::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, SFC::Arg& Context, CyberComposition::Simulink::Event& Event, SFC::LocalVar& LocalVar, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	std::string trigger = Event.Trigger();
Gz_guard = trigger == "FALLING_EDGE_EVENT";;
	return Gz_guard;
}

void FallingEdge_501d::processInputPackets( const Packets_t& events_501e, const Packets_t& argDeclBases_5020, const Packets_t& localVars_5023, const Packets_t& contexts_5026, const Packets_t& unaryExprss_5029)
{
	for( Packets_t::const_iterator itEvent_5031= events_501e.begin(), itArgDeclBase_503a= argDeclBases_5020.begin(), itLocalVar_5043= localVars_5023.begin(), itContext_504c= contexts_5026.begin(), itUnaryExprs_5055= unaryExprss_5029.begin(); itEvent_5031!= events_501e.end(), itArgDeclBase_503a!= argDeclBases_5020.end(), itLocalVar_5043!= localVars_5023.end(), itContext_504c!= contexts_5026.end(), itUnaryExprs_5055!= unaryExprss_5029.end(); ++itEvent_5031, ++itArgDeclBase_503a, ++itLocalVar_5043, ++itContext_504c, ++itUnaryExprs_5055)
	{
		bool isUnique= isInputUnique( *itEvent_5031, *itArgDeclBase_503a, *itLocalVar_5043, *itContext_504c, *itUnaryExprs_5055);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itEvent_5031, *itArgDeclBase_503a, *itLocalVar_5043, *itContext_504c, *itUnaryExprs_5055);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_5062, currMatch.localVar_5063, currMatch.context_5064, currMatch.unaryExprs_5065);
	}
}

bool FallingEdge_501d::patternMatcher( const Udm::Object& event_5032, const Udm::Object& argDeclBase_503b, const Udm::Object& localVar_5044, const Udm::Object& context_504d, const Udm::Object& unaryExprs_5056)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( event_5032.type(), CyberComposition::Simulink::Event::meta))
			continue;
		CyberComposition::Simulink::Event event_5037= CyberComposition::Simulink::Event::Cast( event_5032);
		if( false== Uml::IsDerivedFrom( argDeclBase_503b.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_5040= SFC::ArgDeclBase::Cast( argDeclBase_503b);
		if( false== Uml::IsDerivedFrom( localVar_5044.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_5049= SFC::LocalVar::Cast( localVar_5044);
		if( false== Uml::IsDerivedFrom( context_504d.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_5052= SFC::Arg::Cast( context_504d);
		if( false== Uml::IsDerivedFrom( unaryExprs_5056.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_505b= SFC::UnaryExprs::Cast( unaryExprs_5056);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5060;
		if( !isValidBound(boundObjs_5060, event_5037, true))
			continue;
		currMatch.event_5061= event_5037;
		if( !isValidBound(boundObjs_5060, argDeclBase_5040, true))
			continue;
		currMatch.argDeclBase_5062= argDeclBase_5040;
		if( !isValidBound(boundObjs_5060, localVar_5049, true))
			continue;
		currMatch.localVar_5063= localVar_5049;
		if( !isValidBound(boundObjs_5060, context_5052, true))
			continue;
		currMatch.context_5064= context_5052;
		if( !isValidBound(boundObjs_5060, unaryExprs_505b, true))
			continue;
		currMatch.unaryExprs_5065= unaryExprs_505b;
		bool Gz_guard= isGuardTrue( currMatch.argDeclBase_5062, currMatch.context_5064, currMatch.event_5061, currMatch.localVar_5063, currMatch.unaryExprs_5065);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void FallingEdge_501d::outputAppender( const SFC::ArgDeclBase& argDeclBase_506b, const SFC::LocalVar& localVar_506d, const SFC::Arg& context_506f, const SFC::UnaryExprs& unaryExprs_5071)
{
	_argDeclBase_502c->push_back( argDeclBase_506b);
	_localVar_502d->push_back( localVar_506d);
	_context_502e->push_back( context_506f);
	_unaryExprs_502f->push_back( unaryExprs_5071);
}

bool EitherEdge_5073::operator()( const Packets_t& events_5074, const Packets_t& argDeclBases_5076, const Packets_t& localVars_5079, const Packets_t& contexts_507c, const Packets_t& unaryExprss_507f, Packets_t& argDeclBases_5078, Packets_t& localVars_507b, Packets_t& contexts_507e, Packets_t& unaryExprss_5081)
{
#ifdef PRINT_INFO
	printLog( "EitherEdge_5073" );
#endif
	_argDeclBase_5082= &argDeclBases_5078;
	_localVar_5083= &localVars_507b;
	_context_5084= &contexts_507e;
	_unaryExprs_5085= &unaryExprss_5081;
	processInputPackets( events_5074, argDeclBases_5076, localVars_5079, contexts_507c, unaryExprss_507f);
	if( false== _matches.empty())
		return true;
	return false;
}

bool EitherEdge_5073::isInputUnique( const Udm::Object& event_508a, const Udm::Object& argDeclBase_5093, const Udm::Object& localVar_509c, const Udm::Object& context_50a5, const Udm::Object& unaryExprs_50ae)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itEvent_508c= _event_5086.begin(), itArgDeclBase_5095= _argDeclBase_508f.begin(), itLocalVar_509e= _localVar_5098.begin(), itContext_50a7= _context_50a1.begin(), itUnaryExprs_50b0= _unaryExprs_50aa.begin(); itEvent_508c!= _event_5086.end(), itArgDeclBase_5095!= _argDeclBase_508f.end(), itLocalVar_509e!= _localVar_5098.end(), itContext_50a7!= _context_50a1.end(), itUnaryExprs_50b0!= _unaryExprs_50aa.end(); ++itEvent_508c, ++itArgDeclBase_5095, ++itLocalVar_509e, ++itContext_50a7, ++itUnaryExprs_50b0)
	{
		if( ( *itEvent_508c== event_508a)&& ( *itArgDeclBase_5095== argDeclBase_5093)&& ( *itLocalVar_509e== localVar_509c)&& ( *itContext_50a7== context_50a5)&& ( *itUnaryExprs_50b0== unaryExprs_50ae))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_event_5086.push_back( event_508a);
		_argDeclBase_508f.push_back( argDeclBase_5093);
		_localVar_5098.push_back( localVar_509c);
		_context_50a1.push_back( context_50a5);
		_unaryExprs_50aa.push_back( unaryExprs_50ae);
	}
	return isUnique;
}

bool EitherEdge_5073::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool EitherEdge_5073::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, SFC::Arg& Context, CyberComposition::Simulink::Event& Event, SFC::LocalVar& LocalVar, SFC::UnaryExprs& UnaryExprs)
{
	bool Gz_guard= false;
	std::string trigger = Event.Trigger();
Gz_guard = trigger == "EITHER_EDGE_EVENT";;
	return Gz_guard;
}

void EitherEdge_5073::processInputPackets( const Packets_t& events_5074, const Packets_t& argDeclBases_5076, const Packets_t& localVars_5079, const Packets_t& contexts_507c, const Packets_t& unaryExprss_507f)
{
	for( Packets_t::const_iterator itEvent_5087= events_5074.begin(), itArgDeclBase_5090= argDeclBases_5076.begin(), itLocalVar_5099= localVars_5079.begin(), itContext_50a2= contexts_507c.begin(), itUnaryExprs_50ab= unaryExprss_507f.begin(); itEvent_5087!= events_5074.end(), itArgDeclBase_5090!= argDeclBases_5076.end(), itLocalVar_5099!= localVars_5079.end(), itContext_50a2!= contexts_507c.end(), itUnaryExprs_50ab!= unaryExprss_507f.end(); ++itEvent_5087, ++itArgDeclBase_5090, ++itLocalVar_5099, ++itContext_50a2, ++itUnaryExprs_50ab)
	{
		bool isUnique= isInputUnique( *itEvent_5087, *itArgDeclBase_5090, *itLocalVar_5099, *itContext_50a2, *itUnaryExprs_50ab);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itEvent_5087, *itArgDeclBase_5090, *itLocalVar_5099, *itContext_50a2, *itUnaryExprs_50ab);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_50b8, currMatch.localVar_50b9, currMatch.context_50ba, currMatch.unaryExprs_50bb);
	}
}

bool EitherEdge_5073::patternMatcher( const Udm::Object& event_5088, const Udm::Object& argDeclBase_5091, const Udm::Object& localVar_509a, const Udm::Object& context_50a3, const Udm::Object& unaryExprs_50ac)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( event_5088.type(), CyberComposition::Simulink::Event::meta))
			continue;
		CyberComposition::Simulink::Event event_508d= CyberComposition::Simulink::Event::Cast( event_5088);
		if( false== Uml::IsDerivedFrom( argDeclBase_5091.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_5096= SFC::ArgDeclBase::Cast( argDeclBase_5091);
		if( false== Uml::IsDerivedFrom( localVar_509a.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_509f= SFC::LocalVar::Cast( localVar_509a);
		if( false== Uml::IsDerivedFrom( context_50a3.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_50a8= SFC::Arg::Cast( context_50a3);
		if( false== Uml::IsDerivedFrom( unaryExprs_50ac.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_50b1= SFC::UnaryExprs::Cast( unaryExprs_50ac);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_50b6;
		if( !isValidBound(boundObjs_50b6, event_508d, true))
			continue;
		currMatch.event_50b7= event_508d;
		if( !isValidBound(boundObjs_50b6, argDeclBase_5096, true))
			continue;
		currMatch.argDeclBase_50b8= argDeclBase_5096;
		if( !isValidBound(boundObjs_50b6, localVar_509f, true))
			continue;
		currMatch.localVar_50b9= localVar_509f;
		if( !isValidBound(boundObjs_50b6, context_50a8, true))
			continue;
		currMatch.context_50ba= context_50a8;
		if( !isValidBound(boundObjs_50b6, unaryExprs_50b1, true))
			continue;
		currMatch.unaryExprs_50bb= unaryExprs_50b1;
		bool Gz_guard= isGuardTrue( currMatch.argDeclBase_50b8, currMatch.context_50ba, currMatch.event_50b7, currMatch.localVar_50b9, currMatch.unaryExprs_50bb);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void EitherEdge_5073::outputAppender( const SFC::ArgDeclBase& argDeclBase_50c1, const SFC::LocalVar& localVar_50c3, const SFC::Arg& context_50c5, const SFC::UnaryExprs& unaryExprs_50c7)
{
	_argDeclBase_5082->push_back( argDeclBase_50c1);
	_localVar_5083->push_back( localVar_50c3);
	_context_5084->push_back( context_50c5);
	_unaryExprs_5085->push_back( unaryExprs_50c7);
}

void FallingEdge_50c9::operator()( const Packets_t& argDeclBases_50ca, const Packets_t& localVars_50cc, const Packets_t& contexts_50ce, const Packets_t& unaryExprss_50d0)
{
#ifdef PRINT_INFO
	printLog( "FallingEdge_50c9" );
#endif
	RTTGenerator::Instance()->generateRule(4597, "FallingEdge");
	processInputPackets( argDeclBases_50ca, localVars_50cc, contexts_50ce, unaryExprss_50d0);
}

bool FallingEdge_50c9::isInputUnique( const Udm::Object& argDeclBase_50d6, const Udm::Object& localVar_50df, const Udm::Object& context_50e8, const Udm::Object& unaryExprs_50f1)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_50d8= _argDeclBase_50d2.begin(), itLocalVar_50e1= _localVar_50db.begin(), itContext_50ea= _context_50e4.begin(), itUnaryExprs_50f3= _unaryExprs_50ed.begin(); itArgDeclBase_50d8!= _argDeclBase_50d2.end(), itLocalVar_50e1!= _localVar_50db.end(), itContext_50ea!= _context_50e4.end(), itUnaryExprs_50f3!= _unaryExprs_50ed.end(); ++itArgDeclBase_50d8, ++itLocalVar_50e1, ++itContext_50ea, ++itUnaryExprs_50f3)
	{
		if( ( *itArgDeclBase_50d8== argDeclBase_50d6)&& ( *itLocalVar_50e1== localVar_50df)&& ( *itContext_50ea== context_50e8)&& ( *itUnaryExprs_50f3== unaryExprs_50f1))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_50d2.push_back( argDeclBase_50d6);
		_localVar_50db.push_back( localVar_50df);
		_context_50e4.push_back( context_50e8);
		_unaryExprs_50ed.push_back( unaryExprs_50f1);
	}
	return isUnique;
}

bool FallingEdge_50c9::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void FallingEdge_50c9::processInputPackets( const Packets_t& argDeclBases_50ca, const Packets_t& localVars_50cc, const Packets_t& contexts_50ce, const Packets_t& unaryExprss_50d0)
{
	for( Packets_t::const_iterator itArgDeclBase_50d3= argDeclBases_50ca.begin(), itLocalVar_50dc= localVars_50cc.begin(), itContext_50e5= contexts_50ce.begin(), itUnaryExprs_50ee= unaryExprss_50d0.begin(); itArgDeclBase_50d3!= argDeclBases_50ca.end(), itLocalVar_50dc!= localVars_50cc.end(), itContext_50e5!= contexts_50ce.end(), itUnaryExprs_50ee!= unaryExprss_50d0.end(); ++itArgDeclBase_50d3, ++itLocalVar_50dc, ++itContext_50e5, ++itUnaryExprs_50ee)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_50d3, *itLocalVar_50dc, *itContext_50e5, *itUnaryExprs_50ee);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_50d3, *itLocalVar_50dc, *itContext_50e5, *itUnaryExprs_50ee);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool FallingEdge_50c9::patternMatcher( const Udm::Object& argDeclBase_50d4, const Udm::Object& localVar_50dd, const Udm::Object& context_50e6, const Udm::Object& unaryExprs_50ef)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_50d4.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_50d9= SFC::ArgDeclBase::Cast( argDeclBase_50d4);
		if( false== Uml::IsDerivedFrom( localVar_50dd.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_50e2= SFC::LocalVar::Cast( localVar_50dd);
		if( false== Uml::IsDerivedFrom( context_50e6.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_50eb= SFC::Arg::Cast( context_50e6);
		if( false== Uml::IsDerivedFrom( unaryExprs_50ef.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_50f4= SFC::UnaryExprs::Cast( unaryExprs_50ef);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_50f9;
		if( !isValidBound(boundObjs_50f9, argDeclBase_50d9, true))
			continue;
		currMatch.argDeclBase_50fa= argDeclBase_50d9;
		if( !isValidBound(boundObjs_50f9, localVar_50e2, true))
			continue;
		currMatch.localVar_50fb= localVar_50e2;
		if( !isValidBound(boundObjs_50f9, context_50eb, true))
			continue;
		currMatch.context_50fc= context_50eb;
		if( !isValidBound(boundObjs_50f9, unaryExprs_50f4, true))
			continue;
		currMatch.unaryExprs_50fd= unaryExprs_50f4;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void FallingEdge_50c9::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newAnd_50fe= SFC::BinaryExprs::Create( currMatch.unaryExprs_50fd, SFC::UnaryExprs::meta_subexpr);
		SFC::BinaryExprs newGreaterThan_50ff= SFC::BinaryExprs::Create( newAnd_50fe, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newZero_5100= SFC::Int::Create( newGreaterThan_50ff, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newDot_5101= SFC::BinaryExprs::Create( newGreaterThan_50ff, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_5102= SFC::ArgDeclRef::Create( newDot_5101, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef3_5103= SFC::ArgDeclRef::Create( newDot_5101, SFC::BinaryExprs::meta_leftexpr);
		SFC::BinaryExprs newLessThan_5104= SFC::BinaryExprs::Create( newAnd_50fe, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_5105= SFC::ArgDeclRef::Create( newLessThan_5104, SFC::BinaryExprs::meta_leftexpr);
		SFC::Int newZero2_5106= SFC::Int::Create( newLessThan_5104, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs& And= newAnd_50fe;
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_50fa;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_5105;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_5102;
		SFC::ArgDeclRef& ArgDeclRef3= newArgDeclRef3_5103;
		SFC::Arg& Context= currMatch.context_50fc;
		SFC::BinaryExprs& Dot= newDot_5101;
		SFC::BinaryExprs& GreaterThan= newGreaterThan_50ff;
		SFC::BinaryExprs& LessThan= newLessThan_5104;
		SFC::LocalVar& LocalVar= currMatch.localVar_50fb;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_50fd;
		SFC::Int& Zero= newZero_5100;
		SFC::Int& Zero2= newZero2_5106;
		{
GreaterThan.op() = ">=";
};
		{
LessThan.op() = "<";
};
		{
And.op() = "&&";
};
		{
Dot.op() = ".";
};
		{
Zero.val() = 0;
};
		{
Zero2.val() = 0;
};
		newArgDeclRef_5105.argdecl()= currMatch.argDeclBase_50fa;
		newArgDeclRef3_5103.argdecl()= currMatch.context_50fc;
		newArgDeclRef2_5102.argdecl()= currMatch.localVar_50fb;
	}
}

void EitherEdge_5107::operator()( const Packets_t& argDeclBases_5108, const Packets_t& localVars_510b, const Packets_t& contexts_510e, const Packets_t& unaryExprss_5111, Packets_t& argDeclBases_510a, Packets_t& localVars_510d, Packets_t& contexts_5110, Packets_t& leftUnaryExprss_5113, Packets_t& rightUnaryExprss_5114)
{
#ifdef PRINT_INFO
	printLog( "EitherEdge_5107" );
#endif
	RTTGenerator::Instance()->generateRule(4629, "EitherEdge");
	_argDeclBase_5115= &argDeclBases_510a;
	_localVar_5116= &localVars_510d;
	_context_5117= &contexts_5110;
	_leftUnaryExprs_5118= &leftUnaryExprss_5113;
	_rightUnaryExprs_5119= &rightUnaryExprss_5114;
	processInputPackets( argDeclBases_5108, localVars_510b, contexts_510e, unaryExprss_5111);
}

bool EitherEdge_5107::isInputUnique( const Udm::Object& argDeclBase_511e, const Udm::Object& localVar_5127, const Udm::Object& context_5130, const Udm::Object& unaryExprs_5139)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_5120= _argDeclBase_511a.begin(), itLocalVar_5129= _localVar_5123.begin(), itContext_5132= _context_512c.begin(), itUnaryExprs_513b= _unaryExprs_5135.begin(); itArgDeclBase_5120!= _argDeclBase_511a.end(), itLocalVar_5129!= _localVar_5123.end(), itContext_5132!= _context_512c.end(), itUnaryExprs_513b!= _unaryExprs_5135.end(); ++itArgDeclBase_5120, ++itLocalVar_5129, ++itContext_5132, ++itUnaryExprs_513b)
	{
		if( ( *itArgDeclBase_5120== argDeclBase_511e)&& ( *itLocalVar_5129== localVar_5127)&& ( *itContext_5132== context_5130)&& ( *itUnaryExprs_513b== unaryExprs_5139))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_511a.push_back( argDeclBase_511e);
		_localVar_5123.push_back( localVar_5127);
		_context_512c.push_back( context_5130);
		_unaryExprs_5135.push_back( unaryExprs_5139);
	}
	return isUnique;
}

bool EitherEdge_5107::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void EitherEdge_5107::processInputPackets( const Packets_t& argDeclBases_5108, const Packets_t& localVars_510b, const Packets_t& contexts_510e, const Packets_t& unaryExprss_5111)
{
	for( Packets_t::const_iterator itArgDeclBase_511b= argDeclBases_5108.begin(), itLocalVar_5124= localVars_510b.begin(), itContext_512d= contexts_510e.begin(), itUnaryExprs_5136= unaryExprss_5111.begin(); itArgDeclBase_511b!= argDeclBases_5108.end(), itLocalVar_5124!= localVars_510b.end(), itContext_512d!= contexts_510e.end(), itUnaryExprs_5136!= unaryExprss_5111.end(); ++itArgDeclBase_511b, ++itLocalVar_5124, ++itContext_512d, ++itUnaryExprs_5136)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_511b, *itLocalVar_5124, *itContext_512d, *itUnaryExprs_5136);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_511b, *itLocalVar_5124, *itContext_512d, *itUnaryExprs_5136);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool EitherEdge_5107::patternMatcher( const Udm::Object& argDeclBase_511c, const Udm::Object& localVar_5125, const Udm::Object& context_512e, const Udm::Object& unaryExprs_5137)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_511c.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_5121= SFC::ArgDeclBase::Cast( argDeclBase_511c);
		if( false== Uml::IsDerivedFrom( localVar_5125.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_512a= SFC::LocalVar::Cast( localVar_5125);
		if( false== Uml::IsDerivedFrom( context_512e.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_5133= SFC::Arg::Cast( context_512e);
		if( false== Uml::IsDerivedFrom( unaryExprs_5137.type(), SFC::UnaryExprs::meta))
			continue;
		SFC::UnaryExprs unaryExprs_513c= SFC::UnaryExprs::Cast( unaryExprs_5137);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5141;
		if( !isValidBound(boundObjs_5141, argDeclBase_5121, true))
			continue;
		currMatch.argDeclBase_5142= argDeclBase_5121;
		if( !isValidBound(boundObjs_5141, localVar_512a, true))
			continue;
		currMatch.localVar_5143= localVar_512a;
		if( !isValidBound(boundObjs_5141, context_5133, true))
			continue;
		currMatch.context_5144= context_5133;
		if( !isValidBound(boundObjs_5141, unaryExprs_513c, true))
			continue;
		currMatch.unaryExprs_5145= unaryExprs_513c;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void EitherEdge_5107::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newOr_5146= SFC::BinaryExprs::Create( currMatch.unaryExprs_5145, SFC::UnaryExprs::meta_subexpr);
		SFC::UnaryExprs newRightUnaryExprs_5147= SFC::UnaryExprs::Create( newOr_5146, SFC::BinaryExprs::meta_rightexpr);
		SFC::UnaryExprs newLeftUnaryExprs_5148= SFC::UnaryExprs::Create( newOr_5146, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_5142;
		SFC::Arg& Context= currMatch.context_5144;
		SFC::UnaryExprs& LeftUnaryExprs= newLeftUnaryExprs_5148;
		SFC::LocalVar& LocalVar= currMatch.localVar_5143;
		SFC::BinaryExprs& Or= newOr_5146;
		SFC::UnaryExprs& RightUnaryExprs= newRightUnaryExprs_5147;
		SFC::UnaryExprs& UnaryExprs= currMatch.unaryExprs_5145;
		{
RightUnaryExprs.op() = "";
};
		{
LeftUnaryExprs.op() = "";
};
		{
Or.op() = "||";
};
		outputAppender( currMatch.argDeclBase_5142, currMatch.localVar_5143, currMatch.context_5144, newLeftUnaryExprs_5148, newRightUnaryExprs_5147);
	}
}

void EitherEdge_5107::outputAppender( const SFC::ArgDeclBase& argDeclBase_5149, const SFC::LocalVar& localVar_514b, const SFC::Arg& context_514d, const SFC::UnaryExprs& leftUnaryExprs_514f, const SFC::UnaryExprs& rightUnaryExprs_5151)
{
	_argDeclBase_5115->push_back( argDeclBase_5149);
	_localVar_5116->push_back( localVar_514b);
	_context_5117->push_back( context_514d);
	_leftUnaryExprs_5118->push_back( leftUnaryExprs_514f);
	_rightUnaryExprs_5119->push_back( rightUnaryExprs_5151);
}

void StartAssignment_5153::operator()( const Packets_t& charts_5155, const Packets_t& argDeclBases_5157, const Packets_t& oldvals_515a, const Packets_t& contexts_515d, const Packets_t& triggerVars_5160, const Packets_t& functions_5162, Packets_t& events_5154, Packets_t& argDeclBases_5159, Packets_t& oldvals_515c, Packets_t& contexts_515f, Packets_t& unaryExprss_5164)
{
#ifdef PRINT_INFO
	printLog( "StartAssignment_5153" );
#endif
	RTTGenerator::Instance()->generateRule(4643, "StartAssignment");
	_event_5165= &events_5154;
	_argDeclBase_5166= &argDeclBases_5159;
	_oldval_5167= &oldvals_515c;
	_context_5168= &contexts_515f;
	_unaryExprs_5169= &unaryExprss_5164;
	processInputPackets( charts_5155, argDeclBases_5157, oldvals_515a, contexts_515d, triggerVars_5160, functions_5162);
}

bool StartAssignment_5153::isInputUnique( const Udm::Object& chart_516e, const Udm::Object& argDeclBase_5177, const Udm::Object& oldval_5180, const Udm::Object& context_5189, const Udm::Object& triggerVar_5192, const Udm::Object& function_519b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itChart_5170= _chart_516a.begin(), itArgDeclBase_5179= _argDeclBase_5173.begin(), itoldval_5182= _oldval_517c.begin(), itContext_518b= _context_5185.begin(), itTriggerVar_5194= _triggerVar_518e.begin(), itFunction_519d= _function_5197.begin(); itChart_5170!= _chart_516a.end(), itArgDeclBase_5179!= _argDeclBase_5173.end(), itoldval_5182!= _oldval_517c.end(), itContext_518b!= _context_5185.end(), itTriggerVar_5194!= _triggerVar_518e.end(), itFunction_519d!= _function_5197.end(); ++itChart_5170, ++itArgDeclBase_5179, ++itoldval_5182, ++itContext_518b, ++itTriggerVar_5194, ++itFunction_519d)
	{
		if( ( *itChart_5170== chart_516e)&& ( *itArgDeclBase_5179== argDeclBase_5177)&& ( *itoldval_5182== oldval_5180)&& ( *itContext_518b== context_5189)&& ( *itTriggerVar_5194== triggerVar_5192)&& ( *itFunction_519d== function_519b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_chart_516a.push_back( chart_516e);
		_argDeclBase_5173.push_back( argDeclBase_5177);
		_oldval_517c.push_back( oldval_5180);
		_context_5185.push_back( context_5189);
		_triggerVar_518e.push_back( triggerVar_5192);
		_function_5197.push_back( function_519b);
	}
	return isUnique;
}

bool StartAssignment_5153::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool StartAssignment_5153::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, CyberComposition::Simulink::Subsystem& Chart, SFC::Arg& Context, CyberComposition::Simulink::Event& Event, SFC::Function& Function, CyberComposition::Simulink::Primitive& Primitive, CyberComposition::Simulink::State& State, SFC::LocalVar& TriggerVar, SFC::LocalVar& oldval)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< std::string >( Event.Scope() ) == "INPUT_EVENT";;
	return Gz_guard;
}

void StartAssignment_5153::processInputPackets( const Packets_t& charts_5155, const Packets_t& argDeclBases_5157, const Packets_t& oldvals_515a, const Packets_t& contexts_515d, const Packets_t& triggerVars_5160, const Packets_t& functions_5162)
{
	for( Packets_t::const_iterator itChart_516b= charts_5155.begin(), itArgDeclBase_5174= argDeclBases_5157.begin(), itoldval_517d= oldvals_515a.begin(), itContext_5186= contexts_515d.begin(), itTriggerVar_518f= triggerVars_5160.begin(), itFunction_5198= functions_5162.begin(); itChart_516b!= charts_5155.end(), itArgDeclBase_5174!= argDeclBases_5157.end(), itoldval_517d!= oldvals_515a.end(), itContext_5186!= contexts_515d.end(), itTriggerVar_518f!= triggerVars_5160.end(), itFunction_5198!= functions_5162.end(); ++itChart_516b, ++itArgDeclBase_5174, ++itoldval_517d, ++itContext_5186, ++itTriggerVar_518f, ++itFunction_5198)
	{
		bool isUnique= isInputUnique( *itChart_516b, *itArgDeclBase_5174, *itoldval_517d, *itContext_5186, *itTriggerVar_518f, *itFunction_5198);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itChart_516b, *itArgDeclBase_5174, *itoldval_517d, *itContext_5186, *itTriggerVar_518f, *itFunction_5198);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool StartAssignment_5153::patternMatcher( const Udm::Object& chart_516c, const Udm::Object& argDeclBase_5175, const Udm::Object& oldval_517e, const Udm::Object& context_5187, const Udm::Object& triggerVar_5190, const Udm::Object& function_5199)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( chart_516c.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem chart_5171= CyberComposition::Simulink::Subsystem::Cast( chart_516c);
		if( false== Uml::IsDerivedFrom( argDeclBase_5175.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_517a= SFC::ArgDeclBase::Cast( argDeclBase_5175);
		if( false== Uml::IsDerivedFrom( oldval_517e.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar oldval_5183= SFC::LocalVar::Cast( oldval_517e);
		if( false== Uml::IsDerivedFrom( context_5187.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_518c= SFC::Arg::Cast( context_5187);
		if( false== Uml::IsDerivedFrom( triggerVar_5190.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar triggerVar_5195= SFC::LocalVar::Cast( triggerVar_5190);
		if( false== Uml::IsDerivedFrom( function_5199.type(), SFC::Function::meta))
			continue;
		SFC::Function function_519e= SFC::Function::Cast( function_5199);
		set< CyberComposition::Simulink::Primitive> primitives_51a0= chart_5171.Primitive_kind_children();
		for( set< CyberComposition::Simulink::Primitive>::const_iterator itPrimitive_51a1= primitives_51a0.begin(); itPrimitive_51a1!= primitives_51a0.end(); ++itPrimitive_51a1)
		{
			CyberComposition::Simulink::Primitive currPrimitive_51a2= *itPrimitive_51a1;
			set< CyberComposition::Simulink::State> states_51a3= currPrimitive_51a2.State_kind_children();
			for( set< CyberComposition::Simulink::State>::const_iterator itState_51a4= states_51a3.begin(); itState_51a4!= states_51a3.end(); ++itState_51a4)
			{
				CyberComposition::Simulink::State currState_51a5= *itState_51a4;
				set< CyberComposition::Simulink::Event> events_51a6= currState_51a5.Event_kind_children();
				for( set< CyberComposition::Simulink::Event>::const_iterator itEvent_51a7= events_51a6.begin(); itEvent_51a7!= events_51a6.end(); ++itEvent_51a7)
				{
					CyberComposition::Simulink::Event currEvent_51a8= *itEvent_51a7;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_51ac;
					if( !isValidBound(boundObjs_51ac, chart_5171, true))
						continue;
					currMatch.chart_51ad= chart_5171;
					if( !isValidBound(boundObjs_51ac, argDeclBase_517a, true))
						continue;
					currMatch.argDeclBase_51ae= argDeclBase_517a;
					if( !isValidBound(boundObjs_51ac, oldval_5183, true))
						continue;
					currMatch.oldval_51af= oldval_5183;
					if( !isValidBound(boundObjs_51ac, context_518c, true))
						continue;
					currMatch.context_51b0= context_518c;
					if( !isValidBound(boundObjs_51ac, triggerVar_5195, true))
						continue;
					currMatch.triggerVar_51b1= triggerVar_5195;
					if( !isValidBound(boundObjs_51ac, function_519e, true))
						continue;
					currMatch.function_51b2= function_519e;
					if( !isValidBound(boundObjs_51ac, currState_51a5, false))
						continue;
					currMatch.state_51b3= currState_51a5;
					if( !isValidBound(boundObjs_51ac, currEvent_51a8, false))
						continue;
					currMatch.event_51b4= currEvent_51a8;
					if( !isValidBound(boundObjs_51ac, currPrimitive_51a2, false))
						continue;
					currMatch.primitive_51b5= currPrimitive_51a2;
					bool Gz_guard= isGuardTrue( currMatch.argDeclBase_51ae, currMatch.chart_51ad, currMatch.context_51b0, currMatch.event_51b4, currMatch.function_51b2, currMatch.primitive_51b5, currMatch.state_51b3, currMatch.triggerVar_51b1, currMatch.oldval_51af);
					if( true== Gz_guard)
						_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void StartAssignment_5153::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::UserCode newAssignment_51bf= SFC::UserCode::Create( currMatch.function_51b2, SFC::Function::meta_stmnt);
		SFC::BinaryExprs newAssign_51c0= SFC::BinaryExprs::Create( newAssignment_51bf, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newArgDeclRef_51c1= SFC::ArgDeclRef::Create( newAssign_51c0, SFC::BinaryExprs::meta_leftexpr);
		SFC::UnaryExprs newUnaryExprs_51c2= SFC::UnaryExprs::Create( newAssign_51c0, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_51ae;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_51c1;
		SFC::BinaryExprs& Assign= newAssign_51c0;
		SFC::UserCode& Assignment= newAssignment_51bf;
		CyberComposition::Simulink::Subsystem& Chart= currMatch.chart_51ad;
		SFC::Arg& Context= currMatch.context_51b0;
		CyberComposition::Simulink::Event& Event= currMatch.event_51b4;
		SFC::Function& Function= currMatch.function_51b2;
		CyberComposition::Simulink::Primitive& Primitive= currMatch.primitive_51b5;
		CyberComposition::Simulink::State& State= currMatch.state_51b3;
		SFC::LocalVar& TriggerVar= currMatch.triggerVar_51b1;
		SFC::UnaryExprs& UnaryExprs= newUnaryExprs_51c2;
		SFC::LocalVar& oldval= currMatch.oldval_51af;
		{
UnaryExprs.op() = "";
};
		{
__int64 statementCount = Function.statementCount();
Assignment.statementIndex() = statementCount++;
Function.statementCount() = statementCount;
};
		{
Assign.op() = "=";
};
		newArgDeclRef_51c1.argdecl()= currMatch.triggerVar_51b1;
		outputAppender( currMatch.event_51b4, currMatch.argDeclBase_51ae, currMatch.oldval_51af, currMatch.context_51b0, newUnaryExprs_51c2);
	}
}

void StartAssignment_5153::outputAppender( const CyberComposition::Simulink::Event& event_51c3, const SFC::ArgDeclBase& argDeclBase_51c5, const SFC::LocalVar& oldval_51c7, const SFC::Arg& context_51c9, const SFC::UnaryExprs& unaryExprs_51cb)
{
	_event_5165->push_back( event_51c3);
	_argDeclBase_5166->push_back( argDeclBase_51c5);
	_oldval_5167->push_back( oldval_51c7);
	_context_5168->push_back( context_51c9);
	_unaryExprs_5169->push_back( unaryExprs_51cb);
}

void GetState_523a::operator()( const Packets_t& subsystems_523b, const Packets_t& charts_523e, const Packets_t& mains_5242, const Packets_t& functionCalls_5245, Packets_t& subsystems_523d, Packets_t& charts_5240, Packets_t& states_5241, Packets_t& mains_5244, Packets_t& functionCalls_5247)
{
#ifdef PRINT_INFO
	printLog( "GetState_523a" );
#endif
	RTTGenerator::Instance()->generateRule(4668, "GetState");
	_subsystem_5248= &subsystems_523d;
	_chart_5249= &charts_5240;
	_state_524a= &states_5241;
	_main_524b= &mains_5244;
	_functionCall_524c= &functionCalls_5247;
	processInputPackets( subsystems_523b, charts_523e, mains_5242, functionCalls_5245);
}

bool GetState_523a::isInputUnique( const Udm::Object& subsystem_5251, const Udm::Object& chart_525a, const Udm::Object& main_5263, const Udm::Object& functionCall_526c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_5253= _subsystem_524d.begin(), itChart_525c= _chart_5256.begin(), itMain_5265= _main_525f.begin(), itFunctionCall_526e= _functionCall_5268.begin(); itSubsystem_5253!= _subsystem_524d.end(), itChart_525c!= _chart_5256.end(), itMain_5265!= _main_525f.end(), itFunctionCall_526e!= _functionCall_5268.end(); ++itSubsystem_5253, ++itChart_525c, ++itMain_5265, ++itFunctionCall_526e)
	{
		if( ( *itSubsystem_5253== subsystem_5251)&& ( *itChart_525c== chart_525a)&& ( *itMain_5265== main_5263)&& ( *itFunctionCall_526e== functionCall_526c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_524d.push_back( subsystem_5251);
		_chart_5256.push_back( chart_525a);
		_main_525f.push_back( main_5263);
		_functionCall_5268.push_back( functionCall_526c);
	}
	return isUnique;
}

bool GetState_523a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetState_523a::processInputPackets( const Packets_t& subsystems_523b, const Packets_t& charts_523e, const Packets_t& mains_5242, const Packets_t& functionCalls_5245)
{
	for( Packets_t::const_iterator itSubsystem_524e= subsystems_523b.begin(), itChart_5257= charts_523e.begin(), itMain_5260= mains_5242.begin(), itFunctionCall_5269= functionCalls_5245.begin(); itSubsystem_524e!= subsystems_523b.end(), itChart_5257!= charts_523e.end(), itMain_5260!= mains_5242.end(), itFunctionCall_5269!= functionCalls_5245.end(); ++itSubsystem_524e, ++itChart_5257, ++itMain_5260, ++itFunctionCall_5269)
	{
		bool isUnique= isInputUnique( *itSubsystem_524e, *itChart_5257, *itMain_5260, *itFunctionCall_5269);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_524e, *itChart_5257, *itMain_5260, *itFunctionCall_5269);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetState_523a::patternMatcher( const Udm::Object& subsystem_524f, const Udm::Object& chart_5258, const Udm::Object& main_5261, const Udm::Object& functionCall_526a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_524f.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_5254= CyberComposition::Simulink::Subsystem::Cast( subsystem_524f);
		if( false== Uml::IsDerivedFrom( chart_5258.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem chart_525d= CyberComposition::Simulink::Subsystem::Cast( chart_5258);
		if( false== Uml::IsDerivedFrom( main_5261.type(), SFC::Function::meta))
			continue;
		SFC::Function main_5266= SFC::Function::Cast( main_5261);
		if( false== Uml::IsDerivedFrom( functionCall_526a.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall functionCall_526f= SFC::FunctionCall::Cast( functionCall_526a);
		set< CyberComposition::Simulink::SFState> states_5271= chart_525d.SFState_kind_children();
		for( set< CyberComposition::Simulink::SFState>::const_iterator itState_5272= states_5271.begin(); itState_5272!= states_5271.end(); ++itState_5272)
		{
			CyberComposition::Simulink::SFState currState_5273= *itState_5272;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_5277;
			if( !isValidBound(boundObjs_5277, subsystem_5254, true))
				continue;
			currMatch.subsystem_5278= subsystem_5254;
			if( !isValidBound(boundObjs_5277, chart_525d, true))
				continue;
			currMatch.chart_5279= chart_525d;
			if( !isValidBound(boundObjs_5277, main_5266, true))
				continue;
			currMatch.main_527a= main_5266;
			if( !isValidBound(boundObjs_5277, functionCall_526f, true))
				continue;
			currMatch.functionCall_527b= functionCall_526f;
			if( !isValidBound(boundObjs_5277, currState_5273, false))
				continue;
			currMatch.state_527c= currState_5273;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetState_523a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		CyberComposition::Simulink::Subsystem& Chart= currMatch.chart_5279;
		SFC::FunctionCall& FunctionCall= currMatch.functionCall_527b;
		SFC::Function& Main= currMatch.main_527a;
		CyberComposition::Simulink::SFState& State= currMatch.state_527c;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_5278;
		{
std::string fname = State.name();
fname += "_main";
FunctionCall.libFuncName() = fname;
 
};
		outputAppender( currMatch.subsystem_5278, currMatch.chart_5279, currMatch.state_527c, currMatch.main_527a, currMatch.functionCall_527b);
	}
}

void GetState_523a::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_527d, const CyberComposition::Simulink::Subsystem& chart_527f, const CyberComposition::Simulink::SFState& state_5281, const SFC::Function& main_5283, const SFC::FunctionCall& functionCall_5285)
{
	_subsystem_5248->push_back( subsystem_527d);
	_chart_5249->push_back( chart_527f);
	_state_524a->push_back( state_5281);
	_main_524b->push_back( main_5283);
	_functionCall_524c->push_back( functionCall_5285);
}

void GetBlocks_52ee::operator()( const Packets_t& comptypes_52ef, const Packets_t& projects_52f1, Packets_t& subsystems_52f3, Packets_t& projects_52f4)
{
#ifdef PRINT_INFO
	printLog( "GetBlocks_52ee" );
#endif
	_subsystem_52f5= &subsystems_52f3;
	_project_52f6= &projects_52f4;
	if( ( !comptypes_52ef.empty())&& ( !projects_52f1.empty()))
		callGetSubSystems_5320( comptypes_52ef, projects_52f1);
}

void GetBlocks_52ee::callGetSubSystems_5320( const Packets_t& dataflows_52f8, const Packets_t& projects_52fb)
{
	Packets_t subsystems_52fa;
	Packets_t projects_52fd;
	GetSubSystems_52f7 getSubSystems_52f7;
	getSubSystems_52f7( dataflows_52f8, projects_52fb, subsystems_52fa, projects_52fd);
	_subsystem_52f5->insert( _subsystem_52f5->end(), subsystems_52fa.begin(), subsystems_52fa.end());
	_project_52f6->insert( _project_52f6->end(), projects_52fd.begin(), projects_52fd.end());
}

void GetSubSystems_52f7::operator()( const Packets_t& dataflows_52f8, const Packets_t& projects_52fb, Packets_t& subsystems_52fa, Packets_t& projects_52fd)
{
#ifdef PRINT_INFO
	printLog( "GetSubSystems_52f7" );
#endif
	RTTGenerator::Instance()->generateRule(1622, "GetSubSystems");
	_subsystem_52fe= &subsystems_52fa;
	_project_52ff= &projects_52fd;
	processInputPackets( dataflows_52f8, projects_52fb);
}

bool GetSubSystems_52f7::isInputUnique( const Udm::Object& dataflow_5304, const Udm::Object& project_530d)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itDataflow_5306= _dataflow_5300.begin(), itProject_530f= _project_5309.begin(); itDataflow_5306!= _dataflow_5300.end(), itProject_530f!= _project_5309.end(); ++itDataflow_5306, ++itProject_530f)
	{
		if( ( *itDataflow_5306== dataflow_5304)&& ( *itProject_530f== project_530d))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_dataflow_5300.push_back( dataflow_5304);
		_project_5309.push_back( project_530d);
	}
	return isUnique;
}

bool GetSubSystems_52f7::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetSubSystems_52f7::processInputPackets( const Packets_t& dataflows_52f8, const Packets_t& projects_52fb)
{
	for( Packets_t::const_iterator itDataflow_5301= dataflows_52f8.begin(), itProject_530a= projects_52fb.begin(); itDataflow_5301!= dataflows_52f8.end(), itProject_530a!= projects_52fb.end(); ++itDataflow_5301, ++itProject_530a)
	{
		bool isUnique= isInputUnique( *itDataflow_5301, *itProject_530a);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itDataflow_5301, *itProject_530a);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetSubSystems_52f7::patternMatcher( const Udm::Object& dataflow_5302, const Udm::Object& project_530b)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( dataflow_5302.type(), CyberComposition::SimulinkWrapper::meta))
			continue;
		CyberComposition::SimulinkWrapper dataflow_5307= CyberComposition::SimulinkWrapper::Cast( dataflow_5302);
		if( false== Uml::IsDerivedFrom( project_530b.type(), SFC::Project::meta))
			continue;
		SFC::Project project_5310= SFC::Project::Cast( project_530b);
		set< CyberComposition::Simulink::Subsystem> subsystems_5312= dataflow_5307.Simulink_Subsystem_kind_children();
		for( set< CyberComposition::Simulink::Subsystem>::const_iterator itSubsystem_5313= subsystems_5312.begin(); itSubsystem_5313!= subsystems_5312.end(); ++itSubsystem_5313)
		{
			CyberComposition::Simulink::Subsystem currSubsystem_5314= *itSubsystem_5313;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_5318;
			if( !isValidBound(boundObjs_5318, dataflow_5307, true))
				continue;
			currMatch.dataflow_5319= dataflow_5307;
			if( !isValidBound(boundObjs_5318, project_5310, true))
				continue;
			currMatch.project_531a= project_5310;
			if( !isValidBound(boundObjs_5318, currSubsystem_5314, false))
				continue;
			currMatch.subsystem_531b= currSubsystem_5314;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetSubSystems_52f7::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_531b, currMatch.project_531a);
	}
}

void GetSubSystems_52f7::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_531c, const SFC::Project& project_531e)
{
	_subsystem_52fe->push_back( subsystem_531c);
	_project_52ff->push_back( project_531e);
}

void FinishClasses_5329::operator()( const Packets_t& dataflows_532a, const Packets_t& projects_532c, Packets_t& dataflows_532e, Packets_t& projects_532f)
{
#ifdef PRINT_INFO
	printLog( "FinishClasses_5329" );
#endif
	_dataflow_5330= &dataflows_532e;
	_project_5331= &projects_532f;
	_dataflow_5330->insert( _dataflow_5330->end(), dataflows_532a.begin(), dataflows_532a.end());
	_project_5331->insert( _project_5331->end(), projects_532c.begin(), projects_532c.end());
	if( ( !projects_532c.empty()))
		callGetClasses_557c( projects_532c);
}

void FinishClasses_5329::callGetClasses_557c( const Packets_t& projects_5333)
{
	Packets_t classs_5335;
	GetClasses_5332 getClasses_5332;
	getClasses_5332( projects_5333, classs_5335);
	if( ( !classs_5335.empty()))
		callAssignToOutArgs_557e( classs_5335);
}

void FinishClasses_5329::callAssignToOutArgs_557e( const Packets_t& classs_5536)
{
	Packets_t classs_5538;
	AssignToOutArgs_5535 assignToOutArgs_5535;
	assignToOutArgs_5535( classs_5536, classs_5538);
	if( ( !classs_5538.empty()))
		callFinalizeContext_5580( classs_5538);
}

void FinishClasses_5329::callFinalizeContext_5580( const Packets_t& classs_5459)
{
	Packets_t classs_545b;
	FinalizeContext_5458 finalizeContext_5458;
	finalizeContext_5458( classs_5459, classs_545b);
	if( ( !classs_545b.empty()))
		callAddContextArgs_5582( classs_545b);
}

void FinishClasses_5329::callAddContextArgs_5582( const Packets_t& classs_5350)
{
	AddContextArgs_534f addContextArgs_534f;
	addContextArgs_534f( classs_5350);
}

void GetClasses_5332::operator()( const Packets_t& projects_5333, Packets_t& classs_5335)
{
#ifdef PRINT_INFO
	printLog( "GetClasses_5332" );
#endif
	RTTGenerator::Instance()->generateRule(1632, "GetClasses");
	_class_5336= &classs_5335;
	processInputPackets( projects_5333);
}

bool GetClasses_5332::isInputUnique( const Udm::Object& project_533b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itProject_533d= _project_5337.begin(); itProject_533d!= _project_5337.end(); ++itProject_533d)
	{
		if( ( *itProject_533d== project_533b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_project_5337.push_back( project_533b);
	return isUnique;
}

bool GetClasses_5332::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetClasses_5332::processInputPackets( const Packets_t& projects_5333)
{
	for( Packets_t::const_iterator itProject_5338= projects_5333.begin(); itProject_5338!= projects_5333.end(); ++itProject_5338)
	{
		bool isUnique= isInputUnique( *itProject_5338);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itProject_5338);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetClasses_5332::patternMatcher( const Udm::Object& project_5339)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( project_5339.type(), SFC::Project::meta))
			continue;
		SFC::Project project_533e= SFC::Project::Cast( project_5339);
		set< SFC::Program> programs_5340= project_533e.Program_kind_children();
		for( set< SFC::Program>::const_iterator itProgram_5341= programs_5340.begin(); itProgram_5341!= programs_5340.end(); ++itProgram_5341)
		{
			SFC::Program currProgram_5342= *itProgram_5341;
			set< SFC::Class> classs_5343= currProgram_5342.Class_kind_children();
			for( set< SFC::Class>::const_iterator itClass_5344= classs_5343.begin(); itClass_5344!= classs_5343.end(); ++itClass_5344)
			{
				SFC::Class currClass_5345= *itClass_5344;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_5349;
				if( !isValidBound(boundObjs_5349, project_533e, true))
					continue;
				currMatch.project_534a= project_533e;
				if( !isValidBound(boundObjs_5349, currProgram_5342, false))
					continue;
				currMatch.program_534b= currProgram_5342;
				if( !isValidBound(boundObjs_5349, currClass_5345, false))
					continue;
				currMatch.class_534c= currClass_5345;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void GetClasses_5332::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.class_534c);
	}
}

void GetClasses_5332::outputAppender( const SFC::Class& class_534d)
{
	_class_5336->push_back( class_534d);
}

void AddContextArgs_534f::operator()( const Packets_t& classs_5350)
{
#ifdef PRINT_INFO
	printLog( "AddContextArgs_534f" );
#endif
	if( ( !classs_5350.empty()))
		callGetAllMethodCalls_5450( classs_5350);
}

void AddContextArgs_534f::callGetAllMethodCalls_5450( const Packets_t& classs_53a1)
{
	Packets_t methodcalls_53a3;
	Packets_t contextargs_53a4;
	Packets_t callerstructs_53a5;
	GetAllMethodCalls_53a0 getAllMethodCalls_53a0;
	getAllMethodCalls_53a0( classs_53a1, methodcalls_53a3, contextargs_53a4, callerstructs_53a5);
	if( ( !methodcalls_53a3.empty())&& ( !contextargs_53a4.empty()))
		callGetContextArg_5452( methodcalls_53a3, contextargs_53a4);
}

void AddContextArgs_534f::callGetContextArg_5452( const Packets_t& methodCalls_5380, const Packets_t& callerContextArgs_5383)
{
	Packets_t methodCalls_5382;
	Packets_t callerContextArgs_5385;
	GetContextArg_537f getContextArg_537f;
	getContextArg_537f( methodCalls_5380, callerContextArgs_5383, methodCalls_5382, callerContextArgs_5385);
	if( ( !methodCalls_5382.empty())&& ( !callerContextArgs_5385.empty()))
		calladdArgValExprs_5455( methodCalls_5382, callerContextArgs_5385);
}

void AddContextArgs_534f::calladdArgValExprs_5455( const Packets_t& methodCalls_5353, const Packets_t& callerContextArgs_5355)
{
	AddArgValExprs_5352 addArgValExprs_5352;
	addArgValExprs_5352( methodCalls_5353, callerContextArgs_5355);
}

void AddArgValExprs_5352::operator()( const Packets_t& methodCalls_5353, const Packets_t& callerContextArgs_5355)
{
#ifdef PRINT_INFO
	printLog( "AddArgValExprs_5352" );
#endif
	RTTGenerator::Instance()->generateRule(1640, "addArgValExprs");
	processInputPackets( methodCalls_5353, callerContextArgs_5355);
}

bool AddArgValExprs_5352::isInputUnique( const Udm::Object& methodCall_535b, const Udm::Object& callerContextArg_5364)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMethodCall_535d= _methodCall_5357.begin(), itCallerContextArg_5366= _callerContextArg_5360.begin(); itMethodCall_535d!= _methodCall_5357.end(), itCallerContextArg_5366!= _callerContextArg_5360.end(); ++itMethodCall_535d, ++itCallerContextArg_5366)
	{
		if( ( *itMethodCall_535d== methodCall_535b)&& ( *itCallerContextArg_5366== callerContextArg_5364))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_methodCall_5357.push_back( methodCall_535b);
		_callerContextArg_5360.push_back( callerContextArg_5364);
	}
	return isUnique;
}

bool AddArgValExprs_5352::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool AddArgValExprs_5352::isGuardTrue( SFC::ArgVal& ArgVal, SFC::Arg& CallerContextArg, SFC::LocalVar& LocalVar, SFC::FunctionCall& MethodCall, CyberComposition::Simulink::Subsystem& Subsystem)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< __int64 >( ArgVal.argIndex() ) == 0;;
	return Gz_guard;
}

void AddArgValExprs_5352::processInputPackets( const Packets_t& methodCalls_5353, const Packets_t& callerContextArgs_5355)
{
	for( Packets_t::const_iterator itMethodCall_5358= methodCalls_5353.begin(), itCallerContextArg_5361= callerContextArgs_5355.begin(); itMethodCall_5358!= methodCalls_5353.end(), itCallerContextArg_5361!= callerContextArgs_5355.end(); ++itMethodCall_5358, ++itCallerContextArg_5361)
	{
		bool isUnique= isInputUnique( *itMethodCall_5358, *itCallerContextArg_5361);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMethodCall_5358, *itCallerContextArg_5361);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AddArgValExprs_5352::patternMatcher( const Udm::Object& methodCall_5359, const Udm::Object& callerContextArg_5362)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( methodCall_5359.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall methodCall_535e= SFC::FunctionCall::Cast( methodCall_5359);
		if( false== Uml::IsDerivedFrom( callerContextArg_5362.type(), SFC::Arg::meta))
			continue;
		SFC::Arg callerContextArg_5367= SFC::Arg::Cast( callerContextArg_5362);
		set< SFC::ArgVal> argVals_5369= methodCall_535e.ArgVal_kind_children();
		for( set< SFC::ArgVal>::const_iterator itArgVal_536a= argVals_5369.begin(); itArgVal_536a!= argVals_5369.end(); ++itArgVal_536a)
		{
			SFC::ArgVal currArgVal_536b= *itArgVal_536a;
			CyberComposition::Simulink::Subsystem subsystem_536c= methodCall_535e.obj();
			if( !subsystem_536c)
				continue;
			SFC::LocalVar localVar_536d= subsystem_536c.memb();
			if( !localVar_536d)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_5371;
			if( !isValidBound(boundObjs_5371, methodCall_535e, true))
				continue;
			currMatch.methodCall_5372= methodCall_535e;
			if( !isValidBound(boundObjs_5371, callerContextArg_5367, true))
				continue;
			currMatch.callerContextArg_5373= callerContextArg_5367;
			if( !isValidBound(boundObjs_5371, subsystem_536c, false))
				continue;
			currMatch.subsystem_5374= subsystem_536c;
			if( !isValidBound(boundObjs_5371, localVar_536d, false))
				continue;
			currMatch.localVar_5375= localVar_536d;
			if( !isValidBound(boundObjs_5371, currArgVal_536b, false))
				continue;
			currMatch.argVal_5376= currArgVal_536b;
			bool Gz_guard= isGuardTrue( currMatch.argVal_5376, currMatch.callerContextArg_5373, currMatch.localVar_5375, currMatch.methodCall_5372, currMatch.subsystem_5374);
			if( true== Gz_guard)
				_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void AddArgValExprs_5352::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newBinaryExprs_537c= SFC::BinaryExprs::Create( currMatch.argVal_5376, SFC::ArgVal::meta_argexpr);
		SFC::ArgDeclRef newDeclRef_537d= SFC::ArgDeclRef::Create( newBinaryExprs_537c, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_537e= SFC::ArgDeclRef::Create( newBinaryExprs_537c, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_537e;
		SFC::ArgVal& ArgVal= currMatch.argVal_5376;
		SFC::BinaryExprs& BinaryExprs= newBinaryExprs_537c;
		SFC::Arg& CallerContextArg= currMatch.callerContextArg_5373;
		SFC::ArgDeclRef& DeclRef= newDeclRef_537d;
		SFC::LocalVar& LocalVar= currMatch.localVar_5375;
		SFC::FunctionCall& MethodCall= currMatch.methodCall_5372;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_5374;
		{
BinaryExprs.op() = ".";
};
		newDeclRef_537d.argdecl()= currMatch.localVar_5375;
		newArgDeclRef_537e.argdecl()= currMatch.callerContextArg_5373;
	}
}

void GetContextArg_537f::operator()( const Packets_t& methodCalls_5380, const Packets_t& callerContextArgs_5383, Packets_t& methodCalls_5382, Packets_t& callerContextArgs_5385)
{
#ifdef PRINT_INFO
	printLog( "GetContextArg_537f" );
#endif
	RTTGenerator::Instance()->generateRule(1658, "GetContextArg");
	_methodCall_5386= &methodCalls_5382;
	_callerContextArg_5387= &callerContextArgs_5385;
	processInputPackets( methodCalls_5380, callerContextArgs_5383);
	forwardInputs( );
}

bool GetContextArg_537f::isInputUnique( const Udm::Object& methodCall_538c, const Udm::Object& callerContextArg_5395)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMethodCall_538e= _methodCall_5388.begin(), itCallerContextArg_5397= _callerContextArg_5391.begin(); itMethodCall_538e!= _methodCall_5388.end(), itCallerContextArg_5397!= _callerContextArg_5391.end(); ++itMethodCall_538e, ++itCallerContextArg_5397)
	{
		if( ( *itMethodCall_538e== methodCall_538c)&& ( *itCallerContextArg_5397== callerContextArg_5395))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_methodCall_5388.push_back( methodCall_538c);
		_callerContextArg_5391.push_back( callerContextArg_5395);
	}
	return isUnique;
}

bool GetContextArg_537f::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetContextArg_537f::processInputPackets( const Packets_t& methodCalls_5380, const Packets_t& callerContextArgs_5383)
{
	for( Packets_t::const_iterator itMethodCall_5389= methodCalls_5380.begin(), itCallerContextArg_5392= callerContextArgs_5383.begin(); itMethodCall_5389!= methodCalls_5380.end(), itCallerContextArg_5392!= callerContextArgs_5383.end(); ++itMethodCall_5389, ++itCallerContextArg_5392)
	{
		bool isUnique= isInputUnique( *itMethodCall_5389, *itCallerContextArg_5392);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMethodCall_5389, *itCallerContextArg_5392);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetContextArg_537f::patternMatcher( const Udm::Object& methodCall_538a, const Udm::Object& callerContextArg_5393)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( methodCall_538a.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall methodCall_538f= SFC::FunctionCall::Cast( methodCall_538a);
		if( false== Uml::IsDerivedFrom( callerContextArg_5393.type(), SFC::Arg::meta))
			continue;
		SFC::Arg callerContextArg_5398= SFC::Arg::Cast( callerContextArg_5393);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_539d;
		if( !isValidBound(boundObjs_539d, methodCall_538f, true))
			continue;
		currMatch.methodCall_539e= methodCall_538f;
		if( !isValidBound(boundObjs_539d, callerContextArg_5398, true))
			continue;
		currMatch.callerContextArg_539f= callerContextArg_5398;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void GetContextArg_537f::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
	}
}

void GetContextArg_537f::forwardInputs()
{
	*_methodCall_5386= _methodCall_5388;
	*_callerContextArg_5387= _callerContextArg_5391;
}

void GetAllMethodCalls_53a0::operator()( const Packets_t& classs_53a1, Packets_t& methodcalls_53a3, Packets_t& contextargs_53a4, Packets_t& callerstructs_53a5)
{
#ifdef PRINT_INFO
	printLog( "GetAllMethodCalls_53a0" );
#endif
	_methodcall_53a6= &methodcalls_53a3;
	_contextarg_53a7= &contextargs_53a4;
	_callerstruct_53a8= &callerstructs_53a5;
	if( ( !classs_53a1.empty()))
		callGetClassFunctions_5446( classs_53a1);
}

void GetAllMethodCalls_53a0::callGetClassFunctions_5446( const Packets_t& callerClasss_541d)
{
	Packets_t callerMethods_541c;
	Packets_t args_541f;
	Packets_t callerStructs_5420;
	GetClassFunctions_541b getClassFunctions_541b;
	getClassFunctions_541b( callerClasss_541d, callerMethods_541c, args_541f, callerStructs_5420);
	if( ( !callerMethods_541c.empty())&& ( !args_541f.empty())&& ( !callerStructs_5420.empty()))
		callGetSubCompounds_5448( callerMethods_541c, args_541f, callerStructs_5420);
	if( ( !callerMethods_541c.empty())&& ( !args_541f.empty())&& ( !callerStructs_5420.empty()))
		callGetMethodCalls_544c( callerMethods_541c, args_541f, callerStructs_5420);
}

void GetAllMethodCalls_53a0::callGetSubCompounds_5448( const Packets_t& compoundStatements_53e3, const Packets_t& args_53e6, const Packets_t& callerStructs_53e9)
{
	Packets_t subCompounds_53e5;
	Packets_t args_53e8;
	Packets_t callerStructs_53eb;
	GetSubCompounds_53e2 getSubCompounds_53e2;
	getSubCompounds_53e2( compoundStatements_53e3, args_53e6, callerStructs_53e9, subCompounds_53e5, args_53e8, callerStructs_53eb);
	if( ( !subCompounds_53e5.empty())&& ( !args_53e8.empty())&& ( !callerStructs_53eb.empty()))
		callGetMethodCalls_544c( subCompounds_53e5, args_53e8, callerStructs_53eb);
	if( ( !subCompounds_53e5.empty())&& ( !args_53e8.empty())&& ( !callerStructs_53eb.empty()))
		callGetSubCompounds_5448( subCompounds_53e5, args_53e8, callerStructs_53eb);
}

void GetAllMethodCalls_53a0::callGetMethodCalls_544c( const Packets_t& compoundStatements_53ab, const Packets_t& contextargs_53ad, const Packets_t& callerStructs_53b0)
{
	Packets_t methodCalls_53aa;
	Packets_t contextargs_53af;
	Packets_t callerStructs_53b2;
	GetMethodCalls_53a9 getMethodCalls_53a9;
	getMethodCalls_53a9( compoundStatements_53ab, contextargs_53ad, callerStructs_53b0, methodCalls_53aa, contextargs_53af, callerStructs_53b2);
	_methodcall_53a6->insert( _methodcall_53a6->end(), methodCalls_53aa.begin(), methodCalls_53aa.end());
	_contextarg_53a7->insert( _contextarg_53a7->end(), contextargs_53af.begin(), contextargs_53af.end());
	_callerstruct_53a8->insert( _callerstruct_53a8->end(), callerStructs_53b2.begin(), callerStructs_53b2.end());
}

void GetMethodCalls_53a9::operator()( const Packets_t& compoundStatements_53ab, const Packets_t& contextargs_53ad, const Packets_t& callerStructs_53b0, Packets_t& methodCalls_53aa, Packets_t& contextargs_53af, Packets_t& callerStructs_53b2)
{
#ifdef PRINT_INFO
	printLog( "GetMethodCalls_53a9" );
#endif
	RTTGenerator::Instance()->generateRule(4922, "GetMethodCalls");
	_methodCall_53b3= &methodCalls_53aa;
	_contextarg_53b4= &contextargs_53af;
	_callerStruct_53b5= &callerStructs_53b2;
	processInputPackets( compoundStatements_53ab, contextargs_53ad, callerStructs_53b0);
}

bool GetMethodCalls_53a9::isInputUnique( const Udm::Object& compoundStatement_53ba, const Udm::Object& contextarg_53c3, const Udm::Object& callerStruct_53cc)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itCompoundStatement_53bc= _compoundStatement_53b6.begin(), itcontextarg_53c5= _contextarg_53bf.begin(), itCallerStruct_53ce= _callerStruct_53c8.begin(); itCompoundStatement_53bc!= _compoundStatement_53b6.end(), itcontextarg_53c5!= _contextarg_53bf.end(), itCallerStruct_53ce!= _callerStruct_53c8.end(); ++itCompoundStatement_53bc, ++itcontextarg_53c5, ++itCallerStruct_53ce)
	{
		if( ( *itCompoundStatement_53bc== compoundStatement_53ba)&& ( *itcontextarg_53c5== contextarg_53c3)&& ( *itCallerStruct_53ce== callerStruct_53cc))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_compoundStatement_53b6.push_back( compoundStatement_53ba);
		_contextarg_53bf.push_back( contextarg_53c3);
		_callerStruct_53c8.push_back( callerStruct_53cc);
	}
	return isUnique;
}

bool GetMethodCalls_53a9::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetMethodCalls_53a9::processInputPackets( const Packets_t& compoundStatements_53ab, const Packets_t& contextargs_53ad, const Packets_t& callerStructs_53b0)
{
	for( Packets_t::const_iterator itCompoundStatement_53b7= compoundStatements_53ab.begin(), itcontextarg_53c0= contextargs_53ad.begin(), itCallerStruct_53c9= callerStructs_53b0.begin(); itCompoundStatement_53b7!= compoundStatements_53ab.end(), itcontextarg_53c0!= contextargs_53ad.end(), itCallerStruct_53c9!= callerStructs_53b0.end(); ++itCompoundStatement_53b7, ++itcontextarg_53c0, ++itCallerStruct_53c9)
	{
		bool isUnique= isInputUnique( *itCompoundStatement_53b7, *itcontextarg_53c0, *itCallerStruct_53c9);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itCompoundStatement_53b7, *itcontextarg_53c0, *itCallerStruct_53c9);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetMethodCalls_53a9::patternMatcher( const Udm::Object& compoundStatement_53b8, const Udm::Object& contextarg_53c1, const Udm::Object& callerStruct_53ca)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( compoundStatement_53b8.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_53bd= SFC::CompoundStatement::Cast( compoundStatement_53b8);
		if( false== Uml::IsDerivedFrom( contextarg_53c1.type(), SFC::Arg::meta))
			continue;
		SFC::Arg contextarg_53c6= SFC::Arg::Cast( contextarg_53c1);
		if( false== Uml::IsDerivedFrom( callerStruct_53ca.type(), SFC::Struct::meta))
			continue;
		SFC::Struct callerStruct_53cf= SFC::Struct::Cast( callerStruct_53ca);
		set< SFC::FunctionCall> methodCalls_53d1= compoundStatement_53bd.FunctionCall_kind_children();
		for( set< SFC::FunctionCall>::const_iterator itMethodCall_53d2= methodCalls_53d1.begin(); itMethodCall_53d2!= methodCalls_53d1.end(); ++itMethodCall_53d2)
		{
			SFC::FunctionCall currMethodCall_53d3= *itMethodCall_53d2;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_53d7;
			if( !isValidBound(boundObjs_53d7, compoundStatement_53bd, true))
				continue;
			currMatch.compoundStatement_53d8= compoundStatement_53bd;
			if( !isValidBound(boundObjs_53d7, contextarg_53c6, true))
				continue;
			currMatch.contextarg_53d9= contextarg_53c6;
			if( !isValidBound(boundObjs_53d7, callerStruct_53cf, true))
				continue;
			currMatch.callerStruct_53da= callerStruct_53cf;
			if( !isValidBound(boundObjs_53d7, currMethodCall_53d3, false))
				continue;
			currMatch.methodCall_53db= currMethodCall_53d3;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetMethodCalls_53a9::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.methodCall_53db, currMatch.contextarg_53d9, currMatch.callerStruct_53da);
	}
}

void GetMethodCalls_53a9::outputAppender( const SFC::FunctionCall& methodCall_53dc, const SFC::Arg& contextarg_53de, const SFC::Struct& callerStruct_53e0)
{
	_methodCall_53b3->push_back( methodCall_53dc);
	_contextarg_53b4->push_back( contextarg_53de);
	_callerStruct_53b5->push_back( callerStruct_53e0);
}

void GetSubCompounds_53e2::operator()( const Packets_t& compoundStatements_53e3, const Packets_t& args_53e6, const Packets_t& callerStructs_53e9, Packets_t& subCompounds_53e5, Packets_t& args_53e8, Packets_t& callerStructs_53eb)
{
#ifdef PRINT_INFO
	printLog( "GetSubCompounds_53e2" );
#endif
	RTTGenerator::Instance()->generateRule(4928, "GetSubCompounds");
	_subCompound_53ec= &subCompounds_53e5;
	_arg_53ed= &args_53e8;
	_callerStruct_53ee= &callerStructs_53eb;
	processInputPackets( compoundStatements_53e3, args_53e6, callerStructs_53e9);
}

bool GetSubCompounds_53e2::isInputUnique( const Udm::Object& compoundStatement_53f3, const Udm::Object& arg_53fc, const Udm::Object& callerStruct_5405)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itCompoundStatement_53f5= _compoundStatement_53ef.begin(), itArg_53fe= _arg_53f8.begin(), itCallerStruct_5407= _callerStruct_5401.begin(); itCompoundStatement_53f5!= _compoundStatement_53ef.end(), itArg_53fe!= _arg_53f8.end(), itCallerStruct_5407!= _callerStruct_5401.end(); ++itCompoundStatement_53f5, ++itArg_53fe, ++itCallerStruct_5407)
	{
		if( ( *itCompoundStatement_53f5== compoundStatement_53f3)&& ( *itArg_53fe== arg_53fc)&& ( *itCallerStruct_5407== callerStruct_5405))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_compoundStatement_53ef.push_back( compoundStatement_53f3);
		_arg_53f8.push_back( arg_53fc);
		_callerStruct_5401.push_back( callerStruct_5405);
	}
	return isUnique;
}

bool GetSubCompounds_53e2::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetSubCompounds_53e2::processInputPackets( const Packets_t& compoundStatements_53e3, const Packets_t& args_53e6, const Packets_t& callerStructs_53e9)
{
	for( Packets_t::const_iterator itCompoundStatement_53f0= compoundStatements_53e3.begin(), itArg_53f9= args_53e6.begin(), itCallerStruct_5402= callerStructs_53e9.begin(); itCompoundStatement_53f0!= compoundStatements_53e3.end(), itArg_53f9!= args_53e6.end(), itCallerStruct_5402!= callerStructs_53e9.end(); ++itCompoundStatement_53f0, ++itArg_53f9, ++itCallerStruct_5402)
	{
		bool isUnique= isInputUnique( *itCompoundStatement_53f0, *itArg_53f9, *itCallerStruct_5402);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itCompoundStatement_53f0, *itArg_53f9, *itCallerStruct_5402);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetSubCompounds_53e2::patternMatcher( const Udm::Object& compoundStatement_53f1, const Udm::Object& arg_53fa, const Udm::Object& callerStruct_5403)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( compoundStatement_53f1.type(), SFC::CompoundStatement::meta))
			continue;
		SFC::CompoundStatement compoundStatement_53f6= SFC::CompoundStatement::Cast( compoundStatement_53f1);
		if( false== Uml::IsDerivedFrom( arg_53fa.type(), SFC::Arg::meta))
			continue;
		SFC::Arg arg_53ff= SFC::Arg::Cast( arg_53fa);
		if( false== Uml::IsDerivedFrom( callerStruct_5403.type(), SFC::Struct::meta))
			continue;
		SFC::Struct callerStruct_5408= SFC::Struct::Cast( callerStruct_5403);
		set< SFC::CompoundStatement> subCompounds_540a= compoundStatement_53f6.CompoundStatement_kind_children();
		for( set< SFC::CompoundStatement>::const_iterator itSubCompound_540b= subCompounds_540a.begin(); itSubCompound_540b!= subCompounds_540a.end(); ++itSubCompound_540b)
		{
			SFC::CompoundStatement currSubCompound_540c= *itSubCompound_540b;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_5410;
			if( !isValidBound(boundObjs_5410, compoundStatement_53f6, true))
				continue;
			currMatch.compoundStatement_5411= compoundStatement_53f6;
			if( !isValidBound(boundObjs_5410, arg_53ff, true))
				continue;
			currMatch.arg_5412= arg_53ff;
			if( !isValidBound(boundObjs_5410, callerStruct_5408, true))
				continue;
			currMatch.callerStruct_5413= callerStruct_5408;
			if( !isValidBound(boundObjs_5410, currSubCompound_540c, false))
				continue;
			currMatch.subCompound_5414= currSubCompound_540c;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetSubCompounds_53e2::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subCompound_5414, currMatch.arg_5412, currMatch.callerStruct_5413);
	}
}

void GetSubCompounds_53e2::outputAppender( const SFC::CompoundStatement& subCompound_5415, const SFC::Arg& arg_5417, const SFC::Struct& callerStruct_5419)
{
	_subCompound_53ec->push_back( subCompound_5415);
	_arg_53ed->push_back( arg_5417);
	_callerStruct_53ee->push_back( callerStruct_5419);
}

void GetClassFunctions_541b::operator()( const Packets_t& callerClasss_541d, Packets_t& callerMethods_541c, Packets_t& args_541f, Packets_t& callerStructs_5420)
{
#ifdef PRINT_INFO
	printLog( "GetClassFunctions_541b" );
#endif
	RTTGenerator::Instance()->generateRule(4934, "GetClassFunctions");
	_callerMethod_5421= &callerMethods_541c;
	_arg_5422= &args_541f;
	_callerStruct_5423= &callerStructs_5420;
	processInputPackets( callerClasss_541d);
}

bool GetClassFunctions_541b::isInputUnique( const Udm::Object& callerClass_5428)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itCallerClass_542a= _callerClass_5424.begin(); itCallerClass_542a!= _callerClass_5424.end(); ++itCallerClass_542a)
	{
		if( ( *itCallerClass_542a== callerClass_5428))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_callerClass_5424.push_back( callerClass_5428);
	return isUnique;
}

bool GetClassFunctions_541b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetClassFunctions_541b::processInputPackets( const Packets_t& callerClasss_541d)
{
	for( Packets_t::const_iterator itCallerClass_5425= callerClasss_541d.begin(); itCallerClass_5425!= callerClasss_541d.end(); ++itCallerClass_5425)
	{
		bool isUnique= isInputUnique( *itCallerClass_5425);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itCallerClass_5425);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetClassFunctions_541b::patternMatcher( const Udm::Object& callerClass_5426)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( callerClass_5426.type(), SFC::Class::meta))
			continue;
		SFC::Class callerClass_542b= SFC::Class::Cast( callerClass_5426);
		set< SFC::Function> callerMethods_542d= callerClass_542b.Function_kind_children();
		for( set< SFC::Function>::const_iterator itCallerMethod_542e= callerMethods_542d.begin(); itCallerMethod_542e!= callerMethods_542d.end(); ++itCallerMethod_542e)
		{
			SFC::Function currCallerMethod_542f= *itCallerMethod_542e;
			set< SFC::Struct> callerStructs_5430= callerClass_542b.Struct_kind_children();
			for( set< SFC::Struct>::const_iterator itCallerStruct_5431= callerStructs_5430.begin(); itCallerStruct_5431!= callerStructs_5430.end(); ++itCallerStruct_5431)
			{
				SFC::Struct currCallerStruct_5432= *itCallerStruct_5431;
				set< SFC::Arg> args_5433= currCallerMethod_542f.Arg_kind_children();
				for( set< SFC::Arg>::const_iterator itArg_5434= args_5433.begin(); itArg_5434!= args_5433.end(); ++itArg_5434)
				{
					SFC::Arg currArg_5435= *itArg_5434;
					SFC::DT callerStruct_5436= currArg_5435.dt();
					if(!callerStruct_5436 || false== Uml::IsDerivedFrom( callerStruct_5436.type(), SFC::Struct::meta))
						continue;
					SFC::Struct callerStruct_5437= SFC::Struct::Cast( callerStruct_5436);
					if( !callerStruct_5437)
						continue;
					if( currCallerStruct_5432!= callerStruct_5437)
						continue;
					Match currMatch;
					set< pair<int, Udm::Object> > boundObjs_543b;
					if( !isValidBound(boundObjs_543b, callerClass_542b, true))
						continue;
					currMatch.callerClass_543c= callerClass_542b;
					if( !isValidBound(boundObjs_543b, currCallerMethod_542f, false))
						continue;
					currMatch.callerMethod_543d= currCallerMethod_542f;
					if( !isValidBound(boundObjs_543b, currArg_5435, false))
						continue;
					currMatch.arg_543e= currArg_5435;
					if( !isValidBound(boundObjs_543b, currCallerStruct_5432, false))
						continue;
					currMatch.callerStruct_543f= currCallerStruct_5432;
					_matches.push_back( currMatch);
				}
			}
		}
	}
	return !_matches.empty();
}

void GetClassFunctions_541b::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.callerMethod_543d, currMatch.arg_543e, currMatch.callerStruct_543f);
	}
}

void GetClassFunctions_541b::outputAppender( const SFC::Function& callerMethod_5440, const SFC::Arg& arg_5442, const SFC::Struct& callerStruct_5444)
{
	_callerMethod_5421->push_back( callerMethod_5440);
	_arg_5422->push_back( arg_5442);
	_callerStruct_5423->push_back( callerStruct_5444);
}

void FinalizeContext_5458::operator()( const Packets_t& classs_5459, Packets_t& classs_545b)
{
#ifdef PRINT_INFO
	printLog( "FinalizeContext_5458" );
#endif
	_class_545c= &classs_545b;
	_class_545c->insert( _class_545c->end(), classs_5459.begin(), classs_5459.end());
	if( ( !classs_5459.empty()))
		callGetAllMethodCalls_552d( classs_5459);
}

void FinalizeContext_5458::callGetAllMethodCalls_552d( const Packets_t& classs_53a1)
{
	Packets_t methodcalls_53a3;
	Packets_t contextargs_53a4;
	Packets_t callerstructs_53a5;
	GetAllMethodCalls_53a0 getAllMethodCalls_53a0;
	getAllMethodCalls_53a0( classs_53a1, methodcalls_53a3, contextargs_53a4, callerstructs_53a5);
	if( ( !methodcalls_53a3.empty())&& ( !callerstructs_53a5.empty()))
		callGetCalleeObject_552f( methodcalls_53a3, callerstructs_53a5);
}

void FinalizeContext_5458::callGetCalleeObject_552f( const Packets_t& methodCalls_5507, const Packets_t& callerStructs_550a)
{
	Packets_t calleeSubsystems_5509;
	Packets_t callerStructs_550c;
	GetCalleeObject_5506 getCalleeObject_5506;
	getCalleeObject_5506( methodCalls_5507, callerStructs_550a, calleeSubsystems_5509, callerStructs_550c);
	if( ( !calleeSubsystems_5509.empty())&& ( !callerStructs_550c.empty()))
		callAddMembers_5532( calleeSubsystems_5509, callerStructs_550c);
}

void FinalizeContext_5458::callAddMembers_5532( const Packets_t& calleeObjects_545e, const Packets_t& callerStructs_5460)
{
	AddMembers_545d addMembers_545d;
	addMembers_545d( calleeObjects_545e, callerStructs_5460);
}

void AddMembers_545d::operator()( const Packets_t& calleeObjects_545e, const Packets_t& callerStructs_5460)
{
#ifdef PRINT_INFO
	printLog( "AddMembers_545d" );
#endif
	for( Packets_t::const_iterator itcalleeObject_5463= calleeObjects_545e.begin(), itcallerStruct_546a= callerStructs_5460.begin(); itcalleeObject_5463!= calleeObjects_545e.end(), itcallerStruct_546a!= callerStructs_5460.end(); ++itcalleeObject_5463, ++itcallerStruct_546a)
	{
		bool isUnique= isInputUnique( *itcalleeObject_5463, *itcallerStruct_546a);
		if( !isUnique)
			continue;
		Packets_t onecalleeObject_5467( 1, *itcalleeObject_5463);
		Packets_t onecallerStruct_546e( 1, *itcallerStruct_546a);
		executeOne( onecalleeObject_5467, onecallerStruct_546e);
	}
}

void AddMembers_545d::executeOne( const Packets_t& calleeObjects_545e, const Packets_t& callerStructs_5460)
{
	if( ( !calleeObjects_545e.empty())&& ( !callerStructs_5460.empty()))
		callContextTest_5500( calleeObjects_545e, callerStructs_5460);
}

bool AddMembers_545d::isInputUnique( const Udm::Object& calleeObject_5464, const Udm::Object& callerStruct_546b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itcalleeObject_5466= _calleeObject_5462.begin(), itcallerStruct_546d= _callerStruct_5469.begin(); itcalleeObject_5466!= _calleeObject_5462.end(), itcallerStruct_546d!= _callerStruct_5469.end(); ++itcalleeObject_5466, ++itcallerStruct_546d)
	{
		if( ( *itcalleeObject_5466== calleeObject_5464)&& ( *itcallerStruct_546d== callerStruct_546b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_calleeObject_5462.push_back( calleeObject_5464);
		_callerStruct_5469.push_back( callerStruct_546b);
	}
	return isUnique;
}

void AddMembers_545d::callContextTest_5500( const Packets_t& calleeObjects_5471, const Packets_t& callerStructs_5473)
{
	Packets_t calleeObjects_5475;
	Packets_t callerStructs_5476;
	Packets_t calleeObjects_5477;
	Packets_t callerStructs_5478;
	ContextTest_5470 contextTest_5470;
	contextTest_5470( calleeObjects_5471, callerStructs_5473, calleeObjects_5475, callerStructs_5476, calleeObjects_5477, callerStructs_5478);
	if( ( !calleeObjects_5477.empty())&& ( !callerStructs_5478.empty()))
		callAddContextMember_5503( calleeObjects_5477, callerStructs_5478);
}

void AddMembers_545d::callAddContextMember_5503( const Packets_t& calleeSubsystems_54dd, const Packets_t& callerStructs_54df)
{
	AddContextMember_54dc addContextMember_54dc;
	addContextMember_54dc( calleeSubsystems_54dd, callerStructs_54df);
}

void ContextTest_5470::operator()( const Packets_t& calleeObjects_5471, const Packets_t& callerStructs_5473, Packets_t& calleeObjects_5475, Packets_t& callerStructs_5476, Packets_t& calleeObjects_5477, Packets_t& callerStructs_5478)
{
#ifdef PRINT_INFO
	printLog( "ContextTest_5470" );
#endif
	_calleeObject_5479= &calleeObjects_5475;
	_callerStruct_547a= &callerStructs_5476;
	_calleeObject_547b= &calleeObjects_5477;
	_callerStruct_547c= &callerStructs_5478;
	for( Packets_t::const_iterator itcalleeObject_547e= calleeObjects_5471.begin(), itcallerStruct_5485= callerStructs_5473.begin(); itcalleeObject_547e!= calleeObjects_5471.end(), itcallerStruct_5485!= callerStructs_5473.end(); ++itcalleeObject_547e, ++itcallerStruct_5485)
	{
		bool isUnique= isInputUnique( *itcalleeObject_547e, *itcallerStruct_5485);
		if( !isUnique)
			continue;
		Packets_t onecalleeObject_5482( 1, *itcalleeObject_547e);
		Packets_t onecallerStruct_5489( 1, *itcallerStruct_5485);
		executeOne( onecalleeObject_5482, onecallerStruct_5489);
	}
}

void ContextTest_5470::executeOne( const Packets_t& calleeObjects_5471, const Packets_t& callerStructs_5473)
{
	Packets_t calleeSubsystems_548e;
	Packets_t callerStructs_5491;
	CallerStructHasMember_548b callerStructHasMember_548b;
	bool isMatchCallerStructHasMember_548b= callerStructHasMember_548b( calleeObjects_5471, callerStructs_5473, calleeSubsystems_548e, callerStructs_5491);
	_calleeObject_5479->insert( _calleeObject_5479->end(), calleeSubsystems_548e.begin(), calleeSubsystems_548e.end());
	_callerStruct_547a->insert( _callerStruct_547a->end(), callerStructs_5491.begin(), callerStructs_5491.end());
	if( isMatchCallerStructHasMember_548b)
		return;
	Packets_t calleeSubsystems_54ba;
	Packets_t callerStructs_54bd;
	Otherwise_54b7 otherwise_54b7;
	bool isMatchOtherwise_54b7= otherwise_54b7( calleeObjects_5471, callerStructs_5473, calleeSubsystems_54ba, callerStructs_54bd);
	_calleeObject_547b->insert( _calleeObject_547b->end(), calleeSubsystems_54ba.begin(), calleeSubsystems_54ba.end());
	_callerStruct_547c->insert( _callerStruct_547c->end(), callerStructs_54bd.begin(), callerStructs_54bd.end());
	if( isMatchOtherwise_54b7)
		return;
}

bool ContextTest_5470::isInputUnique( const Udm::Object& calleeObject_547f, const Udm::Object& callerStruct_5486)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itcalleeObject_5481= _calleeObject_547d.begin(), itcallerStruct_5488= _callerStruct_5484.begin(); itcalleeObject_5481!= _calleeObject_547d.end(), itcallerStruct_5488!= _callerStruct_5484.end(); ++itcalleeObject_5481, ++itcallerStruct_5488)
	{
		if( ( *itcalleeObject_5481== calleeObject_547f)&& ( *itcallerStruct_5488== callerStruct_5486))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_calleeObject_547d.push_back( calleeObject_547f);
		_callerStruct_5484.push_back( callerStruct_5486);
	}
	return isUnique;
}

bool CallerStructHasMember_548b::operator()( const Packets_t& calleeSubsystems_548c, const Packets_t& callerStructs_548f, Packets_t& calleeSubsystems_548e, Packets_t& callerStructs_5491)
{
#ifdef PRINT_INFO
	printLog( "CallerStructHasMember_548b" );
#endif
	_calleeSubsystem_5492= &calleeSubsystems_548e;
	_callerStruct_5493= &callerStructs_5491;
	processInputPackets( calleeSubsystems_548c, callerStructs_548f);
	if( false== _matches.empty())
		return true;
	return false;
}

bool CallerStructHasMember_548b::isInputUnique( const Udm::Object& calleeSubsystem_5498, const Udm::Object& callerStruct_54a1)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itcalleeSubsystem_549a= _calleeSubsystem_5494.begin(), itCallerStruct_54a3= _callerStruct_549d.begin(); itcalleeSubsystem_549a!= _calleeSubsystem_5494.end(), itCallerStruct_54a3!= _callerStruct_549d.end(); ++itcalleeSubsystem_549a, ++itCallerStruct_54a3)
	{
		if( ( *itcalleeSubsystem_549a== calleeSubsystem_5498)&& ( *itCallerStruct_54a3== callerStruct_54a1))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_calleeSubsystem_5494.push_back( calleeSubsystem_5498);
		_callerStruct_549d.push_back( callerStruct_54a1);
	}
	return isUnique;
}

bool CallerStructHasMember_548b::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CallerStructHasMember_548b::processInputPackets( const Packets_t& calleeSubsystems_548c, const Packets_t& callerStructs_548f)
{
	for( Packets_t::const_iterator itcalleeSubsystem_5495= calleeSubsystems_548c.begin(), itCallerStruct_549e= callerStructs_548f.begin(); itcalleeSubsystem_5495!= calleeSubsystems_548c.end(), itCallerStruct_549e!= callerStructs_548f.end(); ++itcalleeSubsystem_5495, ++itCallerStruct_549e)
	{
		bool isUnique= isInputUnique( *itcalleeSubsystem_5495, *itCallerStruct_549e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itcalleeSubsystem_5495, *itCallerStruct_549e);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.calleeSubsystem_54b0, currMatch.callerStruct_54b1);
	}
}

bool CallerStructHasMember_548b::patternMatcher( const Udm::Object& calleeSubsystem_5496, const Udm::Object& callerStruct_549f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( calleeSubsystem_5496.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem calleeSubsystem_549b= CyberComposition::Simulink::Subsystem::Cast( calleeSubsystem_5496);
		if( false== Uml::IsDerivedFrom( callerStruct_549f.type(), SFC::Struct::meta))
			continue;
		SFC::Struct callerStruct_54a4= SFC::Struct::Cast( callerStruct_549f);
		set< SFC::LocalVar> localVars_54a6= callerStruct_54a4.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itLocalVar_54a7= localVars_54a6.begin(); itLocalVar_54a7!= localVars_54a6.end(); ++itLocalVar_54a7)
		{
			SFC::LocalVar currLocalVar_54a8= *itLocalVar_54a7;
			set< CyberComposition::Simulink::Subsystem> calleeSubsystems_54a9= currLocalVar_54a8.sys();
			for( set< CyberComposition::Simulink::Subsystem>::const_iterator itcalleeSubsystems_54aa= calleeSubsystems_54a9.begin(); itcalleeSubsystems_54aa!= calleeSubsystems_54a9.end(); ++itcalleeSubsystems_54aa)
			{
				CyberComposition::Simulink::Subsystem currcalleeSubsystem_54ab= *itcalleeSubsystems_54aa;
				if( calleeSubsystem_549b!= currcalleeSubsystem_54ab)
					continue;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_54af;
				if( !isValidBound(boundObjs_54af, calleeSubsystem_549b, true))
					continue;
				currMatch.calleeSubsystem_54b0= calleeSubsystem_549b;
				if( !isValidBound(boundObjs_54af, callerStruct_54a4, true))
					continue;
				currMatch.callerStruct_54b1= callerStruct_54a4;
				if( !isValidBound(boundObjs_54af, currLocalVar_54a8, false))
					continue;
				currMatch.localVar_54b2= currLocalVar_54a8;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void CallerStructHasMember_548b::outputAppender( const CyberComposition::Simulink::Subsystem& calleeSubsystem_54b3, const SFC::Struct& callerStruct_54b5)
{
	_calleeSubsystem_5492->push_back( calleeSubsystem_54b3);
	_callerStruct_5493->push_back( callerStruct_54b5);
}

bool Otherwise_54b7::operator()( const Packets_t& calleeSubsystems_54b8, const Packets_t& callerStructs_54bb, Packets_t& calleeSubsystems_54ba, Packets_t& callerStructs_54bd)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_54b7" );
#endif
	_calleeSubsystem_54be= &calleeSubsystems_54ba;
	_callerStruct_54bf= &callerStructs_54bd;
	processInputPackets( calleeSubsystems_54b8, callerStructs_54bb);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_54b7::isInputUnique( const Udm::Object& calleeSubsystem_54c4, const Udm::Object& callerStruct_54cd)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itcalleeSubsystem_54c6= _calleeSubsystem_54c0.begin(), itCallerStruct_54cf= _callerStruct_54c9.begin(); itcalleeSubsystem_54c6!= _calleeSubsystem_54c0.end(), itCallerStruct_54cf!= _callerStruct_54c9.end(); ++itcalleeSubsystem_54c6, ++itCallerStruct_54cf)
	{
		if( ( *itcalleeSubsystem_54c6== calleeSubsystem_54c4)&& ( *itCallerStruct_54cf== callerStruct_54cd))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_calleeSubsystem_54c0.push_back( calleeSubsystem_54c4);
		_callerStruct_54c9.push_back( callerStruct_54cd);
	}
	return isUnique;
}

bool Otherwise_54b7::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_54b7::processInputPackets( const Packets_t& calleeSubsystems_54b8, const Packets_t& callerStructs_54bb)
{
	for( Packets_t::const_iterator itcalleeSubsystem_54c1= calleeSubsystems_54b8.begin(), itCallerStruct_54ca= callerStructs_54bb.begin(); itcalleeSubsystem_54c1!= calleeSubsystems_54b8.end(), itCallerStruct_54ca!= callerStructs_54bb.end(); ++itcalleeSubsystem_54c1, ++itCallerStruct_54ca)
	{
		bool isUnique= isInputUnique( *itcalleeSubsystem_54c1, *itCallerStruct_54ca);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itcalleeSubsystem_54c1, *itCallerStruct_54ca);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.calleeSubsystem_54d6, currMatch.callerStruct_54d7);
	}
}

bool Otherwise_54b7::patternMatcher( const Udm::Object& calleeSubsystem_54c2, const Udm::Object& callerStruct_54cb)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( calleeSubsystem_54c2.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem calleeSubsystem_54c7= CyberComposition::Simulink::Subsystem::Cast( calleeSubsystem_54c2);
		if( false== Uml::IsDerivedFrom( callerStruct_54cb.type(), SFC::Struct::meta))
			continue;
		SFC::Struct callerStruct_54d0= SFC::Struct::Cast( callerStruct_54cb);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_54d5;
		if( !isValidBound(boundObjs_54d5, calleeSubsystem_54c7, true))
			continue;
		currMatch.calleeSubsystem_54d6= calleeSubsystem_54c7;
		if( !isValidBound(boundObjs_54d5, callerStruct_54d0, true))
			continue;
		currMatch.callerStruct_54d7= callerStruct_54d0;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_54b7::outputAppender( const CyberComposition::Simulink::Subsystem& calleeSubsystem_54d8, const SFC::Struct& callerStruct_54da)
{
	_calleeSubsystem_54be->push_back( calleeSubsystem_54d8);
	_callerStruct_54bf->push_back( callerStruct_54da);
}

void AddContextMember_54dc::operator()( const Packets_t& calleeSubsystems_54dd, const Packets_t& callerStructs_54df)
{
#ifdef PRINT_INFO
	printLog( "AddContextMember_54dc" );
#endif
	RTTGenerator::Instance()->generateRule(1683, "AddContextMember");
	processInputPackets( calleeSubsystems_54dd, callerStructs_54df);
}

bool AddContextMember_54dc::isInputUnique( const Udm::Object& calleeSubsystem_54e5, const Udm::Object& callerStruct_54ee)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itcalleeSubsystem_54e7= _calleeSubsystem_54e1.begin(), itCallerStruct_54f0= _callerStruct_54ea.begin(); itcalleeSubsystem_54e7!= _calleeSubsystem_54e1.end(), itCallerStruct_54f0!= _callerStruct_54ea.end(); ++itcalleeSubsystem_54e7, ++itCallerStruct_54f0)
	{
		if( ( *itcalleeSubsystem_54e7== calleeSubsystem_54e5)&& ( *itCallerStruct_54f0== callerStruct_54ee))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_calleeSubsystem_54e1.push_back( calleeSubsystem_54e5);
		_callerStruct_54ea.push_back( callerStruct_54ee);
	}
	return isUnique;
}

bool AddContextMember_54dc::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void AddContextMember_54dc::processInputPackets( const Packets_t& calleeSubsystems_54dd, const Packets_t& callerStructs_54df)
{
	for( Packets_t::const_iterator itcalleeSubsystem_54e2= calleeSubsystems_54dd.begin(), itCallerStruct_54eb= callerStructs_54df.begin(); itcalleeSubsystem_54e2!= calleeSubsystems_54dd.end(), itCallerStruct_54eb!= callerStructs_54df.end(); ++itcalleeSubsystem_54e2, ++itCallerStruct_54eb)
	{
		bool isUnique= isInputUnique( *itcalleeSubsystem_54e2, *itCallerStruct_54eb);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itcalleeSubsystem_54e2, *itCallerStruct_54eb);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AddContextMember_54dc::patternMatcher( const Udm::Object& calleeSubsystem_54e3, const Udm::Object& callerStruct_54ec)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( calleeSubsystem_54e3.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem calleeSubsystem_54e8= CyberComposition::Simulink::Subsystem::Cast( calleeSubsystem_54e3);
		if( false== Uml::IsDerivedFrom( callerStruct_54ec.type(), SFC::Struct::meta))
			continue;
		SFC::Struct callerStruct_54f1= SFC::Struct::Cast( callerStruct_54ec);
		SFC::Class calleeClass_54f3= calleeSubsystem_54e8.cls();
		if( !calleeClass_54f3)
			continue;
		set< SFC::Struct> calleeStructs_54f4= calleeClass_54f3.Struct_kind_children();
		for( set< SFC::Struct>::const_iterator itCalleeStruct_54f5= calleeStructs_54f4.begin(); itCalleeStruct_54f5!= calleeStructs_54f4.end(); ++itCalleeStruct_54f5)
		{
			SFC::Struct currCalleeStruct_54f6= *itCalleeStruct_54f5;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_54fa;
			if( !isValidBound(boundObjs_54fa, calleeSubsystem_54e8, true))
				continue;
			currMatch.calleeSubsystem_54fb= calleeSubsystem_54e8;
			if( !isValidBound(boundObjs_54fa, callerStruct_54f1, true))
				continue;
			currMatch.callerStruct_54fc= callerStruct_54f1;
			if( !isValidBound(boundObjs_54fa, calleeClass_54f3, false))
				continue;
			currMatch.calleeClass_54fd= calleeClass_54f3;
			if( !isValidBound(boundObjs_54fa, currCalleeStruct_54f6, false))
				continue;
			currMatch.calleeStruct_54fe= currCalleeStruct_54f6;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void AddContextMember_54dc::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::LocalVar newLocalVar_54ff= SFC::LocalVar::Create( currMatch.callerStruct_54fc, SFC::Struct::meta_memb);
		SFC::Class& CalleeClass= currMatch.calleeClass_54fd;
		SFC::Struct& CalleeStruct= currMatch.calleeStruct_54fe;
		SFC::Struct& CallerStruct= currMatch.callerStruct_54fc;
		SFC::LocalVar& LocalVar= newLocalVar_54ff;
		CyberComposition::Simulink::Subsystem& calleeSubsystem= currMatch.calleeSubsystem_54fb;
		{
__int64 memberCount = CallerStruct.memberCount();

std::ostringstream itoa;
itoa << memberCount;

LocalVar.statementIndex() = memberCount++;
LocalVar.name() = static_cast< std::string >( CalleeClass.name() ) + "_member" + itoa.str();

CallerStruct.memberCount() = memberCount;
std::string tmp = LocalVar.name();
SFUtils::obj2VarNameMap[calleeSubsystem.uniqueId()]=tmp;
};
		newLocalVar_54ff.sys()+= currMatch.calleeSubsystem_54fb;
		newLocalVar_54ff.dt()= currMatch.calleeStruct_54fe;
	}
}

void GetCalleeObject_5506::operator()( const Packets_t& methodCalls_5507, const Packets_t& callerStructs_550a, Packets_t& calleeSubsystems_5509, Packets_t& callerStructs_550c)
{
#ifdef PRINT_INFO
	printLog( "GetCalleeObject_5506" );
#endif
	RTTGenerator::Instance()->generateRule(1695, "GetCalleeObject");
	_calleeSubsystem_550d= &calleeSubsystems_5509;
	_callerStruct_550e= &callerStructs_550c;
	processInputPackets( methodCalls_5507, callerStructs_550a);
}

bool GetCalleeObject_5506::isInputUnique( const Udm::Object& methodCall_5513, const Udm::Object& callerStruct_551c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itMethodCall_5515= _methodCall_550f.begin(), itCallerStruct_551e= _callerStruct_5518.begin(); itMethodCall_5515!= _methodCall_550f.end(), itCallerStruct_551e!= _callerStruct_5518.end(); ++itMethodCall_5515, ++itCallerStruct_551e)
	{
		if( ( *itMethodCall_5515== methodCall_5513)&& ( *itCallerStruct_551e== callerStruct_551c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_methodCall_550f.push_back( methodCall_5513);
		_callerStruct_5518.push_back( callerStruct_551c);
	}
	return isUnique;
}

bool GetCalleeObject_5506::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetCalleeObject_5506::processInputPackets( const Packets_t& methodCalls_5507, const Packets_t& callerStructs_550a)
{
	for( Packets_t::const_iterator itMethodCall_5510= methodCalls_5507.begin(), itCallerStruct_5519= callerStructs_550a.begin(); itMethodCall_5510!= methodCalls_5507.end(), itCallerStruct_5519!= callerStructs_550a.end(); ++itMethodCall_5510, ++itCallerStruct_5519)
	{
		bool isUnique= isInputUnique( *itMethodCall_5510, *itCallerStruct_5519);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itMethodCall_5510, *itCallerStruct_5519);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetCalleeObject_5506::patternMatcher( const Udm::Object& methodCall_5511, const Udm::Object& callerStruct_551a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( methodCall_5511.type(), SFC::FunctionCall::meta))
			continue;
		SFC::FunctionCall methodCall_5516= SFC::FunctionCall::Cast( methodCall_5511);
		if( false== Uml::IsDerivedFrom( callerStruct_551a.type(), SFC::Struct::meta))
			continue;
		SFC::Struct callerStruct_551f= SFC::Struct::Cast( callerStruct_551a);
		CyberComposition::Simulink::Subsystem calleeSubsystem_5521= methodCall_5516.obj();
		if( !calleeSubsystem_5521)
			continue;
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5525;
		if( !isValidBound(boundObjs_5525, methodCall_5516, true))
			continue;
		currMatch.methodCall_5526= methodCall_5516;
		if( !isValidBound(boundObjs_5525, callerStruct_551f, true))
			continue;
		currMatch.callerStruct_5527= callerStruct_551f;
		if( !isValidBound(boundObjs_5525, calleeSubsystem_5521, false))
			continue;
		currMatch.calleeSubsystem_5528= calleeSubsystem_5521;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void GetCalleeObject_5506::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.calleeSubsystem_5528, currMatch.callerStruct_5527);
	}
}

void GetCalleeObject_5506::outputAppender( const CyberComposition::Simulink::Subsystem& calleeSubsystem_5529, const SFC::Struct& callerStruct_552b)
{
	_calleeSubsystem_550d->push_back( calleeSubsystem_5529);
	_callerStruct_550e->push_back( callerStruct_552b);
}

void AssignToOutArgs_5535::operator()( const Packets_t& classs_5536, Packets_t& classs_5538)
{
#ifdef PRINT_INFO
	printLog( "AssignToOutArgs_5535" );
#endif
	_class_5539= &classs_5538;
	if( ( !classs_5536.empty()))
		callIdenticalOutArgs_557a( classs_5536);
	_class_5539->insert( _class_5539->end(), classs_5536.begin(), classs_5536.end());
}

void AssignToOutArgs_5535::callIdenticalOutArgs_557a( const Packets_t& classs_553b)
{
	IdenticalOutArgs_553a identicalOutArgs_553a;
	identicalOutArgs_553a( classs_553b);
}

void IdenticalOutArgs_553a::operator()( const Packets_t& classs_553b)
{
#ifdef PRINT_INFO
	printLog( "IdenticalOutArgs_553a" );
#endif
	RTTGenerator::Instance()->generateRule(1703, "IdenticalOutArgs");
	processInputPackets( classs_553b);
}

bool IdenticalOutArgs_553a::isInputUnique( const Udm::Object& class_5541)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itClass_5543= _class_553d.begin(); itClass_5543!= _class_553d.end(); ++itClass_5543)
	{
		if( ( *itClass_5543== class_5541))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_class_553d.push_back( class_5541);
	return isUnique;
}

bool IdenticalOutArgs_553a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool IdenticalOutArgs_553a::isGuardTrue( CyberComposition::Simulink::Block& Block, SFC::Class& Class, SFC::Function& Function, SFC::Arg& LeftArg, CyberComposition::Simulink::OutPort& LeftSubsystemOutPort, CyberComposition::Simulink::Line& Line, CyberComposition::Simulink::OutPort& OutPort, SFC::Arg& RightArg, CyberComposition::Simulink::OutPort& RightSubsystemOutPort, CyberComposition::Simulink::Subsystem& Subsystem)
{
	bool Gz_guard= false;
	Udm::Object object = OutPort.argdecl();
Gz_guard = object != Udm::null && Uml::IsDerivedFrom( object.type(), SFC::Arg::meta ) && SFC::Arg::Cast( OutPort.argdecl() ) == RightArg;;
	return Gz_guard;
}

void IdenticalOutArgs_553a::processInputPackets( const Packets_t& classs_553b)
{
	for( Packets_t::const_iterator itClass_553e= classs_553b.begin(); itClass_553e!= classs_553b.end(); ++itClass_553e)
	{
		bool isUnique= isInputUnique( *itClass_553e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itClass_553e);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool IdenticalOutArgs_553a::patternMatcher( const Udm::Object& class_553f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( class_553f.type(), SFC::Class::meta))
			continue;
		SFC::Class class_5544= SFC::Class::Cast( class_553f);
		set< CyberComposition::Simulink::Subsystem> subsystems_5546= class_5544.obj();
		for( set< CyberComposition::Simulink::Subsystem>::const_iterator itSubsystems_5547= subsystems_5546.begin(); itSubsystems_5547!= subsystems_5546.end(); ++itSubsystems_5547)
		{
			CyberComposition::Simulink::Subsystem currSubsystem_5548= *itSubsystems_5547;
			set< CyberComposition::Simulink::Block> blocks_5549= currSubsystem_5548.Block_kind_children();
			for( set< CyberComposition::Simulink::Block>::const_iterator itBlock_554a= blocks_5549.begin(); itBlock_554a!= blocks_5549.end(); ++itBlock_554a)
			{
				CyberComposition::Simulink::Block currBlock_554b= *itBlock_554a;
				set< CyberComposition::Simulink::OutPort> rightSubsystemOutPorts_554c= currSubsystem_5548.OutPort_kind_children();
				for( set< CyberComposition::Simulink::OutPort>::const_iterator itRightSubsystemOutPort_554d= rightSubsystemOutPorts_554c.begin(); itRightSubsystemOutPort_554d!= rightSubsystemOutPorts_554c.end(); ++itRightSubsystemOutPort_554d)
				{
					CyberComposition::Simulink::OutPort currRightSubsystemOutPort_554e= *itRightSubsystemOutPort_554d;
					set< CyberComposition::Simulink::OutPort> outPorts_554f= currBlock_554b.OutPort_kind_children();
					for( set< CyberComposition::Simulink::OutPort>::const_iterator itOutPort_5550= outPorts_554f.begin(); itOutPort_5550!= outPorts_554f.end(); ++itOutPort_5550)
					{
						CyberComposition::Simulink::OutPort currOutPort_5551= *itOutPort_5550;
						set< SFC::Arg> rightArgs_5552= currRightSubsystemOutPort_554e.arg();
						for( set< SFC::Arg>::const_iterator itRightArgs_5553= rightArgs_5552.begin(); itRightArgs_5553!= rightArgs_5552.end(); ++itRightArgs_5553)
						{
							SFC::Arg currRightArg_5554= *itRightArgs_5553;
							Udm::Object rightArgParent_5555= currRightArg_5554.container();
							if( false== Uml::IsDerivedFrom( rightArgParent_5555.type(), SFC::Function::meta))
								continue;
							SFC::Function functionRightArg_5556= SFC::Function::Cast( rightArgParent_5555);
							set< SFC::Arg> leftArgs_5557= functionRightArg_5556.Arg_kind_children();
							for( set< SFC::Arg>::const_iterator itLeftArg_5558= leftArgs_5557.begin(); itLeftArg_5558!= leftArgs_5557.end(); ++itLeftArg_5558)
							{
								SFC::Arg currLeftArg_5559= *itLeftArg_5558;
								set< CyberComposition::Simulink::SF_Port> leftSubsystemOutPorts_555a= currLeftArg_5559.port();
								for( set< CyberComposition::Simulink::SF_Port>::const_iterator itLeftSubsystemOutPorts_555b= leftSubsystemOutPorts_555a.begin(); itLeftSubsystemOutPorts_555b!= leftSubsystemOutPorts_555a.end(); ++itLeftSubsystemOutPorts_555b)
								{
									if( false== Uml::IsDerivedFrom( (*itLeftSubsystemOutPorts_555b).type(), CyberComposition::Simulink::OutPort::meta))
										continue;
									CyberComposition::Simulink::OutPort currLeftSubsystemOutPort_555c= CyberComposition::Simulink::OutPort::Cast( *itLeftSubsystemOutPorts_555b);
									set< CyberComposition::Simulink::Line> lines_555d= currOutPort_5551.dstLine();
									for( set< CyberComposition::Simulink::Line>::const_iterator itLines_555e= lines_555d.begin(); itLines_555e!= lines_555d.end(); ++itLines_555e)
									{
										CyberComposition::Simulink::Line currLine_555f= *itLines_555e;
										CyberComposition::Simulink::SF_Port leftSubsystemOutPort_5560= currLine_555f.dstLine_end();
										if( false== Uml::IsDerivedFrom( leftSubsystemOutPort_5560.type(), CyberComposition::Simulink::OutPort::meta))
											continue;
										CyberComposition::Simulink::OutPort currLeftSubsystemOutPort_5561= CyberComposition::Simulink::OutPort::Cast( leftSubsystemOutPort_5560);
										if( currLeftSubsystemOutPort_555c!= currLeftSubsystemOutPort_5561)
											continue;
										Match currMatch;
										set< pair<int, Udm::Object> > boundObjs_5565;
										if( !isValidBound(boundObjs_5565, class_5544, true))
											continue;
										currMatch.class_5566= class_5544;
										if( !isValidBound(boundObjs_5565, currBlock_554b, false))
											continue;
										currMatch.block_5567= currBlock_554b;
										if( !isValidBound(boundObjs_5565, currSubsystem_5548, false))
											continue;
										currMatch.subsystem_5568= currSubsystem_5548;
										if( !isValidBound(boundObjs_5565, currRightSubsystemOutPort_554e, false))
											continue;
										currMatch.rightSubsystemOutPort_5569= currRightSubsystemOutPort_554e;
										if( !isValidBound(boundObjs_5565, currRightArg_5554, false))
											continue;
										currMatch.rightArg_556a= currRightArg_5554;
										if( !isValidBound(boundObjs_5565, currOutPort_5551, false))
											continue;
										currMatch.outPort_556b= currOutPort_5551;
										if( !isValidBound(boundObjs_5565, currLine_555f, false))
											continue;
										currMatch.line_556c= currLine_555f;
										if( !isValidBound(boundObjs_5565, currLeftSubsystemOutPort_555c, false))
											continue;
										currMatch.leftSubsystemOutPort_556d= currLeftSubsystemOutPort_555c;
										if( !isValidBound(boundObjs_5565, currLeftArg_5559, false))
											continue;
										currMatch.leftArg_556e= currLeftArg_5559;
										if( !isValidBound(boundObjs_5565, functionRightArg_5556, false))
											continue;
										currMatch.function_556f= functionRightArg_5556;
										bool Gz_guard= isGuardTrue( currMatch.block_5567, currMatch.class_5566, currMatch.function_556f, currMatch.leftArg_556e, currMatch.leftSubsystemOutPort_556d, currMatch.line_556c, currMatch.outPort_556b, currMatch.rightArg_556a, currMatch.rightSubsystemOutPort_5569, currMatch.subsystem_5568);
										if( true== Gz_guard)
											_matches.push_back( currMatch);
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return !_matches.empty();
}

void IdenticalOutArgs_553a::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		CyberComposition::Simulink::Block& Block= currMatch.block_5567;
		SFC::Class& Class= currMatch.class_5566;
		SFC::Function& Function= currMatch.function_556f;
		SFC::Arg& LeftArg= currMatch.leftArg_556e;
		CyberComposition::Simulink::OutPort& LeftSubsystemOutPort= currMatch.leftSubsystemOutPort_556d;
		CyberComposition::Simulink::Line& Line= currMatch.line_556c;
		CyberComposition::Simulink::OutPort& OutPort= currMatch.outPort_556b;
		SFC::Arg& RightArg= currMatch.rightArg_556a;
		CyberComposition::Simulink::OutPort& RightSubsystemOutPort= currMatch.rightSubsystemOutPort_5569;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_5568;
		{
getSFCSymbolTable().push( "right", RightArg );
getSFCSymbolTable().push( "left", LeftArg );

mstat2SFC( Function, "left = right", true );

getSFCSymbolTable().clear();
};
	}
}

void CheckPorts_5584::operator()( const Packets_t& comptypes_5585, const Packets_t& projects_5587, Packets_t& dataflows_5589, Packets_t& projects_558a)
{
#ifdef PRINT_INFO
	printLog( "CheckPorts_5584" );
#endif
	_dataflow_558b= &dataflows_5589;
	_project_558c= &projects_558a;
	if( ( !comptypes_5585.empty())&& ( !projects_5587.empty()))
		callCheckPortTypes_5771( comptypes_5585, projects_5587);
}

void CheckPorts_5584::callCheckPortTypes_5771( const Packets_t& dataflows_5631, const Packets_t& projects_5633)
{
	Packets_t dataflows_5635;
	Packets_t projects_5636;
	CheckPortTypes_5630 checkPortTypes_5630;
	checkPortTypes_5630( dataflows_5631, projects_5633, dataflows_5635, projects_5636);
	if( ( !dataflows_5635.empty())&& ( !projects_5636.empty()))
		callCheckError_5774( dataflows_5635, projects_5636);
}

void CheckPorts_5584::callCheckError_5774( const Packets_t& dataflows_558e, const Packets_t& projects_5590)
{
	Packets_t dataflows_5592;
	Packets_t projects_5593;
	CheckError_558d checkError_558d;
	checkError_558d( dataflows_558e, projects_5590, dataflows_5592, projects_5593);
	_dataflow_558b->insert( _dataflow_558b->end(), dataflows_5592.begin(), dataflows_5592.end());
	_project_558c->insert( _project_558c->end(), projects_5593.begin(), projects_5593.end());
}

void CheckError_558d::operator()( const Packets_t& dataflows_558e, const Packets_t& projects_5590, Packets_t& dataflows_5592, Packets_t& projects_5593)
{
#ifdef PRINT_INFO
	printLog( "CheckError_558d" );
#endif
	_dataflow_5594= &dataflows_5592;
	_project_5595= &projects_5593;
	for( Packets_t::const_iterator itdataflow_5597= dataflows_558e.begin(), itproject_559e= projects_5590.begin(); itdataflow_5597!= dataflows_558e.end(), itproject_559e!= projects_5590.end(); ++itdataflow_5597, ++itproject_559e)
	{
		bool isUnique= isInputUnique( *itdataflow_5597, *itproject_559e);
		if( !isUnique)
			continue;
		Packets_t onedataflow_559b( 1, *itdataflow_5597);
		Packets_t oneproject_55a2( 1, *itproject_559e);
		executeOne( onedataflow_559b, oneproject_55a2);
	}
}

void CheckError_558d::executeOne( const Packets_t& dataflows_558e, const Packets_t& projects_5590)
{
	if( ( !dataflows_558e.empty())&& ( !projects_5590.empty()))
		callCheckError_562a( dataflows_558e, projects_5590);
}

bool CheckError_558d::isInputUnique( const Udm::Object& dataflow_5598, const Udm::Object& project_559f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itdataflow_559a= _dataflow_5596.begin(), itproject_55a1= _project_559d.begin(); itdataflow_559a!= _dataflow_5596.end(), itproject_55a1!= _project_559d.end(); ++itdataflow_559a, ++itproject_55a1)
	{
		if( ( *itdataflow_559a== dataflow_5598)&& ( *itproject_55a1== project_559f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_dataflow_5596.push_back( dataflow_5598);
		_project_559d.push_back( project_559f);
	}
	return isUnique;
}

void CheckError_558d::callCheckError_562a( const Packets_t& dataflows_55c2, const Packets_t& projects_55c4)
{
	Packets_t dataflows_55c6;
	Packets_t projects_55c7;
	Packets_t dataflows_55c8;
	Packets_t projects_55c9;
	CheckError_55c1 checkError_55c1;
	checkError_55c1( dataflows_55c2, projects_55c4, dataflows_55c6, projects_55c7, dataflows_55c8, projects_55c9);
	if( ( !dataflows_55c8.empty())&& ( !projects_55c9.empty()))
		callReportError_562d( dataflows_55c8, projects_55c9);
	_dataflow_5594->insert( _dataflow_5594->end(), dataflows_55c6.begin(), dataflows_55c6.end());
	_project_5595->insert( _project_5595->end(), projects_55c7.begin(), projects_55c7.end());
}

void CheckError_558d::callReportError_562d( const Packets_t& dataflows_55a5, const Packets_t& projects_55a7)
{
	ReportError_55a4 reportError_55a4;
	reportError_55a4( dataflows_55a5, projects_55a7);
}

void ReportError_55a4::operator()( const Packets_t& dataflows_55a5, const Packets_t& projects_55a7)
{
#ifdef PRINT_INFO
	printLog( "ReportError_55a4" );
#endif
	RTTGenerator::Instance()->generateRule(1735, "ReportError");
	processInputPackets( dataflows_55a5, projects_55a7);
}

bool ReportError_55a4::isInputUnique( const Udm::Object& dataflow_55ad, const Udm::Object& project_55b6)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itDataflow_55af= _dataflow_55a9.begin(), itProject_55b8= _project_55b2.begin(); itDataflow_55af!= _dataflow_55a9.end(), itProject_55b8!= _project_55b2.end(); ++itDataflow_55af, ++itProject_55b8)
	{
		if( ( *itDataflow_55af== dataflow_55ad)&& ( *itProject_55b8== project_55b6))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_dataflow_55a9.push_back( dataflow_55ad);
		_project_55b2.push_back( project_55b6);
	}
	return isUnique;
}

bool ReportError_55a4::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void ReportError_55a4::processInputPackets( const Packets_t& dataflows_55a5, const Packets_t& projects_55a7)
{
	for( Packets_t::const_iterator itDataflow_55aa= dataflows_55a5.begin(), itProject_55b3= projects_55a7.begin(); itDataflow_55aa!= dataflows_55a5.end(), itProject_55b3!= projects_55a7.end(); ++itDataflow_55aa, ++itProject_55b3)
	{
		bool isUnique= isInputUnique( *itDataflow_55aa, *itProject_55b3);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itDataflow_55aa, *itProject_55b3);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ReportError_55a4::patternMatcher( const Udm::Object& dataflow_55ab, const Udm::Object& project_55b4)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( dataflow_55ab.type(), CyberComposition::SimulinkWrapper::meta))
			continue;
		CyberComposition::SimulinkWrapper dataflow_55b0= CyberComposition::SimulinkWrapper::Cast( dataflow_55ab);
		if( false== Uml::IsDerivedFrom( project_55b4.type(), SFC::Project::meta))
			continue;
		SFC::Project project_55b9= SFC::Project::Cast( project_55b4);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_55be;
		if( !isValidBound(boundObjs_55be, dataflow_55b0, true))
			continue;
		currMatch.dataflow_55bf= dataflow_55b0;
		if( !isValidBound(boundObjs_55be, project_55b9, true))
			continue;
		currMatch.project_55c0= project_55b9;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void ReportError_55a4::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		CyberComposition::SimulinkWrapper& Dataflow= currMatch.dataflow_55bf;
		SFC::Project& Project= currMatch.project_55c0;
		{
SFUtils::setErrorReported();
std::cerr << "ERROR:  One or more ports in the CyPhyML model (Dataflow portion) do not have a type associated with them."<<std::endl;
};
	}
}

void CheckError_55c1::operator()( const Packets_t& dataflows_55c2, const Packets_t& projects_55c4, Packets_t& dataflows_55c6, Packets_t& projects_55c7, Packets_t& dataflows_55c8, Packets_t& projects_55c9)
{
#ifdef PRINT_INFO
	printLog( "CheckError_55c1" );
#endif
	_dataflow_55ca= &dataflows_55c6;
	_project_55cb= &projects_55c7;
	_dataflow_55cc= &dataflows_55c8;
	_project_55cd= &projects_55c9;
	for( Packets_t::const_iterator itdataflow_55cf= dataflows_55c2.begin(), itproject_55d6= projects_55c4.begin(); itdataflow_55cf!= dataflows_55c2.end(), itproject_55d6!= projects_55c4.end(); ++itdataflow_55cf, ++itproject_55d6)
	{
		bool isUnique= isInputUnique( *itdataflow_55cf, *itproject_55d6);
		if( !isUnique)
			continue;
		Packets_t onedataflow_55d3( 1, *itdataflow_55cf);
		Packets_t oneproject_55da( 1, *itproject_55d6);
		executeOne( onedataflow_55d3, oneproject_55da);
	}
}

void CheckError_55c1::executeOne( const Packets_t& dataflows_55c2, const Packets_t& projects_55c4)
{
	Packets_t dataflows_55df;
	Packets_t projects_55e2;
	NoError_55dc noError_55dc;
	bool isMatchNoError_55dc= noError_55dc( dataflows_55c2, projects_55c4, dataflows_55df, projects_55e2);
	_dataflow_55ca->insert( _dataflow_55ca->end(), dataflows_55df.begin(), dataflows_55df.end());
	_project_55cb->insert( _project_55cb->end(), projects_55e2.begin(), projects_55e2.end());
	if( isMatchNoError_55dc)
		return;
	Packets_t dataflows_5606;
	Packets_t projects_5609;
	NoErrorReported_5603 noErrorReported_5603;
	bool isMatchNoErrorReported_5603= noErrorReported_5603( dataflows_55c2, projects_55c4, dataflows_5606, projects_5609);
	_dataflow_55cc->insert( _dataflow_55cc->end(), dataflows_5606.begin(), dataflows_5606.end());
	_project_55cd->insert( _project_55cd->end(), projects_5609.begin(), projects_5609.end());
	if( isMatchNoErrorReported_5603)
		return;
}

bool CheckError_55c1::isInputUnique( const Udm::Object& dataflow_55d0, const Udm::Object& project_55d7)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itdataflow_55d2= _dataflow_55ce.begin(), itproject_55d9= _project_55d5.begin(); itdataflow_55d2!= _dataflow_55ce.end(), itproject_55d9!= _project_55d5.end(); ++itdataflow_55d2, ++itproject_55d9)
	{
		if( ( *itdataflow_55d2== dataflow_55d0)&& ( *itproject_55d9== project_55d7))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_dataflow_55ce.push_back( dataflow_55d0);
		_project_55d5.push_back( project_55d7);
	}
	return isUnique;
}

bool NoError_55dc::operator()( const Packets_t& dataflows_55dd, const Packets_t& projects_55e0, Packets_t& dataflows_55df, Packets_t& projects_55e2)
{
#ifdef PRINT_INFO
	printLog( "NoError_55dc" );
#endif
	_dataflow_55e3= &dataflows_55df;
	_project_55e4= &projects_55e2;
	processInputPackets( dataflows_55dd, projects_55e0);
	if( false== _matches.empty())
		return true;
	return false;
}

bool NoError_55dc::isInputUnique( const Udm::Object& dataflow_55e9, const Udm::Object& project_55f2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itDataflow_55eb= _dataflow_55e5.begin(), itProject_55f4= _project_55ee.begin(); itDataflow_55eb!= _dataflow_55e5.end(), itProject_55f4!= _project_55ee.end(); ++itDataflow_55eb, ++itProject_55f4)
	{
		if( ( *itDataflow_55eb== dataflow_55e9)&& ( *itProject_55f4== project_55f2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_dataflow_55e5.push_back( dataflow_55e9);
		_project_55ee.push_back( project_55f2);
	}
	return isUnique;
}

bool NoError_55dc::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool NoError_55dc::isGuardTrue( CyberComposition::SimulinkWrapper& Dataflow, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard = !SFUtils::getPortTypeError();;
	return Gz_guard;
}

void NoError_55dc::processInputPackets( const Packets_t& dataflows_55dd, const Packets_t& projects_55e0)
{
	for( Packets_t::const_iterator itDataflow_55e6= dataflows_55dd.begin(), itProject_55ef= projects_55e0.begin(); itDataflow_55e6!= dataflows_55dd.end(), itProject_55ef!= projects_55e0.end(); ++itDataflow_55e6, ++itProject_55ef)
	{
		bool isUnique= isInputUnique( *itDataflow_55e6, *itProject_55ef);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itDataflow_55e6, *itProject_55ef);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.dataflow_55fb, currMatch.project_55fc);
	}
}

bool NoError_55dc::patternMatcher( const Udm::Object& dataflow_55e7, const Udm::Object& project_55f0)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( dataflow_55e7.type(), CyberComposition::SimulinkWrapper::meta))
			continue;
		CyberComposition::SimulinkWrapper dataflow_55ec= CyberComposition::SimulinkWrapper::Cast( dataflow_55e7);
		if( false== Uml::IsDerivedFrom( project_55f0.type(), SFC::Project::meta))
			continue;
		SFC::Project project_55f5= SFC::Project::Cast( project_55f0);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_55fa;
		if( !isValidBound(boundObjs_55fa, dataflow_55ec, true))
			continue;
		currMatch.dataflow_55fb= dataflow_55ec;
		if( !isValidBound(boundObjs_55fa, project_55f5, true))
			continue;
		currMatch.project_55fc= project_55f5;
		bool Gz_guard= isGuardTrue( currMatch.dataflow_55fb, currMatch.project_55fc);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void NoError_55dc::outputAppender( const CyberComposition::SimulinkWrapper& dataflow_55ff, const SFC::Project& project_5601)
{
	_dataflow_55e3->push_back( dataflow_55ff);
	_project_55e4->push_back( project_5601);
}

bool NoErrorReported_5603::operator()( const Packets_t& dataflows_5604, const Packets_t& projects_5607, Packets_t& dataflows_5606, Packets_t& projects_5609)
{
#ifdef PRINT_INFO
	printLog( "NoErrorReported_5603" );
#endif
	_dataflow_560a= &dataflows_5606;
	_project_560b= &projects_5609;
	processInputPackets( dataflows_5604, projects_5607);
	if( false== _matches.empty())
		return true;
	return false;
}

bool NoErrorReported_5603::isInputUnique( const Udm::Object& dataflow_5610, const Udm::Object& project_5619)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itDataflow_5612= _dataflow_560c.begin(), itProject_561b= _project_5615.begin(); itDataflow_5612!= _dataflow_560c.end(), itProject_561b!= _project_5615.end(); ++itDataflow_5612, ++itProject_561b)
	{
		if( ( *itDataflow_5612== dataflow_5610)&& ( *itProject_561b== project_5619))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_dataflow_560c.push_back( dataflow_5610);
		_project_5615.push_back( project_5619);
	}
	return isUnique;
}

bool NoErrorReported_5603::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool NoErrorReported_5603::isGuardTrue( CyberComposition::SimulinkWrapper& Dataflow, SFC::Project& Project)
{
	bool Gz_guard= false;
	Gz_guard = !SFUtils::getErrorReported();;
	return Gz_guard;
}

void NoErrorReported_5603::processInputPackets( const Packets_t& dataflows_5604, const Packets_t& projects_5607)
{
	for( Packets_t::const_iterator itDataflow_560d= dataflows_5604.begin(), itProject_5616= projects_5607.begin(); itDataflow_560d!= dataflows_5604.end(), itProject_5616!= projects_5607.end(); ++itDataflow_560d, ++itProject_5616)
	{
		bool isUnique= isInputUnique( *itDataflow_560d, *itProject_5616);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itDataflow_560d, *itProject_5616);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.dataflow_5622, currMatch.project_5623);
	}
}

bool NoErrorReported_5603::patternMatcher( const Udm::Object& dataflow_560e, const Udm::Object& project_5617)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( dataflow_560e.type(), CyberComposition::SimulinkWrapper::meta))
			continue;
		CyberComposition::SimulinkWrapper dataflow_5613= CyberComposition::SimulinkWrapper::Cast( dataflow_560e);
		if( false== Uml::IsDerivedFrom( project_5617.type(), SFC::Project::meta))
			continue;
		SFC::Project project_561c= SFC::Project::Cast( project_5617);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5621;
		if( !isValidBound(boundObjs_5621, dataflow_5613, true))
			continue;
		currMatch.dataflow_5622= dataflow_5613;
		if( !isValidBound(boundObjs_5621, project_561c, true))
			continue;
		currMatch.project_5623= project_561c;
		bool Gz_guard= isGuardTrue( currMatch.dataflow_5622, currMatch.project_5623);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void NoErrorReported_5603::outputAppender( const CyberComposition::SimulinkWrapper& dataflow_5626, const SFC::Project& project_5628)
{
	_dataflow_560a->push_back( dataflow_5626);
	_project_560b->push_back( project_5628);
}

void CheckPortTypes_5630::operator()( const Packets_t& dataflows_5631, const Packets_t& projects_5633, Packets_t& dataflows_5635, Packets_t& projects_5636)
{
#ifdef PRINT_INFO
	printLog( "CheckPortTypes_5630" );
#endif
	_dataflow_5637= &dataflows_5635;
	_project_5638= &projects_5636;
	_dataflow_5637->insert( _dataflow_5637->end(), dataflows_5631.begin(), dataflows_5631.end());
	_project_5638->insert( _project_5638->end(), projects_5633.begin(), projects_5633.end());
	if( ( !dataflows_5631.empty()))
		callGetSubsystems_576d( dataflows_5631);
}

void CheckPortTypes_5630::callGetSubsystems_576d( const Packets_t& comptypes_115a)
{
	Packets_t subsystems_115c;
	GetSubsystems_1159 getSubsystems_1159;
	getSubsystems_1159( comptypes_115a, subsystems_115c);
	if( ( !subsystems_115c.empty()))
		callCheckAllPorts_576f( subsystems_115c);
}

void CheckPortTypes_5630::callCheckAllPorts_576f( const Packets_t& blocks_563a)
{
	CheckAllPorts_5639 checkAllPorts_5639;
	checkAllPorts_5639( blocks_563a);
}

void CheckAllPorts_5639::operator()( const Packets_t& blocks_563a)
{
#ifdef PRINT_INFO
	printLog( "CheckAllPorts_5639" );
#endif
	if( ( !blocks_563a.empty()))
		callFilterInstances_5765( blocks_563a);
}

void CheckAllPorts_5639::callFilterInstances_5765( const Packets_t& blocks_563d)
{
	Packets_t blocks_563f;
	FilterInstances_563c filterInstances_563c;
	filterInstances_563c( blocks_563d, blocks_563f);
	if( ( !blocks_563f.empty()))
		callCheckPorts_5767( blocks_563f);
}

void CheckAllPorts_5639::callCheckPorts_5767( const Packets_t& blocks_5666)
{
	Packets_t blocks_5668;
	CheckPorts_5665 checkPorts_5665;
	checkPorts_5665( blocks_5666, blocks_5668);
	if( ( !blocks_5668.empty()))
		callChartFilter_5769( blocks_5668);
}

void CheckAllPorts_5639::callChartFilter_5769( const Packets_t& blocks_570d)
{
	Packets_t systems_570f;
	Packets_t systems_5710;
	ChartFilter_570c chartFilter_570c;
	chartFilter_570c( blocks_570d, systems_570f, systems_5710);
	if( ( !systems_5710.empty()))
		callGetSubBlocks_576b( systems_5710);
}

void CheckAllPorts_5639::callGetSubBlocks_576b( const Packets_t& subsystems_574e)
{
	Packets_t blocks_574d;
	GetSubBlocks_574c getSubBlocks_574c;
	getSubBlocks_574c( subsystems_574e, blocks_574d);
	if( ( !blocks_574d.empty()))
		callFilterInstances_5765( blocks_574d);
}

void FilterInstances_563c::operator()( const Packets_t& blocks_563d, Packets_t& blocks_563f)
{
#ifdef PRINT_INFO
	printLog( "FilterInstances_563c" );
#endif
	_block_5640= &blocks_563f;
	if( ( !blocks_563d.empty()))
		callNotAnInstanceTest_5663( blocks_563d);
}

void FilterInstances_563c::callNotAnInstanceTest_5663( const Packets_t& blocks_5642)
{
	Packets_t blocks_5644;
	NotAnInstanceTest_5641 notAnInstanceTest_5641;
	notAnInstanceTest_5641( blocks_5642, blocks_5644);
	_block_5640->insert( _block_5640->end(), blocks_5644.begin(), blocks_5644.end());
}

void NotAnInstanceTest_5641::operator()( const Packets_t& blocks_5642, Packets_t& blocks_5644)
{
#ifdef PRINT_INFO
	printLog( "NotAnInstanceTest_5641" );
#endif
	_block_5645= &blocks_5644;
	for( Packets_t::const_iterator itblock_5647= blocks_5642.begin(); itblock_5647!= blocks_5642.end(); ++itblock_5647)
	{
		bool isUnique= isInputUnique( *itblock_5647);
		if( !isUnique)
			continue;
		Packets_t oneblock_564b( 1, *itblock_5647);
		executeOne( oneblock_564b);
	}
}

void NotAnInstanceTest_5641::executeOne( const Packets_t& blocks_5642)
{
	Packets_t blocks_5650;
	NotAnInstance_564d notAnInstance_564d;
	bool isMatchNotAnInstance_564d= notAnInstance_564d( blocks_5642, blocks_5650);
	_block_5645->insert( _block_5645->end(), blocks_5650.begin(), blocks_5650.end());
	if( isMatchNotAnInstance_564d)
		return;
}

bool NotAnInstanceTest_5641::isInputUnique( const Udm::Object& block_5648)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itblock_564a= _block_5646.begin(); itblock_564a!= _block_5646.end(); ++itblock_564a)
	{
		if( ( *itblock_564a== block_5648))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_block_5646.push_back( block_5648);
	return isUnique;
}

bool NotAnInstance_564d::operator()( const Packets_t& blocks_564e, Packets_t& blocks_5650)
{
#ifdef PRINT_INFO
	printLog( "NotAnInstance_564d" );
#endif
	_block_5651= &blocks_5650;
	processInputPackets( blocks_564e);
	if( false== _matches.empty())
		return true;
	return false;
}

bool NotAnInstance_564d::isInputUnique( const Udm::Object& block_5656)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itBlock_5658= _block_5652.begin(); itBlock_5658!= _block_5652.end(); ++itBlock_5658)
	{
		if( ( *itBlock_5658== block_5656))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_block_5652.push_back( block_5656);
	return isUnique;
}

bool NotAnInstance_564d::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool NotAnInstance_564d::isGuardTrue( CyberComposition::Simulink::Block& Block)
{
	bool Gz_guard= false;
	return !Block.isInstance();;
	return Gz_guard;
}

void NotAnInstance_564d::processInputPackets( const Packets_t& blocks_564e)
{
	for( Packets_t::const_iterator itBlock_5653= blocks_564e.begin(); itBlock_5653!= blocks_564e.end(); ++itBlock_5653)
	{
		bool isUnique= isInputUnique( *itBlock_5653);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itBlock_5653);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.block_565f);
	}
}

bool NotAnInstance_564d::patternMatcher( const Udm::Object& block_5654)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( block_5654.type(), CyberComposition::Simulink::Block::meta))
			continue;
		CyberComposition::Simulink::Block block_5659= CyberComposition::Simulink::Block::Cast( block_5654);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_565e;
		if( !isValidBound(boundObjs_565e, block_5659, true))
			continue;
		currMatch.block_565f= block_5659;
		bool Gz_guard= isGuardTrue( currMatch.block_565f);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void NotAnInstance_564d::outputAppender( const CyberComposition::Simulink::Block& block_5661)
{
	_block_5651->push_back( block_5661);
}

void CheckPorts_5665::operator()( const Packets_t& blocks_5666, Packets_t& blocks_5668)
{
#ifdef PRINT_INFO
	printLog( "CheckPorts_5665" );
#endif
	_block_5669= &blocks_5668;
	if( ( !blocks_5666.empty()))
		callGetPorts_5705( blocks_5666);
}

void CheckPorts_5665::callGetPorts_5705( const Packets_t& blocks_56d6)
{
	Packets_t blocks_56d8;
	Packets_t ports_56d9;
	GetPorts_56d5 getPorts_56d5;
	getPorts_56d5( blocks_56d6, blocks_56d8, ports_56d9);
	if( ( !blocks_56d8.empty())&& ( !ports_56d9.empty()))
		callCheckPort_5707( blocks_56d8, ports_56d9);
}

void CheckPorts_5665::callCheckPort_5707( const Packets_t& blocks_566b, const Packets_t& ports_566d)
{
	Packets_t blocks_566f;
	Packets_t ports_5670;
	Packets_t blocks_5671;
	Packets_t ports_5672;
	CheckPort_566a checkPort_566a;
	checkPort_566a( blocks_566b, ports_566d, blocks_566f, ports_5670, blocks_5671, ports_5672);
	if( ( !blocks_5671.empty()))
		callSetError_570a( blocks_5671);
	_block_5669->insert( _block_5669->end(), blocks_566f.begin(), blocks_566f.end());
}

void CheckPorts_5665::callSetError_570a( const Packets_t& blocks_56f3)
{
	Packets_t blocks_56f5;
	SetError_56f2 setError_56f2;
	setError_56f2( blocks_56f3, blocks_56f5);
	_block_5669->insert( _block_5669->end(), blocks_56f5.begin(), blocks_56f5.end());
}

void CheckPort_566a::operator()( const Packets_t& blocks_566b, const Packets_t& ports_566d, Packets_t& blocks_566f, Packets_t& ports_5670, Packets_t& blocks_5671, Packets_t& ports_5672)
{
#ifdef PRINT_INFO
	printLog( "CheckPort_566a" );
#endif
	_block_5673= &blocks_566f;
	_port_5674= &ports_5670;
	_block_5675= &blocks_5671;
	_port_5676= &ports_5672;
	for( Packets_t::const_iterator itblock_5678= blocks_566b.begin(), itport_567f= ports_566d.begin(); itblock_5678!= blocks_566b.end(), itport_567f!= ports_566d.end(); ++itblock_5678, ++itport_567f)
	{
		bool isUnique= isInputUnique( *itblock_5678, *itport_567f);
		if( !isUnique)
			continue;
		Packets_t oneblock_567c( 1, *itblock_5678);
		Packets_t oneport_5683( 1, *itport_567f);
		executeOne( oneblock_567c, oneport_5683);
	}
}

void CheckPort_566a::executeOne( const Packets_t& blocks_566b, const Packets_t& ports_566d)
{
	Packets_t blocks_5688;
	Packets_t ports_568b;
	PortHasType_5685 portHasType_5685;
	bool isMatchPortHasType_5685= portHasType_5685( blocks_566b, ports_566d, blocks_5688, ports_568b);
	_block_5673->insert( _block_5673->end(), blocks_5688.begin(), blocks_5688.end());
	_port_5674->insert( _port_5674->end(), ports_568b.begin(), ports_568b.end());
	if( isMatchPortHasType_5685)
		return;
	Packets_t blocks_56b3;
	Packets_t ports_56b6;
	Otherwise_56b0 otherwise_56b0;
	bool isMatchOtherwise_56b0= otherwise_56b0( blocks_566b, ports_566d, blocks_56b3, ports_56b6);
	_block_5675->insert( _block_5675->end(), blocks_56b3.begin(), blocks_56b3.end());
	_port_5676->insert( _port_5676->end(), ports_56b6.begin(), ports_56b6.end());
	if( isMatchOtherwise_56b0)
		return;
}

bool CheckPort_566a::isInputUnique( const Udm::Object& block_5679, const Udm::Object& port_5680)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itblock_567b= _block_5677.begin(), itport_5682= _port_567e.begin(); itblock_567b!= _block_5677.end(), itport_5682!= _port_567e.end(); ++itblock_567b, ++itport_5682)
	{
		if( ( *itblock_567b== block_5679)&& ( *itport_5682== port_5680))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_block_5677.push_back( block_5679);
		_port_567e.push_back( port_5680);
	}
	return isUnique;
}

bool PortHasType_5685::operator()( const Packets_t& blocks_5686, const Packets_t& ports_5689, Packets_t& blocks_5688, Packets_t& ports_568b)
{
#ifdef PRINT_INFO
	printLog( "PortHasType_5685" );
#endif
	_block_568c= &blocks_5688;
	_port_568d= &ports_568b;
	processInputPackets( blocks_5686, ports_5689);
	if( false== _matches.empty())
		return true;
	return false;
}

bool PortHasType_5685::isInputUnique( const Udm::Object& block_5692, const Udm::Object& port_569b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itBlock_5694= _block_568e.begin(), itPort_569d= _port_5697.begin(); itBlock_5694!= _block_568e.end(), itPort_569d!= _port_5697.end(); ++itBlock_5694, ++itPort_569d)
	{
		if( ( *itBlock_5694== block_5692)&& ( *itPort_569d== port_569b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_block_568e.push_back( block_5692);
		_port_5697.push_back( port_569b);
	}
	return isUnique;
}

bool PortHasType_5685::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void PortHasType_5685::processInputPackets( const Packets_t& blocks_5686, const Packets_t& ports_5689)
{
	for( Packets_t::const_iterator itBlock_568f= blocks_5686.begin(), itPort_5698= ports_5689.begin(); itBlock_568f!= blocks_5686.end(), itPort_5698!= ports_5689.end(); ++itBlock_568f, ++itPort_5698)
	{
		bool isUnique= isInputUnique( *itBlock_568f, *itPort_5698);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itBlock_568f, *itPort_5698);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.block_56a8, currMatch.port_56a9);
	}
}

bool PortHasType_5685::patternMatcher( const Udm::Object& block_5690, const Udm::Object& port_5699)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( block_5690.type(), CyberComposition::Simulink::Block::meta))
			continue;
		CyberComposition::Simulink::Block block_5695= CyberComposition::Simulink::Block::Cast( block_5690);
		if( false== Uml::IsDerivedFrom( port_5699.type(), CyberComposition::Simulink::SF_Port::meta))
			continue;
		CyberComposition::Simulink::SF_Port port_569e= CyberComposition::Simulink::SF_Port::Cast( port_5699);
		set< CyberComposition::Simulink::TypeBaseRef> typeBaseRefs_56a0= port_569e.TypeBaseRef_kind_children();
		for( set< CyberComposition::Simulink::TypeBaseRef>::const_iterator itTypeBaseRef_56a1= typeBaseRefs_56a0.begin(); itTypeBaseRef_56a1!= typeBaseRefs_56a0.end(); ++itTypeBaseRef_56a1)
		{
			CyberComposition::Simulink::TypeBaseRef currTypeBaseRef_56a2= *itTypeBaseRef_56a1;
			CyberComposition::Simulink::SF_TypeBase typeBase_56a3= currTypeBaseRef_56a2.ref();
			if( !typeBase_56a3)
				continue;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_56a7;
			if( !isValidBound(boundObjs_56a7, block_5695, true))
				continue;
			currMatch.block_56a8= block_5695;
			if( !isValidBound(boundObjs_56a7, port_569e, true))
				continue;
			currMatch.port_56a9= port_569e;
			if( !isValidBound(boundObjs_56a7, currTypeBaseRef_56a2, false))
				continue;
			currMatch.typeBaseRef_56aa= currTypeBaseRef_56a2;
			if( !isValidBound(boundObjs_56a7, typeBase_56a3, false))
				continue;
			currMatch.typeBase_56ab= typeBase_56a3;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void PortHasType_5685::outputAppender( const CyberComposition::Simulink::Block& block_56ac, const CyberComposition::Simulink::SF_Port& port_56ae)
{
	_block_568c->push_back( block_56ac);
	_port_568d->push_back( port_56ae);
}

bool Otherwise_56b0::operator()( const Packets_t& blocks_56b1, const Packets_t& ports_56b4, Packets_t& blocks_56b3, Packets_t& ports_56b6)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_56b0" );
#endif
	_block_56b7= &blocks_56b3;
	_port_56b8= &ports_56b6;
	processInputPackets( blocks_56b1, ports_56b4);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_56b0::isInputUnique( const Udm::Object& block_56bd, const Udm::Object& port_56c6)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itBlock_56bf= _block_56b9.begin(), itPort_56c8= _port_56c2.begin(); itBlock_56bf!= _block_56b9.end(), itPort_56c8!= _port_56c2.end(); ++itBlock_56bf, ++itPort_56c8)
	{
		if( ( *itBlock_56bf== block_56bd)&& ( *itPort_56c8== port_56c6))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_block_56b9.push_back( block_56bd);
		_port_56c2.push_back( port_56c6);
	}
	return isUnique;
}

bool Otherwise_56b0::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_56b0::processInputPackets( const Packets_t& blocks_56b1, const Packets_t& ports_56b4)
{
	for( Packets_t::const_iterator itBlock_56ba= blocks_56b1.begin(), itPort_56c3= ports_56b4.begin(); itBlock_56ba!= blocks_56b1.end(), itPort_56c3!= ports_56b4.end(); ++itBlock_56ba, ++itPort_56c3)
	{
		bool isUnique= isInputUnique( *itBlock_56ba, *itPort_56c3);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itBlock_56ba, *itPort_56c3);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.block_56cf, currMatch.port_56d0);
	}
}

bool Otherwise_56b0::patternMatcher( const Udm::Object& block_56bb, const Udm::Object& port_56c4)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( block_56bb.type(), CyberComposition::Simulink::Block::meta))
			continue;
		CyberComposition::Simulink::Block block_56c0= CyberComposition::Simulink::Block::Cast( block_56bb);
		if( false== Uml::IsDerivedFrom( port_56c4.type(), CyberComposition::Simulink::SF_Port::meta))
			continue;
		CyberComposition::Simulink::SF_Port port_56c9= CyberComposition::Simulink::SF_Port::Cast( port_56c4);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_56ce;
		if( !isValidBound(boundObjs_56ce, block_56c0, true))
			continue;
		currMatch.block_56cf= block_56c0;
		if( !isValidBound(boundObjs_56ce, port_56c9, true))
			continue;
		currMatch.port_56d0= port_56c9;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_56b0::outputAppender( const CyberComposition::Simulink::Block& block_56d1, const CyberComposition::Simulink::SF_Port& port_56d3)
{
	_block_56b7->push_back( block_56d1);
	_port_56b8->push_back( port_56d3);
}

void GetPorts_56d5::operator()( const Packets_t& blocks_56d6, Packets_t& blocks_56d8, Packets_t& ports_56d9)
{
#ifdef PRINT_INFO
	printLog( "GetPorts_56d5" );
#endif
	RTTGenerator::Instance()->generateRule(1787, "GetPorts");
	_block_56da= &blocks_56d8;
	_port_56db= &ports_56d9;
	processInputPackets( blocks_56d6);
}

bool GetPorts_56d5::isInputUnique( const Udm::Object& block_56e0)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itBlock_56e2= _block_56dc.begin(); itBlock_56e2!= _block_56dc.end(); ++itBlock_56e2)
	{
		if( ( *itBlock_56e2== block_56e0))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_block_56dc.push_back( block_56e0);
	return isUnique;
}

bool GetPorts_56d5::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetPorts_56d5::processInputPackets( const Packets_t& blocks_56d6)
{
	for( Packets_t::const_iterator itBlock_56dd= blocks_56d6.begin(); itBlock_56dd!= blocks_56d6.end(); ++itBlock_56dd)
	{
		bool isUnique= isInputUnique( *itBlock_56dd);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itBlock_56dd);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetPorts_56d5::patternMatcher( const Udm::Object& block_56de)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( block_56de.type(), CyberComposition::Simulink::Block::meta))
			continue;
		CyberComposition::Simulink::Block block_56e3= CyberComposition::Simulink::Block::Cast( block_56de);
		set< CyberComposition::Simulink::SF_Port> ports_56e5= block_56e3.SF_Port_kind_children();
		for( set< CyberComposition::Simulink::SF_Port>::const_iterator itPort_56e6= ports_56e5.begin(); itPort_56e6!= ports_56e5.end(); ++itPort_56e6)
		{
			CyberComposition::Simulink::SF_Port currPort_56e7= *itPort_56e6;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_56eb;
			if( !isValidBound(boundObjs_56eb, block_56e3, true))
				continue;
			currMatch.block_56ec= block_56e3;
			if( !isValidBound(boundObjs_56eb, currPort_56e7, false))
				continue;
			currMatch.port_56ed= currPort_56e7;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetPorts_56d5::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.block_56ec, currMatch.port_56ed);
	}
}

void GetPorts_56d5::outputAppender( const CyberComposition::Simulink::Block& block_56ee, const CyberComposition::Simulink::SF_Port& port_56f0)
{
	_block_56da->push_back( block_56ee);
	_port_56db->push_back( port_56f0);
}

void SetError_56f2::operator()( const Packets_t& blocks_56f3, Packets_t& blocks_56f5)
{
#ifdef PRINT_INFO
	printLog( "SetError_56f2" );
#endif
	RTTGenerator::Instance()->generateRule(1791, "SetError");
	_block_56f6= &blocks_56f5;
	processInputPackets( blocks_56f3);
	forwardInputs( );
}

bool SetError_56f2::isInputUnique( const Udm::Object& block_56fb)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itBlock_56fd= _block_56f7.begin(); itBlock_56fd!= _block_56f7.end(); ++itBlock_56fd)
	{
		if( ( *itBlock_56fd== block_56fb))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_block_56f7.push_back( block_56fb);
	return isUnique;
}

bool SetError_56f2::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void SetError_56f2::processInputPackets( const Packets_t& blocks_56f3)
{
	for( Packets_t::const_iterator itBlock_56f8= blocks_56f3.begin(); itBlock_56f8!= blocks_56f3.end(); ++itBlock_56f8)
	{
		bool isUnique= isInputUnique( *itBlock_56f8);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itBlock_56f8);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool SetError_56f2::patternMatcher( const Udm::Object& block_56f9)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( block_56f9.type(), CyberComposition::Simulink::Block::meta))
			continue;
		CyberComposition::Simulink::Block block_56fe= CyberComposition::Simulink::Block::Cast( block_56f9);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5703;
		if( !isValidBound(boundObjs_5703, block_56fe, true))
			continue;
		currMatch.block_5704= block_56fe;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void SetError_56f2::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		CyberComposition::Simulink::Block& Block= currMatch.block_5704;
		{
SFUtils::setPortTypeError();
};
	}
}

void SetError_56f2::forwardInputs()
{
	*_block_56f6= _block_56f7;
}

void ChartFilter_570c::operator()( const Packets_t& blocks_570d, Packets_t& systems_570f, Packets_t& systems_5710)
{
#ifdef PRINT_INFO
	printLog( "ChartFilter_570c" );
#endif
	_system_5711= &systems_570f;
	_system_5712= &systems_5710;
	for( Packets_t::const_iterator itblock_5714= blocks_570d.begin(); itblock_5714!= blocks_570d.end(); ++itblock_5714)
	{
		bool isUnique= isInputUnique( *itblock_5714);
		if( !isUnique)
			continue;
		Packets_t oneblock_5718( 1, *itblock_5714);
		executeOne( oneblock_5718);
	}
}

void ChartFilter_570c::executeOne( const Packets_t& blocks_570d)
{
	Packets_t subsystems_571d;
	Block_571a block_571a;
	bool isMatchBlock_571a= block_571a( blocks_570d, subsystems_571d);
	_system_5711->insert( _system_5711->end(), subsystems_571d.begin(), subsystems_571d.end());
	if( isMatchBlock_571a)
		return;
	Packets_t subsystems_573a;
	IsSubsystem_5737 isSubsystem_5737;
	bool isMatchIsSubsystem_5737= isSubsystem_5737( blocks_570d, subsystems_573a);
	_system_5712->insert( _system_5712->end(), subsystems_573a.begin(), subsystems_573a.end());
	if( isMatchIsSubsystem_5737)
		return;
}

bool ChartFilter_570c::isInputUnique( const Udm::Object& block_5715)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itblock_5717= _block_5713.begin(); itblock_5717!= _block_5713.end(); ++itblock_5717)
	{
		if( ( *itblock_5717== block_5715))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_block_5713.push_back( block_5715);
	return isUnique;
}

bool Block_571a::operator()( const Packets_t& subsystems_571b, Packets_t& subsystems_571d)
{
#ifdef PRINT_INFO
	printLog( "Block_571a" );
#endif
	_subsystem_571e= &subsystems_571d;
	processInputPackets( subsystems_571b);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Block_571a::isInputUnique( const Udm::Object& subsystem_5723)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_5725= _subsystem_571f.begin(); itSubsystem_5725!= _subsystem_571f.end(); ++itSubsystem_5725)
	{
		if( ( *itSubsystem_5725== subsystem_5723))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_subsystem_571f.push_back( subsystem_5723);
	return isUnique;
}

bool Block_571a::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Block_571a::processInputPackets( const Packets_t& subsystems_571b)
{
	for( Packets_t::const_iterator itSubsystem_5720= subsystems_571b.begin(); itSubsystem_5720!= subsystems_571b.end(); ++itSubsystem_5720)
	{
		bool isUnique= isInputUnique( *itSubsystem_5720);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_5720);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_5732);
	}
}

bool Block_571a::patternMatcher( const Udm::Object& subsystem_5721)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_5721.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_5726= CyberComposition::Simulink::Subsystem::Cast( subsystem_5721);
		set< CyberComposition::Simulink::Primitive> primitives_5728= subsystem_5726.Primitive_kind_children();
		for( set< CyberComposition::Simulink::Primitive>::const_iterator itPrimitive_5729= primitives_5728.begin(); itPrimitive_5729!= primitives_5728.end(); ++itPrimitive_5729)
		{
			CyberComposition::Simulink::Primitive currPrimitive_572a= *itPrimitive_5729;
			set< CyberComposition::Simulink::State> states_572b= currPrimitive_572a.State_kind_children();
			for( set< CyberComposition::Simulink::State>::const_iterator itState_572c= states_572b.begin(); itState_572c!= states_572b.end(); ++itState_572c)
			{
				CyberComposition::Simulink::State currState_572d= *itState_572c;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_5731;
				if( !isValidBound(boundObjs_5731, subsystem_5726, true))
					continue;
				currMatch.subsystem_5732= subsystem_5726;
				if( !isValidBound(boundObjs_5731, currPrimitive_572a, false))
					continue;
				currMatch.primitive_5733= currPrimitive_572a;
				if( !isValidBound(boundObjs_5731, currState_572d, false))
					continue;
				currMatch.state_5734= currState_572d;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void Block_571a::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_5735)
{
	_subsystem_571e->push_back( subsystem_5735);
}

bool IsSubsystem_5737::operator()( const Packets_t& subsystems_5738, Packets_t& subsystems_573a)
{
#ifdef PRINT_INFO
	printLog( "IsSubsystem_5737" );
#endif
	_subsystem_573b= &subsystems_573a;
	processInputPackets( subsystems_5738);
	if( false== _matches.empty())
		return true;
	return false;
}

bool IsSubsystem_5737::isInputUnique( const Udm::Object& subsystem_5740)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_5742= _subsystem_573c.begin(); itSubsystem_5742!= _subsystem_573c.end(); ++itSubsystem_5742)
	{
		if( ( *itSubsystem_5742== subsystem_5740))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_subsystem_573c.push_back( subsystem_5740);
	return isUnique;
}

bool IsSubsystem_5737::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void IsSubsystem_5737::processInputPackets( const Packets_t& subsystems_5738)
{
	for( Packets_t::const_iterator itSubsystem_573d= subsystems_5738.begin(); itSubsystem_573d!= subsystems_5738.end(); ++itSubsystem_573d)
	{
		bool isUnique= isInputUnique( *itSubsystem_573d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_573d);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_5749);
	}
}

bool IsSubsystem_5737::patternMatcher( const Udm::Object& subsystem_573e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_573e.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_5743= CyberComposition::Simulink::Subsystem::Cast( subsystem_573e);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5748;
		if( !isValidBound(boundObjs_5748, subsystem_5743, true))
			continue;
		currMatch.subsystem_5749= subsystem_5743;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void IsSubsystem_5737::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_574a)
{
	_subsystem_573b->push_back( subsystem_574a);
}

void GetSubBlocks_574c::operator()( const Packets_t& subsystems_574e, Packets_t& blocks_574d)
{
#ifdef PRINT_INFO
	printLog( "GetSubBlocks_574c" );
#endif
	RTTGenerator::Instance()->generateRule(1806, "GetSubBlocks");
	_block_5750= &blocks_574d;
	processInputPackets( subsystems_574e);
}

bool GetSubBlocks_574c::isInputUnique( const Udm::Object& subsystem_5755)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_5757= _subsystem_5751.begin(); itSubsystem_5757!= _subsystem_5751.end(); ++itSubsystem_5757)
	{
		if( ( *itSubsystem_5757== subsystem_5755))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_subsystem_5751.push_back( subsystem_5755);
	return isUnique;
}

bool GetSubBlocks_574c::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetSubBlocks_574c::processInputPackets( const Packets_t& subsystems_574e)
{
	for( Packets_t::const_iterator itSubsystem_5752= subsystems_574e.begin(); itSubsystem_5752!= subsystems_574e.end(); ++itSubsystem_5752)
	{
		bool isUnique= isInputUnique( *itSubsystem_5752);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_5752);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetSubBlocks_574c::patternMatcher( const Udm::Object& subsystem_5753)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_5753.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_5758= CyberComposition::Simulink::Subsystem::Cast( subsystem_5753);
		set< CyberComposition::Simulink::Block> blocks_575a= subsystem_5758.Block_kind_children();
		for( set< CyberComposition::Simulink::Block>::const_iterator itBlock_575b= blocks_575a.begin(); itBlock_575b!= blocks_575a.end(); ++itBlock_575b)
		{
			CyberComposition::Simulink::Block currBlock_575c= *itBlock_575b;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_5760;
			if( !isValidBound(boundObjs_5760, subsystem_5758, true))
				continue;
			currMatch.subsystem_5761= subsystem_5758;
			if( !isValidBound(boundObjs_5760, currBlock_575c, false))
				continue;
			currMatch.block_5762= currBlock_575c;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetSubBlocks_574c::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.block_5762);
	}
}

void GetSubBlocks_574c::outputAppender( const CyberComposition::Simulink::Block& block_5763)
{
	_block_5750->push_back( block_5763);
}

void ParamInitFcn_5777::operator()( const Packets_t& dataflows_5778, const Packets_t& projects_577a, Packets_t& dataflows_577c, Packets_t& projects_577d)
{
#ifdef PRINT_INFO
	printLog( "ParamInitFcn_5777" );
#endif
	_dataflow_577e= &dataflows_577c;
	_project_577f= &projects_577d;
	_dataflow_577e->insert( _dataflow_577e->end(), dataflows_5778.begin(), dataflows_5778.end());
	_project_577f->insert( _project_577f->end(), projects_577a.begin(), projects_577a.end());
	if( ( !dataflows_5778.empty()))
		callCreateParamInitFcn_5a10( dataflows_5778);
}

void ParamInitFcn_5777::callCreateParamInitFcn_5a10( const Packets_t& sigflows_5781)
{
	CreateParamInitFcn_5780 createParamInitFcn_5780;
	createParamInitFcn_5780( sigflows_5781);
}

void CreateParamInitFcn_5780::operator()( const Packets_t& sigflows_5781)
{
#ifdef PRINT_INFO
	printLog( "CreateParamInitFcn_5780" );
#endif
	if( ( !sigflows_5781.empty()))
		callCreateParamInitFcn_59f2( sigflows_5781);
}

void CreateParamInitFcn_5780::callCreateParamInitFcn_59f2( const Packets_t& signalFlowModels_5784)
{
	Packets_t signalFlowModels_5786;
	Packets_t functions_5787;
	Packets_t contexts_5788;
	CreateParamInitFcn_5783 createParamInitFcn_5783;
	createParamInitFcn_5783( signalFlowModels_5784, signalFlowModels_5786, functions_5787, contexts_5788);
	if( ( !signalFlowModels_5786.empty())&& ( !functions_5787.empty())&& ( !contexts_5788.empty()))
		callSortParamRefs_59f4( signalFlowModels_5786, functions_5787, contexts_5788);
}

void CreateParamInitFcn_5780::callSortParamRefs_59f4( const Packets_t& signalFlowModels_59ba, const Packets_t& functions_59bd, const Packets_t& contexts_59c0)
{
	Packets_t parameterRefs_59bc;
	Packets_t functions_59bf;
	Packets_t contexts_59c2;
	SortParamRefs_59b9 sortParamRefs_59b9;
	sortParamRefs_59b9( signalFlowModels_59ba, functions_59bd, contexts_59c0, parameterRefs_59bc, functions_59bf, contexts_59c2);
	if( ( !parameterRefs_59bc.empty())&& ( !functions_59bf.empty())&& ( !contexts_59c2.empty()))
		callCreateAssignment_59f8( parameterRefs_59bc, functions_59bf, contexts_59c2);
}

void CreateParamInitFcn_5780::callCreateAssignment_59f8( const Packets_t& parameterRefs_57ad, const Packets_t& functions_57b0, const Packets_t& contexts_57b3)
{
	Packets_t localVars_57af;
	Packets_t dotExprss_57b2;
	Packets_t structs_57b5;
	CreateAssignment_57ac createAssignment_57ac;
	createAssignment_57ac( parameterRefs_57ad, functions_57b0, contexts_57b3, localVars_57af, dotExprss_57b2, structs_57b5);
	if( ( !localVars_57af.empty())&& ( !localVars_57af.empty())&& ( !dotExprss_57b2.empty())&& ( !structs_57b5.empty()))
		callTestContext_59fc( localVars_57af, localVars_57af, dotExprss_57b2, structs_57b5);
}

void CreateParamInitFcn_5780::callTestContext_59fc( const Packets_t& localvars_583b, const Packets_t& structvars_583d, const Packets_t& exprss_583f, const Packets_t& ctxstrcts_5841)
{
	Packets_t localVars_5843;
	Packets_t structvars_5844;
	Packets_t exprss_5845;
	Packets_t ctxstrcts_5846;
	Packets_t localVars_5847;
	Packets_t structvars_5848;
	Packets_t exprss_5849;
	Packets_t ctxstrcts_584a;
	Packets_t localVars_584b;
	Packets_t structvars_584c;
	Packets_t exprss_584d;
	Packets_t ctxstrcts_584e;
	TestContext_583a testContext_583a;
	testContext_583a( localvars_583b, structvars_583d, exprss_583f, ctxstrcts_5841, localVars_5843, structvars_5844, exprss_5845, ctxstrcts_5846, localVars_5847, structvars_5848, exprss_5849, ctxstrcts_584a, localVars_584b, structvars_584c, exprss_584d, ctxstrcts_584e);
	if( ( !localVars_584b.empty())&& ( !structvars_584c.empty())&& ( !exprss_584d.empty())&& ( !ctxstrcts_584e.empty()))
		callNextLocalVar_5a01( localVars_584b, structvars_584c, exprss_584d, ctxstrcts_584e);
	if( ( !localVars_5847.empty())&& ( !structvars_5848.empty())&& ( !exprss_5849.empty())&& ( !ctxstrcts_584a.empty()))
		callNextDot_5a06( localVars_5847, structvars_5848, exprss_5849, ctxstrcts_584a);
	if( ( !localVars_5843.empty())&& ( !structvars_5844.empty())&& ( !exprss_5845.empty())&& ( !ctxstrcts_5846.empty()))
		callLastDot_5a0b( localVars_5843, structvars_5844, exprss_5845, ctxstrcts_5846);
}

void CreateParamInitFcn_5780::callNextLocalVar_5a01( const Packets_t& localVars_57f2, const Packets_t& structVars_57f5, const Packets_t& dotExprss_57f8, const Packets_t& structs_57fb)
{
	Packets_t localVars_57f4;
	Packets_t nextStructVars_57f7;
	Packets_t dotExprss_57fa;
	Packets_t structs_57fd;
	NextLocalVar_57f1 nextLocalVar_57f1;
	nextLocalVar_57f1( localVars_57f2, structVars_57f5, dotExprss_57f8, structs_57fb, localVars_57f4, nextStructVars_57f7, dotExprss_57fa, structs_57fd);
	if( ( !localVars_57f4.empty())&& ( !nextStructVars_57f7.empty())&& ( !dotExprss_57fa.empty())&& ( !structs_57fd.empty()))
		callTestContext_59fc( localVars_57f4, nextStructVars_57f7, dotExprss_57fa, structs_57fd);
}

void CreateParamInitFcn_5780::callNextDot_5a06( const Packets_t& localVars_5977, const Packets_t& structVars_597a, const Packets_t& dotExprss_597c, const Packets_t& structs_597f)
{
	Packets_t localVars_5979;
	Packets_t nextDotExprss_597e;
	Packets_t nextStructs_5981;
	NextDot_5976 nextDot_5976;
	nextDot_5976( localVars_5977, structVars_597a, dotExprss_597c, structs_597f, localVars_5979, nextDotExprss_597e, nextStructs_5981);
	if( ( !localVars_5979.empty())&& ( !localVars_5979.empty())&& ( !nextDotExprss_597e.empty())&& ( !nextStructs_5981.empty()))
		callTestContext_59fc( localVars_5979, localVars_5979, nextDotExprss_597e, nextStructs_5981);
}

void CreateParamInitFcn_5780::callLastDot_5a0b( const Packets_t& localVars_5944, const Packets_t& structVars_5946, const Packets_t& dotExprss_5948, const Packets_t& structs_594a)
{
	LastDot_5943 lastDot_5943;
	lastDot_5943( localVars_5944, structVars_5946, dotExprss_5948, structs_594a);
}

void CreateParamInitFcn_5783::operator()( const Packets_t& signalFlowModels_5784, Packets_t& signalFlowModels_5786, Packets_t& functions_5787, Packets_t& contexts_5788)
{
#ifdef PRINT_INFO
	printLog( "CreateParamInitFcn_5783" );
#endif
	RTTGenerator::Instance()->generateRule(1817, "CreateParamInitFcn");
	_signalFlowModel_5789= &signalFlowModels_5786;
	_function_578a= &functions_5787;
	_context_578b= &contexts_5788;
	processInputPackets( signalFlowModels_5784);
}

bool CreateParamInitFcn_5783::isInputUnique( const Udm::Object& signalFlowModel_5790)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSignalFlowModel_5792= _signalFlowModel_578c.begin(); itSignalFlowModel_5792!= _signalFlowModel_578c.end(); ++itSignalFlowModel_5792)
	{
		if( ( *itSignalFlowModel_5792== signalFlowModel_5790))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
		_signalFlowModel_578c.push_back( signalFlowModel_5790);
	return isUnique;
}

bool CreateParamInitFcn_5783::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateParamInitFcn_5783::processInputPackets( const Packets_t& signalFlowModels_5784)
{
	for( Packets_t::const_iterator itSignalFlowModel_578d= signalFlowModels_5784.begin(); itSignalFlowModel_578d!= signalFlowModels_5784.end(); ++itSignalFlowModel_578d)
	{
		bool isUnique= isInputUnique( *itSignalFlowModel_578d);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSignalFlowModel_578d);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateParamInitFcn_5783::patternMatcher( const Udm::Object& signalFlowModel_578e)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( signalFlowModel_578e.type(), CyberComposition::SimulinkWrapper::meta))
			continue;
		CyberComposition::SimulinkWrapper signalFlowModel_5793= CyberComposition::SimulinkWrapper::Cast( signalFlowModel_578e);
		set< CyberComposition::Simulink::Subsystem> subsystems_5795= signalFlowModel_5793.Simulink_Subsystem_kind_children();
		for( set< CyberComposition::Simulink::Subsystem>::const_iterator itSubsystem_5796= subsystems_5795.begin(); itSubsystem_5796!= subsystems_5795.end(); ++itSubsystem_5796)
		{
			CyberComposition::Simulink::Subsystem currSubsystem_5797= *itSubsystem_5796;
			SFC::Class class_5798= currSubsystem_5797.cls();
			if( !class_5798)
				continue;
			set< SFC::Struct> structs_5799= class_5798.Struct_kind_children();
			for( set< SFC::Struct>::const_iterator itStruct_579a= structs_5799.begin(); itStruct_579a!= structs_5799.end(); ++itStruct_579a)
			{
				SFC::Struct currStruct_579b= *itStruct_579a;
				Match currMatch;
				set< pair<int, Udm::Object> > boundObjs_579f;
				if( !isValidBound(boundObjs_579f, signalFlowModel_5793, true))
					continue;
				currMatch.signalFlowModel_57a0= signalFlowModel_5793;
				if( !isValidBound(boundObjs_579f, class_5798, false))
					continue;
				currMatch.class_57a1= class_5798;
				if( !isValidBound(boundObjs_579f, currSubsystem_5797, false))
					continue;
				currMatch.subsystem_57a2= currSubsystem_5797;
				if( !isValidBound(boundObjs_579f, currStruct_579b, false))
					continue;
				currMatch.struct_57a3= currStruct_579b;
				_matches.push_back( currMatch);
			}
		}
	}
	return !_matches.empty();
}

void CreateParamInitFcn_5783::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Function newFunction_57a4= SFC::Function::Create( currMatch.class_57a1);
		SFC::Arg newContext_57a5= SFC::Arg::Create( newFunction_57a4);
		SFC::Class& Class= currMatch.class_57a1;
		SFC::Arg& Context= newContext_57a5;
		SFC::Function& Function= newFunction_57a4;
		CyberComposition::SimulinkWrapper& SignalFlowModel= currMatch.signalFlowModel_57a0;
		SFC::Struct& Struct= currMatch.struct_57a3;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_57a2;
		{
Context.name() = "context";
Context.argIndex() = 0;
Context.ptr() = true;
};
		{
__int64 statementCount = Class.statementCount();
Function.statementIndex() = statementCount;
Class.statementCount() = ++statementCount;

std::string name = static_cast< std::string >( Subsystem.name() ) + "_" + boost::lexical_cast< std::string >( Subsystem.uniqueId() );
Function.name() = name + "_paramInit";

Function.argCount() = 1;
};
		newContext_57a5.dt()= currMatch.struct_57a3;
		outputAppender( currMatch.signalFlowModel_57a0, newFunction_57a4, newContext_57a5);
	}
}

void CreateParamInitFcn_5783::outputAppender( const CyberComposition::SimulinkWrapper& signalFlowModel_57a6, const SFC::Function& function_57a8, const SFC::Arg& context_57aa)
{
	_signalFlowModel_5789->push_back( signalFlowModel_57a6);
	_function_578a->push_back( function_57a8);
	_context_578b->push_back( context_57aa);
}

void CreateAssignment_57ac::operator()( const Packets_t& parameterRefs_57ad, const Packets_t& functions_57b0, const Packets_t& contexts_57b3, Packets_t& localVars_57af, Packets_t& dotExprss_57b2, Packets_t& structs_57b5)
{
#ifdef PRINT_INFO
	printLog( "CreateAssignment_57ac" );
#endif
	RTTGenerator::Instance()->generateRule(1832, "CreateAssignment");
	_localVar_57b6= &localVars_57af;
	_dotExprs_57b7= &dotExprss_57b2;
	_struct_57b8= &structs_57b5;
	processInputPackets( parameterRefs_57ad, functions_57b0, contexts_57b3);
}

bool CreateAssignment_57ac::isInputUnique( const Udm::Object& parameterRef_57bd, const Udm::Object& function_57c6, const Udm::Object& context_57cf)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itParameterRef_57bf= _parameterRef_57b9.begin(), itFunction_57c8= _function_57c2.begin(), itContext_57d1= _context_57cb.begin(); itParameterRef_57bf!= _parameterRef_57b9.end(), itFunction_57c8!= _function_57c2.end(), itContext_57d1!= _context_57cb.end(); ++itParameterRef_57bf, ++itFunction_57c8, ++itContext_57d1)
	{
		if( ( *itParameterRef_57bf== parameterRef_57bd)&& ( *itFunction_57c8== function_57c6)&& ( *itContext_57d1== context_57cf))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_parameterRef_57b9.push_back( parameterRef_57bd);
		_function_57c2.push_back( function_57c6);
		_context_57cb.push_back( context_57cf);
	}
	return isUnique;
}

bool CreateAssignment_57ac::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateAssignment_57ac::processInputPackets( const Packets_t& parameterRefs_57ad, const Packets_t& functions_57b0, const Packets_t& contexts_57b3)
{
	for( Packets_t::const_iterator itParameterRef_57ba= parameterRefs_57ad.begin(), itFunction_57c3= functions_57b0.begin(), itContext_57cc= contexts_57b3.begin(); itParameterRef_57ba!= parameterRefs_57ad.end(), itFunction_57c3!= functions_57b0.end(), itContext_57cc!= contexts_57b3.end(); ++itParameterRef_57ba, ++itFunction_57c3, ++itContext_57cc)
	{
		bool isUnique= isInputUnique( *itParameterRef_57ba, *itFunction_57c3, *itContext_57cc);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itParameterRef_57ba, *itFunction_57c3, *itContext_57cc);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateAssignment_57ac::patternMatcher( const Udm::Object& parameterRef_57bb, const Udm::Object& function_57c4, const Udm::Object& context_57cd)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( parameterRef_57bb.type(), CyberComposition::ParameterRef::meta))
			continue;
		CyberComposition::ParameterRef parameterRef_57c0= CyberComposition::ParameterRef::Cast( parameterRef_57bb);
		if( false== Uml::IsDerivedFrom( function_57c4.type(), SFC::Function::meta))
			continue;
		SFC::Function function_57c9= SFC::Function::Cast( function_57c4);
		if( false== Uml::IsDerivedFrom( context_57cd.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_57d2= SFC::Arg::Cast( context_57cd);
		CyberComposition::ParameterBase sF_Parameter_57d4= parameterRef_57c0.ref();
		if( false== Uml::IsDerivedFrom( sF_Parameter_57d4.type(), CyberComposition::Simulink::SF_Parameter::meta))
			continue;
		CyberComposition::Simulink::SF_Parameter sF_Parameter_57d5= CyberComposition::Simulink::SF_Parameter::Cast( sF_Parameter_57d4);
		if( !sF_Parameter_57d5)
			continue;
		SFC::LocalVar localVar_57d6= sF_Parameter_57d5.memb();
		if( !localVar_57d6)
			continue;
		SFC::DT dT_57d7= localVar_57d6.dt();
		if( !dT_57d7)
			continue;
		SFC::DT struct_57d8= context_57d2.dt();
		if(!struct_57d8 || false== Uml::IsDerivedFrom( struct_57d8.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_57d9= SFC::Struct::Cast( struct_57d8);
		if( !struct_57d9)
			continue;
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_57dd;
		if( !isValidBound(boundObjs_57dd, parameterRef_57c0, true))
			continue;
		currMatch.parameterRef_57de= parameterRef_57c0;
		if( !isValidBound(boundObjs_57dd, function_57c9, true))
			continue;
		currMatch.function_57df= function_57c9;
		if( !isValidBound(boundObjs_57dd, context_57d2, true))
			continue;
		currMatch.context_57e0= context_57d2;
		if( !isValidBound(boundObjs_57dd, sF_Parameter_57d5, false))
			continue;
		currMatch.sF_Parameter_57e1= sF_Parameter_57d5;
		if( !isValidBound(boundObjs_57dd, localVar_57d6, false))
			continue;
		currMatch.localVar_57e2= localVar_57d6;
		if( !isValidBound(boundObjs_57dd, dT_57d7, false))
			continue;
		currMatch.dT_57e3= dT_57d7;
		if( !isValidBound(boundObjs_57dd, struct_57d9, false))
			continue;
		currMatch.struct_57e4= struct_57d9;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateAssignment_57ac::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::Arg newArg_57e5= SFC::Arg::Create( currMatch.function_57df);
		SFC::UserCode newUserCode_57e6= SFC::UserCode::Create( currMatch.function_57df);
		SFC::BinaryExprs newAssignment_57e7= SFC::BinaryExprs::Create( newUserCode_57e6, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newArgDeclRef2_57e8= SFC::ArgDeclRef::Create( newAssignment_57e7, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newDotExprs_57e9= SFC::BinaryExprs::Create( newAssignment_57e7, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef_57ea= SFC::ArgDeclRef::Create( newDotExprs_57e9, SFC::BinaryExprs::meta_leftexpr);
		SFC::Arg& Arg= newArg_57e5;
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_57ea;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_57e8;
		SFC::BinaryExprs& Assignment= newAssignment_57e7;
		SFC::Arg& Context= currMatch.context_57e0;
		SFC::DT& DT= currMatch.dT_57e3;
		SFC::BinaryExprs& DotExprs= newDotExprs_57e9;
		SFC::Function& Function= currMatch.function_57df;
		SFC::LocalVar& LocalVar= currMatch.localVar_57e2;
		CyberComposition::ParameterRef& ParameterRef= currMatch.parameterRef_57de;
		CyberComposition::Simulink::SF_Parameter& SF_Parameter= currMatch.sF_Parameter_57e1;
		SFC::Struct& Struct= currMatch.struct_57e4;
		SFC::UserCode& UserCode= newUserCode_57e6;
		{
Assignment.op() = "=";
};
		{
__int64 statementCount = Function.statementCount();
UserCode.statementIndex()= statementCount;
Function.statementCount() = ++statementCount;
};
		{
__int64 argCount = Function.argCount();
Arg.argIndex() = argCount;
Function.argCount() = ++argCount;

Arg.name() = ParameterRef.name();
};
		{
DotExprs.op() = ".";
};
		{
std::string tmp = LocalVar.name();
SFUtils::obj2VarNameMap[SF_Parameter.uniqueId()] = tmp;
};
		newArg_57e5.dt()= currMatch.dT_57e3;
		newArgDeclRef2_57e8.argdecl()= newArg_57e5;
		newArgDeclRef_57ea.argdecl()= currMatch.context_57e0;
		outputAppender( currMatch.localVar_57e2, newDotExprs_57e9, currMatch.struct_57e4);
	}
}

void CreateAssignment_57ac::outputAppender( const SFC::LocalVar& localVar_57eb, const SFC::BinaryExprs& dotExprs_57ed, const SFC::Struct& struct_57ef)
{
	_localVar_57b6->push_back( localVar_57eb);
	_dotExprs_57b7->push_back( dotExprs_57ed);
	_struct_57b8->push_back( struct_57ef);
}

void NextLocalVar_57f1::operator()( const Packets_t& localVars_57f2, const Packets_t& structVars_57f5, const Packets_t& dotExprss_57f8, const Packets_t& structs_57fb, Packets_t& localVars_57f4, Packets_t& nextStructVars_57f7, Packets_t& dotExprss_57fa, Packets_t& structs_57fd)
{
#ifdef PRINT_INFO
	printLog( "NextLocalVar_57f1" );
#endif
	RTTGenerator::Instance()->generateRule(1864, "NextLocalVar");
	_localVar_57fe= &localVars_57f4;
	_nextStructVar_57ff= &nextStructVars_57f7;
	_dotExprs_5800= &dotExprss_57fa;
	_struct_5801= &structs_57fd;
	processInputPackets( localVars_57f2, structVars_57f5, dotExprss_57f8, structs_57fb);
}

bool NextLocalVar_57f1::isInputUnique( const Udm::Object& localVar_5806, const Udm::Object& structVar_580f, const Udm::Object& dotExprs_5818, const Udm::Object& struct_5821)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itLocalVar_5808= _localVar_5802.begin(), itStructVar_5811= _structVar_580b.begin(), itDotExprs_581a= _dotExprs_5814.begin(), itStruct_5823= _struct_581d.begin(); itLocalVar_5808!= _localVar_5802.end(), itStructVar_5811!= _structVar_580b.end(), itDotExprs_581a!= _dotExprs_5814.end(), itStruct_5823!= _struct_581d.end(); ++itLocalVar_5808, ++itStructVar_5811, ++itDotExprs_581a, ++itStruct_5823)
	{
		if( ( *itLocalVar_5808== localVar_5806)&& ( *itStructVar_5811== structVar_580f)&& ( *itDotExprs_581a== dotExprs_5818)&& ( *itStruct_5823== struct_5821))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_localVar_5802.push_back( localVar_5806);
		_structVar_580b.push_back( structVar_580f);
		_dotExprs_5814.push_back( dotExprs_5818);
		_struct_581d.push_back( struct_5821);
	}
	return isUnique;
}

void NextLocalVar_57f1::processInputPackets( const Packets_t& localVars_57f2, const Packets_t& structVars_57f5, const Packets_t& dotExprss_57f8, const Packets_t& structs_57fb)
{
	for( Packets_t::const_iterator itLocalVar_5803= localVars_57f2.begin(), itStructVar_580c= structVars_57f5.begin(), itDotExprs_5815= dotExprss_57f8.begin(), itStruct_581e= structs_57fb.begin(); itLocalVar_5803!= localVars_57f2.end(), itStructVar_580c!= structVars_57f5.end(), itDotExprs_5815!= dotExprss_57f8.end(), itStruct_581e!= structs_57fb.end(); ++itLocalVar_5803, ++itStructVar_580c, ++itDotExprs_5815, ++itStruct_581e)
	{
		bool isUnique= isInputUnique( *itLocalVar_5803, *itStructVar_580c, *itDotExprs_5815, *itStruct_581e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itLocalVar_5803, *itStructVar_580c, *itDotExprs_5815, *itStruct_581e);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool NextLocalVar_57f1::patternMatcher( const Udm::Object& localVar_5804, const Udm::Object& structVar_580d, const Udm::Object& dotExprs_5816, const Udm::Object& struct_581f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( localVar_5804.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_5809= SFC::LocalVar::Cast( localVar_5804);
		if( false== Uml::IsDerivedFrom( structVar_580d.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar structVar_5812= SFC::LocalVar::Cast( structVar_580d);
		if( false== Uml::IsDerivedFrom( dotExprs_5816.type(), SFC::BinaryExprs::meta))
			continue;
		SFC::BinaryExprs dotExprs_581b= SFC::BinaryExprs::Cast( dotExprs_5816);
		if( false== Uml::IsDerivedFrom( struct_581f.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_5824= SFC::Struct::Cast( struct_581f);
		Udm::Object structVarParent_5826= structVar_5812.container();
		if( false== Uml::IsDerivedFrom( structVarParent_5826.type(), SFC::Struct::meta))
			continue;
		SFC::Struct nextStructStructVar_5827= SFC::Struct::Cast( structVarParent_5826);
		set< SFC::TypedEntity> nextStructVars_5828= nextStructStructVar_5827.te();
		for( set< SFC::TypedEntity>::const_iterator itNextStructVars_5829= nextStructVars_5828.begin(); itNextStructVars_5829!= nextStructVars_5828.end(); ++itNextStructVars_5829)
		{
			if( false== Uml::IsDerivedFrom( (*itNextStructVars_5829).type(), SFC::LocalVar::meta))
				continue;
			SFC::LocalVar currNextStructVar_582a= SFC::LocalVar::Cast( *itNextStructVars_5829);
			Match currMatch;
			currMatch.localVar_582c= localVar_5809;
			currMatch.structVar_582d= structVar_5812;
			currMatch.dotExprs_582e= dotExprs_581b;
			currMatch.struct_582f= struct_5824;
			currMatch.nextStructVar_5830= currNextStructVar_582a;
			currMatch.nextStruct_5831= nextStructStructVar_5827;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void NextLocalVar_57f1::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.localVar_582c, currMatch.nextStructVar_5830, currMatch.dotExprs_582e, currMatch.struct_582f);
	}
}

void NextLocalVar_57f1::outputAppender( const SFC::LocalVar& localVar_5832, const SFC::LocalVar& nextStructVar_5834, const SFC::BinaryExprs& dotExprs_5836, const SFC::Struct& struct_5838)
{
	_localVar_57fe->push_back( localVar_5832);
	_nextStructVar_57ff->push_back( nextStructVar_5834);
	_dotExprs_5800->push_back( dotExprs_5836);
	_struct_5801->push_back( struct_5838);
}

void TestContext_583a::operator()( const Packets_t& localvars_583b, const Packets_t& structvars_583d, const Packets_t& exprss_583f, const Packets_t& ctxstrcts_5841, Packets_t& localVars_5843, Packets_t& structvars_5844, Packets_t& exprss_5845, Packets_t& ctxstrcts_5846, Packets_t& localVars_5847, Packets_t& structvars_5848, Packets_t& exprss_5849, Packets_t& ctxstrcts_584a, Packets_t& localVars_584b, Packets_t& structvars_584c, Packets_t& exprss_584d, Packets_t& ctxstrcts_584e)
{
#ifdef PRINT_INFO
	printLog( "TestContext_583a" );
#endif
	_localVar_584f= &localVars_5843;
	_structvar_5850= &structvars_5844;
	_exprs_5851= &exprss_5845;
	_ctxstrct_5852= &ctxstrcts_5846;
	_localVar_5853= &localVars_5847;
	_structvar_5854= &structvars_5848;
	_exprs_5855= &exprss_5849;
	_ctxstrct_5856= &ctxstrcts_584a;
	_localVar_5857= &localVars_584b;
	_structvar_5858= &structvars_584c;
	_exprs_5859= &exprss_584d;
	_ctxstrct_585a= &ctxstrcts_584e;
	for( Packets_t::const_iterator itlocalvar_585c= localvars_583b.begin(), itstructvar_5863= structvars_583d.begin(), itexprs_586a= exprss_583f.begin(), itctxstrct_5871= ctxstrcts_5841.begin(); itlocalvar_585c!= localvars_583b.end(), itstructvar_5863!= structvars_583d.end(), itexprs_586a!= exprss_583f.end(), itctxstrct_5871!= ctxstrcts_5841.end(); ++itlocalvar_585c, ++itstructvar_5863, ++itexprs_586a, ++itctxstrct_5871)
	{
		bool isUnique= isInputUnique( *itlocalvar_585c, *itstructvar_5863, *itexprs_586a, *itctxstrct_5871);
		if( !isUnique)
			continue;
		Packets_t onelocalvar_5860( 1, *itlocalvar_585c);
		Packets_t onestructvar_5867( 1, *itstructvar_5863);
		Packets_t oneexprs_586e( 1, *itexprs_586a);
		Packets_t onectxstrct_5875( 1, *itctxstrct_5871);
		executeOne( onelocalvar_5860, onestructvar_5867, oneexprs_586e, onectxstrct_5875);
	}
}

void TestContext_583a::executeOne( const Packets_t& localvars_583b, const Packets_t& structvars_583d, const Packets_t& exprss_583f, const Packets_t& ctxstrcts_5841)
{
	Packets_t localVars_587a;
	Packets_t structVars_587d;
	Packets_t binaryExprss_5880;
	Packets_t structs_5883;
	LVinContext_5877 lVinContext_5877;
	bool isMatchLVinContext_5877= lVinContext_5877( localvars_583b, structvars_583d, exprss_583f, ctxstrcts_5841, localVars_587a, structVars_587d, binaryExprss_5880, structs_5883);
	_localVar_584f->insert( _localVar_584f->end(), localVars_587a.begin(), localVars_587a.end());
	_structvar_5850->insert( _structvar_5850->end(), structVars_587d.begin(), structVars_587d.end());
	_exprs_5851->insert( _exprs_5851->end(), binaryExprss_5880.begin(), binaryExprss_5880.end());
	_ctxstrct_5852->insert( _ctxstrct_5852->end(), structs_5883.begin(), structs_5883.end());
	if( isMatchLVinContext_5877)
		return;
	Packets_t localVars_58bf;
	Packets_t structVars_58c2;
	Packets_t binaryExprss_58c5;
	Packets_t structs_58c8;
	SVinContext_58bc sVinContext_58bc;
	bool isMatchSVinContext_58bc= sVinContext_58bc( localvars_583b, structvars_583d, exprss_583f, ctxstrcts_5841, localVars_58bf, structVars_58c2, binaryExprss_58c5, structs_58c8);
	_localVar_5853->insert( _localVar_5853->end(), localVars_58bf.begin(), localVars_58bf.end());
	_structvar_5854->insert( _structvar_5854->end(), structVars_58c2.begin(), structVars_58c2.end());
	_exprs_5855->insert( _exprs_5855->end(), binaryExprss_58c5.begin(), binaryExprss_58c5.end());
	_ctxstrct_5856->insert( _ctxstrct_5856->end(), structs_58c8.begin(), structs_58c8.end());
	if( isMatchSVinContext_58bc)
		return;
	Packets_t localVars_5904;
	Packets_t structVars_5907;
	Packets_t binaryExprss_590a;
	Packets_t structs_590d;
	Otherwise_5901 otherwise_5901;
	bool isMatchOtherwise_5901= otherwise_5901( localvars_583b, structvars_583d, exprss_583f, ctxstrcts_5841, localVars_5904, structVars_5907, binaryExprss_590a, structs_590d);
	_localVar_5857->insert( _localVar_5857->end(), localVars_5904.begin(), localVars_5904.end());
	_structvar_5858->insert( _structvar_5858->end(), structVars_5907.begin(), structVars_5907.end());
	_exprs_5859->insert( _exprs_5859->end(), binaryExprss_590a.begin(), binaryExprss_590a.end());
	_ctxstrct_585a->insert( _ctxstrct_585a->end(), structs_590d.begin(), structs_590d.end());
	if( isMatchOtherwise_5901)
		return;
}

bool TestContext_583a::isInputUnique( const Udm::Object& localvar_585d, const Udm::Object& structvar_5864, const Udm::Object& exprs_586b, const Udm::Object& ctxstrct_5872)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itlocalvar_585f= _localvar_585b.begin(), itstructvar_5866= _structvar_5862.begin(), itexprs_586d= _exprs_5869.begin(), itctxstrct_5874= _ctxstrct_5870.begin(); itlocalvar_585f!= _localvar_585b.end(), itstructvar_5866!= _structvar_5862.end(), itexprs_586d!= _exprs_5869.end(), itctxstrct_5874!= _ctxstrct_5870.end(); ++itlocalvar_585f, ++itstructvar_5866, ++itexprs_586d, ++itctxstrct_5874)
	{
		if( ( *itlocalvar_585f== localvar_585d)&& ( *itstructvar_5866== structvar_5864)&& ( *itexprs_586d== exprs_586b)&& ( *itctxstrct_5874== ctxstrct_5872))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_localvar_585b.push_back( localvar_585d);
		_structvar_5862.push_back( structvar_5864);
		_exprs_5869.push_back( exprs_586b);
		_ctxstrct_5870.push_back( ctxstrct_5872);
	}
	return isUnique;
}

bool LVinContext_5877::operator()( const Packets_t& localVars_5878, const Packets_t& structVars_587b, const Packets_t& binaryExprss_587e, const Packets_t& structs_5881, Packets_t& localVars_587a, Packets_t& structVars_587d, Packets_t& binaryExprss_5880, Packets_t& structs_5883)
{
#ifdef PRINT_INFO
	printLog( "LVinContext_5877" );
#endif
	_localVar_5884= &localVars_587a;
	_structVar_5885= &structVars_587d;
	_binaryExprs_5886= &binaryExprss_5880;
	_struct_5887= &structs_5883;
	processInputPackets( localVars_5878, structVars_587b, binaryExprss_587e, structs_5881);
	if( false== _matches.empty())
		return true;
	return false;
}

bool LVinContext_5877::isInputUnique( const Udm::Object& localVar_588c, const Udm::Object& structVar_5895, const Udm::Object& binaryExprs_589e, const Udm::Object& struct_58a7)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itLocalVar_588e= _localVar_5888.begin(), itStructVar_5897= _structVar_5891.begin(), itBinaryExprs_58a0= _binaryExprs_589a.begin(), itStruct_58a9= _struct_58a3.begin(); itLocalVar_588e!= _localVar_5888.end(), itStructVar_5897!= _structVar_5891.end(), itBinaryExprs_58a0!= _binaryExprs_589a.end(), itStruct_58a9!= _struct_58a3.end(); ++itLocalVar_588e, ++itStructVar_5897, ++itBinaryExprs_58a0, ++itStruct_58a9)
	{
		if( ( *itLocalVar_588e== localVar_588c)&& ( *itStructVar_5897== structVar_5895)&& ( *itBinaryExprs_58a0== binaryExprs_589e)&& ( *itStruct_58a9== struct_58a7))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_localVar_5888.push_back( localVar_588c);
		_structVar_5891.push_back( structVar_5895);
		_binaryExprs_589a.push_back( binaryExprs_589e);
		_struct_58a3.push_back( struct_58a7);
	}
	return isUnique;
}

void LVinContext_5877::processInputPackets( const Packets_t& localVars_5878, const Packets_t& structVars_587b, const Packets_t& binaryExprss_587e, const Packets_t& structs_5881)
{
	for( Packets_t::const_iterator itLocalVar_5889= localVars_5878.begin(), itStructVar_5892= structVars_587b.begin(), itBinaryExprs_589b= binaryExprss_587e.begin(), itStruct_58a4= structs_5881.begin(); itLocalVar_5889!= localVars_5878.end(), itStructVar_5892!= structVars_587b.end(), itBinaryExprs_589b!= binaryExprss_587e.end(), itStruct_58a4!= structs_5881.end(); ++itLocalVar_5889, ++itStructVar_5892, ++itBinaryExprs_589b, ++itStruct_58a4)
	{
		bool isUnique= isInputUnique( *itLocalVar_5889, *itStructVar_5892, *itBinaryExprs_589b, *itStruct_58a4);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itLocalVar_5889, *itStructVar_5892, *itBinaryExprs_589b, *itStruct_58a4);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.localVar_58b0, currMatch.structVar_58b1, currMatch.binaryExprs_58b2, currMatch.struct_58b3);
	}
}

bool LVinContext_5877::patternMatcher( const Udm::Object& localVar_588a, const Udm::Object& structVar_5893, const Udm::Object& binaryExprs_589c, const Udm::Object& struct_58a5)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( localVar_588a.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_588f= SFC::LocalVar::Cast( localVar_588a);
		if( false== Uml::IsDerivedFrom( structVar_5893.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar structVar_5898= SFC::LocalVar::Cast( structVar_5893);
		if( false== Uml::IsDerivedFrom( binaryExprs_589c.type(), SFC::BinaryExprs::meta))
			continue;
		SFC::BinaryExprs binaryExprs_58a1= SFC::BinaryExprs::Cast( binaryExprs_589c);
		if( false== Uml::IsDerivedFrom( struct_58a5.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_58aa= SFC::Struct::Cast( struct_58a5);
		set< SFC::LocalVar> localVars_58ac= struct_58aa.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itLocalVar_58ad= localVars_58ac.begin(); itLocalVar_58ad!= localVars_58ac.end(); ++itLocalVar_58ad)
		{
			SFC::LocalVar currLocalVar_58ae= *itLocalVar_58ad;
			if( localVar_588f!= currLocalVar_58ae)
				continue;
			Match currMatch;
			currMatch.localVar_58b0= localVar_588f;
			currMatch.structVar_58b1= structVar_5898;
			currMatch.binaryExprs_58b2= binaryExprs_58a1;
			currMatch.struct_58b3= struct_58aa;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void LVinContext_5877::outputAppender( const SFC::LocalVar& localVar_58b4, const SFC::LocalVar& structVar_58b6, const SFC::BinaryExprs& binaryExprs_58b8, const SFC::Struct& struct_58ba)
{
	_localVar_5884->push_back( localVar_58b4);
	_structVar_5885->push_back( structVar_58b6);
	_binaryExprs_5886->push_back( binaryExprs_58b8);
	_struct_5887->push_back( struct_58ba);
}

bool SVinContext_58bc::operator()( const Packets_t& localVars_58bd, const Packets_t& structVars_58c0, const Packets_t& binaryExprss_58c3, const Packets_t& structs_58c6, Packets_t& localVars_58bf, Packets_t& structVars_58c2, Packets_t& binaryExprss_58c5, Packets_t& structs_58c8)
{
#ifdef PRINT_INFO
	printLog( "SVinContext_58bc" );
#endif
	_localVar_58c9= &localVars_58bf;
	_structVar_58ca= &structVars_58c2;
	_binaryExprs_58cb= &binaryExprss_58c5;
	_struct_58cc= &structs_58c8;
	processInputPackets( localVars_58bd, structVars_58c0, binaryExprss_58c3, structs_58c6);
	if( false== _matches.empty())
		return true;
	return false;
}

bool SVinContext_58bc::isInputUnique( const Udm::Object& localVar_58d1, const Udm::Object& structVar_58da, const Udm::Object& binaryExprs_58e3, const Udm::Object& struct_58ec)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itLocalVar_58d3= _localVar_58cd.begin(), itStructVar_58dc= _structVar_58d6.begin(), itBinaryExprs_58e5= _binaryExprs_58df.begin(), itStruct_58ee= _struct_58e8.begin(); itLocalVar_58d3!= _localVar_58cd.end(), itStructVar_58dc!= _structVar_58d6.end(), itBinaryExprs_58e5!= _binaryExprs_58df.end(), itStruct_58ee!= _struct_58e8.end(); ++itLocalVar_58d3, ++itStructVar_58dc, ++itBinaryExprs_58e5, ++itStruct_58ee)
	{
		if( ( *itLocalVar_58d3== localVar_58d1)&& ( *itStructVar_58dc== structVar_58da)&& ( *itBinaryExprs_58e5== binaryExprs_58e3)&& ( *itStruct_58ee== struct_58ec))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_localVar_58cd.push_back( localVar_58d1);
		_structVar_58d6.push_back( structVar_58da);
		_binaryExprs_58df.push_back( binaryExprs_58e3);
		_struct_58e8.push_back( struct_58ec);
	}
	return isUnique;
}

void SVinContext_58bc::processInputPackets( const Packets_t& localVars_58bd, const Packets_t& structVars_58c0, const Packets_t& binaryExprss_58c3, const Packets_t& structs_58c6)
{
	for( Packets_t::const_iterator itLocalVar_58ce= localVars_58bd.begin(), itStructVar_58d7= structVars_58c0.begin(), itBinaryExprs_58e0= binaryExprss_58c3.begin(), itStruct_58e9= structs_58c6.begin(); itLocalVar_58ce!= localVars_58bd.end(), itStructVar_58d7!= structVars_58c0.end(), itBinaryExprs_58e0!= binaryExprss_58c3.end(), itStruct_58e9!= structs_58c6.end(); ++itLocalVar_58ce, ++itStructVar_58d7, ++itBinaryExprs_58e0, ++itStruct_58e9)
	{
		bool isUnique= isInputUnique( *itLocalVar_58ce, *itStructVar_58d7, *itBinaryExprs_58e0, *itStruct_58e9);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itLocalVar_58ce, *itStructVar_58d7, *itBinaryExprs_58e0, *itStruct_58e9);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.localVar_58f5, currMatch.structVar_58f6, currMatch.binaryExprs_58f7, currMatch.struct_58f8);
	}
}

bool SVinContext_58bc::patternMatcher( const Udm::Object& localVar_58cf, const Udm::Object& structVar_58d8, const Udm::Object& binaryExprs_58e1, const Udm::Object& struct_58ea)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( localVar_58cf.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_58d4= SFC::LocalVar::Cast( localVar_58cf);
		if( false== Uml::IsDerivedFrom( structVar_58d8.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar structVar_58dd= SFC::LocalVar::Cast( structVar_58d8);
		if( false== Uml::IsDerivedFrom( binaryExprs_58e1.type(), SFC::BinaryExprs::meta))
			continue;
		SFC::BinaryExprs binaryExprs_58e6= SFC::BinaryExprs::Cast( binaryExprs_58e1);
		if( false== Uml::IsDerivedFrom( struct_58ea.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_58ef= SFC::Struct::Cast( struct_58ea);
		set< SFC::LocalVar> structVars_58f1= struct_58ef.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itStructVar_58f2= structVars_58f1.begin(); itStructVar_58f2!= structVars_58f1.end(); ++itStructVar_58f2)
		{
			SFC::LocalVar currStructVar_58f3= *itStructVar_58f2;
			if( structVar_58dd!= currStructVar_58f3)
				continue;
			Match currMatch;
			currMatch.localVar_58f5= localVar_58d4;
			currMatch.structVar_58f6= structVar_58dd;
			currMatch.binaryExprs_58f7= binaryExprs_58e6;
			currMatch.struct_58f8= struct_58ef;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void SVinContext_58bc::outputAppender( const SFC::LocalVar& localVar_58f9, const SFC::LocalVar& structVar_58fb, const SFC::BinaryExprs& binaryExprs_58fd, const SFC::Struct& struct_58ff)
{
	_localVar_58c9->push_back( localVar_58f9);
	_structVar_58ca->push_back( structVar_58fb);
	_binaryExprs_58cb->push_back( binaryExprs_58fd);
	_struct_58cc->push_back( struct_58ff);
}

bool Otherwise_5901::operator()( const Packets_t& localVars_5902, const Packets_t& structVars_5905, const Packets_t& binaryExprss_5908, const Packets_t& structs_590b, Packets_t& localVars_5904, Packets_t& structVars_5907, Packets_t& binaryExprss_590a, Packets_t& structs_590d)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_5901" );
#endif
	_localVar_590e= &localVars_5904;
	_structVar_590f= &structVars_5907;
	_binaryExprs_5910= &binaryExprss_590a;
	_struct_5911= &structs_590d;
	processInputPackets( localVars_5902, structVars_5905, binaryExprss_5908, structs_590b);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_5901::isInputUnique( const Udm::Object& localVar_5916, const Udm::Object& structVar_591f, const Udm::Object& binaryExprs_5928, const Udm::Object& struct_5931)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itLocalVar_5918= _localVar_5912.begin(), itStructVar_5921= _structVar_591b.begin(), itBinaryExprs_592a= _binaryExprs_5924.begin(), itStruct_5933= _struct_592d.begin(); itLocalVar_5918!= _localVar_5912.end(), itStructVar_5921!= _structVar_591b.end(), itBinaryExprs_592a!= _binaryExprs_5924.end(), itStruct_5933!= _struct_592d.end(); ++itLocalVar_5918, ++itStructVar_5921, ++itBinaryExprs_592a, ++itStruct_5933)
	{
		if( ( *itLocalVar_5918== localVar_5916)&& ( *itStructVar_5921== structVar_591f)&& ( *itBinaryExprs_592a== binaryExprs_5928)&& ( *itStruct_5933== struct_5931))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_localVar_5912.push_back( localVar_5916);
		_structVar_591b.push_back( structVar_591f);
		_binaryExprs_5924.push_back( binaryExprs_5928);
		_struct_592d.push_back( struct_5931);
	}
	return isUnique;
}

void Otherwise_5901::processInputPackets( const Packets_t& localVars_5902, const Packets_t& structVars_5905, const Packets_t& binaryExprss_5908, const Packets_t& structs_590b)
{
	for( Packets_t::const_iterator itLocalVar_5913= localVars_5902.begin(), itStructVar_591c= structVars_5905.begin(), itBinaryExprs_5925= binaryExprss_5908.begin(), itStruct_592e= structs_590b.begin(); itLocalVar_5913!= localVars_5902.end(), itStructVar_591c!= structVars_5905.end(), itBinaryExprs_5925!= binaryExprss_5908.end(), itStruct_592e!= structs_590b.end(); ++itLocalVar_5913, ++itStructVar_591c, ++itBinaryExprs_5925, ++itStruct_592e)
	{
		bool isUnique= isInputUnique( *itLocalVar_5913, *itStructVar_591c, *itBinaryExprs_5925, *itStruct_592e);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itLocalVar_5913, *itStructVar_591c, *itBinaryExprs_5925, *itStruct_592e);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.localVar_5937, currMatch.structVar_5938, currMatch.binaryExprs_5939, currMatch.struct_593a);
	}
}

bool Otherwise_5901::patternMatcher( const Udm::Object& localVar_5914, const Udm::Object& structVar_591d, const Udm::Object& binaryExprs_5926, const Udm::Object& struct_592f)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( localVar_5914.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_5919= SFC::LocalVar::Cast( localVar_5914);
		if( false== Uml::IsDerivedFrom( structVar_591d.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar structVar_5922= SFC::LocalVar::Cast( structVar_591d);
		if( false== Uml::IsDerivedFrom( binaryExprs_5926.type(), SFC::BinaryExprs::meta))
			continue;
		SFC::BinaryExprs binaryExprs_592b= SFC::BinaryExprs::Cast( binaryExprs_5926);
		if( false== Uml::IsDerivedFrom( struct_592f.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_5934= SFC::Struct::Cast( struct_592f);
		Match currMatch;
		currMatch.localVar_5937= localVar_5919;
		currMatch.structVar_5938= structVar_5922;
		currMatch.binaryExprs_5939= binaryExprs_592b;
		currMatch.struct_593a= struct_5934;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_5901::outputAppender( const SFC::LocalVar& localVar_593b, const SFC::LocalVar& structVar_593d, const SFC::BinaryExprs& binaryExprs_593f, const SFC::Struct& struct_5941)
{
	_localVar_590e->push_back( localVar_593b);
	_structVar_590f->push_back( structVar_593d);
	_binaryExprs_5910->push_back( binaryExprs_593f);
	_struct_5911->push_back( struct_5941);
}

void LastDot_5943::operator()( const Packets_t& localVars_5944, const Packets_t& structVars_5946, const Packets_t& dotExprss_5948, const Packets_t& structs_594a)
{
#ifdef PRINT_INFO
	printLog( "LastDot_5943" );
#endif
	RTTGenerator::Instance()->generateRule(1907, "LastDot");
	processInputPackets( localVars_5944, structVars_5946, dotExprss_5948, structs_594a);
}

bool LastDot_5943::isInputUnique( const Udm::Object& localVar_5950, const Udm::Object& structVar_5959, const Udm::Object& dotExprs_5962, const Udm::Object& struct_596b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itLocalVar_5952= _localVar_594c.begin(), itStructVar_595b= _structVar_5955.begin(), itDotExprs_5964= _dotExprs_595e.begin(), itStruct_596d= _struct_5967.begin(); itLocalVar_5952!= _localVar_594c.end(), itStructVar_595b!= _structVar_5955.end(), itDotExprs_5964!= _dotExprs_595e.end(), itStruct_596d!= _struct_5967.end(); ++itLocalVar_5952, ++itStructVar_595b, ++itDotExprs_5964, ++itStruct_596d)
	{
		if( ( *itLocalVar_5952== localVar_5950)&& ( *itStructVar_595b== structVar_5959)&& ( *itDotExprs_5964== dotExprs_5962)&& ( *itStruct_596d== struct_596b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_localVar_594c.push_back( localVar_5950);
		_structVar_5955.push_back( structVar_5959);
		_dotExprs_595e.push_back( dotExprs_5962);
		_struct_5967.push_back( struct_596b);
	}
	return isUnique;
}

void LastDot_5943::processInputPackets( const Packets_t& localVars_5944, const Packets_t& structVars_5946, const Packets_t& dotExprss_5948, const Packets_t& structs_594a)
{
	for( Packets_t::const_iterator itLocalVar_594d= localVars_5944.begin(), itStructVar_5956= structVars_5946.begin(), itDotExprs_595f= dotExprss_5948.begin(), itStruct_5968= structs_594a.begin(); itLocalVar_594d!= localVars_5944.end(), itStructVar_5956!= structVars_5946.end(), itDotExprs_595f!= dotExprss_5948.end(), itStruct_5968!= structs_594a.end(); ++itLocalVar_594d, ++itStructVar_5956, ++itDotExprs_595f, ++itStruct_5968)
	{
		bool isUnique= isInputUnique( *itLocalVar_594d, *itStructVar_5956, *itDotExprs_595f, *itStruct_5968);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itLocalVar_594d, *itStructVar_5956, *itDotExprs_595f, *itStruct_5968);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool LastDot_5943::patternMatcher( const Udm::Object& localVar_594e, const Udm::Object& structVar_5957, const Udm::Object& dotExprs_5960, const Udm::Object& struct_5969)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( localVar_594e.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_5953= SFC::LocalVar::Cast( localVar_594e);
		if( false== Uml::IsDerivedFrom( structVar_5957.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar structVar_595c= SFC::LocalVar::Cast( structVar_5957);
		if( false== Uml::IsDerivedFrom( dotExprs_5960.type(), SFC::BinaryExprs::meta))
			continue;
		SFC::BinaryExprs dotExprs_5965= SFC::BinaryExprs::Cast( dotExprs_5960);
		if( false== Uml::IsDerivedFrom( struct_5969.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_596e= SFC::Struct::Cast( struct_5969);
		Match currMatch;
		currMatch.localVar_5971= localVar_5953;
		currMatch.structVar_5972= structVar_595c;
		currMatch.dotExprs_5973= dotExprs_5965;
		currMatch.struct_5974= struct_596e;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void LastDot_5943::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ArgDeclRef newArgDeclRef_5975= SFC::ArgDeclRef::Create( currMatch.dotExprs_5973, SFC::BinaryExprs::meta_rightexpr);
		newArgDeclRef_5975.argdecl()= currMatch.localVar_5971;
	}
}

void NextDot_5976::operator()( const Packets_t& localVars_5977, const Packets_t& structVars_597a, const Packets_t& dotExprss_597c, const Packets_t& structs_597f, Packets_t& localVars_5979, Packets_t& nextDotExprss_597e, Packets_t& nextStructs_5981)
{
#ifdef PRINT_INFO
	printLog( "NextDot_5976" );
#endif
	RTTGenerator::Instance()->generateRule(1915, "NextDot");
	_localVar_5982= &localVars_5979;
	_nextDotExprs_5983= &nextDotExprss_597e;
	_nextStruct_5984= &nextStructs_5981;
	processInputPackets( localVars_5977, structVars_597a, dotExprss_597c, structs_597f);
}

bool NextDot_5976::isInputUnique( const Udm::Object& localVar_5989, const Udm::Object& structVar_5992, const Udm::Object& dotExprs_599b, const Udm::Object& struct_59a4)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itLocalVar_598b= _localVar_5985.begin(), itStructVar_5994= _structVar_598e.begin(), itDotExprs_599d= _dotExprs_5997.begin(), itStruct_59a6= _struct_59a0.begin(); itLocalVar_598b!= _localVar_5985.end(), itStructVar_5994!= _structVar_598e.end(), itDotExprs_599d!= _dotExprs_5997.end(), itStruct_59a6!= _struct_59a0.end(); ++itLocalVar_598b, ++itStructVar_5994, ++itDotExprs_599d, ++itStruct_59a6)
	{
		if( ( *itLocalVar_598b== localVar_5989)&& ( *itStructVar_5994== structVar_5992)&& ( *itDotExprs_599d== dotExprs_599b)&& ( *itStruct_59a6== struct_59a4))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_localVar_5985.push_back( localVar_5989);
		_structVar_598e.push_back( structVar_5992);
		_dotExprs_5997.push_back( dotExprs_599b);
		_struct_59a0.push_back( struct_59a4);
	}
	return isUnique;
}

void NextDot_5976::processInputPackets( const Packets_t& localVars_5977, const Packets_t& structVars_597a, const Packets_t& dotExprss_597c, const Packets_t& structs_597f)
{
	for( Packets_t::const_iterator itLocalVar_5986= localVars_5977.begin(), itStructVar_598f= structVars_597a.begin(), itDotExprs_5998= dotExprss_597c.begin(), itStruct_59a1= structs_597f.begin(); itLocalVar_5986!= localVars_5977.end(), itStructVar_598f!= structVars_597a.end(), itDotExprs_5998!= dotExprss_597c.end(), itStruct_59a1!= structs_597f.end(); ++itLocalVar_5986, ++itStructVar_598f, ++itDotExprs_5998, ++itStruct_59a1)
	{
		bool isUnique= isInputUnique( *itLocalVar_5986, *itStructVar_598f, *itDotExprs_5998, *itStruct_59a1);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itLocalVar_5986, *itStructVar_598f, *itDotExprs_5998, *itStruct_59a1);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool NextDot_5976::patternMatcher( const Udm::Object& localVar_5987, const Udm::Object& structVar_5990, const Udm::Object& dotExprs_5999, const Udm::Object& struct_59a2)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( localVar_5987.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_598c= SFC::LocalVar::Cast( localVar_5987);
		if( false== Uml::IsDerivedFrom( structVar_5990.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar structVar_5995= SFC::LocalVar::Cast( structVar_5990);
		if( false== Uml::IsDerivedFrom( dotExprs_5999.type(), SFC::BinaryExprs::meta))
			continue;
		SFC::BinaryExprs dotExprs_599e= SFC::BinaryExprs::Cast( dotExprs_5999);
		if( false== Uml::IsDerivedFrom( struct_59a2.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_59a7= SFC::Struct::Cast( struct_59a2);
		SFC::DT nextStruct_59a9= structVar_5995.dt();
		if(!nextStruct_59a9 || false== Uml::IsDerivedFrom( nextStruct_59a9.type(), SFC::Struct::meta))
			continue;
		SFC::Struct nextStruct_59aa= SFC::Struct::Cast( nextStruct_59a9);
		if( !nextStruct_59aa)
			continue;
		Match currMatch;
		currMatch.localVar_59ac= localVar_598c;
		currMatch.structVar_59ad= structVar_5995;
		currMatch.dotExprs_59ae= dotExprs_599e;
		currMatch.struct_59af= struct_59a7;
		currMatch.nextStruct_59b0= nextStruct_59aa;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void NextDot_5976::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newNextDotExprs_59b1= SFC::BinaryExprs::Create( currMatch.dotExprs_59ae, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef_59b2= SFC::ArgDeclRef::Create( newNextDotExprs_59b1, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef& ArgDeclRef= newArgDeclRef_59b2;
		SFC::BinaryExprs& DotExprs= currMatch.dotExprs_59ae;
		SFC::LocalVar& LocalVar= currMatch.localVar_59ac;
		SFC::BinaryExprs& NextDotExprs= newNextDotExprs_59b1;
		SFC::Struct& NextStruct= currMatch.nextStruct_59b0;
		SFC::Struct& Struct= currMatch.struct_59af;
		SFC::LocalVar& StructVar= currMatch.structVar_59ad;
		{
NextDotExprs.op() = ".";
};
		newArgDeclRef_59b2.argdecl()= currMatch.structVar_59ad;
		outputAppender( currMatch.localVar_59ac, newNextDotExprs_59b1, currMatch.nextStruct_59b0);
	}
}

void NextDot_5976::outputAppender( const SFC::LocalVar& localVar_59b3, const SFC::BinaryExprs& nextDotExprs_59b5, const SFC::Struct& nextStruct_59b7)
{
	_localVar_5982->push_back( localVar_59b3);
	_nextDotExprs_5983->push_back( nextDotExprs_59b5);
	_nextStruct_5984->push_back( nextStruct_59b7);
}

void SortParamRefs_59b9::operator()( const Packets_t& signalFlowModels_59ba, const Packets_t& functions_59bd, const Packets_t& contexts_59c0, Packets_t& parameterRefs_59bc, Packets_t& functions_59bf, Packets_t& contexts_59c2)
{
#ifdef PRINT_INFO
	printLog( "SortParamRefs_59b9" );
#endif
	RTTGenerator::Instance()->generateRule(1928, "SortParamRefs");
	_parameterRef_59c3= &parameterRefs_59bc;
	_function_59c4= &functions_59bf;
	_context_59c5= &contexts_59c2;
	processInputPackets( signalFlowModels_59ba, functions_59bd, contexts_59c0);
	sortOutputs( );
}

bool SortParamRefs_59b9::isInputUnique( const Udm::Object& signalFlowModel_59ca, const Udm::Object& function_59d3, const Udm::Object& context_59dc)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSignalFlowModel_59cc= _signalFlowModel_59c6.begin(), itFunction_59d5= _function_59cf.begin(), itContext_59de= _context_59d8.begin(); itSignalFlowModel_59cc!= _signalFlowModel_59c6.end(), itFunction_59d5!= _function_59cf.end(), itContext_59de!= _context_59d8.end(); ++itSignalFlowModel_59cc, ++itFunction_59d5, ++itContext_59de)
	{
		if( ( *itSignalFlowModel_59cc== signalFlowModel_59ca)&& ( *itFunction_59d5== function_59d3)&& ( *itContext_59de== context_59dc))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_signalFlowModel_59c6.push_back( signalFlowModel_59ca);
		_function_59cf.push_back( function_59d3);
		_context_59d8.push_back( context_59dc);
	}
	return isUnique;
}

bool SortParamRefs_59b9::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void SortParamRefs_59b9::processInputPackets( const Packets_t& signalFlowModels_59ba, const Packets_t& functions_59bd, const Packets_t& contexts_59c0)
{
	for( Packets_t::const_iterator itSignalFlowModel_59c7= signalFlowModels_59ba.begin(), itFunction_59d0= functions_59bd.begin(), itContext_59d9= contexts_59c0.begin(); itSignalFlowModel_59c7!= signalFlowModels_59ba.end(), itFunction_59d0!= functions_59bd.end(), itContext_59d9!= contexts_59c0.end(); ++itSignalFlowModel_59c7, ++itFunction_59d0, ++itContext_59d9)
	{
		bool isUnique= isInputUnique( *itSignalFlowModel_59c7, *itFunction_59d0, *itContext_59d9);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSignalFlowModel_59c7, *itFunction_59d0, *itContext_59d9);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool SortParamRefs_59b9::patternMatcher( const Udm::Object& signalFlowModel_59c8, const Udm::Object& function_59d1, const Udm::Object& context_59da)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( signalFlowModel_59c8.type(), CyberComposition::SimulinkWrapper::meta))
			continue;
		CyberComposition::SimulinkWrapper signalFlowModel_59cd= CyberComposition::SimulinkWrapper::Cast( signalFlowModel_59c8);
		if( false== Uml::IsDerivedFrom( function_59d1.type(), SFC::Function::meta))
			continue;
		SFC::Function function_59d6= SFC::Function::Cast( function_59d1);
		if( false== Uml::IsDerivedFrom( context_59da.type(), SFC::Arg::meta))
			continue;
		SFC::Arg context_59df= SFC::Arg::Cast( context_59da);
		set< CyberComposition::ParameterRef> parameterRefs_59e1= signalFlowModel_59cd.ParameterRef_kind_children();
		for( set< CyberComposition::ParameterRef>::const_iterator itParameterRef_59e2= parameterRefs_59e1.begin(); itParameterRef_59e2!= parameterRefs_59e1.end(); ++itParameterRef_59e2)
		{
			CyberComposition::ParameterRef currParameterRef_59e3= *itParameterRef_59e2;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_59e7;
			if( !isValidBound(boundObjs_59e7, signalFlowModel_59cd, true))
				continue;
			currMatch.signalFlowModel_59e8= signalFlowModel_59cd;
			if( !isValidBound(boundObjs_59e7, function_59d6, true))
				continue;
			currMatch.function_59e9= function_59d6;
			if( !isValidBound(boundObjs_59e7, context_59df, true))
				continue;
			currMatch.context_59ea= context_59df;
			if( !isValidBound(boundObjs_59e7, currParameterRef_59e3, false))
				continue;
			currMatch.parameterRef_59eb= currParameterRef_59e3;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void SortParamRefs_59b9::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.parameterRef_59eb, currMatch.function_59e9, currMatch.context_59ea);
	}
}

void SortParamRefs_59b9::outputAppender( const CyberComposition::ParameterRef& parameterRef_59ec, const SFC::Function& function_59ee, const SFC::Arg& context_59f0)
{
	_parameterRef_59c3->push_back( parameterRef_59ec);
	_function_59c4->push_back( function_59ee);
	_context_59c5->push_back( context_59f0);
}

void SortParamRefs_59b9::sortOutputs()
{
	typedef std::multiset< CyberComposition::ParameterRef, std::pointer_to_binary_function< const CyberComposition::ParameterRef&, const CyberComposition::ParameterRef&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const CyberComposition::ParameterRef&, const CyberComposition::ParameterRef&, bool> ptr_PRCompare( PRCompare< CyberComposition::ParameterRef>);
	SortedSet_t sortedSet( ptr_PRCompare);
	std::vector< int> permutationVector( _parameterRef_59c3->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _parameterRef_59c3->begin(); it!= _parameterRef_59c3->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( CyberComposition::ParameterRef::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _parameterRef_59c3->begin());
	// order rest of the containers
	permutate( permutationVector, *_function_59c4);
	permutate( permutationVector, *_context_59c5);
}

void MakeTrigger_5a27::operator()( const Packets_t& systems_5a28, const Packets_t& childSubsystems_5a2a, const Packets_t& systemFunctions_5a2c, Packets_t& systems_5a2e, Packets_t& childSubsystems_5a2f, Packets_t& compoundStatements_5a30)
{
#ifdef PRINT_INFO
	printLog( "MakeTrigger_5a27" );
#endif
	_system_5a31= &systems_5a2e;
	_childSubsystem_5a32= &childSubsystems_5a2f;
	_compoundStatement_5a33= &compoundStatements_5a30;
	if( ( !systems_5a28.empty())&& ( !childSubsystems_5a2a.empty())&& ( !systemFunctions_5a2c.empty()))
		callIsTriggered_5fa6( systems_5a28, childSubsystems_5a2a, systemFunctions_5a2c);
}

void MakeTrigger_5a27::callIsTriggered_5fa6( const Packets_t& systems_5a35, const Packets_t& childSubsystems_5a37, const Packets_t& systemFunctions_5a39)
{
	Packets_t systems_5a3b;
	Packets_t childSubsystems_5a3c;
	Packets_t systemFunctions_5a3d;
	Packets_t systems_5a3e;
	Packets_t childSubsystems_5a3f;
	Packets_t systemFunctions_5a40;
	IsTriggered_5a34 isTriggered_5a34;
	isTriggered_5a34( systems_5a35, childSubsystems_5a37, systemFunctions_5a39, systems_5a3b, childSubsystems_5a3c, systemFunctions_5a3d, systems_5a3e, childSubsystems_5a3f, systemFunctions_5a40);
	if( ( !systems_5a3b.empty())&& ( !childSubsystems_5a3c.empty())&& ( !systemFunctions_5a3d.empty()))
		callCreateTriggering_5faa( systems_5a3b, childSubsystems_5a3c, systemFunctions_5a3d);
	_system_5a31->insert( _system_5a31->end(), systems_5a3e.begin(), systems_5a3e.end());
	_childSubsystem_5a32->insert( _childSubsystem_5a32->end(), childSubsystems_5a3f.begin(), childSubsystems_5a3f.end());
	_compoundStatement_5a33->insert( _compoundStatement_5a33->end(), systemFunctions_5a40.begin(), systemFunctions_5a40.end());
}

void MakeTrigger_5a27::callCreateTriggering_5faa( const Packets_t& systems_5acb, const Packets_t& childSubsystems_5acd, const Packets_t& systemFunctions_5acf)
{
	Packets_t systems_5ad1;
	Packets_t childSubsystems_5ad2;
	Packets_t conditionalBlocks_5ad3;
	CreateTriggering_5aca createTriggering_5aca;
	createTriggering_5aca( systems_5acb, childSubsystems_5acd, systemFunctions_5acf, systems_5ad1, childSubsystems_5ad2, conditionalBlocks_5ad3);
	_system_5a31->insert( _system_5a31->end(), systems_5ad1.begin(), systems_5ad1.end());
	_childSubsystem_5a32->insert( _childSubsystem_5a32->end(), childSubsystems_5ad2.begin(), childSubsystems_5ad2.end());
	_compoundStatement_5a33->insert( _compoundStatement_5a33->end(), conditionalBlocks_5ad3.begin(), conditionalBlocks_5ad3.end());
}

void IsTriggered_5a34::operator()( const Packets_t& systems_5a35, const Packets_t& childSubsystems_5a37, const Packets_t& systemFunctions_5a39, Packets_t& systems_5a3b, Packets_t& childSubsystems_5a3c, Packets_t& systemFunctions_5a3d, Packets_t& systems_5a3e, Packets_t& childSubsystems_5a3f, Packets_t& systemFunctions_5a40)
{
#ifdef PRINT_INFO
	printLog( "IsTriggered_5a34" );
#endif
	_system_5a41= &systems_5a3b;
	_childSubsystem_5a42= &childSubsystems_5a3c;
	_systemFunction_5a43= &systemFunctions_5a3d;
	_system_5a44= &systems_5a3e;
	_childSubsystem_5a45= &childSubsystems_5a3f;
	_systemFunction_5a46= &systemFunctions_5a40;
	for( Packets_t::const_iterator itsystem_5a48= systems_5a35.begin(), itchildSubsystem_5a4f= childSubsystems_5a37.begin(), itsystemFunction_5a56= systemFunctions_5a39.begin(); itsystem_5a48!= systems_5a35.end(), itchildSubsystem_5a4f!= childSubsystems_5a37.end(), itsystemFunction_5a56!= systemFunctions_5a39.end(); ++itsystem_5a48, ++itchildSubsystem_5a4f, ++itsystemFunction_5a56)
	{
		bool isUnique= isInputUnique( *itsystem_5a48, *itchildSubsystem_5a4f, *itsystemFunction_5a56);
		if( !isUnique)
			continue;
		Packets_t onesystem_5a4c( 1, *itsystem_5a48);
		Packets_t onechildSubsystem_5a53( 1, *itchildSubsystem_5a4f);
		Packets_t onesystemFunction_5a5a( 1, *itsystemFunction_5a56);
		executeOne( onesystem_5a4c, onechildSubsystem_5a53, onesystemFunction_5a5a);
	}
}

void IsTriggered_5a34::executeOne( const Packets_t& systems_5a35, const Packets_t& childSubsystems_5a37, const Packets_t& systemFunctions_5a39)
{
	Packets_t subsystems_5a5f;
	Packets_t blocks_5a62;
	Packets_t mains_5a65;
	HasTriggers_5a5c hasTriggers_5a5c;
	bool isMatchHasTriggers_5a5c= hasTriggers_5a5c( systems_5a35, childSubsystems_5a37, systemFunctions_5a39, subsystems_5a5f, blocks_5a62, mains_5a65);
	_system_5a41->insert( _system_5a41->end(), subsystems_5a5f.begin(), subsystems_5a5f.end());
	_childSubsystem_5a42->insert( _childSubsystem_5a42->end(), blocks_5a62.begin(), blocks_5a62.end());
	_systemFunction_5a43->insert( _systemFunction_5a43->end(), mains_5a65.begin(), mains_5a65.end());
	if( isMatchHasTriggers_5a5c)
		return;
	Packets_t subsystems_5a98;
	Packets_t blocks_5a9b;
	Packets_t mains_5a9e;
	Otherwise_5a95 otherwise_5a95;
	bool isMatchOtherwise_5a95= otherwise_5a95( systems_5a35, childSubsystems_5a37, systemFunctions_5a39, subsystems_5a98, blocks_5a9b, mains_5a9e);
	_system_5a44->insert( _system_5a44->end(), subsystems_5a98.begin(), subsystems_5a98.end());
	_childSubsystem_5a45->insert( _childSubsystem_5a45->end(), blocks_5a9b.begin(), blocks_5a9b.end());
	_systemFunction_5a46->insert( _systemFunction_5a46->end(), mains_5a9e.begin(), mains_5a9e.end());
	if( isMatchOtherwise_5a95)
		return;
}

bool IsTriggered_5a34::isInputUnique( const Udm::Object& system_5a49, const Udm::Object& childSubsystem_5a50, const Udm::Object& systemFunction_5a57)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itsystem_5a4b= _system_5a47.begin(), itchildSubsystem_5a52= _childSubsystem_5a4e.begin(), itsystemFunction_5a59= _systemFunction_5a55.begin(); itsystem_5a4b!= _system_5a47.end(), itchildSubsystem_5a52!= _childSubsystem_5a4e.end(), itsystemFunction_5a59!= _systemFunction_5a55.end(); ++itsystem_5a4b, ++itchildSubsystem_5a52, ++itsystemFunction_5a59)
	{
		if( ( *itsystem_5a4b== system_5a49)&& ( *itchildSubsystem_5a52== childSubsystem_5a50)&& ( *itsystemFunction_5a59== systemFunction_5a57))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_system_5a47.push_back( system_5a49);
		_childSubsystem_5a4e.push_back( childSubsystem_5a50);
		_systemFunction_5a55.push_back( systemFunction_5a57);
	}
	return isUnique;
}

bool HasTriggers_5a5c::operator()( const Packets_t& subsystems_5a5d, const Packets_t& blocks_5a60, const Packets_t& mains_5a63, Packets_t& subsystems_5a5f, Packets_t& blocks_5a62, Packets_t& mains_5a65)
{
#ifdef PRINT_INFO
	printLog( "HasTriggers_5a5c" );
#endif
	_subsystem_5a66= &subsystems_5a5f;
	_block_5a67= &blocks_5a62;
	_main_5a68= &mains_5a65;
	processInputPackets( subsystems_5a5d, blocks_5a60, mains_5a63);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasTriggers_5a5c::isInputUnique( const Udm::Object& subsystem_5a6d, const Udm::Object& block_5a76, const Udm::Object& main_5a7f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_5a6f= _subsystem_5a69.begin(), itBlock_5a78= _block_5a72.begin(), itMain_5a81= _main_5a7b.begin(); itSubsystem_5a6f!= _subsystem_5a69.end(), itBlock_5a78!= _block_5a72.end(), itMain_5a81!= _main_5a7b.end(); ++itSubsystem_5a6f, ++itBlock_5a78, ++itMain_5a81)
	{
		if( ( *itSubsystem_5a6f== subsystem_5a6d)&& ( *itBlock_5a78== block_5a76)&& ( *itMain_5a81== main_5a7f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_5a69.push_back( subsystem_5a6d);
		_block_5a72.push_back( block_5a76);
		_main_5a7b.push_back( main_5a7f);
	}
	return isUnique;
}

bool HasTriggers_5a5c::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void HasTriggers_5a5c::processInputPackets( const Packets_t& subsystems_5a5d, const Packets_t& blocks_5a60, const Packets_t& mains_5a63)
{
	for( Packets_t::const_iterator itSubsystem_5a6a= subsystems_5a5d.begin(), itBlock_5a73= blocks_5a60.begin(), itMain_5a7c= mains_5a63.begin(); itSubsystem_5a6a!= subsystems_5a5d.end(), itBlock_5a73!= blocks_5a60.end(), itMain_5a7c!= mains_5a63.end(); ++itSubsystem_5a6a, ++itBlock_5a73, ++itMain_5a7c)
	{
		bool isUnique= isInputUnique( *itSubsystem_5a6a, *itBlock_5a73, *itMain_5a7c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_5a6a, *itBlock_5a73, *itMain_5a7c);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_5a8b, currMatch.block_5a8c, currMatch.main_5a8d);
	}
}

bool HasTriggers_5a5c::patternMatcher( const Udm::Object& subsystem_5a6b, const Udm::Object& block_5a74, const Udm::Object& main_5a7d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_5a6b.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_5a70= CyberComposition::Simulink::Subsystem::Cast( subsystem_5a6b);
		if( false== Uml::IsDerivedFrom( block_5a74.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem block_5a79= CyberComposition::Simulink::Subsystem::Cast( block_5a74);
		if( false== Uml::IsDerivedFrom( main_5a7d.type(), SFC::Function::meta))
			continue;
		SFC::Function main_5a82= SFC::Function::Cast( main_5a7d);
		set< CyberComposition::Simulink::TriggerPort> triggerPorts_5a84= block_5a79.TriggerPort_kind_children();
		for( set< CyberComposition::Simulink::TriggerPort>::const_iterator itTriggerPort_5a85= triggerPorts_5a84.begin(); itTriggerPort_5a85!= triggerPorts_5a84.end(); ++itTriggerPort_5a85)
		{
			CyberComposition::Simulink::TriggerPort currTriggerPort_5a86= *itTriggerPort_5a85;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_5a8a;
			if( !isValidBound(boundObjs_5a8a, subsystem_5a70, true))
				continue;
			currMatch.subsystem_5a8b= subsystem_5a70;
			if( !isValidBound(boundObjs_5a8a, block_5a79, true))
				continue;
			currMatch.block_5a8c= block_5a79;
			if( !isValidBound(boundObjs_5a8a, main_5a82, true))
				continue;
			currMatch.main_5a8d= main_5a82;
			if( !isValidBound(boundObjs_5a8a, currTriggerPort_5a86, false))
				continue;
			currMatch.triggerPort_5a8e= currTriggerPort_5a86;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void HasTriggers_5a5c::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_5a8f, const CyberComposition::Simulink::Subsystem& block_5a91, const SFC::Function& main_5a93)
{
	_subsystem_5a66->push_back( subsystem_5a8f);
	_block_5a67->push_back( block_5a91);
	_main_5a68->push_back( main_5a93);
}

bool Otherwise_5a95::operator()( const Packets_t& subsystems_5a96, const Packets_t& blocks_5a99, const Packets_t& mains_5a9c, Packets_t& subsystems_5a98, Packets_t& blocks_5a9b, Packets_t& mains_5a9e)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_5a95" );
#endif
	_subsystem_5a9f= &subsystems_5a98;
	_block_5aa0= &blocks_5a9b;
	_main_5aa1= &mains_5a9e;
	processInputPackets( subsystems_5a96, blocks_5a99, mains_5a9c);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_5a95::isInputUnique( const Udm::Object& subsystem_5aa6, const Udm::Object& block_5aaf, const Udm::Object& main_5ab8)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_5aa8= _subsystem_5aa2.begin(), itBlock_5ab1= _block_5aab.begin(), itMain_5aba= _main_5ab4.begin(); itSubsystem_5aa8!= _subsystem_5aa2.end(), itBlock_5ab1!= _block_5aab.end(), itMain_5aba!= _main_5ab4.end(); ++itSubsystem_5aa8, ++itBlock_5ab1, ++itMain_5aba)
	{
		if( ( *itSubsystem_5aa8== subsystem_5aa6)&& ( *itBlock_5ab1== block_5aaf)&& ( *itMain_5aba== main_5ab8))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_5aa2.push_back( subsystem_5aa6);
		_block_5aab.push_back( block_5aaf);
		_main_5ab4.push_back( main_5ab8);
	}
	return isUnique;
}

bool Otherwise_5a95::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_5a95::processInputPackets( const Packets_t& subsystems_5a96, const Packets_t& blocks_5a99, const Packets_t& mains_5a9c)
{
	for( Packets_t::const_iterator itSubsystem_5aa3= subsystems_5a96.begin(), itBlock_5aac= blocks_5a99.begin(), itMain_5ab5= mains_5a9c.begin(); itSubsystem_5aa3!= subsystems_5a96.end(), itBlock_5aac!= blocks_5a99.end(), itMain_5ab5!= mains_5a9c.end(); ++itSubsystem_5aa3, ++itBlock_5aac, ++itMain_5ab5)
	{
		bool isUnique= isInputUnique( *itSubsystem_5aa3, *itBlock_5aac, *itMain_5ab5);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_5aa3, *itBlock_5aac, *itMain_5ab5);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.subsystem_5ac1, currMatch.block_5ac2, currMatch.main_5ac3);
	}
}

bool Otherwise_5a95::patternMatcher( const Udm::Object& subsystem_5aa4, const Udm::Object& block_5aad, const Udm::Object& main_5ab6)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_5aa4.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_5aa9= CyberComposition::Simulink::Subsystem::Cast( subsystem_5aa4);
		if( false== Uml::IsDerivedFrom( block_5aad.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem block_5ab2= CyberComposition::Simulink::Subsystem::Cast( block_5aad);
		if( false== Uml::IsDerivedFrom( main_5ab6.type(), SFC::Function::meta))
			continue;
		SFC::Function main_5abb= SFC::Function::Cast( main_5ab6);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5ac0;
		if( !isValidBound(boundObjs_5ac0, subsystem_5aa9, true))
			continue;
		currMatch.subsystem_5ac1= subsystem_5aa9;
		if( !isValidBound(boundObjs_5ac0, block_5ab2, true))
			continue;
		currMatch.block_5ac2= block_5ab2;
		if( !isValidBound(boundObjs_5ac0, main_5abb, true))
			continue;
		currMatch.main_5ac3= main_5abb;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_5a95::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_5ac4, const CyberComposition::Simulink::Subsystem& block_5ac6, const SFC::Function& main_5ac8)
{
	_subsystem_5a9f->push_back( subsystem_5ac4);
	_block_5aa0->push_back( block_5ac6);
	_main_5aa1->push_back( main_5ac8);
}

void CreateTriggering_5aca::operator()( const Packets_t& systems_5acb, const Packets_t& childSubsystems_5acd, const Packets_t& systemFunctions_5acf, Packets_t& systems_5ad1, Packets_t& childSubsystems_5ad2, Packets_t& conditionalBlocks_5ad3)
{
#ifdef PRINT_INFO
	printLog( "CreateTriggering_5aca" );
#endif
	_system_5ad4= &systems_5ad1;
	_childSubsystem_5ad5= &childSubsystems_5ad2;
	_conditionalBlock_5ad6= &conditionalBlocks_5ad3;
	if( ( !systems_5acb.empty())&& ( !childSubsystems_5acd.empty())&& ( !systemFunctions_5acf.empty()))
		callCreateTriggerCondition_5f9b( systems_5acb, childSubsystems_5acd, systemFunctions_5acf);
}

void CreateTriggering_5aca::callCreateTriggerCondition_5f9b( const Packets_t& subsystems_5b05, const Packets_t& blocks_5b08, const Packets_t& mains_5b0c)
{
	Packets_t subsystems_5b07;
	Packets_t blocks_5b0a;
	Packets_t triggerPorts_5b0b;
	Packets_t conditionalBlocks_5b0e;
	Packets_t conditions_5b0f;
	CreateTriggerCondition_5b04 createTriggerCondition_5b04;
	createTriggerCondition_5b04( subsystems_5b05, blocks_5b08, mains_5b0c, subsystems_5b07, blocks_5b0a, triggerPorts_5b0b, conditionalBlocks_5b0e, conditions_5b0f);
	_system_5ad4->insert( _system_5ad4->end(), subsystems_5b07.begin(), subsystems_5b07.end());
	_childSubsystem_5ad5->insert( _childSubsystem_5ad5->end(), blocks_5b0a.begin(), blocks_5b0a.end());
	_conditionalBlock_5ad6->insert( _conditionalBlock_5ad6->end(), conditionalBlocks_5b0e.begin(), conditionalBlocks_5b0e.end());
	if( ( !triggerPorts_5b0b.empty())&& ( !conditions_5b0f.empty()))
		callAssignCondVal_5f9f( triggerPorts_5b0b, conditions_5b0f);
}

void CreateTriggering_5aca::callAssignCondVal_5f9f( const Packets_t& triggerPorts_5ad8, const Packets_t& conditions_5adc)
{
	Packets_t argDeclBases_5ada;
	Packets_t dTs_5adb;
	Packets_t conditions_5ade;
	AssignCondVal_5ad7 assignCondVal_5ad7;
	assignCondVal_5ad7( triggerPorts_5ad8, conditions_5adc, argDeclBases_5ada, dTs_5adb, conditions_5ade);
	if( ( !argDeclBases_5ada.empty())&& ( !dTs_5adb.empty())&& ( !conditions_5ade.empty()))
		callcreateTriggerOr_5fa2( argDeclBases_5ada, dTs_5adb, conditions_5ade);
}

void CreateTriggering_5aca::callcreateTriggerOr_5fa2( const Packets_t& argdecls_5b48, const Packets_t& dts_5b4a, const Packets_t& conditions_5b4c)
{
	CreateTriggerOr_5b47 createTriggerOr_5b47;
	createTriggerOr_5b47( argdecls_5b48, dts_5b4a, conditions_5b4c);
}

void AssignCondVal_5ad7::operator()( const Packets_t& triggerPorts_5ad8, const Packets_t& conditions_5adc, Packets_t& argDeclBases_5ada, Packets_t& dTs_5adb, Packets_t& conditions_5ade)
{
#ifdef PRINT_INFO
	printLog( "AssignCondVal_5ad7" );
#endif
	RTTGenerator::Instance()->generateRule(4718, "AssignCondVal");
	_argDeclBase_5adf= &argDeclBases_5ada;
	_dT_5ae0= &dTs_5adb;
	_condition_5ae1= &conditions_5ade;
	processInputPackets( triggerPorts_5ad8, conditions_5adc);
}

bool AssignCondVal_5ad7::isInputUnique( const Udm::Object& triggerPort_5ae6, const Udm::Object& condition_5aef)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itTriggerPort_5ae8= _triggerPort_5ae2.begin(), itCondition_5af1= _condition_5aeb.begin(); itTriggerPort_5ae8!= _triggerPort_5ae2.end(), itCondition_5af1!= _condition_5aeb.end(); ++itTriggerPort_5ae8, ++itCondition_5af1)
	{
		if( ( *itTriggerPort_5ae8== triggerPort_5ae6)&& ( *itCondition_5af1== condition_5aef))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_triggerPort_5ae2.push_back( triggerPort_5ae6);
		_condition_5aeb.push_back( condition_5aef);
	}
	return isUnique;
}

bool AssignCondVal_5ad7::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void AssignCondVal_5ad7::processInputPackets( const Packets_t& triggerPorts_5ad8, const Packets_t& conditions_5adc)
{
	for( Packets_t::const_iterator itTriggerPort_5ae3= triggerPorts_5ad8.begin(), itCondition_5aec= conditions_5adc.begin(); itTriggerPort_5ae3!= triggerPorts_5ad8.end(), itCondition_5aec!= conditions_5adc.end(); ++itTriggerPort_5ae3, ++itCondition_5aec)
	{
		bool isUnique= isInputUnique( *itTriggerPort_5ae3, *itCondition_5aec);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itTriggerPort_5ae3, *itCondition_5aec);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool AssignCondVal_5ad7::patternMatcher( const Udm::Object& triggerPort_5ae4, const Udm::Object& condition_5aed)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( triggerPort_5ae4.type(), CyberComposition::Simulink::SF_Port::meta))
			continue;
		CyberComposition::Simulink::SF_Port triggerPort_5ae9= CyberComposition::Simulink::SF_Port::Cast( triggerPort_5ae4);
		if( false== Uml::IsDerivedFrom( condition_5aed.type(), SFC::UserCode::meta))
			continue;
		SFC::UserCode condition_5af2= SFC::UserCode::Cast( condition_5aed);
		SFC::ArgDeclBase argDeclBase_5af4= triggerPort_5ae9.argdecl();
		if( !argDeclBase_5af4)
			continue;
		SFC::DT dT_5af5= argDeclBase_5af4.dt();
		if( !dT_5af5)
			continue;
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5af9;
		if( !isValidBound(boundObjs_5af9, triggerPort_5ae9, true))
			continue;
		currMatch.triggerPort_5afa= triggerPort_5ae9;
		if( !isValidBound(boundObjs_5af9, condition_5af2, true))
			continue;
		currMatch.condition_5afb= condition_5af2;
		if( !isValidBound(boundObjs_5af9, argDeclBase_5af4, false))
			continue;
		currMatch.argDeclBase_5afc= argDeclBase_5af4;
		if( !isValidBound(boundObjs_5af9, dT_5af5, false))
			continue;
		currMatch.dT_5afd= dT_5af5;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void AssignCondVal_5ad7::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_5afc, currMatch.dT_5afd, currMatch.condition_5afb);
	}
}

void AssignCondVal_5ad7::outputAppender( const SFC::ArgDeclBase& argDeclBase_5afe, const SFC::DT& dT_5b00, const SFC::UserCode& condition_5b02)
{
	_argDeclBase_5adf->push_back( argDeclBase_5afe);
	_dT_5ae0->push_back( dT_5b00);
	_condition_5ae1->push_back( condition_5b02);
}

void CreateTriggerCondition_5b04::operator()( const Packets_t& subsystems_5b05, const Packets_t& blocks_5b08, const Packets_t& mains_5b0c, Packets_t& subsystems_5b07, Packets_t& blocks_5b0a, Packets_t& triggerPorts_5b0b, Packets_t& conditionalBlocks_5b0e, Packets_t& conditions_5b0f)
{
#ifdef PRINT_INFO
	printLog( "CreateTriggerCondition_5b04" );
#endif
	RTTGenerator::Instance()->generateRule(4725, "CreateTriggerCondition");
	_subsystem_5b10= &subsystems_5b07;
	_block_5b11= &blocks_5b0a;
	_triggerPort_5b12= &triggerPorts_5b0b;
	_conditionalBlock_5b13= &conditionalBlocks_5b0e;
	_condition_5b14= &conditions_5b0f;
	processInputPackets( subsystems_5b05, blocks_5b08, mains_5b0c);
}

bool CreateTriggerCondition_5b04::isInputUnique( const Udm::Object& subsystem_5b19, const Udm::Object& block_5b22, const Udm::Object& main_5b2b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itSubsystem_5b1b= _subsystem_5b15.begin(), itBlock_5b24= _block_5b1e.begin(), itMain_5b2d= _main_5b27.begin(); itSubsystem_5b1b!= _subsystem_5b15.end(), itBlock_5b24!= _block_5b1e.end(), itMain_5b2d!= _main_5b27.end(); ++itSubsystem_5b1b, ++itBlock_5b24, ++itMain_5b2d)
	{
		if( ( *itSubsystem_5b1b== subsystem_5b19)&& ( *itBlock_5b24== block_5b22)&& ( *itMain_5b2d== main_5b2b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_subsystem_5b15.push_back( subsystem_5b19);
		_block_5b1e.push_back( block_5b22);
		_main_5b27.push_back( main_5b2b);
	}
	return isUnique;
}

bool CreateTriggerCondition_5b04::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateTriggerCondition_5b04::processInputPackets( const Packets_t& subsystems_5b05, const Packets_t& blocks_5b08, const Packets_t& mains_5b0c)
{
	for( Packets_t::const_iterator itSubsystem_5b16= subsystems_5b05.begin(), itBlock_5b1f= blocks_5b08.begin(), itMain_5b28= mains_5b0c.begin(); itSubsystem_5b16!= subsystems_5b05.end(), itBlock_5b1f!= blocks_5b08.end(), itMain_5b28!= mains_5b0c.end(); ++itSubsystem_5b16, ++itBlock_5b1f, ++itMain_5b28)
	{
		bool isUnique= isInputUnique( *itSubsystem_5b16, *itBlock_5b1f, *itMain_5b28);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itSubsystem_5b16, *itBlock_5b1f, *itMain_5b28);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateTriggerCondition_5b04::patternMatcher( const Udm::Object& subsystem_5b17, const Udm::Object& block_5b20, const Udm::Object& main_5b29)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( subsystem_5b17.type(), CyberComposition::Simulink::Subsystem::meta))
			continue;
		CyberComposition::Simulink::Subsystem subsystem_5b1c= CyberComposition::Simulink::Subsystem::Cast( subsystem_5b17);
		if( false== Uml::IsDerivedFrom( block_5b20.type(), CyberComposition::Simulink::Block::meta))
			continue;
		CyberComposition::Simulink::Block block_5b25= CyberComposition::Simulink::Block::Cast( block_5b20);
		if( false== Uml::IsDerivedFrom( main_5b29.type(), SFC::Function::meta))
			continue;
		SFC::Function main_5b2e= SFC::Function::Cast( main_5b29);
		set< CyberComposition::Simulink::TriggerPort> triggerPorts_5b30= block_5b25.TriggerPort_kind_children();
		for( set< CyberComposition::Simulink::TriggerPort>::const_iterator itTriggerPort_5b31= triggerPorts_5b30.begin(); itTriggerPort_5b31!= triggerPorts_5b30.end(); ++itTriggerPort_5b31)
		{
			CyberComposition::Simulink::TriggerPort currTriggerPort_5b32= *itTriggerPort_5b31;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_5b36;
			if( !isValidBound(boundObjs_5b36, subsystem_5b1c, true))
				continue;
			currMatch.subsystem_5b37= subsystem_5b1c;
			if( !isValidBound(boundObjs_5b36, block_5b25, true))
				continue;
			currMatch.block_5b38= block_5b25;
			if( !isValidBound(boundObjs_5b36, main_5b2e, true))
				continue;
			currMatch.main_5b39= main_5b2e;
			if( !isValidBound(boundObjs_5b36, currTriggerPort_5b32, false))
				continue;
			currMatch.triggerPort_5b3a= currTriggerPort_5b32;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void CreateTriggerCondition_5b04::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ConditionalBlock newConditionalBlock_5b3b= SFC::ConditionalBlock::Create( currMatch.main_5b39);
		SFC::UserCode newCondition_5b3c= SFC::UserCode::Create( newConditionalBlock_5b3b, SFC::ConditionalBlock::meta_cond);
		CyberComposition::Simulink::Block& Block= currMatch.block_5b38;
		SFC::UserCode& Condition= newCondition_5b3c;
		SFC::ConditionalBlock& ConditionalBlock= newConditionalBlock_5b3b;
		SFC::Function& Main= currMatch.main_5b39;
		CyberComposition::Simulink::Subsystem& Subsystem= currMatch.subsystem_5b37;
		CyberComposition::Simulink::TriggerPort& TriggerPort= currMatch.triggerPort_5b3a;
		{
__int64 sc = Main.statementCount();
ConditionalBlock.statementIndex() = sc++;
Main.statementCount() = sc;
};
		{
Condition.expr() = "0"; 
};
		outputAppender( currMatch.subsystem_5b37, currMatch.block_5b38, currMatch.triggerPort_5b3a, newConditionalBlock_5b3b, newCondition_5b3c);
	}
}

void CreateTriggerCondition_5b04::outputAppender( const CyberComposition::Simulink::Subsystem& subsystem_5b3d, const CyberComposition::Simulink::Block& block_5b3f, const CyberComposition::Simulink::TriggerPort& triggerPort_5b41, const SFC::ConditionalBlock& conditionalBlock_5b43, const SFC::UserCode& condition_5b45)
{
	_subsystem_5b10->push_back( subsystem_5b3d);
	_block_5b11->push_back( block_5b3f);
	_triggerPort_5b12->push_back( triggerPort_5b41);
	_conditionalBlock_5b13->push_back( conditionalBlock_5b43);
	_condition_5b14->push_back( condition_5b45);
}

void CreateTriggerOr_5b47::operator()( const Packets_t& argdecls_5b48, const Packets_t& dts_5b4a, const Packets_t& conditions_5b4c)
{
#ifdef PRINT_INFO
	printLog( "CreateTriggerOr_5b47" );
#endif
	if( ( !argdecls_5b48.empty())&& ( !dts_5b4a.empty())&& ( !conditions_5b4c.empty()))
		callStructTest_5f8b( argdecls_5b48, dts_5b4a, conditions_5b4c);
}

void CreateTriggerOr_5b47::callStructTest_5f8b( const Packets_t& argdecls_5edc, const Packets_t& dts_5ede, const Packets_t& conditions_5ee0)
{
	Packets_t argdecls_5ee2;
	Packets_t structs_5ee3;
	Packets_t conditions_5ee4;
	Packets_t argdecls_5ee5;
	Packets_t dts_5ee6;
	Packets_t conditions_5ee7;
	StructTest_5edb structTest_5edb;
	structTest_5edb( argdecls_5edc, dts_5ede, conditions_5ee0, argdecls_5ee2, structs_5ee3, conditions_5ee4, argdecls_5ee5, dts_5ee6, conditions_5ee7);
	if( ( !argdecls_5ee2.empty())&& ( !structs_5ee3.empty())&& ( !conditions_5ee4.empty()))
		callgetStructMembers_5f8f( argdecls_5ee2, structs_5ee3, conditions_5ee4);
	if( ( !argdecls_5ee5.empty())&& ( !conditions_5ee7.empty()))
		callargDeclIsCondition_5f93( argdecls_5ee5, conditions_5ee7);
}

void CreateTriggerOr_5b47::callgetStructMembers_5f8f( const Packets_t& argDeclBases_5b4f, const Packets_t& structs_5b52, const Packets_t& userCodes_5b56)
{
	Packets_t argDeclBases_5b51;
	Packets_t structs_5b54;
	Packets_t localVars_5b55;
	Packets_t userCodes_5b58;
	GetStructMembers_5b4e getStructMembers_5b4e;
	getStructMembers_5b4e( argDeclBases_5b4f, structs_5b52, userCodes_5b56, argDeclBases_5b51, structs_5b54, localVars_5b55, userCodes_5b58);
	if( ( !argDeclBases_5b51.empty())&& ( !structs_5b54.empty())&& ( !localVars_5b55.empty())&& ( !userCodes_5b58.empty()))
		callPlaceMember_5f96( argDeclBases_5b51, structs_5b54, localVars_5b55, userCodes_5b58);
}

void CreateTriggerOr_5b47::callargDeclIsCondition_5f93( const Packets_t& argDeclBases_5f6e, const Packets_t& conditions_5f70)
{
	ArgDeclIsCondition_5f6d argDeclIsCondition_5f6d;
	argDeclIsCondition_5f6d( argDeclBases_5f6e, conditions_5f70);
}

void CreateTriggerOr_5b47::callPlaceMember_5f96( const Packets_t& argdecls_5b8c, const Packets_t& structs_5b8e, const Packets_t& membs_5b90, const Packets_t& conditions_5b92)
{
	PlaceMember_5b8b placeMember_5b8b;
	placeMember_5b8b( argdecls_5b8c, structs_5b8e, membs_5b90, conditions_5b92);
}

void GetStructMembers_5b4e::operator()( const Packets_t& argDeclBases_5b4f, const Packets_t& structs_5b52, const Packets_t& userCodes_5b56, Packets_t& argDeclBases_5b51, Packets_t& structs_5b54, Packets_t& localVars_5b55, Packets_t& userCodes_5b58)
{
#ifdef PRINT_INFO
	printLog( "GetStructMembers_5b4e" );
#endif
	RTTGenerator::Instance()->generateRule(4741, "getStructMembers");
	_argDeclBase_5b59= &argDeclBases_5b51;
	_struct_5b5a= &structs_5b54;
	_localVar_5b5b= &localVars_5b55;
	_userCode_5b5c= &userCodes_5b58;
	processInputPackets( argDeclBases_5b4f, structs_5b52, userCodes_5b56);
	sortOutputs( );
}

bool GetStructMembers_5b4e::isInputUnique( const Udm::Object& argDeclBase_5b61, const Udm::Object& struct_5b6a, const Udm::Object& userCode_5b73)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_5b63= _argDeclBase_5b5d.begin(), itStruct_5b6c= _struct_5b66.begin(), itUserCode_5b75= _userCode_5b6f.begin(); itArgDeclBase_5b63!= _argDeclBase_5b5d.end(), itStruct_5b6c!= _struct_5b66.end(), itUserCode_5b75!= _userCode_5b6f.end(); ++itArgDeclBase_5b63, ++itStruct_5b6c, ++itUserCode_5b75)
	{
		if( ( *itArgDeclBase_5b63== argDeclBase_5b61)&& ( *itStruct_5b6c== struct_5b6a)&& ( *itUserCode_5b75== userCode_5b73))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_5b5d.push_back( argDeclBase_5b61);
		_struct_5b66.push_back( struct_5b6a);
		_userCode_5b6f.push_back( userCode_5b73);
	}
	return isUnique;
}

bool GetStructMembers_5b4e::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetStructMembers_5b4e::processInputPackets( const Packets_t& argDeclBases_5b4f, const Packets_t& structs_5b52, const Packets_t& userCodes_5b56)
{
	for( Packets_t::const_iterator itArgDeclBase_5b5e= argDeclBases_5b4f.begin(), itStruct_5b67= structs_5b52.begin(), itUserCode_5b70= userCodes_5b56.begin(); itArgDeclBase_5b5e!= argDeclBases_5b4f.end(), itStruct_5b67!= structs_5b52.end(), itUserCode_5b70!= userCodes_5b56.end(); ++itArgDeclBase_5b5e, ++itStruct_5b67, ++itUserCode_5b70)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_5b5e, *itStruct_5b67, *itUserCode_5b70);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_5b5e, *itStruct_5b67, *itUserCode_5b70);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetStructMembers_5b4e::patternMatcher( const Udm::Object& argDeclBase_5b5f, const Udm::Object& struct_5b68, const Udm::Object& userCode_5b71)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_5b5f.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_5b64= SFC::ArgDeclBase::Cast( argDeclBase_5b5f);
		if( false== Uml::IsDerivedFrom( struct_5b68.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_5b6d= SFC::Struct::Cast( struct_5b68);
		if( false== Uml::IsDerivedFrom( userCode_5b71.type(), SFC::UserCode::meta))
			continue;
		SFC::UserCode userCode_5b76= SFC::UserCode::Cast( userCode_5b71);
		set< SFC::LocalVar> localVars_5b78= struct_5b6d.LocalVar_kind_children();
		for( set< SFC::LocalVar>::const_iterator itLocalVar_5b79= localVars_5b78.begin(); itLocalVar_5b79!= localVars_5b78.end(); ++itLocalVar_5b79)
		{
			SFC::LocalVar currLocalVar_5b7a= *itLocalVar_5b79;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_5b7e;
			if( !isValidBound(boundObjs_5b7e, argDeclBase_5b64, true))
				continue;
			currMatch.argDeclBase_5b7f= argDeclBase_5b64;
			if( !isValidBound(boundObjs_5b7e, struct_5b6d, true))
				continue;
			currMatch.struct_5b80= struct_5b6d;
			if( !isValidBound(boundObjs_5b7e, userCode_5b76, true))
				continue;
			currMatch.userCode_5b81= userCode_5b76;
			if( !isValidBound(boundObjs_5b7e, currLocalVar_5b7a, false))
				continue;
			currMatch.localVar_5b82= currLocalVar_5b7a;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetStructMembers_5b4e::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_5b7f, currMatch.struct_5b80, currMatch.localVar_5b82, currMatch.userCode_5b81);
	}
}

void GetStructMembers_5b4e::outputAppender( const SFC::ArgDeclBase& argDeclBase_5b83, const SFC::Struct& struct_5b85, const SFC::LocalVar& localVar_5b87, const SFC::UserCode& userCode_5b89)
{
	_argDeclBase_5b59->push_back( argDeclBase_5b83);
	_struct_5b5a->push_back( struct_5b85);
	_localVar_5b5b->push_back( localVar_5b87);
	_userCode_5b5c->push_back( userCode_5b89);
}

void GetStructMembers_5b4e::sortOutputs()
{
	typedef std::multiset< SFC::LocalVar, std::pointer_to_binary_function< const SFC::LocalVar&, const SFC::LocalVar&, bool> > SortedSet_t;
	std::pointer_to_binary_function< const SFC::LocalVar&, const SFC::LocalVar&, bool> ptr_StatementOrder( StatementOrder< SFC::LocalVar>);
	SortedSet_t sortedSet( ptr_StatementOrder);
	std::vector< int> permutationVector( _localVar_5b5b->size());
	int currStep= 0;
	for( Packets_t::const_iterator it= _localVar_5b5b->begin(); it!= _localVar_5b5b->end(); ++it, ++currStep)
	{
		SortedSet_t::const_iterator inserted= sortedSet.insert( SFC::LocalVar::Cast(*it));
		SortedSet_t::difference_type pos= std::distance( SortedSet_t::const_iterator( sortedSet.begin()), inserted);
		permutationVector[ currStep]=  pos;
		for( int i= 0; i< currStep; ++i)
		{
			if( permutationVector[ i] >= pos)
				++permutationVector[ i];
		}
	}
	// order the primary container
	std::copy( sortedSet.begin(), sortedSet.end(), _localVar_5b5b->begin());
	// order rest of the containers
	permutate( permutationVector, *_argDeclBase_5b59);
	permutate( permutationVector, *_struct_5b5a);
	permutate( permutationVector, *_userCode_5b5c);
}

void PlaceMember_5b8b::operator()( const Packets_t& argdecls_5b8c, const Packets_t& structs_5b8e, const Packets_t& membs_5b90, const Packets_t& conditions_5b92)
{
#ifdef PRINT_INFO
	printLog( "PlaceMember_5b8b" );
#endif
	for( Packets_t::const_iterator itargdecl_5b95= argdecls_5b8c.begin(), itstruct_5b9c= structs_5b8e.begin(), itmemb_5ba3= membs_5b90.begin(), itcondition_5baa= conditions_5b92.begin(); itargdecl_5b95!= argdecls_5b8c.end(), itstruct_5b9c!= structs_5b8e.end(), itmemb_5ba3!= membs_5b90.end(), itcondition_5baa!= conditions_5b92.end(); ++itargdecl_5b95, ++itstruct_5b9c, ++itmemb_5ba3, ++itcondition_5baa)
	{
		bool isUnique= isInputUnique( *itargdecl_5b95, *itstruct_5b9c, *itmemb_5ba3, *itcondition_5baa);
		if( !isUnique)
			continue;
		Packets_t oneargdecl_5b99( 1, *itargdecl_5b95);
		Packets_t onestruct_5ba0( 1, *itstruct_5b9c);
		Packets_t onememb_5ba7( 1, *itmemb_5ba3);
		Packets_t onecondition_5bae( 1, *itcondition_5baa);
		executeOne( oneargdecl_5b99, onestruct_5ba0, onememb_5ba7, onecondition_5bae);
	}
}

void PlaceMember_5b8b::executeOne( const Packets_t& argdecls_5b8c, const Packets_t& structs_5b8e, const Packets_t& membs_5b90, const Packets_t& conditions_5b92)
{
	if( ( !argdecls_5b8c.empty())&& ( !structs_5b8e.empty())&& ( !membs_5b90.empty())&& ( !conditions_5b92.empty()))
		calltestMemberPos_5ebe( argdecls_5b8c, structs_5b8e, membs_5b90, conditions_5b92);
}

bool PlaceMember_5b8b::isInputUnique( const Udm::Object& argdecl_5b96, const Udm::Object& struct_5b9d, const Udm::Object& memb_5ba4, const Udm::Object& condition_5bab)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itargdecl_5b98= _argdecl_5b94.begin(), itstruct_5b9f= _struct_5b9b.begin(), itmemb_5ba6= _memb_5ba2.begin(), itcondition_5bad= _condition_5ba9.begin(); itargdecl_5b98!= _argdecl_5b94.end(), itstruct_5b9f!= _struct_5b9b.end(), itmemb_5ba6!= _memb_5ba2.end(), itcondition_5bad!= _condition_5ba9.end(); ++itargdecl_5b98, ++itstruct_5b9f, ++itmemb_5ba6, ++itcondition_5bad)
	{
		if( ( *itargdecl_5b98== argdecl_5b96)&& ( *itstruct_5b9f== struct_5b9d)&& ( *itmemb_5ba6== memb_5ba4)&& ( *itcondition_5bad== condition_5bab))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argdecl_5b94.push_back( argdecl_5b96);
		_struct_5b9b.push_back( struct_5b9d);
		_memb_5ba2.push_back( memb_5ba4);
		_condition_5ba9.push_back( condition_5bab);
	}
	return isUnique;
}

void PlaceMember_5b8b::calltestMemberPos_5ebe( const Packets_t& argdecls_5d9f, const Packets_t& structs_5da1, const Packets_t& membs_5da3, const Packets_t& conditions_5da5)
{
	Packets_t argdecls_5da7;
	Packets_t structs_5da8;
	Packets_t membs_5da9;
	Packets_t conditions_5daa;
	Packets_t argdecls_5dab;
	Packets_t structs_5dac;
	Packets_t membs_5dad;
	Packets_t conditions_5dae;
	TestMemberPos_5d9e testMemberPos_5d9e;
	testMemberPos_5d9e( argdecls_5d9f, structs_5da1, membs_5da3, conditions_5da5, argdecls_5da7, structs_5da8, membs_5da9, conditions_5daa, argdecls_5dab, structs_5dac, membs_5dad, conditions_5dae);
	if( ( !argdecls_5dab.empty())&& ( !membs_5dad.empty())&& ( !conditions_5dae.empty()))
		callfirstBinaryExprs_5ec3( argdecls_5dab, membs_5dad, conditions_5dae);
	if( ( !argdecls_5da7.empty())&& ( !membs_5da9.empty())&& ( !conditions_5daa.empty()))
		callfirstBinaryExprs_5ec7( argdecls_5da7, membs_5da9, conditions_5daa);
}

void PlaceMember_5b8b::callfirstBinaryExprs_5ec3( const Packets_t& argdecls_5bb1, const Packets_t& membs_5bb3, const Packets_t& conditions_5bb5)
{
	Packets_t argdecls_5bb7;
	Packets_t membs_5bb8;
	Packets_t binaryexprss_5bb9;
	Packets_t argdecls_5bba;
	Packets_t membs_5bbb;
	Packets_t conditions_5bbc;
	FirstBinaryExprs_5bb0 firstBinaryExprs_5bb0;
	firstBinaryExprs_5bb0( argdecls_5bb1, membs_5bb3, conditions_5bb5, argdecls_5bb7, membs_5bb8, binaryexprss_5bb9, argdecls_5bba, membs_5bbb, conditions_5bbc);
	if( ( !argdecls_5bba.empty())&& ( !membs_5bbb.empty())&& ( !conditions_5bbc.empty()))
		callcreateOnlyExprs_5ecb( argdecls_5bba, membs_5bbb, conditions_5bbc);
	if( ( !argdecls_5bb7.empty())&& ( !membs_5bb8.empty())&& ( !binaryexprss_5bb9.empty()))
		callCreateLastBinaryExprs_5ecf( argdecls_5bb7, membs_5bb8, binaryexprss_5bb9);
}

void PlaceMember_5b8b::callfirstBinaryExprs_5ec7( const Packets_t& argdecls_5bb1, const Packets_t& membs_5bb3, const Packets_t& conditions_5bb5)
{
	Packets_t argdecls_5bb7;
	Packets_t membs_5bb8;
	Packets_t binaryexprss_5bb9;
	Packets_t argdecls_5bba;
	Packets_t membs_5bbb;
	Packets_t conditions_5bbc;
	FirstBinaryExprs_5bb0 firstBinaryExprs_5bb0;
	firstBinaryExprs_5bb0( argdecls_5bb1, membs_5bb3, conditions_5bb5, argdecls_5bb7, membs_5bb8, binaryexprss_5bb9, argdecls_5bba, membs_5bbb, conditions_5bbc);
	if( ( !argdecls_5bba.empty())&& ( !membs_5bbb.empty())&& ( !conditions_5bbc.empty()))
		callcreateFirstBinaryExprs_5ed3( argdecls_5bba, membs_5bbb, conditions_5bbc);
	if( ( !argdecls_5bb7.empty())&& ( !membs_5bb8.empty())&& ( !binaryexprss_5bb9.empty()))
		callCreateNextBinaryExprs_5ed7( argdecls_5bb7, membs_5bb8, binaryexprss_5bb9);
}

void PlaceMember_5b8b::callcreateOnlyExprs_5ecb( const Packets_t& argDeclBases_5d73, const Packets_t& localVars_5d75, const Packets_t& userCodes_5d77)
{
	CreateOnlyExprs_5d72 createOnlyExprs_5d72;
	createOnlyExprs_5d72( argDeclBases_5d73, localVars_5d75, userCodes_5d77);
}

void PlaceMember_5b8b::callCreateLastBinaryExprs_5ecf( const Packets_t& argDeclBases_5e93, const Packets_t& localVars_5e95, const Packets_t& binaryExprss_5e97)
{
	CreateLastBinaryExprs_5e92 createLastBinaryExprs_5e92;
	createLastBinaryExprs_5e92( argDeclBases_5e93, localVars_5e95, binaryExprss_5e97);
}

void PlaceMember_5b8b::callcreateFirstBinaryExprs_5ed3( const Packets_t& argDeclBases_5d46, const Packets_t& localVars_5d48, const Packets_t& userCodes_5d4a)
{
	CreateFirstBinaryExprs_5d45 createFirstBinaryExprs_5d45;
	createFirstBinaryExprs_5d45( argDeclBases_5d46, localVars_5d48, userCodes_5d4a);
}

void PlaceMember_5b8b::callCreateNextBinaryExprs_5ed7( const Packets_t& argDeclBases_5e66, const Packets_t& localVars_5e68, const Packets_t& binaryExprss_5e6a)
{
	CreateNextBinaryExprs_5e65 createNextBinaryExprs_5e65;
	createNextBinaryExprs_5e65( argDeclBases_5e66, localVars_5e68, binaryExprss_5e6a);
}

void FirstBinaryExprs_5bb0::operator()( const Packets_t& argdecls_5bb1, const Packets_t& membs_5bb3, const Packets_t& conditions_5bb5, Packets_t& argdecls_5bb7, Packets_t& membs_5bb8, Packets_t& binaryexprss_5bb9, Packets_t& argdecls_5bba, Packets_t& membs_5bbb, Packets_t& conditions_5bbc)
{
#ifdef PRINT_INFO
	printLog( "FirstBinaryExprs_5bb0" );
#endif
	_argdecl_5bbd= &argdecls_5bb7;
	_memb_5bbe= &membs_5bb8;
	_binaryexprs_5bbf= &binaryexprss_5bb9;
	_argdecl_5bc0= &argdecls_5bba;
	_memb_5bc1= &membs_5bbb;
	_condition_5bc2= &conditions_5bbc;
	if( ( !argdecls_5bb1.empty())&& ( !membs_5bb3.empty())&& ( !conditions_5bb5.empty()))
		callCondHasExprs_5d3d( argdecls_5bb1, membs_5bb3, conditions_5bb5);
}

void FirstBinaryExprs_5bb0::callCondHasExprs_5d3d( const Packets_t& argdecls_5bc4, const Packets_t& membs_5bc6, const Packets_t& conditions_5bc8)
{
	Packets_t argdecls_5bca;
	Packets_t membs_5bcb;
	Packets_t conditions_5bcc;
	Packets_t argdecls_5bcd;
	Packets_t membs_5bce;
	Packets_t conditions_5bcf;
	CondHasExprs_5bc3 condHasExprs_5bc3;
	condHasExprs_5bc3( argdecls_5bc4, membs_5bc6, conditions_5bc8, argdecls_5bca, membs_5bcb, conditions_5bcc, argdecls_5bcd, membs_5bce, conditions_5bcf);
	_argdecl_5bc0->insert( _argdecl_5bc0->end(), argdecls_5bcd.begin(), argdecls_5bcd.end());
	_memb_5bc1->insert( _memb_5bc1->end(), membs_5bce.begin(), membs_5bce.end());
	_condition_5bc2->insert( _condition_5bc2->end(), conditions_5bcf.begin(), conditions_5bcf.end());
	if( ( !argdecls_5bca.empty())&& ( !membs_5bcb.empty())&& ( !conditions_5bcc.empty()))
		callgetLastBinaryExprs_5d41( argdecls_5bca, membs_5bcb, conditions_5bcc);
}

void FirstBinaryExprs_5bb0::callgetLastBinaryExprs_5d41( const Packets_t& argdecls_5c5a, const Packets_t& membs_5c5c, const Packets_t& conditions_5c5e)
{
	Packets_t argdecls_5c60;
	Packets_t membs_5c61;
	Packets_t binaryexprss_5c62;
	GetLastBinaryExprs_5c59 getLastBinaryExprs_5c59;
	getLastBinaryExprs_5c59( argdecls_5c5a, membs_5c5c, conditions_5c5e, argdecls_5c60, membs_5c61, binaryexprss_5c62);
	_argdecl_5bbd->insert( _argdecl_5bbd->end(), argdecls_5c60.begin(), argdecls_5c60.end());
	_memb_5bbe->insert( _memb_5bbe->end(), membs_5c61.begin(), membs_5c61.end());
	_binaryexprs_5bbf->insert( _binaryexprs_5bbf->end(), binaryexprss_5c62.begin(), binaryexprss_5c62.end());
}

void CondHasExprs_5bc3::operator()( const Packets_t& argdecls_5bc4, const Packets_t& membs_5bc6, const Packets_t& conditions_5bc8, Packets_t& argdecls_5bca, Packets_t& membs_5bcb, Packets_t& conditions_5bcc, Packets_t& argdecls_5bcd, Packets_t& membs_5bce, Packets_t& conditions_5bcf)
{
#ifdef PRINT_INFO
	printLog( "CondHasExprs_5bc3" );
#endif
	_argdecl_5bd0= &argdecls_5bca;
	_memb_5bd1= &membs_5bcb;
	_condition_5bd2= &conditions_5bcc;
	_argdecl_5bd3= &argdecls_5bcd;
	_memb_5bd4= &membs_5bce;
	_condition_5bd5= &conditions_5bcf;
	for( Packets_t::const_iterator itargdecl_5bd7= argdecls_5bc4.begin(), itmemb_5bde= membs_5bc6.begin(), itcondition_5be5= conditions_5bc8.begin(); itargdecl_5bd7!= argdecls_5bc4.end(), itmemb_5bde!= membs_5bc6.end(), itcondition_5be5!= conditions_5bc8.end(); ++itargdecl_5bd7, ++itmemb_5bde, ++itcondition_5be5)
	{
		bool isUnique= isInputUnique( *itargdecl_5bd7, *itmemb_5bde, *itcondition_5be5);
		if( !isUnique)
			continue;
		Packets_t oneargdecl_5bdb( 1, *itargdecl_5bd7);
		Packets_t onememb_5be2( 1, *itmemb_5bde);
		Packets_t onecondition_5be9( 1, *itcondition_5be5);
		executeOne( oneargdecl_5bdb, onememb_5be2, onecondition_5be9);
	}
}

void CondHasExprs_5bc3::executeOne( const Packets_t& argdecls_5bc4, const Packets_t& membs_5bc6, const Packets_t& conditions_5bc8)
{
	Packets_t argDeclBases_5bee;
	Packets_t localVars_5bf1;
	Packets_t userCodes_5bf4;
	HasExpr_5beb hasExpr_5beb;
	bool isMatchHasExpr_5beb= hasExpr_5beb( argdecls_5bc4, membs_5bc6, conditions_5bc8, argDeclBases_5bee, localVars_5bf1, userCodes_5bf4);
	_argdecl_5bd0->insert( _argdecl_5bd0->end(), argDeclBases_5bee.begin(), argDeclBases_5bee.end());
	_memb_5bd1->insert( _memb_5bd1->end(), localVars_5bf1.begin(), localVars_5bf1.end());
	_condition_5bd2->insert( _condition_5bd2->end(), userCodes_5bf4.begin(), userCodes_5bf4.end());
	if( isMatchHasExpr_5beb)
		return;
	Packets_t argDeclBases_5c27;
	Packets_t localVars_5c2a;
	Packets_t userCodes_5c2d;
	Otherwise_5c24 otherwise_5c24;
	bool isMatchOtherwise_5c24= otherwise_5c24( argdecls_5bc4, membs_5bc6, conditions_5bc8, argDeclBases_5c27, localVars_5c2a, userCodes_5c2d);
	_argdecl_5bd3->insert( _argdecl_5bd3->end(), argDeclBases_5c27.begin(), argDeclBases_5c27.end());
	_memb_5bd4->insert( _memb_5bd4->end(), localVars_5c2a.begin(), localVars_5c2a.end());
	_condition_5bd5->insert( _condition_5bd5->end(), userCodes_5c2d.begin(), userCodes_5c2d.end());
	if( isMatchOtherwise_5c24)
		return;
}

bool CondHasExprs_5bc3::isInputUnique( const Udm::Object& argdecl_5bd8, const Udm::Object& memb_5bdf, const Udm::Object& condition_5be6)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itargdecl_5bda= _argdecl_5bd6.begin(), itmemb_5be1= _memb_5bdd.begin(), itcondition_5be8= _condition_5be4.begin(); itargdecl_5bda!= _argdecl_5bd6.end(), itmemb_5be1!= _memb_5bdd.end(), itcondition_5be8!= _condition_5be4.end(); ++itargdecl_5bda, ++itmemb_5be1, ++itcondition_5be8)
	{
		if( ( *itargdecl_5bda== argdecl_5bd8)&& ( *itmemb_5be1== memb_5bdf)&& ( *itcondition_5be8== condition_5be6))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argdecl_5bd6.push_back( argdecl_5bd8);
		_memb_5bdd.push_back( memb_5bdf);
		_condition_5be4.push_back( condition_5be6);
	}
	return isUnique;
}

bool HasExpr_5beb::operator()( const Packets_t& argDeclBases_5bec, const Packets_t& localVars_5bef, const Packets_t& userCodes_5bf2, Packets_t& argDeclBases_5bee, Packets_t& localVars_5bf1, Packets_t& userCodes_5bf4)
{
#ifdef PRINT_INFO
	printLog( "HasExpr_5beb" );
#endif
	_argDeclBase_5bf5= &argDeclBases_5bee;
	_localVar_5bf6= &localVars_5bf1;
	_userCode_5bf7= &userCodes_5bf4;
	processInputPackets( argDeclBases_5bec, localVars_5bef, userCodes_5bf2);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasExpr_5beb::isInputUnique( const Udm::Object& argDeclBase_5bfc, const Udm::Object& localVar_5c05, const Udm::Object& userCode_5c0e)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_5bfe= _argDeclBase_5bf8.begin(), itLocalVar_5c07= _localVar_5c01.begin(), itUserCode_5c10= _userCode_5c0a.begin(); itArgDeclBase_5bfe!= _argDeclBase_5bf8.end(), itLocalVar_5c07!= _localVar_5c01.end(), itUserCode_5c10!= _userCode_5c0a.end(); ++itArgDeclBase_5bfe, ++itLocalVar_5c07, ++itUserCode_5c10)
	{
		if( ( *itArgDeclBase_5bfe== argDeclBase_5bfc)&& ( *itLocalVar_5c07== localVar_5c05)&& ( *itUserCode_5c10== userCode_5c0e))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_5bf8.push_back( argDeclBase_5bfc);
		_localVar_5c01.push_back( localVar_5c05);
		_userCode_5c0a.push_back( userCode_5c0e);
	}
	return isUnique;
}

bool HasExpr_5beb::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void HasExpr_5beb::processInputPackets( const Packets_t& argDeclBases_5bec, const Packets_t& localVars_5bef, const Packets_t& userCodes_5bf2)
{
	for( Packets_t::const_iterator itArgDeclBase_5bf9= argDeclBases_5bec.begin(), itLocalVar_5c02= localVars_5bef.begin(), itUserCode_5c0b= userCodes_5bf2.begin(); itArgDeclBase_5bf9!= argDeclBases_5bec.end(), itLocalVar_5c02!= localVars_5bef.end(), itUserCode_5c0b!= userCodes_5bf2.end(); ++itArgDeclBase_5bf9, ++itLocalVar_5c02, ++itUserCode_5c0b)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_5bf9, *itLocalVar_5c02, *itUserCode_5c0b);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_5bf9, *itLocalVar_5c02, *itUserCode_5c0b);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_5c1a, currMatch.localVar_5c1b, currMatch.userCode_5c1c);
	}
}

bool HasExpr_5beb::patternMatcher( const Udm::Object& argDeclBase_5bfa, const Udm::Object& localVar_5c03, const Udm::Object& userCode_5c0c)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_5bfa.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_5bff= SFC::ArgDeclBase::Cast( argDeclBase_5bfa);
		if( false== Uml::IsDerivedFrom( localVar_5c03.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_5c08= SFC::LocalVar::Cast( localVar_5c03);
		if( false== Uml::IsDerivedFrom( userCode_5c0c.type(), SFC::UserCode::meta))
			continue;
		SFC::UserCode userCode_5c11= SFC::UserCode::Cast( userCode_5c0c);
		set< SFC::Exprs> exprss_5c13= userCode_5c11.Exprs_kind_children();
		for( set< SFC::Exprs>::const_iterator itExprs_5c14= exprss_5c13.begin(); itExprs_5c14!= exprss_5c13.end(); ++itExprs_5c14)
		{
			SFC::Exprs currExprs_5c15= *itExprs_5c14;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_5c19;
			if( !isValidBound(boundObjs_5c19, argDeclBase_5bff, true))
				continue;
			currMatch.argDeclBase_5c1a= argDeclBase_5bff;
			if( !isValidBound(boundObjs_5c19, localVar_5c08, true))
				continue;
			currMatch.localVar_5c1b= localVar_5c08;
			if( !isValidBound(boundObjs_5c19, userCode_5c11, true))
				continue;
			currMatch.userCode_5c1c= userCode_5c11;
			if( !isValidBound(boundObjs_5c19, currExprs_5c15, false))
				continue;
			currMatch.exprs_5c1d= currExprs_5c15;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void HasExpr_5beb::outputAppender( const SFC::ArgDeclBase& argDeclBase_5c1e, const SFC::LocalVar& localVar_5c20, const SFC::UserCode& userCode_5c22)
{
	_argDeclBase_5bf5->push_back( argDeclBase_5c1e);
	_localVar_5bf6->push_back( localVar_5c20);
	_userCode_5bf7->push_back( userCode_5c22);
}

bool Otherwise_5c24::operator()( const Packets_t& argDeclBases_5c25, const Packets_t& localVars_5c28, const Packets_t& userCodes_5c2b, Packets_t& argDeclBases_5c27, Packets_t& localVars_5c2a, Packets_t& userCodes_5c2d)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_5c24" );
#endif
	_argDeclBase_5c2e= &argDeclBases_5c27;
	_localVar_5c2f= &localVars_5c2a;
	_userCode_5c30= &userCodes_5c2d;
	processInputPackets( argDeclBases_5c25, localVars_5c28, userCodes_5c2b);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_5c24::isInputUnique( const Udm::Object& argDeclBase_5c35, const Udm::Object& localVar_5c3e, const Udm::Object& userCode_5c47)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_5c37= _argDeclBase_5c31.begin(), itLocalVar_5c40= _localVar_5c3a.begin(), itUserCode_5c49= _userCode_5c43.begin(); itArgDeclBase_5c37!= _argDeclBase_5c31.end(), itLocalVar_5c40!= _localVar_5c3a.end(), itUserCode_5c49!= _userCode_5c43.end(); ++itArgDeclBase_5c37, ++itLocalVar_5c40, ++itUserCode_5c49)
	{
		if( ( *itArgDeclBase_5c37== argDeclBase_5c35)&& ( *itLocalVar_5c40== localVar_5c3e)&& ( *itUserCode_5c49== userCode_5c47))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_5c31.push_back( argDeclBase_5c35);
		_localVar_5c3a.push_back( localVar_5c3e);
		_userCode_5c43.push_back( userCode_5c47);
	}
	return isUnique;
}

bool Otherwise_5c24::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_5c24::processInputPackets( const Packets_t& argDeclBases_5c25, const Packets_t& localVars_5c28, const Packets_t& userCodes_5c2b)
{
	for( Packets_t::const_iterator itArgDeclBase_5c32= argDeclBases_5c25.begin(), itLocalVar_5c3b= localVars_5c28.begin(), itUserCode_5c44= userCodes_5c2b.begin(); itArgDeclBase_5c32!= argDeclBases_5c25.end(), itLocalVar_5c3b!= localVars_5c28.end(), itUserCode_5c44!= userCodes_5c2b.end(); ++itArgDeclBase_5c32, ++itLocalVar_5c3b, ++itUserCode_5c44)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_5c32, *itLocalVar_5c3b, *itUserCode_5c44);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_5c32, *itLocalVar_5c3b, *itUserCode_5c44);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_5c50, currMatch.localVar_5c51, currMatch.userCode_5c52);
	}
}

bool Otherwise_5c24::patternMatcher( const Udm::Object& argDeclBase_5c33, const Udm::Object& localVar_5c3c, const Udm::Object& userCode_5c45)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_5c33.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_5c38= SFC::ArgDeclBase::Cast( argDeclBase_5c33);
		if( false== Uml::IsDerivedFrom( localVar_5c3c.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_5c41= SFC::LocalVar::Cast( localVar_5c3c);
		if( false== Uml::IsDerivedFrom( userCode_5c45.type(), SFC::UserCode::meta))
			continue;
		SFC::UserCode userCode_5c4a= SFC::UserCode::Cast( userCode_5c45);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5c4f;
		if( !isValidBound(boundObjs_5c4f, argDeclBase_5c38, true))
			continue;
		currMatch.argDeclBase_5c50= argDeclBase_5c38;
		if( !isValidBound(boundObjs_5c4f, localVar_5c41, true))
			continue;
		currMatch.localVar_5c51= localVar_5c41;
		if( !isValidBound(boundObjs_5c4f, userCode_5c4a, true))
			continue;
		currMatch.userCode_5c52= userCode_5c4a;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_5c24::outputAppender( const SFC::ArgDeclBase& argDeclBase_5c53, const SFC::LocalVar& localVar_5c55, const SFC::UserCode& userCode_5c57)
{
	_argDeclBase_5c2e->push_back( argDeclBase_5c53);
	_localVar_5c2f->push_back( localVar_5c55);
	_userCode_5c30->push_back( userCode_5c57);
}

void GetLastBinaryExprs_5c59::operator()( const Packets_t& argdecls_5c5a, const Packets_t& membs_5c5c, const Packets_t& conditions_5c5e, Packets_t& argdecls_5c60, Packets_t& membs_5c61, Packets_t& binaryexprss_5c62)
{
#ifdef PRINT_INFO
	printLog( "GetLastBinaryExprs_5c59" );
#endif
	_argdecl_5c63= &argdecls_5c60;
	_memb_5c64= &membs_5c61;
	_binaryexprs_5c65= &binaryexprss_5c62;
	if( ( !argdecls_5c5a.empty())&& ( !membs_5c5c.empty())&& ( !conditions_5c5e.empty()))
		callgetFirstBinaryExprs_5d35( argdecls_5c5a, membs_5c5c, conditions_5c5e);
}

void GetLastBinaryExprs_5c59::callgetFirstBinaryExprs_5d35( const Packets_t& argDeclBases_5c67, const Packets_t& localVars_5c6a, const Packets_t& userCodes_5c6d)
{
	Packets_t argDeclBases_5c69;
	Packets_t localVars_5c6c;
	Packets_t binaryExprss_5c6f;
	GetFirstBinaryExprs_5c66 getFirstBinaryExprs_5c66;
	getFirstBinaryExprs_5c66( argDeclBases_5c67, localVars_5c6a, userCodes_5c6d, argDeclBases_5c69, localVars_5c6c, binaryExprss_5c6f);
	if( ( !argDeclBases_5c69.empty())&& ( !localVars_5c6c.empty())&& ( !binaryExprss_5c6f.empty()))
		callgetNextBinaryExprs_5d39( argDeclBases_5c69, localVars_5c6c, binaryExprss_5c6f);
}

void GetLastBinaryExprs_5c59::callgetNextBinaryExprs_5d39( const Packets_t& argdecls_5ca0, const Packets_t& membs_5ca2, const Packets_t& binaryexprss_5ca4)
{
	Packets_t argdecls_5ca6;
	Packets_t membs_5ca7;
	Packets_t binaryexprss_5ca8;
	Packets_t argdecls_5ca9;
	Packets_t membs_5caa;
	Packets_t binaryexprss_5cab;
	GetNextBinaryExprs_5c9f getNextBinaryExprs_5c9f;
	getNextBinaryExprs_5c9f( argdecls_5ca0, membs_5ca2, binaryexprss_5ca4, argdecls_5ca6, membs_5ca7, binaryexprss_5ca8, argdecls_5ca9, membs_5caa, binaryexprss_5cab);
	if( ( !argdecls_5ca6.empty())&& ( !membs_5ca7.empty())&& ( !binaryexprss_5ca8.empty()))
		callgetNextBinaryExprs_5d39( argdecls_5ca6, membs_5ca7, binaryexprss_5ca8);
	_argdecl_5c63->insert( _argdecl_5c63->end(), argdecls_5ca9.begin(), argdecls_5ca9.end());
	_memb_5c64->insert( _memb_5c64->end(), membs_5caa.begin(), membs_5caa.end());
	_binaryexprs_5c65->insert( _binaryexprs_5c65->end(), binaryexprss_5cab.begin(), binaryexprss_5cab.end());
}

void GetFirstBinaryExprs_5c66::operator()( const Packets_t& argDeclBases_5c67, const Packets_t& localVars_5c6a, const Packets_t& userCodes_5c6d, Packets_t& argDeclBases_5c69, Packets_t& localVars_5c6c, Packets_t& binaryExprss_5c6f)
{
#ifdef PRINT_INFO
	printLog( "GetFirstBinaryExprs_5c66" );
#endif
	RTTGenerator::Instance()->generateRule(4789, "getFirstBinaryExprs");
	_argDeclBase_5c70= &argDeclBases_5c69;
	_localVar_5c71= &localVars_5c6c;
	_binaryExprs_5c72= &binaryExprss_5c6f;
	processInputPackets( argDeclBases_5c67, localVars_5c6a, userCodes_5c6d);
}

bool GetFirstBinaryExprs_5c66::isInputUnique( const Udm::Object& argDeclBase_5c77, const Udm::Object& localVar_5c80, const Udm::Object& userCode_5c89)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_5c79= _argDeclBase_5c73.begin(), itLocalVar_5c82= _localVar_5c7c.begin(), itUserCode_5c8b= _userCode_5c85.begin(); itArgDeclBase_5c79!= _argDeclBase_5c73.end(), itLocalVar_5c82!= _localVar_5c7c.end(), itUserCode_5c8b!= _userCode_5c85.end(); ++itArgDeclBase_5c79, ++itLocalVar_5c82, ++itUserCode_5c8b)
	{
		if( ( *itArgDeclBase_5c79== argDeclBase_5c77)&& ( *itLocalVar_5c82== localVar_5c80)&& ( *itUserCode_5c8b== userCode_5c89))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_5c73.push_back( argDeclBase_5c77);
		_localVar_5c7c.push_back( localVar_5c80);
		_userCode_5c85.push_back( userCode_5c89);
	}
	return isUnique;
}

bool GetFirstBinaryExprs_5c66::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void GetFirstBinaryExprs_5c66::processInputPackets( const Packets_t& argDeclBases_5c67, const Packets_t& localVars_5c6a, const Packets_t& userCodes_5c6d)
{
	for( Packets_t::const_iterator itArgDeclBase_5c74= argDeclBases_5c67.begin(), itLocalVar_5c7d= localVars_5c6a.begin(), itUserCode_5c86= userCodes_5c6d.begin(); itArgDeclBase_5c74!= argDeclBases_5c67.end(), itLocalVar_5c7d!= localVars_5c6a.end(), itUserCode_5c86!= userCodes_5c6d.end(); ++itArgDeclBase_5c74, ++itLocalVar_5c7d, ++itUserCode_5c86)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_5c74, *itLocalVar_5c7d, *itUserCode_5c86);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_5c74, *itLocalVar_5c7d, *itUserCode_5c86);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool GetFirstBinaryExprs_5c66::patternMatcher( const Udm::Object& argDeclBase_5c75, const Udm::Object& localVar_5c7e, const Udm::Object& userCode_5c87)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_5c75.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_5c7a= SFC::ArgDeclBase::Cast( argDeclBase_5c75);
		if( false== Uml::IsDerivedFrom( localVar_5c7e.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_5c83= SFC::LocalVar::Cast( localVar_5c7e);
		if( false== Uml::IsDerivedFrom( userCode_5c87.type(), SFC::UserCode::meta))
			continue;
		SFC::UserCode userCode_5c8c= SFC::UserCode::Cast( userCode_5c87);
		set< SFC::BinaryExprs> binaryExprss_5c8e= userCode_5c8c.BinaryExprs_kind_children();
		for( set< SFC::BinaryExprs>::const_iterator itbinaryExprs_5c8f= binaryExprss_5c8e.begin(); itbinaryExprs_5c8f!= binaryExprss_5c8e.end(); ++itbinaryExprs_5c8f)
		{
			SFC::BinaryExprs currbinaryExprs_5c90= *itbinaryExprs_5c8f;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_5c94;
			if( !isValidBound(boundObjs_5c94, argDeclBase_5c7a, true))
				continue;
			currMatch.argDeclBase_5c95= argDeclBase_5c7a;
			if( !isValidBound(boundObjs_5c94, localVar_5c83, true))
				continue;
			currMatch.localVar_5c96= localVar_5c83;
			if( !isValidBound(boundObjs_5c94, userCode_5c8c, true))
				continue;
			currMatch.userCode_5c97= userCode_5c8c;
			if( !isValidBound(boundObjs_5c94, currbinaryExprs_5c90, false))
				continue;
			currMatch.binaryExprs_5c98= currbinaryExprs_5c90;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void GetFirstBinaryExprs_5c66::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_5c95, currMatch.localVar_5c96, currMatch.binaryExprs_5c98);
	}
}

void GetFirstBinaryExprs_5c66::outputAppender( const SFC::ArgDeclBase& argDeclBase_5c99, const SFC::LocalVar& localVar_5c9b, const SFC::BinaryExprs& binaryExprs_5c9d)
{
	_argDeclBase_5c70->push_back( argDeclBase_5c99);
	_localVar_5c71->push_back( localVar_5c9b);
	_binaryExprs_5c72->push_back( binaryExprs_5c9d);
}

void GetNextBinaryExprs_5c9f::operator()( const Packets_t& argdecls_5ca0, const Packets_t& membs_5ca2, const Packets_t& binaryexprss_5ca4, Packets_t& argdecls_5ca6, Packets_t& membs_5ca7, Packets_t& binaryexprss_5ca8, Packets_t& argdecls_5ca9, Packets_t& membs_5caa, Packets_t& binaryexprss_5cab)
{
#ifdef PRINT_INFO
	printLog( "GetNextBinaryExprs_5c9f" );
#endif
	_argdecl_5cac= &argdecls_5ca6;
	_memb_5cad= &membs_5ca7;
	_binaryexprs_5cae= &binaryexprss_5ca8;
	_argdecl_5caf= &argdecls_5ca9;
	_memb_5cb0= &membs_5caa;
	_binaryexprs_5cb1= &binaryexprss_5cab;
	for( Packets_t::const_iterator itargdecl_5cb3= argdecls_5ca0.begin(), itmemb_5cba= membs_5ca2.begin(), itbinaryexprs_5cc1= binaryexprss_5ca4.begin(); itargdecl_5cb3!= argdecls_5ca0.end(), itmemb_5cba!= membs_5ca2.end(), itbinaryexprs_5cc1!= binaryexprss_5ca4.end(); ++itargdecl_5cb3, ++itmemb_5cba, ++itbinaryexprs_5cc1)
	{
		bool isUnique= isInputUnique( *itargdecl_5cb3, *itmemb_5cba, *itbinaryexprs_5cc1);
		if( !isUnique)
			continue;
		Packets_t oneargdecl_5cb7( 1, *itargdecl_5cb3);
		Packets_t onememb_5cbe( 1, *itmemb_5cba);
		Packets_t onebinaryexprs_5cc5( 1, *itbinaryexprs_5cc1);
		executeOne( oneargdecl_5cb7, onememb_5cbe, onebinaryexprs_5cc5);
	}
}

void GetNextBinaryExprs_5c9f::executeOne( const Packets_t& argdecls_5ca0, const Packets_t& membs_5ca2, const Packets_t& binaryexprss_5ca4)
{
	Packets_t argDeclBases_5cca;
	Packets_t localVars_5ccd;
	Packets_t rightBinaryExprss_5cd0;
	HasExpr_5cc7 hasExpr_5cc7;
	bool isMatchHasExpr_5cc7= hasExpr_5cc7( argdecls_5ca0, membs_5ca2, binaryexprss_5ca4, argDeclBases_5cca, localVars_5ccd, rightBinaryExprss_5cd0);
	_argdecl_5cac->insert( _argdecl_5cac->end(), argDeclBases_5cca.begin(), argDeclBases_5cca.end());
	_memb_5cad->insert( _memb_5cad->end(), localVars_5ccd.begin(), localVars_5ccd.end());
	_binaryexprs_5cae->insert( _binaryexprs_5cae->end(), rightBinaryExprss_5cd0.begin(), rightBinaryExprss_5cd0.end());
	if( isMatchHasExpr_5cc7)
		return;
	Packets_t argDeclBases_5d03;
	Packets_t localVars_5d06;
	Packets_t binaryExprss_5d09;
	Otherwise_5d00 otherwise_5d00;
	bool isMatchOtherwise_5d00= otherwise_5d00( argdecls_5ca0, membs_5ca2, binaryexprss_5ca4, argDeclBases_5d03, localVars_5d06, binaryExprss_5d09);
	_argdecl_5caf->insert( _argdecl_5caf->end(), argDeclBases_5d03.begin(), argDeclBases_5d03.end());
	_memb_5cb0->insert( _memb_5cb0->end(), localVars_5d06.begin(), localVars_5d06.end());
	_binaryexprs_5cb1->insert( _binaryexprs_5cb1->end(), binaryExprss_5d09.begin(), binaryExprss_5d09.end());
	if( isMatchOtherwise_5d00)
		return;
}

bool GetNextBinaryExprs_5c9f::isInputUnique( const Udm::Object& argdecl_5cb4, const Udm::Object& memb_5cbb, const Udm::Object& binaryexprs_5cc2)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itargdecl_5cb6= _argdecl_5cb2.begin(), itmemb_5cbd= _memb_5cb9.begin(), itbinaryexprs_5cc4= _binaryexprs_5cc0.begin(); itargdecl_5cb6!= _argdecl_5cb2.end(), itmemb_5cbd!= _memb_5cb9.end(), itbinaryexprs_5cc4!= _binaryexprs_5cc0.end(); ++itargdecl_5cb6, ++itmemb_5cbd, ++itbinaryexprs_5cc4)
	{
		if( ( *itargdecl_5cb6== argdecl_5cb4)&& ( *itmemb_5cbd== memb_5cbb)&& ( *itbinaryexprs_5cc4== binaryexprs_5cc2))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argdecl_5cb2.push_back( argdecl_5cb4);
		_memb_5cb9.push_back( memb_5cbb);
		_binaryexprs_5cc0.push_back( binaryexprs_5cc2);
	}
	return isUnique;
}

bool HasExpr_5cc7::operator()( const Packets_t& argDeclBases_5cc8, const Packets_t& localVars_5ccb, const Packets_t& binaryExprss_5cce, Packets_t& argDeclBases_5cca, Packets_t& localVars_5ccd, Packets_t& rightBinaryExprss_5cd0)
{
#ifdef PRINT_INFO
	printLog( "HasExpr_5cc7" );
#endif
	_argDeclBase_5cd1= &argDeclBases_5cca;
	_localVar_5cd2= &localVars_5ccd;
	_rightBinaryExprs_5cd3= &rightBinaryExprss_5cd0;
	processInputPackets( argDeclBases_5cc8, localVars_5ccb, binaryExprss_5cce);
	if( false== _matches.empty())
		return true;
	return false;
}

bool HasExpr_5cc7::isInputUnique( const Udm::Object& argDeclBase_5cd8, const Udm::Object& localVar_5ce1, const Udm::Object& binaryExprs_5cea)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_5cda= _argDeclBase_5cd4.begin(), itLocalVar_5ce3= _localVar_5cdd.begin(), itBinaryExprs_5cec= _binaryExprs_5ce6.begin(); itArgDeclBase_5cda!= _argDeclBase_5cd4.end(), itLocalVar_5ce3!= _localVar_5cdd.end(), itBinaryExprs_5cec!= _binaryExprs_5ce6.end(); ++itArgDeclBase_5cda, ++itLocalVar_5ce3, ++itBinaryExprs_5cec)
	{
		if( ( *itArgDeclBase_5cda== argDeclBase_5cd8)&& ( *itLocalVar_5ce3== localVar_5ce1)&& ( *itBinaryExprs_5cec== binaryExprs_5cea))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_5cd4.push_back( argDeclBase_5cd8);
		_localVar_5cdd.push_back( localVar_5ce1);
		_binaryExprs_5ce6.push_back( binaryExprs_5cea);
	}
	return isUnique;
}

bool HasExpr_5cc7::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void HasExpr_5cc7::processInputPackets( const Packets_t& argDeclBases_5cc8, const Packets_t& localVars_5ccb, const Packets_t& binaryExprss_5cce)
{
	for( Packets_t::const_iterator itArgDeclBase_5cd5= argDeclBases_5cc8.begin(), itLocalVar_5cde= localVars_5ccb.begin(), itBinaryExprs_5ce7= binaryExprss_5cce.begin(); itArgDeclBase_5cd5!= argDeclBases_5cc8.end(), itLocalVar_5cde!= localVars_5ccb.end(), itBinaryExprs_5ce7!= binaryExprss_5cce.end(); ++itArgDeclBase_5cd5, ++itLocalVar_5cde, ++itBinaryExprs_5ce7)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_5cd5, *itLocalVar_5cde, *itBinaryExprs_5ce7);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_5cd5, *itLocalVar_5cde, *itBinaryExprs_5ce7);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_5cf6, currMatch.localVar_5cf7, currMatch.rightBinaryExprs_5cf9);
	}
}

bool HasExpr_5cc7::patternMatcher( const Udm::Object& argDeclBase_5cd6, const Udm::Object& localVar_5cdf, const Udm::Object& binaryExprs_5ce8)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_5cd6.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_5cdb= SFC::ArgDeclBase::Cast( argDeclBase_5cd6);
		if( false== Uml::IsDerivedFrom( localVar_5cdf.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_5ce4= SFC::LocalVar::Cast( localVar_5cdf);
		if( false== Uml::IsDerivedFrom( binaryExprs_5ce8.type(), SFC::BinaryExprs::meta))
			continue;
		SFC::BinaryExprs binaryExprs_5ced= SFC::BinaryExprs::Cast( binaryExprs_5ce8);
		set< SFC::BinaryExprs> rightBinaryExprss_5cef= binaryExprs_5ced.BinaryExprs_kind_children();
		for( set< SFC::BinaryExprs>::const_iterator itRightBinaryExprs_5cf0= rightBinaryExprss_5cef.begin(); itRightBinaryExprs_5cf0!= rightBinaryExprss_5cef.end(); ++itRightBinaryExprs_5cf0)
		{
			SFC::BinaryExprs currRightBinaryExprs_5cf1= *itRightBinaryExprs_5cf0;
			Match currMatch;
			set< pair<int, Udm::Object> > boundObjs_5cf5;
			if( !isValidBound(boundObjs_5cf5, argDeclBase_5cdb, true))
				continue;
			currMatch.argDeclBase_5cf6= argDeclBase_5cdb;
			if( !isValidBound(boundObjs_5cf5, localVar_5ce4, true))
				continue;
			currMatch.localVar_5cf7= localVar_5ce4;
			if( !isValidBound(boundObjs_5cf5, binaryExprs_5ced, true))
				continue;
			currMatch.binaryExprs_5cf8= binaryExprs_5ced;
			if( !isValidBound(boundObjs_5cf5, currRightBinaryExprs_5cf1, false))
				continue;
			currMatch.rightBinaryExprs_5cf9= currRightBinaryExprs_5cf1;
			_matches.push_back( currMatch);
		}
	}
	return !_matches.empty();
}

void HasExpr_5cc7::outputAppender( const SFC::ArgDeclBase& argDeclBase_5cfa, const SFC::LocalVar& localVar_5cfc, const SFC::BinaryExprs& rightBinaryExprs_5cfe)
{
	_argDeclBase_5cd1->push_back( argDeclBase_5cfa);
	_localVar_5cd2->push_back( localVar_5cfc);
	_rightBinaryExprs_5cd3->push_back( rightBinaryExprs_5cfe);
}

bool Otherwise_5d00::operator()( const Packets_t& argDeclBases_5d01, const Packets_t& localVars_5d04, const Packets_t& binaryExprss_5d07, Packets_t& argDeclBases_5d03, Packets_t& localVars_5d06, Packets_t& binaryExprss_5d09)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_5d00" );
#endif
	_argDeclBase_5d0a= &argDeclBases_5d03;
	_localVar_5d0b= &localVars_5d06;
	_binaryExprs_5d0c= &binaryExprss_5d09;
	processInputPackets( argDeclBases_5d01, localVars_5d04, binaryExprss_5d07);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_5d00::isInputUnique( const Udm::Object& argDeclBase_5d11, const Udm::Object& localVar_5d1a, const Udm::Object& binaryExprs_5d23)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_5d13= _argDeclBase_5d0d.begin(), itLocalVar_5d1c= _localVar_5d16.begin(), itBinaryExprs_5d25= _binaryExprs_5d1f.begin(); itArgDeclBase_5d13!= _argDeclBase_5d0d.end(), itLocalVar_5d1c!= _localVar_5d16.end(), itBinaryExprs_5d25!= _binaryExprs_5d1f.end(); ++itArgDeclBase_5d13, ++itLocalVar_5d1c, ++itBinaryExprs_5d25)
	{
		if( ( *itArgDeclBase_5d13== argDeclBase_5d11)&& ( *itLocalVar_5d1c== localVar_5d1a)&& ( *itBinaryExprs_5d25== binaryExprs_5d23))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_5d0d.push_back( argDeclBase_5d11);
		_localVar_5d16.push_back( localVar_5d1a);
		_binaryExprs_5d1f.push_back( binaryExprs_5d23);
	}
	return isUnique;
}

bool Otherwise_5d00::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_5d00::processInputPackets( const Packets_t& argDeclBases_5d01, const Packets_t& localVars_5d04, const Packets_t& binaryExprss_5d07)
{
	for( Packets_t::const_iterator itArgDeclBase_5d0e= argDeclBases_5d01.begin(), itLocalVar_5d17= localVars_5d04.begin(), itBinaryExprs_5d20= binaryExprss_5d07.begin(); itArgDeclBase_5d0e!= argDeclBases_5d01.end(), itLocalVar_5d17!= localVars_5d04.end(), itBinaryExprs_5d20!= binaryExprss_5d07.end(); ++itArgDeclBase_5d0e, ++itLocalVar_5d17, ++itBinaryExprs_5d20)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_5d0e, *itLocalVar_5d17, *itBinaryExprs_5d20);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_5d0e, *itLocalVar_5d17, *itBinaryExprs_5d20);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_5d2c, currMatch.localVar_5d2d, currMatch.binaryExprs_5d2e);
	}
}

bool Otherwise_5d00::patternMatcher( const Udm::Object& argDeclBase_5d0f, const Udm::Object& localVar_5d18, const Udm::Object& binaryExprs_5d21)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_5d0f.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_5d14= SFC::ArgDeclBase::Cast( argDeclBase_5d0f);
		if( false== Uml::IsDerivedFrom( localVar_5d18.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_5d1d= SFC::LocalVar::Cast( localVar_5d18);
		if( false== Uml::IsDerivedFrom( binaryExprs_5d21.type(), SFC::BinaryExprs::meta))
			continue;
		SFC::BinaryExprs binaryExprs_5d26= SFC::BinaryExprs::Cast( binaryExprs_5d21);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5d2b;
		if( !isValidBound(boundObjs_5d2b, argDeclBase_5d14, true))
			continue;
		currMatch.argDeclBase_5d2c= argDeclBase_5d14;
		if( !isValidBound(boundObjs_5d2b, localVar_5d1d, true))
			continue;
		currMatch.localVar_5d2d= localVar_5d1d;
		if( !isValidBound(boundObjs_5d2b, binaryExprs_5d26, true))
			continue;
		currMatch.binaryExprs_5d2e= binaryExprs_5d26;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_5d00::outputAppender( const SFC::ArgDeclBase& argDeclBase_5d2f, const SFC::LocalVar& localVar_5d31, const SFC::BinaryExprs& binaryExprs_5d33)
{
	_argDeclBase_5d0a->push_back( argDeclBase_5d2f);
	_localVar_5d0b->push_back( localVar_5d31);
	_binaryExprs_5d0c->push_back( binaryExprs_5d33);
}

void CreateFirstBinaryExprs_5d45::operator()( const Packets_t& argDeclBases_5d46, const Packets_t& localVars_5d48, const Packets_t& userCodes_5d4a)
{
#ifdef PRINT_INFO
	printLog( "CreateFirstBinaryExprs_5d45" );
#endif
	RTTGenerator::Instance()->generateRule(4815, "createFirstBinaryExprs");
	processInputPackets( argDeclBases_5d46, localVars_5d48, userCodes_5d4a);
}

bool CreateFirstBinaryExprs_5d45::isInputUnique( const Udm::Object& argDeclBase_5d50, const Udm::Object& localVar_5d59, const Udm::Object& userCode_5d62)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_5d52= _argDeclBase_5d4c.begin(), itLocalVar_5d5b= _localVar_5d55.begin(), itUserCode_5d64= _userCode_5d5e.begin(); itArgDeclBase_5d52!= _argDeclBase_5d4c.end(), itLocalVar_5d5b!= _localVar_5d55.end(), itUserCode_5d64!= _userCode_5d5e.end(); ++itArgDeclBase_5d52, ++itLocalVar_5d5b, ++itUserCode_5d64)
	{
		if( ( *itArgDeclBase_5d52== argDeclBase_5d50)&& ( *itLocalVar_5d5b== localVar_5d59)&& ( *itUserCode_5d64== userCode_5d62))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_5d4c.push_back( argDeclBase_5d50);
		_localVar_5d55.push_back( localVar_5d59);
		_userCode_5d5e.push_back( userCode_5d62);
	}
	return isUnique;
}

bool CreateFirstBinaryExprs_5d45::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateFirstBinaryExprs_5d45::processInputPackets( const Packets_t& argDeclBases_5d46, const Packets_t& localVars_5d48, const Packets_t& userCodes_5d4a)
{
	for( Packets_t::const_iterator itArgDeclBase_5d4d= argDeclBases_5d46.begin(), itLocalVar_5d56= localVars_5d48.begin(), itUserCode_5d5f= userCodes_5d4a.begin(); itArgDeclBase_5d4d!= argDeclBases_5d46.end(), itLocalVar_5d56!= localVars_5d48.end(), itUserCode_5d5f!= userCodes_5d4a.end(); ++itArgDeclBase_5d4d, ++itLocalVar_5d56, ++itUserCode_5d5f)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_5d4d, *itLocalVar_5d56, *itUserCode_5d5f);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_5d4d, *itLocalVar_5d56, *itUserCode_5d5f);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateFirstBinaryExprs_5d45::patternMatcher( const Udm::Object& argDeclBase_5d4e, const Udm::Object& localVar_5d57, const Udm::Object& userCode_5d60)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_5d4e.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_5d53= SFC::ArgDeclBase::Cast( argDeclBase_5d4e);
		if( false== Uml::IsDerivedFrom( localVar_5d57.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_5d5c= SFC::LocalVar::Cast( localVar_5d57);
		if( false== Uml::IsDerivedFrom( userCode_5d60.type(), SFC::UserCode::meta))
			continue;
		SFC::UserCode userCode_5d65= SFC::UserCode::Cast( userCode_5d60);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5d6a;
		if( !isValidBound(boundObjs_5d6a, argDeclBase_5d53, true))
			continue;
		currMatch.argDeclBase_5d6b= argDeclBase_5d53;
		if( !isValidBound(boundObjs_5d6a, localVar_5d5c, true))
			continue;
		currMatch.localVar_5d6c= localVar_5d5c;
		if( !isValidBound(boundObjs_5d6a, userCode_5d65, true))
			continue;
		currMatch.userCode_5d6d= userCode_5d65;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateFirstBinaryExprs_5d45::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newOr_5d6e= SFC::BinaryExprs::Create( currMatch.userCode_5d6d, SFC::UserCode::meta_codeexpr);
		SFC::BinaryExprs newDot_5d6f= SFC::BinaryExprs::Create( newOr_5d6e, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_5d70= SFC::ArgDeclRef::Create( newDot_5d6f, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef1_5d71= SFC::ArgDeclRef::Create( newDot_5d6f, SFC::BinaryExprs::meta_leftexpr);
		newArgDeclRef2_5d70.argdecl()= currMatch.localVar_5d6c;
		newArgDeclRef1_5d71.argdecl()= currMatch.argDeclBase_5d6b;
	}
}

void CreateOnlyExprs_5d72::operator()( const Packets_t& argDeclBases_5d73, const Packets_t& localVars_5d75, const Packets_t& userCodes_5d77)
{
#ifdef PRINT_INFO
	printLog( "CreateOnlyExprs_5d72" );
#endif
	RTTGenerator::Instance()->generateRule(4829, "createOnlyExprs");
	processInputPackets( argDeclBases_5d73, localVars_5d75, userCodes_5d77);
}

bool CreateOnlyExprs_5d72::isInputUnique( const Udm::Object& argDeclBase_5d7d, const Udm::Object& localVar_5d86, const Udm::Object& userCode_5d8f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_5d7f= _argDeclBase_5d79.begin(), itLocalVar_5d88= _localVar_5d82.begin(), itUserCode_5d91= _userCode_5d8b.begin(); itArgDeclBase_5d7f!= _argDeclBase_5d79.end(), itLocalVar_5d88!= _localVar_5d82.end(), itUserCode_5d91!= _userCode_5d8b.end(); ++itArgDeclBase_5d7f, ++itLocalVar_5d88, ++itUserCode_5d91)
	{
		if( ( *itArgDeclBase_5d7f== argDeclBase_5d7d)&& ( *itLocalVar_5d88== localVar_5d86)&& ( *itUserCode_5d91== userCode_5d8f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_5d79.push_back( argDeclBase_5d7d);
		_localVar_5d82.push_back( localVar_5d86);
		_userCode_5d8b.push_back( userCode_5d8f);
	}
	return isUnique;
}

bool CreateOnlyExprs_5d72::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateOnlyExprs_5d72::processInputPackets( const Packets_t& argDeclBases_5d73, const Packets_t& localVars_5d75, const Packets_t& userCodes_5d77)
{
	for( Packets_t::const_iterator itArgDeclBase_5d7a= argDeclBases_5d73.begin(), itLocalVar_5d83= localVars_5d75.begin(), itUserCode_5d8c= userCodes_5d77.begin(); itArgDeclBase_5d7a!= argDeclBases_5d73.end(), itLocalVar_5d83!= localVars_5d75.end(), itUserCode_5d8c!= userCodes_5d77.end(); ++itArgDeclBase_5d7a, ++itLocalVar_5d83, ++itUserCode_5d8c)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_5d7a, *itLocalVar_5d83, *itUserCode_5d8c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_5d7a, *itLocalVar_5d83, *itUserCode_5d8c);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateOnlyExprs_5d72::patternMatcher( const Udm::Object& argDeclBase_5d7b, const Udm::Object& localVar_5d84, const Udm::Object& userCode_5d8d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_5d7b.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_5d80= SFC::ArgDeclBase::Cast( argDeclBase_5d7b);
		if( false== Uml::IsDerivedFrom( localVar_5d84.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_5d89= SFC::LocalVar::Cast( localVar_5d84);
		if( false== Uml::IsDerivedFrom( userCode_5d8d.type(), SFC::UserCode::meta))
			continue;
		SFC::UserCode userCode_5d92= SFC::UserCode::Cast( userCode_5d8d);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5d97;
		if( !isValidBound(boundObjs_5d97, argDeclBase_5d80, true))
			continue;
		currMatch.argDeclBase_5d98= argDeclBase_5d80;
		if( !isValidBound(boundObjs_5d97, localVar_5d89, true))
			continue;
		currMatch.localVar_5d99= localVar_5d89;
		if( !isValidBound(boundObjs_5d97, userCode_5d92, true))
			continue;
		currMatch.userCode_5d9a= userCode_5d92;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateOnlyExprs_5d72::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newDot_5d9b= SFC::BinaryExprs::Create( currMatch.userCode_5d9a, SFC::UserCode::meta_codeexpr);
		SFC::ArgDeclRef newArgDeclRef1_5d9c= SFC::ArgDeclRef::Create( newDot_5d9b, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_5d9d= SFC::ArgDeclRef::Create( newDot_5d9b, SFC::BinaryExprs::meta_rightexpr);
		newArgDeclRef1_5d9c.argdecl()= currMatch.argDeclBase_5d98;
		newArgDeclRef2_5d9d.argdecl()= currMatch.localVar_5d99;
	}
}

void TestMemberPos_5d9e::operator()( const Packets_t& argdecls_5d9f, const Packets_t& structs_5da1, const Packets_t& membs_5da3, const Packets_t& conditions_5da5, Packets_t& argdecls_5da7, Packets_t& structs_5da8, Packets_t& membs_5da9, Packets_t& conditions_5daa, Packets_t& argdecls_5dab, Packets_t& structs_5dac, Packets_t& membs_5dad, Packets_t& conditions_5dae)
{
#ifdef PRINT_INFO
	printLog( "TestMemberPos_5d9e" );
#endif
	_argdecl_5daf= &argdecls_5da7;
	_struct_5db0= &structs_5da8;
	_memb_5db1= &membs_5da9;
	_condition_5db2= &conditions_5daa;
	_argdecl_5db3= &argdecls_5dab;
	_struct_5db4= &structs_5dac;
	_memb_5db5= &membs_5dad;
	_condition_5db6= &conditions_5dae;
	for( Packets_t::const_iterator itargdecl_5db8= argdecls_5d9f.begin(), itstruct_5dbf= structs_5da1.begin(), itmemb_5dc6= membs_5da3.begin(), itcondition_5dcd= conditions_5da5.begin(); itargdecl_5db8!= argdecls_5d9f.end(), itstruct_5dbf!= structs_5da1.end(), itmemb_5dc6!= membs_5da3.end(), itcondition_5dcd!= conditions_5da5.end(); ++itargdecl_5db8, ++itstruct_5dbf, ++itmemb_5dc6, ++itcondition_5dcd)
	{
		bool isUnique= isInputUnique( *itargdecl_5db8, *itstruct_5dbf, *itmemb_5dc6, *itcondition_5dcd);
		if( !isUnique)
			continue;
		Packets_t oneargdecl_5dbc( 1, *itargdecl_5db8);
		Packets_t onestruct_5dc3( 1, *itstruct_5dbf);
		Packets_t onememb_5dca( 1, *itmemb_5dc6);
		Packets_t onecondition_5dd1( 1, *itcondition_5dcd);
		executeOne( oneargdecl_5dbc, onestruct_5dc3, onememb_5dca, onecondition_5dd1);
	}
}

void TestMemberPos_5d9e::executeOne( const Packets_t& argdecls_5d9f, const Packets_t& structs_5da1, const Packets_t& membs_5da3, const Packets_t& conditions_5da5)
{
	Packets_t argDeclBases_5dd6;
	Packets_t structs_5dd9;
	Packets_t localVars_5ddc;
	Packets_t userCodes_5ddf;
	NotLastMember_5dd3 notLastMember_5dd3;
	bool isMatchNotLastMember_5dd3= notLastMember_5dd3( argdecls_5d9f, structs_5da1, membs_5da3, conditions_5da5, argDeclBases_5dd6, structs_5dd9, localVars_5ddc, userCodes_5ddf);
	_argdecl_5daf->insert( _argdecl_5daf->end(), argDeclBases_5dd6.begin(), argDeclBases_5dd6.end());
	_struct_5db0->insert( _struct_5db0->end(), structs_5dd9.begin(), structs_5dd9.end());
	_memb_5db1->insert( _memb_5db1->end(), localVars_5ddc.begin(), localVars_5ddc.end());
	_condition_5db2->insert( _condition_5db2->end(), userCodes_5ddf.begin(), userCodes_5ddf.end());
	if( isMatchNotLastMember_5dd3)
		return;
	Packets_t argDeclBases_5e1f;
	Packets_t structs_5e22;
	Packets_t localVars_5e25;
	Packets_t userCodes_5e28;
	Otherwise_5e1c otherwise_5e1c;
	bool isMatchOtherwise_5e1c= otherwise_5e1c( argdecls_5d9f, structs_5da1, membs_5da3, conditions_5da5, argDeclBases_5e1f, structs_5e22, localVars_5e25, userCodes_5e28);
	_argdecl_5db3->insert( _argdecl_5db3->end(), argDeclBases_5e1f.begin(), argDeclBases_5e1f.end());
	_struct_5db4->insert( _struct_5db4->end(), structs_5e22.begin(), structs_5e22.end());
	_memb_5db5->insert( _memb_5db5->end(), localVars_5e25.begin(), localVars_5e25.end());
	_condition_5db6->insert( _condition_5db6->end(), userCodes_5e28.begin(), userCodes_5e28.end());
	if( isMatchOtherwise_5e1c)
		return;
}

bool TestMemberPos_5d9e::isInputUnique( const Udm::Object& argdecl_5db9, const Udm::Object& struct_5dc0, const Udm::Object& memb_5dc7, const Udm::Object& condition_5dce)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itargdecl_5dbb= _argdecl_5db7.begin(), itstruct_5dc2= _struct_5dbe.begin(), itmemb_5dc9= _memb_5dc5.begin(), itcondition_5dd0= _condition_5dcc.begin(); itargdecl_5dbb!= _argdecl_5db7.end(), itstruct_5dc2!= _struct_5dbe.end(), itmemb_5dc9!= _memb_5dc5.end(), itcondition_5dd0!= _condition_5dcc.end(); ++itargdecl_5dbb, ++itstruct_5dc2, ++itmemb_5dc9, ++itcondition_5dd0)
	{
		if( ( *itargdecl_5dbb== argdecl_5db9)&& ( *itstruct_5dc2== struct_5dc0)&& ( *itmemb_5dc9== memb_5dc7)&& ( *itcondition_5dd0== condition_5dce))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argdecl_5db7.push_back( argdecl_5db9);
		_struct_5dbe.push_back( struct_5dc0);
		_memb_5dc5.push_back( memb_5dc7);
		_condition_5dcc.push_back( condition_5dce);
	}
	return isUnique;
}

bool NotLastMember_5dd3::operator()( const Packets_t& argDeclBases_5dd4, const Packets_t& structs_5dd7, const Packets_t& localVars_5dda, const Packets_t& userCodes_5ddd, Packets_t& argDeclBases_5dd6, Packets_t& structs_5dd9, Packets_t& localVars_5ddc, Packets_t& userCodes_5ddf)
{
#ifdef PRINT_INFO
	printLog( "NotLastMember_5dd3" );
#endif
	_argDeclBase_5de0= &argDeclBases_5dd6;
	_struct_5de1= &structs_5dd9;
	_localVar_5de2= &localVars_5ddc;
	_userCode_5de3= &userCodes_5ddf;
	processInputPackets( argDeclBases_5dd4, structs_5dd7, localVars_5dda, userCodes_5ddd);
	if( false== _matches.empty())
		return true;
	return false;
}

bool NotLastMember_5dd3::isInputUnique( const Udm::Object& argDeclBase_5de8, const Udm::Object& struct_5df1, const Udm::Object& localVar_5dfa, const Udm::Object& userCode_5e03)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_5dea= _argDeclBase_5de4.begin(), itStruct_5df3= _struct_5ded.begin(), itLocalVar_5dfc= _localVar_5df6.begin(), itUserCode_5e05= _userCode_5dff.begin(); itArgDeclBase_5dea!= _argDeclBase_5de4.end(), itStruct_5df3!= _struct_5ded.end(), itLocalVar_5dfc!= _localVar_5df6.end(), itUserCode_5e05!= _userCode_5dff.end(); ++itArgDeclBase_5dea, ++itStruct_5df3, ++itLocalVar_5dfc, ++itUserCode_5e05)
	{
		if( ( *itArgDeclBase_5dea== argDeclBase_5de8)&& ( *itStruct_5df3== struct_5df1)&& ( *itLocalVar_5dfc== localVar_5dfa)&& ( *itUserCode_5e05== userCode_5e03))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_5de4.push_back( argDeclBase_5de8);
		_struct_5ded.push_back( struct_5df1);
		_localVar_5df6.push_back( localVar_5dfa);
		_userCode_5dff.push_back( userCode_5e03);
	}
	return isUnique;
}

bool NotLastMember_5dd3::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool NotLastMember_5dd3::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, SFC::LocalVar& LocalVar, SFC::Struct& Struct, SFC::UserCode& UserCode)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< __int64 >( LocalVar.statementIndex() ) != static_cast< __int64 >( Struct.statementIndex() ) - 1;;
	return Gz_guard;
}

void NotLastMember_5dd3::processInputPackets( const Packets_t& argDeclBases_5dd4, const Packets_t& structs_5dd7, const Packets_t& localVars_5dda, const Packets_t& userCodes_5ddd)
{
	for( Packets_t::const_iterator itArgDeclBase_5de5= argDeclBases_5dd4.begin(), itStruct_5dee= structs_5dd7.begin(), itLocalVar_5df7= localVars_5dda.begin(), itUserCode_5e00= userCodes_5ddd.begin(); itArgDeclBase_5de5!= argDeclBases_5dd4.end(), itStruct_5dee!= structs_5dd7.end(), itLocalVar_5df7!= localVars_5dda.end(), itUserCode_5e00!= userCodes_5ddd.end(); ++itArgDeclBase_5de5, ++itStruct_5dee, ++itLocalVar_5df7, ++itUserCode_5e00)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_5de5, *itStruct_5dee, *itLocalVar_5df7, *itUserCode_5e00);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_5de5, *itStruct_5dee, *itLocalVar_5df7, *itUserCode_5e00);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_5e0c, currMatch.struct_5e0d, currMatch.localVar_5e0e, currMatch.userCode_5e0f);
	}
}

bool NotLastMember_5dd3::patternMatcher( const Udm::Object& argDeclBase_5de6, const Udm::Object& struct_5def, const Udm::Object& localVar_5df8, const Udm::Object& userCode_5e01)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_5de6.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_5deb= SFC::ArgDeclBase::Cast( argDeclBase_5de6);
		if( false== Uml::IsDerivedFrom( struct_5def.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_5df4= SFC::Struct::Cast( struct_5def);
		if( false== Uml::IsDerivedFrom( localVar_5df8.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_5dfd= SFC::LocalVar::Cast( localVar_5df8);
		if( false== Uml::IsDerivedFrom( userCode_5e01.type(), SFC::UserCode::meta))
			continue;
		SFC::UserCode userCode_5e06= SFC::UserCode::Cast( userCode_5e01);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5e0b;
		if( !isValidBound(boundObjs_5e0b, argDeclBase_5deb, true))
			continue;
		currMatch.argDeclBase_5e0c= argDeclBase_5deb;
		if( !isValidBound(boundObjs_5e0b, struct_5df4, true))
			continue;
		currMatch.struct_5e0d= struct_5df4;
		if( !isValidBound(boundObjs_5e0b, localVar_5dfd, true))
			continue;
		currMatch.localVar_5e0e= localVar_5dfd;
		if( !isValidBound(boundObjs_5e0b, userCode_5e06, true))
			continue;
		currMatch.userCode_5e0f= userCode_5e06;
		bool Gz_guard= isGuardTrue( currMatch.argDeclBase_5e0c, currMatch.localVar_5e0e, currMatch.struct_5e0d, currMatch.userCode_5e0f);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void NotLastMember_5dd3::outputAppender( const SFC::ArgDeclBase& argDeclBase_5e14, const SFC::Struct& struct_5e16, const SFC::LocalVar& localVar_5e18, const SFC::UserCode& userCode_5e1a)
{
	_argDeclBase_5de0->push_back( argDeclBase_5e14);
	_struct_5de1->push_back( struct_5e16);
	_localVar_5de2->push_back( localVar_5e18);
	_userCode_5de3->push_back( userCode_5e1a);
}

bool Otherwise_5e1c::operator()( const Packets_t& argDeclBases_5e1d, const Packets_t& structs_5e20, const Packets_t& localVars_5e23, const Packets_t& userCodes_5e26, Packets_t& argDeclBases_5e1f, Packets_t& structs_5e22, Packets_t& localVars_5e25, Packets_t& userCodes_5e28)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_5e1c" );
#endif
	_argDeclBase_5e29= &argDeclBases_5e1f;
	_struct_5e2a= &structs_5e22;
	_localVar_5e2b= &localVars_5e25;
	_userCode_5e2c= &userCodes_5e28;
	processInputPackets( argDeclBases_5e1d, structs_5e20, localVars_5e23, userCodes_5e26);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_5e1c::isInputUnique( const Udm::Object& argDeclBase_5e31, const Udm::Object& struct_5e3a, const Udm::Object& localVar_5e43, const Udm::Object& userCode_5e4c)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_5e33= _argDeclBase_5e2d.begin(), itStruct_5e3c= _struct_5e36.begin(), itLocalVar_5e45= _localVar_5e3f.begin(), itUserCode_5e4e= _userCode_5e48.begin(); itArgDeclBase_5e33!= _argDeclBase_5e2d.end(), itStruct_5e3c!= _struct_5e36.end(), itLocalVar_5e45!= _localVar_5e3f.end(), itUserCode_5e4e!= _userCode_5e48.end(); ++itArgDeclBase_5e33, ++itStruct_5e3c, ++itLocalVar_5e45, ++itUserCode_5e4e)
	{
		if( ( *itArgDeclBase_5e33== argDeclBase_5e31)&& ( *itStruct_5e3c== struct_5e3a)&& ( *itLocalVar_5e45== localVar_5e43)&& ( *itUserCode_5e4e== userCode_5e4c))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_5e2d.push_back( argDeclBase_5e31);
		_struct_5e36.push_back( struct_5e3a);
		_localVar_5e3f.push_back( localVar_5e43);
		_userCode_5e48.push_back( userCode_5e4c);
	}
	return isUnique;
}

bool Otherwise_5e1c::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

bool Otherwise_5e1c::isGuardTrue( SFC::ArgDeclBase& ArgDeclBase, SFC::LocalVar& LocalVar, SFC::Struct& Struct, SFC::UserCode& UserCode)
{
	bool Gz_guard= false;
	Gz_guard = static_cast< __int64 >( LocalVar.statementIndex() ) != static_cast< __int64 >( Struct.statementIndex() ) - 1;;
	return Gz_guard;
}

void Otherwise_5e1c::processInputPackets( const Packets_t& argDeclBases_5e1d, const Packets_t& structs_5e20, const Packets_t& localVars_5e23, const Packets_t& userCodes_5e26)
{
	for( Packets_t::const_iterator itArgDeclBase_5e2e= argDeclBases_5e1d.begin(), itStruct_5e37= structs_5e20.begin(), itLocalVar_5e40= localVars_5e23.begin(), itUserCode_5e49= userCodes_5e26.begin(); itArgDeclBase_5e2e!= argDeclBases_5e1d.end(), itStruct_5e37!= structs_5e20.end(), itLocalVar_5e40!= localVars_5e23.end(), itUserCode_5e49!= userCodes_5e26.end(); ++itArgDeclBase_5e2e, ++itStruct_5e37, ++itLocalVar_5e40, ++itUserCode_5e49)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_5e2e, *itStruct_5e37, *itLocalVar_5e40, *itUserCode_5e49);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_5e2e, *itStruct_5e37, *itLocalVar_5e40, *itUserCode_5e49);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argDeclBase_5e55, currMatch.struct_5e56, currMatch.localVar_5e57, currMatch.userCode_5e58);
	}
}

bool Otherwise_5e1c::patternMatcher( const Udm::Object& argDeclBase_5e2f, const Udm::Object& struct_5e38, const Udm::Object& localVar_5e41, const Udm::Object& userCode_5e4a)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_5e2f.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_5e34= SFC::ArgDeclBase::Cast( argDeclBase_5e2f);
		if( false== Uml::IsDerivedFrom( struct_5e38.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_5e3d= SFC::Struct::Cast( struct_5e38);
		if( false== Uml::IsDerivedFrom( localVar_5e41.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_5e46= SFC::LocalVar::Cast( localVar_5e41);
		if( false== Uml::IsDerivedFrom( userCode_5e4a.type(), SFC::UserCode::meta))
			continue;
		SFC::UserCode userCode_5e4f= SFC::UserCode::Cast( userCode_5e4a);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5e54;
		if( !isValidBound(boundObjs_5e54, argDeclBase_5e34, true))
			continue;
		currMatch.argDeclBase_5e55= argDeclBase_5e34;
		if( !isValidBound(boundObjs_5e54, struct_5e3d, true))
			continue;
		currMatch.struct_5e56= struct_5e3d;
		if( !isValidBound(boundObjs_5e54, localVar_5e46, true))
			continue;
		currMatch.localVar_5e57= localVar_5e46;
		if( !isValidBound(boundObjs_5e54, userCode_5e4f, true))
			continue;
		currMatch.userCode_5e58= userCode_5e4f;
		bool Gz_guard= isGuardTrue( currMatch.argDeclBase_5e55, currMatch.localVar_5e57, currMatch.struct_5e56, currMatch.userCode_5e58);
		if( true== Gz_guard)
			_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_5e1c::outputAppender( const SFC::ArgDeclBase& argDeclBase_5e5d, const SFC::Struct& struct_5e5f, const SFC::LocalVar& localVar_5e61, const SFC::UserCode& userCode_5e63)
{
	_argDeclBase_5e29->push_back( argDeclBase_5e5d);
	_struct_5e2a->push_back( struct_5e5f);
	_localVar_5e2b->push_back( localVar_5e61);
	_userCode_5e2c->push_back( userCode_5e63);
}

void CreateNextBinaryExprs_5e65::operator()( const Packets_t& argDeclBases_5e66, const Packets_t& localVars_5e68, const Packets_t& binaryExprss_5e6a)
{
#ifdef PRINT_INFO
	printLog( "CreateNextBinaryExprs_5e65" );
#endif
	RTTGenerator::Instance()->generateRule(4864, "CreateNextBinaryExprs");
	processInputPackets( argDeclBases_5e66, localVars_5e68, binaryExprss_5e6a);
}

bool CreateNextBinaryExprs_5e65::isInputUnique( const Udm::Object& argDeclBase_5e70, const Udm::Object& localVar_5e79, const Udm::Object& binaryExprs_5e82)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_5e72= _argDeclBase_5e6c.begin(), itLocalVar_5e7b= _localVar_5e75.begin(), itBinaryExprs_5e84= _binaryExprs_5e7e.begin(); itArgDeclBase_5e72!= _argDeclBase_5e6c.end(), itLocalVar_5e7b!= _localVar_5e75.end(), itBinaryExprs_5e84!= _binaryExprs_5e7e.end(); ++itArgDeclBase_5e72, ++itLocalVar_5e7b, ++itBinaryExprs_5e84)
	{
		if( ( *itArgDeclBase_5e72== argDeclBase_5e70)&& ( *itLocalVar_5e7b== localVar_5e79)&& ( *itBinaryExprs_5e84== binaryExprs_5e82))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_5e6c.push_back( argDeclBase_5e70);
		_localVar_5e75.push_back( localVar_5e79);
		_binaryExprs_5e7e.push_back( binaryExprs_5e82);
	}
	return isUnique;
}

bool CreateNextBinaryExprs_5e65::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateNextBinaryExprs_5e65::processInputPackets( const Packets_t& argDeclBases_5e66, const Packets_t& localVars_5e68, const Packets_t& binaryExprss_5e6a)
{
	for( Packets_t::const_iterator itArgDeclBase_5e6d= argDeclBases_5e66.begin(), itLocalVar_5e76= localVars_5e68.begin(), itBinaryExprs_5e7f= binaryExprss_5e6a.begin(); itArgDeclBase_5e6d!= argDeclBases_5e66.end(), itLocalVar_5e76!= localVars_5e68.end(), itBinaryExprs_5e7f!= binaryExprss_5e6a.end(); ++itArgDeclBase_5e6d, ++itLocalVar_5e76, ++itBinaryExprs_5e7f)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_5e6d, *itLocalVar_5e76, *itBinaryExprs_5e7f);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_5e6d, *itLocalVar_5e76, *itBinaryExprs_5e7f);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateNextBinaryExprs_5e65::patternMatcher( const Udm::Object& argDeclBase_5e6e, const Udm::Object& localVar_5e77, const Udm::Object& binaryExprs_5e80)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_5e6e.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_5e73= SFC::ArgDeclBase::Cast( argDeclBase_5e6e);
		if( false== Uml::IsDerivedFrom( localVar_5e77.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_5e7c= SFC::LocalVar::Cast( localVar_5e77);
		if( false== Uml::IsDerivedFrom( binaryExprs_5e80.type(), SFC::BinaryExprs::meta))
			continue;
		SFC::BinaryExprs binaryExprs_5e85= SFC::BinaryExprs::Cast( binaryExprs_5e80);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5e8a;
		if( !isValidBound(boundObjs_5e8a, argDeclBase_5e73, true))
			continue;
		currMatch.argDeclBase_5e8b= argDeclBase_5e73;
		if( !isValidBound(boundObjs_5e8a, localVar_5e7c, true))
			continue;
		currMatch.localVar_5e8c= localVar_5e7c;
		if( !isValidBound(boundObjs_5e8a, binaryExprs_5e85, true))
			continue;
		currMatch.binaryExprs_5e8d= binaryExprs_5e85;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateNextBinaryExprs_5e65::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newOr_5e8e= SFC::BinaryExprs::Create( currMatch.binaryExprs_5e8d, SFC::BinaryExprs::meta_rightexpr);
		SFC::BinaryExprs newDot_5e8f= SFC::BinaryExprs::Create( newOr_5e8e, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_5e90= SFC::ArgDeclRef::Create( newDot_5e8f, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef1_5e91= SFC::ArgDeclRef::Create( newDot_5e8f, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_5e8b;
		SFC::ArgDeclRef& ArgDeclRef1= newArgDeclRef1_5e91;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_5e90;
		SFC::BinaryExprs& BinaryExprs= currMatch.binaryExprs_5e8d;
		SFC::BinaryExprs& Dot= newDot_5e8f;
		SFC::LocalVar& LocalVar= currMatch.localVar_5e8c;
		SFC::BinaryExprs& Or= newOr_5e8e;
		{
Or.op() = "||";
};
		{
Dot.op() = ".";
};
		newArgDeclRef2_5e90.argdecl()= currMatch.localVar_5e8c;
		newArgDeclRef1_5e91.argdecl()= currMatch.argDeclBase_5e8b;
	}
}

void CreateLastBinaryExprs_5e92::operator()( const Packets_t& argDeclBases_5e93, const Packets_t& localVars_5e95, const Packets_t& binaryExprss_5e97)
{
#ifdef PRINT_INFO
	printLog( "CreateLastBinaryExprs_5e92" );
#endif
	RTTGenerator::Instance()->generateRule(4880, "CreateLastBinaryExprs");
	processInputPackets( argDeclBases_5e93, localVars_5e95, binaryExprss_5e97);
}

bool CreateLastBinaryExprs_5e92::isInputUnique( const Udm::Object& argDeclBase_5e9d, const Udm::Object& localVar_5ea6, const Udm::Object& binaryExprs_5eaf)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_5e9f= _argDeclBase_5e99.begin(), itLocalVar_5ea8= _localVar_5ea2.begin(), itBinaryExprs_5eb1= _binaryExprs_5eab.begin(); itArgDeclBase_5e9f!= _argDeclBase_5e99.end(), itLocalVar_5ea8!= _localVar_5ea2.end(), itBinaryExprs_5eb1!= _binaryExprs_5eab.end(); ++itArgDeclBase_5e9f, ++itLocalVar_5ea8, ++itBinaryExprs_5eb1)
	{
		if( ( *itArgDeclBase_5e9f== argDeclBase_5e9d)&& ( *itLocalVar_5ea8== localVar_5ea6)&& ( *itBinaryExprs_5eb1== binaryExprs_5eaf))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_5e99.push_back( argDeclBase_5e9d);
		_localVar_5ea2.push_back( localVar_5ea6);
		_binaryExprs_5eab.push_back( binaryExprs_5eaf);
	}
	return isUnique;
}

bool CreateLastBinaryExprs_5e92::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void CreateLastBinaryExprs_5e92::processInputPackets( const Packets_t& argDeclBases_5e93, const Packets_t& localVars_5e95, const Packets_t& binaryExprss_5e97)
{
	for( Packets_t::const_iterator itArgDeclBase_5e9a= argDeclBases_5e93.begin(), itLocalVar_5ea3= localVars_5e95.begin(), itBinaryExprs_5eac= binaryExprss_5e97.begin(); itArgDeclBase_5e9a!= argDeclBases_5e93.end(), itLocalVar_5ea3!= localVars_5e95.end(), itBinaryExprs_5eac!= binaryExprss_5e97.end(); ++itArgDeclBase_5e9a, ++itLocalVar_5ea3, ++itBinaryExprs_5eac)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_5e9a, *itLocalVar_5ea3, *itBinaryExprs_5eac);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_5e9a, *itLocalVar_5ea3, *itBinaryExprs_5eac);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool CreateLastBinaryExprs_5e92::patternMatcher( const Udm::Object& argDeclBase_5e9b, const Udm::Object& localVar_5ea4, const Udm::Object& binaryExprs_5ead)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_5e9b.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_5ea0= SFC::ArgDeclBase::Cast( argDeclBase_5e9b);
		if( false== Uml::IsDerivedFrom( localVar_5ea4.type(), SFC::LocalVar::meta))
			continue;
		SFC::LocalVar localVar_5ea9= SFC::LocalVar::Cast( localVar_5ea4);
		if( false== Uml::IsDerivedFrom( binaryExprs_5ead.type(), SFC::BinaryExprs::meta))
			continue;
		SFC::BinaryExprs binaryExprs_5eb2= SFC::BinaryExprs::Cast( binaryExprs_5ead);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5eb7;
		if( !isValidBound(boundObjs_5eb7, argDeclBase_5ea0, true))
			continue;
		currMatch.argDeclBase_5eb8= argDeclBase_5ea0;
		if( !isValidBound(boundObjs_5eb7, localVar_5ea9, true))
			continue;
		currMatch.localVar_5eb9= localVar_5ea9;
		if( !isValidBound(boundObjs_5eb7, binaryExprs_5eb2, true))
			continue;
		currMatch.binaryExprs_5eba= binaryExprs_5eb2;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void CreateLastBinaryExprs_5e92::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::BinaryExprs newDot_5ebb= SFC::BinaryExprs::Create( currMatch.binaryExprs_5eba, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclRef newArgDeclRef1_5ebc= SFC::ArgDeclRef::Create( newDot_5ebb, SFC::BinaryExprs::meta_leftexpr);
		SFC::ArgDeclRef newArgDeclRef2_5ebd= SFC::ArgDeclRef::Create( newDot_5ebb, SFC::BinaryExprs::meta_rightexpr);
		SFC::ArgDeclBase& ArgDeclBase= currMatch.argDeclBase_5eb8;
		SFC::ArgDeclRef& ArgDeclRef1= newArgDeclRef1_5ebc;
		SFC::ArgDeclRef& ArgDeclRef2= newArgDeclRef2_5ebd;
		SFC::BinaryExprs& BinaryExprs= currMatch.binaryExprs_5eba;
		SFC::BinaryExprs& Dot= newDot_5ebb;
		SFC::LocalVar& LocalVar= currMatch.localVar_5eb9;
		{
Dot.op() = ".";
};
		newArgDeclRef1_5ebc.argdecl()= currMatch.argDeclBase_5eb8;
		newArgDeclRef2_5ebd.argdecl()= currMatch.localVar_5eb9;
	}
}

void StructTest_5edb::operator()( const Packets_t& argdecls_5edc, const Packets_t& dts_5ede, const Packets_t& conditions_5ee0, Packets_t& argdecls_5ee2, Packets_t& structs_5ee3, Packets_t& conditions_5ee4, Packets_t& argdecls_5ee5, Packets_t& dts_5ee6, Packets_t& conditions_5ee7)
{
#ifdef PRINT_INFO
	printLog( "StructTest_5edb" );
#endif
	_argdecl_5ee8= &argdecls_5ee2;
	_struct_5ee9= &structs_5ee3;
	_condition_5eea= &conditions_5ee4;
	_argdecl_5eeb= &argdecls_5ee5;
	_dt_5eec= &dts_5ee6;
	_condition_5eed= &conditions_5ee7;
	for( Packets_t::const_iterator itargdecl_5eef= argdecls_5edc.begin(), itdt_5ef6= dts_5ede.begin(), itcondition_5efd= conditions_5ee0.begin(); itargdecl_5eef!= argdecls_5edc.end(), itdt_5ef6!= dts_5ede.end(), itcondition_5efd!= conditions_5ee0.end(); ++itargdecl_5eef, ++itdt_5ef6, ++itcondition_5efd)
	{
		bool isUnique= isInputUnique( *itargdecl_5eef, *itdt_5ef6, *itcondition_5efd);
		if( !isUnique)
			continue;
		Packets_t oneargdecl_5ef3( 1, *itargdecl_5eef);
		Packets_t onedt_5efa( 1, *itdt_5ef6);
		Packets_t onecondition_5f01( 1, *itcondition_5efd);
		executeOne( oneargdecl_5ef3, onedt_5efa, onecondition_5f01);
	}
}

void StructTest_5edb::executeOne( const Packets_t& argdecls_5edc, const Packets_t& dts_5ede, const Packets_t& conditions_5ee0)
{
	Packets_t argVarBases_5f06;
	Packets_t structs_5f09;
	Packets_t conditions_5f0c;
	IsStruct_5f03 isStruct_5f03;
	bool isMatchIsStruct_5f03= isStruct_5f03( argdecls_5edc, dts_5ede, conditions_5ee0, argVarBases_5f06, structs_5f09, conditions_5f0c);
	_argdecl_5ee8->insert( _argdecl_5ee8->end(), argVarBases_5f06.begin(), argVarBases_5f06.end());
	_struct_5ee9->insert( _struct_5ee9->end(), structs_5f09.begin(), structs_5f09.end());
	_condition_5eea->insert( _condition_5eea->end(), conditions_5f0c.begin(), conditions_5f0c.end());
	if( isMatchIsStruct_5f03)
		return;
	Packets_t argVarBases_5f3b;
	Packets_t dTs_5f3e;
	Packets_t conditions_5f41;
	Otherwise_5f38 otherwise_5f38;
	bool isMatchOtherwise_5f38= otherwise_5f38( argdecls_5edc, dts_5ede, conditions_5ee0, argVarBases_5f3b, dTs_5f3e, conditions_5f41);
	_argdecl_5eeb->insert( _argdecl_5eeb->end(), argVarBases_5f3b.begin(), argVarBases_5f3b.end());
	_dt_5eec->insert( _dt_5eec->end(), dTs_5f3e.begin(), dTs_5f3e.end());
	_condition_5eed->insert( _condition_5eed->end(), conditions_5f41.begin(), conditions_5f41.end());
	if( isMatchOtherwise_5f38)
		return;
}

bool StructTest_5edb::isInputUnique( const Udm::Object& argdecl_5ef0, const Udm::Object& dt_5ef7, const Udm::Object& condition_5efe)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itargdecl_5ef2= _argdecl_5eee.begin(), itdt_5ef9= _dt_5ef5.begin(), itcondition_5f00= _condition_5efc.begin(); itargdecl_5ef2!= _argdecl_5eee.end(), itdt_5ef9!= _dt_5ef5.end(), itcondition_5f00!= _condition_5efc.end(); ++itargdecl_5ef2, ++itdt_5ef9, ++itcondition_5f00)
	{
		if( ( *itargdecl_5ef2== argdecl_5ef0)&& ( *itdt_5ef9== dt_5ef7)&& ( *itcondition_5f00== condition_5efe))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argdecl_5eee.push_back( argdecl_5ef0);
		_dt_5ef5.push_back( dt_5ef7);
		_condition_5efc.push_back( condition_5efe);
	}
	return isUnique;
}

bool IsStruct_5f03::operator()( const Packets_t& argVarBases_5f04, const Packets_t& structs_5f07, const Packets_t& conditions_5f0a, Packets_t& argVarBases_5f06, Packets_t& structs_5f09, Packets_t& conditions_5f0c)
{
#ifdef PRINT_INFO
	printLog( "IsStruct_5f03" );
#endif
	_argVarBase_5f0d= &argVarBases_5f06;
	_struct_5f0e= &structs_5f09;
	_condition_5f0f= &conditions_5f0c;
	processInputPackets( argVarBases_5f04, structs_5f07, conditions_5f0a);
	if( false== _matches.empty())
		return true;
	return false;
}

bool IsStruct_5f03::isInputUnique( const Udm::Object& argVarBase_5f14, const Udm::Object& struct_5f1d, const Udm::Object& condition_5f26)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgVarBase_5f16= _argVarBase_5f10.begin(), itStruct_5f1f= _struct_5f19.begin(), itCondition_5f28= _condition_5f22.begin(); itArgVarBase_5f16!= _argVarBase_5f10.end(), itStruct_5f1f!= _struct_5f19.end(), itCondition_5f28!= _condition_5f22.end(); ++itArgVarBase_5f16, ++itStruct_5f1f, ++itCondition_5f28)
	{
		if( ( *itArgVarBase_5f16== argVarBase_5f14)&& ( *itStruct_5f1f== struct_5f1d)&& ( *itCondition_5f28== condition_5f26))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argVarBase_5f10.push_back( argVarBase_5f14);
		_struct_5f19.push_back( struct_5f1d);
		_condition_5f22.push_back( condition_5f26);
	}
	return isUnique;
}

bool IsStruct_5f03::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void IsStruct_5f03::processInputPackets( const Packets_t& argVarBases_5f04, const Packets_t& structs_5f07, const Packets_t& conditions_5f0a)
{
	for( Packets_t::const_iterator itArgVarBase_5f11= argVarBases_5f04.begin(), itStruct_5f1a= structs_5f07.begin(), itCondition_5f23= conditions_5f0a.begin(); itArgVarBase_5f11!= argVarBases_5f04.end(), itStruct_5f1a!= structs_5f07.end(), itCondition_5f23!= conditions_5f0a.end(); ++itArgVarBase_5f11, ++itStruct_5f1a, ++itCondition_5f23)
	{
		bool isUnique= isInputUnique( *itArgVarBase_5f11, *itStruct_5f1a, *itCondition_5f23);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgVarBase_5f11, *itStruct_5f1a, *itCondition_5f23);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argVarBase_5f2f, currMatch.struct_5f30, currMatch.condition_5f31);
	}
}

bool IsStruct_5f03::patternMatcher( const Udm::Object& argVarBase_5f12, const Udm::Object& struct_5f1b, const Udm::Object& condition_5f24)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argVarBase_5f12.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argVarBase_5f17= SFC::ArgDeclBase::Cast( argVarBase_5f12);
		if( false== Uml::IsDerivedFrom( struct_5f1b.type(), SFC::Struct::meta))
			continue;
		SFC::Struct struct_5f20= SFC::Struct::Cast( struct_5f1b);
		if( false== Uml::IsDerivedFrom( condition_5f24.type(), SFC::UserCode::meta))
			continue;
		SFC::UserCode condition_5f29= SFC::UserCode::Cast( condition_5f24);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5f2e;
		if( !isValidBound(boundObjs_5f2e, argVarBase_5f17, true))
			continue;
		currMatch.argVarBase_5f2f= argVarBase_5f17;
		if( !isValidBound(boundObjs_5f2e, struct_5f20, true))
			continue;
		currMatch.struct_5f30= struct_5f20;
		if( !isValidBound(boundObjs_5f2e, condition_5f29, true))
			continue;
		currMatch.condition_5f31= condition_5f29;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void IsStruct_5f03::outputAppender( const SFC::ArgDeclBase& argVarBase_5f32, const SFC::Struct& struct_5f34, const SFC::UserCode& condition_5f36)
{
	_argVarBase_5f0d->push_back( argVarBase_5f32);
	_struct_5f0e->push_back( struct_5f34);
	_condition_5f0f->push_back( condition_5f36);
}

bool Otherwise_5f38::operator()( const Packets_t& argVarBases_5f39, const Packets_t& dTs_5f3c, const Packets_t& conditions_5f3f, Packets_t& argVarBases_5f3b, Packets_t& dTs_5f3e, Packets_t& conditions_5f41)
{
#ifdef PRINT_INFO
	printLog( "Otherwise_5f38" );
#endif
	_argVarBase_5f42= &argVarBases_5f3b;
	_dT_5f43= &dTs_5f3e;
	_condition_5f44= &conditions_5f41;
	processInputPackets( argVarBases_5f39, dTs_5f3c, conditions_5f3f);
	if( false== _matches.empty())
		return true;
	return false;
}

bool Otherwise_5f38::isInputUnique( const Udm::Object& argVarBase_5f49, const Udm::Object& dT_5f52, const Udm::Object& condition_5f5b)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgVarBase_5f4b= _argVarBase_5f45.begin(), itDT_5f54= _dT_5f4e.begin(), itCondition_5f5d= _condition_5f57.begin(); itArgVarBase_5f4b!= _argVarBase_5f45.end(), itDT_5f54!= _dT_5f4e.end(), itCondition_5f5d!= _condition_5f57.end(); ++itArgVarBase_5f4b, ++itDT_5f54, ++itCondition_5f5d)
	{
		if( ( *itArgVarBase_5f4b== argVarBase_5f49)&& ( *itDT_5f54== dT_5f52)&& ( *itCondition_5f5d== condition_5f5b))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argVarBase_5f45.push_back( argVarBase_5f49);
		_dT_5f4e.push_back( dT_5f52);
		_condition_5f57.push_back( condition_5f5b);
	}
	return isUnique;
}

bool Otherwise_5f38::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void Otherwise_5f38::processInputPackets( const Packets_t& argVarBases_5f39, const Packets_t& dTs_5f3c, const Packets_t& conditions_5f3f)
{
	for( Packets_t::const_iterator itArgVarBase_5f46= argVarBases_5f39.begin(), itDT_5f4f= dTs_5f3c.begin(), itCondition_5f58= conditions_5f3f.begin(); itArgVarBase_5f46!= argVarBases_5f39.end(), itDT_5f4f!= dTs_5f3c.end(), itCondition_5f58!= conditions_5f3f.end(); ++itArgVarBase_5f46, ++itDT_5f4f, ++itCondition_5f58)
	{
		bool isUnique= isInputUnique( *itArgVarBase_5f46, *itDT_5f4f, *itCondition_5f58);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgVarBase_5f46, *itDT_5f4f, *itCondition_5f58);
	}
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		outputAppender( currMatch.argVarBase_5f64, currMatch.dT_5f65, currMatch.condition_5f66);
	}
}

bool Otherwise_5f38::patternMatcher( const Udm::Object& argVarBase_5f47, const Udm::Object& dT_5f50, const Udm::Object& condition_5f59)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argVarBase_5f47.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argVarBase_5f4c= SFC::ArgDeclBase::Cast( argVarBase_5f47);
		if( false== Uml::IsDerivedFrom( dT_5f50.type(), SFC::DT::meta))
			continue;
		SFC::DT dT_5f55= SFC::DT::Cast( dT_5f50);
		if( false== Uml::IsDerivedFrom( condition_5f59.type(), SFC::UserCode::meta))
			continue;
		SFC::UserCode condition_5f5e= SFC::UserCode::Cast( condition_5f59);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5f63;
		if( !isValidBound(boundObjs_5f63, argVarBase_5f4c, true))
			continue;
		currMatch.argVarBase_5f64= argVarBase_5f4c;
		if( !isValidBound(boundObjs_5f63, dT_5f55, true))
			continue;
		currMatch.dT_5f65= dT_5f55;
		if( !isValidBound(boundObjs_5f63, condition_5f5e, true))
			continue;
		currMatch.condition_5f66= condition_5f5e;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void Otherwise_5f38::outputAppender( const SFC::ArgDeclBase& argVarBase_5f67, const SFC::DT& dT_5f69, const SFC::UserCode& condition_5f6b)
{
	_argVarBase_5f42->push_back( argVarBase_5f67);
	_dT_5f43->push_back( dT_5f69);
	_condition_5f44->push_back( condition_5f6b);
}

void ArgDeclIsCondition_5f6d::operator()( const Packets_t& argDeclBases_5f6e, const Packets_t& conditions_5f70)
{
#ifdef PRINT_INFO
	printLog( "ArgDeclIsCondition_5f6d" );
#endif
	RTTGenerator::Instance()->generateRule(4911, "argDeclIsCondition");
	processInputPackets( argDeclBases_5f6e, conditions_5f70);
}

bool ArgDeclIsCondition_5f6d::isInputUnique( const Udm::Object& argDeclBase_5f76, const Udm::Object& condition_5f7f)
{
	bool isUnique= true;
	for( Packets_t::const_iterator itArgDeclBase_5f78= _argDeclBase_5f72.begin(), itCondition_5f81= _condition_5f7b.begin(); itArgDeclBase_5f78!= _argDeclBase_5f72.end(), itCondition_5f81!= _condition_5f7b.end(); ++itArgDeclBase_5f78, ++itCondition_5f81)
	{
		if( ( *itArgDeclBase_5f78== argDeclBase_5f76)&& ( *itCondition_5f81== condition_5f7f))
		{
			isUnique= false;
			break;
		}
	}
	if( isUnique)
	{
		_argDeclBase_5f72.push_back( argDeclBase_5f76);
		_condition_5f7b.push_back( condition_5f7f);
	}
	return isUnique;
}

bool ArgDeclIsCondition_5f6d::isValidBound( set< pair<int, Udm::Object> >& boundObjs, Udm::Object& currObj, bool isInputObj)
{
	if( boundObjs.find(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj)) != boundObjs.end())
		if( !isInputObj)
			return false;
		else
			return true;
	else
		boundObjs.insert(make_pair(currObj.__impl()->__getdn()->uniqueId(), currObj));
	return true;
}

void ArgDeclIsCondition_5f6d::processInputPackets( const Packets_t& argDeclBases_5f6e, const Packets_t& conditions_5f70)
{
	for( Packets_t::const_iterator itArgDeclBase_5f73= argDeclBases_5f6e.begin(), itCondition_5f7c= conditions_5f70.begin(); itArgDeclBase_5f73!= argDeclBases_5f6e.end(), itCondition_5f7c!= conditions_5f70.end(); ++itArgDeclBase_5f73, ++itCondition_5f7c)
	{
		bool isUnique= isInputUnique( *itArgDeclBase_5f73, *itCondition_5f7c);
		if( !isUnique)
			continue;
		bool isMatch= patternMatcher( *itArgDeclBase_5f73, *itCondition_5f7c);
		if( isMatch)
			effector( );
		_matches.clear();
	}
}

bool ArgDeclIsCondition_5f6d::patternMatcher( const Udm::Object& argDeclBase_5f74, const Udm::Object& condition_5f7d)
{
	for( int i= 0; i< 1; ++i)
	{
		if( false== Uml::IsDerivedFrom( argDeclBase_5f74.type(), SFC::ArgDeclBase::meta))
			continue;
		SFC::ArgDeclBase argDeclBase_5f79= SFC::ArgDeclBase::Cast( argDeclBase_5f74);
		if( false== Uml::IsDerivedFrom( condition_5f7d.type(), SFC::UserCode::meta))
			continue;
		SFC::UserCode condition_5f82= SFC::UserCode::Cast( condition_5f7d);
		Match currMatch;
		set< pair<int, Udm::Object> > boundObjs_5f87;
		if( !isValidBound(boundObjs_5f87, argDeclBase_5f79, true))
			continue;
		currMatch.argDeclBase_5f88= argDeclBase_5f79;
		if( !isValidBound(boundObjs_5f87, condition_5f82, true))
			continue;
		currMatch.condition_5f89= condition_5f82;
		_matches.push_back( currMatch);
	}
	return !_matches.empty();
}

void ArgDeclIsCondition_5f6d::effector()
{
	for( std::list< Match>::const_iterator itMatch= _matches.begin(); itMatch!= _matches.end(); ++itMatch)
	{
		Match currMatch= *itMatch;
		SFC::ArgDeclRef newArgDeclRef_5f8a= SFC::ArgDeclRef::Create( currMatch.condition_5f89, SFC::UserCode::meta_codeexpr);
		newArgDeclRef_5f8a.argdecl()= currMatch.argDeclBase_5f88;
	}
}

